@&#MAIN-TITLE@&#
A chaos based image encryption and lossless compression algorithm using hash table and Chinese Remainder Theorem

@&#HIGHLIGHTS@&#
No useful information is leaked out as full encryption is done.A very larger key space of 10195 is achieved.Complex diffusion matrix provides strong sensitivity.A lossless compression ratio of 5:1 is achieved.

@&#KEYPHRASES@&#
Chaos,Chinese Remainder Theorem,Lorenz equations,Hyper chaos,Hash table,

@&#ABSTRACT@&#
A chaos based image encryption and lossless compression algorithm using hash table and Chinese Remainder Theorem is proposed. Initially, the Henon map is used to generate the scrambled blocks of the input image. The scrambled block undergoes a fixed number of iterations based on the plain image using Arnold cat map. Since hyper chaos system has complex dynamical characteristics than chaos, the confused image is further permuted using the index sequence generated by the hyper chaos along with hash table structure. The permuted image is divided into blocks and the diffusion is carried out either by using Lorenz equations or by using another complex matrix generated from the plain image appropriately. Along with diffusion, compression is also carried out by Chinese Remainder Theorem for each block. This encryption algorithm has high key space, good NPCR and UACI values and very less correlation among adjacent pixels. Simulation results show the high effectiveness and security features of the proposed algorithm.

@&#INTRODUCTION@&#
Due to wide usage of internet technology and digital image processing, secure communication of images becomes more important. High redundancy and bulk capacity of image data demands compression along with encryption. Many research papers [1–4] focus only on compression in which the security aspects are not considered. Chaos based image encryption [5–10] becomes famous due to its intrinsic features such as sensitivity to initial conditions, ergodicity and pseudo randomness. It has very good permutation and diffusion properties that are well suited for many crypto systems. These systems encompass confidentiality of the data but the reduction of data is not taken into account. So the need for applying both encryption and compression [11–14] to digital images becomes necessary in recent years.Many research papers have proposed encryption schemes combined with compression. There are two directions in which the combined form of image encryption and compression is performed. In the first direction [15–18], encryption and compression are done at two distinct stages. There is no contact between these two stages. So the opponent aims on breaking the crypto system without considering the compression scheme. In the second direction [19–27], both compression and encryption are combined in a single stage. In some of the research papers, simultaneous encryption and compression [22–26] is done which is a special technique followed along this direction.There are many security analysis methods available which can be used to test a cipher's resistance to attacks. Entropy gives a measure of randomness. Histogram and correlation between adjacent pixels are the measures of resistance to statistical attack. NPCR (Number of Pixel Change Rate) and UACI (Unified Average Changing Intensity) values determine resistance to differential attack. Key space analysis is the measure of resistance to brute force attack. Key sensitivity analysis is the sensitivity of the change in key values. Similarly for a compressed image, compression ratio is calculated between the cipher text length and the plain text length. The encryption speed is also an important measurement describing the time taken to execute the algorithm.In Zhu et al. [22] method, a new simultaneous encryption–compression scheme is proposed using hyper-chaos and Chinese Remainder Theorem (CRT). It yields a correlation coefficient of 0.0058 between adjacent pixels along horizontal direction and a good entropy of 7.997576509. Although a good lossless compression ratio of 4:1 is proposed in this scheme, it can be easily cryptanalyzed due to its simultaneous encryption–compression nature using CRT as discussed in [27]. Referring to Yuen and Wong [19] method, a chaos based joint compression and encryption using DCT and SHA-1 is proposed. It yields high plaintext sensitivity and key sensitivity. Moreover, it has large key space to withstand brute force attack. But there is a compression degradation of 3.26–9.02% as the quality of the image increases.In Wang et al. [15] method, the compressed image is encrypted by chaotic map and arithmetic coding. Here the compression and encryption are done at different stages of operation. So the adversary can break out the cryptosystem without considering the compression. Moreover it has a lower NPCR value such as 32.81 compared to the ideal value and the compression ratio is also very low as 1.3. In Zhou et al. [24] method, the compression and encryption are achieved simultaneously by using partial Hadamard matrix controlled by chaos map. Although a good compression ratio of 4:1 is achieved, the keyspace is as small as 1034.In Xiang et al. [25] method, a compression and selective encryption algorithm based on set partitioning in hierarchical trees (SPIHT) is proposed to attain simultaneous image encryption and compression. Here, only the essential part of the compressed sequence is encrypted. But it suffers from full encryption such that some of the information may be disclosed. Referring to the method suggested by Maniccam and Bourbakis [16], a lossless image compression and encryption using SCAN pattern is proposed. The compression ratio achieved by this scheme is only 1.6353. Moreover the encryption and decryption times are also as high as 54 and 11s respectively.The proposed scheme uses an image encryption and compression technique employing chaotic maps and CRT. The plain image is divided into blocks and these blocks are first scrambled by means of Henon map. The scrambled blocks are further confused using Arnold cat map. The confused image is then permuted using the sequence got from the hyper chaos and hash table structure. During the diffusion stage, the permuted image is divided into blocks and each block is diffused by either the matrix generated from the Lorenz equations or the matrix generated from the plain image prior to compression by CRT. So, the cryptanalysis of the image encryption algorithms based on CRTs may be unsuccessful since simultaneous encryption and compression has not been performed.Moreover, the proposed algorithm can resist various kind of attacks such as brute force attack, statistical attack and differential attack. The keyspace of the proposed algorithm is 10195, which makes the brute force attack infeasible. The NPCR and UACI values are 99.6291 and 33.4092 which are closer to the ideal values. The key features of the proposed scheme are listed as follows:(i) Since full encryption is done, no useful information pertaining to the input image is leaked out. (ii) A very larger key space is achieved such as 10195 to resist various kind of brute force attacks. (iii) Since simultaneous image encryption and compression by CRT is vulnerable to attacks, diffusion is carried out prior to compression which further strengthens the security of the proposed scheme. (iv) A good lossless compression ratio of 5:1 is achieved.Brief review of the chaotic maps used in the proposed algorithm, the concepts of CRT and Hash table data structure are discussed at length in the next section. Section 3 describes the proposed algorithm in detail. Sections 4 and 5 discuss the performance analysis and security analysis of the proposed algorithm respectively.Henon map is a discrete time dynamical system that reveals chaotic behavior. It maps a point (xn, yn) to a new point in a plane. It is described by the following set of equations:(1)xn+1=yn−1+f⋅xn2(2)yn+1=g⋅xnThe map depends on the two parameters, f and g, that can be controlled to examine the chaotic behavior. Normally, it uses 1.4 for f and 0.3 for g. For these values, the Henon map is chaotic in nature.Chaos is a well known phenomenon that exhibits the property like sensitivity to initial conditions which can be better utilized for image encryption. It has one positive Lyapunov exponent which shows the instability in one direction. Whereas, hyper-chaos is a special type of chaos phenomenon in which it has more than one positive Lyapunov exponent. It shows the instability in more than one direction. From the generalized 2D hyper-chaos system, the proposed algorithm uses a simple 2D hyper-chaos system such as the one used in the following equations.(3)Xn+1=axn+byn(4)Yn+1=c+dxn2+eynFor the constants a=−0.95, b=−1.3, c=−0.45, d=2.4, e=1.05 this system exhibits chaotic behavior.The classical Arnold cat map is given by,(5)Xn+1Yn+1=1112XnYnmodMwhere (Xn, Yn) are the coordinates of the original image pixel values and (Xn+1, Yn+1) are the coordinates of the shuffled image pixel values.Hash tables are commonly used data structures that are mainly used for accessing the data efficiently. It is based on three components such as keys, buckets and the hash function. The keys may contain any kind of data, the buckets are mostly an index in an array and are used to store the values associated with the keys. The hash function plays an important role by which the values are associated to each key. An ideal hash function also called as perfect hash function associates each key to a single bucket and provides access to the values corresponding to a particular key in O(1) which is illustrated in Fig. 1. In the figure, a1, a2, …, anare the keys used to associate the values to the bucket by means of the hash function; 0, 1, 2, ..., n are the array of indices of the bucket in which the values are stored. As shown in the figure, each key is associated with a single bucket.But in practical situations, more than one key may be assigned to a single bucket. This situation is called as hash collision and is illustrated in Fig. 2. Here, the key a2 is already placed in the bucket 1 and a3 is demanding the same bucket. There are various strategies to deal with such kind of collision and they fall into two groups namely, open hashing and closed hashing. In open hashing, each bucket points to a data structure where the values associated with the keys are stored.Closed hashing finds another free bucket within the hash table itself and is shown in Fig. 3. Here, the bucket 2 is free and the values associated with a3 are stored in bucket 2. The proposed scheme uses the closed hashing technique i.e., finding the free buckets for handling duplicates in the hyper-chaotic sequences. For instance, consider a 1×16 hyper chaotic sequence as shown in Fig. 4(a). The duplicate index values are identified first (Fig. 4(b)). Then the free slots are identified by placing 1 in the available index values and 0 in the unavailable index values as illustrated in Fig. 4(c). The unavailable index values are then placed in the positions of the duplicate values as shown in Fig. 4(d).Lorenz equations are a set of ordinary differential equations which exhibit chaotic properties for certain initial values and system parameters. Moreover, it is a continuous time system that adds the step size as an additional key parameter. The equations are given below:(6)dxdt=s⋅(x−y)(7)dydt=x⋅(l−z)−y(8)dzdt=x⋅y−b⋅zwhere x, y, z are system states, t is the time, and s, l and b are known as system parameters. For, s=10, l=28 and b=8/3 the system exhibits chaotic behavior. By Euler's method, solution for Eqs. (6)–(8) are obtained, as given in Eqs. (9)–(11).(9)gi+1=gi+h⋅f(ti,gi)(10)h=ti+1−ti(11)f(t,g)=dgdtwhere, g=x, y, z and h is the step size.Consider a set of k positive integers n1, n2, n3, …, nkthat are pairwise relatively prime to each other. LetNi−1be the modular multiplicative inverse of an integer Nimod niso that the following equation is satisfied.NiNi−1≡1(modni),where i=1, 2, …, k.Let a1, a2, a3, …, akbe any given k integers. Then the following system of simultaneous congruential equation(12)x≡a1(modn1),x≡a2(modn2),…,x≡ak(modnk)has a unique solution modulo n=n1n2n3…nkthat is given by Eq. (13),(13)x≡N1N1−1a1+N2N2−1a2+⋯+NkNk−1ak(modn).For any k gray level values a1, a2, a3, …, ak, a gray level value x is substituted so that the Chinese Remainder Theorem works for the compression ratio k. aican be retrieved back by usingai≡xmodniwhere, i=1, 2, …, k so that decompression can be achieved.The details of the proposed algorithm are illustrated in Fig. 5. The input plain image is first divided into non-overlapping squares and loaded one on the top of the other from top left corner to the bottom right corner. Using the matrix generated from the Henon map, the loaded squares are then scrambled. The next step is to restore back the scrambled stack to the original image size. Then the scrambled image undergoes U number of iterations to get the confused Image 1. To attain the final permuted image, the confused Image 1 is further permuted using index order sequences got from the 2D hyper-chaos system along with hash table organization.To get the diffused image, the permuted image is first divided into the blocks of size 2Cr, where Cris the compression ratio. These blocks are further divided into lower and upper half of size Cr. Similarly, the input image is also divided into the blocks of size 2Crand it is further divided into lower and upper half of size Cr. A matrix is generated from the lower half blocks of the input image and it is XORed with the lower half blocks of the permuted image which then gets compressed by CRT. Another matrix is generated from the Lorenz equations and it is XORed with the upper half blocks of the permuted image which then gets compressed by CRT. These blocks are then combined to get the final encrypted and compressed image.Let I(x, y) denote the input plain image of size M×N and P(x, y) denote the corresponding permuted image.Step 1: The input plain image I of size M×N is divided into a total of R non overlapping squares (in order) of size A×B such that A×B×R=M×N. These squares are then loaded one on top of the other from top left corner moving row wise to bottom right corner to get a A×B×R matrix J of height R. For instance, with the 256×256 standard Lena image,M=N=A=B=4thusR=4096=256×2564×4.Step 2: A 1×R matrix SH containing all natural numbers between 1 and R in random order is generated using the Henon map (1) and (2) by specifying the initial values x0, y0 and constants a, b as key parameters.Step 3: The R elements along the height of array J (constructed in step 1) are then filled up into another same sized matrix K using SH such that indices of K along the height are chosen with the element values of SH and K's elements are chosen from elements of J with same indices as SH. For example, if J[1]=156 and SH[1]=1001; then K[1]=156.Step 4: Then the elements of the matrix K along the height are made into a M×N matrix L by reversing the process followed in step 1.Step 5: The Sum Q of all the pixel elements of I is calculated and U=QmodM is obtained. L is shuffled for U number of iterations using classical Arnold's cat map to get the matrix E of size M×N.Step 6: Assign the initial values (X0, Y0) for the 2D hyper-chaos system and then iterate the system for G+M×N times, where G is a constant and remove the first G values in order to avoid any kind of harmful effect imposed by the system. This leads to two different hyper-chaotic sequences X=X1, X2, X3, …, XM×Nand Y=Y1, Y2, Y3, …, YM×N.Step 7: Values of the two hyper chaotic sequences are magnified to an appropriate natural numbernϵℕ, by doing the following operations.(14)Xi=floor(Xi×1010);0≤i<M×N(15)Yi=floor(Yi×1010);0≤i<M×Nand the two modified chaotic sequences X=X1, X2, X3, …, XM×Nand Y=Y1, Y2, Y3, …, YM×Nare obtained.Step 8: Convert the two hyper-chaotic sequences X=X1, X2, X3, …, XM×Nand into the integers ranging from 1 to M×N by using the following equations(16)Xi=mod(Xi,M×N);0≤i<M×N(17)Yi=mod(Yi,M×N);0≤i<M×NStep 9: Store the indices of the duplicate values of the two hyper chaotic sequences X=X1, X2, X3, …, XM×Nand Y=Y1, Y2, Y3, …, YM×Nin the arraysvx=vx1,vx2,vx3,…,vxnn1andvy=vy1,vy2,vy3,…,vynn2.vxj=indicesoftheduplicatesinXi,0≤i<M×Nvyk=indicesoftheduplicatesinYi,0≤j<nn1;0≤k<nn2Step 10: Search the two hyper chaotic sequences X=X1, X2, X3, …, XM×Nand Y=Y1, Y2, Y3, …, YM×Nfor finding the unavailable index values and store them in the arraysux=ux1,ux2,ux3,…,uxnn1,uy=uy1,uy2,uy3,…,uynn2.uxj=unavailableindicesinXi,0≤i<M×Nuyk=unavailableindicesinYi,0≤j<nn1;0≤k<nn2Step 11: Use the hash table structure with closed hashing for replacing the duplicate valuesvxj,vykwith the unavailable index sequences uxj, uykin the two hyper chaotic sequences X=X1, X2, X3, …, XM×Nand Y=Y1, Y2, Y3, …, YM×Nto get the modified index order sequencesKx=Kx1,Kx2,Kx3,…,KxM×NandKy=Ky1,Ky2,Ky3,…,KyM×N.Step 12: Convert the matrix E got from step 5 to a one dimensional vector EE=EE1, EE2, EE3, …, EEM×N. Rearrange the matrix EE by Kxand Kyto get the permuted gray level sequenceE′=E′1,E′2,E′3,…,E′M×NTempj=EEkxj,j=1,2,…,M×NE′j=Tempkyj,j=1,2,…,M×NStep 13: ReshapeE′=E′1,E′2,E′3,…,E′M×Nto a two dimensional gray level matrix to get the completely permuted image P.Fig. 6shows the detailed illustration of the steps in the permutation process with an example. A sample 8×8 matrix with its gray level values is shown in Fig. 6(a). The sample matrix is then split into 2×2 blocks as shown in Fig. 6(b) and the corresponding 16 blocks R1, R2, …, R16 are shown in Fig. 6(c). The stacked 16 blocks, the vector generated from the Henon map and the stacked blocks according to the vector generated from the Henon map are shown in Fig. 6(d)–(f) respectively. Fig. 6(g) and (h) show the confused blocks and the corresponding confused matrix. The confused image using Arnold cat map for U number of iterations is shown in Fig. 6(i) and the completely permuted image using hash table structure is shown Fig. 6(j). Fig. 7(a) is the plain image and Fig. 7(b) and (c) are the confused images at different stages of permutation process.Step 1: Let the compression ratio be Cr. Select Crpositive integersn1,n2,n3,…,nCrsuch that they are pairwise relatively prime to each other. Choose each, ni, i=1, 2, 3, …, Crto be greater than 256.Step 2: Lorenz equations are solved using Euler's method by taking the initial conditions x0, y0, z0, constants s, l, b and the step size h.Step 3: Lorenz equations are iterated for a number of times equal to compression ratio Cr. At every iteration, the values of x, y, and z are magnified to an appropriate natural number,kϵℕ, by performing ki=floor(mi×1015), 0≤i<Cr, where, iϵW, m is an array whose indices range from 0 to Cr−1 and the elements in m are calculated as: m3j=xj,m3j+1=yj, m3j+2=zj, 3j+2<Cr, j≥0, jϵW and F is the highest possible gray level value in the image format.Step 4: pi=kimod(F+1), 0≤i<Cr, iϵW is calculated. By using the p values, a 1×CrmatrixQ=Q1,Q2,Q3,…,QCris generated.Step 5: Convert the permuted 2D matrix P into a one dimensional vector P=P1, P2, P3, …, PM×N.Step 6: Split the permuted vector P into (M×N)/2CrblocksB={B1,B2,B3,…,B(M×N)/2Cr}such thatB1={P1,P2,P3,…,P2Cr},B2={P2Cr+1,P2Cr+2,P2Cr+3,…,P4Cr}, …,B(M×N)/2Cr={P(M×N)−(2Cr−1),P(M×N)−(2Cr−2),P(M×N)−(2Cr−3),…,PM×N}, where M and N are the height and width of the image respectively.Step 7: For each block Bi, where i=1, 2, 3, …, (M×N)/2Crdivide the corresponding block into two equal halves named upper and lower half, Bi={UPi, LPi}. For instance, for the block B1={UP1, LP1}, the upper half isUP1={P1,P2,P3,…,PCr}, and the lower half isLP1={PCr+1,PCr+2,PCr+3,…,P2Cr}.Step 8: The original image I is converted into a 1×MN matrix T. Step 6 and Step 7 are repeated for T to get (M×N)/2CrblocksS={S1,S2,S3,…,S(M×N)/2Cr}and the two halves upperUIiand lower LIifor each block Siwhere i=1, 2, 3, …, (M×N)/2Cr.Step 9: For each block in S, the lower half of the block is used to construct another 1×Crmatrix using (18).(18)LFi=LIi(1)×1+LIi(2)×2+LIi(3)×3+⋯+LIi(Cr−1)×(Cr−1)+LIi(Cr)×Crwhere, i=1, 2, 3, …, (M×N)/2Cr.Step 10: Then, Fi=LFimod(F+1) is obtained.Step 11: Another 1×Crmatrix LRiis generated from LFiusing (19).(19)LRi=LFi(Cr)×1+LFi(Cr−1)×2+LFi(Cr−2)×3+⋯+LFi(Cr−(Cr−1))×Crwhere, i=1, 2, 3, …, (M×N)/2Cr.Step 12: Using LRi, LRi=LRimod(F+1) is calculated.Step 13: For each block Bi, from the permuted vector P, the upper half UPiof the block is Bitwise XORed with Q and compressed using Eqs. (12) and (13) and the resultant upper half is stored in a one dimensional vector Z=Z1, Z2, Z3, …, ZM×Nof size M×N.Step 14: For each block Bi, from the permuted vector P, the lower half LPiof the block is Bitwise XORed with LRiand compressed using Eqs. (12) and (13). The resultant lower half is stored in Z after the upper half obtained from Step 13.Step 15: Step 13 and Step 14 are repeated for all the (M×N)/2Crblocks and stored as contiguous values in Z.Step 16: Reshape the vector Z back to the two dimensional matrix CE(x, y) of size M×N/Crto get the completely encrypted and compressed image.Fig. 8(a) is the plain image and Fig. 8(b) and (c) are the compressed images for the compression ratios 4:1 and 5:1 respectively.The proposed chaos based image encryption and compression algorithm is implemented in MATLAB that runs on a personal computer with 2.4GHz Intel Core2 processor, 4 Giga bytes memory and a hard disk capacity of 500 Giga bytes. In this section, the proposed algorithm is analyzed based on the performance measures such as compression ratio and the running speed.The experimentation is done on various standard 512×512 test images like Lena, Aerial, Airplane, Baboon, Barbara, Couple, Bridge, Clown, Girlface, etc., having 256 gray levels. In order to prove the efficiency of the proposed algorithm, the compression ratio (Cr), which is the ratio between the size of the plain image and the size of the encrypted image is computed using (20).The proposed algorithm is also compared with other algorithms and the results are listed in Table 1. For all the images the compression ratio Cris set as 5 in the proposed algorithm and it yields a good compression performance than the other algorithms listed in Table 1.(20)Cr=sizeofplainimagesizeofcipherimageAnother important factor of measuring the performance of any cryptosystem is the running speed. The running speed of the proposed algorithm is calculated for the Lena image for various sizes such as 256×256, 512×512, 1024×1024 and it is compared with the algorithm in Ref. [22] and the DES algorithm. The values are listed in Table 2and it shows that the proposed algorithm has good speed performance compared to the other algorithms listed in the table. This speed is high enough to be used in any kind of internet applications.The principles of cryptology [28–30] suggest that a good encryption scheme must have resistance to any kind of attack such as statistical, brute force, differential etc. Resistance to statistical attack can be evaluated by histogram and correlation analysis. The key space of any encryption scheme should be extremely large enough to make brute force attack impossible. Entropy analysis is a good measure for the randomness of the encrypted image. NPCR and UACI values determine the resistance to differential attack of the encryption scheme. In this section, the basic security analyses are carried out in order to verify the resistance to various kinds of attacks.Key space is termed as the total number of entirely different keys used in the algorithm. Larger key space is able to resist brute force attacks. The keys used in this algorithm are the initial conditions x0, y0 of the Henon map, the initial conditions X0, Y0 of the hyper-chaos system, U number of iterations of the Arnold cat map, the initial conditions x0, y0, z0 and the step size h of the Lorenz equations and the pairwise relatively prime numbers n1, n2, n3, n4, n5 chosen for CRT.IEEE floating point standard [31] suggests the computational precision for a 64-bit double precision number as 10−15. If all the initial conditions and the parameters used in the proposed algorithm have a precision of 10−15, the keyspace of the proposed algorithm reaches 10195 which is equivalent to 2648. Consider that the fastest computer till date performs 280 computations per second. Then the computational load can be calculated as,2648280×365×24×60×60≅3.17×10163years.This keyspace is very large enough for resisting various kind of brute force attacks.In this method, the sensitivity of the keys used in the proposed encryption scheme is determined for the change-in key values. The procedure is given below:1.For the various maps used in the algorithm a set of initial parameters and constants are chosen.Using these values the cipher image CE is obtained by encrypting the M×N plain image I.Then a small increment such as 10−15 is given to any one key value of the algorithm and the encryption is done on I again, to obtain a new cipher image CE+ (increment).Then a small decrement of same magnitude is given to the key value chosen in the previous step and the encryption is again done on I, to yield yet another (third) cipher image CE− (decrement).Now the sensitivity of the chosen key is determined using (21):The sensitivity of various key values is listed in Table 3. Thus it is evident from Table 3 that there is a strong sensitivity to change in the initial conditions of the equations so that even a slight change in them results in a drastic change in the cipher image. Key sensitivity can also be proved visually by modifying a single bit in the key so that it should produce a completely different cipher image. In order to prove the senstivity of the cipher image to the change-in key values, the cipher image is decrypted by making a minor change in the original key.The following procedure is followed for testing the key sensitivity visually: (i) The encrypted image (Fig. 9(b)) is obtained by encrypting the plain image (Fig. 9(a)) with the key values given Table 3. (ii) The decrypted image of Fig. 9(b) is obtained as shown in Fig. 9(c) by using the above initial key values. (iii) Small changes are made in the initial key values of x0 and y0 and the resulting decrypted images of Fig. 9(b) are given in Fig. 9(d) and (e) respectively.From these figures, it is seen that the original image cannot be recovered unless the correct key values are substituted at the receiver side. This shows that the proposed algorithm is very much sensitive to the keys used in the algorithm so that even a small change in the keys used would not generate the correct plain image.The entropy H(m) is the most outstanding feature of randomness which is determined using (23), as,(23)H(m)=−∑i=0F−1p(mi)×log2(p(mi))where F denotes the total number of possible gray level values, and p(mi) denotes the probability of occurrence of the bit mi. Base 2 logarithm is used so that entropy is expressed in binary bits. For a random display with 256 possible gray level values, F=256. If an encryption is really good, the entropy of the gray scale cipher image should be close to 8. For the proposed scheme, the entropy of the Lena image is 7.997325484 and it is higher than the other schemes listed in Table 4. So, the information leakage from the proposed algorithm is insignificant since the entropy value is close to 8.Shannon [32] has pointed out that any cryptosystem can be broken by means of statistical attack. Thus, resistance to statistical attack is a vital factor in determining strength of a crypto system. The two most commonly used tests and the results are discussed in this section.The correlation of adjacent pixels is carried out using (24)–(26), by picking up 6000 samples of adjacent pixels randomly from both the plain and encrypted image separately.(24)Cor=cov(x,y)D(x)×D(y)where,cov(x,y)=1T∑i=1T(xi−E(x))(yi−E(y))(25)E(t)=1T∑i=1Tti(26)D(t)=1T∑i=1T(t−E(t))2,t=x,yThe pair (xi, yi) represents two adjacent pixel values, E(t) represents the mean and D(t) represents the variance. E(t) and D(t) are calculated for all x values and all y values separately and T(=6000) is the total number of pixel pair samples chosen. Due to strong correlation among adjacent pixels, correlation for plain images is close to 1. A good cipher image must have low correlation along all 3 directions – horizontal, vertical and diagonal, ideally zero. Table 5gives the comparison of correlation values of the proposed scheme with the existing schemes.Histogram shows the graphical representation of distribution of gray level values in an image. The histogram of the Lena image at various stages of the proposed algorithm is illustrated in Fig. 10.Compared to the histogram of the original image (Fig. 10(b)), the histogram of the compressed cipher image (Fig. 10(f)) has a uniform distribution of pixels along various values, which shows that the characteristic distribution of pixels along the entire range of the original image is lost. Thus no useful information can be extracted regarding the pixel values of the original image.A slight change is made to the plain image and the corresponding changes in the cipher image are analyzed to develop a correlation between the plain and cipher image. The change can be as small as changing a single pixel value by unity or a bit change. There are two methods to measure this change.NPCR determines the number of pixels whose values have changed in the cipher image in the same position for the two plain images, the original and the one with one pixel value changed with respect to the original at some random position. The NPCR value for the proposed scheme is calculated using (27) and (28) for various standard test images.(27)NPCR=∑i=1M∑j=1ND(i,j)M×N×100%where,(28)D(i,j)=1,ifC1≠C20,ifC1=C2C1 and C2 are the two cipher images respectively and M and N are the width and the height of the images respectively. The values of NPCR obtained for various images are furnished in Table 6.UACI determines the average change in pixel intensities in corresponding positions in the two cipher images as a percentage with F, the maximum supported pixel value (F=255 in gray scale images). The UACI value for the proposed scheme is calculated using (29) for the standard test images and the values obtained are given in Table 6.(29)UACI=∑i=1N∑j=1M|c1(i,j)−c2(i,j)|255×M×N×100%where C1 and C2 are the two cipher images respectively and MandN are the width and the height of the images respectively.From Table 6, it is seen that the proposed algorithm is resistant to differential attack than the other one listed in the table.The quality of encryption can be determined by deviation in the pixel values between the plain and its corresponding encrypted images. Higher change in the pixel values leads to an effective cipher. Let I and CE represent the plain and the corresponding encrypted images respectively with a size of M×N with F gray level values. HF(I) and HF(CE) represent the total number of occurrences of each possible gray level value F in the plain and encrypted images respectively. The encryption quality is expressed using the formula (30).(30)Encryptionquality=∑F255|HF(I)−HF(E′)|256The encryption quality for the proposed encryption scheme is calculated for various test images and compared with the algorithm in Ref. [22] and the algorithm A5/1 (stream cipher for air communication privacy in GSM) and is listed in Table 7. For all the images, the proposed algorithm yields a higher value than the others.The quality of the image after decryption can be determined by the mean square error (MSE). Smaller value of MSE indicates that the quality of the image is not compromised during decryption process. Let I and I′ be the plain and decrypted images respectively. The MSE values can be determined using (31).(31)MSE=∑m=1M∑n=1N[I(m,n)−I′(m,n)]2M×Nwhere (m, n) denotes the coordinates of the pixel values, M×N is the size of the image under consideration. I(m, n) and I′(m, n) are the plain and decrypted images respectively. For more than thirty images, MSE has been calculated and in all the cases the value is 0. Thus it shows that the proposed image encryption–compression produces lossless image cipher.

@&#CONCLUSIONS@&#
