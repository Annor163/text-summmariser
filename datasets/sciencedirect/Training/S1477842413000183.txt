@&#MAIN-TITLE@&#
Binary trees as a computational framework

@&#HIGHLIGHTS@&#
We present a new set of algorithms for performing arithmetic computations using binary trees.Our arithmetic algorithms have average time and space complexity comparable to traditional operations on bitstrings.Our results are implemented using Haskell instances isomorphic to natural numbers.

@&#KEYPHRASES@&#
Arithmetic computations with binary trees,Gödel System T types,Modeling computational abstractions with functional programming,Computations with balanced parenthesis languages,

@&#ABSTRACT@&#
We present a new set of algorithms for performing arithmetic computations on the set of natural numbers, represented as ordered rooted binary trees. We show formally that these algorithms are correct and discuss their time and space complexity in comparison to traditional arithmetic operations on bitstrings.Our binary tree algorithms follow the structure of a simple type language, similar to that of Gödel's System T.Generic implementations using Haskell's type class mechanism are shared between instances shown to be isomorphic to the set of natural numbers. This representation independence is illustrated by instantiating our computational framework to the language of balanced parenthesis languages.The self-contained source code of the paper is available at http://logic.cse.unt.edu/tarau/research/2012/jtypes.hs.In this paper11This paper is an extended and improved version of [1].we focus on computing with binary trees, seen as a minimalist type language(1)τ=τ→τ|ewhere e represents an empty leaf node.Choosing the simplest possible type language as a foundation for data and code representations is partly motivated by the use of type theory as a constructive alternative to conventional predicate calculus based axiomatizations. This has resulted in powerful proof assistants like Coq [2], based entirely on constructive formalizations of type theory [3]. For instance, one can use the isomorphism between types and natural numbers that provides a total ordering on types, as a generic means to provide termination proofs for type inference algorithms and type-based proof systems.Our main result deals with the set of natural numbers, on which we establish an isomorphism to our binary tree type using a bijection based on a pairing function (Section 2). Given this new representation, we provide algorithms for the successor and predecessor functions (Section 4), including a formal proof of their correctness and a general strategy for proving that the other arithmetic operations built upon them are also sound. Then, using these functions we describe a simple but inefficient specification of arithmetic operations using Gödel's recursor (Section 5). We immediately follow this with a larger, more efficient set of arithmetic operations on binary trees (Section 6). We offer a detailed discussion on the time and space complexity of the algorithms, including a proof that the successor and predecessor functions (used as building blocks for the other operations) have constant average running time. As well, we define a total ordering relation on the binary tree type, isomorphic with that of natural numbers (Section 8). We also show that arithmetic operations can be performed on succinctly represented members of the Catalan family, such as parenthesis languages (Section 9).Finally, we provide a brief survey of related work (Section 10), comments on further work and practical applications (Section 11) as well as our conclusions (Section 12).In this paper we will use a subset of the non-strict functional language Haskell to provide executable specifications of mathematical functions and data types.We mention, for the benefit of the reader unfamiliar with the language, that a notation like f x y stands forf(x,y), [t] represents sequences of type t and a type declaration like f ::s -> t -> u stands for a functionf:s×t→u(modulo Haskell's “currying” operation, given the isomorphism between the function spacess×t→uands→t→u). Our Haskell functions are always represented as sets of recursive equations guided by pattern matching, conditional to constraints (boolean relations following|and before the = symbol). Locally scoped helper functions are defined in Haskell after the where keyword, using the same equational style. The composition of functions f and g is denoted f .g. It is also customary in Haskell to write f=g instead of f x=g x (“point-free” notation). The use of Haskell's “call-by-need” evaluation also allows us to work with infinite sequences, like the[0‥]list notation, corresponding to the set of natural numbersN.In this paper we use Haskell's type class mechanism to provide implementations of primitive operations that can be refined by instances that override these operations with potentially more efficient equivalents.The class PureTypes assumes only the Read/Show superclasses needed for input/output. An instance of this class is required to implement the following primitive operations:class(Readn,Shown)=>PureTypesnwhereempty:: nisEmpty:: n −>Boolarrow:: n−>n−>nfrom,to:: n−>nThe PureTypes type class also provides to its instances generic implementations of the following derived operations:isArrow:: n−>BoolisArrow=not.isEmptyeq :: n −>n−>Booleqxy|isEmptyx&&isEmptyy=Trueeqxy|isEmptyx||isEmptyy=Falseeqxy=eq(fromx)(fromy)&&eq(tox)(toy)While one could also have derived equality from the Haskell Eq class, we have defined it here to clarify our assumptions. The following properties allow testing the properties connecting these operations:pure_type_prop1::(PureTypesn)=>n −>Boolpure_type_prop2::(PureTypesn)=>n −>n −>Boolpure_type_prop1z=isEmptyz||eqz(arrow(fromz)(toz))pure_type_prop2xy=eqx(fromz)&&eqy(toz)wherez=arrowxyIt is convenient at this point, as we target multiple Haskell instances, to provide a polymorphic converter between two different instances of the type class PureTypes. The function view will allow converting between two different PureTypes instances, genericallyview :: (PureTypesa,PureTypesb)=>a−>bviewx|isEmptyx=emptyviewx=arrow(view(fromx))(view(tox))We can build an instance of the type class PureTypes as a rooted ordered binary tree type, implemented by the type data T. We can see these binary trees as a representation of System T types with an empty base type or simply as the free magma of rooted ordered binary trees with one generator, representing empty leavesinfixr5 :−>dataT=E|T :−>Tderiving(Read,Show)instancePureTypesTwhereempty=EisEmptyE=TrueisEmpty_=Falsearrow=(:−>)fromE=undefinedfrom(x :−>_)=xtoE=undefinedto(_ :−>y)=yWe can now specialize the generic instance transformer “view” simply by specifying its target type as Tt :: (PureTypesa)=>a−>Tt=viewThrough a possible Haskell language extension one could think about using arrow and empty as patterns when occurring on the left side of a definition and as data constructors when occurring on the right side of a definition in a way similar to the handling of data constructors :-> and E.We will next define another instance where arrow, from and to are implemented as computations on natural numbers.After adding the type synonymtypeN=Integerwe observe that standard arithmetic provides an alternative instance described in terms of the constructors and destructors of the type class PureTypesinstancePureTypesNwhereempty=0isEmpty0=TrueisEmpty_=Falsearrowxy=(2^x)*(2*y+1)fromx|x>0=ifoddxthen0else1+(from(x‘div‘2))from_=undefinedtox|x>0=ifoddxthen(x−1)‘div‘2elseto(x‘div‘2)to_=undefinedBy specializing the generic instance transformer view to target type N we obtainn :: (PureTypesa)=>a−>Nn=viewThe following examples illustrate the use of n and t as transformers between the data types N and T*SystemT>t42(E :−>E) :−>((E :−>E) :−>((E :−>E) :−>E))*SystemT>nit42*SystemT>t2012((E :−>E) :−>E) :−>(E :−>(E :−>((E :−>E) :−>(E :−>(E :−>(E :−>(E :−>E)))))))*SystemT>nit2012Perhaps the most interesting item to note from our definition of the instanceNis thearrowconstructor. The corresponding operation on Tsimply creates a single tree from two trees and likewise we need a way to construct a single number from two. Pairing functions come to mind, and in fact the bijection we have defined is based on the pairing function(2)f(x,y)=2x(2y+1)−1.Fig. 1shows the natural number eight as a binary tree constructed in this fashion. Note that our modification to the pairing function means that we do not map zero and instead deal with it programmatically; this has the advantage of ensuring that the successor and predecessor functions that we define in the following section are inverses.We may now use this interpretation to proceed with building an implementation of Peano arithmetic; first however, we offer an explicit proof that the data types T and N are isomorphic.The definition of PureTypes given in the previous section does not, by itself, guarantee its instances are isomorphic; instead it offers a convenient mechanism under which to define such instances while avoiding repetitive complex logic. In the following proofs we show that T and N are indeed isomorphic, under the transformation provided by view. We now switch to a mathematical notation, using subscripts to indicate the instance to which a particular operation belongs.The definitions of n and t, given by view, are(3)t(z)=arrowT(t(fromN(z)),t(toN(z)))(4)n(v)=arrowN(n(fromT(v)),n(toT(v))).Note that arrow and from/to exhibit an inverse relationship by definition: they may also be thought of as constructors and destructors. More specifically (omitting the type subscripts as the equations are the same)(5)arrow(from(x),to(x))=x(6)from(arrow(x,y))=x(7)to(arrow(x,y))=y.An examination of the code for T reveals that these equations are true trivially; for N we rely on the bijective22arrowN(x,y)=2x(2y+1)is bijective betweenN×NandN−{0}as a result of the fundamental theorem of arithmetic; all of the twos dividing a number are factored out, leaving the odd part.property of the pairing function given in (2). Finally note that in the following proofs, as in Eqs. (3) and (4), x, y, z, and 0 are of type N; v and E are of type T.Proposition 1nandtdefine homomorphisms between typesNandT.Proving this requires showing that all operations of PureTypes are preserved under n and t. Given that empty indicates the identity element and that isEmpty is trivial, we show that arrow, from, and to are unchanged by simply applying the previous definitions (only t is shown here, a nearly identical argument applies to n).t(arrowN(x,y))=arrowT(t(fromN(arrowN(x,y))),t(toN(arrowN(x,y))))by(3)=arrowT(t(x),t(y))by(6)and(7)fromT(t(z))=fromT(arrowT(t(fromN(z)),t(toN(z))))by(3)=t(fromN(z))by(6)toT(t(z))=toT(arrowT(t(fromN(z)),t(toN(z))))by(3)=t(toN(z))by(7)□nandtare inverses.Here as in other proofs to follow, we use structural induction, where after showing the property holds for our “base” elements, we assume the property holds for the recursive substructures (from and to). The base cases for inversion aren(t(0))=n(E)=0t(n(E))=t(0)=E,and the induction hypotheses are(8)∀z′<Nz,n(t(z′))=z′(9)∀v′<Tv,t(n(v′))=v′.Note the subscripts on the<relation: for N, this is the normal ordering on natural numbers, and for T it should be read “is a subtree of”. Because fromN(z) and toN(z) are both less than z, and fromT(v) and toT(v) are subtrees of v, (8) and (9) imply the following statements:(10)n(t(fromN(z)))=fromN(z)(11)n(t(toN(z)))=toN(z)(12)t(n(fromT(v)))=fromT(v)(13)t(n(toT(v)))=toT(v).These, combined with Proposition 1, allow us to shown(t(z))=arrowN(n(fromT(t(z))),n(toT(t(z))))by(4)=arrowN(n(t(fromN(z))),n(t(toN(z))))byhomomorphism=arrowN(fromN(z),toN(z))by(10)and(11)=zby(5)t(n(v))=arrowT(t(fromN(n(v))),t(toN(n(v))))by(3)=arrowT(t(n(fromT(v))),t(n(toT(v))))byhomomorphism=arrowT(fromT(v),toT(v))by(12)and(13)=vby(5).□Consequently, code expressed exclusively in terms of arrow, from, to, empty, and isEmpty in our type classes can be safely shared between instances N and T.As the first step of an implementation of Peano arithmetic we define the successor and predecessor functions s and p in a class extending PureTypes, and formally prove they are correctclassPureTypesn=>PeanoArithnwheres,p :: n−>nsz|isEmptyz=arrowemptyemptysz|isEmpty(fromz)=arrow(s(fromst)(tost)wherest=s(toz)sz=arrowempty(arrow(p(fromz))(toz))pz|isEmpty(fromz)&&isEmpty(toz)=emptypz|isEmpty(fromz)=arrow(s(from(toz)))(to(toz))pz=arrowempty(p(arrow(p(fromz))(toz)))Proposition 3For anyxof typeN, s x=x + 1 andp x=x −1, where the latter holds providedx>0.If we carefully describe the computations on instance N using mathematical notation, we can easily prove that the operations are correct. As s and p are mutually recursive, we conduct our proof using simultaneous structural induction. For convenience we first introduce several new notations for our operations on the type N. First we denote the arrow operation on N as〈x,y〉=2x(2y+1),calling〈x,y〉the pairing of x and y. From this pairing we define the from and to operations as projection functions respectivelyπx=ν2(z)πy=2-ν2(z)z-12.The notationνp(z)is called the (additive) p-adic valuation or the p-adic order of z, and is used here as a succinct way to write “the highest power of 2 that divides z” [6].Basis: Given an empty instance which is zero by definition, the function s “pairs” two empty instances:〈0,0〉=20[2(0)+1]=1.Similarly, p acts on the inverse – given that both from and to are empty, the empty instance (zero) is returned – so our base case holds on both s and p.Case1 (Induction). (from z) is empty. In this instance, z is an odd number because for any y used in the pairing to construct z we have〈0,y〉=(2y+1)which is the definition of an odd number. Now, to show that s and p act as expected, we write them using our new notation which is easily manipulated algebraically.Starting with s, we note that (s (to z)) is used in both arguments to the arrow operation, so we assign its value to an intermediate variable mm=2-ν2(z)z-12+1.If we then let l and r be the first and second arguments of the arrow operation respectively, they may be written in terms of m:l=ν2(m)+1r=2-ν2(m)m-12.Now, we simply perform the pairing (the application of arrow) and back substitute for m〈l,r〉=2l(2r+1)=2ν2(m)+1[2(2-ν2(m)m-12)+1]=2ν2(m)+1[2−ν2(m)m]=2m=2[2-ν2(z)z-12+1]=2−ν2(z)z+1Finally, recall that we have established z as an odd number, meaning there is no power of 2 that divides it. Withν2(z)=0, the equation reduces toz+1.We handle p in the same fashion, letting the m be the value of (to x) and l and r the first and second arguments of arrowm=2-ν2(z)z-12l=ν2(m)+1r=2-ν2(m)m-12Perform the pairing2l(2r+1)=2ν2(m)+1[2(2-ν2(m)m-12)+1]=2ν2(m+1)[2−ν2(m)m]=2m=2[2-ν2(z)z-12]=2−ν2(z)z−1,which reduces toz−1.Case2 (Induction). (from z) is not empty. Here, we recall that a number n is even if there exists another number k such thatn=2k. Again, if we consider the pairing〈x,y〉used to construct z and the fact thatx>0(otherwise it would be covered by the previous case), we see that z is indeed a factor of 2.For s we again assign the arguments of the inner arrow operation to l and r respectively and let m be their pairingl=ν2(z)−1r=2-ν2(z)z-12m=〈l,r〉=2l(2r+1)=2ν2(z)−1[2(2-ν2(z)z-12)+1]=2ν2(z)−1[2−ν2(z)z]=2−1zPerform the pairing for the outer arrow operation:〈0,m〉=20[2(2−1z)+1]=z+1.Conveniently,ν2(z)in the exponent cancels out.The final case for p is handled in the same wayl=ν2(z)−1r=2-ν2(z)z-12m=〈l,r〉=2l(2r+1)=2ν2(z)−1[2(2-ν2(z)z-12)+1]=2ν2(z)−1[2−ν2(z)z]=2−1z〈0,m〉=20[2(2−1z−1)+1]=z−1.□The strategy employed here to show that s and p are correct is easily applied to the other arithmetic operations we have defined in the following section. One simply expands out the definition in terms of the base PureTypes operations arrow, from, and to, and then plugs in the mathematical notation given by instance N. Note also that because the operations s and p are defined entirely in those terms, the isomorphism between N and T holds here as well.Now, recall that for the Peano axioms to be satisfied on a triple(N,n0,f)where N is a non-empty set,n0∈N, andf:N→N, the following three properties must hold [7]:1.Ifx∈Nthenf(x)≠n0.Ifx,y∈Nandf(x)=f(y)then x=y.IfM⊆Nsuch thatn0∈Mandx∈M⇒f(x)∈M, then M=N.We will also state the induction principle on the initial algebra [8] of binary trees of type T.Proposition 4Let P(x) be a predicate about the terms ofT. If P holds for the generatorE∈Tand from P (x) and P(y) one can concludeP(x:→y), then P holds for all terms ofT.We instantiate the successor/predecessor definitions for the algebra T rewritten with the helper functions d and h, all mutually recursive:sE=E :−>E−−1 −−s(E :−>y)=d(sy)−−2 −−sz=E :−>(hz)−−3 −−p(E :−>E)=E−−1’ −−p(E :−>y)=dy−−3’ −−pz=E :−>(p(hz))−−2’ −−d(a :−>b)=(sa) :−>b−−4 −−h(a :−>b)=(pa) :−>b−−4’ −−The intuition behind these operations is their conventional arithmetic interpretation, as 0 for E,λx.λy.2x(2y+1)for:→,λx.2xfor d (assumingx>0) andλx.x/2(assuming x even andx>0) for h.The first and second properties hold by virtue of the fact that the s and p operations are inverses, for which we also give a simple direct proof.Proposition 5LetTbe the set of terms of the initial algebraTandT+=T−{E}. Thens:T→T+is a bijection andp:T+→Tis its inverse.We will proceed by induction on the structure of the terms of T. Observe that f is the inverse of f’ if and only if∀u∈T,∀v∈T+,fu=v⟺f′v=u. We will show this for the base case and the inductive steps for both s and p as well as d and h.Observe that if s and p are inverses, then d and h are also inverses (on their respective domains). This reduces to showing thatdy=z⟺hz=y, or equivalently, thatd(a:→b)=c:→d⟺h(c:→d)=a:→b, which further reduces to(sa):→b=c:→d⟺(p:→c):→d=a:→bandsa=c⟺pc=a, which holds based on the inductive hypothesis for s and p.We can now start our main induction proof, by case analysis. Observe that rules k and k’ are such that rule -- k -- is the unique match for function f if and only if rule -- k’ -- is the unique match for functionf′.We will show thatsu=v⟺pv=u, assuming it holds inductively for alla,bsuch thatv=a:→b. Note that case k corresponds to the application of rules -- k -- and -- k’ -- in the definitions of s and p1.su=sE=E:→E=v⟺pv=p(E:→E)=E=u.su=s(E:→y)=d(sy)=v⟺sy=hvpv=E:→ywherey=p(hv)⟺sy=hv, given that d and h are inverses under the inductive hypothesis covering their calls to s and p.v=su⟺v=E:→ywherey=huu=pv⟺v=E:→ywhereu=dy, which holds, given that d and h are inverses under the inductive hypothesis covering their calls to s and p.□Given that the instance N is an interpretation of Peano's axioms, one can establish a correspondence between proofs of program properties through the isomorphisms n and t between N and T that transport successors and predecessors. As well, given that N can be seen as a model of the free successor algebra with one generator33Also called Peano Algebra.and T a model for the free magma of (rooted, ordered) binary trees with empty leaves, the operations n and t provide the two sides of an isomorphism between these two free objects.After adding T and N as instances of PeanoArith one can observe experimentally that they agree on s and pinstancePeanoArithTinstancePeanoArithN*SystemT>mapt[0..4][E,E :−>E, (E :−>E) :−>E,E :−>(E :−>E),((E :−>E) :−>E) :−>E]*SystemT>mapsit[E :−>E, (E :−>E) :−>E,E :−>(E :−>E),((E :−>E) :−>E) :−>E,E :−>((E :−>E) :−>E)]*SystemT>mapnit[1,2,3,4,5]*SystemT>mappit[0,1,2,3,4]*SystemT>maptit[E,E :−>E, (E :−>E) :−>E,E :−>(E :−>E),((E :−>E) :−>E) :−>E]Starting with our successor and predecessor functions from Section 4, we proceed along the lines of Tait's definition of Gödel's recursor [9] and define some basic arithmetic functions:classPeanoArithn=>GoedelArithnwhererecursor :: (n −>n −>n) −>n −>n −>nrecursorfxy|isEmptyx=yrecursorfxy=f(px)(recursorf(px)y)After defining the (simpler) iterator itritr :: (n −>n) −>n −>n −>nitrftu=recursorgtuwhereg_ y=fyone can specify addition (recAdd), multiplication (recMul) and exponentiation (recPow) as follows:recAdd,recMul,recPow :: n −>n −>nrecAdd=itrsrecMulxy=itrfyemptywherefy=recAddxyrecPowxy=itrfy(sempty)wherefy=recMulxyIn a co-inductive style, we can generate the infinite stream of natural numbers and their twin T trees by applying s:allFrom :: n−>[n]allFromk=k : allFrom(sk)allOf :: [n]allOf=allFromemptyAfter adding the “twin” instancesinstanceGoedelArithTinstanceGoedelArithNone can try out these operations as follows:*SystemT>recMul51050*SystemT>recPow53125*SystemT>recAdd(E :−>E)(E:−>(E:−>E))((E :−>E) :−>E) :−>E*SystemT>take5(allFrom0)[0,1,2,3,4]*SystemT>take5(allFromE)[E,E :−>E, (E :−>E) :−>E,E :−>(E :−>E), ((E :−>E) :−>E) :−>E]While these algorithms are correct and serve as an executable specification, they are extremely slow as they are all expressed in terms of iterated successor operations. Our refinement in the next section focuses on efficient arithmetic operations in the form of a type class extending PeanoArith.We start with a few operations that, by deepening the analogy with their twin instance N, will provide a view of T objects as binary numbers. This view will ensure that arithmetic operations can be performed in the two instances within reasonable asymptotic time and space complexity bounds. We first define recognizers for “odd” and “even” objects:classPeanoArithn=>TreeArithnwhereone :: none=arrowemptyemptyisOdd,isEven :: n−>BoolisOddx=isArrowx&&isEmpty(fromx)isEvenx=isArrowx&&isArrow(fromx)We also add two constructors that build such “even” and “odd” objects:makeOdd,makeEven :: n−>nmakeOddx=arrowemptyxmakeEven=s.makeOddA destructor that reverses the action of both constructors follows:trim :: n−>ntrimx|isEmpty(fromx)=toxtrimx=p(arrow(p(fromx))(tox))Using the “twin instance” method, we can test that they do indeed, on integers, what we expect:*SystemT>mapt[0..3][E, E :−>E, (E :−>E) :−>E, E :−>(E :−>E)]*SystemT>mapisOddit[False,True,False,True]*SystemT>mapisOdd[0..3][False,True,False,True]*SystemT>makeOdd37*SystemT>makeEven38*SystemT>trim73*SystemT>trim83The last examples show that makeOdd and makeEven work on instance N as if implemented byλx.2x+1andλx.2x+2while trim works by undoing their action. We can now implement addition as follows:add :: n−>n−>naddxy|isEmptyx=yaddxy|isEmptyy=xaddxy|isOddx&&isOddy=makeEven(add(trimx)(trimy))addxy|isOddx&&isEveny=makeOdd(s(add(trimx)(trimy)))addxy|isEvenx&&isOddy=makeOdd(s(add(trimx)(trimy)))addxy|isEvenx&&isEveny=makeEven(s(add(trimx)(trimy)))Subtraction, under the assumption that the second operand is not larger than the first, is implemented in a similar way. Note that termination of both is immediate by structural induction as trim operations are always applied on the right side of the recursive rules to both argumentssub :: n−>n−>nsubxy|isEmptyy=xsubyx|isOddy&&isOddx=p(makeOdd(sub(trimy)(trimx)))subyx|isOddy&&isEvenx=p(p(makeOdd(sub(trimy)(trimx))))subyx|isEveny&&isOddx=makeOdd(sub(trimy)(trimx))subyx|isEveny&&isEvenx=p(makeOdd(sub(trimy)(trimx)))Efficient multiplication takes advantage of the fact that it falls back to addition on the left branches (selected by from), given that they represent exponents of 2 and that2x2y=2x+y. While it proceeds otherwise as traditional multiplication, this results in falling back to addition on “sparse numbers” containing large blocks of zerosmultiply :: n−>n−>nmultiplyx _|isEmptyx=emptymultiply_ x|isEmptyx=emptymultiplyxy=arrow(add(fromx)(fromy))(addam)where(tx,ty)=(tox,toy)a=addtxtym=double(multiplytxty)Similarly, the power operation falls back to multiplication on the left branches of the recursive rulespow :: n−>n−>npow_ y|isEmptyy=onepowxy|isOddy=multiplyx(pow(multiplyxx)(trimy))powxy|isEveny=multiplyx’(powx’(trimy))wherex’=multiplyxxThe following special cases have even more efficient implementations:half,double :: n−>ndouble=p.makeOddhalf=trim.sexp2 :: n−>nexp2x=arrowxemptyNote the simplicity of exp2 which is clearly a constant time operation when working on instance T. A left inverse of exp2, the integer binary logarithm log2 can be implemented as follows:log2 :: n−>nlog2x|isEmpty(tox)=fromxlog2x=add(fromx)(s(log2(tox)))After addinginstanceTreeArithTinstanceTreeArithNwe can try out and note the agreement on various arithmetic operations between the “twin” views*SystemT>t3E :−>(E :−>E)*SystemT>n(add(t3)(t4))7*SystemT>n(multiply(t3)(t4))12*SystemT>n(sub(t101)(t100))1*SystemT>n(pow(t3)(t4))81*SystemT>mapexp2[0..7][1,2,4,8,16,32,64,128]We can start our analysis by making a general statement about the runtime and space complexity of all our arithmetic operations.44As discussed at the end of the section, we describe our algorithms in terms of a number n rather than a bit size n.In one way or another each operation recurses on its subtrees, so if we wish to examine complexity in terms of the natural number n represented by any particular tree we look at how n decomposes down to empty leaf nodes. Our best and worst case scenarios correspond to a tree that is composed only of left subtrees or right subtrees respectively. In the former case, we are able to maximizeν2(n)which yields a number of the form22···2︸ntimesor2↑↑nan operation known as tetration (the latter denotation uses Knuth's “up arrow” representation [10]). At each recursion we are takinglgn, which gives usO(lg⁎n)wherelg⁎nis the following function.Definition 1The iterated logarithm,lg⁎n={0ifn≤11+lg⁎(lgn)ifn>1,is the number of times the logarithm must be applied successively before the result is less than or equal to one [11].This function, which grows very slowly, gives a very efficient representation.The latter case is for numbers of the form2k−1which as a bitstring would be a string of all 1s. Here, at each recursion we are merely cutting n in half which isO(lgn). Most of the natural numbers will be somewhere between these two extremes so it is perhaps more useful to examine what happens in the average case.In Section 4 we showed that the successor and predecessor algorithms were correct by examining their equivalent mathematical notation, and here we will do the same by examining the recurrences they represent. Note that d represents the constant-time work done by the arrow operation on type TS(n)=S(2−ν2(n)n−12)+S(ν2(2−ν2(n)n−12+1))+d(ifnisodd)S(n)=P(ν2(n))+d(ifniseven)P(n)=S(ν2(2−ν2(n)n−12))+d(ifnisodd)P(n)=P(ν2(n))+P(2ν2(n)−1(2(2−ν2(n)n−12)+1))+d(ifniseven)After some basic algebraic reductions, including the fact thatν2=0when n is odd, we get a better picture of the algorithm's behaviorS(n)=S(n−12)+S(ν2(n+12))+d(ifnisodd)S(n)=P(ν2(n))+d(ifniseven)P(n)=S(ν2(n−12))+d(ifnisodd)P(n)=P(ν2(n))+P(n/2)+d(ifniseven)At this point it is much easier to see intuitively why s and p are efficient on average: each has a case where we takeν2(n)which drastically reduces the size of the input (or the amount of “work”) to its subsequent recursive call; even falling into these cases only once or twice can quickly lead to termination.We now adjust our equations into inequalities that are easier to manipulate, by replacing some arguments with larger values; most notably we replaceν2(n)withlgn, which is the largest value that function could assumeS(n)≤S(n/2)+S(lgn)+d(ifnisodd)S(n)≤P(lgn)+d(ifniseven)P(n)≤S(lgn)+d(ifnisodd)P(n)≤P(lgn)+P(n/2)+d(ifniseven)We can combine each pair of inequalities into one that represents the expected running time by noting that a random number n is equally likely to be even or oddE[S(n)]≤12[E[S(n/2)]+E[S(lgn)]]+12E[P(lgn)]+dE[P(n)]≤12[E[P(lgn)]+E[P(n/2)]]+12E[S(lgn)]+dWe can clearly re-write this as one equation(14)E[T(n)]≤12[E[T(n/2)]+E[T(lgn)]]+12E[T(lgn)]+d=12[E[T(n/2)]]+E[T(lgn)]+d.Now, using the standard substitution method for such recurrences, we can easily prove the asymptotic complexity of the two operations.In the following, we will adopt the notation used in [11] for functional iteration. The notationlg(i)nwill represent the binary logarithm iteratively applied i times, wherei≥0andlg(0)n=n. It is important to note that many authors use a similar notation, without the superscript in parenthesis, to denote exponentiation of a function; the two should not be confused. For example,lg(2)nislglgn.We will show that the s and p operations areO(lg(lg⁎n−1)n), that is, the binary logarithm iterated one less time thanlg⁎n. Our proof will require a simple lemma.55Recall another notational convention: the logarithm function is applied only to the term immediately following.lg⁎n−1is(lg⁎n)−1and notlg⁎(n−1).Lemma 1For alln>2,lg(lg⁎n−1)n≤2.The proof follows from the definition of the iterated logarithm, which tells us thatlg(lg⁎n)n≤1. Taking each side of this inequality as a power of 2 yields the desired resultlg(lg⁎n)n≤1⟺2lg(lg⁎n)n≤21⟺lg(lg⁎n−1)n≤2,as long aslg⁎n≥1which is guaranteed whenn>2.□Eq.(14)isO(lg(lg⁎n−1)n).We aim to show by induction thatE[T(n)]≤clg(lg⁎n−1)n−bforn≥n0where b, c, and n0 are some positive constants. Our induction hypothesis isE[T(n/2)]≤clg(lg⁎n−1)n/2−bE[T(lgn)]≤clg(lg⁎n−1)(lgn)−b.Noting thatlg(lg⁎n−1)(lgn)=lg(lg⁎n)nand substituting into the original inequality yieldsE[T(n)]≤12(clg(lg⁎n−1)n/2−b)+clg(lg⁎n)n−b+d=c[lg(lg⁎n−1)n/22+lg(lg⁎n)n]−3b2+d≤c[lg(lg⁎n−1)n/22+1]−3b2+d(byDefinition1)≤c[1+1]−3b2+d(byLemma1)=2c−3b2+d.It now remains to show that2c−3b2+d≤clg(lg⁎n−1)n−bby choosing our constants appropriately. Our use of Lemma 1 requiresn>2, which also allows the reduction:2c−3b2+d≤2c−b.This statement holds for any positive c and anyb≥2d, but we must also show that a base case holds; selectingn0=4requires us to show thatE[T(4)]meets the same conditions. We have, based on the recurrence,E[T(1)]=d,E[T(2)]=5d/2, andE[T(4)]=19d/4. We must show19d/4≤clg(lg⁎4−1)4−b=clg(1)4−b=2c−b,which holds whenc≥27d/4, completing the proof.□An immediate consequence of this proof is that for a random natural number n, the expected running time of s n and p n isO(1). Our result ofO(lg(lg⁎n−1)n)is actually a tighter upper bound, that more accurately describes the behavior ofE[T(n)]. Another way to interpret this result is to imagine the asymptotic boundary changing as we pass each tetration of 2, as shown in Table 1.Finally, the authors also verified this result empirically by running the s operator on every natural number up to231−1and counting the number of recursive s and p calls that were made. Fig. 2, which is scaled logarithmically along the x-axis, shows a portion of these results for2↑↑3<n≤2↑↑4. The plot at the top shows how the average number of recursive calls changes as s is applied to increasing n versuslglglgn.Informally, and without proof, we extend our reasoning to some of the higher order operations we have implemented. As we build an arithmetic operation of the next highest order (starting with s and p), the upper bound is increased by a factor oflgn. For example, examining the recurrence representing the add operation would show that there are four cases, depending on whether the inputs are even or odd. Three of these cases adjust their inputs so that they are both even (which includes performing some constant number of s and p operation) and call the fourth case, which recursively reduces both inputs by half. In other words, the recurrence would look something likeT(n)=T(n/2)+O(1), making the add operationO(lgn). By the same reasoning, multiply isO(lgnlgn).In comparing our results to traditional operations on bit strings, two important considerations must be kept in mind. The first, to reiterate, is that the results in this section are the expected or average running times, based on the assumption that n is chosen at random. As mentioned previously, operations on some numbers, like those of the form2↑↑nare very efficient while others are notably worse – although all running times are sub-linear.Second, running time on primitive arithmetic operations is most often discussed in terms of bit complexity[12], so a simple conversion is needed to make a true “apples-to-apples” comparison of the runtime complexities given here: m bits can represent a number of size2m−1; taking the traditional multiplication algorithm as an example, its bit complexity ofO(m2)expressed in terms of the value of a number n isO(lgnlgn), equivalent to our estimate for multiply.In spite of these caveats, there is a respectable result: the expected runtime of our tree-based arithmetic algorithms have the same asymptotic complexity as their traditional bitstring counterparts.Finally, given that the traditional bitstring representation of a number n consumes exactlylgnbits, asymptotically our storage is also quite efficient – this is because the structure effectively “compresses” any repeated strings of zero in the traditional representation.We conclude our arithmetic related work by defining a total order, provided as a new class Ordered. Comparison proceeds by case analysis, the interesting cases being when the order relation is strengthened from EQ to LT or GT. Termination of the algorithm is ensured by the fact that at each recursive step the trim operation makes the arguments smallerclassTreeArithn=>Orderednwherecmp :: n−>n−>Orderingcmpxy|isEmptyx&&isEmptyy=EQcmpxy|isEmptyx&&not(isEmptyy)=LTcmpxy|not(isEmptyx)&&isEmptyy=GTcmpxy|isOddx&&isOddy=cmp(trimx)(trimy)cmpxy|isEvenx&&isEveny=cmp(trimx)(trimy)cmpxy|isOddx&&isEveny=downeq(cmp(trimx)(trimy))wheredowneqEQ=LTdowneqb=bcmpxy|isEvenx&&isOddy=upeq(cmp(trimx)(trimy))whereupeqEQ=GTupeqb=bBoolean comparison operators are defined as follows:lt,gt :: n−>n−>Boolltxy=LT==cmpxygtxy=GT==cmpxyWith the help of our comparison operations, we can now implement efficient division and remainder operations (returned as a pair):div_and_rem :: n−>n−>(n,n)div_and_remxy|ltxy=(empty,x)div_and_remxy|gtyempty=(add(exp2qt)u,v)wheredivstepnm=(q,subnn’)whereq=try_to_doublenmemptyn’=multiply(exp2q)m(qt,rm)=divstepxy(u,v)=div_and_remrmytry_to_doublexyk|ltxy=pktry_to_doublexyk=try_to_doublex(doubley)(sk)and the two separate operations as first and second projections:divide,remainder :: n−>n−>ndividenm=fst(div_and_remnm)remaindernm=snd(div_and_remnm)After addinginstanceOrderedTinstanceOrderedNempirical agreement on sorting between the “twin” views illustrates that they are order-isomorphic*SystemT>mapt[3,1,1,4,2][E :−>(E :−>E), E :−>E, E :−>E,((E :−>E) :−>E) :−>E, (E :−>E) :−>E]*SystemT>sortBycmpit[E :−>E, E :−>E, (E :−>E) :−>E, E :−>(E :−>E),((E :−>E) :−>E) :−>E]*SystemT>mapnit[1,1,2,3,4]To hint towards the generality of the representation mechanisms described so far, we conclude by interpreting our type classes as a balanced parenthesis languages, a member, together with binary trees (and a few dozen other data types) of the Catalan family of combinatorial structures [13]. We chose it partly because it provides a succinct, 1-bit per parenthesis representation resulting in a total average size of about twice that of a bitstring representation. We define a data type for lists of left and right parenthesis L and RdataPar=L|Rderiving(Eq,Read,Show)dataPars=Pars[Par]deriving(Eq,Read,Show)Next we define it as an instance of PureTypes by defining arrow, from and to operations that work directly on balanced parenthesis listsinstancePureTypesParswhereempty=Pars[L,R]arrow(Parsx)(Pars(L:xs))=Pars(L : x++xs)from=fst.from_toto=snd.from_toisEmpty(Pars[L,R])=TrueisEmpty_=FalseThe implementation of from and to uses a “parser”-like function from_to that extracts them as a pair of parenthesis lists:from_to(Pars(c:cs))|c==L=(Pars(L:fs),Pars(L:ts))where(fs,ts)=parexprcsparexpr(c:cs)|c==L=parlistcswhereparlist(c:cs)|c==R=([R],cs)parlist(c:cs)=(c:fs++ts,cs2)where(fs,cs1)=parexpr(c:cs)(ts,cs2)=parlistcs1Conversion to and from this parenthesis language representation and the natural number or binary tree view is automated by simply specifying the type of the conversion operation parpar :: (PureTypesa)=>a−>Parspar=viewBy adding instance declarations to various classes, arithmetic operations become readily available on balanced parenthesis languagesinstancePeanoArithParsinstanceTreeArithParsinstanceOrderedParsFor instance, one can convert from this parenthesis language representation to natural numbers and back as follows:*SystemT>par 2012Pars[L,L,L,L,R,R,R,L,R,L,R,L,L,R,R,L,R,L,R,L,R,L,R,R]*SystemT>nit2012One can also perform arithmetic operations with them, and observe that they correspond to their natural number equivalents*SystemT>add(Pars[L,L,R,L,R,R])(Pars[L,L,L,R,R,R])Pars[L,L,R,L,L,R,R,R]*SystemT>n(Pars[L,L,R,L,R,R])3*SystemT>n(Pars[L,L,L,R,R,R])2*SystemT>nPars[L,L,R,L,L,R,R,R]*SystemT>n(Pars[L,L,R,L,L,R,R,R])5Note that if represented as bitstrings (with 0 standing for L and 1 standing for R), parenthesis languages can be seen as a succinct data type on which arithmetic operations can be directly performed.

@&#INTRODUCTION@&#


@&#CONCLUSIONS@&#
