@&#MAIN-TITLE@&#
A comparison of five hybrid metaheuristic algorithms for unrelated parallel-machine scheduling and inbound trucks sequencing in multi-door cross docking systems

@&#HIGHLIGHTS@&#
Develops five hybrid metaheuristics for parallel-machine and inbound-trucks sequencing in multi door cross docking.The 2-stage hybrid ACO is found to be the best if maximal number of evaluations is used as the stopping criterion.The hybrid simulated-annealing tabu-search algorithm is the best if CPU time is used the stopping criterion instead.

@&#KEYPHRASES@&#
Hybrid metaheuristic,Simulated annealing,Ant colony optimization,Unrelated parallel machine scheduling,Makespan,Inbound truck sequencing,

@&#ABSTRACT@&#
The objective of this paper is to develop five hybrid metaheuristic algorithms, including three hybrid ant colony optimization (hACO) variants, and compare their performances in two related applications: unrelated parallel machine scheduling and inbound truck sequencing in a multi-door cross docking system in consideration of sequence dependent setup, and both zero and nonzero release time. The three hACO variants were modified and adapted from the existing literature and they differ mainly in how a solution is coded and decoded, how a pheromone matrix is represented, and the local search methods employed. The other two hybrids are newly constructed hybrid simulated annealing (hSA) algorithms, which are built based on the authors’ knowledge and experience. The evaluation criteria are computational time and the objective function value, i.e., makespan. Based on the results of computational experiments the simulated annealing-tabu search hybrid turns out to be the best if maximal CPU time is used as the stopping criterion and the 2-stage hACO variant is the best if maximal number of evaluations is the stopping criterion. The contributions of this paper are: (i) being the first to carry out a comparative study of hybrid metaheuristics for the two selected applications, (ii) being the first to consider nonzero truck arrival time in multi-door cross docking operations, (iii) identifying which hACO variant is the best among the three, and (iv) investigating the effect of release time on the makespan.

@&#INTRODUCTION@&#
Scheduling and sequencing problems are pervasive in the real world. Researchers have been very interested in developing various algorithms to help find (near-) optimal schedule/sequence for various applications. A number of reviews already exist with each focuses on different facets of the scheduling and sequencing problems. For examples, Allahverdi et al. [1] review the literature on scheduling problems involving setup times (costs). Of particular interest in this paper is parallel machine scheduling. A brief introduction follows.An identical parallel-machine scheduling problem involves the scheduling of jobs on multiple identical machines in a production system, in which a job can be processed by any one of the free machines and each finished job will free the machine used and leave the system. If those machines are not identical, then we have a non-identical parallel machine scheduling problem, for which two cases can be further distinguished: uniform and unrelated. A uniform parallel machine scheduling problem assumes that different machines process the same job with different speeds. In other words, the processing times of a job on different machines can be related to each other by speed factors. On the contrary, an unrelated parallel machine scheduling problem considers the case that the processing times of a job on different machines are different and unrelated, or cannot be related by speed factors. Identical or similar problems can also be found in other systems such as computing systems, cross-docking warehouse systems, and port crane systems.Other than whether the parallel machines are identical or not, jobs characteristics and optimization criteria of concern might also vary from one application to another. Two different notation schemes have been used to classify research in parallel machine scheduling. The three-parameter notation, α/β/γ, introduced by Graham et al. [2] specifies the machine environment (α=P for identical, Q, uniform, and R unrelated), job characteristics (β), and the chosen optimization criterion (γ), respectively. On the other hand, the four-parameter notation, A/B/C/D, introduced by Conway et al. [3] denotes number of jobs (A), number of available machines (B), flow pattern and special system conditions (C), and the criterion used to evaluate a schedule (D). The former scheme is followed in this paper.Most researchers study scheduling problems as deterministic problems. All deterministic scheduling problems, with deterministic parallel machine scheduling included, are combinatorial optimization problems. Many deterministic parallel machine scheduling problems have been proved to be NP-hard. Most of the complexity results for parallel machine scheduling and other scheduling problems can be found in the Internet address http://www.informatik.uni-osnabrueck.de/knust/class/. Hence, for solving large scale deterministic parallel machine scheduling problems approximation algorithms, metaheuristics, and heuristics have been popular. Approximation algorithms are algorithms used to find approximate solutions to optimization problems. Unlike heuristics, approximate algorithms have provable solution quality and provable run-time bounds. Ideally, the approximation is optimal up to a small constant factor (for instance within 5% of the optimal solution). Meta-heuristics, such as ant colony optimization, are one kind of heuristics that find a good solution based on some intelligent search scheme and problem-dependent local search methods. Heuristics include the algorithms developed for specific problems that have no performance guarantees and are not meta-heuristics; examples include the heuristic developed by Srivastava [4] for minimizing makespan on unrelated parallel machines and the heuristic developed by Yu and Egbelu [5] for sequencing trucks in a single door cross docking system.To date, there have been at least four reviews on “parallel machine scheduling”, which include Cheng and Sin [6], Mokotoff [7], Li and Yang [8], and Kravchenko and Werner [9]. Cheng and Sin review 80 papers organized in three categories in terms of optimization criteria: completion time based, due date based, and flow time based. To the best of our knowledge, no metaheuristic algorithm was included in their review. Mokotoff review mostly research works that employ completion time based optimization criteria, organized based on the solution approaches: efficient algorithms for solving particular and simple cases, enumerative algorithms, and approximation algorithms. They further distinguish two types of approximation algorithms: improvement algorithms and constructive algorithms. The category of improvement algorithms includes threshold algorithms (including iterative improvement, threshold accepting, and simulated annealing), tabu search, and genetic algorithms. The review of Li and Yang focuses on a class of non-identical parallel-machine scheduling problems in which the goal is to minimize total (or mean) weighted (or unweighted) completion time. Kravchenko and Werner survey existing approaches for the problem of scheduling n jobs with each requiring an identical execution time on a set of parallel machines, with preemption either allowed or forbidden. They focus mostly on dynamic programming and liner programming approaches, trying to describe the most fruitful ideas and pose problems with an open complexity status.Of particular interest in his paper is the use of hybrid metaheuristic algorithms for solving unrelated parallel machine scheduling problems and inbound trucks sequencing in a multi-door cross docking system with minimizing makespan as the objective. Hybrid metaheuristic algorithms have been found to outperform pure metaheuristics for various applications in many studies, including ours such as Liao [10], Liao et al. [11]; Liao et al. [12]; Liao et al. [13], and Yi et al. [14]. So far the use of hybrid metaheuristic algorithms in parallel machine scheduling and/or truck sequencing in cross docking systems has been limited, as reviewed below.Anghinolfi and Paolucci [15] propose a hybrid metaheuristic (HMH) approach which integrates several features from tabu search (TS), simulated annealing (SA) and variable neighborhood search (VNS) to minimize total tardiness for a class of scheduling problems characterized by a set of independent jobs to be executed on a set of parallel machines with non-zero ready times and sequence dependent setups. Guo et al. [16] study the unrelated parallel machine problem for minimizing the makespan by using a hybrid of Simulated Annealing (SA) and Tabu Search (TS) with Neighborhood Search (NS). Chen and Chen [17] proposes several hybrid metaheuristics that integrate the principles of the variable neighborhood descent approach and tabu search for the unrelated parallel-machine scheduling problem with sequence-dependent setup times given the objective of minimizing the weighted number of tardy jobs.For the minimization of makespan in scheduling problems with parallel machines and sequence-dependent setup times, Behnamian et al. [18] propose a hybrid metaheuristic, which comprises three components: an initial population generation method based on an ant colony optimization (ACO), a simulated annealing (SA) for solution evolution, and a variable neighborhood search (VNS) which involves the use of three local search procedures to improve the population. Arnaout et al. [19] introduce a two-stage ant colony optimization (ACO) algorithm enhanced by a local search procedure to minimize the makespan for the unrelated parallel machine scheduling problem with machine-dependent and sequence-dependent setup times when the number of jobs to the number of machines ratio (N/M) is large. Keskinturk et al. [20] develop an ant colony optimization algorithm to solve the problem of minimizing average relative percentage of imbalance (ARPI) with sequence-dependent setup times in a parallel-machine environment. Note that the only similarity among the above-mentioned three studies is that they all consider sequence-dependent setup times. Both Behnamian et al. and Arnaout et al. use minimizing makespan as the evaluation criterion while Keskinturk et al. focus on minimizing average relative percentage of imbalance (ARPI) instead. Both Behnamian et al. and Keskinturk et al. consider identical parallel-machine while Arnaout et al. focus on unrelated parallel-machine instead. Most importantly, the ant colony optimization algorithms developed in the above three works are all different, mainly in how a solution is coded and decoded, how a pheromone matrix is represented, and the use of different local search methods.As far as truck sequencing in cross docking operations are concerned, very few studies have employed hybrid metaheuristics. Soltani and Sadjadi [21] propose two hybrid metaheuristics, i.e., hybrid simulated annealing and hybrid variable neighborhood search, to solve truck sequencing in a single-door cross docking system. Liao et al. [11] develop two hybrid differential evolution algorithms for both inbound and outbound truck sequencing in a single-door cross docking system. Liao et al. [22] report that both hybrid differential evolution and ant colony optimization perform best among six metaheuristic algorithms, when applied to solve the problem of simultaneous dock assignment and inbound trucks sequencing in a multi-door cross docking system, with the objective to minimize total weighted tardiness under a fixed outbound truck departure schedule.This research is motivated by the desire to determine which hybrid metheuristic and which variant of hybrid ant colony optimization algorithms perform better. To enable the comparative study, two related application domains are chosen, which include the unrelated parallel machine scheduling problem with sequence-dependent setup and inbound truck sequencing with nonzero release time in a multi-door cross docking system. The evaluation is based on both objective function value, i.e., makespan, and computational time. Makespan is chosen because it is commonly used in both application domains. To enable the comparative study, five hybrid metaheuristics are developed, which include two hybrid simulated annealing and three hybrid ACO variants. The new contributions of this paper are mainly in (i) carrying out the first comparative study of hybrid metaheuristics for the two selected application domains, (ii) being the first to apply a hybrid metaheuristic algorithm for inbound trucks sequencing with nonzero release time in a multi-door cross docking system, (iii) clearly identifying which hybrid ant colony optimization variant is the best among the three tested, and (iv) investigating the effect of truck arrival (release) time on makespan.The remainder of the paper is organized as follows. Section 2 introduces both the unrelated parallel machine scheduling problem and the inbound trucks sequencing problem. Section 3 describes the five hybrid metaheuristics, including three variants of hybrid ant colony optimization algorithm. Tuning of algorithmic parameters is also covered. Section 4 presents the test data and results for each application, followed by the discussion. Finally the paper is concluded.This section describes the two applications chosen for comparing five hybrid metaheuristics, including three variants of hybrid ant colony optimization to be detailed in the following section. Mathematically, the two applications can be formulated identically. Before presenting the mathematical formulation of the problems, the assumptions are summarized below.•Each job (or inbound truck) has only one operation.Any machine can process any job (any receiving door can process any inbound truck).No job (inbound truck) can be processed on more than one machine (door or dock) simultaneously.No machine (receiving door) may process more than one job (truck) at a time.Machines (receiving doors) will never break down and are available throughout the scheduling period.Job (truck) processing times are independent of the schedule.Jobs (trucks) cannot be pre-emptied. Any job (truck) once set up on a machine (door) cannot be removed before being completed.Machine setup time is not negligible and not included in the processing time and sequence-dependent setup times on each machine are fixed. In the context of inbound trucks, setup times are truck changing times.Number of jobs (inbound trucks), n, is fixed.Number of machines (receiving doors), m, is fixed.The number of jobs (inbound trucks) is larger than the number of machines (receiving doors), n>m, to avoid trivial cases.Processing time of job (truck) j on machine (door) k, pjk, is given and fixed for all j and k.Ready (release) time of job (truck) j, for all j is known and can be zero or nonzero.Let Π be the set of all possible schedules. For any schedule S, letσk={j1(k),j2(k),…,jrk(k)}be the subset of jobs (trucks) scheduled on machine (door) k in that order. That is, we use σknot only to denote the subset of jobs (trucks) assigned to machine (door) k but also to define the sequence by which these jobs (trucks) will be processed on the machine (door). It is straightforward to prove that any optimal schedule for the subject problem cannot have inserted idle time between any two consecutive jobs (trucks) on any machine (door). Therefore, there exists a one-to-one correspondence between a schedule and a partition of the n jobs (trucks) into m subsets σ1, σ2,…,σmsuch that σ1∪σ2∪,…,∪ σm={1, 2,…,n}and σi∩σk=∅ for all i≠k. In other words, a schedule is uniquely determined by such a job (truck) partition, and vice versa.Let Cj(S) be the completion time of job (truck) j in schedule S. For simplicity, Cj(S) is simply written as Cj. Definesj0(k),j1(k)=s0,j1(k)(i.e., the initial setup time of job or truck j1(k)). Then, depending upon whether each job (truck) is weighted or not, the completion time of job ji(k) on machine (door) k (k=1, 2,…,m) can be computed by either Eq. (1a) for the non-weighted case or Eq. (1b) for the weighted case if all jobs (trucks) are available at time zero.(1a)Cji(k)=Cji−1(k)+(sji−1(k),ji(k)+pji(k),k)or(1b)Cji(k)=Cji−1(k)+wji(sji−1(k),ji(k)+pji(k),k)where Cjo(k)=0, for all k. The job (truck) weight is applied if each job (truck) varies in importance.The subject unrelated parallel machine scheduling problem or inbound truck sequencing in a multi-door cross docking system is to find an optimal schedule S*∈Π so as to minimize the makespan, Cmax. That is,(2)MinimizeCmax=maxk(Crk)Let rkdenote the cardinality of subset σk(i.e., rk=|σk|), for all k. Then the total number of possible schedules can be expressed as(3)Π=∑r1+r2+…+rm=n(r1!Cnr1)(r2!Cn−r1r2)…(rm!Cn−(r1+…+rm−1)rm).It can be seen that Π≥m×n! for all m>1. This indicates that the search for an optimal schedule in reasonable time by total enumeration is challenging as n increases. As pointed out by Arnaout et al. [19], the subject problem is NP-hard; hence justify the use of metaheuristics.To the best of our knowledge, all existing studies on truck sequencing in cross docking systems assume zero release time of trucks. This assumption might not be true in reality, especially when trucks arrive throughout the day at different times. In this study, both zero and nonzero release times are studied. Accordingly, Eqs. (1a) and (1b) must be modified to take nonzero release time into consideration. This study considers the case that each truck is not weighted. In other words, each truck is treated equally. Let t be the current time and the arrival (release) time of truck ji(k) on door k be aji(k). If i=1 (the first truck), thenCji(k)=(s0,ji(k)+pji(k),k),ifaji(k)<tCji(k)=aji(k)+(s0,ji(k)+pji(k),k),elseelse(4)Cji(k)=t+(sji−1(k),ji(k)+pji(k),k),ifaji(k)<tCji(k)=aji(k)+(sji−1(k),ji(k)+pji(k),k),elseLikely, similar modification can be made for the case that each truck is weighted differently.For carrying out the comparative study, five hybrid metaheuristic algorithms are developed. Three of the five are hybrid ant colony optimization algorithms. Ant colony optimization (ACO) is a well-known bio-inspired metaheuristic algorithm originally developed by Dorigo and his colleagues [28]. The authors have experience in using ACO in several applications, which include feature selection [23], project scheduling [24], supply chain inventory management [25], and inbound truck sequencing in a multi-door cross docking system [22] to name just a few. The three variants of hybrid ant colony optimization algorithm are developed with each following an existing study with varying amounts of modifications deemed necessary. The remaining two are hybrid simulated annealing algorithms. One of them is a simulated-annealing differential-evolution hybrid whereas the other is a simulated-annealing tabu-search hybrid. More details are given below.Following Behnamian et al. [18], the first variant of hACO uses the random key list approach to code a solution, with the integer value indicating the machine or door assignment and the decimal value indicating job or truck sequence priority. This representation allows the use of a continuous metaheuristic algorithm, but a decoding step is necessary to construct a schedule before evaluating its goodness. The decoding operation involves in converting a real coded vector into a schedule as described in Section 2. Instead of using the max-min ant system (MMAS) as in Behnamian et al. [18], the continuous version of ant colony optimization algorithm, ACOR that was developed originally by Socha and Dorigo [26], is adopted instead. In fact, it is unclear to us how the MMAS implements the random key list approach.The fundamental idea underlying ACOR is the use of a continuous Gaussian kernel probability density function. The ACOR maintains a number of solutions in the archive and the information (i.e., variable values and objective value) associated with these solutions are used to construct new solutions. The archive and the solutions therein thus act very much like the pheromone matrix in the conventional ACO. In constructing a new solution one dimension (or variable) at a time, each ant follows a two-step procedure. First, it chooses one solution in the archive (equivalently one of the Gaussian functions that compose the Gaussian kernel) based on some probability. The probability is in turns computed based on the weight of each solution (or Gaussian function). Then, it takes a randomly sampled value from the associated Gaussian function characterized by its mean and standard deviation. There are four parameters associated with ACOR: number of ants, ants, size of archive, sar, a parameter used in computing the weight of each solution, θ, and a scaling parameter used in computing the standard deviation of each Gaussian function, ξ. To avoid redundancy, interested readers are referred to the original paper for more details.For this study, the original ACOR algorithm is enhanced by crossover and mutation operators commonly used in real-coded genetic algorithms. Specifically, the uniform crossover is applied to each ant constructed solution together with the global best solution to generate two offspring. The first offspring is then subject to either non-uniform mutation or multiple non-uniform mutations with equal probability. The non-uniform mutation operator changes one of the parameters of the current solution (the parent in GA) while multi-non uniform mutation changes all of the parameters of the parent based on a non-uniform probability distribution, i.e., Gaussian. This Gaussian distribution starts wide, and narrows to a point distribution as the current number of function evaluations (current generation in GA) approaches the maximal number of function evaluations (the maximum generation in GA). The 1st variant is thus also called random key list hybrid ACO, RKL_hACO for short.The new solutions constructed by ants might be outside the domain range. In such a case, a simple repair procedure is employed. Based on equal probability, the value is either set as the bound value or regenerated randomly within the domain range. The algorithm is stopped whenever the number of function evaluations, nfe, reaches the maximum, i.e., maximal number of function evaluations, maxnfe. The pseudo code of the 1st variant (or RKL_hACO) for the subject problem is given below.Algorithm: RKL_hACO.1. Specify parameter values including ants, sar, θ, and ξ.2. Load data and define domain range for each variable, i.e., ∈[1,m+1] in this study.3. Randomly generate the initial set of solutions, decode and evaluate them based on Eq. (2), and let number of function evaluations, nfe=sar. The completion time of each job or truck is computed based on Eq. (1) or (4) depending upon the application.4. Sort the solutions and store them in the archive, compute the weights and probabilities associated with solutions (refer to the original paper by Socha and Dorigo).5. Record the best solution as the global best.6. While nfe<maxnfea. For each anta.1. Construct a solution from the archive according to the probabilities one dimension at a time.a.2. Repair the solution if out of domain range, decode and evaluate it based on Eq. (2), and increment nfe by 1.a.3. Perform crossover and mutation operations, decode and evaluate the two new offspring, and increment nfe by 2.a.4. Update the archive by replacing worse solutions with newly generated better solutions.End forUpdate the global best if appropriate.End whileThe 2-stage procedure of Arnaout et al. [19] uses one vector and one matrix to code a solution. The vector is called the assignment vector and has the same size as the number of jobs or trucks; each value in the vector denotes the machine assigned to a job (or the receiving door assigned to an inbound truck). The matrix represents the sequence of jobs (trucks) on each machine (door), which has size of m×n with each row showing the sequence of jobs (trucks) assigned to a corresponding machine (door) and for each row the entries after the last job (truck) are padded with zeros. To support the generation of new solutions, their procedure requires the use of 2 pheromone matrices, one of size m×n for machine assignment and another of size n×n×m for job (truck) sequencing.The 2nd variant is a modification of the 2-stage procedure of Arnaout et al. [19] described above, mainly in the second stage. Instead of using one vector and one matrix to code a solution, two vectors are used instead. The first vector is identical to that of Arnaout et al. The second vector called the sequence permutation vector also has the same size as the number of jobs (trucks) and each value in the vector denotes a job (truck). The two vectors can be used together to generate the matrix representing the sequence of jobs (trucks) on each machine (door) easily. To support the generation of new solutions, our procedure requires the use of two pheromone matrices, one of size m×n for machine (door) assignment,τikI,i∈{1,…,n},k∈{1,…,m}, and another of size (n+1)×n for job (truck) sequencing,τijII,i∈{1,…,n+1},j∈{1,…,n}.Note that the first row of this pheromone matrix is used for choosing the first job to be sequenced. It is apparent that our second pheromone matrix is smaller than that of Arnaout et al. [19].In constructing a new solution, each ant follows a two-step procedure: first constructing the machine (door) assignment vector and then constructing the job (truck) sequence vector. In the first step, machine (door) k to be assigned to job (truck) i is determined based on probability computed by:(5)PrikI=(τikI)a(ηikI)b∑l=1m(τilI)a(ηilI)bwhereηikI=1/pik,pikdenotes the time required to process job (truck) i on machine (door) k. In the second step, job (truck) j to be sequenced after job (truck) i is determined based on probability computed by:(6)PrijII=(τ1jII)a(η1jII)b∑l∈Ψ(τ1lII)a(η1lII)bifjisthe1stjob(truck)(τijII)a(ηijII)b∑l∈Ψ(τilII)a(ηilII)bifjisnotthe1stjob(truck)In Eq. (6), Ψ denotes the set of jobs (trucks) not yet being sequenced (not tabooed), a and b are the weights on pheromone information and heuristic information, respectively, andηijII=1/sij¯,wheresij¯denotes that average setup time for processing job j after job i across all machines (or average changeup time for processing truck j after truck i across all doors). After all ants finish constructing their paths, the pheromone amounts in each matrix are updated as follows:(7a)τikI=(1−ρ)τikI+ϕ1CmaxBest,ifarc(i,k)isusedbythebestant.(7b)τijII=(1−ρ)τijII+ϕ1CmaxBest,ifarc(i,j)isusedbythebestant.In Eqs. (7a) and (7b), ρ and ϕ are the pheromone evaporation rate, and global update rate, respectively.An integral component of the algorithm of Arnaout et al. [19] is the application of a local search procedure for a specified number of iterations, maxnls. In each iteration, a solution is changed either by altering a small percentage (5% was used) of machine (door) assignment or by swapping two randomly selected jobs (trucks) in the matrix with equal probability. The 2nd variant is thus also called 2-stage hybrid ACO, 2S_hACO for short. The algorithm is stopped whenever the number of function evaluations, nfe, reaches the maximum, i.e., maximal number of function evaluations, maxnfe. The pseudo code of the 2nd variant (or 2S_hACO) for the subject problem is given below.Algorithm: 2S_hACO.1. Specify parameter values including ants, a, b, ρ, ϕ, and maxnls.2. Load data3. Randomly generate an initial solution, evaluate it based on Eq. (2), let number of function evaluation, nfe=1, and record the solution to be the global best.4. Initialize the two pheromone matrices (= 10 in this study following Arnaout et al.).5. While nfe<maxnfea. For each anta.1. Construct the machine (door) assignment according to Eq. (5).a.2. Construct the job (truck) sequence according to Eq. (6).a.3. Decode the two vectors to construct the schedule, evaluate it, and increment nfe by 1.a.4. Apply the local search procedure until a better solution is found within the specified number of iterations, maxnls, increment nfe with the appropriate number of evaluations taken.End forb. Update the two pheromone matrices according to Eqs. (7).c. Update the global best solution if appropriate.End whileFollowing Keskinturk et al. [20], the 3rd variant represents the subject problem as a graph (or network) with jobs (or trucks) as supernodes (or node clusters) and each supernode has m nodes with each node corresponds to a particular machine (or door). The nodes on each supernode are not connected. However, every node in a supernode is connected to all other nodes in other supernodes. The total number of arcs is thus (m×n)2. On this graph, to construct a solution, each artificial ant travels to each supernode, i.e., visits any node (denoting machine or door) on that supernode. When an ant completes a tour, the order of visiting each supernode yields the order of assignment of jobs (trucks) to the machines (doors). Furthermore, the node visited at each supernode determines the assignment of a job (truck) to a machine (door). To support the generation of new solutions, their procedure requires the use of one big pheromone matrix of size (m×n+1)×(m×n); the first row of the matrix can be considered corresponding to a dummy node (for ants’ nest) and is used for choosing the first job (truck) and the machine (door) to be assigned.The next node to be selected is determined in three ways with different probabilities: (i) select the node having the maximal pheromone amount with probability q, (ii) select a node based on the roulette wheel concept with probability d, and (iii) select a node randomly with probability r. The sum of these three probabilities is one. After all ants have constructed their solutions and possibly improved by local search, the pheromone matrix is updated according to the following equation:(8)τik,i′k′(t)=(1−ρ)τik,i′k′(t−1)+∑i=1antsΔτik,i′k′i(t),(9)Δτik,i′k′i=1Cmaxor1Cmax+ifantitravelsonedge(ik,i′k′)0elseIn Eq. (9) the value taken for an edge traveled by an ant is the inverse of the objective function value.Each ant solution is subject to a local search procedure. Essentially, the 2-exchange heuristic is used to switch the position of two jobs (trucks) attempting to find a better solution for at most a specified number of iterations, which is set equal to two in all three variants. The two jobs (trucks) swapped could be originally assigned to the same machine (door) or different machines (doors). The pseudo code of the third ACO variant, called one-pheromone-matrix_hACO or 1PM_hACO for short, is summarized below.Algorithm: 1PM hACO.1. Specify parameter values including ants, ρ, and three probabilities associated with constructing a solution: q, d, and r.2. Load data3. Generate an initial solution randomly, evaluate it according to Eq. (2), let nfe=1, and record the solution to be the global best.4. Initialize the pheromone matrix (= 10−8 following Keskinturk et al.)5. While nfe<maxnfea. For each anta.1. Construct a new solutiona.2. Evaluate the new solution, and increment nfe by one.a.3. Apply the local search procedure to each ant solution until a better solution is found within the specified maximal number of iterations.a.4. Replace the ant solution if improved after local search.End forb. Update the pheromone matrix with the ant solutions according to Eqs. (8) and (9)c. Update the global best solution if appropriate.End whileThis hybrid simulated annealing algorithm incorporates the tabu list with dynamic tenure and aspiration criterion concepts in tabu search into the simulated annealing algorithm to prevent visiting the same search area unless necessary. The simulated annealing algorithm simulates the physical material annealing process, in which the temperature is gradually reduced from the starting temperature, Ts, according to a cooling schedule (a simple cooling rate, α, is often sufficient) during the search process. At each temperature, a number of iterations take place in an attempt to find a better solution within the pre-specified maximal number of iterations, maxitr. At each temperature, the tabu list is also resized randomly between the pre-specified maximum, TLmax, and minimum, TLmin.Three trial solutions are generated by three different operators in each iteration. The first operator inserts a job (truck) randomly selected from the machine (door) with longest completion time right after another job (truck) randomly selected from the machine (door) with shortest completion time. The second operator implements a random pairwise swap on the current schedule. The two jobs (trucks) swapped could come from the same machine (door) or different machines (doors). The third operator adds another step to the first operator. In other words, a temporary solution is first obtained by the first operator, followed by a random pairwise swap on the machine with the shortest completion time before a job being inserted. All three trial solutions are evaluated and sorted. In the order starting from the best, a trial solution is acceptance if not tabooed or meeting the aspiration criterion.One unique feature of the simulated annealing algorithm is its ability to escape from local minima by accepting a worse neighborhood solution with some probability. The probability function is usually defined as a function of both the temperature, T, and the magnitude of the worse solution compared to the current solution, Δ=Cns−Ccur. Several different probability functions have been proposed; this study elects to use the following one:(10)Prob=TT2+Δ2The trial solution accepted by tabu search is then determined whether to be accepted according to Eq. (10). The current best and global best solutions are then updated.The pseudo code of the fourth hybrid, called hSATS for short, is summarized below.Algorithm: hSATS.1. Load data.2. Specify algorithmic parameter (Ts, α, maxitr, maxnfe, TLmax, TLmin).3. Define number of machines (doors) and number of jobs (trucks).4. Randomly generate an initial solution, evaluate its makespan, and set the evaluation counter, nfe=1.5. Make the initial solution be the current best and the global best.6. Set current temperature T=Ts.7. While nfe<maxnfea. Initialize the iteration counter, itr=1.b. While itr<maxitrb.1. Generate and evaluate three trial solutions, increment nfe by 3, and sort them.b.2. For each trial solution starting from the bestb.2.1. Accept it if it is not tabooed or if it is tabooed and meets the aspiration criterion and break from the loop.b.3. Accept the trial solution accepted by tabu search if it is better than the current best or accept a worse solution with a probability computed as Eq. (10).b.4. Update the current best solution, the tabu list, and the global best solution if needed.c. End while itrd. Update the temperature according to the cooling rate.e. Randomly adjust the tabu list size to be between the maximum, TLmaxand the minimum, TLmin.8. End WhileThis hybrid is composed of two metaheuristic algorithms: simulated annealing for machine (door) assignment and differential evolution for job (truck) sequencing. At each annealing temperature, each metaheuristic algorithm attempts to improve the solution based on the half of the current best solution found by the other algorithm. At each temperature, a number of iterations take place in an attempt to find a better solution within the pre-specified maximal number of iterations, maxitr. For each iteration, a trial solution is generated by a random pairwise swap operation on the current best solution, followed by a mutation operation with certain probability pm, which changes the assignment for a randomly selected value other than the one currently assigned for a randomly selected job (truck).The differential evolution algorithm adopted here is the modified version proposed by Angira and Babu [27]. It maintains only one array (of the population), instead of two arrays as the original. This array is updated as and when a better solution is found (the minute that a trial vector is selected). These newly found better solutions are allowed to take part in the mutation and crossover operations in the evolution of the entire population with size NP at the same annealing temperature. At each temperature, each solution vector in the population has to serve once as the target vector so that totally NP competitions take place. For each target vector, the DE's mutation operator generates a new parameter vector, called the mutated vector, by adding the weighted difference between two population vectors to a third vector, hence the name of differential evolution. These three vectors are randomly chosen and must be different from the target vector. Hence, NP must be at least 4. Let xi, i=1,…,NP, be the target vector, a mutated vector is generated according to(11)mi=xr1+F(xr2−xr3),where r1, r2, and r3 are mutually different random indexes taking from {1, 2,…,NP}, and are not equal to i. F in the above equation is a constant real value ∈ [0,2], which controls the amplification of the differential variation between the second and the third randomly chosen population vectors, i.e., (xr2−xr3).Each mutated vector is subjected to parameter mixing using the crossover operation and the resultant vector is called the trial vector. The trial vector, ti={ti1,…,tij,…,tiD}, where D is the dimension of the problem defined by the number of variables, is obtained from the mutated vector according to(12)tij=mijifrand(j)≤CRorj=rnbr(i)xijifrand(j)>CRandj≠rnbr(i)where rand(j) is the jth component of a D-dimensional uniform random number ∈ [0,1] and rnbr(i) is a randomly chosen index ∈ {1,…,D} to ensure that at least one mutated dimensional value is used in the trial vector. CR denotes the crossover threshold. If the trial vector yields a lower cost function value than the target vector for a minimization problem, then the trial vector replaces the target vector.The pseudo code of the fourth hybrid, called hSADE for short, is summarized below.Algorithm: hSADE.1. Load data.2. Specify algorithmic parameter (Ts, α, maxitr, maxnfe).3. Define the domain ranges of variables.4. Randomly generate an initial solution, evaluate its makespan, and set the evaluation counter, nfe=1.5. Make the initial solution be the current best and the global best.6. Set current temperature T=Ts.7. While nfe<maxnfec. Initialize the iteration counter, itr=1.d. While itr<maxitrb.1. Generate a new assignment and combine it with the current best sequence found by DE to construct a candidate schedule.b.2. Evaluate the candidate schedule and increment nfe by 1.b.3. Accept the new assignment if the candidate schedule is better than the current solution or accept a worse solution with a probability computed as Eq. (11), update the current best and global best solutions, and break from the while loop; else increment itr by 1.c. End while itrd. For each target vectord.1. Randomly find three other vectors different from the target vector from the population of vectors.d.2. Generate the mutated vector according to Eq. (11).d.3. Generate the trial vector according to Eq. (12).d.4. Convert the real-valued trial vector to sequence by sorting in ascending orderd.5. Combine the trial sequence with the current best assignment found by SA to construct a candidate schedule.d.6. Evaluate the candidate schedule and increment nfe by 1.d.7. Replace the target vector with the trial vector if the solution improves and update the global solution if appropriate.e. Update current temperature by applying the cooling rate.8. End whileFor the 1st variant of hACO, by fixing sar at 10 times of the problem dimension (equaling to the number of jobs), a 33 factorial design with ants={25, 50, 75}, q, ξ={0.5, 0.7, 0.9} is executed to determine the optimal set of parameter values that minimize the makespan of the 4m50j-1 dataset, i.e., the first instance of the dataset involving scheduling 50 jobs on 4 unrelated parallel machines. The ANOVA results indicate that ξ is the only one significant factor at α=0.05 and the lower ξ is the better. For the 1st variant, the following set of parameter values: ants=25, q=0.7, and ξ=0.5 produce the lowest mean makespan and hence are used in subsequent testing.For the 2nd variant of hACO, by fixing ants=25 and a=1, a 33 factorial design with b={1, 2, 3}, ρ={0.1, 0.2, 0.3}, and ϕ={0.1, 0.2, 0.3} is executed to determine the optimal set of parameter values that minimize the makespan of the 4m50j-1 dataset. The ANOVA results indicate that ρ and b are statistically significant with p-value close to 0. For the 2nd variant, the following set of parameter values: b=3, ρ=0.3 and ϕ=0.2 produce the lowest mean makespan and hence are used in subsequent testing.For the 3rd variant of hACO, by fixing ants=25, a 33 factorial design with ρ={0.1, 0.2, 0.3}, q={0.1, 0.2, 0.3}, and d={0.4, 0.5, 0.6} is executed to determine the optimal set of parameter values based on the same dataset, i.e., 4m50j-1. The ANOVA results indicate that no factor is statistically significant. Nevertheless, the following set of parameter values: ρ=0.2, q=0.2 and d=0.6 that produce the lowest mean makespan is used in subsequent testing.For the hSATS hybrid, by fixing the starting annealing temperature, Ts, at 100, two parameters, i.e., maximal number of iterations at each temperature, maxitr, and cooling rate, α, are varied at three levels each, i.e., maxitr ={50, 75, 100} and α={0.9, 0.95, 0.98} in a 23 factorial design. The ANOVA results indicate that no factor is statistically significant. Again, the set of parameter values producing the lowest mean makespan is used in subsequent testing; that is, maxitr=100, α=0.9, and Ts=100.For the hSADE hybrid, a 33 factorial design, with pm={0.5, 0.7, 0.9}. F={0.3, 0.5, 0.7} and CR={0.1, 0.5, 0.9}, is executed while fixing the SA parameters at the optimal values chosen for the hSATS hybrid. The ANOVA results indicate that neither main factors nor interaction factors are statistically significant. The parameter values that produce the lowest mean makespan are pm=0.9, F=0.3, CR=0.5; they are hence used in subsequent testing.All five hybrid metaheuristics were coded in matlab. Throughout this study, the computer used to carry out all computational experiments is a Dell Vostro 1510 laptop equipped with Intel Core 2 Duo CPU T9300 @ 2.50GHz, 2.49GHz.Two groups of data were randomly generated for testing. One group assumes that jobs (trucks) are weighted and all jobs (trucks) are available at time zero, i.e., zero release time. The other group assumes that jobs (trucks) are not weighted and all jobs (trucks) arrive at different time, i.e., nonzero release time. Note that all five hybrids can be tested with both group of data but a different evaluation module must be used for each group of data.Table 1summarizes the major characteristics of the first group of datasets generated for testing. For comparing all five hybrids, seven selected datasets with 3 replicates each (21 total) were tested with the objective to minimize the makespan. To capture the stochastic behavior of metaheuristic, each algorithm is applied to each dataset repeatedly for 25 times. The reason for not using all datasets in the comparison is because of its excessive long computational time involved in the 3rd hACO variant. Note that the largest dataset tested in the original paper by Keskinturk et al. [20] from which the 3rd variant is modified is 6-machine 60-job only.The test results of makespan and CPU time are summarized in Tables 2 and 3in terms of the mean and standard deviation, respectively. These results indicate that by using maxnfe=10,000 as the stopping criterion, the 2nd variant of hACO finds the best solution with the lowest makespan for nearly all datasets, except one, i.e., 4m75j-3. The second and third best hybrids are hSATS and hSADE, respectively. However, hACO requires more computational time than hSATS and hSADE. Among all five hybrids, the hSATS is the most efficient. In the next section, it will be shown that hSATA outperforms hACO 2 if given the same amount of computational time as taken by the latter. Tables 4 and 5give the results obtained by hACO 2, hSATS, and hSADE for other datasets from Table 1 (the other two hACO variants were not run for these datasets due to high computational time required). The same observations made earlier pretty much hold.Fig. 1shows the convergence process of all five hybrid metaheuristics in processing a selected dataset, i.e., 6m100j-1. For each algorithm, two profiles are shown with one profile tracking the convergence of the mean of the population means obtained in all 25 runs while the other profile showing the convergence of the mean of the population bests in all runs. The first profile is of course expected to be above the second profile until the very end of the search process, at which point both profiles might or might not converge. For the hSATS hybrid, the two profiles are identical because it is a trajectory based metaheuristc with population size of one. For this particular dataset, both profiles are close together for the 2nd variant of hACO and hSADE whereas far apart for other two variants of hACO, particularly the 3rd variant. Note that the population mean of hACO 2 (and more so for hACO 3) actually might get worse throughout the search, which is possible because there is no guarantee that each individual ant will always improve over its previous search (in other words, there is a chance for an ant to construct a worse solution).The major characteristics of the second group of test data are given in Table 6. For comparing the five hybrids, the test results of selected datasets are given in Table 7for both the mean and standard deviation of makespan and CPU time. Again, the reason for not using all datasets in the comparison is because of its excessive long computational time required by the 3rd variant of hACO. Just like the first group of data, by using maxnfe=10,000 as the stopping criterion, the 2nd variant of hACO finds the best solution with the lowest makespan for nearly all datasets, except one, i.e., 5d100t. The second and third best are hSATS and hSADE, respectively. However, hACO requires more computational time than hSATS and hSADE. Among all five hybrids, the hSATS is again the most efficient as expected. Table 8gives the results obtained by the 2nd variant of hACO, hSATS, and hSADE for other datasets from Table 6. The same observations made earlier still hold.Tukey's tests available in MiniTab were applied to determine whether the performances of the five hybrid metaheuristics are statistically different for makespan and CPU time separately (at α=0.05). Because of the high variance among test datasets, Tukey's tests thus were performed by individual dataset (without distinguishing instances of the same dataset). The test results are summarized in Table 9, which indicate that:(i)In terms of makespan, variants 1 and 3 of hACO are often in the same group (8 out of 11 datasets) having the highest mean makespan, hSADE is often standalone (9 out of 11) with the second highest mean makespan, and the 2nd variant of hACO and hSATS are often in the same group (7 out of 11) with the lowest mean makespan.In terms of CPU time, variant 3 of hACO is always alone and requires the longest time in every dataset. The hSATS hybrid has the lowest mean CPU time, but often statistically insignificant from hSADE (7 out of 11 datasets).In summary, all the results obtained in the two applications strongly indicate that the 2nd hACO variant, i.e., 2-stage_hACO, is the best among the five hybrids if maxnfe is used as the stopping criterion. Further analyzing the results obtained by the 2nd variant of hACO, it is found that makespan increases with number of jobs/trucks and decreases with number of machines/doors, which are expected. Analyzing the second group of data, it is found that CPU time seems to be affected more by number of jobs/trucks than by number of machines/doors. For each application, ANOVA tests were carried out to determine the significant effect of each factor on makespan and CPU time. The ANOVA test results indicate that: (i) both factors, i.e., number of machines (doors) and jobs (trucks), are statistically significant (p-value=0) to both responses, i.e., makespan and CPU time, for the first group of data, and (ii) for the 2nd group of data both factors are statistically significant (p-value=0) to makespan but only the factor of number of jobs (trucks) is statistically significant to CPU time.

@&#CONCLUSIONS@&#
This paper has presented five hybrid metaheuristics, including three variants of hybrid ant colony optimization developed for unrelated parallel machine scheduling and inbound trucks sequencing problems in a multi-door cross docking system in consideration of sequence-dependent setup times, and zero and nonzero release time. Two groups of datasets were randomly generated for testing with maximal number of evaluations as the stopping criterion. The performance of each hybrid is measured in terms of makespan and CPU time taken. The results obtained in computational experiments for both groups of datasets suggest that:1.The 2nd variant of hACO, i.e., the 2-stage hACO, is the best among the five hybrids, in terms of makespan. However, it requires longer computational time than hSATS and hSADE. Among all hybrids, hSATS is the one that requires the lowest CPU time.The 3rd variant of hACO, i.e., the one-pheromone matrix_hACO, works well on small datasets but not on large datasets. It requires excessive computational time and produces the worst objective values than the other hybrids. Hence, it is not recommended.The effect of using an alternative stopping criterion, i.e., maximal CPU time, was also investigated. The test results suggest that in this case the hSATS hybrid is the best, followed by the 2nd variant of hACO. For the hSATS hybrid, the random pairwise swap operator plays the most dominant role in producing an improved solution compared to the other two operators. The effect of varying release time was also investigated and the results showed that makespan increased with release time, as expected. How the current study can be extended to solve other similar problems was also discussed. Possible topics for future study include considering processing set restriction, or other more realistic situations.