@&#MAIN-TITLE@&#
Order acceptance and scheduling with machine availability constraints

@&#HIGHLIGHTS@&#
We study an order acceptance and scheduling model.The manufacturer is available to process orders only within a number of discontinuous time intervals.We study the approximability of the model and some of its important special cases.

@&#KEYPHRASES@&#
Order acceptance and scheduling,Machine availability constraints,Job rejection,Approximation,

@&#ABSTRACT@&#
We consider an order acceptance and scheduling model with machine availability constraints. The manufacturer (machine) is assumed to be available to process orders only within a number of discontinuous time intervals. To capture the real-life behavior of a typical manufacturer who has restrictions of time availability to process orders, our model allows the manufacturer to reject or outsource some of the orders. When an order is rejected or outsourced, an order-dependent cost of penalty will occur. The objective is to minimize the makespan of all accepted orders plus the total penalty of all rejected/outsourced orders. We study the approximability of the model and some of its important special cases.

@&#INTRODUCTION@&#
Order acceptance and scheduling (OAS) has attracted considerable attention from scheduling researchers as well as production managers who practice it in the past a few decades. The key issue in OAS is to balance order acceptance (to increase revenue and guarantee satisfaction to customers) and order rejection (to reduce production load so as to meet production capacity restrictions). In traditional OAS models the manufacturer (machine) is usually assumed to have the capacity of processing orders continuously. But in reality, production could be interrupted due to some potential reasons such as machine breakdown/maintenance, production setup, and worker vacation, which leads to the scenario that there are only a number of discontinuous time intervals available to process the orders in question. When production capacity and machine available time have restrictions, to reduce production load, the manufacturer may have to reject some orders which have long processing times but contribute relatively small profits, or outsource the production of some orders, in which case the profit of those outsourced orders is reduced. In this paper we study a single-machine OAS model with machine availability constraints. In the proposed model, the manufacturer (machine) is available to process orders only within a number of given discontinuous time intervals, and she is allowed to reject some orders. When an order is rejected, an order-dependent penalty will occur. The manufacturer needs to balance the production capacity (the makespan of completing all accepted orders) and the total penalty of all rejected jobs.OAS has been studied extensively in the production scheduling literature. Guerrero and Kern (1988) provided the rational how to accept and reject orders effectively. Slotnick and Morton (1996) and Ghosh (1997) studied single-machine OAS with the objective of maximizing revenue minus weighted lateness penalties. Slotnick and Morton (2007) extended their previous work (Slotnick & Morton, 1996) by replacing lateness with tardiness in the objective function. Rom and Slotnick (2009) developed a genetic algorithm for the same problem and compared it with the myopic heuristic given in Slotnick and Morton (2007). Talla Nobibon and Leus (2011) studied an OAS model with “firm planned orders as well as potential orders”. Oguz, Salman, and Yalcin (2010) included sequence-dependent setup times and two-level due-dates in an OAS model with weighted tardiness. Cesaret, Oguz, and Salman (2012) developed a tabu algorithm for the same problem and compared it with the two heuristics proposed in Oguz et al. (2010). Yang and Geunes (2007) considered an OAS model with controllable processing times. Chen and Li (2008), Lee and Sung (2008, 2008) and Qi (2008, 2009, 2011) considered OAS models with outsourcing options. An excellent literature survey on the topic of OAS is provided by Slotnick (2011) recently.OAS is actually equivalent to machine scheduling with rejection (MSR) in mathematics. Bartal, Leonardi, Marchetti-Spaccamela, Sgall, and Stougie (2000) first introduced a multi-processor MSR model to minimize the makespan of all accepted jobs plus the total rejection penalty of all rejected jobs. Seiden (2001) and Hoogeveen, Skutella, and Woeginger (2003) studied the on-line version and the off-line version in Bartal et al. (2000) when job preemption is allowed, respectively. Epstein, Noga, and Woeginger (2002) considered on-line MSR with unit-processing-time jobs and the total completion time of all accepted jobs. Engels et al. (2003) studied single-processor MSR with total weighted completion times of all accepted jobs, and recently, Kellerer and Strusevich (2013) improved the related results. MSR models with industrial applications are studied by Cheng and Sun (2009), Zhang, Lu, and Yuan (2009, 2010), Lu, Zhang, and Yuan (2008), Lu, Cheng, Yuan, and Zhang (2009), among others. A very recent survey on MSR is provided by Shabtay, Gaspar, and Kaspi (2013). All of the OAS and MSR models mentioned above have the potential assumption that machines can process jobs continuously, which differ from our model.Our model is an extension of machine scheduling with availability constraints (MSAC). MSAC also has been studied extensively. The surveys of MSAC are provided by Schmidt (2000) and Ma, Chu, and Zuo (2010). In this paper we consider a single machine model and the criterion of all accepted jobs is to minimize the makespan. Therefore, in the following we only review the previous work of MSAC with a single machine, and whose objective is limited to minimization of makespan. For convenience, define MSAC-k to be the MSAC problem to minimize makespan with a single machine and k time intervals during which the machine is not allowed to process jobs. Lee (1996) showed that MSAC-1 has been NP-hard, and that MSAC-k is NP-hard in the strong sense if k is arbitrary. He, Ji, and Cheng (2005) proposed a fully polynomial time approximation scheme (FPTAS) for MSAC-1. Breit, Schmidt, and Strusevich (2003) showed that no polynomial time approximation algorithm with a fixed performance ratio exists for MSAC-2. When every job also has a delivery time, Yuan, She, and Ou (2008) showed that MSAC-k can be solved by a pseudo-polynomial time algorithm if k is fixed. They also developed a polynomial time approximation scheme (PTAS) for MSAC-1. Kacem (2009) studied a similar problem to Yuan et al. (2008), and proposed an FPTAS by exploiting the well-known approach of Ibarra and Kim (1975). Wu and Lee (2003), Gawiejnowicz (2007), and Ji, He, and Cheng (2006) studied MSAC with deterioration, where the processing time of a job is a linear function of its starting time. To the best of our knowledge, our model is the first to examine OAS with machine availability constraints.We now describe our problem formally as follows. Given a set of n jobs J={J1,J2,…,Jn} and a single machine, each job Jj∈J is associated with a processing time pjand a rejection penalty wj. Job Jjis either accepted and then processed on the machine, or it is rejected by the machine and then a rejection penalty wjis paid. Penalty wjis regarded as the cost of losing or outsourcing job Jj. Also given 2m+1 integers a0,a1,…,a2msuch that 0=a0<a1<⋯<a2m, we assume that in the planning horizon the machine is available to process jobs within time intervals [a2m, +∞) and [a2i−2, a2i−1] for i=1,2,…,m, but it is not allowed to process any job during time interval (a2i−1, a2i) for any i=1,2,…,m. In order words, there are m UIs (time intervals during which the machine is not allowed to process jobs) and m+1 AIs (time intervals during which the machine is allowed to process jobs) in the planning horizon. Let A be the set of jobs accepted, and R=J⧹A be the set of jobs rejected. Define Cmaxto be the makespan of A, i.e., the completion time of the last accepted job. The problem is to determine A and a feasible schedule of jobs in A on the machine so as to minimize the objective functionZ=Cmax+∑Jj∈Rwj, i.e., the makespan of all accepted jobs plus the total penalty of all rejected jobs. Denote the proposed problem with m UIs (or, equivalently, m+1 AIs) by P(m).In our model, we assume that the machine can process at most one job at a time, that job preemption is not allowed, and that pjand wjare non-negative integers for j=1,2,…,n. For convenience, we introduce the following notations, which will be used throughout the paper:P=∑Jj∈Jpjthe total processing time of all the jobs;U={Jj∈J∣wj>pj}the set of jobs with processing times less than their rejection penalty;V={Jj∈J∣wj⩽pj}the set of jobs with processing times no less than their rejection penalty;P(U)=∑Jj∈Upjthe total processing time of all the jobs in U;σ∗the optimal solution;A∗the set of all accepted jobs in σ∗;R∗=J⧹A∗the set of all rejected jobs in σ∗;Cmax∗the makespan of A∗, i.e., the completion time of the last accepted job in A∗.Z∗=Cmax∗+∑Jj∈R∗wjthe objective function value of σ∗;a2m+1=a2m+Pthe largest possible makespan of all accepted jobs in σ∗;Li=a2i−a2i−1the length of the ith UI (i=1,2,…,m);Li′=a2i-1-a2i-2the length of the ith AI (i=1,2,…,m+1).Note that if P(U)⩽a1, it is easy to obtain an optimal solution where all the jobs in U are accepted and all the jobs in V are rejected. Also note that if there exists some α∈{1,2,…,m} such thatLα′⩾P, then it is easy to show that no job should be processed after a2α−1 in any optimal solution. Thus, we can ignore the UIs after a2α−1 without destroying optimality if such α exists. Without loss of generality, in the remainder of this paper we assume P(U)>a1 and(1)Li′<P(i=1,2,…,m).The rest of the paper is organized as follows. In Section 2 we develop a pseudo-polynomial algorithm to solve problem P(m) when m is fixed. In Section 3 we provide non-approximability results to problem P(m) when m>1. In Section 4 we present an FPTAS for the special case P(1). In Section 5 we develop a (2+∊)-approximation for the special case withLi′=L′and Li=L for i=1,2,…,m. Some concluding remarks are provided in Section 6.Note that if m is arbitrarily, then it is easy to show that problem P(m) is NP-hard in the strong sense by reducing from 3-PARTITION, and thus an optimal pseudo-polynomial algorithm for P(m) does not exist (Garey & Johnson, 1979). Therefore, in the remainder of this section, we assume that the value of m is fixed. We will present a pseudo-polynomial algorithm to solve P(m) when m is fixed.ConsiderCmax∗, the makespan of all accepted jobs in optimal solution σ∗. Assume thata2μ-2<Cmax∗⩽a2μ-1for some μ∈{1,2,…,m+1}, i.e., the last accepted job in σ∗ is processed and completed within the μth AI [a2μ−2, a2μ−1]. Provided the value of μ, we will present a pseudo-polynomial algorithm to solve P(m) in the following.We first study the situation when μ=m+1, in which case we will develop an O(nPm) optimal dynamic program (DP) to solve P(m). Define J0 to be a dummy job with zero processing time, and fix J0 to be accepted and processed on the machine at time a2m(i.e., J0 is the first accepted job processed within the last AI). We schedule J0 before the scheduling of any job in our DP. Scheduling J0 has a contribution of a2mto the objective function value. Due to the existence of J0, for any job Jj(j=1,2,…,n), no matter it is rejected, or processed within the (m+1)th AI, its contribution to the value of the objective function is equal topj′=min{pj,wj}.Based on such an insight, we are now ready to present our DP for the case with μ=m+1. Our DP will keep track of the total processing time of the jobs scheduled within each of the first m AIs when scheduling the n jobs one by one. Denote the problem instance containing only the first j jobs J1,J2,…,Jjby Ij. For any j=1,2,…,n andgi=0,1,…,Li′, define Gj(g1,…,gm) as the minimum total cost to Ijsuch that the total processing time of all accepted jobs assigned to AI [a2i−2, a2i−1] is equal to gifor i=1,2,…,m. To develop recursive relations, consider the following two cases:Case a. Job Jjis rejected, or it is processed within the (m+1)th AI. In this case, we haveGj(g1,…,gm)=Gj-1(g1,…,gm)+pj′.Case b. Job Jjis accepted and scheduled to the ith AI for some i∈{1,2,…,m}. In this case, we should have gi⩾pjand Gj(g1,…,gm)=Gj−1(g1,…,gi−1,gi−pj,gi+1,…,gm) as Jjdoes not contribute to the value of the objective function.Combining the two cases above, we have the following dynamic program DP1:(I)Recurrence relation: For j=1,2,…,n, i=1,2,…,m andgi=0,1,…,Li′,Gj(g1,…,gm)=minGj-1(g1,…,gm)+pj′,min1⩽i⩽ms.t.gi⩾pj{Gj-1(g1,…,gi-1,gi-pj,gi+1,…,gm)}.Boundary condition:G0(g1,…,gm)=a2m,ifg1=g2=⋯=gm=0;+∞,otherwise.Objective:minGn(g1,…,gm)|1⩽i⩽m,0⩽gi⩽Li′,∑i=1,2,…,mgi⩽P.Consider the complexity of DP1. Note thatLi′<Pfor i=1,2,…,m (by (1)). The recursive function has at most O(nPm) states for Gj(g1,…,gm), and each recursion can be calculated in O(m)=O(1) time. Therefore, DP1 has a complexity of O(nPm).We now study the situation when μ⩽m. For this case, we develop another DP to solve the problem. The new DP is similar to DP1, but it needs to keep track of the total processing time of the jobs processed within each of the first μ AIs. It is not difficult to design such a DP with complexity of O(nPμ). We would like to point out that the new DP is actually applicable to the situation when μ=m+1, but the corresponding time complexity is O(nPm+1). To reduce complexity, we develop DP1 to handle the situation when μ=m+1 additionally, so that the overall time complexity of our algorithm is bounded by O(nPm). We thus have the following theorem.Theorem 1ProblemP(m)can be solved in O(nPm) time when m is fixed.In this section, we study the approximability of problem P(m). We will show that P(m) does not admit a polynomial time approximation algorithm with a constant worst-case bound when m>1, and that a 2-approximation exists for the special case with P(U)⩾a2m. As we will use the well-known NP-hard problem PARTITION (Garey & Johnson, 1979) in our analysis, for convenience, we state PARTITION in advance here: Given a set of t positive integers S={e1,e2,…,et} such that∑i=1tei=2B. The question is to decide if there is a subset S′⊆S such that∑ei∈S′ei=∑ei∈S⧹S′ei=B.Theorem 2When m>1, problemP(m)does not admit a polynomial time approximation algorithm with worst-case bound better than 2nunless P=NP.We use the gap reduction from PARTITION. Given an instance I of PARTITION, construct an instance I′ of P(m) as follows. There are n=t jobs, where the processing time and rejection penalty of job Jjare (pj, wj)=(ej, 2n(2B+1)) for j=1,…,t. There are m=2 UIs: (a1, a2)=(B, B+1) and (a3, a4)=(2B+1, 2n(2B+1)). Such an instance can be constructed in polynomial time. Consider the optimal solution value of instance I′. It is obvious that the optimal solution value of I′ is no less than 2B+1. If we reject one job, the total penalty is no less than 2n(2B+1). Also, if there exists a job processed after time 2n(2B+1), the corresponding makespan also will be no less than 2n(2B+1). Thus, to obtain a solution value of 2B+1 is equivalent to find a subset of jobs with a total processing time of B, so that all of the jobs in the subset are processed on the machine within interval [0, B] without any idle time, while all of the rest of the other jobs are processed on the machine within interval [B+1, 2B+1] also without any idle time. This is equivalent to a solution to PARTITION. If it fails to find out such a subset of jobs, then solution value is at least 2n(2B+1), which is 2ntimes of 2B+1. This completes the proof. □Through such the proof above, we can see that if a2m, the ending point of the last UI, is much larger than total processing time P(U), then it is impossible to develop a polynomial approximation algorithm with a constant worst-case bound. However, as we will show it later, if P(U)>a2m, i.e., the total processing time in U is greater than the ending point of the last UI, then a very simple heuristic with a worst-case bound of 2 can be developed. The heuristic is denoted by H1, which is described as follows: Reject all jobs in V, and let all jobs in U be accepted and processed within time interval [a2m, +∞) as early as possible in any job sequence. LetZH1be the objective function value of the solution generated by heuristic H1. We have the following theorem.Theorem 3ZH1⩽2Z∗if P(U)>a2m.Note that we have Z∗>a2mif P(U)>a2m. Remember that A∗ and R∗ are the set of all accepted jobs and the set of all rejected jobs in the optimal solution, respectively. We then haveZ∗⩾∑Jj∈A∗pj+∑Jj∈R∗wj⩾∑Jj∈A∗min{pj,wj}+∑Jj∈R∗min{pj,wj}=∑Jj∈Jmin{pj,wj}=∑Jj∈Umin{pj,wj}+∑Jj∈Vmin{pj,wj}=∑Jj∈Upj+∑Jj∈Vwj=P(U)+∑Jj∈Vwj.Thus,ZH1=a2m+P(U)+∑Jj∈Vwj<2P(U)+∑Jj∈Vwj⩽2P(U)+∑Jj∈Vwj⩽2Z∗.This completes the proof. □When P(U)>a2m, the following theorem shows that the worst-case bound of 2 cannot be improved unless P=NP. Let ∊>0 be any given small constant such that1∊is a positive integer.Theorem 4If P(U)>a2m, problemP(m)does not admit a polynomial time approximation algorithm with worst-case bound better than 2−∊ unless P=NP, even when m=2.We use the gap reduction from PARTITION again. Given an instance I of PARTITION, construct an instance I″ of P(m) as follows. Letd=2B+4∊. There are n=t+1 jobs, where the processing time and rejection penalty of Jjare (pj, wj)=(ej, 2B+1+d) for j=1,…,t, and (pt+1, wt+1)=(d+2, d+3). There are m=2 UIs: (a1, a2)=(B, B+1) and (a3, a4)=(2B+1, 2B+1+d). Such an instance construction can be done in polynomial time. It is obvious that U={J1,J2,…,Jt+1} and V=∅. Hence, we have P(U)=2B+2+d>2B+1+d=a4=a2m.Suppose that there is a polynomial time approximation algorithm A for solving I″ such that Z′⩽(2−∊)Z∗, where Z′ is the objective function value of the solution generated by A.Consider the answer to instance I. On one hand, if instance I has a “YES” answer, then there exists a subset S′⊆S such that∑ei∈S′ei=∑ei∈S⧹S′ei=B. Consider the following solution to instance I″: Accept all of jobs corresponding to S′ and schedule them within AI [0, B]; also accept all of jobs corresponding to S⧹S′ and schedule them within AI [B+1, 2B+1]; reject job Jt+1. It is easy to check that the objective function value of such a solution is equal to 2B+4+d, which is optimal. Note that d·∊=2B+4. We thus haveZ′⩽(2-∊)Z∗=(2-∊)(2B+4+d)=2B+4+2d-∊(2B+4)<2B+4+2d.On the other hand, if instance I has a “NO” answer, then there does not exist a subset S1⊆S such that∑ei∈S′ei=∑ei∈S⧹S′ei=B. As a result, at least one job among J1,J2,…,Jtis scheduled to neither interval [0, B] nor [B+1, 2B+1]. Without loss of generality, assume such a job to be Jk, where k∈{1,2,…,t}. Then, there are two possible cases: Either Jkis rejected, or Jkis accepted and processed within interval [2B+1+d, +∞) on the machine. If job Jkis rejected, we haveZ′⩾wk+wt+1=(2B+1+d)+(d+3)=2B+4+2d.If Jkis accepted and processed within interval [2B+1+d, +∞), it is easy to check that Jt+1 should also be processed within interval [2B+1+d, +∞). The corresponding objective function value determined by algorithm A should haveZ′⩾a2m+pt+1+pk=(2B+1+d)+(d+2)+pk=2B+3+2d+pk.Note that pk=ekis a positive integer. Thus,Z′⩾2B+4+2d.In any case, we have Z′⩾2B+4+2d when instance I has a “NO” answer.The above analysis indicates that if Z′<2B+4+2d, then instance I has a “YES” answer; Otherwise, I has a “NO” answer. Consequently, we can use approximation algorithm A to solve PARTITION in polynomial time, which is a contradiction unless P=NP.□In this section we study problem P(1), where there is only one UI in the time horizon. Denote the unique UI by (a, b). Note that P(1) has been shown to be NP-hard when job rejection is not allowed (see Lee, 1996), which indicates that P(1) is NP-hard in general. We will present an FPTAS to P(1). A family of algorithms {A∊∣∊>0} is called an FPTAS of a minimization problem if A∊is a (1+∊)-approximation running in polynomial time in the input size and1∊for each given ∊.We will use the classical 0–1 Min-Knapsack Problem (Min-KP) (Kellerer, Pferschy, & Pisinger, 2004) in our analysis. For convenience, we state Min-KP in advance here: Given a knapsack and a set of items; the size of the knapsack is given; associated with each item is a given size and a given profit. The problem is to select a subset of items into the knapsack so as to minimize the total profit of all unselected items. It is well-known that an FPTAS exists for solving Min-KP (see Kellerer et al., 2004).We now present an FPTAS to P(1) based on the FPTAS to Min-KP. Our analysis is partitioned into the following two cases: (i)Cmax∗>band (ii)Cmax∗⩽a.Case (i):Cmax∗>b. In this case, it is easy to see that all jobs in U are accepted and processed on the machine in σ∗, the optimal solution to P(1). However, some jobs in V might be scheduled within interval [0, a] in σ∗. In other words, we have(2)U⊆A∗Let Qabe the set of all unselected items corresponding to U inσˆa, and Rabe the set of all unselected items corresponding to V inσˆa. By the definition of Pa, we have(7)Za∗=∑j∈Qapj+∑j∈Rawjand(8)∑j∈{1,2,…,n}⧹(Qa∪Ra)pj⩽a.LetQa′⊆Ube the job set corresponding to Qa, and letRa′⊆Vbe the job set corresponding to Ra. To prove Eq. (6), on one hand, ifb+Za∗<Z∗, we can construct a better solution to P(1) as follows: Reject all jobs inRa′, accept all jobs inJ⧹Ra′, process all jobs inQa′on the machine after time b as early as possible in any sequence, and process all jobs inJ⧹Ra′∪Qa′on the machine within time interval [0, a] in any sequence. Consider the feasibility of such a solution to P(1). Note thatQa′⊆U=J⧹V⊆J⧹Ra′,i.e., it is feasible to partitionJ⧹Ra′into two subsets:Qa′andJ⧹Qa′∪Ra′. By (8), we have∑Jj∈J⧹Qa′∪Ra′pj=∑j∈{1,2,…,n}⧹(Qa∪Ra)pj⩽a,i.e., such a solution to P(1) is feasible. However, by (7), the objective function value of such a solution to P(1) is equal tob+∑Jj∈Qa′pj+∑Jj∈Ra′wj=b+∑j∈Qapj+∑j∈Rawj=b+Za∗<Z∗,which is a contradiction to the optimality of σ∗. On the other hand, ifb+Za∗>Z∗, we can construct a better solution to Paas follows: Select all items corresponding to J⧹(Q∪R∗) to the knapsack. By (5) and the definition of Pa, such a solution is feasible. By (2)–(4) and the definition of Pa, the objective function value of such a solution to Pais equal to∑Jj∈Qpj+∑Jj∈R∗wj=Z∗-b<Za∗,which is a contradiction to the optimality ofσˆa. Thus, Eq. (6) holds.We now show that based on the FPTAS to Min-KP, we can develop an FPTAS to P(1) whenCmax∗>beasily. Assume thatA∼∊is a (1+∊)-approximation algorithm to Min-KP. Apply algorithmA∼∊to solve auxiliary problem Pa. LetZ(A∼∊)be the objective function value of the solution after applyingA∼∊to Pa. We have(9)Z(A∼∊)⩽(1+∊)Za∗.Note that based on the solution generated by algorithmA∼∊, we can obtain a feasible solution with an objective function value ofb+Z(A∼∊)for problem P(1). Thus, using such an approach to obtain a solution to P(1), by (6) and (9), we haveb+Z(A∼∊)Z∗=b+Z(A∼∊)b+Za∗⩽b+(1+∊)Za∗b+Za∗=1+∊Za∗b+Za∗⩽1+∊,i.e., such an approach is a (1+∊)-approximation algorithm to problem P(1), and the time complexity is the same as the one ofA∼∊. In other words, whenCmax∗>b, there exists an FPTAS to P(1) with the same time complexity as the FPTAS to Min-KP.Case (ii):Cmax∗⩽a. In this case, it is easy to see that it is optimal to reject all the jobs in V, and that P(U)>a. Without loss of generality, we assume V=∅ in this case. Note that in the optimal solution to P(1) in this case,(10)Z∗=∑Jj∈A∗pj+∑Jj∈R∗wj=∑Jj∈Upj-∑Jj∈U⧹A∗pj+∑Jj∈R∗wj=P(U)-∑Jj∈R∗pj+∑Jj∈R∗wj=P(U)+∑Jj∈R∗(wj-pj).Summarizing the analysis of Cases (i) and (ii), we have presented an FPTAS to P(1) with the same time complexity as the FPTAS to Min-KP. So far, the best FPTAS to Min-KP is designed by Kellerer and Pferschy (1999, 2004, 2004) with the time complexity of O(n/∊). Therefore, we have the following theorem.Theorem 5There exists an FPTAS to problemP(1)in O(n/∊) time.For the variant of P(m) when job preemption is allowed, it is easy to show that such a variant is actually equivalent to problem P(1). Thus, P(m) is still NP-hard even when job preemption is allowed, and an FPTAS exists for such a variant.In this section we consider the special case of P(m) when the length of each AI is identical, and the length of each UI is also identical, i.e.,Li′=L′and Li=L for i=1,2,…,m. This case happens when the working hour on each day is fixed, or when machine maintenance activities are periodic (Ji, He, & Cheng, 2007). Denote such a special case byP¯e. Without loss of generality, we assume pj⩽L′ and wj>0 for any Jj∈J in problemP¯e(note that if pj>L′ or wj=0, then it is optimal to reject Jj). We still let the optimal solution toP¯ebe σ∗, and letCmax∗and Z∗ be the makespan and the objective function value of σ∗, respectively. Let ∊ be any given small constant such that 1/∊ is a positive integer. We will present an efficient heuristic to solveP¯ewith a tight worst-case bound of 2+∊ in the remainder of this section.In order to develop the desired heuristic, we first partition J into 1+n/∊ subsets. We defineS¯0={Jj∈J|wj>L′+L}andS¯i=Jj∈J(i-1)(L′+L)∊n<wj⩽i(L′+L)∊nfor i=1,2,…,n/∊. For anyJj∈S¯i,i=1,2,…,n/∊, letw̃j=(i-1)(L′+L)∊nbe the modified rejection penalty. Clearly,(12)0⩽w̃j⩽wj⩽w̃j+(L′+L)∊n.DefineI¯to be the problem instance the same as the original problemP¯e, except that the rejection penalty of each jobJj∈S¯i⊆Jis replaced byw̃j=(i-1)(L′+L)∊n,i=1,2,…,n/∊. DefineI¯′to be the problem instance the same asI¯except that jobs in J are resumable, i.e., job preemption is allowed when a job encounters a UI during processing on the machine. Clearly, the objective function value of the optimal solution toI¯′is a lower bound of the optimal solution value toP¯e. Based on such an insight, the major flow of our approach is as follows. We first develop a polynomial-time algorithm to determine an optimal solution toI¯′, based on which we construct a feasible solution toI¯. Based on the constructed solution toI¯, we can obtain a feasible solution to the original problemP¯eby replacing the scaled rejection penalties by the original ones for all rejected jobs in the solution.To start our approach, we first develop a polynomial time algorithm to solveI¯′optimally. LetJ¯=J⧹S¯0and letN=|J¯|be the number of jobs inJ¯. Without loss of generality, we assume that the jobs inJ¯are the first N jobs in J, i.e.,J¯={J1,J2,…,JN}. DefineK=(L′+L)∊nandΔ(x)=x-xL+L′(L+L′)for any x⩾0. For j=1,2,…,N and t=0,1,…,nN/∊, define φj(t) to be the objective function value of the optimal solution to the instance containing only the first j jobs ofJ¯inI¯′, such that the total modified penalty of the first j jobs is equal to tK. To develop recursive relations, consider the following two cases:Case 1. Job Jjis rejected. In this case, we haveφj(t)=φj-1t-w̃jK+w̃j.Case 2. Job Jjis accepted and processed on the machine. Note that jobs are resumable in problem instanceI¯′. In this case, the makespan of the first j−1 jobs on the machine is equal to φj−1(t)−tK. Then, L′−Δ(φj−1(t)−tK) represents the remaining space of the AI corresponding to the makespan of the first j−1 jobs. If L′−Δ(φj−1(t)−tK)⩾pj, then the processing of Jjcan be completed within the same AI, in which case the makespan of the first j jobs is equal to φj−1(t)−tK+pj, and the total cost is equal to φj−1(t)+pj. However, if L′−Δ(φj−1(t)−tK)>pj, then the processing of Jjcan be completed within the next AI of the current one (note that pj⩽L′), in which case the makespan of the first j jobs is equal to φj−1(t)−tK+pj+L, and the total cost is equal to φj−1(t)+pj+L.Combining the analysis of Case 1 and Case 2, we have the following dynamic program DP2:(I)Recurrence relation: For j=1,2,…,N and t=0,1,…,nN/∊,φj(t)=minφj-1(t)+pj,φj-1t-w̃jK+w̃j,ifL′-Δ(φj-1(t)-tK)⩾pj;minφj-1(t)+pj+L,φj-1t-w̃jK+w̃j,ifL′-Δ(φj-1(t)-tK)<pj.Boundary condition:φ0(t)=0,ift=0;+∞,otherwise.Objective: min{φN(t)∣ t=0,1,…,nN/∊}.The time complexity of DP2 is bounded by O(N2n/∊)=O(n3/∊). Assume thatφN(t¯)=min{φN(t)|t=0,1,…,nN/∊},wheret¯∈{0,1,…,nN/∊}. LetR¯t¯be the set of all rejected jobs in the optimal solution corresponding toφN(t¯). Based on the solution generated by DP2, we further assign the jobs inS¯0one by one to the machine as early as possible, so as to generate a solution toI¯′. Denote such a solution toI¯′byσ¯t¯′, and letZ¯t¯′be its objective function value. Note thatZ¯t¯′-t¯Krepresents the makespan of all accepted jobs in solutionσ¯t¯′. It is easy to check that no job inS¯0should be rejected in the optimal solution toI¯′. Thus,σ¯t¯′is optimal toI¯′, which further indicates that(13)Z¯t¯′⩽Z∗.Based on solutionσ¯t¯′, we now construct a feasible solutionσ¯t¯to problem instanceI¯as follows: Inσ¯t¯, all jobs inR¯t¯are rejected and all jobs inJ⧹R¯t¯are accepted; The jobs inJ⧹R¯t¯are assigned to the machine as early as possible in the longest-processing-time-first (LPT) order. Denote the objective function value ofσ¯t¯byZ¯t¯. Note thatZ¯t¯-t¯Krepresents the makespan of all accepted jobs in solutionσ¯t¯. We have the following property.Lemma 1Z¯t¯-t¯K⩽2Z¯t¯′-t¯K.We assume that∑Jj∈J⧹R¯t¯pj=λL′+δ,where 0<δ⩽L′ and λ is a nonnegative integer. We then haveZ¯t¯′-t¯K=λ(L′+L)+δ.If λ=0, thenZ¯t¯-t¯K=δ=Z¯t¯′-t¯K, and the result holds. We only consider the case with λ⩾1 in the following analysis. SupposeZ¯t¯-t¯K>2λ(L′+L)+δ. Then, there must exist at least one job inJ⧹R¯t¯that is assigned to the (2λ+1)th AI by the LPT rule. AssumeJη∈J⧹R¯tto be the last job assigned to the (2λ+1)th AI. If pη⩽L′/2, then the total processing time of the jobs that have been assigned to any of the first 2λ AIs is greater than L′/2 as Jηfails to be assigned to any of them. If pη>L′/2, then according to the LPT rule, any of the first 2λ AIs has been assigned a job with a processing time no less than pη. Thus, in each of the two cases, the total processing time of the jobs assigned to the first 2λ AIs is greater than λL′. This indicates that after assigning the jobs to the first 2λ AIs, the total processing time of the jobs remaining inJ⧹R¯t¯is less than λL′+δ−λL′=δ⩽L′. This further indicates that all of the jobs remaining inJ⧹R¯t¯can be assigned to the (2λ+1)th AI with a job completion time less than 2 λ(L′+L)+δ. This is a contradiction. Thus, we haveZ¯t¯-t¯K⩽2λ(L′+L)+δ⩽2Z¯t¯′-t¯K.□Based on solutionσ¯t¯, we now construct a feasible solutionσt¯to the original problemP¯eby replacing rejection penaltyw̃jby the original one wjfor any jobJj∈R¯t¯. Denote the objective function value ofσt¯byZt¯. We also have the following property.Lemma 2IfCmax∗⩾L′+L, thenZ¯t¯⩽(2+∊)Z∗.Note thatt¯K=∑Jj∈R¯t¯w̃j. Thus, ifZ∗⩾Cmax∗⩾L′+L, then by Lemmas 1 and (12),Zt¯=Z¯t¯-t¯K+∑Jj∈R¯t¯wj⩽2Z¯t¯′-t¯K+∑Jj∈R¯t¯w̃j+(L+L′)∊n⩽2Z¯t¯′+N(L+L′)∊n⩽2Z∗+(L+L′)∊⩽2Z∗+∊Z∗=(2+∊)Z∗.□By Lemma 2, ifCmax∗, the makespan in the optimal solution, is no less than L+L′, then the proposed approach is a (2+∊)-approximation toP¯ewith the running time bounded by O(n3/∊). Note that ifCmax∗<L+L′, or equivalently,Cmax∗⩽L′, then we can apply the FPTAS to P(1) in Case (ii) to solveP¯ewith a worst-case bound of 1+∊ and time complexity of O(n/∊). We thus have the following theorem.Theorem 6There exists a (2+∊)-approximation to problemP¯ewith the time complexity of O(n3/∊).Note that when job rejection is not allowed,P¯eis the same as the one in Ji et al. (2007). Ji et al. (2007) have shown that the worst-case bound of the LPT rule to solve the corresponding problem is 2, and the bound is tight. Therefore, our worst-case bound of 2+∊ is also tight for solving problemP¯e.

@&#CONCLUSIONS@&#
