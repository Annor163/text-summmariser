@&#MAIN-TITLE@&#
Subgrouping Automata: Automatic sequence subgrouping using phylogenetic tree-based optimum subgrouping algorithm

@&#HIGHLIGHTS@&#
An algorithm is developed for automatic sequence subgrouping for given sequence set.The algorithm basically utilizes phylogenetic tree from multiple sequence alignment.The algorithm calculates all of pairwise sequence identities and statistical analysis.The algorithm automatically determines optimum subgrouping node in phylogenetic tree.The algorithm showed good performance for family- or superfamily-level sequence set.

@&#KEYPHRASES@&#
Subgrouping,Protein family discrimination,Optimum subgrouping node,Phylogenetic tree,Statistical analysis,

@&#ABSTRACT@&#
Sequence subgrouping for a given sequence set can enable various informative tasks such as the functional discrimination of sequence subsets and the functional inference of unknown sequences. Because an identity threshold for sequence subgrouping may vary according to the given sequence set, it is highly desirable to construct a robust subgrouping algorithm which automatically identifies an optimal identity threshold and generates subgroups for a given sequence set. To meet this end, an automatic sequence subgrouping method, named ‘Subgrouping Automata’ was constructed. Firstly, tree analysis module analyzes the structure of tree and calculates the all possible subgroups in each node. Sequence similarity analysis module calculates average sequence similarity for all subgroups in each node. Representative sequence generation module finds a representative sequence using profile analysis and self-scoring for each subgroup. For all nodes, average sequence similarities are calculated and ‘Subgrouping Automata’ searches a node showing statistically maximum sequence similarity increase using Student's t-value. A node showing the maximum t-value, which gives the most significant differences in average sequence similarity between two adjacent nodes, is determined as an optimum subgrouping node in the phylogenetic tree. Further analysis showed that the optimum subgrouping node from SA prevents under-subgrouping and over-subgrouping.

@&#INTRODUCTION@&#
The generation of subgroups containing functionally relevant sequences based on sequence similarity or identity can give good information for functional discrimination of sequences in a given set of sequences (Heger and Holm, 2000). Through clustering or subgrouping, functions of anonymous protein sequences can be easily inferred from the functions of other sequences in the same cluster (or subgroup) or the sequences in neighbor subgroups. A homologous sequence set for clustering can be prepared by text mining or several search methods such as BLAST (Altschul et al., 1990) or profile analysis (Altschul et al., 1997; Eddy, 1998). When we assume that the functions of homologous proteins are diversified along time owing to point mutation, deletion, insertion, multimerization and duplication, the function of the collected anonymous sequences in a given sequence set can be predicted more in detail by the functional inference based on phylogenomic analysis method (Eisen, 1998). When the functions of the several members in all subgroups in the phylogenetic tree are revealed by experiments, we can roughly identify the function of anonymous sequences in a given sequence set. Then the next remaining question is how we can make functionally meaningful subgroups from large set of sequences (Eisen, 1998; Eisen and Fraser, 2003; Krause et al., 2002). As summarized by Lee et al. (2010), developed algorithms can be categorized into three main types, i.e. phylogenomics, pattern recognition and clustering. According to Lee et al., SCI-PHY, which utilize pattern recognition and clustering, gives better results in protein function prediction than sequence-only methods such as Secator (Wicker et al., 2001), Ncut (Abascal and Valencia, 2002) and CD-HIT (Li and Godzik, 2006). However, these methods need conserved domains (for pattern recognition) or pre-determined sequence identity cut-off (for clustering). Some methods use mathematical models. Brown introduced model-based sequence clustering method utilizing Dirichlet process (Brown, 2008). This method is reported to show good group purity and VI score, which divides the given sequence set into functionally different subgroups. However, according to Andreopoulos et al. (2009), most models used in model-based clustering methods are often oversimplified, so that leading to inaccurate result. In addition, another disadvantage of model-based method is slow processing time for large sequence sets.From the standpoint of enzymologists, bioinformatical methods should be feasible regardless of the level of input sequence set. Input sequence set could consist of sequences in superfamily, family or subfamily level. If the sequence set consists of superfamily level, sequences may be very diverse to draw conserved domains. In addition, sequence identity cut-off for sequence subgrouping could be never known for sequence set collected from database by utilizing any homology search method. Therefore, sequence clustering algorithm should produce family or subfamily sequence sets from superfamily or family-level sequence set without prior knowledge of sequence identity cut-off.In this work, we designed a versatile algorithm for sub-classification of input sequence set, which uses sequence comparison and clustering method. Because there are many outperforming sequence alignment methods, we focused on the development of algorithm to generate subgroups utilizing the sequence alignment result produced from other multiple sequence alignment methods.Sequences of β-alanine:pyruvate aminotransferase, γ-aminobutyrate aminotransferase, l-ornithine aminotransferase and lysine decarboxylase were searched with EC number and retrieved from BRENDA. Redundant sequences were removed by sequence clustering with 100% threshold using CD-HIT. 97 sequences of β-alanine:pyruvate aminotransferase, 272 sequences of γ-aminobutyrate aminotransferase, 72 sequences of l-ornithine aminotransferase and 111 sequences of lysine decarboxylase were used for subgrouping.In the case of branched-chain aminotransferase (bcAT), sequences of bcATs were searched using the EC number of bcAT (2.6.1.42) at RefSeq database in NCBI. Putative sequences and fragment sequences were removed from the search result. To remove the redundant sequences, sequence clustering with the sequence identity threshold of 100% was performed using CD-HIT. A total of 691 sequences were gathered. The sequence subgrouping using the developed subgrouping algorithm was performed for the final 691 sequences. For aspartate ammonia-lyase, sequence sets were searched with EC number, and retrieved from BRENDA. Redundant sequences were removed by sequence clustering with 100% threshold using CD-HIT. HMM profile was built using ‘hmmbuild’ and ‘hmmcalibrate’ program in HMMER package. 843 microbial genomes (as of March 2009) were searched using the generated profile. From the result of the search for each microbial genome, hit sequences scoring over default E-value of 10 were collected. Sequence clustering was performed to remove redundant sequences using CD-HIT with 100% threshold. Final 379 sequences were used for subgrouping.In the case of (S)-2-aminoadipate semialdehyde dehydrogenase (aasDH) sequence sets, there are two kinds of sequences in BRENDA database. The sequences of approximately 400 amino acids were chosen, but the number of the sequences was too small. Therefore, simple BLASTP search was performed with aasDH from Stenotrophomonas sp. SKA14 in NCBI and top 100 sequences were retrieved. Redundant sequences were removed by sequence clustering with 100% threshold using CD-HIT. Final 99 sequences were remained and used for subgrouping.The sequences for the subgrouping analysis of aminotransferase group I, II and all the other aminotransferase groups were manually collected from the NR database. Putative sequences and fragment sequences were manually removed. BcAT sequences were re-collected manually with the same method for sequences of other aminotransferase subgroups. Sequence set of all aminotransferases consists of 11 sequences of alanine aminotransferase, 152 sequences of aspartate aminotransferase, 39 sequences of aromatic aminotransferase, 22 sequences of histidinol-phosphate aminotransferase, 16 sequences of ω-aminotransferase, 10 sequences of l-ornithine aminotransferase, 55 sequences of N-acetyl-l-ornithine aminotransferase, 129 sequences of 7,8-diaminopelargonate aminotransferase, 48 sequences of γ-aminobutyrate aminotransferase, 10 sequences of d-alanine aminotransferase, 53 sequences of branched-chain aminotransferase, 22 sequences of phosphoserine aminotransferase and 50 sequences of serine aminotransferase. Aminotransferase group I consists of alanine aminotransferase, aspartate aminotransferase, aromatic aminotransferase and histidinol-phosphate aminotransferase. Aminotransferase group II consists of ω-aminotransferase, l-ornithine aminotransferase, N-acetyl-l-ornithine aminotransferase, 7,8-diaminopelargonate aminotransferase and γ-aminobutyrate aminotransferase. Classification of aminotransferase in the work of Mehta et al. (Mehta et al., 1993) was adopted.ClustalW 1.83 (Thompson et al., 1994) was used for the multiple alignment of input sequence sets. In this work, we used ClustalW because some input sequence sets have large number of sequences. Although we used ClustalW for multiple sequence alignment, any alignment programs can be used to generate multiple sequence alignment. “hmmbuild”, “hmmcalibrate” and “hmmsearch” in HMMER package (Eddy, 1998) were used for profile building and profile search. Subgrouping algorithm and parsing algorithm for the result of ClustalW and programs in HMMER package were coded using Python programming language.Two assumptions were made to construct the algorithm. (1) If sequence sets consist of a certain level (e.g. family level), subgrouping should be performed to discriminate sub-level (e.g. subfamily level); (2) at the optimum subgrouping node in phylogenetic tree, an average sequence similarity shows a maximum increase. Program starts with the ‘PHYLIP’ format of the tree and ‘clustal’ format of the alignment result. Therefore, if a user can make these two files, any alignment program can be used. In phylogenetic tree recognition and analysis, node number is calculated from ‘PHYLIP’ format of the phylogenetic tree. Starting from node index of zero, +1 is added when an opening parenthesis appears and −1 is added when a closing parenthesis appears. Therefore, the origin of the rooted tree is designated as node 1. After the node number assignment, the subgroup at node i is picked by selecting sequences between an opening parenthesis with node number (i+1) and a closing parenthesis with node number i. The node number and the subgroup tag for each sequence can be assigned as in Fig. 1(a). For example, because node number of tree origin is 1, subgrouping at node 1 results in one subgroup and it contains all the sequences.Next, subgroups at each node were identified. For instance, three subgroups can be identified at node 2 and four subgroups at node 3 (Fig. 1(a)). Therefore, sequence a in Fig. 1(a) can have the multiple subgroup tags of 3-1, 4-2 and so on. For sequences in each subgroup, to calculate the average sequence similarity, pairwise sequence similarities were calculated for all the sequence pairs using the multiple alignment result. Sequence similarity was calculated on the assumption that the aligning of similar amino acids is matched. Groups of similar amino acid are as follows: ‘aa1’:(G, A, V, L, I), ‘aa2’:(F, Y, W), ‘aa3’:(C, M), ‘aa4’:(S, T), ‘aa5’:(K, R, H), ‘aa6’:(D, E, N, Q), ‘aa7’:(P). Average sequence similarity for a subgroup, which is a total sequence similarity of a subgroup, can be calculated by averaging all the pairwise sequence similarities from all the sequence pairs in the subgroup. The average sequence similarity (ASS) for all of the possible subgroups in a certain node was calculated for all the nodes. Let the sequence similarity be SS, and the average sequence similarity of subgroup k at node i be ASS(i)k.Then,ASS(i)k=∑SS for all sequence pairs inkthsubgroup at nodeinumber of all sequence pairs inkthsubgroup at nodeiLet the average of all the ASS(i)kat node i be ASS(i), thenASS(i)=∑k=1nASS(i)k/n, where n is the number of subgroups at node i. For example, in Fig. 1(a), we can find three subgroups at node 2 and ASS(2) is(ASS(2)1+ASS(2)2+ASS(2)3)/3. Our program calculates all the ASS(i) (i=1, 2, …, n) for all the nodes. Accounting the assumption 2, student's t-value indicating normalized average sequence similarity differences between ASS(i+1) and ASS(i) at node i and i+1 can be adopted and calculated. The t-value is defined as follows:t(i+1,i)=ASS(i+1)−ASS(i)(var(i+1)/n(i+1))+(var(i)/n(i)),where var(i) is the variance of SSs of all sequence pairs in all subgroups at node i and n is the number of all the sequence pairs in all subgroups at node i.A simple ASS difference can give information for ASS change. However, t-value was adopted to normalize the ASS difference and calculate statistically most meaningful ASS increase. Sequence similarity values generally follow extreme value distribution and t-test is used on the sample set following the normal distribution. However, when the sample size is sufficiently large, we are able to assume that sequence similarity values approximately follow the normal distribution. With this assumption, the t-test is adopted to normalize ASS difference. When t(i+1, i) shows a maximum value at a certain node, program performs subgrouping at the node, which is very likely to be the optimum node. For example, if t(3,2) shows a maximum value among the t values, the program performs subgrouping at node 3. Since some sequences branched out before the optimum node, there can be sequences that are not included in the generated subgroups (i.e. dropouts). These dropouts were also gathered and stored for the selection of the representative sequences.Representative sequences were chosen by a self-scoring method to represent the average sequence characteristics of subgroups. The self-scoring method is proceeded as following (Fig. 1(b)): (1) multiple alignment for the sequences in subgroup is performed, (2) HMM profile is generated from the multiple alignment, (3) this HMM profile is used for scoring the member sequences in that subgroup, (4) the top scoring sequence is chosen as the representative sequence. Representative sequences are selected from the dropout sequences generated before the optimum node as well as from the subgroups at optimum node. When representative sequences were determined from the dropout sequences, evolutionary history was considered using the following procedure. After the collection of dropout sequences, subgroups in dropout sequences were determined according to branch points and nodes. Using this algorithm, the program selects additional representative sequences from the dropout sequences. For example, if ‘Subgrouping Automata’ (SA) performs subgrouping at node 4 in Fig. 1(a), there are 6 dropout sequences – i.e. sequences b, c, d, e, f and g. Because the sequences b, c, d, e, f and g have different evolutionary history, four different cases should be considered. Sequences e and f are branched out at node 2. Therefore, one representative sequence should be selected from the sequence set of e and f. Next, sequences b, c, d and g, which are dropped out at node 3, have three different evolutionary histories. Therefore, selection should be performed to pick one from sequence b itself, one from g itself and one from the sequence set of c and d. If the number of sequences of a given sequence set is larger than two (e.g. (c, d) set and (e, f) set), same self-scoring method was applied to select representative sequence. Using this algorithm, program selects additional representative sequences from dropout sequences. Therefore, in case of Fig. 1(a) with subgrouping at node 4, total nine representative sequences could be selected. Using these nine representative sequences, ASS(i)rscan be made by the calculation of average of 36 sequence similarities from 36 sequence pairs generated from nine representative sequences.ASS(i)rscalculates the average sequence similarity among the representative sequences at each node, and it is compared to ASS(i) to determine whether the subgrouping is either overdone (i.e. too specific subgrouping), underdone (i.e. too broad subgrouping) or optimally done.

@&#CONCLUSIONS@&#
SA can perform a sequence subgrouping in an automated manner. It does not need a pre-determined sequence threshold for sequence clustering. Using the stochastic calculation of ASS(i) at each node and statistical calculation (t-value), it automatically determines the subgrouping node. From the analysis of various sequence sets, the followings could be addressed. (1) Subgrouping node determined by the maximum t-value is the same or very close to the node where ASS(i) and ASS(i)rsare similar or same; (2) Subgrouping by SA functionally discriminates the sequences in a given sequence set with a high probability by using the simple calculation of sequence similarity; (3) If the subgroups have a similar evolutionary history in phylogenetic tree, SA clearly discriminate the subgroups as shown in Section 3.2, which could be found in the clear discrimination of aminotransferase group II, III and IV in the subgrouping of all aminotransferase groups.If we define that optimum subgrouping is the one escaping from under-subgrouping or over-subgrouping, SA could successfully achieve optimum subgrouping without prior knowledge about the input sequence set. In addition, SA can suggest the optimum sequence similarity threshold which is value of ASS(i) where ASS(i)=ASS(i)rs. This is the major difference from CD-HIT or DivergentSet (Widmann et al., 2006). CD-HIT solely depends on the pre-defined sequence identity to perform the sequence clustering and DivergentSet refers to the phylogenetic tree and performs the sequence clustering at the pre-defined sequence identity threshold. In contrast to these methods, SA refers to the phylogenetic tree and suggests the optimum sequence similarity threshold for subgrouping by the stochastic calculation. In addition, although SA only utilizes multiple sequence alignment and sequence similarity calculation, it gives good subgrouping result for the superfamily-level sequence set.SA can automatically find the optimum subgrouping node. In addition, it can split an input sequence set into functionally different subgroups. Once the input sequence set is given, the next task is to perform the subgrouping efficiently according to their function, which can be done by SA. Representative sequences selected by SA could fully represent the given sequence set, which efficiently reduces a search space for the further study such as the selection of subgroup having activity on the target enzymatic reaction.