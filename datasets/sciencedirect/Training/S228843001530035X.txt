@&#MAIN-TITLE@&#
A framework for similarity recognition of CAD models

@&#HIGHLIGHTS@&#
Developing a knowledge-based framework to assist the designer in design decisions.Opitz feature recognition and code generation from STEP for data standardization.An efficient similarity recognition algorithm to retrieve models from database.

@&#KEYPHRASES@&#
Design classification,Opitz coding system,Similarity retrieval,

@&#ABSTRACT@&#
Graphical abstract

@&#INTRODUCTION@&#
Market competition and constantly changing customer demands yield to massive production. Consequently a huge amount of information is produced and archived every day. Reusing such information can reduce the product cost and time; along with optimizing the product design. There is no doubt that the dimension of reusing such know-how greatly affects the designing of new products in the conceptual design phase. Different information could be derived and learnt from the already existing design including geometry, material, process planning, manufacturing, price and generally Product Lifecycle Management (PLM) information. It is possible to become skilled at PLM knowledge by knowing the similar cases, therefore making better design decisions. In this regard, an efficient similarity recognition algorithm is a fundamental prerequisite which assists in providing an automated and intelligent decision making.Alongside all research developed by engineers on decision making and Decision Support Systems (DSS) [1–3] and models [4], psychologists suggest four essential techniques for improving the problem of decision making and choice overload [5–7] listed in following:(1)Cut: get rid of the extraneous alternativesConcretize: Make it realCategorize: more categorization, fewer choiceCondition: for complexity, it is easier to make complex decisions by gradually increasing the complexityThe above mentioned techniques have been considered in the current research aiming for modeling a knowledge-based framework. Such a structure guides the designer to an optimized decision making with respect to reuse of the existing similar artifacts data,Fig. 1.A CAM-based classification system was applied and developed further intended for automatic extraction of the design information from STEP file. In addition, an infrastructure was designed and developed for a comprehensive retrieval, i.e. selective similarity recognition and part retrieval. The following paragraphs explain these phases briefly.•Comprehensive similarity recognition algorithm: A comprehensive similarity recognition algorithm has been developed to calculate distance function. A distance function is applied to measure the similarity and accordingly to discard the dissimilar cases and retrieve only the similar models. The percentage of total similarity can be tuned by the designer.3D CAD presentation of the retrieved models: To make the retrieved similar models more tangible, all the related 3D CAD models are also represented to the user in addition to STEP files and the classification codes (Opitz codes).Opitz coding system: For categorization and classification, Opitz coding system as a successful method of group technology (GT) in manufacturing has been applied.Adjustable similarity recognition for each digit: The similarity setting for each digit can vary from 0 to 100 percent. 0 indicates dissimilar features and 100 for identical models and the required weight for each digit step-by-step can be adjusted between these two numbers by the user.Opitz coding system is a method of group technology which is applied in Computer Aided Manufacturing (CAM) for part classification. It is a well-known method for classification of manufacturing features and is named after Herwart Opitz who originally proposed this coding system [8]. Opitz coding system consists of alphanumerical digits, each presenting a feature and its type. In the other words, a digit is the aggregation of all the feature conditions it is composed of according to the code׳s definition. Created by Herwert Opitz in 1970, Opitz code is a hybrid code consisting of a maximum of 14 digits. The code itself is divided into 3 sections. The first section consists of five digits which are dubbed the “form code” and describe the geometry and topology of the product/part. The second section, also called the “supplementary code” was added later and consists again of four digits that represent the dimensions, material, original shape of raw stock, and accuracy of the product/part. Each digit in these two sections may contain 10 different values ranging from 0 to 9. The third section consists of only four characters; A, B, C, and D. It is called the “secondary code” and allows for organization customization of the code. Here, organizations can include proprietary and organization-specific information regarding the product/part. The Opitz code׳s structure is given below inFig. 2.The first five digits of the code are referred to manufacturing features and highlight the manufacturing features such as bore, step, forming, etc. and their specifications. As an instance if the discussed manufacturing feature is bore, blind bore, through bore, number of the bore/s, position/s and main/axial bore are specifically pointed and highlighted in the code.The number of digits or the size of Opitz code is fixed for all parts and it is independent of complexity of a part. The current research incorporates feature recognition and the translation of such features into a model׳s group comparison functions code, explained in Section 3. The group technology code will then be used to retrieve identical or similar models from a benchmark discussed in Section 4. After constructing such an application, it will be evaluated by some of the most common evaluation techniques. For example, the feature recognition functionality will be evaluated with regard to the accuracy of the produced code and the similarity-retrieval functionality will be evaluated using one of the most famous query evaluation techniques; the precision–recall technique discussed in Section 5.The objective of this paper is to describe a framework for feature recognition and similarity retrieval of a CAD model. The modules of the framework will be discussed in detail. In addition, the test and benchmark results of shape representation and similarity retrieval of the proposed method will be discussed and compared with other well-known similar methods.

@&#CONCLUSIONS@&#
The main objective of this paper is to present a framework to support similarity and retrieval system that would assist to search for and retrieve similar models from a given CAD model. It was also required that the resulting system be evaluated as well as validated against other existing endeavors in this area. The system would, in turn, allow inexperienced designers to relate their textual requirements via wizard or rough model to existing models and give them something to start with instead of rebuilding models from scratch (re-inventing the wheel). It was shown that the approach is sound when it comes to using an Opitz code as a shape signature. It was also shown to be consistent method into some of the popular approaches in that field, and its issues have been outlined and discussed. It has also been shown that its issues do not impede its main functionality, whether these are incorrectly classified models, or the fact that using an Opitz code as a signature returns many more results than expected. Rather, these issues can be used to show that the system indeed does perform as expected, and has room for improvement. However, due to the limitations of the Opitz code approach, models that are not completely similar may be considered similar.Using this method it is possible to realize partial similarity retrieval. By giving a larger weight to a certain property, and relaxing the similarity threshold, the similar models with regards to the certain property are retrieved. Although the other properties will also be compared, but the weights will significantly influence the similarity values.The work presented in this research is similar in its reliance on rule-based systems to generate the group technology code, but different in how it is applied. Instead of using predicates to generate feature information, the application simply runs through a decision tree. The first applicable path is selected and followed to its end in a forward chaining manner. This reduces the memory utilization usually consumed by storing predicates and conclusions of such predicates. As seen in the evaluation section, this process is slightly rigid. This has been somewhat mediated by the use of thresholds and flexibility levels. Though the overall code accuracy is not high, the accuracy per feature as well as the average accuracy per feature measures are promising.