@&#MAIN-TITLE@&#
A dynamic data driven-based semi-distributed reputation mechanism in unknown networks

@&#HIGHLIGHTS@&#
A reputation- and trust-based mechanism distinguishes trustworthy nodes in networks.Dynamics of trust occurs in a trusted network and causes disguises of the nodes.Semi-distributed reputation mechanism based on dynamic data-driven application system.The proposed mechanism focuses on dynamics of trust and the balance between nodes.

@&#KEYPHRASES@&#
Dynamic data driven application system (DDDAS),Reputation- and trust-based model (RTM),Dynamics of trust,

@&#ABSTRACT@&#
Trust is a crucial concern related to unknown networks. A mechanism that distinguishes trustworthy and untrustworthy nodes is essential. The effectiveness of the mechanism depends on the accuracy of a node’s reputation. The dynamics of trust often occurs in a trusted network and causes intoxication and disguises of the nodes, resulting in abnormal behaviors. This study proposes a semi-distributed reputation mechanism based on a dynamic data-driven application system. This mechanism includes two reputations, local reputation (LRep) and global reputation (GRep). LRep is dynamically and selectively injected into a central controller, and this controller collects the injected data to compute GRep, which contains the neural network prediction method, and returns it to provide reference to the distributed nodes. The proposed mechanism focuses on dynamics of trust and the balance between distributed nodes and the central controller. Experimental results showed that GRep was computable with only 52.21% (average) LReps upload and that GRep increased or reduced by 26.5% (average) in a short period, demonstrating that the proposed mechanism effectively handles the problem of dynamics of trust.

@&#INTRODUCTION@&#
Information security concerns are associated with various types of networks, such as social, peer-to-peer (P2P), e-commerce, and sensor networks. For example, in an e-commerce network, a buyer may encounter fake goods, and in a P2P network, malicious nodes affect normal nodes, resulting in network inefficiency and even meltdown. Therefore, trust relationship in unknown networks is an active research topic. In the past decade, many studies have reported on reputation- and trust-based models (RTMs), and many are currently underway. RTMs distinguish trustworthy and untrustworthy nodes in a network through one or more reputation metrics. In addition, they use different reward and punishment mechanisms to prevent unexpected node behavior. Their main architecture is of two types (Kamvar et al. 2003; Liu and Issarny 2004; Lin 2005), central and distributed architecture. In the central architecture, such as that in some e-commerce websites (e.g., Yahoo!, Auction, and eBay), all transactions and feedback are recorded after each transaction, and these records are referred to during future transactions. The center must have a large storage and high computing ability. Throughput is a concern, particularly in sensor networks. With increasing network traffic, network congestion occurs if all nodes upload all their data to the center. In the distributed architecture, nodes maintain, transfer, exchange, and gather their trust information independently. Finite information is finally used to calculate trust value. A complex algorithm requires high computing ability at each node. For example, mobiles devices are increasingly being used. However, they have limited computing ability and storage. In mobile ad hoc networks, systems using complex RTM exhausts all device resources. Therefore, in the distributed architecture, RTMs cannot be highly complex under limited resource conditions. Conversely, the dynamics of trust (Kanawattanachai and Yoo 2002; Govindan and Mohapatra 2012) causes trust metrics to be nonlinear. For instance, in e-commerce networks, the account of a seller with a high reputation may be stolen by fraudulent buyers because of intoxication, and in P2P networks, a new malicious node pretends to be a good node but becomes malicious after a period, thus displaying an unexpected behavior. Under the dynamics of trust conditions, depending on only historical transaction experiences is insufficient, and time is required to achieve a balance. In this study, this problem is resolved.This study proposes a semi-distributed reputation mechanism based on a dynamic data-driven application system (DDDAS; Darema 2004) with a semi-distributed architecture. With this mechanism, the system accurately and efficiently distinguishes trustworthy and untrustworthy nodes. Furthermore, the system collects dynamic reputation data efficiently, predicts dynamic data, and maintains a resource balance between the central and distributed nodes. The trust mechanism is divided into six components: trust computation, trust propagation, trust aggregation, trust record, trust prediction, and trust application. All components, particularly trust propagation and aggregation, are discussed in the following sections.By using a DDDAS, reputation data are injected into a central controller (Onolaja 2012). The central controller efficiently gathers only the useful data from all data in the network. It computes new reputation values to be referred to during future transactions. The DDDAS uses a simulation system to predict the next reputation value at the next tick and provides feedback to the physical system. Consequently, predictions relate to the real world. In addition, the semi-distributed architecture balances the utilization of central and distributed resources, rather than relying on only one. In this study, a query-cycle model (QCM; Schlosser 2003) was used to simulate a real-world P2P network to evaluate the availability of this study; in addition, the processing results of the dynamics of trust are presented.Although the concept of trust is encountered every day, trust and reputation have various meanings. Jøsang et al. (2007) used the following examples to illustrate the difference:(1)“I trust you because of your good reputation.”“I trust you despite your bad reputation.”Sentence (1) indicates that trust depends on a trustee’s reputation, which is based on others’ trust. Sentence (2) implies that a trustee may have private knowledge or different standards that override the trustee’s bad reputation originating from others’ trust (Jøsang et al. 2007). Trust is subjective, whereas reputation is relatively objective; that is, reputation is composed of a party’s trust. For example, let trust and reputation metrics range between 0 and 1, and let the reputation value be aggregated on the basis of a party’s trust value (e.g., 0.8) and Node A’s reputation value. The trust thresholds of Nodes B and C are 0.7 and 0.5, respectively. Therefore, Node B trusts Node A because Node A’s trust threshold is higher than the reputation value of Node A, and Node C does not trust Node B because Node B’s trust threshold is lesser than that of Node B.Transitivity is crucial in RTMs, as detailed in a subsequent section. Briefly, if Node A trusts Node B and Node B trusts Node C, then Node A trusts Node C. In this study, only limited transitivity exists because our trust metric was subjective. Transitivity exists only when the trust threshold is higher than the reputation value. RTMs are implemented in various fields with different metrics. For example, in e-commerce networks, a system aggregate user offers feedback to a metric, and this feedback is applied to the next user assessment before a new transaction starts, and in web service networks, the reputation value depends on stability, transmission speed, and accuracy.The following RTMs are highly correlated in this study.EigenTrust (Kamvar et al. 2003) is an algorithm with a distributed architecture. It aggregates neighbors’ trust to calculate the reputation value that can influence reputation in the next node; that is, Node A requires its neighbors’ help if it does not trade with Node B. In brief, the reputation value is transitive. Letcijbe the reputation value from i to j. The new value istik=∑j=1cijcjk. A hightikindicates a trustworthy node. Letti→represent the vector intik, and C represent matrix[cij]such thatti→=CTci→. If the system demands two-layer neighbors, the power of the equation is two (ti→=(CT)2ci→), and so on. Computing stops when the reputation value converges.EigenTrust determines the layer of neighbors which want to ask their trust value. However, computing resources increase with increasing number of layers. Here, the reputation value is equal to the weight of neighbors’ recommendations.As shown in Fig. 1, a broker framework (Lin 2005) has three components, user, broker, and reputation authority.Each user represents a network node, such as a sender or receiver in P2P file-sharing networks. Users are connected to brokers responsible for collecting transaction data and maintaining the reputation database. After a transaction, users upload their rating for this transaction. For example, after User A trades with User B, both Users A and B upload their ratings, which may differ. A relevant equation is as follows:Rnew=e-βΔtNN+1Rold+(1-e-βΔtNN+1)r,whereRnew,Rold,e-βΔt, andrdenote the new reputation value, old reputation value, discount factor ofRold, and rating uploaded by the user, respectively.Before a transaction, each user queries the broker on the reputation of the trading user. The broker first searches the reputation of the trading user in its database. If it does not have the related reputation data, it queries another broker or reputation authority. To exclude fake reputation values, legitimate brokers eliminate fake brokers using the following equation:X=X+F*(1−X), if the recommendation value is consistent with the facts, andX=X*(1−F), if the recommendation value is inconsistent with the facts,where X is the reputation value of a broker, whose initial value is 0.5, and F is a parameter (0.2).The higher the X, the more difficulty it is to increase X. However, X can be easily decreased. Therefore, brokers are motivated to maintain their reputation.Similar to the semi-distributed architecture, users exchange reputation information through brokers. Users only upload their transaction rating and thus the model does not require higher computing resources. The disadvantage is that the model cannot predict future results because it is not a prediction model. Moreover, users have to upload all their ratings, thus resulting in network congestion.Currently, lightweight devices are popular; therefore, computing resources are a consideration in designing reputation mechanisms; that is, the mechanisms should not be too complex. Liu and Issarny (2004) classified reputation into two components, service reputation and recommendation reputation, which are refreshed after transactions are completed. In addition, reputation is time-sensitive and context-dependent.Every node contains three aspects: First, an experienced manager is responsible for computing transaction satisfaction and refreshing service reputation. This refreshing is dependent on time and service type. Second, the recommendation manager is responsible for receiving neighbors’ recommendations of service reputation. These recommendation results have to be normalized. Third, the reputation manager is responsible for integrating his own experience with neighbors’ recommendations and providing metrics to determine whether to trade. In addition, the final value is recommended to other nodes, forming a cyclic loop.This mechanism has two metrics, which are computed individually. Therefore, the result is more accurate than mechanisms with only one metric.DDDASs incorporate additional data in executing applications; these data are either archival or collected on-line; conversely, the applications can dynamically steer the measurement process. This paradigm improves modeling methods and augments the analysis and prediction capabilities of application simulations and the effectiveness of measurement systems, and presents the potential to transform science and engineering and majorly shift such functions as manufacturing, commerce, hazard management, and medicine (Darema 2004). Cluster heads (Onolaja 2012) in physical systems, such as intrusion detection systems, overhear all transaction packets between connected nodes and uploads them to the central controller. As shown in Fig. 2, the central controller has a simulation system to predict the reputation at the next tick. The prediction method weights the probability of each scenario and its result with regard to the reputation value. Their weighted average is the future reputation value.This mechanism which shown in Fig. 2 solves the problem of dynamics of trust by using a DDDAS, and the accuracy obtained using this mechanism is higher than those reported in previous studies. The limitation is that cluster heads overhear all packets between nodes. However, this is almost impossible in the real world. DDDAS is the result of multidisciplinary research and creates new challenges for applications, algorithms, system software, and measurement methods. In general, it has a prediction method or system that feeds back to the physical system, such as a more accurate prediction model and more useful decision support system. Collecting and storing useful data efficiently is another crucial aspect because of the dynamic nature of DDDAS.In this section, a semi-distributed reputation mechanism based on the DDDAS is presented in detail. First, we define the problems of trust and reputation in unknown networks. Second, local Reputation (LRep) and global Reputation (GRep) are defined. Third, the design of a semi-distributed reputation mechanism based on the DDDAS is introduced. Finally, we elaborate on the advantages and disadvantages.In unknown networks, the proposed mechanism efficiently distinguishes trustworthy and untrustworthy nodes and solves the problems related to the dynamics of trust and resource balance. The dynamics of trust is defined as the evolution of trust over time. Trust changes with time, experience, and the state of different sources it is derived from (e.g., environment and mobility) (Govindan and Mohapatra 2012). Therefore, quickly handling changes in the dynamics of trust is a problem in RTMs. The distributed nodes and central controller have different resources, with distributed nodes usually having limited resources. If all data are uploaded to the central controller, the network becomes congested, and balancing the distributed nodes and the central controller becomes problematic. The ideal solution is to upload only the data required by the system.An unknown network is an interconnected network in which nodes do not have prior knowledge of each other. This study uses two metrics to build a reputation mechanism in unknown networks: (1) LRep: in distributed nodes, each node uses its limited information, such as experience and neighbors’ recommendations, to derive an aggregated reputation value. Before each transaction, a node immediately determines whether the other node is trustworthy depending on whether the metric is high or low after comparing the average node values. (2) GRep: distributed nodes upload their LReps values to the central controller under specific conditions and compute a reputation value using the uploaded values. This metric contains a history of the LRep, online LRep, and the predicted value multiplied by different rates. After obtaining the new GRep, the central controller immediately provides feedback to the distributed nodes. Therefore, the distributed nodes more accurately determine whether another node is trustworthy.Many networks, such as the World Wide Web and social and P2P networks, exhibit a power-law degree distribution in the real world (Saroiu 2001). Therefore, the proposed model assumes that an unknown network exhibits a power-law degree distribution. Furthermore, malicious nodes may exhibits malicious behaviors that normal nodes do not engage in, such as fraud in e-commerce networks and transferring fake files in P2P networks. The proposed mechanism assumes that the number of malicious nodes is lesser than that of normal nodes.As shown in Fig. 3, the semi-distributed architecture in the proposed model consists of three components: central controller, cluster heads, and distributed nodes. The distributed nodes form an unknown network, and the gray lines between nodes represent the relationships between neighbors. Each distributed node has a connection with one cluster head (black circles), and each cluster head has a channel connected to the central controller (blue arrows). A distributed node can transact with another node as long as both the nodes agree. For example, if Node A requests Node B for a transaction and Node B permits it, Node A accepts Node B’s response, thus initiating a transaction.As depicted in Fig. 4, a distributed node follows these stages if it intends to transact.•Initialization Stage.The distributed nodes verify whether they are connected to a cluster head, query the cluster head, and receive responses.Computation of LRep.The distributed node selects one of the received responses and computes its source’s new LRep using the node’s experience and neighbors’ recommendations.Check Stage.In this stage, LRep is used to preliminarily determine whether another node is trustworthy. In addition, the new LRep is uploaded to the central controller through the cluster heads if LRep is less than a specified value.Computation of GRep.The central controller generates a new GRep whenever it receives LReps from the distributed nodes through the cluster heads. GRep comprises historical, online, and predicted values, meaning that each GRep is recorded and used in the future as historical data. Finally, feedback (GRep) is shared with the distributed nodes through the cluster heads.Derivation of GRep and Making a Transaction Decision.Nodes can receive new GReps at any time. Therefore, the final step is to obtain a new GRep from the cluster heads and use it to determine whether another node is trustworthy.The distributed nodes, cluster heads, and central controller are explained in detail in the following sections.Fig. 5is the transaction flowchart of the distributed nodes; each node must follow a particular flow before it establishes a transaction. Herein, the complete flow is illustrated comprehensively.(1)A node must connect with one cluster head because the mechanism depends on the cluster heads. Therefore, a new node search entails connecting with a cluster head if the connection has not yet been established.Before the distributed node establishes a transaction, it must query and wait for responses; there may be zero, one, or more responses. For example, many responses are recieved in P2P networks.If zero responses are recieved, the transaction is considered a failure because no node can trade. If the number of responses equals or exceeds one, the node selects one of the responses and proceeds to the next step.After a response is selected, its source can be obtained. Let the querying node be Nodea, the selected responding node be Nodeo, and the neighbors of Node a be Nodes p. In this step, the LRep of nodeois computed from the perspective of nodea. LRep lies between zero and one. A high LRep indicates high trustworthiness of nodeo. In addition, LRep is composed of the experience of nodeaand its neighbors’ recommendations. Eq. (1) (Liu and Issarny 2004) is used to compute LRep, whereExpa(o)tis an experience value between zero and one from a to o at tick t,Recommendationsa(o)tis an aggregate of the neighbors’ recommendations between zero and one from a to o at tick t, andαis a ratio that is multiplied withExpa(o)t. Therefore,LRepa(o)tis located between zero and one:The recommendation values of nodes differ because nodes have different experiences and neighbors, and their weights differ because the reliability of each recommendation is inconsistent; recommenders with accurate results in the past are afforded high weights. As shown in Fig. 6, Nodes a and p have different weights.In Eq. (2),LRepp(o)tis an LRep from p to o at tick t, the recommendation value is from p to a at tick t, andweighta(p)tis the weight of the recommendation, between zero and one, from a to p at tick t. The weighted average the of recommendation values yieldsRecommendationsa(o)t. In addition, ifweighta(p)tis lesser than a specific threshold (λa), Node a does not query Node p:(2)Recommendationsa(o)t=∑p∈P(weighta(p)t∗LRepp(o)t)∑p∈Pweighta(p)tifweighta(p)t>λa.LRep can thus be obtained from a to o at tick t and is passed to the next step. Eqs. (1) and (2) not only divide reputation into two components, experienceExpa(p)tand recommendationweighta(p)t, but also easily add a thresholdλa, which controls the number of neighbors queried. Therefore, LRep is computable using limited resources.(5)If LRep of a node is an outlier of historical data, the node is immediately judged untrustworthy. The definition of the outliers is a kind of anomaly or abnormal data. It means the set of data points that are considerably different than the historical data. Historical data contain all LReps of neighbors and their history. The amount of historical data depends on the storage capacity of the distributed nodes. The more data the distributed node stores, the more accurately outliers are captured. Using mean and standard deviation is the simplest approach to capturing outliers. In normally distributed data, 99% of the data is located within the mean±three standard deviations. This study does not focus on the means of computing outliers.After determining that the LRep is not an outlier, whether LRep must be uploaded to the central controller through a cluster head is determined. Each node has its own upload threshold. Let the threshold of the query node beδa, a value between zero and one. The higher theδais, the more accurately and quickly malicious nodes are identified. Conversely, lowδaindicates heavy network loads. Therefore, balancing accuracy and network load is crucial. Moreover, a node uploads LReps in 10 ticks with a cache mechanism, meaning that LReps are not repeatedly uploaded after they have already been uploaded. Every 10 ticks, these nodes that don’t be uploaded any local reputations means that have higher probability to not make any malicious transactions during current 10 ticks, so they need a self-adjusted global reputation mechanism to get the highest global reputation currently in central controller and pretend to upload it for each good nodes during past 10 ticks. Actually all actions are in central controller, so good nodes during past 10 ticks doesn’t upload any data.In this step, the node obtains a new GRep from the central controller through a cluster head. The computation of GRep is discussed in a subsequent section. If GRep is lesser than the specific thresholdδa, the source Node o is judged untrustworthy by the querying Node a. Conversely, if GRep is higher thanδa, the source Node o trades with the querying node a. In addition, if the source Node o is judged untrustworthy, Node o is discarded from all responses arriving from Step 2, and the flow restarts from Step 3 until the transaction is completed or terminated.Finally, this mechanism determines whether to trade. Node a rates Node o and obtains a satisfaction value after completing the transaction. Letsata(o)be the satisfaction value, between zero and one, from a to o. In addition,sata(o)can be subjective or objective in the networks, which likes the quality of service in P2P networks or user feedback in e-commerce networks. According to Liu and Issarny (2004),sata(o)is used to updateExpa(p)tandweighta(p)tfor training and obtaining more accurate results. The updating experience is depicted as Eq. (3), whereρ(t-t′)is a fading factor andExpa(p)treduces over time but is complemented by the arrivingsata(o):Eq. (4) clarifies weight updation, whereρ(t-t′)is a fading factor similar to that in Eq. (3);diffis determined according to the similarity of the recommendation with the node’s own experience. As shown in Eq. (5), ifLRepp(o)t′is similar toExpa(o)t′,diffis high and with highweighta(o)t′. More details can be found in Liu and Issarny (2004).(4)weighta(o)t′=weighta(o)t∗ρ(t′-t)+diff∗(1-ρ(t′-t))(5)diff=1-|LRepp(o)t-Expa(o)t′|.In the computation of GRep stage, after the central controller receives LReps from the distributed nodes, the new GRep is computed. Eq. (6) shows that GRep contains three values: historical, online, and predicted (Onolaja 2012).(6)GRep(o)t=μhθh+μoθo+μfθf,whereθhis the historical value, the average of past GReps;θois the online value, the just-uploaded GRep;θfis the value predicted using a neural network; andμh,μo, andμfare the scaling factors. To adapt to a rapid change,μomust be higher thanμf. We used Onolaja’s (2012) settings of scaling factors in the experiment. An artificial neural network (ANN) need not have prior knowledge to operate in an unknown network; thus it can handle unexpected malicious behaviors.Finally, the central controller obtains a new GRep, which is uploaded to all cluster heads. After a node trades with other nodes, it receives a new GRep from the cluster heads and determines whether to trade.Cluster heads are responsible for gathering information and balancing network loads. Because cluster heads have higher computational power and storage capacity (Onolaja 2012), their security is more stable and they can quickly filter noise data. In addition, cluster heads have a cache of GRep, meaning that cluster heads can quickly respond to GRep requests.

@&#CONCLUSIONS@&#
Trust problems in unknown networks are crucial because they may result in network inefficiency and even meltdown. Therefore, detecting malicious nodes in unknown networks is essential. The dynamics of trust is a research topic because it damages entire networks and is difficult to capture. Therefore, we proposed a mechanism based on a DDDAS with a semi-distributed architecture. DDDAS can dynamically inject data to the system and give feedback. We used two metrics, local reputation and global reputation, to build the proposed mechanism. Local reputation is dynamically and selectively injected to the central controller, and the central controller collects the injected data to compute global reputation, which contains the neural network prediction method, and returns it to provide reference to the distributed nodes. The proposed mechanism focuses on the dynamics of trust and the balance between distributed nodes and the central controller. The experimental results showed that the dynamics of trust was captured and only a part of the reputation data was uploaded to the central controller. The proposed mechanism quickly increases or reduces global reputation (average 26.5%) during 50 ticks after dynamics of trust occurs. In addition, the proposed mechanism only uploaded local reputation (average 52.21%); that is, it saved on average 47.79% of the network throughput.Some aspects and concerns in this study are worth further research. The first is to provide more functions in the cluster heads, which collect LReps, and the second is to use multiple central controllers. For example, cluster heads can reject servicing the requests of malicious nodes and can cross-compare the uploaded values to recognize malicious nodes in advance. The objective of these functions is to relieve the pressure on the central controller, thus making the mechanism more efficient. Furthermore, the proposed mechanism has only one central controller. Although the central controller efficiently resists attacks, it is not absolutely secure, and thus multiple central controllers can be considered. Building a mechanism of exchange between central controllers and preventing them from being attacked are critical concerns. Because of the increased computing ability and storage capacity, multiple central controllers will provide more accuracy than distributed nodes do.