@&#MAIN-TITLE@&#
Scheduling resource-constrained projects with a flexible project structure

@&#HIGHLIGHTS@&#
We present the problem to schedule resource-constrained projects with a flexible project structure.The model for the classical RCPSP is extended to cover the choice on the project structure.We present a genetic algorithm to solve resource-constrained scheduling problems with flexible project structure.In a comprehensive numerical study, the developed algorithm proves to be fast and accurate.

@&#KEYPHRASES@&#
Project scheduling,Genetic algorithms,RCPSP,Flexible projects,

@&#ABSTRACT@&#
In projects with a flexible project structure, the activities that must be scheduled are not completely known in advance. Scheduling such projects includes deciding whether to perform particular activities. This decision also affects precedence constraints among the implemented activities. However, established model formulations and solution approaches for the resource-constrained project scheduling problem (RCPSP) assume that the project structure is provided in advance. In this paper, the traditional RCPSP is extended using a highly general model-endogenous decision on this flexible project structure. This extension is illustrated using the example of the aircraft turnaround process at airports. We present a genetic algorithm to solve this type of scheduling problem and evaluate it in an extensive numerical study.

@&#INTRODUCTION@&#
In the classical resource-constrained project scheduling problem (RCPSP), the project structure is provided exogenously, i.e., all activities and precedence constraints are known, and all activities must be implemented. In this paper, the RCPSP is extended using a model-endogenous decision on the project structure. For projects with a flexible project structure, scheduling includes deciding whether to implement specific optional activities and impose the related precedence constraints.Because of these constraints, any predecessor activity must be completed before a directly succeeding activity can be started. In addition, resource constraints must be considered for renewable and/or non-renewable resources. Renewable resources, e.g., machines or human resources, are available in a given quantity in each period. By contrast, non-renewable resources are limited for the entire planning horizon. An example of this latter type of resource is the budget available for the entire project. It is not necessary to consider this type of resource in the classical RCPSP. However, for projects with a flexible project structure, the resource requirements for a non-renewable resource may vary because of the (non-)implementation of some activities so that a particular project structure may be infeasible due to a non-renewable resource. The typical aim of the RCPSP is to create a schedule that minimizes the total makespan of the project, i.e., the completion time of the last activity. The established multi-mode extension of the RCPSP (MRCPSP, cf., e.g., Talbot, 1982) can be interpreted as a special case of the problem studied in this paper. In the MRCPSP, each activity can be performed in one or more alternative modes, one of which must be selected, while all precedence constraints must be respected, regardless of the chosen activity modes. In our approach, we would introduce a specific activity that corresponds to each mode of the MRCPSP and impose the same set of precedence constraints. Thus, the MRCPSP is included in the problem studied in this paper. However, as observed below, the modeling flexibility that our approach achieves notably exceeds that of the MRCPSP.The remainder of this paper is organized as follows. In Section 2, the assumptions for the RCPSP with model-endogenous decision on the project structure (RCPSP-PS) are stated, and a practical example is provided. In Section 3, we develop a mathematical model for the RCPSP-PS. The genetic algorithm to solve the problem is presented in Section 4. We report the numerical results in Section 5. The paper ends with some conclusions and suggestions for further research in Section 6.In projects with a flexible project structure, decisions must be made whether to implement specific activities and impose specific precedence constraints, which leads to the question of how to model this flexibility of the project structure.Even in flexible projects, some activities and the precedence constraints among those activities might be mandatory, i.e., they must always be implemented, as in a classical RCPSP. In addition, to develop the RCPSP-PS, we assume that(i)Choices among alternative activities must be made, which (eventually)Cause the (non-)implementation of further activities, and/orTrigger further choices.Because of assumptions (ii) and (iii), such a RCPSP-PS with a flexible structure differs from the multi-mode MRCPSP with a rigid project structure. In the RCPSP-PS, a set of potential precedence constraints is defined in the same manner as the precedence constraints in the RCPSP. However, this potential precedence constraint is only enforced if both the preceding and the succeeding activities that are connected via this constraint are actually implemented in a schedule. In this schedule, the starting and finishing times of the implemented activities are determined. Thus, the timing of the implemented activities and the decision on the project structure are interdependent. In addition, the decision about the project structure, which addresses topics (i)–(iii), can be combinatorial. Therefore, it is unreasonable to separate these two planning steps from each other. Instead, the decision about the project structure and the timing of activities should be made model-endogenously and simultaneously.For example, these flexible projects can describe the passenger aircraft turnaround process at an airport, which is explained in the next subsection to illustrate the problem. However, flexible projects are also found in other fields. The basic idea for the model presented in this paper evolved from the interdisciplinary collaborative research center “Regeneration of complex durable goods”, in which the often highly individual overhaul of complex capital goods such as aircraft engines is investigated, see www.sfb871.de. For a given wear pattern of an engine, alternative regeneration processes may be legally possible within the airworthiness regulations and the engine manual of the engine producer, leading to a flexible project structure in which alternative activities reflect alternative methods to regenerate the aircraft engine. However, because of the high complexity of those regeneration processes, we use the example of the much less complex but project-type structured passenger aircraft turnaround process for illustrative purposes, although this process is typically not called a “project”.The aircraft turnaround process consists of the steps through which a passenger aircraft passes between its arrival at an airport and its next departure. This turnaround process can be interpreted as a (small) project and organized in different ways, cf. Kuster, Jannach, and Friedrich (2009).Table 1presents a strongly simplified version of the flexible turnaround process. Some activities are mandatory, e.g., cleaning the aircraft, catering and boarding. The choice among alternative arrival options affects the (de-)boarding of the aircraft. The aircraft can arrive either at the apron of the airfield or at the terminal. If the aircraft arrives at the terminal, this choice activates two other activities. First, passenger deboarding must be performed using a bridge. Second, a push-back operation must be performed using a tow vehicle to transport the aircraft back to the airfield. If the aircraft arrives at the apron, this triggers another choice related to deboarding: after leaving the aircraft via stairs, the passengers can (in principle) either walk to the terminal building or be transported by a bus. Finally, there is a choice of fueling. If firefighters supervise the fueling, passengers may board the aircraft while it is being fueled. Without the supervision of firefighters, fueling must be completed before passengers may board the aircraft. (To simplify the example, we intentionally abstract from different boarding operations and possible aircraft relocation operations.) This tiny and simplified example of a flexible project contains all problem aspects introduced in Subsection 2.1. We will return to the example in Subsection 3.1.There is a broad body of literature on resource-constrained project scheduling. Demeulemeester and Herroelen (2002) provide a broad overview of the basic principles and approaches in this field. Extensive literature surveys are provided by Hartmann and Briskorn (2010), Kolisch and Padman (2001), Herroelen, De Reyck, and Demeulemeester (1998), Özdamar and Ulusoy (1995) as well as Brucker, Drexl, Möhring, Neumann, and Pesch (1999). Thus, only the most important research publications regarding execution modes of activities are addressed here.In the multi-mode extension of the RCPSP, the MRCPSP (cf., e.g., Talbot (1982), or for a recent survey Wȩglarz, Józefowska, Mika, & Waligóra, 2011), different execution modes can be available for an activity. Although the capacity load and duration vary over these different modes, each activity still must be implemented. Thus, the precedence relations are fixed, and the set of activities to be implemented, i.e., the project structure, does not vary in the MRCPSP. Therefore, even if a dummy-mode with a duration of 0 units is implemented, which indicates that an activity is not implemented, it is not possible to remove the precedence restrictions that accompany fueling without firefighters in the above example. Another difference between the RCPSP-PS studied in this paper and the MRCPSP is the independent choice of modes of the MRCPSP, i.e., a selected mode for one activity does not imply a specific mode for another activity. Indeed, some papers consider that all activities in a predefined set must be executed in the same mode (cf., e.g., Salewski, Schirmer, and Drexl (1997) and Drexl, Nissen, Patterson, and Salewski (2000), pp. 62–64). However, it is not possible to assure that, e.g., only one activity is allowed to be performed in the dummy-mode. Naber and Kolisch (2014) have treated a specific different type of flexibility with respect to resource profiles such that the more of a resource is allocated to an activity at a moment in time, the shorter its duration is.Tiwari, Patterson, and Mabert (2009) extended the MRCPSP using rework activities. Rework is required if the original activity is implemented in a specific predefined mode. In this approach, rework always consists of a single activity that is a direct successor of the original activity causing the rework activity. This requirement results in variation in the project structure, although only to a notably limited extent because only single rework activities can be activated.Belhe and Kusiak (1995) present the so-called “design activity network” to include logical dependencies among some activities. For a logical “or” dependency, a decision must be made regarding which branch in the network is implemented. Čapek, Šůcha, and Hanzálek (2012) also examined alternative process plans. In contrast to the RCPSP-PS, these approaches assume that a logical dependency among activities always accompanies a precedence constraint among these activities. Using their design activity network, Belhe and Kusiak (1995) generated all possible precedence networks and analyzed them separately via a (potentially time-consuming) full enumeration.The notion that the project structure is not known in advance has also been treated in the context of stochastic project networks, cf. Elmaghraby (1964) or Neumann (1990). In contrast to this paper, the decision on the implementation of activities depends on random exogenous influences and is made as the project progresses. Therefore, the developed methods for stochastic project networks consider a different problem class than that treated by the RCPSP-PS in this paper.Kuster et al. (2009, 2010) have addressed disruption management problems at airports with alternative process implementation paths. The basic assumptions are similar to the RCPSP-PS. However, their approach only treats the rescheduling problem and does not address the question of how to create a new schedule considering the flexibility of the project structure. Furthermore, the authors did not present a mathematical model to precisely describe their problem setting.To the best of our knowledge, the RCPSP-PS has not been treated in the literature. However, it appears to contain several of the problem settings described as special cases. A preliminary introduction to this scheduling problem has been presented in Kellenbrink (2014a) without a formal model and the details of the algorithm or the numerical analysis presented in this paper, see also for more details Kellenbrink (2014b).The resource-constrained project scheduling problem with a flexible project structure (RCPSP-PS) generalizes the established modeling approach of the RCPSP (cf., e.g., Pritsker, Watters, & Wolfe, 1969). The RCPSP and our RCPSP-PS are modeled as an activity-on-node network and built around a central binary variable xjtfor activityj∈Jand periodt∈T. This variable indicates whether activity j is finished in period t, i.e., xjt= 1, or not, i.e., xjt= 0. Using this established variable, the structural decision of whether to implement an activity can be implicitly described: if an activity j is not implemented, the corresponding binary variable xjtis 0 for each period t. Thus, we can expand the modeling flexibility of the RCPSP without introducing new decision variables. Instead, we use indices and sets of indices to model the project structure flexibility, which is introduced in Subsection 2.1 and exemplified in Table 1 as follows:•We denote withe∈Eall choices that may be made.The activitiesj,i∈Jare topologically ordered so that for any pair of activities i and j with i < j, there must not be a constraint that enforces activity j to precede activity i.The subsetV⊆Jcontains all mandatory activities, i.e., those that must always be implemented. The other activities are non-mandatory or optional.Each choice e consists of the selection of exactly one activity j among several optional activitiesWe⊆J∖V. Each optional activity can belong to at most one setWe.Each choice e is connected to a triggering activity a(e). If the triggering activity a(e) is mandatory (as is the dummy “start” activity i = 1), choice e is also mandatory, i.e., a(e) = 1, and one optional activityj∈Wemust be implemented. However, the triggering activity a(e) might be optional. In this case, it must be among the optional activities related to exactly one (earlier) choice e′, i.e.,a(e)∈We′for one e′. In this latter case, it is possible that choice e is not triggered; hence, no optional activityj∈Weis implemented.An optional activityj∈Wemight have a set of (dependent) optional activitiesk∈Bj⊆J∖V. All caused activities k must be implemented if the optional activity j itself is implemented. The activities are numbered so thatk∈Bjimplies j < k. Each optional activity belongs to either one setWeor one setBjwithj∈We.Any choice e can only be triggered by an activity a(e) that must not succeed the optional activitiesj∈Weto avoid cycles of cause and effect. In this case, the topological ordering of the activities can be such that the condition a(e) < j holds for each choice e and each optional activityj∈We.Like the activities, the choices e are also topologically ordered such that for any pair of choices e′ and e with e′ < e, choice e must not trigger choice e′.A precedence constraint is implemented whenever it connects two implemented activities.We use the example introduced in Subsection 2.2 to illustrate the use of these sets and indices. To this end, we also introduce a specific graphical representation based on an activity-on-node network. Each choice e is represented as an oval around its optional activitiesj∈We. Activities caused by other activities are specifically marked. Note that the established graphical representations of project networks are not suitable to represent projects with a flexible project structure, cf. Kuster et al. (2009), p. 244. Even the graphical evaluation and review technique (GERT, cf., e.g., Neumann (1990), pp. 17–19) used for stochastic project networks is not appropriate because it is not possible to represent logical dependencies and precedence constraints independently. In contrast to the RCPSP-PS, in which the activities ‘bridge’ and ‘push-back’ in our example depend on each other without being linked by a direct precedence constraint, in a GERT network, a logical dependency among activities always accompanies a precedence constraint among these activities.The project network for the turnaround example is presented in Fig. 1. Precedence constraints related to an optional activity are depicted as broken arrows. The set of mandatory activities isV={begin,cleaning,catering,boarding,end}. Choice 1 is the mandatory choice among the alternative activities concerning the arrival (W1={terminal,apron}). Because it is mandatory, choice e = 1 is triggered by the beginning activity, i.e., a(1) = `begin'. The arrival at the terminal causes deboarding by bridge and the push-back (Bterminal={bridge,push-back}). The optional choice 2 is caused by the decision to arrive at the apron a(2) = `apron' and determines how deboarding passengers are transported from the apron to the terminal. The optional activities for e = 2 areW2={byfoot,by bus}. Finally, there is a mandatory choice e = 3 with a(3) = `begin' regarding the fueling (W3={fueling(withfirefighters),fueling}).The presented modeling approach of introducing new setsE,V,WeandBjand indices without changing the decision variable xjthas the effect that only limited modifications of the RCPSP are necessary to formally establish the RCPSP-PS, cf. Klein (2000), pp. 79–80. It is presented below using the notation in Table 2.Model RCPSP-PS(1)minZ=∑t=EFTjLFTjt·xJtsubject to(2)∑t=EFTjLFTjxjt=1j∈V(3)∑i∈We∑t=EFTiLFTixit=∑t=EFTa(e)LFTa(e)xa(e),te∈E(4)∑t=EFTiLFTixit=∑t=EFTjLFTjxjte∈E;j∈We;i∈Bj(5)∑t=EFTiLFTit·xit≤∑t=EFTjLFTj(t−dj)·xjt+T·(1−∑t=EFTjLFTjxjt)j∈J;i∈Pj(6)∑j=1J(kjr·∑τ=tt+dj−1xjτ)≤Krr∈R;t∈T(7)∑j=1J(kjr·∑t=EFTjLFTjxjt)≤Krr∈N(8)xjt∈{0,1}j∈J,t∈TIn the objective function (1), the completion time of the last activity J and consequently the makespan of the project are minimized. Constraints (2)–(5) model the flexible project structure. Eq. (2) declares that each mandatory activityj∈Vmust be implemented once.Eq. (3) reflects the choicese∈Eon the project structure. If choice e is triggered by the implementation of an activity a(e), exactly one activityi∈Wemust be chosen for implementation. Note that none of the optional activitiesi∈Weis implemented if choice e is not triggered. Eq. (4) treats the implemented non-mandatory activities caused by other implemented non-mandatory activities. If activityj∈Weof choice e is implemented, each activityi∈Bjmust also be implemented.Constraint (5) states that a predecessori∈Pjmust be finished before the successive activity j can be started. Because of the second summand on the right-hand side of the constraint, this constraint can only be binding if both predecessor i and successor j are implemented.Constraint (6) ensures that the resource requirement kjrof all activities that affect period t does not exceed the available capacity Krof any renewable resourcer∈R. In addition, constraint (7) states the capacity constraints of the non-renewable resourcesr∈N.Note that in the standard RCPSP with its exogenous project structure, it is possible to determine the earliest and latest starting and ending times of all activities using simple forward and backward recursions by ignoring the capacity constraints. In the context of our RCPSP-PS, the earliest finishing times EFTj were computed via a standard forward recursion considering only the mandatory activities. To compute latest finishing times LFTj, we used the sum of all (mandatory or optional) activities as (an upper bound on) the project deadline and performed a standard backward recursion. If the setEof choices is empty, constraints (3) and (4) disappear, and the classical RCPSP results.We introduce in Fig. 2 a simple project comprising 10 activities. In this project, a mandatory choice must be made between the implementation of activity 4 and activity 5. If and only if activity 4 is chosen, activity 9 is implemented. If and only if activity 5 is chosen, decision 2 is triggered. The optional choice 2 is about the implementation of activity 7 or activity 8.There are three different project structures with specific sets of implemented activities for this project:A={1,2,3,4,6,9,10},B={1,2,3,5,6,7,10},andC={1,2,3,5,6,8,10}. In addition to the mandatory activities 1, 2, 3, 6, and 10, in project structure A, the optional activities 4 and 9 are implemented. In project structures B and C, the optional activity 5 is chosen in the mandatory decision 1, which triggers decision 2. In this decision, in project structure B, activity 7 is implemented, and in project structure C, activity 8 is chosen.In Table 3, the duration and resource requirement of a single renewable resource is provided. There is no non-renewable resource.We present in Fig. 3the variation of the optimal makespan of this project, which depends on the capacity of the renewable resource K1. An increase in K1 leads to a decrease in the makespan and a change in the optimal project structure. Similar effects are obtained for non-renewable resources.These characteristics demonstrate that the decision on the project structure should be treated together with the scheduling decision because the capacity restrictions affect the selection of the optimal project structure.For each given decision on the project structure, the RCPSP-PS reduces to the RCPSP, so that this problem can, in principle, be solved using a full enumeration over all possible project structures. However, this approach does not appear to be very efficient. We experimented with a slightly larger but still small example comprising only 30 activities, which yielded 12 alternative project structures due to a few endogenous choices.The computation time to solve the problem RCPSP-PS to optimality with CPLEX was only approximately 9 percent of the required time to optimally solve all 12 RCPSPs with a given project structure. This result demonstrates that although the RCPSP-PS is a generalization of the RCPSP with a higher degree of freedom, the time required to solve the RCPSP-PS is not necessarily much larger than that required to solve one RCPSP. Furthermore, Fig. 4presents the distribution of the optimal objective function values over the 12 different project structures. The variance is apparently large, so it is important to find the optimal project structure.The RCPSP-PS includes the RCPSP as a special case, which is already known to beNP-hard, see Blazewicz, Lenstra, and Rinnooy Kan (1983), p. 21. Thus, we must resort to heuristic approaches to solve large problem instances. Genetic algorithms are among the most powerful algorithms for the RCPSP (cf., e.g., Lim, Ma, Rodrigues, Tan, and Xiao (2013), Gonçalves, Resende, and Mendes (2011), Valls, Ballestín, and Quintanilla (2008), Debels and Vanhoucke (2007), Zamani (2013), Van Peteghem and Vanhoucke (2014) and Tseng and Chen, 2006) and its extensions (cf., e.g., Van Peteghem and Vanhoucke (2010), Lova, Tormos, Cervantes, and Barber (2009), Gonçalves, Mendes, and Resende (2008) and Alcaraz, Maroto, and Ruiz, 2003). Hence, we present a genetic algorithm for this new problem class.Genetic algorithms mimic evolutionary processes in biology. Evolution is considered the process by which a species attempts to adapt to its environment by mating to produce potentially “fitter” offspring with modified characteristics and an improved chance of survival. This process is interpreted as a general population-based approach to solve an optimization problem and can be mimicked to solve mathematical optimization problems. In this solution approach, each individual in the population represents a solution of the underlying problem. The genetic algorithm starts with the initialization of a start population. Subsequently, over the course of several generations of populations, new individuals are generated by crossover, mutation and selection, cf. Goldberg (1989).The genetic algorithm for the RCPSP-PS is a modification and generalization of the genetic algorithm for the MRCPSP presented in Hartmann (2001). To extend that approach using the model-endogenous decision on the project structure, the representation of the individuals, population initialization, crossover and mutation proposed in Hartmann (2001) were generalized and modified. As the basis for all further modifications, we begin with the explanation of the representation of individual solutions of the RCPSP-PS.Any solution of the RCPSP-PS consists of two components. The first component addresses the chosen structure of the implemented network of activities, i.e., the ensemble of actually implemented optional activitiesj∈Wefor all choicese∈E,the mandatory activitiesj∈Vand the related precedence constraints. The second component eventually determines the schedule of those activities that are actually implemented based on those former choices on the structure. To represent a solution, we consequently use a combination of a choice list α to reflect the chosen structure and an activity list λ supplemented by an implementation list ν to (indirectly) determine the actual schedule. The general structure for an individual II=(ChoicelistαActivitylistλAuxiliaryinformationImplementationlistν)is detailed as follows:I=(α1α2…αEλ1λ2…λJa(1);W1a(2);W2…a(E);WEνλ1νλ2…νλJ)The choice list α = (α1, α2, … , αE) contains the selected optional activityj∈Wefor each of the choices e. The auxiliary information below the choice list only serves expository purposes in this paper to explain the examples and is not actually implemented in our algorithm. For each choice e, the auxiliary information contains the triggering activity a(e) and the set of optional activitiesj∈We(remember that any mandatory choice is triggered by the start activity).The activity list λ = (λ1, λ2, … , λJ) contains all activities in the sequence in which they are treated during the process of creating a schedule using the serial schedule generation scheme, cf. Kelley (1963), pp. 352–353 or Kolisch and Hartmann (1999), p. 152. However, because of the choices on the project structure, some optional activities on the activity list are not implemented. Thus, the activity list is supplemented by an implementation listν=(νλ1,νλ2,…,νλJ). The elements of the implementation list are binary coded. If the associated activity on the activity list is implemented, the element of the implementation list is equal to 1, otherwise it is 0. Note that there is a redundancy of information between the choice list α and the implementation list ν, which we deliberately use here to explain the algorithm. In our implementation of the genetic algorithm, we only used the right-hand side of an individual, i.e., the activity list λ and the implementation list ν. This reduced representation is notably similar to that from Hartmann (2001) if 0 on the implementation list ν is interpreted as a mode in which the activity is not implemented.An activity list is feasible if the sequence of activities on the activity list does not contradict any active precedence constraint of the project. If an implemented activity i must precede another implemented activity j because of the precedence constraints, this activity i must also precede activity j in the activity list. An example of why we only consider the active precedence constraints is the (indirect) precedence constraint between activity 2 and activity 6, which is not active in project structure B of our example (see Fig. 5) because of the non-implementation of activity 4. To avoid prohibiting some solutions, we allow activity 6 to be executed before activity 2. A feasible activity list can be decoded to a unique schedule. In the serial schedule generation scheme, each active element of the activity list is scheduled as early as possible based on the available capacity of renewable resources and the precedence constraints. This method creates a so-called active schedule, in which no activity can be started earlier without delaying another activity, cf. Kolisch (1996), p. 325.To explain all central elements of the genetic algorithm, we refer to the example of a flexible project introduced in Subsection 3.3. We consider the second possible project structure with the setB={1,2,3,5,6,7,10}of implemented activities, which is also shown in Fig. 5 (using solid arrows and boxes for implemented activities and precedence constraints). One possible solution to the remaining scheduling problem for this structure is represented by the following individual, which is denoted as IM:IM=(57136428579101;{4,5}5;{7,8}1110101101)The choice list indicates that in the mandatory choice 1, activity 5 is selected. Because the optional choice 2 is triggered by activity 5, either activity 7 or 8 must be implemented, and activity 7 is chosen. The implementation list contains the (derived) information that activities 4, 8, and 9 are not implemented. The activity list shows that the implemented activities are treated (within the scheduling process) in the sequence 1, 3, 6, 2, 5, 7, and 10.The feasibility of an activity list depends on the content of the choice list and the corresponding implementation list. Assume that in choice 1, activity 4 had been chosen instead of activity 5. In this case, it would have been necessary to consider an (indirect) precedence relation between activities 2 and 6, cf. Fig. 5. The current activity list would violate this constraint and therefore be infeasible.Fitness values are computed only for individuals with a feasible activity list. If (according to the implementation list) the individual is also feasible with respect to the non-renewable resources, its fitness value is simply the makespan of the project. A lower fitness value corresponds to a better individual. However, if the implemented activities exceed the available capacity of the non-renewable resources, the individual does not represent a resource-feasible schedule regardless of its makespan. In this case, the fitness value is computed as the length of the planning horizonT=∑j=1Jdjplus the additionally required capacity of the non-renewable resource(s), as in Hartmann (2001). Therefore, individuals that represent infeasible schedules always have a higher (worse) fitness value than feasible individuals.To illustrate the fitness computation, we return to the example introduced in Subsection 3.3. We assume that no non-renewable resource and only one renewable resource with a capacity K1 = 10 are required and use the additional data in Table 3. The scheduling sequence 1, 3, 6, 2, 5, 7, 10 from the activity list leads to the schedule in Fig. 6(note that activities 1 and 10 are “dummy” activities with zero duration and resource requirement). The makespan of the project, which is the fitness value F(IM), is 14.At the beginning of the genetic algorithm, NIindividuals are generated as a start population. For each individual, a choice list, an activity list and an implementation list are determined randomly but consistently. Because the feasibility of the activity list depends on the choice list and, hence, the implementation list, the initialization of the individuals begins with the decision on the network structure, i.e., the choice of optional activities.First, all mandatory activities are activated(νj:=1,j∈V). All other activities are deactivated, at least initially(νj:=0,j∉V). Next, each choicee∈Eis considered in the sequence of the topological ordering of choices. If choice e is triggered by the mandatory start activity or a previously selected optional activity (νa(e) = 1), one activityj∈Weis randomly selected (αe≔ j) and activated (νj≔ 1). After considering all choices e, all activities i that are caused by the activated optional activities are also activated (νi:=1,i∈Bjwith νj= 1).The procedure for determining the choice list and the implemented activities is demonstrated below using the example project introduced in Subsection 3.3. Now, a new individual IFis generated. First, the mandatory activities 1, 2, 3, 6, and 10 are activated (ν1F=ν2F=ν3F=ν6F=ν10F:=1), and all optional activities are deactivated (ν4F=ν5F=ν7F=ν8F=ν9F:=0). In mandatory decision 1, activity 4 is randomly selected (α1F:=4;ν4F:=1). Therefore, choice 2 is not triggered (ν5F=0), and neither of the optional activities 7 and 8 is activated. Eventually, activity 9 is caused by the activation of activity 4 (ν9F:=1).Given the information on the activities to be implemented, the resource requirement for the non-renewable resources can now be computed. If the available capacity is exceeded for any non-renewable resource, a new project structure must be determined. If the number of trials to compute a feasible selection of activated optional activities exceeds Trialmax, the procedure continues with the infeasible selection of activated optional activities (and a prohibitively poor fitness value).Afterwards, the activity list is determined. For each position on the activity list, a set of activities that are eligible to be placed at that position is determined. In this set of eligible activities, implemented and not implemented activities are considered. An activity is eligible if it has not been placed on the activity list and if all active predecessors have been placed on the activity list. The only exception is the dummy activity J, which is disregarded at this point in the algorithm and is always positioned at the last position of the activity list. A probabilistic dispatching procedure based on the latest start times, see Baker (1974), p. 204, and Appendix A, is used to randomly choose one activity from this set of eligible activities for the current position on the activity list.One possible combination of choice list, activity list and implementation list for the described choices leads to the following individual IF:IF=(4−123745689101;{4,5}5;{7,8}1110101011)The corresponding schedule (not shown here) has a makespan of 13 time units.In the crossover operation of the genetic algorithm, two parent individuals IM(“mother”) and IF(“father”) are combined to create two new child individuals IDand IS. Each new individual possesses traits of two distinct individuals from the previous generation. Each individual from the parent generation is chosen exactly once as a mother or a father of two children. In Algorithm 1, we show how a daughter IDinherits from (mother) IMand (father) IF. A son ISis analogously created. Only the roles of the mother and father in the algorithm are exchanged.As in the initial population, all mandatory activities of the daughter are initially activated(νjD:=1,j∈V),and all optional activities are initially deactivated(νjD:=0,j∉V). A crossover parameter cαis randomly determined (1≤cα≤|E|). The first cαchoices are inherited from IM, which affects both the choice list αDand the implementation parameter(νjD:=νjM,j∈We). The remaining choices are inherited from IF. Note that a choice e inherited from the mother (e ≤ cα) can trigger another choice e′ with cα< e′ to be inherited from the father. If that decision e′ is not (also) triggered for IF, choiceαe′and the implementation state are also inherited from the mother IM(νjD:=νjM,j∈We′). Finally, all possibly caused activities are activated if the causing activity is implemented (νiD:=1,i∈BjifνjD=1).The crossover of the activity list λ is taken from Hartmann (2001). First, the crossover parameter for the activity list cλis randomly determined (1 ≤ cλ≤ J). The cλfirst activities are inherited from the mother’s activity list λM. The sequence of the remaining activities is inherited from the father’s list λF.We apply the crossover to the example from Subsection 3.3 with assumed crossover parameters cα= 1 and cλ= 4 and create the daughter ID. The first choice e is inherited from IM, i.e., activity 5 is activated (α1D:=α1M=5andν5D:=1). The second decision should (in principle) be inherited from IF. However, this inheritance is not possible because this decision is not triggered for the father but is triggered for the daughter. Therefore, the choice and the implementation state are taken from the mother, i.e., activity 7 is chosen (α2D:=α2M=7andν7D:=1). No further activity is caused. In the activity list, the first four (cα= 4) activities (1, 3, 6, 4) are inherited from the mother λM, and the order of the remaining activities (2, 7, 5, 8, 9, 10) is inherited from the father λF.For the son IS, the first decision is inherited from IF, i.e., activity 4 is activated (α1S:=4andν4S:=1). The second decision is not triggered for the son. Therefore, no value is assigned toα2S. The choice to implement activity 4 causes the implementation of activity 9 (ν9S:=1). In the activity list, the first four activities (1, 2, 3, 7) are inherited from λF, and the order of the remaining activities (6, 4, 8, 5, 9, 10) originates from λM.IM=(57136428579101;{4,5}5;{7,8}1110101101)IF=(4−123745689101;{4,5}5;{7,8}1110101011)ID=(57136427589101;{4,5}5;{7,8}1110111001)IS=(4−123764859101;{4,5}5;{7,8}1110110011)Note that the implementation list ν of the newly created daughter IDand son ISreflects its respective choice list αDor αS. The activity list λDor λSof the new individual may be inconsistent with the possible new project structure and may require a repair. This problem is addressed in the next subsection, along with the mutation operation.The mutation operation creates some random diversity in the population of solutions. The objective is to make such spaces of the solution space accessible that cannot be reached by combining elements of the known solutions using the crossover. Thus, individual elements of the solution are occasionally changed (or mutated) at random. In our context, this method affects the project structure (as expressed by the choice list α and the corresponding implementation list ν) and the schedule (as determined by the activity list λ). Systematic repair operations may be necessary to ensure that the contents of different lists are consistent and feasible. Note that the crossover operation might have led to an infeasible activity list λ. Thus, we use a three-step approach to mutate and repair. In the first step, mutation is applied to choice list α. In the second step, activity list λ, which may now be infeasible, is repaired. This step leads to a consistent and feasible combination of choice list α, activity list λ and implementation list ν. In the final step, the activity list λ is mutated in such a way that only feasible solutions result. The procedure is shown in Algorithm 2.For the mutation of the choice list α and implementation list ν (in the first of the three steps), each decision is considered. If a previously not triggered choice e is now triggered due to the mutation, one activityj∈Weis randomly selected, and choice list α and implementation list ν are updated. Otherwise, with a low mutation probability mα, an activityj∈Weis randomly selected to replace the previous activity αeif it differs from j. If choice e is currently not triggered but was previously triggered, it must be deactivated. Finally, all dependent activitiesi∈Bjfor eachj∈Weare updated (νi≔ νj).We use the individuals IDand ISfrom Subsection 4.4 to demonstrate the mutation of the implementation list. For ID, we assume that a mutation occurs in the second choice e = 2. Instead of activity 7, activity 8 is activated (α2D:=8;ν7D:=0,ν8D:=1). No further adjustment is necessary for ID.In the case of IS, we assume that, due to a mutation of the first choice e = 1, activity 5 is implemented instead of activity 4 (α1S:=5;ν4S:=0,ν5S:=1). Thus, the second decision is triggered. Activity 7 is randomly selected fromW2(ν7S:=1). Due to the deactivation of activity 4, activity 9 is no longer caused and must be deactivated (ν9S:=0).ID=(58136427589101;{4,5}5;{7,8}1110101101)IS=(57123764859101;{4,5}5;{7,8}1111100101)The second step of the algorithm is only performed if the activity list λ is infeasible because there is a pair (i, j) of activities that are both active (νi= νj= 1) and exhibit a precedence constrainti∈Pj,even though activity j precedes activity i on the activity list λ. The activity list is re-sequenced by placing activity j behind i on the activity list for all such conflicting pairs.For the individual IDof our example, no repair of the activity list λ is necessary: all precedence constraints are satisfied. However, for the individual IS, the precedence relation between activities 5 and 7 is violated, which requires the postponement of activity 7 until activity 5 has been placed on the activity list. The sequence of the remaining activities must not be changed, which leads to the following (preliminary) result:IS=(57123648579101;{4,5}5;{7,8}1111001101)The mutation of the activity list in the third step is implemented analogously to Hartmann (2001). With a low probability mλ, activity j is selected to be exchanged with the next implemented activity i in the activity list. This exchange is only feasible and consequently implemented if activity j is not a predecessor of activity i (j∉Pi).In our example, a mutation of activity λ7 = 5 is attempted for ID. The next active activity is activity λ8 = 8. Because of the precedence relation between these activities, the mutation is not feasible. For IS, an exchange of activity λ4 = 6 with the next implemented activity (λ7 = 5) is intended. This exchange is feasible, and thus the positions of these activities are exchanged (λ7 ≔ 6, λ4 ≔ 5) to give the following result:IS=(57123548679101;{4,5}5;{7,8}1111001101)After the mutation, the generation of new individuals is finished. For each individual, the fitness can be computed, and the best NIindividuals among the parent and children generation are selected as the parent generation for the next iteration of the genetic algorithm. The crossover, mutation and selection procedures of the genetic algorithm are reapplied until NGgenerations are created and evaluated. The fittest individual and the corresponding best schedule of the last generation is then chosen as the solution of the underlying problem.For the presented example, the fitness F of the individuals is F(IS) = 14, F(IM) = 14, F(IF) = 13 and F(ID) = 12 if the schedules for individuals IF, ID, and ISare generated similarly to IMin Fig. 6. The individuals IDand IFwill be selected as the parent generation for the next iteration of the genetic algorithm if a population size of 2 is used (which is too small in a realistic attempt to use a genetic algorithm).To evaluate the genetic algorithm with respect to speed and solution quality, adequate test instances must be generated. We extended the instance generator ProGen (cf. Kolisch, Sprecher, and Drexl, 1995) to create problem instances with a flexible project structure. Four different problem classes with 30, 60, 90, and 120 non-dummy activities were generated, cf. Appendix B. Each class comprised 1536 test instances, among which some were infeasible because of limited non-renewable resources, such that 1166, 1072, 1047, and 1040 instances remained, respectively.In a preprocessing step, we identified and eliminated the optional activities that would violate the capacity constraints of the non-renewable resources if they were implemented.The genetic algorithm was implemented in Delphi XE and executed on a 2.66  GHz Intel Core2 Quad machine with 4 GB of RAM using a single thread. Each generation of the genetic algorithm consisted of NI= 80 individuals (and hence schedules). To illustrate the improvement of the solutions over the generations, we present results for 13, 63, and 125 generations NG, i.e., after generating 1040, 5040, and 10,000 schedules. The mutation parameters were set to mα= 3 percent and mλ= 10 percent, respectively.We used CPLEX 12 on a 2.00  GHz Intel Xeon machine with 20  GB of RAM and four threads in a central compute cluster at Leibniz Universität Hannover, cf. www.rrzn.uni-hannover.de/clustersystemto determine optimal reference values for all problem instances with 30 activities. It was not possible to solve all test instances with 60, 90 or 120 activities to optimality within a reasonable time. Therefore, we limited the CPLEX CPU time per instance to two hours for those three problem classes, and we solved 87.1 percent, 80.2 percent, and 73.8 percent of the instances to the proven optimum. For the remaining instances, we only computed the upper bounds.To compute additional reference values, we systematically enumerated all possible project structures per instance for all instances with 30, 60, and 90 non-dummy activities. To compute solutions for all resulting RCPSPs (with fixed structure) in this structure enumeration approach, we again used a genetic algorithm, but with a lower number of individuals or schedules for each possible project structure (NI= 50) and only 10 generations (NG= 10), i.e., 500 schedules per project structure. Because of the large number of possible project structures and the substantial computational effort, we were unable to determine reference values using this method for problem class 4, which had the largest number of non-dummy activities.

@&#CONCLUSIONS@&#
