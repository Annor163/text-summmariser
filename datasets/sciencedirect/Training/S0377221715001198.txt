@&#MAIN-TITLE@&#
Improved integer linear programming formulations for the job Sequencing and tool Switching Problem

@&#HIGHLIGHTS@&#
We study the job Sequencing and tool Switching Problem, arising in computer systems.We study the polyhedral combinatorics of the problem.We develop new integer linear programming formulations for the problem.We show that the formulations are provably better than the current state-of-the-art.

@&#KEYPHRASES@&#
Job sequencing,Tool switching,Traveling salesman problem,Combinatorial optimization,Integer programming,

@&#ABSTRACT@&#
In this article we investigate the job Sequencing and tool Switching Problem (SSP), aNP-hard combinatorial optimization problem arising from computer and manufacturing systems. Starting from the results described in Tang and Denardo (1987), Crama et al. (1994) and Laporte et al. (2004), we develop new integer linear programming formulations for the problem that are provably better than the alternative ones currently described in the literature. Computational experiments show that the lower bounds obtained by the linear relaxation of the considered formulations improve, on average, upon those currently described in the literature and suggest, at the same time, new directions for the development of future exact solution approaches.

@&#INTRODUCTION@&#
In manufacturing systems it often happens that a set of jobs, each one requiring a specific set of tools, has to be sequentially processed in a flexible machine with a capacitated tool magazine (Crama, 1997; Crama, Moonen, Spieksma, and Talloen, 2007; Tang and Denardo, 1987). The capacity of the magazine is usually suited to store the tools required by any job, but it is usually insufficient to store, at the same time, all of the involved tools. Hence, operations of tools switching (i.e., the removal of a tool from the magazine and the insertion of a new one in its place) may be necessary to sequentially process the considered set. This situation often occurs e.g., in metal working industries, where automatic machines are used to manufacture parts. Each machine performs operations by using the tools placed in its limited capacity tool magazine and requires tool switching operations when completing a job and moving to the next one in the sequence (Tang and Denardo, 1987). This situation also occurs in other contexts, such as computer systems. Specifically, a modern computer system has k pages of fast memory andn−kpages of slow memory. The system usually has to satisfy a sequence of requests to pages in their order of occurrence. A request can be addressed only if the required page is in the fast memory. If the request cannot be addressed, a page fault occurs and a page in the fast memory must be selected and moved to the slow memory in order to make room for the requested page (McGeoch and Sleator, 1994).Tools switching operations can be performed either in groups or one at a time, depending on the specific application. However, they are generally time consuming and/or expensive, hence it is usually convenient to process the jobs in such a way that the overall number of tool switches is minimized.The switching cost may be tool and/or application dependent as shown in Tang and Denardo (1987), Crama (1997), Crama et al. (2007), Crama, Kolen, Oerlemans, and Spieksma (1994), Balakrishnan and Chakravarty (2001), Belady (1966), Blazewicz and Finke (1994), McGeoch and Sleator (1994), Privault and Finke (2000). In this article we just focus on the simplest (although the main) version of the switching cost, characterized by being uniform and tool independent, and we investigate the problem of determining the job processing sequence inducing the minimum overall switching cost. Such a problem is known in the literature as the job Sequencing and tool Switching Problem (SSP) (Crama et al., 1994; Ghiani, Grieco, and Guerriero, 2010; Laporte, Salazar-Gonzáles, and Semet, 2004; Tang and Denardo, 1987). An example of an instance of the SSP is shown in Table 1. In particular, the first row in the table provides the labels of the jobs and the corresponding processing order; the last row provides the capacity of the magazine. Each column in the table refers to a particular job in the considered set and specifies the tools necessary to its processing. The empty entries in each column denote jobs requiring a number of tools smaller than the capacity of the magazine. A solution to an instance of the SSP is obtained by specifying both the sequence in which the jobs have to be processed and the tools that have to be in the magazine when a given job is processed. For example, Table 2shows a feasible solution to the instance shown in Table 1. In this case, the job processing sequence is {8, 1, 6, 4, 2, 5, 10, 3, 9, 7}; the circled tools represent tools that are unnecessary to process a specific job, but that may prove useful to decrease the overall number of switches induced by a specific job sequence. The circled tools can be added only if a job requires a number of tools smaller than the capacity of the magazine. The solution induces an overall number of tool switches equal to 15, in particular: 4 tool switches to load the tools required by job 8; 1 tool switch in the transition from job 8 to job 1; 1 tool switch in the transition from job 1 to job 6; 2 tool switches in the transition from job 6 to job 4; 2 tool switches in the transition from job 4 to job 2; and 1 tool switch in each of the remaining transitions. The size (i.e., the number of jobs and tools) of an instance of the SSP depends on the nature of the considered application and can easily range from dozens (e.g., in manufacturing systems) to hundreds (e.g., in computer systems) of jobs and tools.Although numerous applications of the SSP appeared in the literature since 1966 (see e.g., Balakrishnan and Chakravarty, 2001; Belady, 1966; Blazewicz and Finke, 1994; Crama et al., 1994; Crama et al., 2007; McGeoch and Sleator, 1994; Privault and Finke, 2000), the problem was formally stated only in 1987 by Tang and Denardo (1987). The authors first observed that the optimal solution to an instance of the SSP does not change if one removes from the instance a job whose tool set is a subset of the tool set required by another job. The authors called this property the dominance rule. For example, job 10 in Table 1 requires tools 5 and 7 i.e., a subset of the tool set required by job 4. Hence, job 10 can be removed from the instance without affecting the corresponding optimal solution. If we apply the dominance rule also to jobs 7, 8 and 9, we obtain a new instance of the SSP (see Table 3) characterized by a smaller size. Unless not explicitly stated, in this article we will always assume to work with instances of the SSP containing only jobs requiring non-dominated tool sets.Tang and Denardo (1987) also investigated a number of practical aspects of the problem and first pointed out the relationship between the SSP and the Traveling Salesman Problem (TSP) (see Garey and Johnson, 2003). In particular, the authors observed that an instance of the SSP degenerates into an instance of the TSP when (i) the tool set of each job has cardinality constant and equal to the capacity of the magazine and (ii) the switching cost is uniform and tool independent. This observation constitutes the earliest proof of NP-hardness of the SSP; a more formal and thorough analysis of the complexity of the SSP was performed seven years later by Crama et al. (1994).Interestingly, Tang and Denardo showed that the SSP can be decomposed into two nested subproblems called:1.the Sequencing Problem (SP), consisting of identifying an (optimal) job processing sequence;the Tooling Problem (TP), consisting of determining, for a given job processing sequence, what tools should be loaded in the tool magazine at each position of the sequence, in order to minimize the total number of tool switches.The authors showed that the TP can be solved in polynomial time via a greedy algorithm called Keep Tool Needed Soonest (KTNS); in contrast, the SP constitutes the hardest part of the problem. Tang and Denardo developed an integer linear programming formulation to exactly solve the problem and a constructive heuristic to approximate its optimal solution. However, the performances of both approaches proved to be rather disappointing in practice (Laporte et al., 2004). Hence, numerous research efforts focused on developing solution approaches aiming at solving, at least heuristically, instances of the SSP, see e.g., Crama (1997), Crama et al. (2007), Crama et al. (1994), Askin, Sodhi, and Sen (1994), Avci and Akturk (1996), Bard (1988), Gray, Seidmann, and Stecke (1993), Hertz and Widmer (1993), Hertz, Laporte, Mittaz, and Stecke (1998). Surprisingly enough, however, in the last two decades only a limited number of exact solution approaches have been proposed in the literature, namely Laporte et al. (2004) and Ghiani et al. (2010).Laporte et al. (2004) proposed an Integer Linear Programming (ILP) formulation and a branch-and-bound algorithm to exactly solve the SSP. The authors showed that the proposed ILP formulation was tighter than Tang and Denardo’s but, at the same time, unable to solve instances containing more than 10 jobs within 1 hour of computing time. In contrast, the branch-and-bound algorithm and the corresponding combinatorial lower bounds proved to be more successful, allowing the solution of instances of the SSP containing up to 25 jobs within the same runtime limit. Ghiani et al. (2010) proposed a different exact solution approach for the SSP based on modeling the problem as a nonlinear TSP. The authors improved the KTNS greedy algorithm for the TP and developed a branch-and-cut algorithm for the SSP exploiting a number of symmetry breaking techniques, dominance rules, and specific lower bounds. Their computational experiments showed that the proposed algorithm outperforms the performance of Laporte et al., being able to solve instances of the SSP containing up to 45 jobs within 1 hour of computing time.The weak lower bounds provided by the linear programming relaxations of the ILP formulations currently described in the literature on the SSP possibly are one of the main reasons for explaining the limited number of exact solution approaches for the problem. In this article, we address this major limitation and investigate new ILP formulations for the SSP able to provide tighter lower bounds to the problem. Starting from the results discussed in Tang and Denardo (1987), Crama (1997), Crama et al. (1994), Laporte et al. (2004), Ghiani et al. (2010), in Section 2 we briefly review the main ILP formulations for the SSP currently described in the literature. In Section 3 we present new ILP formulations for the SSP that have a Linear Programming (LP) relaxation that is provably tighter than the LP relaxation of the previous ones described in the literature. We investigate the combinatorial interpretation of the proposed formulations and we propose valid inequalities to further improve the lower bounds provided by their linear programming relaxations. In Sections 4.4 and 4.5 we present computational results obtained by running the proposed formulations on a number of benchmark instances for the SSP and discuss the performances of each formulation. The theoretical findings discussed in this article may provide new insights about the combinatorial aspects of the problem and may suggest, at the same time, new directions for the development of future exact solution approaches for the problem.Before proceeding, in the next section we introduce some notation that will prove useful throughout the article.Consider a setJ={1,2,…,n}of n jobs to process in the flexible machine and letT={1,2,…,m}be the set of m tools necessary to process the jobs in J. Denote Tjas the set of tools necessary to process job j ∈ J; Jtas the set of jobs using tool t ∈ T;cJtas the complement of Jt; and C ≥ maxj{|Tj|} as the capacity of the magazine, i.e., the maximum number of tools that can be stored in the magazine of the machine at any time. A job processing sequence s, is a sequence of n naturals representing the processing order for the jobs. For example, by referring to the example in Table 1,s={1,2,3,4,5,6}represents a job processing sequence having job 1 as first job to process, job 2 as second job to process, and so on. Tang and Denardo proposed the following formulation for the SSP based on the assignment of jobs to the positions of a processing sequence (Tang and Denardo, 1987).DenoteK={1,2,…,n}as the set of n positions in the job sequence to be determined. Letujkbe a decision variable equal to 1 if job j is processed in position k and 0 otherwise. Similarly, letvtkbe a decision variable equal to 1 if tool t is present when processing a job in position k and 0 otherwise. Finally, letwtkbe a decision variable equal to 1 if tool t is present when processing job k and not when processing jobk−1,and 0 otherwise. Then, a valid formulation for the problem is the following:Formulation 1(Tang and Denardo, 1987),(1a)min∑t∈Tvt1+∑t∈T∑k∈K∖{1}wtk(1b)s.t.∑j∈Jujk=1∀k∈K(1c)∑k∈Kujk=1∀j∈J(1d)∑j∈Jtujk≤vtk∀k∈K,t∈T(1e)∑t∈Tvtk≤C∀k∈K(1f)vtk−vtk−1≤wtk∀k∈K∖{1},t∈T(1g)ujk∈{0,1}∀k∈K,j∈J(1h)vtk,wtk∈{0,1}∀k∈K,t∈T.The objective function (1a) minimizes the total number of tool switches. In particular, the addend∑t∈Tvt1takes into account the loading of the magazine when processing the first job in the sequence. Constraints (1b) and (1c) are assignment constraints. Constraints (1d) impose that no job requiring tool t can be processed in position k if such a tool is not present in the magazine at that position. Constraints (1e) guarantee that the magazine capacity is never exceeded. Note that these constraints can be stated as equalities since there is no need to remove unnecessary tools from the magazine (Laporte et al., 2004). Finally, constraints (1f) impose that a tool switch must be counted whenever a tool is present in position k but was not present in positionk−1.It is worth noting that the solutionujk=1/n,for all j ∈ J and k ∈ K,vtk=|Jt|/nfor all k ∈ K and t ∈ T, andwtk=0,for all k ∈ K and t ∈ T, is feasible and optimal for the linear programming relaxation of Formulation 1. To overcome such a drawback, Laporte et al. (2004) proposed an alternative integer linear programming formulation that exploits the analogies between the SP and the TSP. Specifically, the authors introduced a dummy job 0 to represent the start and stop operations and set by conventionT0=∅. Subsequently, they modeled the SSP as a particular version of the TSP in which the optimal hamiltonian circuit has to (i) start and end at vertex (job) 0, (ii) visit all the remaining vertices (jobs) exactly once and (iii) have as a weight on the edge (i, j) of the circuit the corresponding number of tool switches relative to the transition from job i to job j. In order to describe in detail the proposed formulation, denoteJ0=J∪{0},Ji=J∖{i},for all i ∈ J, andJ0i=J0∖{i},for all i ∈ J. Moreover, denote G as the complete graph having as vertexset J0.Let xijbe a decision variable equal to 1 if job j follows immediately job i in the sequence and 0 otherwise, for all i, j ∈ J0, i ≠ j. Moreover, letyjtbe a decision variable equal to 1 if tool t ∈ T is in the magazine when job j is processed and 0 otherwise, for all j ∈ J0, t ∈ T. Similarly, letzjtbe a decision variable equal to 1 if tool t ∈ T is inserted when processing job j and 0 otherwise, for all j ∈ J0, t ∈ T. Then, Laporte et al.’s formulation can be stated as follows:Formulation 2(Laporte et al., 2004),(2a)min∑j∈J∑t∈Tjzjt(2b)s.t.∑j∈J0ixij=1∀i∈J0(2c)∑i∈J0jxij=1∀j∈J0(2d)∑i,j∈S:i≠jxij≤|S|−1∀S⊂J0,2≤|S|≤n−1(2e)∑t∈Tyjt≤C∀j∈J(2f)xij+yjt−yit≤zjt+1∀i,j∈J,i≠j,t∈T(2g)x0j+yjt≤zjt+1∀j∈J,t∈T(2h)yjt=1∀j∈J,t∈Tj(2i)zjt=0∀j∈J,t∈T∖Tj(2j)yjt,zjt∈{0,1}∀j∈J,t∈T(2k)xij∈{0,1}∀i,j∈J0.The objective function (2a) minimizes the overall number of tool switches. Constraints (2b) and (2c) are assignment constraints. Constraints (2d) prevent the arising of subtours. Constraints (2e) are capacity constraints. Constraints (2f) prevent that job j follows job i in the optimal sequence if, at the same time, job j requires tool t and tool t is neither carried from job i nor inserted for job j. Constraints (2g) are a special case of constraints (2f) and account for the loading of the magazine relative to the transition from the dummy job 0 to the first job in the optimal job processing sequence. Finally, constraints (2h)–(2i) ensure that a tool switch is only performed when the tool is required to immediately execute a job.As shown in Laporte et al. (2004), the linear programming relaxation of Formulation 2 dominates the relaxation of Tang and Denardo’s model. However, computational experiments showed that the lower bounds provided by Formulation 2 are still generally poor (Laporte et al., 2004). This fact in turn prevents Formulation 2 from solving instances of the SSP containing more than 10 jobs within 1 hour of computing time (Laporte et al., 2004). In order to improve the lower bounds obtained by linear programming, in the next section we shall present a number of alternative ILP formulations for the SSP whose LP relaxations are provably tighter than the LP relaxations of Formulation 2.Consider a decision variableyijtequal to 1 if in the processing sequence a tool t ∈ T is carried in the transition from job i to job j, i, j ∈ J0, i ≠ j, and 0 otherwise. Similarly, letzijtbe a decision variable equal to 1 if in the processing sequence a tool t ∈ T has to be added in the transition from job i to job j, i, j ∈ J0, i ≠ j, and 0 otherwise. Then, a valid formulation for the SSP is the following:Formulation 3(3a)min∑i,j∈J0:i≠j∑t∈Tjzijt(3b)s.t.∑j∈J0ixij=1∀i∈J0(3c)∑i∈J0jxij=1∀j∈J0(3d)∑i,j∈S:i≠jxij≤|S|−1∀S⊂J0,2≤|S|≤n−1(3e)∑i∈J0j(yijt+zijt)=1∀j∈J0,t∈Tj(3f)yijt+zijt≤xij∀i,j∈J0:i≠j,t∈T:t∉Ti,t∈Tj(3g)∑t∈T(yijt+zijt)≤Cxij∀i,j∈J0:i≠j(3h)∑k∈J0i(ykit+zkit)≥∑j∈J0iyijt∀i∈J0,t∈T(3i)yijt≥xij∀i,j∈J0:i≠j,t∈Ti∩Tj(3j)zijt=0∀i,j∈J0:i≠j,t∈T∖Tj(3k)y0jt=0∀j∈J,t∈T(3l)xij∈{0,1}∀i,j∈J0:i≠(3m)yijt,zijt∈{0,1}∀i,j∈J0:i≠j,t∈T.Constraints (3b)–(3d) are equivalent to constraints (2b)–(2d) in Formulation 2. Constraints (3e) impose that in the transition from job i to job j a given tool t ∈ Tjis either carried from job i or it is added in the transition. Constraints (3f) impose that a tool t ∈ Tjcan be either carried from a previous job or added in the transition, only if such a transition is in the optimal job processing sequence. Constraints (3g) are similar to the capacity constraints (2e) in Formulation 2. Constraints (3h) impose that if a tool t ∈ T is carried in the transition from job i to any job j then it must be either carried or added in the transition from another job k to job i, k ≠ i. Constraints (3i) impose to carry all of the tools in Ti∩Tjwhen considering the transition from job i to job j. Constraints (3j) are analogous to constraints (2i) in Formulation 2. Finally, constraints (3k) account for the loading of the magazine relative to the transition from the dummy job 0 to the first job in the optimal job processing sequence.Variablesyjtandzjtin Formulation 2 and variablesyijtandzijtin Formulation 3 are related by the following equations:(4)yjt=∑i∈J0j(yijt+zijt)∀j∈J,t∈T(5)zjt=∑i∈J0jzijt∀j∈J,t∈T.These relationships can be used to show that Formulation 3 is tighter than Formulation 2. To this end, we add (4), (5) and (2j) to Formulation 3. Note that this addition does not alter the LP relaxation of Formulation 3 since the new constraints only define the old variablesyjtandzjt. After adding these constrains, (3e) and (2h) become equivalent. Similarly, the surrogates of constraints (3g) and (3j) with respect to index i become equivalent to constraints (2e) and (2i), respectively. Now, if we combine Eqs. (4) and (5) together with (3c), (3f) and (3h) then we obtain an inequality that dominates constraints (2f) in Formulation 2. Specifically, defineJ0ij=J0∖{i,j}and add up constraints (3f) for all jobs inJ0ijby using constraints (3c). Then, it holds that(6)∑k∈J0ij(ykjt+zkjt)≤∑k∈J0ijxkj=1−xij.By addingyijt+zijtto both sides of (6) we get(7)∑k∈J0j(ykjt+zkjt)≤yijt+zijt+xij.It is worth noting that constraint (3h) can be rewritten as(8)∑k∈J0i(ykit+zkit)∑k∈J0ijyikt≥yijt.Then, it holds that(9)∑k∈J0j(ykjt+zkjt)≤yijt+zijt+1xij≤∑k∈J0i(ykit+zkit)∑k∈J0ijyikt+zijt+xij.Now, note that: (i) the first term in the right-hand-side of (9) is equal toyit; (ii) the second term is less than or equal to 0;and (iii) the third term is less than or equal tozjt. Hence, we have(10)yjt=∑k∈J0j(ykjt+zkjt)≤yijt+zijt+xij≤∑k∈J0i(ykit+zkit)×∑k∈J0ijyikt+zijt+1xij≤yit+zjt+xij,which implies thatProposition 1The objective function value of the linear programming relaxation of Formulation 3 is greater than or equal to the linear programming relaxation of Formulation 2.By just exploiting the definitions of variablesyijtandzijt,it is possible to replace constraints (3f) by the following three new sets of constraints:(11a)yijt+zijt=xij∀i,j∈J0:i≠j,t∈T:t∉Ti,t∈Tj(11b)yijt=xij∀i,j∈J0:i≠j,t∈T:t∈Ti∩Tj(11c)yijt≤xij∀i,j∈J0:i≠j,t∈T:t∉Tj.Constraints (11a) force a tool t ∈ T such that t∉Tiand t ∈ Tjto be either carried from job i or added in job j if the transition from job i to job j is actually considered in the optimal job processing sequence. Constraints (11b) force a tool t ∈ T such that t ∈ Ti∩Tjto be carried from job i if the transition from job i to job j is considered in the optimal job processing sequence. Finally, constraints (11c) allow a tool t ∈ T such that t∉Tjto be carried from job i if the transition from job i to job j is considered in the optimal job processing sequence. Interestingly, these new sets of constraints, in particular the equality constraints, can be used to reduce the size of Formulation 3. Specifically, we can use constraints (11a) to eliminate all of variableszijtand constraints (11b) to eliminate variablesyijtwhen t ∈ Ti∩Tj. In this way, we have to consider only variablesyijtdefined for all i, j ∈ J0 such that i ≠ j and for all t ∈ T such that either t∉Tior t ∈ Ti~and~t∉Tj. In the light of this observation, constraints (3e) become redundant. In fact, for all j ∈ J0 and t ∈ Tj, it holds that1=∑i∈J0j(yijt+zijt)=∑i∈J0jyijt+∑i∈J0j:t∉Tizijt=∑i∈J0jyijt+∑i∈J0j:t∉Ti(xij−yijt),which is equivalent to∑i∈J0jyijt+∑i∈J0j:t∉Tixij=1+∑i∈J0j:t∉Tiyijt,which can be rewritten as∑i∈J0j:t∈Tiyijt+∑i∈J0j:t∉Tixij=1,which, in turn, due to (11b), becomes∑i∈J0j:t∈Tixij+∑i∈J0j:t∉Tixij=1.Similarly, for all i, j ∈ J0, i ≠ j, constraints (3g) can be rewritten as∑t∈Tyijt+∑t∈T:t∉Ti,t∈Tjzijt≤Cxij,which is equivalent to∑t∈Tyijt+∑t∈T:t∉Ti,t∈Tj(xij−yijt)≤Cxij,which can be rewritten as(12)∑t∈T:t∈Ti,t∉Tjyijt+∑t∈T:t∉Ti,t∈Tjxij≤Cxij.The first term of (12) can in turn be expanded as∑t∈T:t∈Ti,t∉Tjyijt+∑t∈T:t∉Ti,t∉Tjyijt+∑t∈T:t∈Ti,t∈Tjyijt+∑t∈T:t∉Ti,t∈Tjxij≤Cxij.By using (11b) we get∑t∈T:t∈Ti,t∉Tjyijt+∑t∈T:t∉Ti,t∉Tjyijt+∑t∈T:t∈Ti,t∈Tjxijt+∑t∈T:t∉Ti,t∈Tjxij≤Cxij,which is equivalent to∑t∈T:t∈Ti,t∉Tjyijt+∑t∈T:t∉Ti,t∉Tjyijt+∑t∈T:t∈Tjxijt≤Cxij,which leads to the constraint∑t∈T:t∈Ti,t∉Tjyijt+∑t∈T:t∉Ti,t∉Tjyijt≤(C−|Tj|)xij.Finally, consider constraints (3h) and first assume that t ∈ Ti. Then, it holds that∑k∈J0iykit+∑k∈J0i:t∉Tkzkit≥∑j∈J0iyijt.By using (11a) we get∑k∈J0iykit+∑k∈J0i:t∉Tk(xij−ykit)≥∑j∈J0iyijt,which, in turn, can be rewritten as∑k∈J0i:t∈Tkykit+∑k∈J0i:t∉Tkxij≥∑j∈J0iyijt.By using (11b) and (3b) we obtain1=∑k∈J0i:t∈Tkxki+∑k∈J0i:t∉Tkxij≥∑j∈J0iyijt,which, in turn, implies that the constraint is redundant. In contrast, if we assume that t∉Ti, then variableszijtare not defined and the constraint reduces to∑k∈J0iykit≥∑j∈J0iyijt.Thus, Formulation 3 reduces toFormulation 4(13a)min∑j∈J|Tj|x0j+∑i,j∈J:i≠j∑t∈T:t∉Tit∈Tj(xij−yijt)(13b)s.t.∑j∈J0ixij=1∀i∈J0(13c)∑i∈J0jxij=1∀j∈J0(13d)∑i,j∈S:i≠jxij≤|S|−1∀S⊂J0,2≤|S|≤n−1(13e)∑k∈J0iykit−∑j∈J0iyijt≥0∀i∈J0,t∈T∖Ti(13f)∑t∈T:t∈Tit∉Tjyijt+∑t∈T:t∉Tit∉Tjyijt≤(C−|Tj|)xij∀i,j∈J0:i≠j(13g)yijt≤xij∀i,j∈J0:i≠j,t∈T:t∉Tj(13h)xij∈{0,1}∀i,j∈J0:i≠j(13i)yijt∈{0,1}∀i,j∈J0:i≠j,t∈T:t∉Tior(t∈Tiandt∉Tj).In the light of these results, the following proposition holds:Proposition 2The linear programming relaxations of Formulations 3 and 4 have the same optimal solution value.The following proposition holds for Formulation 4:Proposition 3Assume that variables xijare fixed and determine a hamiltonian circuit in G. Then, constraints (13e)–(13g) determine a matrix that is totally unimodular.Consider the capacity constraints (13f) and introduce the slack variable qij, for all i, j ∈ J0, i ≠ j. Then we have(14)∑t∈T:t∈Tit∉Tjyijt+∑t∈T:t∉Tit∉Tjyijt+qij=(C−|Tj|)xij∀i,j∈J0:i≠j.Without loss of generality, assume both thatxi,i+1=1,for alli=0,…,n−1,andxn0=1. Then, it holds thatyijt=0,for all j ∈ J0 such thatj≠i+1. Hence, the system reduces to(15)yj−1,jt−yj,j+1t≥0∀j∈J0t∈T∖Tj(16)∑t∈T:t∈Tj−1t∉Tjyj−1,jt+∑t∈T:t∉Tj−1t∉Tjyj−1,jt+qj−1,j=(C−|Tj|)∀j∈J0(17)yj,j+1t≤1∀j∈J0,t∈T:t∉Tj.Consider constraints (16) for a fixed j ∈ J0 and subtract the same constraint forj+1. Then it holds that(18)∑t∈T:t∈Tj−1t∉Tjyj−1,jt+∑t∈T:t∉Tj−1t∉Tjyj−1,jt+qj−1,j−∑t∈T:t∈Tjt∉Tj+1yj,j+1t−∑t∈T:t∉Tjt∉Tj+1yj,j+1t−qj,j+1=|Tj|−|Tj+1|.Now observe that the system constituted by (15), (17) and (18) is totally unimodular because each variable appears exactly twice with coefficients both+1 and−1.□The decomposition of the SSP in two nested subproblems (namely, the Sequencing Problem (SP) and the Tooling Problem (TP)) described in Tang and Denardo (1987) proves useful to provide a combinatorial interpretation of Formulation 4. Before proceeding, we briefly review Crama et al.’s results and insights (Crama et al., 1994) and introduce some notations that will prove useful in the remainder of the article.A tooling policy for a given job processing sequence s is any determination of the tools that have to be loaded in the tool magazine at each position of s. A tooling policy is feasible if, at each position of s, the capacity constraint is respected, i.e., if the sum of the tools present in the magazine at any position of s is smaller than or equal to C. A feasible tooling policy is optimal if it minimizes the overall tool switches in s.Let a job processing sequence s be fixed and consider a n × m boolean matrix P whose generic entry pijis equal to 1 if tool i is required for the jth job in s and 0 otherwise. For example, Table 4shows the P matrix corresponding to the example in Table 1.A 0-block of P is a maximal subset of consecutive zeros in a row of P or, more formally, a set of the form{(i,j),(i,j+1),…,(i,j+k)}for which the following conditions hold:1.1<j≤j+k<n;pij=pi,j+1=…=pi,j+k=0;pi,j−1=pi,j+k+1=1.Thus, a 0-block denotes the maximal interval before and after which a tool t ∈ T is needed, but during which it is not needed. This fact suggests, as a possible approach to solve the SSP, to find a job processing sequence inducing the minimum number of 0-blocks during which each tool t ∈ T is not kept. This is precisely what Formulation 4 does. In fact, it is worth noting that, for each t, Formulation 4 determines a sequence of jobsi1,i2,…,ip,that are defined by the variablesyijtbeing equal to one, more preciselyyi1i2t,yi2i3t,…,yip−1ipt. Such a sequence can be seen as a path starting at job i1 and ending at job ip. This path is maximal if it cannot be augmented, i.e., if the variables y associated with all of the arcs incoming into job (vertex) i1 and all of the arcs leaving job (vertex) ipare equal to zero. It is easy to see that these maximal paths correspond to Crama et al.’s 0-blocks.In this section we provide valid inequalities to strengthen Formulation 4.Proposition 4The inequality(19)∑i∈J∖{j,k}yijt≥yjkt∀k,j∈J:k≠j,t∈Tk∖Tjis valid for Formulation 4.In a feasible solution to the problem, variableyjktcan assume values in {0, 1}. Ifyjkt=0the inequality is trivially valid. Ifyjkt=1then the pair (j, k) belongs to a 0-block during which tool t is kept (see Fig. 1), hence there exists at least onei^∈J∖{j,k}such thatyi^jt=1. Thus, the inequality is again valid.□We refer to inequalities (19) as the 1-arc inequalities. It is worth noting that, with arguments similar to those used in Proposition 4, the 1-arc inequalities can be generalized as in Fig. 2. Specifically, let S1, S2⊂J and denoteyt(S1,S2)=∑i∈S1∑j∈S2yijt. Then the following proposition holds:Proposition 5The inequality(20)yt(J∖S,S∖{k})≥∑i∈S∖{k}yikt∀S⊂.J,k∈S,t∈Tk:Jt∩S={k}is valid for Formulation 4.We refer to inequalities (20) as the cut inequalities.The structural properties of the tooling subproblem, and in particular the concept of a 0-block, suggest an alternative network-based integer linear programming formulation for the SSP that can be viewed as a disaggregation of Formulation 4. Specifically, by definition a 0-block with respect to a tool t is a sequence of jobs starting at a job i ending at a job j and such that no job in between i and j (but i and j themselves) needs tool t. Such a sequence can be seen as a path in the induced directed subgraphGijt=(Vijt,Aijt)of G having as vertexsetVijt=cJt∪{i,j},for all distinct i, j ∈ J such that t ∈ Ti∩Tj, and as arcsetAijtthe subset of arcs having endpoints inVijtexcept: (i) arc (i, j), (ii) arcs incoming into i, and (iii) arcs diverging from j. By denotingfij,kltas a decision variable equal to 1 if vertex l immediately follows vertex k in a path ofGijtand 0 otherwise, it is easy to see that the following relationships hold between variablesyijtin Formulation 4 and variablesfij,klt:(21a)yklt=∑i∈Jtfil,klt∀t∈T,∀k∈cJt,l∈Jt(21b)yklt=∑j∈Jtfkj,klt∀t∈T,∀k∈Jt,l∈cJt(21c)yklt=∑i,j∈Jt:i≠jfij,klt∀t∈T,∀k,l∈cJt:k≠l.These relationships suggest the following formulation for the SSP.Formulation 5(22a)min∑j∈J|Tj|x0j+∑i,j∈J:i≠jt∈Tj∖Ti(xij−∑k∈J:k≠jt∈Tkfkj,ijt)(22b)s.t.∑j∈J0ixij=1∀i∈J0(22c)∑i∈J0jxij=1∀j∈J0(22d)∑i,j∈S:i≠jxij≤|S|−1∀S⊂J0,2≤|S|≤n−1(22e)∑l∈Vijt:l≠kfij,klt−∑l∈Vijt:l≠kfij,lkt≥0∀i,j∈J:i≠j,∀t∈Ti∩Tj,∀k∈cJt(22f)∑i∈Jtfil,klt≤xkl∀t∈T,∀k∈cJt,l∈Jt(22g)∑j∈Jtfkj,klt≤xkl∀t∈T,∀k∈Jt,l∈cJt(22h)∑i,j∈Jt:i≠jfij,klt≤xkl∀t∈T,∀k,l∈cJt:k≠l(22i)∑t∈T:t∈Tkt∉Tl∑j∈Jt:j≠kfkj,klt+∑t∈T:t∉Tkt∉Tl∑i,j∈Jt:i≠jfij,klt≤(C−|Tl|)xkl∀k,l∈J:k≠l(22j)xij∈{0,1}∀i,j∈J0:i≠j(22k)fij,klt≥0∀t∈T,∀i,j∈J:i≠j,∀k,l∈Vijt:k≠l,{k,l}≠{i,j}.Using Eqs. (21a)–(21c) it is easy to see that the objective function (22a) is analogous to (13a) in Formulation 4; constraints (22b)–(22d) correspond to constraints (13b)–(13d) of Formulation 4; constraints (22e) allow the existence of a path (0-block) inVijtif such a path has been chosen in the optimal solution to the problem; constraints (22f)–(22h) correspond to constraints (13g) of Formulation 4; and the capacity constraints (22i) correspond to constraints (13f) of Formulation 4. It is easy to see that, if for a fixed triple t, k and l, we add constraint (22e) for all i and j then we obtain constraint (13e) of Formulation 4. Thus, based on the previous observations, the following proposition holds:Proposition 6The objective function value of the linear programming relaxation of Formulation 5 is greater than or equal to the objective function value of the linear programming relaxation of Formulation 4.We will see in Section 4 that Formulation 5 usually provides tighter lower bounds than Formulation 4.In this section we analyze the performances of the formulations described in the previous sections. As the performances of Formulation 1 and Formulation 2 have been already discussed in Laporte et al. (2004), here we focus on the comparison between Formulations 2, 4 and 5. We excluded from the analysis Formulation 3 as it provides the same lower bounds as Formulation 4 and contains more variables and constraints.Our experiments were motivated by a number of goals, namely: to compare the lower bounds of the formulations; to evaluate, with respect to Formulation 4, the benefits obtained by including the valid inequalities previously described; and to allow the analysis of datasets larger than the ones currently handled by Formulation 2. We do not attempt to compare the runtime performances of approaches that are non-linear or that are not based on integer linear programming, as those analyses have been already performed in Laporte et al. (2004) and Ghiani et al. (2010).In order to test the performances of Formulations 2, 4 and 5, we considered the datasets described in Laporte et al. (2004), downloadable at http://homepages.ulb.ac.be/~dacatanz/Site/Software_files/JSTSPinstances.zip. Each dataset contains 10 random instances of the SSP, characterized by having the same number of jobs, tools, and magazine capacity. Moreover, each dataset is also characterized by two positive numbers,Tm*andTM*,such thatTm*=minj′∈J|Tj′|andTM*=maxj′∈J|Tj′|. As described in Laporte et al., a generic instance in a given dataset is created by generating at random, for each job j ∈ J, the set Tjin such a way that Tjis non-dominated andTm*≤|Tj|≤TM*. Datasets belonging to the same group (e.g., datAx, datBx, and so on) differ from one another by the capacity of the magazine. The characteristics of the considered datasets are summarized in Table 5.

@&#CONCLUSIONS@&#
