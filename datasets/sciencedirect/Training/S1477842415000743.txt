@&#MAIN-TITLE@&#
Inference of ranking functions for proving temporal properties by abstract interpretation

@&#HIGHLIGHTS@&#
We present new static analysis methods for proving liveness properties of programs.We generalize an existing abstract interpretation framework for termination.We reuse existing abstract domains based on piecewise-defined ranking functions.The static analyses methods infer sufficient preconditions for the liveness properties.We provide a prototype implementation of these static analyses.

@&#KEYPHRASES@&#
Static analysis,Abstract interpretation,Liveness,Temporal properties,Ranking functions,Termination,

@&#ABSTRACT@&#
We present new static analysis methods for proving liveness properties of programs. In particular, with reference to the hierarchy of temporal properties proposed by Manna and Pnueli, we focus on guarantee (i.e., “something good occurs at least once”) and recurrence (i.e., “something good occurs infinitely often”) temporal properties.We generalize the abstract interpretation framework for termination presented by Cousot and Cousot. Specifically, static analyses of guarantee and recurrence temporal properties are systematically derived by abstraction of the program operational trace semantics.These methods automatically infer sufficient preconditions for the temporal properties by reusing existing numerical abstract domains based on piecewise-defined ranking functions. We augment these abstract domains with new abstract operators, including a dual widening.To illustrate the potential of the proposed methods, we have implemented a research prototype static analyzer, for programs written in a C-like syntax, that yielded interesting preliminary results.

@&#INTRODUCTION@&#
Software verification addresses the problem of checking that programs satisfy certain properties. Lamport, in the late 1970s, suggested a classification of program properties into the classes of safety and liveness properties [1]. The class of safety properties is informally characterized as the class of properties stating that “something bad never happens”, that is, a program never reaches an unacceptable state. The class of liveness properties is informally characterized as the class of properties stating that “something good eventually happens”, that is, a program eventually reaches a desirable state.Manna and Pnueli, in the late 1980s, suggested a more fine grained classification of program properties into a hierarchy [2], which distinguishes four basic classes making different claims about the frequency or occurrence of “something good” mentioned in the informal characterizations proposed by Lamport:•safety properties: “something good always happens”, i.e., the program never reaches an unacceptable state (e.g., partial correctness, mutual exclusion);guarantee properties: “something good happens at least once”, i.e., the program eventually reaches a desirable state (e.g., total correctness, termination);recurrence properties: “something good happens infinitely often”, i.e., the program reaches a desirable state infinitely often (e.g., starvation freedom);persistence properties: “something good eventually always happens”, i.e., the program eventually reaches and stays in a desirable state (e.g., stabilization).This paper concerns the verification of programs by static analysis. We set our work in the framework of Abstract Interpretation [3], a general theory of semantic approximation that provides a basis for various successful industrial-scale tools (e.g., Astrée [4]). Abstract Interpretation has to a large extent been concerned with safety properties and has only recently been extended to program termination [5], which is just a particular guarantee property.In this paper, we generalize the framework proposed by Cousot and Cousot for termination [5] and we propose an abstract interpretation framework for proving guarantee and recurrence temporal properties of programs. Moreover, we present new static analysis methods for inferring sufficient preconditions for these temporal properties. Let us consider the program SIMPLE in Fig. 1, where the program variables are interpreted in the set of mathematical integers. The first loop is an infinite loop for the values of the variable x greater than or equal to zero: at each iteration the value of x is increased by one. The second loop is an infinite loop for any value of the variable x: at each iteration, the value of x is increased by one or negated when it becomes greater than ten. Given the guarantee property “x=3 at least once”, where x=3 is the desirable state, our approach is able to automatically infer that the property is true if the initial value of x is smaller than or equal to three. Given the recurrence property “x=3 infinitely often”, our approach is able to automatically infer that the property is true if the initial value of x is strictly negative (i.e., if the first loop is not entered).Our approach follows the traditional method for proving liveness properties by means of a well-founded argument (i.e., a function from the states of a program to a well-ordered set whose value decreases during program execution). More precisely, we build a well-founded argument for guarantee and recurrence properties in an incremental way: we start from the desirable program states, where the function has value zero (and is undefined elsewhere); then, we add states to the domain of the function, retracing the program backwards and counting the maximum number of performed program steps as value of the function. Additionally, for recurrence properties, this process is iteratively repeated in order to construct an argument that is also invariant with respect to program execution steps so that even after reaching a desirable state we know that the execution will reach a desirable state again. We formalize these intuitions into sound and complete guarantee and recurrence semantics that are systematically derived by abstract interpretation of the program operational trace semantics.In order to achieve effective static analyses, we further abstract these semantics. Specifically, we leverage existing numerical abstract domains based on piecewise-defined ranking functions [6–8] by introducing new abstract operators, including a dual widening. The piecewise-defined ranking functions are attached to the program control points and represent an upper bound on the number of program execution steps before the program reaches a desirable state. They are automatically inferred through backward analysis and yield sufficient preconditions for the guarantee and recurrence temporal properties. We prove the soundness of the analysis, meaning that all program executions respecting these preconditions indeed satisfy the temporal properties, while a program execution that does not respect these preconditions might or might not satisfy the temporal properties.To illustrate the potential of our approach, let us consider again the program SIMPLE in Fig. 1. Given the guarantee property “x=3 at least once”, the piecewise-defined ranking function inferred at program control point 1 isλx.{−3x+10x<0−2x+60≤x∧x≤3undefinedotherwisewhich bounds the wait (from the program control point1) for the desirable state x=3 by−3x+10program execution steps whenx<0, and by−2x+6execution steps when0≤x∧x≤3. The analysis is inconclusive when3<x. In this case, when3<x, the guarantee property is never satisfied. Thus, the preconditionx≤3induced by the domain of the ranking function is the weakest precondition for “x=3 at least once”. Given the recurrence property “x=3 infinitely often”, the piecewise-defined ranking function at program point 1 bounds the wait for the next occurrence of the desirable state x=3 by−3x+10program execution steps:λx.{−3x+10x<0undefinedotherwisewhich induces the preconditionx<0. Indeed, when0≤x∧x≤3, the desirable state x=3 does not occur infinitely often but only once. Againx<0is the weakest precondition for “x=3 at least once”. At program point 3 (i.e., at the beginning of the second while loop), for both “x=3 infinitely at least” and “x=3 infinitely often”, we get the following piecewise-defined ranking function:λx.{−3x+9x≤3−3x+723<x≤103x+1210<xwhich bounds the wait (from the program point3) for the next occurrence of x=3 by−3x+9execution steps whenx≤3, by−3x+72execution steps when3<x≤10, and by3x+12execution steps when10<x.Our contribution: In summary, this paper makes the following contributions. First, we present an abstract interpretation framework for proving guarantee and recurrence program temporal properties. In particular, we generalize the framework proposed by Cousot and Cousot for termination [5]. Moreover, by means of piecewise-defined ranking function abstract domains [6–8], we design new static analysis methods to effectively infer sufficient preconditions for these temporal properties, and provide upper bounds in terms of program execution steps on the waiting time before a program reaches a desirable state. Finally, we provide a research prototype static analyzer for programs written in a C-like syntax.Limitations: In general, liveness properties are used to specify the behavior of concurrent programs and are satisfied only under fairness hypotheses. In this paper, we model concurrent programs as non-deterministic sequential programs and we assume that the fair scheduler is explicitly represented within the program (e.g., see [9] and Example 16 in Section 9). We plan, as part of our future work, to extend our framework in order to explicitly express and handle fairness properties.Outline of the paper: Section 2 introduces the preliminary notions used in the paper. In Section 3, we give a brief overview of Cousot and Cousot׳s abstract interpretation framework for termination. In Sections 4 and 5, we propose a small idealized programming language used to illustrate our work, and a small specification language used to describe guarantee and recurrence properties. The next two sections are devoted to the main contribution of the paper: we formalize our framework for guarantee and recurrence properties in Section 6 and in Section 7, respectively. In Section 8, we present decidable guarantee and recurrence abstractions based on piecewise-defined ranking functions. We describe our prototype static analyzer in Section 9. Finally, Section 10 discusses related work and Section 11 concludes.In order to be independent from the choice of a particular programming language, following [11,3], we formalize programs as transition systems:Definition 1Transition systemA transition system is a pair〈Σ,τ〉where Σ is a (potentially infinite) set of states and the transition relationτ⊆Σ×Σdescribes the possible transitions between states.Note that this model allows representing programs with (possibly unbounded) non-determinism. In some cases, a setI⊆Σis designated as the set of initial states. The set of blocking or final states isΩ=def{s∈Σ|∀s′∈Σ:〈s,s′〉∉τ}.We define the following functions to manipulate sets of program states.Definition 2Given a transition system〈Σ,τ〉,pre:P(Σ)→P(Σ)maps a set of program statesX∈P(Σ)to the set of their predecessors with respect to the program transition relation τ:(1)pre(X)=def{s∈Σ|∃s′∈X:〈s,s′〉∈τ}Given a transition system〈Σ,τ〉,pre˜:P(Σ)→P(Σ)maps a set of statesX∈P(Σ)to the set of states whose successors with respect to the program transition relation τ are all in the set X:(2)pre˜(X)=def{s∈Σ|∀s′∈Σ:〈s,s′〉∈τ⇒s′∈X}The semantics of a program is a mathematical characterization of all possible behaviors of the program when executed for all possible input data. The semantics generated by a transition system is the set of computations described by the transition system. We formally define this notion below.Given a setS, the setSn=def{s0⋯sn−1|∀i<n:si∈S}is the set of all sequences of exactly n elements fromS. We writeεto denote the empty sequence, i.e.,S0≜{ε}. In the following, letS⁎=def⋃n∈NSnbe the set of all finite sequences,S+=defS⁎⧹S0be the set of all non-empty finite sequences,Sωbe the set of all infinite sequences,S+∞=defS+∪Sωbe the set of all non-empty finite or infinite sequences andS⁎∞=defS⁎∪Sωbe the set of all finite or infinite sequences of elements fromS. In the following, in order to ease the notation, sequences of a single elements∈Sare often written omitting the curly brackets, e.g., we writesωands+∞instead of{s}ωand{s}+∞. We writeσσ′for the concatenation of two sequencesσ,σ′∈S+∞(withσε=εσ=σ, andσσ′=σwhenσ∈Sω),T+=defT∩S+for the selection of the non-empty finite sequences ofT⊆S+∞,Tω=defT∩Sωfor the selection of the infinite sequences ofT⊆S+∞andT;T′=def{σsσ′|s∈S∧σs∈T∧sσ′∈T′}for the merging of sets of sequencesT⊆S+andT′⊆S+∞, when a finite sequence inTterminates with the initial state of a sequence inT′.Given a transition system〈Σ,τ〉, a trace is a non-empty sequence of states in Σ determined by the transition relation τ, that is,〈s,s′〉∈τfor each pair of consecutive states s,s′∈Σin the sequence. Note that the set of final states Ω and the transition relation τ can be understood as a set of traces of length one and a set of traces of length two, respectively. The set of all traces generated by a transition system is called partial trace semantics:Definition 4Partial trace semanticsThe partial trace semanticsτ̇+∞∈P(Σ+∞)generated by a transition system〈Σ,τ〉is defined as follows:τ̇+∞=defτ̇+∪τωwhereτ̇+∈P(Σ+)is the set of finite traces:τ̇+=def⋃n>0{s0⋯sn−1∈Σn|∀i<n−1:〈si,si+1〉∈τ}andτω∈P(Σω)is the set of infinite traces:τω=def{s0s1⋯∈Σω|∀i∈N:〈si,si+1〉∈τ}LetΣ={a,b}andτ={〈a,a〉,〈a,b〉}. The partial trace semantics generated by〈Σ,τ〉is the set of tracesa+∞∪a⁎b.In practice, given a transition system〈Σ,τ〉, and possibly a set of initial statesI⊆Σ, the traces worth of consideration (start by an initial state inIand) are either infinite or terminate with a final state in Ω. These traces define the maximal trace semanticsτ+∞∈P(Σ+∞)and represent infinite computations or completed finite computations:Definition 5Maximal trace semanticsThe maximal trace semanticsτ+∞∈P(Σ+∞)generated by a transition system〈Σ,τ〉is defined asτ+∞=defτ+∪τωwhereτ+∈P(Σ+)is the set of finite traces terminating with a final state in Ω:τ+=def⋃n>0{s0⋯sn−1∈Σn|∀i<n−1:〈si,si+1〉∈τ,sn−1∈Ω}The maximal trace semantics generated by the transition system〈Σ,τ〉of Example 1 is the set of tracesaω∪a⁎b. Note that, unlike the partial trace semantics of Example 1, the maximal trace semantics does not include partial computations, i.e., finite sequences ofa∈Σ.In practice, in case a set of initial statesI⊆Σis given, only the traces starting from an initial states∈Iare considered:{sσ∈τ+∞|s∈I}.In the following, we consider the fixpoint definition of the maximal trace semantics proposed by Cousot [11]:(3)τ+∞=lfp⊑ϕ+∞ϕ+∞(T)=defΩ∪(τ;T)where〈P(Σ+∞),⊑,⊔,⊓,Σω,Σ+〉is a complete lattice for the computational order isT1⊑T2⇔T1+⊆T2+∧T1ω⊇T2ω. In Fig. 2, we illustrate the fixpoint iterates. Intuitively, the traces belonging to the maximal trace semantics are built backwards by prepending transitions to them: the finite traces are built extending other finite traces from the set of final states Ω, and the infinite traces are obtained by selecting infinite sequences with increasingly longer prefixes forming traces. In particular, the i-th iterate builds all finite traces of length less than or equal to i, and selects all infinite sequences whose prefixes of length i form traces. At the limit we obtain all infinite traces and all finite traces that terminate in Ω.The maximal trace semantics carries all information about a program. It is the most precise semantics and it fully describes the behavior of a program. However, to reason about a particular program property, it is not necessary to consider all aspects and details of the program behavior. In fact, reasoning is facilitated by the design of a semantics that abstracts away from irrelevant details about program executions. In particular, rather than deriving program semantics by intuition and justifying them a posteriori, Abstract Interpretation [3] offers an elegant and constructive way to systematically derive different program semantics by successive abstractions of the same maximal trace semantics.We illustrate such idea in the following. We first systematically derive a well-adapted semantics for program termination. Then, we derive new program semantics dedicated to guarantee and recurrence properties.The traditional method for proving program termination dates back to Turing [12] and Floyd [13]. It consists in inferring ranking functions, namely functions from program states to elements of a well-ordered set whose value decreases during program execution.Definition 6Ranking functionGiven a transition system〈Σ,τ〉, a ranking function is a partial functionf:Σ⇀Wfrom the set of states Σ into a well-ordered set〈W,≤〉whose value decreases through transitions between states, that is∀s,s′∈dom(f):〈s,s′〉∈τ⇒f(s′)<f(s).The best known well-ordered sets are the natural numbers〈N,≤〉and the ordinals〈O,≤〉, and the most obvious ranking function maps each program state to the number of program execution steps until termination, or some well-chosen upper bound on this numbers.In [5], Cousot and Cousot prove the existence of a most precise ranking functionτt∈Σ⇀Othat can be derived by abstract interpretation of the program maximal trace semantics and can be expressed as a least fixpoint as(4)τt=lfp∅̇⊑ϕtϕt(f)=defλs.{0s∈Ωsup{f(s′)+1|〈s,s′〉∈τ}s∈pre˜(dom(f))undefinedotherwisewhere〈Σ⇀O,⊑〉forms a partially ordered set for the computational orderf1⊑f2⇔dom(f1)⊆dom(f2)∧∀x∈dom(f1):f1(x)≤f2(x)andlfp∅̇denotes the least fixpoint greater than or equal to the totally undefined (ranking) function∅̇. The most precise ranking functionτtis defined starting from the final states in Ω, where the function has value zero, and retracing the program backwards while mapping each program state in Σ definitely leading to a final state (i.e., a program state such that all program traces to which it belong are terminating) to an ordinal inOrepresenting an upper bound on the number of program execution steps remaining to termination.Example 3Let us consider the following trace semantics:The fixpoint iterates of the most precise ranking functionτtarewhere unlabeled states are outside the domain of the function.The domain ofτtis the set of states from which all program executions terminate; all traces branching from a states∈dom(τt)terminate in at mostτt(s)execution steps, while at least one trace branching from a states∉dom(τt)does not terminate:Theorem 1A program terminates for all traces starting from a given set of initial statesIif and only ifI⊆dom(τt).See [5].□Intuitively, a ranking function f1 is more precise than another ranking function f2 when it is defined over a larger set of program states, that is, it can prove termination for more program states, and when its value is always smaller, that is, the maximum number of program execution steps required for termination is smaller. Thus, we define the approximation order between ranking functions asf1≼f2⇔dom(f1)⊇dom(f2)∧∀x∈dom(f2):f1(x)≤f2(x). Observe that the computational order used to define fixpoints and the approximation order often coincide but, in the general case, they are distinct and totally unrelated [14]. We will need to maintain this distinction throughout the rest of this paper.In [5], Cousot and Cousot deriveτt∈Σ⇀O(cf. Eq. (4)) by means of successive abstractions of the maximal trace semanticsτ+∞∈P(Σ+∞)(cf. Eq. (3)). In the following, we briefly retrace their steps.We define the neighborhood of a sequenceσ∈Σ+∞in a set of sequencesT⊆Σ+∞as the set of sequencesσ′∈Twith a common prefix withσ:(5)nbhd(σ,T)=def{σ′∈T|pf(σ)∩pf(σ′)≠∅}wherepf∈Σ+∞→P(Σ+∞)yields the set of prefixes of a sequenceσ∈Σ+∞:(6)pf(σ)=def{σ′∈Σ+∞|∃σ″∈Σ⁎∞:σ=σ′σ″}.A program trace is terminating if and only if it is finite and its neighborhood in the program semantics consists only of finite traces, i.e., the trace terminates independently from the non-deterministic choices made during execution. The corresponding termination abstractionαt:P(Σ+∞)→P(Σ+)is defined as follows:(7)αt(T)=def{σ∈T+|nhbd(σ,Tω)=∅}.Example 4LetT={ab,aba,ba,bb,baω}be a set of sequences. Then, its termination abstraction isαt(T)={ab,aba}sincenbhd(ab,Tω)=∅andnbhd(aba,Tω)=∅. In fact,nbhd(ab,Tω)=nbhd(ab,{baω})=∅(i.e.,pf(ab)∩pf(baω)=∅, cf. Eq. (5)) andnbhd(aba,Tω)=nbhd(aba,{baω})=∅(i.e.,pf(aba)∩pf(baω)=∅), whilenbhd(ba,Tω)=nbhd(ab,{baω})={ba}≠∅(i.e.,pf(ba)∩pf(baω)={ba}≠∅) andnbhd(bb,Tω)=nbhd(bb,{baω})={b}≠∅(i.e.,pf(bb)∩pf(baω)={b}≠∅).The termination semanticsτt∈Σ⇀Ocan now be explicitly defined as abstract interpretation of the maximal trace semanticsτ+∞∈P(Σ+∞):(8)τt=defαrk(αt(τ+∞))where the ranking abstractionαrk:P(Σ+)→(Σ⇀O)is(9)αrk(T)=defαv(α→(T))where the functionα→:P(Σ+∞)→P(Σ×Σ)extracts from a set of sequencesT⊆Σ+∞the smallest transition relationr⊆Σ×Σthat generates T:α→(T)=def{〈s,s′〉|∃σ∈Σ⁎,σ′∈Σ⁎∞:σss′σ′∈T}and where the functionαv:P(Σ×Σ)→(Σ⇀O)provides the rank of the elements in the domain of a relationr⊆Σ×Σ:αv(r)s=def{0∀s′∈Σ:〈s,s′〉∉rsup{αv(r)s′+1|s′∈dom(αv(r))∧〈s,s′〉∈r}otherwiseIn Sections 6.1 and 7.1, we will follow the same abstract interpretation approach in order to systematically derive sound and complete semantics for proving guarantee and recurrence temporal properties of programs.The formal treatment given in the previous section is language independent. In the following, for simplicity we consider a while language with some non-deterministic assignments and tests. The variables are statically allocated and the only data type is the setZof mathematical integers. Note that our implementation, described in Section 9, actually supports a subset of the C language sufficient to handle real examples from actual benchmarks (e.g., the benchmarks of the International Competition on Software Verification11http://sv-comp.sosy-lab.org).In Fig. 3, we define inductively the syntax of our programming language.A program prog consists of an instruction followed by a unique labell∈L. Another unique label appears within each instruction. An instruction stmt is either a skip instruction, a variable assignment, a conditional if statement, a while loop or a sequential composition of instructions.Arithmetic expressions aexp involve variablesX∈X, numeric intervals[a,b]and the arithmetic operators +, −, ⁎,/for addition, subtraction, multiplication, and division. Numeric intervals have constant and possibly infinite bounds, and denote a random choice of a number in the interval. This provides a notion of non-determinism useful to model user input or to approximate arithmetic expressions that cannot be represented exactly in the language. Numeric constants are a particular case of numeric interval. We often write the constant c for the interval[c,c].Boolean expressions bexp are built by comparing arithmetic expressions, and are combined using the boolean not, and, and or operators. The boolean expression ? represents a non-deterministic choice and is useful to provide a sequential encoding of concurrent programs by modeling a (possibly, but not necessarily, fair) scheduler. Whenever clear from the context, we frequently abuse notation and use the symbol ? to also denote the numeric interval[−∞,+∞].In the following, we instantiate the definition of transition system (cf. Definition 1) with respect to programs written in our small imperative language.Expression semantics: An environmentρ:X→Zmaps each program variableX∈Xto its valueρ(X)∈Z. LetEdenote the set of all environments.The semantics of an arithmetic expression aexp is a function〚aexp〛:E→P(Z)mapping an environmentρ∈Eto the possible values for the expression aexp in the environment. Such semantics is standard, for the sake of completeness its formal definition is given in Appendix A. Note that the set of values for an expression may contain several elements because of the non-determinism in the expressions. It might also be empty due to undefined results (e.g., in case of divisions by zero).Similarly, the semantics〚bexp〛:E→P({true,false})of boolean expressions bexp maps an environmentρ∈Eto the set of all possible truth values for the expression bexp in the environment. Such semantics is also standard, and its formal definition is given in Appendix A. In the following, we write true and false to represent a boolean expression that is always true and always false, respectively.Transition systems: A program states∈L×Eis a pair consisting of a labell∈Land an environmentρ∈E, where the ρ defines the values of the program variables at the program point designated by l. Let Σ denote the set of all program states.The initial control pointi〚stmt〛∈L(resp.i〚prog〛∈L) of an instruction stmt (resp. a program prog) defines where the execution of the instruction (resp. program) starts, and the final control pointf〚stmt〛∈L(resp.f〚prog〛∈L) defines where the execution of the instruction stmt (resp. program prog) ends. The formal definitions are given in Appendix A. A program execution starts at its initial program control point with any possible value for the program variables.The set of initial states of a program prog isI=def{〈i〚prog〛,ρ〉|ρ∈E}. The set of final states isQ=def{〈f〚prog〛,ρ〉|ρ∈E}.Remark 1In Section 2 we defined the final states to have no successors with respect to the transition relation, meaning that the program halts:Ω=def{s∈Σ|∀s′∈Σ:〈s,s′〉∉τ}. This is the case when the program successfully terminates by reaching its final label, or when a run-time error occurs. For the sake of simplicity, the definition of program final states given in this section ignores possible run-time errors silently halting the program.Let us consider again the programSIMPLEfrom Fig. 1. The set of program environmentsEcontains functionsρ:{x}→Zmapping the program variable x to any possible valueρ(x)∈Z. The set of program statesΣ=def{1,2,3,4,5,6,7}×Econsists of all pairs of numerical labels and environments; the initial states areI=def{〈1,ρ〉|ρ∈E}and the final states areQ=def{〈7,ρ〉|ρ∈E}.We now define the transition relationτ∈Σ×Σ. In particular, in Fig. 4, we define the transition semanticsτ〚stmt〛∈Σ×Σof each program instruction stmt. Given an environmentρ∈E, a program variableX∈Xand a valuev∈Z, we denote byρ[X←v]the environment obtained by writing v into X in ρ:ρ[X←v](x)={vx=Xρ(x)x≠XThe semantics of a skip instruction simply moves control from the initial label of the instruction to its final label. The execution of a variable assignmentXl≔aexpmoves control from the initial label of the instruction to its final label, and modifies the current environment in order to assign any of the possible values of aexp to the variable X. The semantics of a conditional statementifbexplthenstmt1elsestmt2fimoves control from the initial label of the instruction to the initial label of stmt1, if true is a possible value for bexp, and to the initial label of stmt2, if false is a possible value for bexp; then, stmt1 and stmt2 are executed. Similarly, the execution of a while statementwhilebexpldostmtodmoves control from the initial label of the instruction to its final label, if false is a possible value for bexp, and to the initial label of stmt1, if true is a possible value for bexp; then stmt is executed. Note that control moves from the end of stmt to the initial label l of the while loop. Finally, the semantics of the sequential combination of instructionsstmt1stmt2executes stmt1 and stmt2.The transition relationτ∈Σ×Σof a program prog is defined by the semanticsτ〚prog〛∈Σ×Σof the program asτ〚prog〛=τ〚stmtl〛=defτ〚stmt〛.Example 6Let us consider again the program SIMPLE from Fig. 1. The program transition relationτ∈Σ×Σis defined as follows:τ=def{〈1,ρ〉→〈2,ρ〉|ρ∈E∧true∈〚0≤x〛ρ}∪{〈2,ρ〉→〈1,ρ[x←ρ(x)−1]〉|ρ∈E}∪{〈1,ρ〉→〈3,ρ〉|ρ∈E∧false∈〚0≤x〛ρ}∪{〈3,ρ〉→〈4,ρ〉|ρ∈E}∪{〈4,ρ〉→〈5,ρ〉|ρ∈E∧true∈〚x≤10〛ρ}∪{〈5,ρ〉→〈3,ρ[x←ρ(x)+1]〉|ρ∈E}∪{〈4,ρ〉→〈6,ρ〉|ρ∈E∧false∈〚x≤10〛ρ}∪{〈6,ρ〉→〈3,ρ[x←−ρ(x)]〉|ρ∈E}In the following, we provide a structural definition of the fixpoint termination semanticsτt∈Σ⇀O(cf. Eq. (4)) by induction on the syntax of programs written in our small imperative language.We partitionτtwith respect to the program control points:τt∈L→(E⇀O). In this way, to each program control pointl∈Lcorresponds a partial functionf:E⇀O, and to each program instruction stmt corresponds a termination semantics transformerτt〚stmt〛:(E⇀O)→(E⇀O). Analogously to Eq. (4), the ranking function is built backwards: each transformerτt〚stmt〛:(E⇀O)→(E⇀O)takes as input a ranking function whose domain represents the terminating environments at the final control point of stmt, and determines a ranking function whose domain represents the terminating environments at the initial control point of stmt, and whose value represents an upper bound on the number of program execution steps remaining to termination.Skip instruction: The termination semantics of a skip instruction takes as input a ranking functionf:E⇀Owhose domain represents the terminating environments at the final label of the instruction, and increases its value by one to take into account that from the environments at the initial label of the instruction another program execution step is necessary before termination:(10)τt〚skipl〛f=defλρ∈dom(f).f(ρ)+1Assignment instruction: Similarly, the termination semantics of a variable assignmentXl≔aexptakes as input a ranking functionf:E⇀Owhose domain represent the terminating environments at the final label of the instruction. The resulting ranking function is defined over the environments that when subject to the variable assignment always belong to the domain of the input ranking function. The value of the input ranking function for these environments is increased by one, to take into account another execution step before termination, and the value of the resulting ranking function is the least upper bound of these values, in order to take non-determinism into account:(11)τt〚Xl≔aexp〛f=defλρ.{sup{f(ρ[X←v])+1|v∈〚aexp〛ρ}〚aexp〛ρ≠∅∧∀v′∈〚aexp〛ρ:ρ[X←v′]∈dom(f)undefinedotherwiseNote that all environments yielding a run-time error due to a division by zero do not belong to the domain of the termination semantics of the assignment.Example 7Let us consider again the program SIMPLE from Fig. 1. We assume that the following ranking functionf:E⇀Ois valid at program point3during some iterate of the termination semantics:f=defλρ.{0ρ(x)=3undefinedotherwiseand we consider the assignmentx≔x+1at program point5. The termination semantics of the assignment, given the ranking function, isτt〚x≔x+1〛f=defλρ.{1ρ(x)=2undefinedotherwiseIn particular, note that the function is only defined whenρ(x)=2. In fact, when for exampleρ(x)=1, we have〚x+1〛ρ={2}andρ[x←2]∉dom(f). Similarly, when for exampleρ(x)=3, we have〚x+1〛ρ={4}andρ[x←4]∉dom(f).Conditional instruction: Given a conditionalifbexplthenstmt1elsestmt2fi, its termination semantics takes as input a ranking functionf:E⇀O, whose value represents an upper bound on the number of execution steps to termination from the final control point of the instruction. Then, it derives the termination semanticsτt〚stmt1〛fof stmt1, in the following denoted by S1, and the termination semanticsτt〚stmt2〛fof stmt2, in the following denoted by S2. The value of S1 (respectively, S2) represents an upper bound on the number of execution steps from the initial control of stmt1 (respectively, stmt2). The termination semantics of the conditional instruction is defined by means of the ranking functionF1:E⇀Owhose domain is the set of environmentsρ∈Ethat belong to the domain of S1 and that must satisfy bexp:F1=defλρ∈dom(S1).{S1(ρ)+1〚bexp〛ρ={true}undefinedotherwiseand the ranking functionF2:E⇀Owhose domain is the set of environments that belong to the domain of S2 and that cannot satisfy bexp:F2=defλρ∈dom(S2).{S2(ρ)+1〚bexp〛ρ={false}undefinedotherwiseand the ranking functionF:E⇀Owhose domain is the set of environments that belong to the domain of S1 and to the domain of S2, and that due to non-determinism may both satisfy and not satisfy the boolean expression bexp:F=defλρ∈dom(S1)∩dom(S2).{sup{S1(ρ)+1,S2(ρ)+1}〚bexp〛ρ={true,false}undefinedotherwiseThe value of F1, F2, and F represents an upper bound on the execution steps to termination from the initial control point of the conditional instruction when only the first branch is taken, when only the second branch is takes, or when (due to non-determinism) both branches are taken, respectively. The resulting ranking function is defined joining F1, F2, and F:(12)τt〚ifbexplthenstmt1elsestmt2fi〛f=defF1∪̇F2∪̇Fwhere∪̇joins partial functions with disjoint domains: givenf1:A⇀Bandf2:A⇀Bsuch thatdom(f1)∩dom(f2)=∅,(f1∪̇f2)(x)=f1(x), whenx∈dom(f1), and(f1∪̇f2)(x)=f2(x), whenx∈dom(f2).Example 8Let us consider again the program SIMPLE from Fig. 1. We consider the conditional statementifbexpthenstmt1elsestmt2fiat program point4. We assume, given a ranking functionf:E⇀Ovalid at program point3during some iterate, that the termination semantics of stmt1 is defined asτt〚stmt1〛f=defλρ.{1ρ(x)≤0undefinedotherwiseand that the termination semantics of stmt2 is defined asτt〚stmt2〛f=defλρ.{30≤ρ(x)undefinedotherwiseThen, since the boolean expression bexp isx≤10, the termination semantics of the conditional statement isτt〚ifbexplthenstmt1elsestmt2fi〛f=defλρ.{2ρ(x)≤043<ρ(x)undefinedotherwiseInstead, if bexp is for example the non-deterministic choice?, we haveτt〚ifbexplthenstmt1elsestmt2fi〛f=defλρ.{4ρ(x)=0undefinedotherwiseLoop instruction: The termination semantics of a loopwhilebexpldostmtodtakes as input a ranking functionf:E⇀Othe domain of which represents the terminating environments at the final label of the instruction (i.e., after exiting the loop), and outputs the ranking function which is defined as a least fixpoint of the functionϕt:(E⇀O)→(E⇀O)within〈E⇀O,⊑〉, analogously to Eq. (4):(13)τt〚whilebexpldostmtod〛f=deflfp∅̇⊑ϕtThe functionϕt:(E⇀O)→(E⇀O)takes as input a ranking functionx:E⇀Oand adds to its domain the environments for which one more loop iteration is needed before termination. In the following, the termination semanticsτt〚stmt〛xof the loop body is denoted by S. The functionϕtis defined by means of the ranking functionF1:E⇀Owhose domain is the set of environmentsρ∈Ethat belong to the domain of S and that must satisfy bexp:F1=defλρ∈dom(S).{S(ρ)+1〚bexp〛ρ={true}undefinedotherwiseand the ranking functionF2:E⇀Owhose domain is the set of environments that belong to the domain of the input function f and that cannot satisfy bexp:F2=defλρ∈dom(f).{f(ρ)+1〚bexp〛ρ={false}undefinedotherwiseand the ranking functionF:E⇀Owhose domain is the set of environments that belong to the domain of S and to the domain of the input function f, and that may both satisfy and not satisfy the boolean expression bexp:F=defλρ∈dom(S)∩dom(f).{sup{S(ρ)+1,f(ρ)+1}〚bexp〛ρ={true,false}undefinedotherwiseThe resulting ranking function is defined joining F1, F2, and F:(14)ϕt(x)=defF1∪̇F2∪̇FComposition instruction: Finally, the termination semantics of the sequential combination of instructionsstmt1stmt2, takes as input a ranking functionf:E⇀Oat the final control point of stmt2, determines from f the termination semanticsτt〚stmt2〛fof stmt2, and feeds it as input to the termination semantics of stmt1 in order to get a ranking function at the initial control point of stmt1:(15)τt〚stmt1stmt2〛f=defτt〚stmt1〛(τt〚stmt2〛f)Program termination semantics: The termination semanticsτt〚prog〛∈E⇀Oof a program prog is a ranking function whose domain represents the terminating environments, which is determined taking as input the zero function:(16)τt〚prog〛=τt〚stmtl〛=defτt〚stmt〛(λρ.0).Note that, as pointed out in Remark 1, possible run-time errors silently halting the program are ignored. More specifically, all environments leading to run-time errors are discarded and do not belong to the domain of the termination semantics.In Sections 6.2 and 7.2, we provide a similar denotation for the guarantee properties semantics defined in Section 6.1 and for the recurrence properties semantics defined in Section 7.1.In general, we define a program property as a set of sequences of program states. A program has a certain property if all its traces belong to the property. In this paper, with respect to the hierarchy of program properties proposed in [2], we focus on guarantee (“something good happens at least once”) and recurrence (“something good happens infinitely often”) properties. In particular, we consider guarantee and recurrence properties that are expressible by temporal logic.We assume an underlying specification language, which is used to describe properties of program states. For instance, for our small imperative language, we define inductively the syntax of the state properties as follows:φ::=bexp|l:bexp|φ∧φ|φ∨φl∈LThe predicatel:bexpallows specifying a program state property at a particular program control pointl∈L. When a program states∈Σsatisfies the property φ, we writes⊨φand we say that s is a φ-state. We also slightly abuse notation and write φ to also denote the set{s∈Σ|s⊨φ}of states that satisfy the property φ.Example 9Let us consider again the program SIMPLE from Fig. 1. We write{〈x,v〉}to denote the environmentρ:{x}→Zmapping the program variable x to the valuev∈Z. An example of state property allowed by the specification language that we have defined is the property x=3. The set of states that satisfy this property is{1,2,3,4,5,6,7}×{〈x,3〉}. Note, however, that〈7,{〈x,3〉}〉is not reachable from the initial states. Another example of state property allowed by the specification language is7:x=3, which is only satisfied by〈7,{〈x,3〉}〉.The guarantee and recurrence properties within the hierarchy are then defined by means of the temporal operators always□and eventually⋄.The class of guarantee properties is informally characterized as the class of properties stating that “something good happens at least once”, that is, a program eventually reaches a desirable state. The guarantee properties that we consider are expressible by a temporal formula of the following form:⋄φwhere φ is a state property. The temporal formula expresses that at least one program state in every program trace satisfies the property φ, but it does not promise any repetition. In general, these guarantee properties are used to ensure that some event happens once during a program execution.A typical guarantee property is program termination, which ensures that all computations are finite, expressible by the temporal formula⋄(le:true), wherele∈Ldenotes the program final control point.Another typical guarantee property is program total correctness, which ensures that all computations starting in a φ-state terminate in a ψ-state, expressible by the temporal formula⋄(li:¬φ∨le:ψ), whereli,le∈Lrespectively denote the initial and the final program control point.Example 10Let us consider again the program SIMPLE from Fig. 1. An example of guarantee property is⋄(x=3), which is satisfied when the program initial states are limited to the set{〈1,ρ〉∈Σ|ρ(x)≤3}. In particular, note that when the initial states are limited to{〈1,ρ〉∈Σ|0≤ρ(x)≤3}, the guarantee property is satisfied within the first while loop. Instead, when the initial states are limited to{〈1,ρ〉∈Σ|ρ(x)<0}, the guarantee property is satisfied within the second while loop. Another example of guarantee property is⋄(3≤x), which is always satisfied by the program whatever its initial states.The class of recurrence properties is informally characterized as the class of properties stating that “something good happens infinitely often”, that is, a program reaches a desirable state infinitely often. The recurrence properties that we consider are expressible by a temporal formula of the following form:□⋄φwhere φ is a state property. The temporal formula expresses that infinitely many program states in every program trace satisfy the property φ. In general, these recurrence properties are used to ensure that some event happens infinitely many times during a program execution.A typical recurrence property is starvation freedom, which ensures that a process will repeatedly enter its critical section, and which is expressible by the temporal formula□⋄(lc:true), wherelc∈Lrepresents the critical section.Example 11Let us consider again the program SIMPLE from Fig. 1. The recurrence property represented by the formula□⋄x=3is satisfied when the program initial states are limited to the set{〈1,ρ〉∈Σ|ρ(x)<0}. In particular, note that the recurrence property is satisfied only within the second while loop. Instead, the recurrence property□⋄3≤xis always satisfied by the program.In the following, we generalize Section 3 from termination to guarantee properties. We define a sound and complete semantics for proving guarantee temporal properties by abstract interpretation of the program maximal trace semantics. The generalization is straightforward but provides a building block for proving recurrence temporal properties in the next Section 7.The guarantee semantics, given a set of desirable statesS⊆Σ, is a ranking functionτg[S]∈Σ⇀Odefined starting from the states in S, where the function has value zero, and retracing the program backwards while mapping every state in Σ definitely leading to a state in S (i.e., a state such that all the traces to which it belongs eventually reach a state in S) to an ordinal inOrepresenting an upper bound on the number of program execution steps remaining to S. The domaindom(τg[S])ofτg[S]is the set of states definitely leading to a desirable state in S: all traces branching from a states∈dom(τg[S])reach a state in S in at mostτg[S]sexecution steps, while at least one trace branching from a states∉dom(τg[S])never reaches S.Note that the program traces that satisfy a guarantee property can also be infinite traces. In particular, guarantee properties are satisfied by finite subsequences of possibly infinite traces. Thus, in order to reason about subsequences, we define the functionsq:P(Σ+∞)→P(Σ+), which extracts the finite subsequences of a set of sequencesT⊆Σ+∞:(17)sq(T)=def{σ∈Σ+|∃σ′∈Σ⁎,σ″∈Σ⁎∞:σ′σσ″∈T}We recall that the neighborhood of a sequenceσ∈Σ+∞in a set of sequencesT⊆Σ+∞is the set of sequencesσ′∈Twith a common prefix withσ(cf. Eq. (5)). A finite subsequence of a program trace satisfies a guarantee property if and only if it terminates in the desirable set of states (and never encounter a desirable state before), and its neighborhood in the subsequences of the program semantics consists only of sequences that are terminating in the desirable set of states (and never encounter a desirable state before). The corresponding guarantee abstractionαg[S]:P(Σ+∞)→P(Σ+)is parameterized by a set of desirable statesS⊆Σand it is defined as follows:(18)αg[S]T=def{σs∈sq(T)|σ∈S¯⁎,s∈S,nhbd(σ,sf(T)∩S¯+∞)=∅}whereS¯=defΣ⧹Sand the functionsf:P(Σ+∞)→P(Σ+∞)yields the set of suffixes of a set of sequencesT⊆Σ+∞:(19)sf(T)=def⋃{σ∈Σ+∞|∃σ′∈Σ⁎:σ′σ∈T}.Example 12LetT=def{(abcd)ω,(cd)ω,aω,cdω}and letS=def{c}. We havesf(T)∩S¯+∞={aω,dω}. Then, we haveαg[S]T={c,bc}. In fact, let us consider the trace(abcd)ω: the subsequences of(abcd)ωthat are terminating with c and never encounter c before are{c,bc,abc,dabc}; for abc, we havepf(ab)∩pf(aω)={a}≠∅and, for dabc, we havepf(dab)∩pf(dω)={d}≠∅. Similarly, let us consider(cd)ω: the subsequences of(cd)ωthat are terminating with c and never encounter c before are{c,dc}; for dc, we havepf(d)∩pf(dω)={d}≠∅.We can now define the guarantee semanticsτg[S]∈Σ⇀O:Definition 7Guarantee semanticsGiven a desirable set of statesS⊆Σ, the guarantee semanticsτg[S]∈Σ⇀Ois an abstract interpretation of the maximal trace semanticsτ+∞∈P(Σ+∞)(cf. Eq. (3)):(20)τg[S]=defαrk(αg[S](τ+∞))whereαrk:P(Σ+)→(Σ⇀O)is the ranking abstraction (cf. Eq. (9)).The guarantee semantics can be expressed as a least fixpoint within the partially ordered set〈Σ⇀O,⊑〉as follows:(21)τg[S]=lfp∅̇⊑ϕg[S]ϕg[S]f=defλs.{0s∈Ssup{f(s′)+1|〈s,s′〉∈τ}s∉S∧s∈pre˜(dom(f))undefinedotherwiseExample 13Let us consider the following trace semantics:where the highlighted states are the set S of desirable states.The fixpoint iterates of the guarantee semanticsτg[S]∈Σ⇀Oarewhere unlabeled states are outside the domain of the function.Note that when the set of desirable states S is the set of final states Ω, unsurprisingly we rediscover the termination semantics presented in Section 3, sinceϕg[Ω]=ϕt(cf. Eq. (4)).Let φ be a state property. The φ-guarantee semanticsτgφ∈Σ⇀O:(22)τgφ=defτg[φ]is sound and complete for proving a guarantee property⋄φ:Theorem 2A program satisfies a guarantee property⋄φfor all traces starting from a given set of initial statesIif and only ifI⊆dom(τgφ).By Park׳s Fixpoint Induction Principle [15]. See Appendix B.In the following, we provide a structural definition of the fixpoint guarantee semanticsτgφ∈Σ⇀O(cf. Eq. (22)) by induction on the syntax of programs written in our small imperative language presented in Section 4.We partitionτgφwith respect to the program control points:τgφ∈L→(E⇀O). In this way, to each program control pointl∈Lcorresponds a partial functionf:E⇀O, and to each program instruction stmt corresponds a guarantee semantics transformerτgφ〚stmt〛:(E⇀O)→(E⇀O). Analogously to Eq. (21), the ranking function is built backwards: each transformerτgφ〚stmt〛:(E⇀O)→(E⇀O)takes as input a ranking function whose domain represents the environments always leading to φ from the final control point of stmt, and determines the ranking function whose domain represents the environments always leading to φ from the initial control point of stmt, and whose value represents an upper bound on the number of program execution steps remaining to φ.Skip instruction: The guarantee semantics of a skip instruction resets the input ranking functionf:E⇀Ofor the environments that satisfy φ, and otherwise it increases its value (as the skip termination semantics, cf. Eq. (10)):(23)τgφ〚skipl〛f=defλρ.{0〈l,ρ〉⊨φf(ρ)+1〈l,ρ〉⊭φ∧ρ∈dom(f)undefinedotherwiseAssignment instruction: Similarly, the guarantee semantics of a variable assignmentXl≔aexpresets the value of the input ranking functionf:E⇀Ofor the environments that satisfy φ; otherwise, the resulting ranking function is defined over the environments that when subject to the variable assignment always belong to the domain of f (as the assignment termination semantics, cf. Eq. (11)):(24)τgφ〚Xl≔aexp〛f=defλρ.{0〈l,ρ〉⊨φsup{f(ρ[X←v])+1|v∈〚aexp〛ρ}〈l,ρ〉⊭φ∧〚aexp〛ρ≠∅∧∀v′∈〚aexp〛ρ:ρ[X←v′]∈dom(f)undefinedotherwiseExample 14Let us consider again the program SIMPLE from Fig. 1. We consider the following ranking functionf:E⇀Ovalid at program point3during the first iterate of the guarantee semantics:f=defλρ.{0ρ(x)=3undefinedotherwisethe assignmentx≔x+1at program point5and the guarantee property⋄(x=3). The guarantee semantics of the assignment, given the ranking function, isτgx=3〚x≔x+1〛f=defλρ.{1ρ(x)=20ρ(x)=3undefinedotherwiseNote that the function is defined whenρ(x)=3, even though〚x+1〛ρ={4}andρ[x←4]∉dom(f). Indeed, the environment{〈x,3〉}satisfies the property x=3.Conditional instruction: Given a conditionalifbexplthenstmt1elsestmt2fi, its guarantee semantics takes as input a ranking functionf:E⇀Oand derives the guarantee semanticsτgφ〚stmt1〛fandτgφ〚stmt2〛fof stmt1, and stmt2, respectively. Then, the guarantee semantics of the conditional instruction is defined by joining F1, F2, and F (defined exactly as for the if termination semantics, cf. Eq. (12), where S1 isτgφ〚stmt1〛fand S2 isτgφ〚stmt2〛f), and resetting the value of the function for the environments that satisfy φ:(25)τgφ〚ifbexplthenstmt1elsestmt2fi〛f=defλρ.{0〈l,ρ〉⊨φG(ρ)〈l,ρ〉⊭φ∧ρ∈dom(G)undefinedotherwisewhereG=defF1∪̇F2∪̇F.Example 15Let us consider again the program SIMPLE from Fig. 1. We consider the guarantee property⋄(x=3)and the conditional statementifbexpthenstmt1elsestmt2fiat program point4. We assume, givenf:E⇀Ovalid at program point3during some iterate, that the guarantee semantics of stmt1 is defined asτgx=3〚stmt1〛f=defλρ.{1ρ(x)≤00ρ(x)=3undefinedotherwiseand that the guarantee semantics of stmt2 is defined asτgx=3〚stmt2〛f=defλρ.{30≤ρ(x)<30ρ(x)=333<ρ(x)undefinedotherwiseThen, since the boolean expression bexp isx≤10, the guarantee semantics of the conditional statement isτgx=3〚ifbexplthenstmt1elsestmt2fi〛f=defλρ.{2ρ(x)≤00ρ(x)=343<ρ(x)undefinedotherwiseInstead, if bexp is for example the non-deterministic choice?, we haveτgx=3〚ifbexplthenstmt1elsestmt2fi〛f=defλρ.{4ρ(x)=00ρ(x)=3undefinedotherwiseNote that, unlike Example 8, both functions are also defined whenρ(x)=3, since the environment{〈x,3〉}satisfies the property x=3.Loop instruction: The guarantee semantics of a loopwhilebexpldostmtodtakes as input a ranking functionf:E⇀Owhose domain represents the environments leading to φ from the final label of the instruction (i.e., after exiting the loop), and outputs the ranking function which is defined as the least fixpoint of the functionϕgφ:(E⇀O)→(E⇀O)within〈E⇀O,⊑〉, analogously to Eq. (21):(26)τgφ〚whilebexpldostmtod〛f=deflfp∅̇⊑ϕgφThe functionϕgφ:(E⇀O)→(E⇀O)takes as input a ranking functionx:E⇀O, resets its value for the environments that satisfy φ, and adds to its domain the environments for which one more loop iteration is needed before φ. The functionϕgφis defined by joining the ranking functions F1, F2, and F (defined exactly as for the while termination semantics, cf. Eq. (14), where S is the guarantee semanticsτgφ〚stmt〛xof the loop body), and resetting the value of the function for the environments that satisfy φ:(27)ϕgφ(x)=defλρ.{0〈l,ρ〉⊨φG(ρ)〈l,ρ〉⊭φ∧ρ∈dom(G)undefinedotherwisewhereG=defF1∪̇F2∪̇F.Composition instruction: Finally, the guarantee semantics of the sequential combination of instructionsstmt1stmt2, takes as input a ranking functionf:E⇀Oat the final control point of stmt2, determines from f the guarantee semanticsτgφ〚stmt2〛fof stmt2, and feeds it as input to the guarantee semantics of stmt1 in order to get a ranking function at the initial control point of stmt1:(28)τgφ〚stmt1stmt2〛f=defτgφ〚stmt1〛(τgφ〚stmt2〛f)Program guarantee semantics: The guarantee semanticsτgφ〚prog〛∈E⇀Oof a program prog is a ranking function whose domain represents the environments eventually leading to φ, which is determined by taking as input the constant function equal to zero for the environments that satisfy φ, and undefined otherwise:(29)τgφ〚prog〛=τgφ〚stmtl〛=defτgφ〚stmt〛(λρ.{0〈l,ρ〉⊨φundefinedotherwise)Note that, as pointed out in Remark 1, possible run-time errors are ignored. More specifically, all environments leading to run-time errors are discarded and do not belong to the domain of the guarantee semantics.We now define a sound and complete semantics for proving recurrence temporal properties by abstract interpretation of the program maximal trace semantics, following the same approach used in Section 6 for guarantee properties.The recurrence semantics, given a set of desirable statesS⊆Σ, is a ranking functionτr[S]∈Σ⇀Odefined starting from the states in S, where the function has value zero, and retracing the program backwards while mapping every state in Σ definitely leading infinitely often to a state in S (i.e., a state such that all the traces to which it belongs reach a state in S infinitely often) to an ordinal inOrepresenting an upper bound on the number of program execution steps remaining to the next state in S. The domaindom(τr[S])ofτr[S]is the set of states definitely leading infinitely often to a desirable state in S: all traces branching from a states∈dom(τr[S])reach the next state in S in at mostτr[S]sexecution steps, while at least one trace branching from a states∉dom(τr[S])reaches S at most a finite number of times.In particular, the recurrence semantics reuses the guarantee semantics of Section 6 as a building block: from the guarantee that some desirable event happens once during program execution, the recurrence semantics ensures that the event happens infinitely often. We define the set of subsequences of a program trace that satisfy a recurrence property using the set itself: a finite subsequence of a program trace satisfies a recurrence property if and only if it terminates in the desirable set of states (and never encounter a desirable state before), and its neighborhood in the subsequences of the program semantics consists only of sequences that are terminating in the desirable set of states (and never encounter a desirable state before), and that are prefixes of traces in the program semantics that reach infinitely often the desirable set of states. The corresponding recurrence abstractionαr[S]:P(Σ+∞)→P(Σ+)is parameterized by a set of desirable statesS⊆Σand it is defined as a fixpoint as follows:(30)αr[S]T=defgfpαg[S]T⊆ψr[T,S]ψr[T,S]T′=defαg[pre˜[T]T′∩S]Twherepre˜[T]T′=def{s∈Σ|∀σ∈Σ⁎,σ′∈Σ⁎∞:σsσ′∈T⇒pf(σ′)∩T′≠∅}is the set of states whose successors all belong to a given set of subsequences, andgfpαg[S]denotes the greatest fixpoint less than or equal to the guarantee abstractionαg[S]:P(Σ+∞)→P(Σ+)(cf. Eq. (18)) of T.To explain intuitively Eq. (30), we use the dual of Kleene׳s Fixpoint Theorem [11] to rephraseαr[S]as the following limit of a decreasing iteration:αr[S]T=⋂i∈NTi+1Ti+1=def[ψr[T,S]]i(αg[S]T)Then, for i=0, we get the setT1=αg[S]Tof subsequences of T that guarantee S at least once. For i=1, starting from T1, we derive the set of statesS1=pre˜[T]T1∩S(i.e.,S1⊆S) whose successors all belong to the subsequences in T1, and we get the setT2=αg[S1]Tof subsequences of T that guarantee S1 at least once and thus guarantee S at least twice. Note that all the subsequences in T2 terminate with a states′∈S1and therefore are prefixes of subsequence of T that reach S at least twice. More generally, for eachi∈N, we get the setTi+1of subsequences which are prefixes of subsequences of T that reach S at leasti+1times, i.e., the subsequences that guarantee S at leasti+1times. The limit thus guarantees S infinitely often.Example 16LetT=def{(cd)ω,caω,d(be)ω}and letS=def{b,c,d}. For i=0, we haveT1=αg[S]T={b,eb,c,d}. For i=1, we deriveS1={b,d}, sincec(dc)ω∈Tandpf((dc)ω)∩T1={d}≠∅butcaω∈Tandpf(aω)∩T1=∅. We getT2=αg[S1]T={b,eb,d}. For i=2, we deriveS2={b}, sinced(be)ω∈Tandpf((be)ω)∩T1={b}≠∅butd(cd)ω∈Tandpf((cd)ω)∩T2=∅. We getT3=αg[S2]T={b,eb}which is the greatest fixpoint: the only subsequences of sequences in T that guarantee S infinitely often start with b or eb.We can now define the recurrence semanticsτr[S]∈Σ⇀O:Definition 8Recurrence semanticsGiven a desirable set of statesS⊆Σ, the recurrence semanticsτr[S]∈Σ⇀Ois an abstract interpretation of the maximal trace semanticsτ+∞∈P(Σ+∞)(cf. Eq. (3)):(31)τr[S]=defαrk(αr[S](τ+∞))whereαrk:P(Σ+)→(Σ⇀O)is the ranking abstraction (cf. Eq. (9)).The recurrence semantics can be expressed as a least fixpoint within the partially ordered set〈Σ⇀O,⊑〉as follows:(32)τr[S]=gfpτg[S]⊑ϕr[S]ϕr[S]f=defλs.{f(s)s∈dom(τg[pre˜(dom(f))∩S])undefinedotherwiseNote that the recurrence semantics can be equivalently simplified as(33)τr[S]=gfpτg[S]⊑ϕr[S]ϕr[S]f=defλs.{f(s)s∈pre˜(dom(f))undefinedotherwiseIndeed, there is no need to redefineτg[S]at each iterate since we always havedom(f)⊆dom(τg[S])and∀s∈dom(f):f(s)=τg[S](s).Example 17Let us consider the following trace semantics:where the highlighted states are the set S of desirable states.The fixpoint iterates of the recurrence semanticsτr[S]∈Σ⇀Oarewhere unlabeled states are outside the domain of the function.Let φ be a state property. The φ-recurrence semanticsτrφ∈Σ⇀O:(34)τrφ=defτr[φ]is sound and complete for proving a recurrence property□⋄φ:Theorem 3A program satisfies a recurrence property□⋄φfor all traces starting from a given set of statesIif and only ifI⊆dom(τrφ).The proof follows from the dual of Park׳s Fixpoint Induction Principle [15] and from Theorem 2. See Appendix B.In the following, we provide a structural definition of the fixpoint recurrence semanticsτrφ∈Σ⇀O(cf. Eq. (34)) by induction on the syntax of programs written in our idealized programming language of Section 4.We partitionτrφwith respect to the program control points:τrφ∈L→(E⇀O). In this way, to each program control pointl∈Lcorresponds a partial functionf:E⇀O, and to each program instruction stmt corresponds a recurrence semantics transformerτrφ〚stmt〛:(E⇀O)→(E⇀O). Analogously to Eq. (33), the ranking function is built backwards: each transformerτrφ〚stmt〛:(E⇀O)→(E⇀O)takes as input a ranking function whose domain represents the environments always leading infinitely often to φ from the final control point of stmt, and determines a ranking function whose domain represents the environments always leading infinitely often to φ from the initial control point of stmt, and whose value represents an upper bound on the number of program execution steps remaining to the next occurrence of φ. In particular, each transformerτrφ〚stmt〛∈(E⇀O)→(E⇀O)behaves as the guarantee semantics transformerτgφ〚stmt〛∈(E⇀O)→(E⇀O)defined in Section 6.2 and also ensures that each timeφ is satisfied, it will be satisfied again in the future: the value of the input ranking function is reset for the environments that satisfy φ only if all their successors by means of the instruction stmt belong to the domain of the input ranking function.Skip instruction: The recurrence semantics of a skip instruction is defined analogously to its guarantee semantics (cf. Eq. (23)), except that it resets the value of the input ranking functionf:E⇀Ofor the environments that satisfy φ only when they already belong to its domain:(35)τrφ〚skipl〛f=defλρ.{0〈l,ρ〉⊨φ∧ρ∈dom(f)f(ρ)+1〈l,ρ〉⊭φ∧ρ∈dom(f)undefinedotherwiseAssignment instruction: Similarly, the recurrence semantics of a variable assignmentXl≔aexpis defined analogously to the assignment guarantee semantics (cf. Eq. (24)), except that it resets the value of the input ranking functionf:E⇀Oonly for the environments that satisfy φ and that when subject to the assignment always belong to the domain of f:(36)τrφ〚Xl≔aexp〛f=defλρ.{0〈l,ρ〉⊨φ∧〚aexp〛ρ≠∅∧∀v′∈〚aexp〛ρ:ρ[X←v′]∈dom(f)sup{f(ρ[X←v])+1|v∈〚aexp〛ρ}〈l,ρ〉⊭φ∧〚aexp〛ρ≠∅∧∀v′∈〚aexp〛ρ:ρ[X←v′]∈dom(f)undefinedotherwiseExample 18Let us consider again the program SIMPLE from Fig. 1. We consider the following ranking functionf:E⇀Ovalid at program point3during the first iterate of the recurrence semantics:f=defλρ.{0ρ(x)=3undefinedotherwisethe assignmentx≔x+1at program point5and the recurrence property□⋄(x=3). The recurrence semantics of the assignment isτrx=3〚x≔x+1〛f=defλρ.{1ρ(x)=2undefinedotherwiseNote that, unlike Example 14, the function is not defined whenρ(x)=3, since{〈x,3〉}satisfies the property x=3 but〚x+1〛ρ={4}andρ[x←4]∉dom(f).Conditional instruction: The recurrence semantics of a conditional instructionifbexplthenstmt1elsestmt2fi, unlike its guarantee semantics (cf. Eq. (25)), resets the value of the function obtained by joining F1, F2, and F (cf. Eq. (12), where S1 isτrφ〚stmt1〛fand S2 isτrφ〚stmt2〛f) only for the environments that satisfy φ and also belong to its domain:(37)τgφ〚ifbexplthenstmt1elsestmt2fi〛f=defλρ.{0〈l,ρ〉⊨φ∧ρ∈dom(R)R(ρ)〈l,ρ〉⊭φ∧ρ∈dom(R)undefinedotherwisewhereR=defF1∪̇F2∪̇F.Example 19Let us consider again the program SIMPLE from Fig. 1. We consider the recurrence property□⋄(x=3)and the conditional statementifbexpthenstmt1elsestmt2fiat program point4. We assume, givenf:E⇀Ovalid at program point3during some iterate, that the recurrence semantics of stmt1 is defined asτrx=3〚stmt1〛f=defλρ.{1ρ(x)≤0undefinedotherwiseand that the recurrence semantics of stmt2 is defined asτrx=3〚stmt2〛f=defλρ.{30≤ρ(x)<30ρ(x)=333<ρ(x)undefinedotherwiseThen, since the boolean expression bexp isx≤10, the recurrence semantics of the conditional statement isτrx=3〚ifbexplthenstmt1elsestmt2fi〛f=defλρ.{2ρ(x)≤043<ρ(x)undefinedotherwiseInstead, if bexp is for example the non-deterministic choice?, we haveτrx=3〚ifbexplthenstmt1elsestmt2fi〛f=defλρ.{4ρ(x)=0undefinedotherwiseNote that, unlike Example 15, both functions are undefined whenρ(x)=3, even though the property x=3 is satisfied by the environment{〈x,3〉}. In fact, the ranking function for the then branch of the if is undefined whenρ(x)=3.Loop instruction: The recurrence semantics of a loopwhilebexpldostmtodtakes as input a ranking functionf:E⇀Owhose domain represents the environments leading infinitely often to φ from the final label of the instruction (i.e., after exiting the loop), and outputs the ranking function which is defined as a greatest fixpoint of the functionϕrφ:(E⇀O)→(E⇀O)within〈E⇀O,⊑〉:(38)τrφ〚whilebexpldostmtod〛f=defgfpG⊑ϕrφwhereG=defτgφ〚whilebexpldostmtod〛fis the guarantee semantics of the loop instruction defined in Eq. (26). In essence, from the guarantee that some desirable event eventually happens, the recurrence semantics ensures that the event happens infinitely often. The functionϕrφ:(E⇀O)→(E⇀O)takes as input a ranking functionx:E⇀O, resets its value for the environments that belong to its domain and that satisfy φ, and adds to its domain the environments for which one more loop iteration is needed before the next occurrence of φ. The functionϕrφ, unlikeϕgφ(cf. Eq. (27)), resets the value of the function obtained by joining F1, F2, and F (cf. Eq. (14), where S isτrφ〚stmt〛x) only for the environments that satisfy φ and also belong to its domain:(39)ϕrφ(x)=defλρ.{0〈l,ρ〉⊨φ∧ρ∈dom(R)R(ρ)〈l,ρ〉⊭φ∧ρ∈dom(R)undefinedotherwisewhereR=defF1∪̇F2∪̇F.Composition instruction: Finally, the recurrence semantics of the sequential combination of instructionsstmt1stmt2, takes as input a ranking functionf:E⇀Oat the final control point of stmt2, determines from f the recurrence semanticsτrφ〚stmt2〛fof stmt2, and feeds it as input to the recurrence semantics of stmt1 in order to get a ranking function at the initial control point of stmt1:(40)τrφ〚stmt1stmt2〛f=defτrφ〚stmt1〛(τrφ〚stmt2〛f)Program recurrence semantics: The recurrence semanticsτrφ〚prog〛∈E⇀Oof a program prog is a ranking function whose domain represents the environments leading infinitely often to φ, which is determined by taking as input the totally undefined function, since the program final states cannot satisfy a recurrence property:(41)τrφ〚prog〛=τrφ〚stmtl〛=defτrφ〚stmt〛∅̇As pointed out in Remark 1, possible run-time errors are ignored. Thus, all environments leading to run-time errors are discarded and do not belong to the domain of the recurrence semantics.The termination semanticsτtof Section 3, the φ-guarantee semanticsτgφof Section 6 and the φ-recurrence semanticsτrφof Section 7 are usually not computable (i.e., when the program state space is infinite).In [6–8], we present decidable abstractions ofτtby means of piecewise-defined ranking functions over natural numbers [6], over ordinals [7] and with relational partitioning [8]. In the following, we will briefly recall the main characteristics of these abstractions and we will show how to modify the abstract domains in order to obtain decidable abstractions ofτgφandτrφas well. We refer to [6–8] for more detailed discussions on the abstract domains.The abstract termination semanticsτt♮∈L→Tmaps each program control pointl∈Lto an elementt∈Tof the decision trees abstract domainT.Decision trees abstract domain: The elements of the decision trees abstract domainTare piecewise-defined ranking functions represented by decision trees, where the decision nodes are labeled with linear constraints inC=def{c1X1+⋯+ckXk+ck+1≥0|X1,…,Xk∈X,c1,…,ck,ck+1∈Z}, and the leaf nodes belong to an auxiliary abstract domainFwhose elements are natural-valued (or ordinal-valued [7]) functions of the program variables. The paths along the decision trees establish the shape of the pieces of the ranking functions, and the leaf nodes represent the value of the ranking functions within their pieces. A special element⊥denotes an undefined value within a piece. In the following, we slightly abuse notation and use⊥to also denote a decision tree with a single undefined leaf node.The decision trees abstract domain is parametric in the choice between the expressivity and the cost of the numerical abstract domain [16–18] which underlies the linear constraints labeling the decision nodes, and the choice of the auxiliary abstract domain for the leaf nodes. For example, in [6] we consider piecewise-defined ranking functions represented using interval constraints based on the intervals abstract domain [16] at the decision nodes, and affine functions at the leaf nodes. We used the same parameterization to analyze the program SIMPLE of Fig. 1 for proving⋄(x=3)and⋄(x=3)and, in Fig. 5a, we depict the decision tree inferred at program control point3. The graphical representation of the ranking function is shown in Fig. 5b.Abstract termination semantics: A sound abstract termination semantics transformerτt♮〚stmt〛∈T→Tcorresponds to each program instruction stmt. We define each functionτt♮〚stmt〛in Fig. 7 by means of the following operators in the decision trees abstract domain:STEP,B−ASSIGN〚X≔aexp〛,FILTER〚bexp〛, the join operator⋎, and the widening operator▿. The operatorSTEPdescends along each path of a decision tree up to a leaf node, where it simply increments the value of the ranking function (cf. Fig. 6b) to count another program execution step. The operatorB−ASSIGN〚X≔aexp〛models a backward assignment by substituting the variable X with the expression aexp within the decision nodes as well as within the leaf nodes, and also increments the value of the ranking function within the leaf nodes (cf. Fig. 6c). The operatorFILTER〚bexp〛discards all paths of a decision tree that do not satisfy the expression bexp, possibly introducing new decision nodes, and also increments the value of the ranking function within the remaining leaf nodes (cf. Fig. 6a). The join operator yields a piecewise-defined ranking function defined over the coarsest partition refining both partitions of the given decision trees (cf. Fig. 6d). The widening operator instead imposes the less refined partition of a given decision tree upon another given decision tree, possibly inducing a loss of precision but enforcing termination of the analysis. In Fig. 7,lfp♮ϕt♮denotes the limit of the iteration sequence with widening:(42)y0=def⊥yn+1=def{ynϕt♮(yn)⊑♮yn∧ϕt♮(yn)≼♮ynyn▿ϕt♮(yn)otherwisewhere⊑♮and≼♮are the abstract counterparts of the computational⊑and approximation≼order, respectively. We refer to [6–8] for further details.The transformersτt♮〚stmt〛are combined together to compute a piecewise-defined ranking function for a program through backward analysis. The starting point is the constant function equal to zero at the program final control pointf〚prog〛. This function is then propagated backwards towards the program initial control pointi〚prog〛taking assignments and tests into account and, in case of loops, solving least fixpoints by iteration with widening.The abstract termination semantics is sound with respect to the approximation orderv1≼v2⇔dom(v1)⊇dom(v2)∧∀x∈dom(v2):v1(x)≤v2(x)(cf. Section 3). Thus, the backward analysis computes an over-approximation of the value of the termination semanticsτtand an under-approximation of its domain of definitiondom(τt). In this way, an abstraction provides sufficient preconditions for program termination: if the abstraction is defined on a program state, then all the program traces branching from that state are terminating, and the value of the function provides an upper bound on the number of execution steps before termination.In the following, we describe how to reuse the decision trees abstract domain [6–8] briefly recalled in the previous section, and what changes are required in order to obtain decidable abstractions ofτgφ(cf. Eq. (22)).We define the abstract φ-guarantee semanticsτgφ♮∈L→T: to each program control pointl∈Lcorresponds a piecewise-defined ranking functiont∈T, and for each program instruction stmt a sound guarantee semantics transformerτgφ♮〚stmt〛∈T→Tis defined in Fig. 8. In particular, we complement the operators briefly presented in the previous Section 8.1 with a new operatorRESET〚φ〛, which possibly splits a given piecewise-defined ranking function into more pieces (by introducing new decision nodes in a decision tree) in order to distinguish the pieces that satisfy φ, and resets its value within those pieces (and leaves the other pieces unchanged). We propose an example of use of theRESET〚φ〛operator in Fig. 9. Note thatRESET〚φ〛operates also on undefined leaf nodes.The transformersτgφ♮〚stmt〛are again combined together through backward analysis. The starting point is now the constant function equal to zero only for the environments that satisfy the property φ, and undefined elsewhere (i.e.,RESET〚φ〛⊥), at the program final control pointf〚prog〛. The backward analysis computes an over-approximation of the value of the φ-guarantee semanticsτgφand an under-approximation of its domain of definitiondom(τgφ). In this way, an abstraction provides sufficient preconditions for the guarantee property⋄φ: if the abstraction is defined on a program state, then all the program traces branching from that state eventually reach a state with the property φ, and the value of the function provides an upper bound on the number of execution steps before such state with the property φ.Example 20In Fig. 10a, we depict the decision tree inferred for proving the guarantee property⋄(x=3)at program control point1of the program SIMPLE of Fig. 1. The graphical representation of the ranking function is shown in Fig. 10b. Its domain yields the sufficient preconditionx≤3for⋄(x=3).We now describe the required changes to the decision trees abstract domains in order to obtain a decidable abstraction of the φ-recurrence semanticsτrφ(cf. Eq. (34)).We define the abstract φ-recurrence semanticsτrφ♮∈L→T: to each program control pointl∈Lcorresponds a piecewise-defined ranking functiont∈T, and for each program instruction stmt a sound abstract recurrence semantics transformerτrφ♮〚stmt〛∈T→Tis defined in Fig. 11. In particular, we modify the operatorRESET〚φ〛presented in the previous Section 8.2 in order to reset the value of a ranking function only when the ranking function is already defined within the pieces that satisfy a given property φ. As an example, unlike Fig. 9, the decision tree in Fig. 6c is unmodified by theRESET〚x=3〛operator.The starting point of the recurrence backward analysis is now the totally undefined function at the program final control pointf〚prog〛, since the program final states cannot satisfy a recurrence property. This function is then propagated backwards towards the program initial control pointi〚prog〛. In case of loops, a first increasing iteration with widening yields their abstract guarantee semantics, which is the starting point for the decreasing iteration with a new dual widening operator∇¯. The dual widening∇¯obeys:(i)x⊒x∇¯yandy⊒x∇¯y;for all decreasing sequencesX0⊒X1⊒⋯⊒Xn⊒⋯, the decreasing sequenceY0=defX0,Yn+1=defYn▿¯Xn+1stabilizes, that is,∃l≥0:∀j≥l:yj=yl.The analysis computes an over-approximation of the value of the φ-recurrence semanticsτrφand an under-approximation of its domain of definitiondom(τrφ). In this way, an abstraction provides sufficient preconditions for the recurrence property□⋄φ: if the abstraction is defined on a program state, then all the program traces branching from that state always reach a state with the property φ infinitely often, and the value of the function provides an upper bound on the number of execution steps before the next occurrence of a state with the property φ.Example 21In Fig. 13a, we depict the decision tree inferred for proving the recurrence property□⋄(x=3)at program control point1of the program SIMPLE of Fig. 1. The graphical representation of the ranking function is shown in Fig. 13b. Its domain yields the sufficient preconditionx<0for□⋄(x=3).

@&#CONCLUSIONS@&#
