@&#MAIN-TITLE@&#
A bi-intuitionistic modal logic: Foundations and automation

@&#HIGHLIGHTS@&#
We introduce a bi-intuitionistic tense logic with interrelated modalities.We have considerably extended our understanding of how the foundational structures and the bi-intuitionistic logic extend and generalize approaches to mathematical morphology.The logic is shown decidable and has the effective finite model property. Also, complexity and correspondence results are given.The second focus of the appear is automation of proof systems for the logic.We present a sound, complete and terminating tableau calculus for the logic.An experimental evaluation gave good results when using predecessor blocking.

@&#KEYPHRASES@&#
Intuitionistic logic,Modal logic,Tableau system,Decidability,Correspondence theorem,

@&#ABSTRACT@&#
The paper introduces a bi-intuitionistic modal logic, called BISKT, with two adjoint pairs of tense operators. The semantics of BISKT is defined using Kripke models in which the set of worlds carries a pre-order relation as well as an accessibility relation, and the two relations are linked by a stability condition. A special case of these models arises from graphs in which the worlds are interpreted as nodes and edges of graphs, and formulae represent subgraphs. The pre-order is the incidence structure of the graphs. We present a comprehensive study of the logic, giving decidability, complexity and correspondence results. We also show the logic has the effective finite model property. We present a sound, complete and terminating tableau calculus for the logic and use the MetTeL system to explore implementations of different versions of the calculus. An experimental evaluation gave good results for satisfiable problems using predecessor blocking.

@&#INTRODUCTION@&#
The paper introduces a bi-intuitionistic modal logic, called BISKT, with two adjoint pairs of tense operators. A special case of the semantics for this logic has Kripke models in which the worlds are interpreted as nodes and edges of graphs, and formulae represent subgraphs. In this context the accessibility relations are essentially ‘relations on graphs’. To motivate the logic and the structures which underlie its semantics, we start by reviewing the motivation for developing a theory of ‘relations on graphs’, which generalizes that of ‘relations on sets’. One novel feature of relations on graphs is a pair of adjoint converse operations instead of the involution found with relations on sets. One half of this pair (the ‘left converse’) plays an essential role later in defining the relational semantics of BISKT.Relations on sets underlie the most fundamental of the operations used in the body of techniques for image processing known as mathematical morphology [23,9]. UsingZ2to model a grid of pixels, binary (i.e., black and white) images are modelled by subsets ofZ2. One aim of processing images is to accentuate significant features and to lessen the visual impact of the less important aspects. Several basic transformations on images are parameterized by small patterns of pixels called structuring elements. These structuring elements generate relations, which transform subsets ofZ2via the correspondence between relationsR⊆Z2×Z2and union-preserving operations on the powersetP(Z2). Several fundamental properties of image processing operations can be derived using only properties of these relations.There have been various proposals for developing a version of mathematical morphology for graphs, one of the earliest being Heijmans and Vincent's [12]. One direction in more recent work is seen in [10]. However, most work in this area does not use a relational approach, probably because a theory of relations on graphs may be constructed in several different ways. In one way [24,25], the set of relations on a graph, or more generally a hypergraph, forms a generalization of a relation algebra where, in particular, the usual involutive converse operation becomes a pair of operations (the left converse and the right converse) forming an adjoint pair. In the present paper, we use these relations to give a semantics for a bi-intuitionistic modal logic in which propositions are interpreted over subgraphs as opposed to subsets of worlds as in standard Kripke semantics.Accessibility relations with additional structure are already well-known in intuitionistic modal logic [29]. However, the semantics for the logic we present is distinguished both from this work, and from existing related work we discuss in Section 8, by the use of the left-converse operation. This means the logic BISKT has novel features which include ◇ϕ being equivalent to⨼□¬ϕ, where ⨼ and ¬ are the two negations present in BISKT.Connections between mathematical morphology and modal logic have been developed by Aiello and Ottens [1], who implemented a hybrid modal logic for spatial reasoning, and by Aiello and van Benthem [2] who pointed out connections with linear logic. Bloch [8], also motivated by applications to spatial reasoning, exploited connections between relational semantics for modal logic and mathematical morphology. These approaches used morphology operations on sets, and one motivation for our own work is to extend these techniques to relations on graphs.In this paper, we focus on the logic itself, and the semantic setting we use is more general than that arising from relations on graphs or hypergraphs. We justify the applicability of the logic by explaining its role in developing the theory of mathematical morphology for graphs as a generalization of the set-based case.The main contribution of the paper is a bi-intuitionistic tense logic, called BISKT, for which a Kripke frame consists of a pre-order H interacting with an accessibility relation R via a stability condition.11The name BISKT is short for bi-intuitionistic stable Kt, where Kt is the common notation for the basic tense logic.The semantics interprets formulae as H-sets, the downward-closed subsets of the pre-order. A particular case arises when the worlds represent the edges and nodes of a graph and formulae are interpreted as subgraphs. We establish that BISKT is decidable and has the effective finite model property.The semantic setting for BISKT is a relational setting in which deduction calculi can be developed systematically. We follow the methodology of tableau calculus synthesis and refinement as introduced in [21,26] to develop a tableau calculus for the logic. We give soundness, completeness and termination results as consequences of results of tableau synthesis and the effective finite model property of BISKT.Implementing a prover is normally a time-consuming undertaking but MetTeL22http://www.mettel-prover.org.is software for automatically generating a tableau prover from a set of tableau rules given by the user [27]. For us, using MetTeL turned out to be useful because we could experiment with implementations of different versions of the calculus. In combination with the tableau synthesis method, it was easy to run tests on a growing collection of problems with different provers for several preliminary versions of formalizations of bi-intuitionistic tense logics before settling on the definition given in this paper. MetTeL has also allowed to us experiment with different refinements of the rules and different forms of blocking. Blocking is a technique for forcing termination of tableau calculi for decidable logics.The paper is structured as follows. Section 2 presents the basic notions of pre-orders and relations on downward-closed sets as well as on graphs. Relations on graphs occur naturally in mathematical morphology as demonstrated by an example in Section 2.5. Section 3 defines BISKT as a bi-intuitionistic stable tense logic with a semantics in which formulae are interpreted as downward-closed sets, which include subgraphs as a special case. Just as intuitionistic propositional logic can be embedded into the modal logic S4, BISKT can be embedded into a multi-modal logic with S4 modalities, which allows us to give decidability, complexity and correspondence results for BISKT. In Section 4, the applicability of the logic to mathematical morphology on graphs is considered. The need for automated deduction tools for BISKT in the exploration of the properties of morphology operations on graphs is explained. A systematic way of deriving correspondence results for BISKT is presented in Section 5 along with a demonstration that the frame condition corresponding to the Löb formula in the classical case also holds for BISKT. Frame conditions can be seen as properties of generalized structuring elements, so Section 5 is also a necessary foundation for the programme of using BISKT as a tool to develop mathematical morphology on graphs. In Section 6, we present a terminating labelled tableau calculus for BISKT. Results and findings of an evaluation of different presentations of the tableau calculus implemented using the tableau prover generator MetTeL are given in Section 7. Connections to other work are discussed in Section 8.Let U be a set with a subsetX⊆U, and letR⊆U×Ube a binary relation. Dilation and erosion are key operations used in mathematical morphology and, although we use a different notation, the following definition can be found in [15, p. 61]. The symbols ⊕ and ⊖ are standard but we depart from the practice of writing erosion in the orderX⊖Rin view of Lemma 1.Definition 1Dilation, ⊕, and erosion, ⊖, are operations with signaturesP(U)×P(U×U)⟶P(U)andP(U×U)×P(U)⟶P(U)respectively.X⊕R={u∈U:∃x((x,u)∈R∧x∈X)},R⊖X={u∈U:∀x((u,x)∈R→x∈X)}.For fixed R we obtain operations with signatureP(U)⟶P(U)which form an adjunction from the latticeP(U)to itself. The operation⊕Ris the left adjoint toR⊖in the following sense.Definition 2Let(X,⩽X),(Y,⩽Y)be partially ordered sets. An adjunction between X and Y consists of a pair of functionsf:X⟶Yandg:Y⟶Xsuch thatx⩽Xg(y)ifff(x)⩽Yyfor allx∈Xand ally∈Y. The function f is said to be left adjoint tog, and g is right adjoint tof.When f and g form an adjunction they are necessarily order-preserving. Erosion and dilation interact with composition of relations as follows.Lemma 1If R and S are any binary relations on U andX⊆U, then(S;R)⊖X=S⊖(R⊖X)andX⊕(R;S)=(X⊕R)⊕S.The operations ⊕ and ⊖ can be applied to subgraphs of a graph when relations on graphs are defined. We see how this works in Section 2.3, but first work in a more general setting of H-sets which we now define. Let U be a set and H a pre-order on U (i.e., a reflexive and transitive relation).Definition 3A subsetX⊆Uis an H-set ifX⊕H⊆X.Since H is reflexive, the condition is equivalent toX⊕H=X, and if we were to write H as ⩾ these would be downsets. It follows from the adjunction between dilation and erosion that X satisfiesX=X⊕Hiff it satisfiesX=H⊖X.The H-sets are closed under unions and intersections and form a distributive lattice which is a sub-lattice of the powerset lattice of U. The H-sets are not closed under complements but when A and B are H-sets, we can construct H-setsA→BandA᚜Bas in Definition 4 below. These operations give the structure of a bi-Heyting algebra to the lattice of H-sets. This means that the lattice is a Heyting algebra which is also Heyting algebra under the converse of the partial order in the lattice. We do not need a formal definition of a bi-Heyting algebra here, but the interested reader may find one in Stell [25] although the concept itself is much older and was already well-known to Reyes and Zolfaghari [17]. Heyting algebras are discussed in detail by Balbes and Dwinger [3].Definition 4Let A and B be H-sets. Then the following four H-sets are defined, where − denotes the complement of a subset of U. Note that −A and −B are not necessarily H-sets but merely subsets of U, however the expressions in which they appear below all do denote H-sets.A→B=H⊖(−A∪B)relative pseudocomplementA᚜B=(A∩−B)⊕Hdual relative pseudocomplement¬A=H⊖(−A)pseudocomplement⨼A=(−A)⊕Hdual pseudocomplementRelations on a set U can be identified with the union-preserving functions on the lattice of subsets. When U carries a pre-order H, the union-preserving functions on the lattice of H-sets correspond to relations on U which are stable:Definition 5A binary relation R on U is stable ifH;R;H⊆R.Stable relations are closed under composition, with H as the identity element for this operation, but they are not closed under converse. They do however support an adjoint pair of operations, the left and the right converse, denoted by ⤻ andrespectively.Definition 6The left converse of a stable relation R is⤻R=H;R˘;HwhereR˘is the (ordinary) converse of R.The stability of ⤻R is immediate since H is a pre-order, and the left converse can be characterized as the smallest stable relation which containsR˘. The right converse is characterized as the largest stable relation contained inR˘, but it plays no role in this paper, so we omit the explicit construction. Properties of these operations include⤻R⊆R⊆⤻Rfor any stable relation R, and further details can be found in [24,25].The connection between erosion, dilation, complementation and converse in the lemma below is well-known [9]. We need it to prove Theorem 4 below which generalizes the lemma to the case of a stable relation acting on an H-set.Lemma 2For any relation R on U and anyX⊆U,X⊕R˘=−(R⊖(−X)).We have introduced the operations ¬ and ⨼ on H-sets, and the operation ⤻ on stable relations. For the next result we need to talk about both these operations and the corresponding dual operations onH˘-sets and onH˘-stable relations. Since the operations ¬, ⨼, and ⤻ all depend on H, we need to introduce decorated versions of the symbols for these operations when we need a context in which both H andH˘are used simultaneously. These versions (d indicating dual) are defined as follows, although we only need them for the proof of Theorem 4.Definition 7Let A be anyH˘-set and let R be anyH˘-stable relation. We define the operations¬d,⨼dand⤻das follows.1.¬dA=H˘⊖(−A)⨼dA=(−A)⊕H˘⤻dR=H˘;R;H˘The following properties follow immediately from the definitions.Lemma 3Let A be an H-set and R be a stable relation. Then1.−¬A=⨼d−A−⨼A=¬d−A⤻dR˘=(⤻R)˘The following was proved in [24] for the special case of hypergraphs, but we give a direct proof of the general case as it underlies one of the novel features of the logic we consider.Theorem 4For any stable relation R and any H-set A,A⊕(⤻R)=⨼(R⊖(¬A))and(⤻R)⊖A=¬((⨼A)⊕R).For the first part we have this calculation.A⊕(⤻R)=A⊕(H;R˘;H)by definition of⤻=((A⊕H)⊕R˘)⊕Hby Lemma 1=(A⊕R˘)⊕HasAis anH-set=(−(R⊖(−A)))⊕Hby Lemma 2=⨼(R⊖(−A)))by definition of⨼=⨼((R;H)⊖(−A)))by stability ofR=⨼(R⊖(H⊖(−A)))by Lemma 1=⨼(R⊖(¬A))by definition of¬For the second part⤻dR˘⊖(−A)=−(A⊕⤻R)by Lemmas 2 and 3=−⨼(R⊖¬A)by the first part=¬d−(R⊖−⨼d−A)by Lemma 3=¬d(⨼d−A⊕R˘)by Lemma 2Hence for allH˘-sets B and allH˘-stable relations S,⤻dS⊖B=¬d(⨼dB⊕S)which is equivalent to the required result since this equation holds for allH˘˘-sets B and allH˘˘-stable relations S.  □A special case of the above constructions is when U is the set of all edges and nodes of a graph in the following sense.Definition 8A graph consists of disjoint sets E and N, called edges and nodes respectively, together with an incidence functionf:E⟶P(N)such that the cardinality off(e)is either 1 or 2 for every edge e.Graphs in this sense are sometimes called undirected multigraphs in which multiple loops are permitted. From such a graph we can obtain a set U by puttingU=E∪N. We can then define a pre-order H on U as follows.(u,v)∈Hiff{u∈Eandv∈Nandv∈f(u),oru=vIn this setting, the H-sets are exactly the subgraphs, that is, sets of nodes and edges which include the incident nodes of every edge in the set. The importance of the bi-Heyting algebra of subgraphs of a directed graph has been highlighted by Lawvere as explained in [17].We give an example for an undirected graph of the operations ¬ and ⨼ of Section 2.1 since these motivate the semantics for the two negations in our logic. Fig. 1shows various subgraphs of a graph where the subgraphs are distinguished by depicting the edges and nodes in bold. For a subgraph K, the operations ¬ and ⨼ yield respectively the largest subgraph disjoint from K and the smallest subgraph containing all the edges and nodes not present in K. In Fig. 1 it can be seen that neither¬¬Knor⨼⨼Kis equal to K. The subgraph¬¬Kconsists of K completed by the addition of any edges all of whose incident nodes are in K. The subgraph⨼⨼Kis K with the removal of any nodes that have incident edges none of which is present in K. The subgraph⨼¬Kcan be interpreted as the expansion of K to include things up to one edge away from K, and¬⨼Kis a kind of contraction, removing any nodes on the boundary of K and any edges incident on them.The stable relations on a graph can be visualized as in Fig. 2. The arrows used may have multiple heads and multiple tails; the meaning is that every node or edge at a tail is related to all the edges and nodes at the various heads. The stability condition implies that if a node, n, is related to something, u say, then every edge incident with n is also related to u. Stability also implies that if u, which may be an edge or a node, is related to an edge e, then u is also related to every node incident with e.The left converse operation is illustrated in Fig. 3showing that iterating this operation can lead to successively larger relations.Mathematical morphology provides practically useful image processing operations and in several cases these operations are generated by relations on the set of pixels as mentioned in the Introduction. Given a set U of pixels and a relationR⊆U×Uthe operations⊕RandR⊖take subsets of U to subsets of U. For a concrete example, imagine U to consist of all the pixels available on a particular screen. In a more abstract setting, we might take U to beZ2as in the examples in Figs. 4 and 5which we now discuss.A subset of U can be depicted by shaded pixels, as with the subset X shown in Fig. 5. It is usual to specify the relation R by means of a ‘structuring element’, although it should be noted that not all relations arise from structuring elements. A structuring element is, informally speaking, a pattern of pixels, such as the cross shaped structuring element shown in Fig. 4. A structuring element also includes identification of an origin, which is typically one of the pixels in the pattern. In the case of Fig. 4, choosing the origin as the central pixel induces a relation in which this central pixel is related to all the pixels in the pattern. In this example, this then leads to a relation on all the pixels in U in which each pixel is related to itself and to the four pixels sharing an edge with it.The operations of dilation and erosion defined in Definition 1 are illustrated in Fig. 5. Opening of the subset X can be defined as erosion followed by dilation, but can also be visualized as the largest subset of X which can be covered by (possibly overlapping) copies of the structuring element.Cousty et al. [10] show how to construct various morphological operators on subgraphs of a graph. These operators are shown to outperform (in a sense explained in [10]) operators based on relations on a set of pixels in certain cases. We now show how stable relations presented in this paper underlie these operators on subgraphs. To illustrate this, we consider one example: the operation which Cousty et al. [10] denoted by[δ,Δ]. This operation expands a subgraph by augmenting it with every edge and every node that shares respectively an incident node or an incident edge with an edge or a node present in the subgraph. The notation[δ,Δ]follows well-established conventions in mathematical morphology.Cousty et al. [10] describe the operation[δ,Δ]in terms of its action on sets of edges and on sets of nodes separately. We can, however, find a stable relation, R, such that dilation by R provides a graph-theoretic description of[δ,Δ]. This stable relation is defined byR=Q;⤻Q∪⤻Q;Qwhere Q is the stable relation expressing incidence as follows: A graph G with edges E and nodes N, has incidence relationQ⊆E×Nwhere a pair(e,n)belongs to Q if and only if the edge e is incident with the node n. Note that Q can be obtained from the relation H introduced earlier by removing all the reflexive loops from H.To illustrate the relation R, we consider the graph which is shown in Fig. 6. The nodes of the graph in this figure correspond to the pixels in Fig. 5 and the edges of the graph correspond to cases where pixels are 4-adjacent (sharing a 1-dimensional boundary). The graph in Fig. 6 hasZ2for its set of nodes. Subgraphs are indicated by drawing their nodes and edges in bold lines. Fig. 7shows how relation R can be visualized for the case of the graph in Fig. 6.Besides dilation by R, Fig. 6 also shows the result of erosion and opening by the same relation. Observe that there are pairs of adjacent nodes included in the opening but where the edge between them is not included. A set of pixels corresponds to a set of nodes in this example but does not determine a unique subgraph as different sets of edges between these nodes may be present. Subgraphs thus allow finer distinctions than mere sets of pixels, and this is one of the reasons why mathematical morphology on graphs can lead to better performing operations on images.The significance of stable relations for mathematical morphology on graphs is that they allow an essentially graph-theoretic account of the operations involved. This contrasts with the set-theoretic description in [10] where operations on subgraphs are constructed from operations on sets of nodes and on sets of edges separately. Having shown how stable relations arise in mathematical morphology on graphs, we next introduce the logic BISKT. The applicability of this logic to mathematical morphology is then justified in Section 4.We now propose a modal logic BISKT for which a Kripke frame is a pre-ordered set(U,H)together with a stable binary relation on U. Formulae of BISKT are interpreted as H-sets. A particular case is when the worlds (elements of U) are the edges and nodes of a graph. In this case a valuation assigns subgraphs to propositional variables and given such a valuation each formula is interpreted as a subgraph which can be thought of as the edges and nodes where the formula holds.Definition 9The language of BISKT consists of a set Vars of propositional variables:p,q,…, a constant: ⊥, unary connectives: ¬ and ⨼, binary connectives: ∧, ∨, →, ᚜, and unary modal operators: □, ⧫, ◇, and ■. The set Form of formulae is defined in the usual way.Definition 10An H-frameF=(U,H,R)is a pre-order(U,H)together with a stable binary relation R on U. A valuation on an H-frameFis a functionV:Vars⟶H-Set, whereH-Setis the set of all H-sets.A valuationVonFextends to a function〚〛V:Form⟶H-Setby setting〚p〛V=V(p), for any propositional variable p, and extending this to formulae as follows.〚⊥〛=∅〚⊤〛=U〚ϕ∨ψ〛=〚ϕ〛∪〚ψ〛〚ϕ∧ψ〛=〚ϕ〛∩〚ψ〛〚¬ϕ〛=H⊖(−〚ϕ〛)〚⨼ϕ〛=(−〚ϕ〛)⊕H〚ϕ→ψ〛=H⊖((−〚ϕ〛)∪〚ψ〛)〚ϕ᚜ψ〛=(〚ϕ〛∩(−〚ψ〛))⊕H〚□ϕ〛=R⊖〚ϕ〛〚◇ϕ〛=〚ϕ〛⊕(⤻R)〚⧫ϕ〛=〚ϕ〛⊕R〚■ϕ〛=(⤻R)⊖〚ϕ〛Usually the valuation is clear from the context and we often write〚〛instead of〚〛V.Definition 11Given a frameF, a valuationVonFand a worldw∈Uwe define ⊩ byF,V,w⊩ϕiffw∈〚ϕ〛V.WhenF,V,w⊩ϕholds for allw∈Uwe writeF,V⊩ϕ, and whenF,V⊩ϕholds for all valuationsVwe writeF⊩ϕ.In the special case that H is the identity relation on U, stability places no restriction on R and ⤻R is just the ordinary converse of R. The semantics is then equivalent to the usual relational semantics for tense logic when time is not assumed to have any specific properties.Fig. 8illustrates how the semantics of ◇ and ■ are interpreted on subgraphs. In the figure, R is denoted by the broken lines and H is determined by the graph. The H-sets are shown in bold.We can give a temporal interpretation to the example by taking the nodes to be time points, the edges to be open intervals, and R to relate each open interval to all instants that either end the interval or end some later interval. The times when ◇p holds are then the open intervals for which p holds at some later instant, together with both endpoints of those intervals. The times when ■q holds are all the closed intervals where q holds at all times and has always held.Lemma 5The formulae listed inTables 1, 2, 3, and 4, together with the implications between formulae in the diagrams inFigs. 9 and 10are all valid in BISKT.An alternative semantics, decidability and complexity results for BISKT can be obtained by embedding the logic into the tense logicKt(H,R).Kt(H,R)is a traditional propositional modal logic defined over two accessibility relations H and R and their converse relations. In [19] it is shown that:Theorem 6(See[19].)Kt(H,R)is decidable and has the effective finite model property, that is, there is an effective function μ such that every satisfiable formula ϕ has a finite model bounded in size byμ(ϕ). Moreover, satisfiability inKt(H,R)is PSPACE-complete.These results carry over to BISKT via an embedding of BISKT intoKt(H,R)(as an extension of the standard embedding of intuitionistic propositional logic into the modal logic S4). This allows us to conclude:Theorem 7BISKT has the effective finite model property and is decidable. Moreover, satisfiability in BISKT is PSPACE-complete.A formula containing a single propositional variable can be understood as an operation on subgraphs. For example, the formula ⧫p can be understood as the operation which for any subgraph〚p〛returns the subgraph〚⧫p〛for the appropriate valuation. Table 5lists some principal operations and is immediately established from definitions. In the case of set-based morphology operations generated by a structuring element, the converse versions in the table correspond to working with the structuring element rotated by 180°.Mathematical morphology on graphs is still relatively unexplored compared with the extensive research for the set-based case. One of the reasons that such exploration can be expected to be challenging is that concepts which are familiar for set-based mathematical morphology can have several different counterparts for graphs. This is particularly true of operators defined using the Boolean complement of a set of pixels. Such operators may generalize to more than one morphological operator on graphs since occurrences of the complement can be replaced by the pseudocomplement or by its dual. We illustrate this situation by some examples.Relationships between morphological operations can correspond to the validity of formulae in BISKT. Simple examples of this are the relationships between erosion and converse dilation and between converse erosion and dilation (which follow from Theorem 4):(3)◊p↔⨼□¬pand■p↔¬⧫⨼p.Although the white diamond can thus be defined in terms of the white box in BISKT, there does not appear to be any simple valid formula which allows the definition of white box in terms of white diamond. Similarly we can define black box in terms of black diamond but there does not appear to be any way to define the black diamond in terms of the black box. It is certainly the case that formulae such as¬◊⨼pand⨼■¬p, which in the classical Boolean case would be equivalent to □p and ⧫p respectively, are not equivalent to these in BISKT. The same is true for these formulae if ¬ is substituted for ⨼, or vice versa, or if both of these substitutions are made. The fact that formulae such as¬◊⨼p↔□pare not valid in BISKT shows that the relationship of erosion to converse dilation for mathematical morphology on graphs is considerably more subtle than in the set-based case.The two equivalences in (3) above can be used to derive the generalization of a well-known result in set-based mathematical morphology. The result provides a description of closing by a structuring element in terms of opening by the rotated structuring element and complementation. In detail, the closing can be achieved by opening the complement of the image with the rotated structuring element and then taking the complement of the result. This provides a useful way of visualizing closing as what remains of a set of pixels after copies of the rotated structuring element are fitted around the outside of the image. In the case of mathematical morphology on graphs the closing is expressible in a more complex way:(4)◊■p↔⨼□¬¬⧫⨼p.The examples of valid BISKT formulae (3) and (4) above are relatively simple and can readily be derived by hand. However the exploration of the properties of other morphological operations on graphs will be more complex and the support of automated deduction tools based on the tableau calculus presented later in the paper will be needed to carry out calculations. This can be expected to be the case in particular for the theory of self-dual operators [13]. For morphological operations on sets of pixels, binary (that is black and white) images consist of two complementary subsets: the foreground and the background. As [13, p. 15] makes clear, operators that act in the same way on the foreground and on the background are important in image processing. If U is a set and φ is a function taking subsets of U to subsets of U, then φ is defined to be self-dual ifφ(X)=−(φ(−X))for allX⊆Uwhere − denotes the complement.For graphs, the two kinds of complement and the four possible combinations of two of these as discussed in Section 2.3, together with the identity, provide seven distinct operations on subgraphs compared with just two for the corresponding Boolean case. Alternating sequences of the pseudocomplement and its dual provide yet further distinct operations on graphs. There are thus several different possible notions of self-duality for morphological operators on graphs. The two weaker forms of complement and their combinations all correspond to meaningful operations on subgraphs, and therefore provide more than one notion of self-duality. To explore all these many possibilities and properties of morphological operators, it would clearly be of value to have a tool which automatically establishes the validity or otherwise of BISKT formulae. The machinery for building such a tool is developed later in this paper.In the next section, we consider correspondence theory for the logic. The frame conditions appearing in the correspondence theory are conditions on the relations which, in mathematical morphology, are generalized structuring elements, as explained in Sections 2.4 and 2.5. Some of the results in papers such as [13] depend on properties of the structuring elements used to define morphological operations. Correspondence results provide counterparts in the logic for generalizations of these properties defined on graphs.In this section we derive a number of correspondence results. First we present a method that allows us, for first-order frame conditions in a particular form, to derive correspondence results in BISKT automatically. Later, we examine the case of a frame condition that has no first-order equivalent in Section 5.2 where we show that the Löb formula in BISKT corresponds to the same frame condition as in the classical case.A number of frame conditions can be expressed as inclusions between relations. For example, the condition that R is reflexive can be expressed as the identity relation being included in R. Frame conditions expressible as inclusions have modal correspondents in BISKT that can be obtained in a systematic way and which depend essentially on little more than basic properties of adjunctions. The list of these BISKT correspondents presented in Table 6includes the well-known classical correspondents in the case of H being the equality relation on U.Stable relations correspond exactly to join-preserving functions on the lattice of H-sets. The set of stable relations is best understood as having the algebraic structure of a quantale [18], for a precise statement of this result see [25, Thm. 6, p. 445]. In some more detail, this correspondence is an isomorphism between (a) the quantale of stable relations under relation composition with the usual unions of relations as joins and (b) the quantale of join-preserving functions under function composition with the usual unions of set-valued functions. The isomorphism assigns the function⊕Rto the stable relation R. The key feature of the isomorphism that we need is the following lemma.Lemma 8LetS1,S2be any stable relations. Then the following are equivalent1.S1⊆S2For every H-set X,X⊕S1⊆X⊕S2For every H-set X,S2⊖X⊆S1⊖XIt follows from Lemma 8 that for any H-set, X, the statementsX=UandH⊖X=Uare equivalent. Combining this with the semantic definitions in Section 3, we establish Lemma 9.Lemma 9Letϕ,ψbe any BISKT formulae andVany valuation. ThenF,V⊩ϕ→ψiff〚ϕ〛V⊆〚ψ〛V.Theorem 10LetSi∈{R,⤻R}fori=1,…,mand for each i letBi={□ifSi=R■ifSi=⤻Rand letDi={⧫ifSi=R◊ifSi=⤻R.Let0⩽k⩽mand let ; be relational composition. Then the following are equivalent.1.S1;⋯;Sk⊆Sk+1;⋯;SmF⊩Dk⋯D1p→Dm⋯Dk+1pF⊩Bk+1⋯Bmp→B1⋯BkpThe equivalence of parts 1 and 2 is established as follows and similarly for parts 1 and 3.S1;⋯;Sk⊆Sk+1;⋯;SmiffFor everyH-set,X,X⊕(S1;⋯;Sk)⊆X⊕(Sk+1;⋯;Sm)iffFor everyH-set,X,iff(⋯((X⊕S1)⊕S2)⊕⋯)⊕Sk⊆(⋯((X⊕Sk+1)⊕Sk+2)⊕⋯)⊕SmiffFor every valuation,V,〚Dk⋯D1p〛V⊆〚Dm⋯Dk+1p〛ViffF⊩Dk⋯D1p→Dm⋯Dk+1p□Note that Theorem 10 includes the cases when one side of the inclusion is the identity for composition of stable relations. These cases arise from the extremesk=0andk=mwhich yieldH⊆S1;⋯;SmandS1;⋯;Sm⊆Hrespectively. The theorem allows us to obtain modal correspondents for the frame conditions listed in Table 6. These correspondents will contain only diamonds or only boxes. To obtain the correspondents appearing in the final column of the table which include both diamonds and boxes but where they are all of the same colour we need to use the basic principles for manipulating frame equivalences given in the next two results, together with the fact that the following are all valid in BISKT.⧫□p→pp→□⧫p◊■p→pp→■◊pLemma 111.F⊩ϕ→ψF⊩Mϕ→MψwhereM∈{□,◊,■,⧫}.Lemma 121.⊩ϕF⊩ϕF⊩ϕF⊩σ(ϕ)where σ is any substitution of BISKT formulae for propositional variables.F⊩ϕ→ψF⊩ψ→θF⊩ϕ→θF⊩⧫◊p→◊⧫p⇒F⊩◊p→□◊⧫p⇒F⊩◊□p→□◊⧫□p⇒F⊩◊□p→□◊psince⊩⧫□p→pF⊩◊□p→□◊p⇒F⊩⧫◊□p→◊p⇒F⊩⧫◊□⧫p→◊⧫p⇒F⊩⧫◊p→◊⧫psince⊩p→□⧫pFor an arbitrary relation (not necessarily stable)R⊆U×U, the reflexivity of R is equivalent toI⊆Rwhere I is the identity relation on U. Now I need not be stable, and the identity for composition of stable relations is the stable relation H. Thus it would be natural to define a stable relation R to be reflexive whenH⊆R. The following result shows that reflexivity in this sense is exactly the same as ordinary reflexivity.Lemma 13Let R be a stable relation. ThenH⊆RiffI⊆R.One direction needs onlyI⊆H. The other direction needs the observation that H is the least stable relation containing I.  □We can include the frame condition that R is the empty relation, which we denote by 0. The modal correspondent forR⊆0does not fit the conditions of Theorem 10, but using Lemma 8 and the facts that for any H-set X,0⊖X=UandX⊕0=∅we can argue as follows.R⊆0iff∀X∈H-setX⊕R⊆X⊕0iff∀X∈H-setX⊕R⊆∅iffF⊩⧫p→⊥iffF⊩¬⧫pSimilar arguments establish the other cases in this table.DiamondsBoxesR trivialR⊆0¬⧫p□p⤻R trivial⤻R⊆0¬◊p■pHowever, R is trivial iff ⤻R is trivial, so the four formulae above are all frame equivalent.Although the condition that R is the universal relation is expressible asU×U⊆R, it is known that we cannot express this in any modal formula.Classically this formula characterizes the frames where R is transitive and where there are no infinite sequences in the direction of R like this:w0⟶Rw1⟶Rw2⟶Rw3⟶R⋯Blackburn et al. [7] state, p. 186, that the proof of this was first given by van Benthem. The argument given [7, p. 130] can be adapted to the more general case of BISKT, except for the part where the classically equivalent◊p→◊(p∧−◊p)formula is used. Since the Löb formula is not equivalent to any first order condition on frames it cannot be handled by Theorem 10. We give an explicit proof here.Theorem 14F⊩□(□p→p)→□piff R is transitive and has no infinite forward chains.ProofFirst we show that if R is transitive and has no infinite forward chains thenF⊩□(□p→p)→□p. Suppose there is some valuation such that□(□p→p)→□pdoes not hold at w. There must bew0wherewHw0andw0∈〚□(□p→p)〛butw0∉〚□p〛. So there isw1wherew0Rw1andw1∉〚p〛. In addition,w1∈〚□p→p〛holds, which implies that for every H-successor ofw1if p does not hold then □p cannot hold there either. Butw1is an H-successor ofw1, so we getw1∉〚□p〛. Hence there must bew2wherew1Rw2andw2∉〚p〛and wherew2∈〚□p→p〛since by transitivityw2is an R-successor ofw0. We can repeat this argument to constructw3which is an R-successor ofw2and so on to produce an infinite forward chain.To establish the converse, we consider the two cases where (1) R is not transitive and (2) where R is transitive but has an infinite forward chain. In each case we show thatF⊩□(□p→p)→□pdoes not hold. If R is not transitive there existx,y,zwhere xRy and yRz but not xRz. Consider a valuation where〚p〛=H⊖(U∖{y,z}). Thenw∈〚p〛iff no H-successor of w lies in{y,z}, so we havex∉〚□p〛andy∉〚p〛. The next step is to show that□(□p→p)holds at x, so suppose that w is any R-successor of x. To establish thatw∈H⊖(−〚□p〛∪〚p〛), letw′be any H-successor of w. Ifw′∉〚p〛thenw′Hysincew′Hzwould imply xRz. But this givesw′∉〚□p〛sincew′Rzbecausew′HyRz. Hencew∈〚□p→p〛andx∈〚□(□p→p)〛. But asx∉〚□p〛we getx∉〚□(□p→p)→□p〛.Finally we deal with the case where R is transitive but does have an infinite forward chain. Consider a valuation where〚p〛=U∖{u∈U|there is an infinite chain starting atu}.This does make〚p〛an H-set since if u is not the starting point of an infinite R chain then no H-successor of u can be the starting point of an infinite R chain. With this valuation,□p→pholds everywhere because if w is any world with an H successorw′, then if an infinite chain starts atw′an infinite chain must start at some R successor ofw′. Letw0be the starting point of an infinite chain. We then have□p→pholds atw0but □p does not hold, and hence□(□p→p)→□pdoes not hold atw0.  □In the context of graphs, a graph consisting only of nodes and not having any edges corresponds to H being the identity relation on U. For applications to mathematical morphology this is the case of sets of pixels rather than graphs.The logic cannot distinguish between H being an equivalence relation and actually being the identity as there is no way to refer to individual elements of U. However, when H is an equivalence relation the H-sets are exactly the unions of equivalence classes, so taking the quotient of U by H and replacing H by the identity will lose no information.Lemma 15F⊩⨼p→¬pholds if and only if H is an equivalence relation.F⊩⨼p→¬pholds if and only if for every valuationVwe have−〚p〛V⊕H⊆H⊖−〚p〛V. Now we claim that for any subsetX⊆Uwe haveX⊕H⊆H⊖Xif and only if X is an H-set. The proof of the claim follows fromY⊕H⊆Xif and only ifY⊆H⊖Xby substituting X for Y in one direction andX⊕Hfor Y in the other. HenceF⊩⨼p→¬pif and only if the complement of an H-set is always an H-set. So we need to show that this condition on H-sets is equivalent to H being an equivalence relation. When H is an equivalence relation, the H-sets are unions of equivalence classes so the condition is satisfied. Conversely, suppose the condition holds and that(u,v)∈Hand(v,u)∉H. Then{v}⊕His an H-set not containing u. Thus u belongs to the H-set−({v}⊕H), but, since(u,v)∈H, any H-set containing u contains v so we get the contradiction thatv∈−({v}⊕H). Hence H is symmetric so must be an equivalence relation as it is a pre-order.  □Because the accessibility relations in the Kripke models of BISKT involve converse relations it is natural to use a semantic tableau method as a deduction method. Semantic tableau methods do not place any limitations on how the proof search can be performed. We use a labelled tableau approach, as this ensures proof confluence, which means that from any point in the search space a proof (that is, a closed tableau) can be constructed for unsatisfiable problems. This means, any (fair) order of rule applications will lead to the construction of a closed tableau in which each branch is closed. This avoids expensive (don't know) non-determinism in the proof search. Because unlabelled tableau calculi are not generally proof confluent, backtracking over the search space may be needed when no suitable rule application strategy is available to avoid this. Confluent proof calculi provide more flexibility in defining search heuristics in an implementation. An additional advantage of labelled tableau calculi is that they can be generated automatically using the framework of Schmidt and Tishkovsky [21]. Moreover, labelled tableau calculi return concrete models for satisfiable formulae and are therefore well-suited for model generation and error diagnosis.We present a tableau calculus for BISKT as a labelled signed calculus, following a standard approach for tableau calculi for intuitionistic logics. Formulae in the calculus have one of these forms:⊥s:SϕH(s,t)R(s,t)s≈ts≉tS denotes a sign (either T or F for true or false), s and t represent worlds in the models constructed by the calculus, and ≈ is the equality symbol. Technically, s and t denote terms in the term algebra freely generated from a finite set of constants and a finite set of unary function symbolsfθ,gθ′,gθ′′, which are uniquely associated with subformulae of the input set. Specifically, thefθare associated with subformulae involving quantification in their semantic definition (i.e., ¬ϕ, ⨼ϕ,ϕ→ψ,ϕ᚜ψ, □ϕ, ⧫ϕ, ◇ϕ, ■ϕ), and for each subformulaθ′of the form ◇ϕ or ■ϕ there is a unique function symbolsgθ′andgθ′′. These symbols are Skolem functions and provide a convenient technical device to generate witnesses for formulae of existential import and storing dependency information.The semantics of tableau formulae is defined by extended Kripke models. An extended Kripke model is a structure(M,ι), whereM=(F,V)is a Kripke model as defined in Section 3 (Fdenotes a BISKT-frame andVa valuation function) and ι is an assignment mapping terms in the tableau language to worlds in U. Satisfiability of tableau formulae is defined by:M,ι⊮⊥M,ι⊩s:Tϕiffι(s)∈〚ϕ〛M,ι⊩s:Fϕiffι(s)∉〚ϕ〛M,ι⊩H(s,t)iff(ι(s),ι(t))∈HM,ι⊩R(s,t)iff(ι(s),ι(t))∈RM,ι⊩s≈tiffι(s)=ι(t)M,ι⊩s≉tiffι(s)≠ι(t)LetTabBISKTbe the calculus consisting of the rules given in Fig. 11. The rules are to be applied top–down. Starting with a set of tableau formulae the rules are used to decompose formulae in a goal-directed way. Since some of the rules are branching, the inference process constructs a tree derivation. As soon as a contradiction is derived in a branch (that is, when ⊥ has been derived) the branch is regarded as closed and no more rules are applied to it. If a branch is not closed then it is open. When, in an open branch, no more rules are applicable then the derivation can stop because a model for the input set can be read off from the branch. Then the branch is said to be fully-expanded. We say a tableau derivation is fully-expanded, if all branches are either closed, or open and fully-expanded.The way to use the tableau calculus is as follows. Suppose we are interested in the validity of a formula ϕ in BISKT. Then the input to the tableau derivation is the set{a:Fϕ}where a is a constant representing the initial world, and the aim is to find a counter-model for ϕ. If a counter-model is found then ϕ is not valid, on the other hand, if a closed tableau is constructed then ϕ is valid.The first group of rules in the calculus consists of the closure rule and the decomposition rules of the intuitionistic operators. The main closure rule derives ⊥ when, for a formula ϕ, boths:Tϕands:Fϕoccur on the current branch. The branch is then closed. The other rules can be thought of as ‘decomposing’ labelled formulae and building an ever growing tree derivation. These inference steps basically follow the semantics of the main logical operator of the formula being decomposed. For example, the rule for positive occurrences of implication extends the current branch witht:Fϕandt:Tψthereby creating two branches, if formulae of the forms:Tϕ→ψandH(s,t)belong to the current branch. The rule for negative occurrences of implication extends the current branch with the three formulaeH(s,fϕ→ψ(s)),fϕ→ψ(s):Tϕandfϕ→ψ(s):Fψ, if the formulas:Fϕ→ψoccurs on the current branch. The effect is that an H-successor world is created for s and ψ is assigned false in this successor, while ϕ is assigned true.The rules for the □ and ⧫ operators are signed versions of the standard rules for tense modalities in semantic tableaux for traditional modal logics. The rules for the ◇ and ■ operators are more complicated versions, as they refer to the composite relationH;R˘;Hand its converse.The third group of rules ensures the models constructed have the required properties. For example, the (refl)-rule ensures all terms (representing worlds) are reflexive in a fully-expanded branch, and the (tr)-rule ensures the H-relation is transitively closed. The rule (mon) accommodates the property that the truth sets form downsets. It is justified since we can show monotonicity for any formula of the logic. The rule (stab) ensures the relation R is stable with respect to H in any generated model.The rules have been systematically derived from the definition of the semantics of BISKT as given in Section 3. We first expressed the semantics in first-order logic and then converted the formulae to inference rules following the tableau synthesis method described in [21]. The subset of the rules in the calculusTabBISKTrestricted to the operators and frame conditions relevant to intuitionistic logic coincides with the tableau calculus derived there for intuitionistic logic. We note for the rule refinement step in the synthesis process, atomic rule refinement as introduced in [26] is sufficient. Atomic rule refinement is a specialization of a general rule refinement technique described in [21] with the advantage that it preserves soundness and completeness and is automatic.Theorem 16(i) The tableau calculusTabBISKTis sound, that is, for a satisfiable set of tableau formulae any fully-expanded tableau derivation has an open fully-expanded branch. (ii)TabBISKTis also (refutationally) complete, that is, for any unsatisfiable set of tableau formulae there is a closed tableau derivation. Moreover, (iii) the calculus is constructively complete with respect to the semantics of BISKT, which means that for every open fully-expanded branch a model exists that can be read off from the branch.This follows by the results of the tableau synthesis framework and atomic rule refinement [21,26], as we can show the semantics of BISKT defined in Section 3 is well-defined in the sense of [21].Enhancing the calculus with the unrestricted blocking mechanism provides an easy way to achieve termination. Compared to other blocking techniques, unrestricted blocking imposes no restrictions and is generic, consequently, it is independent of any logic and can even be used for undecidable logics. Unrestricted blocking has the property that adding it to a sound and complete semantic tableau calculus guarantees termination, provided the logic has the finite model property [20–22].The main ingredient of the unrestricted blocking mechanism is the following rule.Unrestricted blocking rule:(ub)s≈t|s≉tSince this involves equality ≈, provision needs to be made for equality reasoning. This can be achieved, for example, via the inclusion of these paramodulation rules.s≉s⊥s≈tt≈ss≈t,G[s]λG[λ/t]Here, G denotes any tableau formula. The notationG[s]λmeans that s occurs as a subterm at position λ in G, andG[λ/t]denotes the formula obtained by replacing s at position λ with t. In MetTeL equality reasoning is provided in the form of ordered rewriting which is more efficient [27].Unrestricted blocking systematically merges terms (sets them to be equal) in order to find small models if they exists. The intuition of the (ub)-rule is that merging two terms s and t either leads to a model, or it does not, in which case s and t cannot be equal. In order that small models are found, it is crucial that blocking is performed exhaustively before the application of any witness-creating rules. The witness-creating rules are the rules expanding formulae with implicit existential quantification. In our implementation using MetTeL, the (ub)-rule has been given higher priority than all the rules creating new Skolem terms.ByTabBISKT(ub)we denote the extension of the calculusTabBISKTby the unrestricted blocking mechanism, including some form of reasoning with equality ≈.Since we proved that BISKT has the effective finite model property (Theorem 7), by the results in [20], the tableau calculusTabBISKT(ub)is terminating (that is, any fully-expanded tableau derivation has a finite open branch if the input set is satisfiable). It therefore provides the basis for a decision procedure for BISKT.Theorem 17The tableau calculusTabBISKT(ub)is sound, (constructively) complete and terminating for BISKT.There are various non-trivial and time-consuming obstacles to overcome when implementing a prover from scratch. With the availability of MetTeL, a tool for automatically generating tableau provers, implementing a tableau calculus has become straightforward [27]. The idea is that the user specifies a set of tableau rules as input to the system and it then produces code of a prover for this calculus. An input file with a specification of the rules and the logic is needed. Because MetTeL makes no assumptions about the formal language, both the language of the calculus and the logic itself need to be specified. Any language specifiable in a quantifier-free first-order language with multiple sorts and equality can be defined. Equality is the only interpreted constructor in the MetTeL specification language. It triggers the use of ordered rewriting in the generated provers.We chose to assign priorities to the rules in order to influence the order in which they are applied. It turned out to be crucial to give lowest priority to the witness-creating rules (the rules for negative negations and implications, positive dual negations and dual implications, and positive diamonds) followed by the blocking rules, so that the creation of new terms and blocking is delayed as much as possible while still ensuring blocking is applied exhaustively before the witness-creating rules, so that termination is not jeopardized. Closure rules have been given highest priority, followed by one premise non-branching rules, two or more premise non-branching rules, and one premise branching rules. It is beneficial to delay the application of the reflexivity rule though.Quick tests of whether properties we expected to hold are provable turned out to be tremendously helpful. We were able to experiment with several initial versions of the calculus. In combination with the tableau synthesis method, it was easy to experiment with different tableau provers for several preliminary versions of formalizations of bi-intuitionistic tense logics before settling on the definition of BISKT.MetTeL allowed us to experiment with different variations of the rules, different rule refinements and alternative forms of blocking. The calculusTabBISKT, as defined in the previous section, includes thisGeneral monotonicity rule:(mon)s:Tϕ,H(s,t)t:Tϕbut theAtomic monotonicity rule:(at-mon)s:Tp,H(s,t)t:Tpis sufficient for completeness. The second rule is a refinement of the first rule as it applies the first rule only to propositional formulae.A natural variation of the (ub) blocking rule is given by these two rules.Predecessor blocking rules:H(s,t)s≈t|s≉tR(s,t)s≈t|s≉tWhereas the (ub)-rule blocks any two distinct terms, these rules restrict blocking to terms connected directly by the H and R relations. Because the calculusTabBISKTwithout blocking is sound and complete and both rules are sound, basing blocking on these rules instead of the (ub)-rule preserves soundness and completeness.The rules implement a form of predecessor blocking, which is known to give decision procedures for basic multi-modal logics with reflexive and transitive modalities. It is however open whether it provides a decision procedure for BISKT. The presence of converse operators in the logic makes it likely that it is not sufficient to guarantee termination, because for modal and description logics with converse operations dynamic blocking is required [14]. In the performance evaluation, better results were however obtained with these predecessor blocking rules than with unrestricted blocking.An experimental evaluation was performed with 105 problems on a Linux laptop with a 2.53 GHz Intel Core i5 (M 540) CPU and 8 GB of main memory. The problems included the validities given in Lemma 5, and were created during the investigations for testing purposes: for testing the properties of the operators, for testing the definition of the logic, as well as for testing the specification in MetTeL. As a consequence, the problems were mostly of modest size. The timeout for individual experimental runs with the generated provers was 200 seconds.The evaluation gave the performance results shown in Table 7. The first column of graphs is the runtime results for the calculusTabBISKTwith predecessor blocking and the general monotonicity rule (mon); the second column is the results for the calculus with predecessor blocking and the atomic monotonicity rule (at-mon); and the third column is the results for the calculus without blocking. The first row gives the results for all problems including problems where a timeout occurred (which were recorded as the maximum time allowed). The second and third rows give respectively the results for satisfiable problems and unsatisfiable problems that were solved within the timeout. Problems with a timeout are not included in these two rows.For the prover based onTabBISKTwith predecessor blocking and general monotonicity (first column), two problems timed out (both with unknown status); with atomic monotonicity (second column), three problems timed out (two with unknown status, one unsatisfiable problem); and for the prover based onTabBISKTwithout blocking (third column), 15 problems timed out (11 satisfiable problems, two unsatisfiable problems, two with unknown status).The results for the versions with unrestricted blocking were significantly worse than those in these graphs.Although the problem sample was small, the following findings can be drawn from the results. The best results were obtained for systems with predecessor blocking and either the general monotonicity rule or the atomic monotonicity rule. The difference between these was negligible, even though, for atomic monotonicity, there seemed to be a small speed-up, as the spikes seem generally less long in the middle column of Table 7 than the first column. With general monotonicity, however, one difficult problem was solved that was not solved with atomic monotonicity.It is not surprising that when no blocking is used fewer satisfiable problems are solved.For unsatisfiable problems similar numbers of problems were solved but generally lower spikes can be observed. For unsatisfiable problems, no blocking rules are needed, because the calculusTabBISKTis complete and constructs a closed tableau even without blocking. Applying blocking is an extra overhead and this explains the better performance. It seems consequently counter-intuitive that not all unsatisfiable problems were solved without blocking. Similar observations were made in experiments with bottom-up model generation methods in a separate study by [5], which uses a similar style of tableau-based deduction and blocking. There it was found that too eager creation of Skolem terms can have a negative impact. This may be a pointer that, with a different selection of formulae for application of the witness-creating rules, better performance could have been obtained. The investigation in Baumgartner and Schmidt [5], and also [19], found however that, for unsatisfiable problems, it is better to use a resolution-based approach.This reiterates that semantic tableau approaches are well suited for testing satisfiability and constructing models, but for testing unsatisfiability there may be better approaches.The website http://staff.cs.manchester.ac.uk/~schmidt/publications/biskt13/, created to accompany this paper, gives MetTeL specifications of tableau calculi for BISKT, instructions how to generate the provers, the problem collection, and the performance results.Propositional bi-intuitionistic logic was studied by Rauszer [16] who referred to it as Heyting–Brouwer (H–B) logic. The co-intuitionistic fragment of H–B logic is one of the propositional paraconsistent logics investigated by Wansing [28], but neither of these papers is concerned with bi-intuitionistic modal logics. The stable relations we use here are already well-known in intuitionistic modal logic [29, p. 219] and they provide a special case of the category-theoretic notion of a distributor [6]. However, as far as we are aware, the left converse operation that we use has not featured in either of these contexts.Reyes and Zolfaghari [17] present modal operators with semantics in bi-Heyting algebras. Graphs are an important example, as in our work, but the modalities are quite different, arising from iterating alternations of ¬ and ⨼.Goré et al. [11] studied a bi-intuitionistic modal logic, BiKt, with the same language as BISKT but with a semantics producing no relationship between the box and diamond operators. The four modal operators form two residuated pairs(□,⧫)and(■,◇)but without any necessary relationship between □ and ◇ or between ■ and ⧫. In our case, the same pairs are residuated (or adjoint) but we have a different semantics for the(■,◇)pair, and consequently there are relationships between □ and ◇ and between ■ and ⧫.We next describe the semantics for BiKt [11, p. 26], using our notation and terminology to clarify the connection with BISKT.Definition 12A BiKt Frame,(U,H,R,S), consists of a set U, a relation H on U which is reflexive and transitive, and two relations R and S on U that satisfyR;H⊆H;RandH˘;S⊆S;H˘.The conditionR;H⊆H;Ris strictly more general thanR=H;R;H. For example, ifU={a,b}andH={(a,a),(a,b),(b,b)}then taking R to be{(b,a),(b,b)}we find thatR;H⊆H;Rholds but notR=H;R;H. However, we see shortly that this additional generality is not essential. The semantics interprets formulae by H-sets and the modalities are defined as follows.〚◇ϕ〛=〚ϕ〛⊕S˘〚□ϕ〛=(H;R)⊖〚ϕ〛〚⧫ϕ〛=〚ϕ〛⊕R〚■ϕ〛=(H;S˘)⊖〚ϕ〛Since〚ϕ〛is an H-set,〚ϕ〛⊕S˘=〚ϕ〛⊕(H;S˘)and〚ϕ〛⊕R=〚ϕ〛⊕(H;R). Thus the only accessibility relations needed in the semantics areR′=H;RandS′=H;S˘. The following lemma shows that the constraints on R and S are equivalent toR′andS′being stable with respect to H.Lemma 18Let U be any set, let H be any pre-order on U, and let S be any binary relation on U. Then the following are equivalent.1.S=H;S;H.There is some relationR⊆U×Usuch thatS=H;RandR;H⊆H;R.Thus we can rephrase the semantics in [11] (p. 26) as1.A frame〈U,H,R′,S′〉consists of a set U, a pre-order H on U, and two stable relationsR′andS′on U. A valuation assigns an H-set to each propositional variable, and the connectives are interpreted as for BISKT.The semantics of the modal operators is:〚◇ϕ〛=〚ϕ〛⊕S′〚□ϕ〛=R′⊖〚ϕ〛〚⧫ϕ〛=〚ϕ〛⊕R′〚■ϕ〛=S′⊖〚ϕ〛

@&#CONCLUSIONS@&#
