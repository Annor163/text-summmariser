@&#MAIN-TITLE@&#
Distributed synthesis is simply undecidable

@&#HIGHLIGHTS@&#
Distributed synthesis in the classical setting (synchronous, Pnueli–Rosner) is undecidable for very weak languages.The safety fragment of the intersection of LTL and ACTL is enough.The reachability fragment of the intersection of LTL and ACTL is enough.The set of architectures, for which synthesis is decidable, is not effected by these language restrictions.

@&#KEYPHRASES@&#
Formal methods,Distributed synthesis,Undecidability,Temporal logic,

@&#ABSTRACT@&#
The distributed synthesis problem of safety and reachability languages is known to be undecidable. In this article, we establish that this is the case for very simple languages, namely for safety and reachability specifications in the intersection of LTL and ACTL.Synthesis, also known as Churchʼs solvability problem [5], is the problem of defining a circuit that continually reacts on an infinite input stream by producing one output letter after receiving one input letter. Churchʼs solvability problem was first raised for specifications in S1S (monadic second order logic of one successor). It inspired the great works of Büchi and Landweber on finite games of infinite duration [2–4] and of Rabin on finite automata over infinite structures [13,14].Pnueli and Rosner extended the question to a setting, where the processes have access to incomplete information [12,10,9,7,1]. They introduced architectures, where the communication from an external environment to working processes and the communication between working processes is through boolean variables. The same boolean variables serve as atomic propositions in the specification. Pnueli and Rosner have shown that the synthesis problem is undecidable for the architecture shown in Fig. 1[12] and hence in general, and Finkbeiner and Schewe [7] have identified the class of architectures, in which synthesis is decidable.In this article, we show that distributed synthesis is undecidable even for the syntactic safety and reachability fragments of LTL [11,6], of ACTL [6], and of their semantic intersection. The undecidability of safety and reachability languages has been established in [8], using a reduction to tiling languages. Besides using weak fragments of temporal logics, we use the standard reduction to halting problems. We believe that this reduction is more accessible for the community. It is also more instructive in that the adjustments needed to the classic proof become clear.We assume that the reader is familiar with temporal logics [11,6] and the distributed synthesis question [12,10,9,7]. For architectures [12,9,10,7], it is enough to know that they are directed graphs, whose vertices are processes that operate synchronously on a joint system clock. The edges are labelled with variables that serve as a means to communicate between processes, and as the propositions of the specification. The processes consist of an environment, which cannot be controlled, and provides an unconstrained behaviour, and processes for which we want to construct a control strategy (the circuit in Churchʼs [5] terms). This control strategy may only use information available to the processes through their respective input stream. The joint behaviour of the resulting system is required to satisfy the specification.We follow [7] by restricting the variables such that each variable can only occur on the outgoing edges of one process (but may be read by many processes) and by allowing for processes that have a fixed finite implementation. (For such processes, no implementation needs to be synthesised. Verification can be viewed as the special case where all processes have a fixed implementation.)We start by revising the classical argument of Pnueli and Rosner that the architecture from Fig. 1 is undecidable. Their argument uses the incomplete information the processes have, to force them to faithfully emit sequences of configurations of deterministic Turing machines (DTMs).A configuration of a deterministic Turing machine (DTM) is represented as a finite string C composed of:1.the (possibly empty) sequence of tape symbols to the left of the read–write head, followed bythe state of the DTM, followed bythe (possibly empty) sequence of tape symbols to the right of the read–write head to the firstblanksymbol.The position of the read–write head is represented by astatesymbol (the set ofstatesymbols contains thehaltsymbol), while a position on the tape (different toblank) is represented by atapesymbol. Thus, a configuration is a sequencetape⁎statetape⁎blank. (For readability, we henceforth refer to the representation of C as C, too, as it is always clear which of the two is meant.) When a start symbol is issued by the environment, this is reflected bystart.The fact that a configuration C is the successor configuration of a configuration D is denoted byD⊢C. When C and D are emitted concurrently starting at the same time, thenD⊢Cis a local property that can be reflected by a small and simple LTL (or ACTL) formula, because the read–write head can only move one field and the tape can only change below the read–write head.Pnueli and Rosner have devised a specification that forces both processes of the architecture from Fig. 1 to emit the correct sequenceC1,C2,C3,C4,…of configurations of a given DTM, such thatC1is the start configuration andC1⊢C2⊢C3⊢C4⊢⋯holds, upon receiving their respective start symbol through a conjunction of specifications that require the following.1.Before receiving the first start symbol, the processes emit a sequence ofblanksymbols.After receiving the first start signal, each process emits sequences of configurations of the DTM.After receiving the first start signal, each process emits the first two configurations of the DTM correctly.If processpiand processp1−istart at the same time to emit the configurationsCiandC1−i, respectively, such thatCi⊢C1−iholds andpiemits the configurationDinext, thenp1−iemits the configurationD1−iwithDi⊢D1−inext.As the conjunction of these specifications forces the processesp0andp1from Fig. 1 to emit the correct sequence of Turing machine configurations, we can reduce the halting problem to the synthesis problem for the architecture from Fig. 1 by adding the following specification.5.A process that receives a start symbol eventually emits a halting configuration.Theorem 2.1(See[12].) The distributed synthesis problem for the architecture fromFig. 1is undecidable for LTL specifications.We first show that this undecidability argument can be adjusted to use only safety specifications. The first observation is that, with safety specifications, we cannot require that a configuration is emitted, but we can require that a sequence is outputted that can be extended to a configuration. For this we define pseudo-configurations and require for a pseudo-configuration C that it is composed of the following:1.a (possibly empty) sequence of tape symbols to the left of the read–write head. This sequence might be infinite. If it is finite, it is followed bya state of the DTM, which is followed bya (possibly empty) sequence of tape symbols to the right of the read–write head. This sequence may be infinite. If it is finite, it is followed by ablanksymbol.Before and when receiving the firststartsignal, the processes emit a sequence ofblanksymbols:(blank∧¬start)W(blank∧start).After receiving the firststartsignal, each process emits a sequence of pseudo-configurations of the DTM.¬startW(start∧□ϕ)withϕ=¬blank∨◯γ.After receiving the firststartsignal, each process emits the first two configurations of the DTM correctly.¬startW(start∧ψ), where ψ forces the correct emission of the first two configurations. Note that ψ requires us to output a particular finite sequence.If processpiand processp1−istart at the same time to emit the configurationsCiandC1−i, respectively, such thatCi⊢C1−iholds, andpiemits the configurationDinext, thenp1−iemits the configurationD1−iwithDi⊢D1−inext.No process ever outputs ahaltstate.□¬halt.Lemma 3.1The resulting formulas are safety formulas that can be expressed in LTL and ACTL.ProofFor all but (4), the LTL specifications are described. For (4), one can again use a specification of the form¬startiW(starti∧□(¬blanki∨¬blank1−i∨θ)). θ requires that the next two pseudo-configurations emitted,CiandDifor process i andC1−iandD1−ifor process1−i, satisfyCi⊬C1−i, orCi⊢C1−iandDi⊢D1−i.For pseudo-configurationsCiandC1−i,Ci⊬C1−iis a safety property, whose violation occurs whenCi⊢C1−iis observed. We formalise this safety specification by requiring an output sequence that satisfies:•a sequence of equaltapesymbols output byp0andp1(weak) until (the weak until is the LTL operatorW) there is a short sequence that is not equal and that does not reflect a single step11A single step can only affect the control state of the DTM, the tape symbol under the read–write head, and the position of the read–write head, which can only move forward or backward a single position. This is therefore a local condition on three symbols.of the DTM, ora sequence of equaltapesymbols output byp0andp1(weak) until there is a short sequence that reflects a single step1 followed by a sequence of equaltapesymbols (weak) until different symbols are emitted.Similarly, one can reflectCi⊢C1−iandDi⊢D1−iby a safety formula, taking into account that, ifC1−iis longer (which happens when the DTM writes, in the configuration represented byCi, on a previously empty tape cell), then each symbol of the configurationDimust be compared with the symbol emitted in the following step byD1−i.The specification we obtain by using these building blocks is in the syntactic safety fragment of LTL. Adding a universal path quantifier in front of each temporal operator results in an equivalent specification in the syntactic safety fragment of ACTL.  □Lemma 3.2The specification is realisable if, and only if, the Turing machine does not halt.ProofWe show this by reduction from the halting problem.If the DTM does not halt, then the specification can be satisfied by simply letting both processes emit the correct sequence of configurations when prompted to do so by the firststartsymbol.Let us assume for contradiction that the DTM halts but the specification is realisable in the given architecture, and fix one such implementation. There must be a smallest n such that one of the processes, saypi, emitsC1⊢C2⊢⋯⊢Cn−1, but does not continue withCn. As the correctness of n is hard-coded forn⩽2, n must be at least 3.Let us consider such a sequence, and let the processp1−ireceive its firststartsymbol|Cn−2|steps afterpi. Thenp1−istarts emittingCn−2whenpiemitsCn−1. By the minimality of n,p1−inext emitsCn−1, andpimust therefore emitCn. ↯ □This provides us with our first main theorem.Theorem 3.3The synthesis problem for the architecture fromFig. 1is undecidable for specifications in the syntactic safety fragment of LTL and ACTL.The adjustment to reachability specifications is slightly more involved. A first and rather general observation is that, for reachability specifications, there must be finite control. That is, a control strategy that can be represented by a finite circuit. This is because the control objective needs to be met in finitely many steps.Lemma 4.1Realisable reachability specifications must have finite control.ProofLet us start with an arbitrary control strategy that meets the reachability objective. Let us assume that the objective is not met in a bounded number of steps. Then the tree of initial sequences of runs where the reachability objective is not yet met is an infinite (and finite branching) tree. Invoking Königʼs lemma, it has an infinite path. This path does not meet the reachability objective. ↯ □The specification from the standard argument does not extend as easily to reachability. In particular, Lemma 4.1 implies that, if there is nostartsymbol, then the control objective must be met within a finite number of steps.We adjust the specification by forcing both processes to start by emitting sequences of configurations and userestartas a restart command instead of a start command. Intuitively, the first restart symbol received forces the processes to start again. We therefore use a safety specification as a core, which we do not then require to hold forever, but only until a reachability condition is met.For this, we add information to each output letter emitted byp0andp1that reflects the status of the process: (a) has not seen astartsymbol or ahaltstate, (b) has not seen astartsymbol and has seen ahaltstate, but not the end of the respective configuration, (c) has not seen astartsymbol and has seen the end of the configuration afterwards, (d) has seen astartsymbol, and nohaltstate after this (e) has seen astartsymbol, ahaltstate after this, but no end of a configuration after thehaltstate, (f) has seen astartsymbol, ahaltstate after this, and an end of a configuration after that. The correctness of this information can be maintained until (and including) the first point in time, where both processes emit (c) or (f) at the same time.Exploiting this information about the status, we can use the following reachability specification.1.For both processes, the additional information (a through f) is updated correctly (strong) until both processes have a c or f status. (Strong until refers to the LTL operatorU.)Initially, each process starts to emit the first two configurations of the DTM correctly (weak) until it receives arestartsymbol. (Weak until refers to the LTL operatorW.)ψrestart, whereψrestartforces the correct emission of the first two configurations until both configurations have been emitted or a restart symbol has been received, whatever happens first; this is a finite sequence.After receiving the firstrestartsignal, each process emits the first two configurations of the DTM correctly, unless the condition that both processes have a c or f (abbreviatedcf) is reached first.¬restartW(cf∨restart∧ψ), where ψ forces the correct emission of the first two configurations of the DTM. Note that this is a finite sequence.Initially, each process emits a sequence of pseudo-configurations of the DTM (weak) until arestartsymbol is received orcfholds.ϕ′W(restart∨cf)withϕ′=¬blank∨◯γ′, whereγ′=tapeW(state∧◯¬state)WtapeW(blank∨restart∨cf)is the relaxation of γ that allows the process to stop emitting a pseudo-configuration upon receiving arestartcommand or reachingcf.When receiving the firstrestartsignal beforecfis reached, each process emits a sequence of pseudo-configurations of the DTM, but it may stop after having emitted an f information.¬restartW(cf∨restart∧(ϕWf))withϕ=¬blank∨◯γas in the safety specification from Section 3.Let the property ϑ describe the following: If processpiand processp1−istart at the same time to emit the configurationsCiandC1−i, respectively, such thatCi⊢C1−iholds; andpiemits the configurationDinext, thenp1−iemits the configurationD1−iwithDi⊢D1−inext, provided no firstrestartsymbol is received meanwhile (which can be read from the state of the processes). We then addϑUcf.The specification is rather obviously a reachability specification. With the observation that the specification is expressible in LTL and ACTL we get:Lemma 4.2The above specification can be expressed in the reachability fragments of LTL and ACTL. □Lemma 4.3The specification is realisable if, and only if, the Turing machine halts.ProofFirst, the specification is realisable if the Turing machine halts: in this case, both processes can simply start by emitting the true sequence of configurations of the Turing machine initially, and restart doing this once they receive the first restart symbol.To establish the ‘only if’ direction, assume that there is an implementation that satisfies the specification, while the Turing machine does not halt. Therefore there is a lowest natural number n such that one of the processes, saypi, emitsC1⊢C2⊢⋯⊢Cn−1, but does not continue withCn, initially or after receiving the first restart command from the environment. Note thatn⩾2is guaranteed by the hard coded requirement to emit the first two configurations correctly.In case of the initial sequence, we consider a situation, where the processp1−ireceives onerestartcommand, and it received it after|Cn−1|steps. Then, by the minimality of n,p1−istarts to emitCn−2whenpistarts to emitCn−1, andp1−icontinues after emittingCn−2by emittingCn−1by the minimality of n. As the reachability objective has not been met,pimust emitCnin order to satisfy the specification.Whenpihas received the firstrestartcommand, we encounter a similar situation when processp1−ireceives therestartcommand|Cn−1|steps after processpi.  □This provides us with our second main theorem.Theorem 4.4The synthesis problem for the architecture fromFig. 1is undecidable for the reachability fragments of LTL and ACTL. □The extension to decidable architectures is a straightforward adaptation from the extension described by Finkbeiner and Schewe [7]. Their argument is that, in the case where there is an information fork, a situation where there are two processesp0andp1who can receive information from the environment – directly or forwarded through a communication chain of arbitrary length – such that this pathway cannot be intercepted by the other process, then synthesis is undecidable. They also provide a decision procedure for all architectures without information forks.In a nutshell, the argument is that the environment can forward more information than just the start signal: besides the start signal, it can transfer a perfect XOR key. This can be used to encrypt the output of the processes, such that neither process can make use of a potential access to the output of the respective other process.This specification is naturally in the safety fragment of ACTL and LTL, but can likewise be encoded in the reachability fragment of ACTL and LTL in the same way as before: it is only maintained until both processes have reached a c or f status a the same time.Theorem 5.1The restriction to the safety or reachability fragment of ACTL ∩ LTL does not affect the set of decidable architectures. □

@&#INTRODUCTION@&#


@&#CONCLUSIONS@&#
