@&#MAIN-TITLE@&#
Path planning using a Multiclass Support Vector Machine

@&#HIGHLIGHTS@&#
Generation of a smooth path based on the hyperplane generated by the SVM training stage.The margin maximization constraint of the SVM ensures that the generated path will be as far as possible from the obstacles in the environment.Robustness against uncertainty and the noise generated by sensors.Generation of a decision graph that allows using higher level methods to select the final path.The method is compared with a previous approach and in real world conditions.

@&#KEYPHRASES@&#
Multiclass Support Vector Machines,Trajectory generation,Mobile robots,Path planning,

@&#ABSTRACT@&#
In this paper, a new path planning algorithm for unstructured environments based on a Multiclass Support Vector Machine (MSVM) is presented. Our method uses as its input an aerial image or an unfiltered auto-generated map of the area in which the robot will be moving. Given this, the algorithm is able to generate a graph showing all of the safe paths that a robot can follow. To do so, our algorithm takes advantage of the training stage of a MSVM, making it possible to obtain the set of paths that maximize the distance to the obstacles while minimizing the effect of measurement errors, yielding paths even when the input data are not sufficiently clear. The method also ensures that it is able to find a path, if it exists, and it is fully adaptable to map changes over time. The functionality of these features was assessed using tests, divided into simulated results and real-world tests. For the latter, four different scenarios were evaluated involving 500 tests each. From these tests, we concluded that the method presented is able to perform the tasks for which it was designed.

@&#INTRODUCTION@&#
From its inception, research on mobile robots has generated great expectations. To this day the field remains wide open and is constantly evolving. Mobile robots are used in applications such as industrial processes, oceanic and planetary exploration, military projects, rescue operations, and many more. One of the most interesting areas related to mobile robotics, one that has seen considerable research since the 1960s, is path planning. This area remains largely untested, however, and many methods are still under development, with some improving on previous methods or complementing existing techniques.The problem we wish to address with the method presented in this paper is the generation of a trajectory which allows reaching any point on a map starting from the current position of a vehicle. The challenge is to be able to do this even if the map provided is noisy and unstructured. To this end, an innovative algorithm that combines techniques typically related to Artificial Intelligence and Machine Learning is used together with classical methods from graph theory. The main idea is to employ an SVM classifier in order to generate all the possible safe paths that a robot can follow between obstacles, creating a simple, weighted graph that allows the robot to easily compute the best paths towards a given destination.The method described in this paper uses a map as its input. Obstacles in the map are represented and transformed into point features, which are tagged using a different label for each obstacle (or class). By doing so, every feature belonging to the same obstacle will have the same label, which will be unique to each obstacle. These generated features are used to train an SVM, yielding a hyperplane that divides all these classes, ensuring that the distance from each hyperplane to the nearest feature of each class is maximized. The intersections of this hyperplane with the plane of the map are extracted and joined together to form a graph (which is then cleaned, for optimization purposes). Edges in the graph will include the value that is desired to be minimized (in our tests, length of the sub-path). Once this graph is complete, it is quite easy and fast to travel along the map.This document is divided as follows: in Section 2 a review of previous path planning related algorithms is presented. In Section 3 a Multiclass Support Vector Machine (MSVM) is briefly explained. The different steps of the algorithm are described in Section 4 and in Section 5 we show the results of several real application experiments. At the end of the document, in Section 6, we present some conclusions and discuss the advantages of our algorithm compared with similar methods.Path planning is a field that has been under development since the mid-1960s, but it was not until the publication of the work by Lozano-Perez in 1979 [20] that interest in this topic started to grow. The problem can be divided in two stages: global and local path planning. Global path planning tries to find the best possible path from a robot's current position to its target. The physical characteristics of the robot are not usually included in this step. Local path planning is designed for a specific robot to follow the global path previously calculated, this local path being dependent on the robot's structure and capabilities. Global path planning can be divided into graph-based and grid-based techniques. Refs. [23,38] and [39] provide a compilation of some of the most relevant methods developed for each of these groups.Graph-based path planning attempts to reduce the robot's world to a graph and then apply graph search algorithms to look for a solution. One example of these techniques is a Visibility Graph, where the robot's environment is simplified to model all the topology of the environment by linking the obstacle vertices to one another and to the initial and final nodes. Thus, the visibility graph obtains the shortest possible path as the graph is explored [49]. Another example is potential field methods, which consider the robot as a particle that is repulsed from obstacles and attracted to its destination. Potential fields are a continuous function and look for the minimum potential. A graph can then be constructed to find a global path [47].Another classical method is the Voronoi diagram [42], where obstacles are enclosed in a 2-D polygon. The segments of the Voronoi diagram are all the points in the plane that are equidistant to the two nearest sites. The Voronoi vertex nodes are those points that are equidistant to three or more sites. The Voronoi diagram is one of the most used classical algorithms because it yields a safe path that maximizes the distance to obstacles.Grid-based path planning divides the environment into cells, reducing the problem to a C-space (Configuration Space) search. Cells can be marked as free space, occupied space and unknown. The result of a search is a connection between adjacent cells marked as free cells from the origin to the destination. This kind of algorithm, which can integrate global and local path planning, became popular due to its use in autonomous car prototypes, like the Stanford Car for the DARPA Urban challenge [45]. It can be easily applied to real problems due to the fact that no previous knowledge of the environment is necessary. Another advantage is that they can work with partial observations of the environment.C-space allows for multiple search algorithms, like dynamic programming where path planning is solved as an optimization problem, as in [43], where optimization techniques reduce algorithm computation time, or A*, where searching algorithms include heuristic knowledge of the route. One of the most used implementations of this kind of algorithm is the Lattice Planner, described in [50], which is based on performing an anytime incremental search on a multi-resolution, dynamically-feasible lattice state space. The resulting plan provides real-time performance and guarantees the suboptimality of the solution. This kind of planner allows including constraints in robot movements, as in [8], where Pivtoraiko presents a set of elementary movements that connect each discrete state value to a set of its reachable neighbors via feasible motions in a discretized field.Heuristic methods are the answer given by researchers to the limitations imposed by classical methods. These limitations are time consumption in high dimensions, and the possibility of getting stuck in a local minimum. The most representative methods within this classification are: Probabilistic Roadmaps (PRM) [18], where random samples of C space are taken to find feasible paths; Rapidly Exploring Random Trees (RRT) [19], where the tree is constructed incrementally from samples drawn randomly from the search space and is inherently biased to grow towards large, unsearched areas of the space; and heuristic improvements of classical methods [37], where classical techniques like potential fields are improved using local minimum avoidance techniques, like simulated annealing.Another class of algorithm uses Artificial Intelligence techniques to optimize the path planning cost function. These include evolutionary algorithms [41], Artificial Neural Networks (ANN) [12], Genetic Algorithms (GA) [35], Particle Swarm Optimization (PSO) [52], Ant Colony (ACO) [26] and Fuzzy Logic (FL) [13]. In general these methods do not search for a global path, looking instead for a more reactive behavior to decide on the best direction to pass an obstacle.Within the Artificial Intelligence methods we may include the methods based on Support Vector Machine (SVM). Three main trends can be highlighted:1.The first one uses SVM to improve or smoothen previous routes generated by other techniques, like [46], where a Voronoi-based path plan is smoothed using SVM. Ref. [6] uses SVM to smoothen a set of candidate routes in topological maps. Ref. [48] uses SVM to provide the critical points and Bezier curves are applied to smoothen the generated path. Ref. [51] uses SVM for mobile robot motion control and obstacle avoidance, and path planning is generated using potential fields based on Lyapunov functions.The second one uses SVM techniques to build a path. In Ref. [24] the navigation is planned in environments for which obstacles are known. In his method, Miura randomly assigns known obstacles into two classes, positive or negative. Using these two classes, an SVM is trained and a decision boundary is used as a path. In order to make this more efficient, a set of fake obstacles (guide samples) is generated on both sides of the robot's current position and destination, as well as parallel to the line that joins both points (nominal line). This is done to help SVM search for a feasible path. The method works well, but it has two important limitations: the method is highly dependent on how well fake obstacles are placed, and tentative paths are generated using different patterns (that is, some obstacles placed in the positive class are randomly labeled as negatives and vice versa) until the number of patterns tried exceeds a predetermined number and at least one feasible path is found. This strategy does not guarantee that the final path is optimal.Other approaches based on SVMs are those proposed by Sarkar et al. [30], who describe the use of SVMs for navigating in known and unknown environments; and by Tennety et al. [33], who developed a method for navigating in unknown environments using SVMs and a k-nearest neighbor algorithm. In their methods, the entire environment sensed by the robot is divided into two classes of data sets and SVM is used to determine the maximum margin hyperplane between the data sets belonging to the two classes. The data are assigned to one class or the other, depending on whether the points are to the robot's left or right. Once the initial labels are assigned, further classification is achieved using a k-nearest neighbor algorithm, where k = 1. The idea is to assign to each point the label of the closest point already labeled. As a consequence, obstacles in the robot's environment are also classified into one of the classes based on the proximity of the obstacle points to the other points in the map. With this strategy, it is impossible to ensure that the best path for avoiding an obstacle is used, especially when more than one obstacle is present (the robot will always pass to the left or right of an obstacle, but if there is a group of obstacles, it is impossible to ensure that the robot will pass them on the shorter side).Ref. [25] describes a specific application of an MSVM path-planning method and applies it to the generation of a Road Network Definition File, which is used as global path planner for Verdino, an autonomous vehicle designed to move in closed pedestrian environments. This paper describes a complete application of an MSVM planner including obstacle inflation, obstacle clustering, navigability mask generation, SVM training, boundary extraction and the Road Network Definition File generation. A costmap is generated using the Verdino's on-board sensors and the method is tuned in order to optimize the performance of the prototype.In the approach described in this paper, multiclass classifiers are used to obtain all the possible paths that the robot can to follow in a given environment, ensuring that the distances to obstacles are maximized, regardless of where the origin and destination points are. In this case, each obstacle is a different class in the classifier. When compared against other SVM-based methods, it improves upon them in some aspects. For example, in contrast to these methods, every possible path is explored, thus ensuring that the path obtained will always be closer to optimality and not just a tentative solution, as happened in the method developed by Miura [24], or the k-means approach developed by Tennety et al. [33]. In these methods, the solutions obtained by using a binary SVM are not necessarily good paths, so they cannot be used as path planning algorithms, but rather as reactive algorithms that, in some circumstances, lead to unexpected behavior. Also, for a situation in which N obstacles are present, the Miura method requires training up to 2N−2 different SVMs to ensure that the path found is optimal. In practice, this number of combinations is not reached, since it is too expensive in terms of the time required. This leads to sub-optimal paths, or even to a valid solution not being found. However, in our method, only N different SVMs (one per class) are always calculated, ensuring that the path found is close to optimal. In addition, if a new obstacle appears in the method described by Tennety et al. [33], it is assigned to one of the classes. In the algorithm introduced in this paper, when a new obstacle appears, it is considered as a new class (see Section 5.1.2), so every possible way to avoid it is computed.Compared to other methods presented in this section, Multiclass Support Vector Machine (MSVM) is designed to find a compromise between the distance to obstacles and the length traveled. It can be applied to continuous and discrete (C-space) spaces, converting actual robot sensor information to a graph used to calculate the shortest path. One of the main advantages of the method is its ability to reduce uncertainty due to errors introduced by sensors, since it tries to maximize the distance to the points that define different obstacles. If it is not possible to define a line that clearly divides two different objects, a function that tries to minimize this effect is generated. As noted above, it outperforms the path planning of other SVMs! (SVMs!). With respect to classical methods, the behavior is similar to Voronoi in that it tries to maximize the distance to obstacles, but in general, a lower traveled distance is achieved due to the ability of Support Vector Machine (SVM) to obtain a smooth decision boundary between classes. Paths generated by Voronoi are too similar in their obstacle profiles, so path smoothing techniques are usually necessary. C-space search algorithms, such as A*, yield soft, short paths, robot constrains can be introduced in the search and anytime methods can be used, but the resulting paths are sometimes too close to obstacles. The method presented in this paper can be used in a continuous space and finds a higher average distance to obstacles, usually at the expense of increased travel distance when compared to C-space results. In conclusion, this method is an option when safety is more important than distance, yielding shorter travel lengths than other methods designed specifically to avoid obstacles, like Voronoi.Support Vector Machines (SVMs) are a set of linear classifiers usually employed both for classification and regression based on supervised learning. This technique relies on the Vapnik Chervonenkis (VC) dimension from statistical learning theory and Structural Risk Minimization. SVMs are maximum margin classifiers that yield an optimal separation hyperplane between diverse data classes. In other words, SVMs transform a linear classification of vectors into a higher dimensional space. Originally, SVMs were developed to solve data acquisition problems. They were originally applied to Optical Character Recognition (OCR) by AT&T laboratories, and later extended to machine learning and prediction problems. The original algorithm was developed by Vladimir Vapnik, but the most currently used version (soft margin) was proposed jointly by Vapnik and Corinna Cortes in 1995 [7]. This technique has been extensively used in problems involving pattern recognition and regression, multi-sensory integration, robot vision, human-machine interaction, etc. More information on Support Vector Machines (SVMs) may be found at [2,53].Binary classification using Support Vector Machines is currently a well-developed technique. The generation of a solution for the multiclass classification in a single step is usually avoided. Instead, a combination of several binary SVM classifiers is used. The best-known methods are:•One-versus all using winner-takes-all strategy Let ωi, i∈1, …, M be the set of classes. The method constructs M binary classifiers. The output function of the ith classifier (ρi) is trained by taking the examples in ωias positive and the remaining classes as negative. Given a new sample x, this strategy labels it with the number of the class with the largest ρi.One-versus-one using max-wins voting In this method a binary classifier is constructed for each different pair of classes, yielding M·(M−1) / 2 different classifiers. The binary classifier Cijis trained using samples from ωias positive and from ωjas negative. Given a new sample x, if the classifier predicts that x is in the class ωi, then a vote is added to this class, else the vote is for the class ωj. After testing all Cijclassifiers, x is assigned to the class with the highest number of votes.Directed Acyclic Graph SVM (DAGSVM)[29]This method is similar to the previous one in the training step. In the testing stage, a rooted binary directed acyclic graph with M·(M−1)/2 nodes and M leaves is used. Each node contains a binary classifier Cij. Given a sample x, the binary decision function is evaluated beginning at the root and then at the right or left node, depending on the output. Therefore, the final leaf node will determine the class of the sample.There are other methods based on binary classifiers, like those based on error-correcting codes [10], the methods developed by Hastie and Tibshirani [15] and the one by Platt [28]. Other methods are able to deal with every class at the same time, like [34] and Weston and Watkins [1], which employ the decomposition method proposed in [17], and Crammer and Singer [9]. More information on More information on MSVM is available at [11,16].

@&#CONCLUSIONS@&#
This paper describes a method that applies Multiclass SVM to robot path planning. Different tests demonstrate that the method is able to find a smooth path, if it exists, while maximizing the distance to obstacles. By generating a non-linear continuous surface whose distance to the support vectors is maximized, the paths can be calculated simply and directly. Also, the effect of the presence of outliers or noise in sensor readings can be reduced.The method is ready to be applied to real-world situations; however, some drawbacks have been identified and future areas of research have been proposed to improve this method.•When there is a large gap between two obstacles, the trajectories calculated may not touch one another, failing to complete the graph and possibly leading to the generation of isolated, unreachable paths. One possible solution for this is to create visibility graphs for isolated paths such that they can be reached in these cases.Sometimes the change between paths is not as smooth as it could be. In order to solve this, changes between paths could be solved through other soft computing techniques.Primitives are not being considered, nor are course changes. One possible solution is to adapt the technique shown in SBPL A* by directing the A* search through the existing graphs.The method limits the number of paths possible since it regards the vehicle's footprint as perfectly circular, with a diameter equal to its longest dimension.Finally, our method has been tested both in a simulated environment and in real conditions, using our Verdino robotic platform. These tests have proven that it is able to work in real time for its intended purposes.