@&#MAIN-TITLE@&#
Ranking paths in stochastic time-dependent networks

@&#HIGHLIGHTS@&#
We consider networks where travel times are both stochastic and time-dependent.We consider the NP-hard problem where an o–d path must be chosen a priori.Our algorithm can easily be extended to the ranking of the first K shortest paths.The algorithm uses the time-adaptive solution as a relaxation of the a priori problem.Our solution methods are effective and robust under realistic test instances.

@&#KEYPHRASES@&#
Shortest paths,Ranking,Stochastic time-dependent networks,Routing,

@&#ABSTRACT@&#
In this paper we address optimal routing problems in networks where travel times are both stochastic and time-dependent. In these networks, the best route choice is not necessarily a path, but rather a time-adaptive strategy that assigns successors to nodes as a function of time. Nevertheless, in some particular cases an origin–destination path must be chosen a priori, since time-adaptive choices are not allowed. Unfortunately, finding the a priori shortest path is an NP-hard problem.In this paper, we propose a solution method for the a priori shortest path problem, and we show that it can be easily extended to the ranking of the first K shortest paths. Our method exploits the solution of the time-adaptive routing problem as a relaxation of the a priori problem. Computational results are presented showing that, under realistic distributions of travel times and costs, our solution methods are effective and robust.

@&#INTRODUCTION@&#
Classical optimization models for routing commodities, vehicles, passengers, etc. in a transportation network assume that link travel times are deterministically known and do not evolve over time. In real cases this assumption is often unrealistic, indeed, several different ways of representing uncertainty and/or variability have been proposed in the literature. In this paper we consider stochastic time-dependent networks (STD networks) where link travel times are represented by random variables with probability distributions varying as a function of departure times. We distinguish between discrete and continuous STD networks, according to the representation of time and the nature of the random variables. Routing models based on STD networks have been often adopted in application areas such as hazardous material transportation (Chang et al., 2005), advanced vehicle navigation and traveler information systems (Gao and Huang, 2012; Ardakani and Sun, 2012) and transit passenger path choice (Hickman and Bernstein, 1997).Optimal routing in STD networks was first addressed by Hall (1986), who considered the minimization of expected travel time for a given origin/destination pair and starting time. Hall pointed out two different ways of formulating the problem. If a route must be specified before travel begins, and no deviations are permitted, a simple (i.e., loopless) path must be selected; this is referred to as a priori route choice. However, the shortest route is not necessarily a path but rather a time-adaptive strategy that assigns optimal successors to a node as a function of leaving time; this is referred to as time-adaptive route choice. The adaptive problem turns out to be computationally easy; in a discrete STD-network an optimal strategy can be found in linear time in the size of the network description (Pretolani, 2000; Miller-Hooks, 2001). By contrast, a priori route choice has been shown to be strongly NP-hard also for discrete and deterministic time-dependent networks (Orda and Rom, 1991; Pretolani, 2000).A solution approach for a priori routing, valid for both discrete and continuous STD networks, was proposed by Hall (1986); his method enumerates loopless paths in a suitably defined deterministic and static version of the STD network. As observed in Miller-Hooks and Mahmassani (2000), Hall’s method has relevant potential drawbacks, since it may process all existing paths before termination. For discrete STD networks, Miller-Hooks and Mahmassani (2000) proposed a labeling algorithm that finds a priori optimal paths, to a given destination, from all the other nodes and for all possible leaving times. In fact, they allow the paths to be looping, which is a major depart from Hall’s original model. This method has similar drawbacks as Hall’s method (see Miller-Hooks and Mahmassani, 2000, Proposition 4) but turns out to be quite effective for sparse random networks. For continuous STD networks, Fu and Rilett (1998) proposed a heuristic approach based on a technique for approximating the expected length of a path. Based on similar techniques, an efficient algorithm was devised by Fu (2001), and later extended to the multicriterion case by Chang et al. (2005).Despite being less flexible and computationally harder, a priori route choice may represent the only alternative in several situations. This is the case, for example, if the traveller does not have access, or is not willing (think of a daily commuter) to react to information made available during the travel. Another relevant example is the transportation of highly sensitive substances, where it is necessary to commit in advance to a specific path, that must be preapproved and monitored. Chang et al. (2005) address a priori routing in this context. Moreover, on the strategic level the difference between the minimum cost under a priori and time-adaptive routing may provide an indication of the value of using on-line information. This indication may support the decision of investing in on-board navigation systems and road infrastructures, see e.g. Gao and Huang (2012), Ardakani and Sun (2012), Boyles and Waller (2011) for some related issues. A comparison between a priori and adaptive routing goes beyond the scope of this work; the interested reader may find some results in Miller-Hooks and Mahmassani (2000) and Nielsen (2004).In many cases where a priori routing is mandatory, finding a single shortest path may not be satisfactory, and it becomes relevant to determine a set of alternative optimal or nearly-optimal paths. This allows e.g. to select the shortest path satisfying some additional constraints not captured by the network model. In other cases we may be interested in selecting a set of spatially dissimilar paths, rather than a single one; this typically happens in hazardous materials transportation, in order to equally distribute the risk among the population. A common approach (see e.g. Akgün et al., 2000) consists in selecting dissimilar paths out of a (large) set of previously generated “attractive” paths. In the situations above, one needs effective methods for ranking a priori paths, that is, the STD counterpart of the classical K shortest (loopless) paths in directed graphs (Yen, 1971). However, to the best of our knowledge, ranking of a priori paths in STD networks has never been addressed in the literature, with the exception of Nielsen et al. (2009) where a ranking procedure was embedded in a two phase method for bicriterion a priori routing.In this paper we consider a priori route choice in discrete STD networks, for a single origin, a single destination, and a given departure time. Our goals are to devise solution methods for the shortest and K shortest path problems, and to evaluate their effectiveness and robustness against a set of challenging instances. In the following we describe in detail the aim and contribution of our work. First, it is worthwhile to add a couple of remarks on the model considered here. Since we address a priori route choice, we ignore all kind of on-line information, including arrival times at intermediate nodes, which implies that waiting is forbidden. Furthermore, according to the original model proposed by Hall, we assume that travel times are independent random variables. Models of STD networks with correlated travel times have been proposed, see e.g. Huang and Gao (2012) for a priori route choice; these models are much more computationally demanding than the classical one.We devise a best-first branch and bound method, where subproblems correspond to subnetworks of the STD network. Due to the best-first policy this method generates paths in non-decreasing order of cost, and thus deals quite naturally with the ranking of a priori paths. A relevant methodological contribution of our approach is that we solve time-adaptive problems as a relaxation of a priori problems. The fact that the former problem is a relaxation of the latter has already been pointed out (Miller-Hooks and Mahmassani, 2000), but has never been exploited for algorithmic purposes. Within our method, the use of the adaptive relaxation allows to skip (or at least delay) the processing of unpromising subproblems, thus avoiding the pitfalls of the previously proposed methods. We also devise a version of our method solving time-adaptive subproblems via reoptimization (see Nielsen et al., 2006). This version turns out to be consistently faster.To the best of our knowledge, our work is the first one addressing the ranking of a priori paths in STD networks, both from a methodological and a computational point of view. It is instructive to point out that previous approaches for the shortest a priori path do not seem suitable for ranking purposes. This may shed light on the motivations and the relevance of our methodological contribution. The method proposed by Hall, despite some similarities to our one, does not necessarily generate paths in nondecreasing order of travel time. Indeed, it generates paths in nondecreasing order of length, which is a (quite loose) lower bound on the expected travel time. As a consequence, the path generation stops only when the length of the last generated path meets the Kth best solution found so far, provided this happens before enumerating all the existing paths. Similar and possibly worse drawbacks affect labeling methods, in particular label correcting ones. In fact, we do not know how a labeling method may be extended to ranking in STD networks, at least without the addition of suitable bounds or domination rules. Note that the above drawbacks are avoided in our method, due to the best-first policy and the use of the time-adaptive relaxation.When considering finding the shortest a priori path (i.e., the case K=1) we do not make strong claims on the merits of our approach, since our setting differs substantially from those of previous proposals. Indeed, labeling methods for the discrete case are conceived for a much more general version of the problem; on the other hand, solution methods based on the continuous model are inherently approximate, even if they may offer a better trade-off between computational cost and solution quality. Based on these premises, it seems apparent that a direct computational comparison to previous algorithmic proposals would be questionable, if not arbitrary. Therefore, in our computational analysis we concentrate on the validation of our ranking methodology, which is the main focus of this paper. In fact, an appraisal of the merits and drawbacks of the many existing approaches to a priori routing in STD networks would be an interesting contribution, but this goes far beyond the scope of this paper.To assess the quality and robustness of our methods we set up a particularly challenging experimental setting. To this aim, we concentrate on networks with a grid topology, and we exclude the final steady state adopted e.g. in Miller-Hooks and Mahmassani (2000) and Huang and Gao (2012). The combined impact of these two choices on the difficulty of the instances is discussed in detail in Section 4. For grids of different size and shape, we consider several different models for the link behavior, i.e., different width and shape of the fluctuations of link travel times and costs. The most important issue in our tests is that we address minimization of costs, in addition to minimization of travel times usually addressed in the literature. Instances involving costs instead of travel times turn out to be computationally much more demanding; a possible explanation of this behavior is given in Section 4. Nevertheless, our methods turn out to be reasonably stable under many different scenarios.We remark that the restriction to grid networks fits the aims of our analysis, and cannot be considered as a limitation. In particular, our benchmark instances simulate road networks with congestion effects, and thus can be considered as a realistic representation (and most likely, a “worst case” example) of “real world” transportation networks. Benchmarks derived from road networks have been occasionally used in the literature on STD networks, but we believe that they would be redundant in our case. Besides, adapting the available network descriptions to our setting would be rather arbitrary, since there is no clearly established methodology for assessing the link behavior.The paper is organized as follows. The definitions of discrete STD networks and of the related routing problems are given in Section 2. In Section 3 we provide our algorithms for the a priori shortest and K shortest path problems. In Section 4 we describe our test instances, and report computational results for finding the shortest and K shortest a priori paths. Finally, we summarize original contributions and directions for further research in Section 5. Appendix A provides an example illustrating several concepts introduced throughout the paper.We consider discrete STD networks where departure times are integer and travel times are independent integer-valued discrete random variables with time-dependent density functions. We assume that departure and arrival times belong to a finite time horizon, i.e. a set H={0,1,…,tmax} of integer values. In practice, we assume that the relevant time period is discretized into time intervals of length δ, i.e., the time horizon H corresponds to the set of time instances 0, δ, 2δ,…, tmaxδ.Let G=(N,A) be a directed network with node set N and arc set A. We will refer to G as the topological network. As usual, FS(u)={(u,v)∈A} denotes the forward star of node u. Let o∈N and d∈N denote the origin and destination node in G, respectively.For each arc (u,v)∈A let L(u,v)⊂H be the set of possible leaving times from node u along arc (u,v). Moreover, let L(u), u≠d denote the set of possible leaving times from node u, i.e.,L(u)=⋃(u,v)∈FS(u)L(u,v).Throughout the paper we assume L(o)={0}, that is, it is only possible to leave the origin at time zero. For each arc (u,v)∈A and t∈L(u,v), let X(u,v,t) denote the arrival time at node v when leaving node u at time t along arc (u,v). The arrival time X(u,v,t) is a discrete random variable with densityPr(X(u,v,t)=ti)=θuvt(ti),ti∈I(u,v,t)whereI(u,v,t)={t1,…,tκ(u,v,t)}denotes the set of κ(u,v,t) possible arrival times at node v when leaving node u at time t along arc (u,v). That is, for each ti∈I(u,v,t) the probability of arriving at node v at time tiwhen leaving node u at time t is θuvt(ti). We assume that travel times are positive, that is, ti>t for each ti∈I(u,v,t). We denote byκ=∑(u,v)∈A,t∈L(u,v)κ(u,v,t)the total number of possible arrival times over all arcs and possible departure times. The value κ can be considered as the space required to describe the STD network, that is, the size of the input to our problem. Note that κ grows with the number of arcs, the length of the time horizon, and the size of the support of the random travel time variables.Adaptive routing in the STD network is described by a (time-adaptive) strategy, that is, a function s: (N⧹{d}×H)→A that assigns to each node u≠d and time t∈L(u) a successor arc s(u,t)=(u,v) such that t∈L(u,v). According to s, a traveller leaving a node u at time t∈L(u) travels along arc s(u,t). From now on, we concentrate on travellers leaving the origin node o at time zero.Definition 1A route is a pair R=(DR,sR) where sRis the restriction of some strategy s over the domain DR, and DR⊆(N⧹{d}×H) is recursively defined as follows:1.(o,0)∈DR;if (u,t)∈DR, s(u,t)=(u,v) and v≠d then (v,t′)∈DRfor each t′∈I(u,v,t).A route R provides a complete and minimal set of routing choices for a traveller that leaves the origin at time zero and moves towards the destination. Indeed, DRcontains a pair (u,t) if and only if the traveller has a non-zero probability of leaving node u at time t. Note that we do not allow waiting at intermediate nodes: a traveller arriving at node u≠d at time t leaves u at time t, along arc sR(u,t). A route allows the traveller to arrive at node d within time tmax for every possible realization of the travel times. In other words, a route R exists if and only if the STD network allows to travel from o to d. We refer the reader to Pretolani (2000) for a formal discussion of these properties.Definition 2Given a route R=(DR,sR), let GR=(VR,AR) denote the subgraph of G defined by R, where(1)VR={u∈V:∃(u,t)∈DR}∪{d},AR=∪(u,t)∈DR{sR(u,t)}.The network GRcontains the arcs which may be used with a positive probability when following the route R. Note that GRmay contain several o–d paths, and is not necessarily acyclic.Definition 3A route R is a path-route if GRis a directed and loopless o–d path.Let P=(o=u1,u2,…,ul,ul+1=d) be a loopless o–d path in G. A traveller following path P adopts a time-independent routing choice, that is, travels along arc (ui,ui+1) regardless of the leaving time from node ui. We say that P is feasible if a traveller following P, and leaving o at time zero, arrives at d within time tmax for every possible realization of the travel times. In other words, a path P is feasible if a traveller following P cannot arrive at an intermediate node uiat time t∉L(ui,ui+1).Theorem 1There is a one-to-one correspondence between feasible o–d paths in G and path-routes in the STD network.By definition, a path-route defines a unique feasible path. To prove the converse, consider a feasible path P=(o=u1,u2,…,ul,ul+1=d) in G. Let DPdenote the set of pairs (u,t) such that a traveller following P has a non-zero probability of leaving u at time t. The set DPcan be defined recursively as follows:1.(o,0)∈DP;if (ui,t)∈DPand ui≠d then (ui+1,t′)∈DPfor each t′∈I(ui,ui+1,t).Indeed, feasibility of P implies that t∈L(ui,ui+1) for each pair (ui,t)∈DP. Furthermore, define the function sP: DP→A such that sP(ui,t)=(ui,ui+1) for each pair (ui,t)∈DP. Clearly, R=(DP,sP) is a path-route. □Several optimality criteria for routing in STD networks have been considered in the literature. Let us consider the minimization of expected cost. Costs can be introduced in our STD model by letting c(u,v,t),t∈L(u,v) denote the expected travel cost of leaving node u at time t along arc (u,v). Moreover, we let gd(t) be a penalty cost of arriving at node d at time t. The expected cost of a route R=(DR,sR) can be defined by means of recursive equations, associating a value ER(u,t) to each pair (u,t)∈DR. In particular, if sR(u,t)=(u,v) we have:ER(u,t)=c(u,v,t)+∑t′∈I(u,v,t)θuvt(t′)ER(v,t′)where ER(d,t)=gd(t) for each t∈H. The value ER(u,t) is the expected cost incurred when leaving node u at time t, following R towards d. The expected cost of R is therefore ER(o,0), which we denote c(R). Note that the minimization of expected costs includes as particular cases the minimization of the expected travel time and the maximization of the reliability, that is, the probability of arriving at d within a given time. In particular, the former case can be formulated as the minimization of the expected cost by setting gd(t)=t for each t∈H and c(u,v,t)=0 for each (u,v) and t∈L(u,v). Other optimality criteria may be dealt with by our solution methods, but we only consider expected travel time and cost in our computational experience.In light of Theorem 1, the shortest a priori path problem (sap) addressed in this paper can be formulated as finding the path-route R with minimum expected cost c(R). This problem is well known to be NP-hard (Orda and Rom, 1991). The ranking version of sap, that is the K-shortest a priori path problem (k-sap) consists in generating the first K path-routes in nondecreasing order of expected cost.Under time-adaptive route choice, the optimal routing problem can be formulated as finding the route R (not necessarily a path-route) with minimum c(R). This problem can be solved in linear time; more precisely, it takes O(κ) time to find the optimal route R or show that no feasible route exists. In Appendix A we present an example showing how the optimal route R can be computed, both for the case of costs and of travel times.Since path-routes are a subset of routes, the time-adaptive problem is a relaxation of sap, referred to as the time-adaptive relaxation in the following. Note in particular that the cost of a path-route R is the same in sapand in the time-adaptive relaxation, a fact that will be exploited in our solution methods.In this section we first present our algorithm for sap, and then describe the extension to k-sap. Furthermore, we devise a faster variant that exploits reoptimization techniques.In their overall structure our algorithms bear some resemblance with the classical Yen’s method (Yen, 1971) for ranking loopless paths in directed graphs. There are, however, significant technical differences, as can be expected since, in STD networks, even finding the shortest path is NP-hard. In fact, our approach consists in adapting path-ranking methods in directed graphs and combining them with the solution of the time-adaptive relaxation.Our solution algorithm for sapis essentially a branch and bound method, where each sub-problem corresponds to a sub-network of the original STD network, defined by a subgraph of the topological network G. In particular, we adopt a best-first enumeration strategy, that is, we select subproblems to be processed in nondecreasing order according to a lower bound on their optimal solution value. The lower bound is obtained by solving a time-adaptive relaxation for each generated sub-problem.Consider a generic subproblem S, defined by the subgraph GS, and let R denote the optimal route returned by the time-adaptive relaxation of S. Clearly, if R is a path-route then it is also the optimal solution to S. Suppose otherwise that S is selected but R is not a path-route; in this case we need to apply a branching operation. The goal of our branching rule is to partition the set of loopless o–d paths in GS; to this aim, we adapt the branching rule defined by Yen (1971) for ranking paths in directed graphs. Our partition technique is based on a branching path pR, contained in the graph GRdefined by R, that starts from the origin o but is not necessarily an o–d path. From now on, let us denote by FSR(u) the forward star of a node u in the graph GR.Definition 4Given a route R, a branching path pR=(o=u1,…,ul,ul+1) in GRis a path satisfying1.FSR(ui)={(ui,ui+1)}, ∀ i=1,…, l−1.∣FSR(ul)∣⩾2.Note that GRalways contains a branching path with l⩾2, since we assume L(o)={0} and therefore (o,0) is the only pair (o,t) contained in DR, that is, FSR(o)={(u1,u2)}. Note also that we may have ul+1=d. By definition, GRcontains a unique path from o to ul, while several arcs may be used as the last arc in pR; we do not make any assumption about the way this arc is chosen. Let ΠSdenote the set of o–d paths in GS.Definition 5Given a branching path pR=(o=u1,…, ul+1) we partition the set ΠSinto the subsetsΠS(i)⊂ΠS,1⩽i⩽l+1, as follows:1.for 1⩽i⩽l, paths inΠS(i)contain the subpathpR(i)=u1,…,uiof pRbut do not contain arc (ui,ui+1);paths inΠS(l+1)contain the branching path pR.Note that one or more of the setsΠS(i)in Definition 5 may be empty. The partition of ΠSimplicitly defines a family of subgraphs of GS.Definition 6Given a branching path pR=(o=u1,…, ul+1) the subgraphGS(i), i=1,…, l+1, is obtained from GSas follows:1.For each node uj, j=1,…, i−1, remove each arc in FS (uj) except (uj,uj+1), i.e., fix arc (uj,uj+1);If i≠l+1, remove arc (ui,ui+1).The following result is rather intuitive; a formal proof may be given by adapting the proof of correctness for Yen’s algorithm.Lemma 1Given a branching path pR=(o=u1,…, ul+1), for each 1⩽i⩽l+1 we have thatΠS(i)is the set of loopless o–d paths in subgraphGS(i).In light of Lemma 1, in our branching operation we select a path pRand we create l+1 subproblems S(1),…, S(l+1), where eachS(i) corresponds to the STD sub-network defined by subgraphGS(i). For each subproblem S(i) we solve the time-adaptive relaxation, and we distinguish two possible cases. If the relaxation yields an optimal route R(i) then we assign to S(i) the lower bound c(R(i)), and we store S(i) for later processing. Otherwise, we discard S(i) since the corresponding STD sub-network does not contain any feasible route. An example of application of our branching rule is worked out in details in Appendix A. Some relevant properties are worth pointing out.Property 1Given a branching path pR=(o=u1,…, ul+1), the following statements hold true:1.none of the subgraphsGS(i),1⩽i⩽l+1, contains all the arcs in GR, and thus, all the arcs in GS;ifΠS(i)=∅then the subproblem S(i) is discarded;none of the subproblems S(i), 1⩽i⩽l+1, admits R as a feasible route.A summary of our branch and bound method is given in Fig. 1. We use a priority queue Q to store subproblems to be processed; actually Q stores pairs (lb′,G′), where lb′ is the lower bound assigned to the STD subnetwork defined by subgraph G′. We denote by F(GS,pR) the family of subgraphs in Definition 6. We also introduce two functions, namely MinCost(G′) and OptRoute(G′), that solve a time-adaptive relaxation in the STD network defined by graph G′. Function MinCost(G′) returns the minimum expected route cost, or +∞ if no feasible route exists; function OptRoute(G′) returns the optimum route, assuming that one exists, that is MinCost(G′)<+∞. Note that the algorithm terminates as soon as a path-route R=OptRoute(G′) is found in Step 2. For the sake of simplicity, we assume MinCost(G)<+∞, that is, that the original STD network contains at least one feasible adaptive route.Theorem 2The algorithm given inFig. 1correctly solves thesapproblem in a finite number of iterations.Finiteness follows from Property 1. Correctness follows from Lemma 1 and from the termination rule in Step 3; indeed, if R=OptRoute(GS) is a path-route we have lbS=c(R), thus no other path-route may have a cost less than c(R). □The worst case complexity is exponential, since it may be necessary to enumerate all the subgraphs of G. Note, however, that the algorithm takes linear time O(κ) for each subproblem inserted into Q. We claim (omitting proof) that a smart implementation takes time O(∣Π∣κ), where Π is the set of loopless o–d paths in G. This implies a polynomial complexity in the (rather unlikely) case where Π is polynomial in the input size κ. Concerning the space complexity a (small) constant amount of information needs to be stored for each subproblem inserted into Q. The interested reader may consult Nielsen (2004) for a description of the data structures and the implementation details.As discussed above, our algorithm for saphas several similarities with Yen’s method for ranking paths in directed graphs. Thus the extension to k-sapis rather straightforward: instead of stopping the enumeration as soon as a path-route is found, we apply Yen’s branching rule to the corresponding o–d path, and continue until K path-routes are obtained.Let us briefly discuss the meaning of Yen’s branching rule when applied in our context. Consider a subproblem S defined by graph GS, assume that R=OptRoute(GS) is a path-route, and let GRcorrespond to the loopless path p=(o=u1,…, uq+1=d). We partition the set ΠS⧹{p} into q subsets Π(i), 1⩽i⩽q. Accordingly, we generate q proper subgraphsGS(i)of GS, for 1⩽i⩽q, such that Π(i) is the set of o–d paths inGS(i). For completeness, recall that we obtain the subgraphGS(i)from GSby removing the arc (ui,ui+1) and by fixing arc (uj,uj+1) for each j=1,…, i−1. We then create a subproblem S(i) for eachGS(i), and we proceed as in the sapalgorithm.Let us denote by F(GS,R) the family of subgraphs defined by Yen’s rule for a subproblem S with shortest path-route R. The algorithm for k-sapis obtained from the one in Fig. 1 replacing Step 5 with the following step, where we assume that the counter k is initialized to zero at the outset:Step 5’ (Yen’s rule)outputR; let k=k+1; if k=K then stop, otherwise let F=F(GS,R) and go to Step 4.The correctness of the k-sapalgorithm then follows from the correctness of Yen’s method and from Theorem 2.A clear drawback of our solution methods for sapand k-sapis that, in Step 4, the time-adaptive relaxationMinCost(GS(i))is solved for each generated subproblem S(i), including discarded ones. This is quite expensive in terms of computation times. A possible alternative is to compute a lower boundLB(GS(i))on the minimal route cost, instead ofMinCost(GS(i)). In this way, the time-adaptive relaxation is solved only when (and if) the subproblem is selected from Q in Step 2. As a consequence, however, subproblems are not necessarily selected in the desired order. Moreover, a subproblem S(i) such thatMinCost(GS(i))=+∞may fail to be discarded, and enter Q with a finite lower boundLB(GS(i)). Therefore, a more complex treatment of the selection phase is necessary.Consider the pair (lbS,GS) removed from Q in Step 2, and let lbmin=min{l: (l,g)∈Q} denote the minimum lower bound among the pairs remaining in Q; we have lbmin=+∞ if Q is empty. Solving the time-adaptive relaxation, three mutually exclusive cases may arise.1.MinCost(GS)=+∞: in this case, we discard (lbS,GS) and repeat Step 2;lbmin<MinCost(GS)<+∞: in this case, we discard (lbS,GS), but we insert into Q the pair (MinCost(GS), GS), and repeat Step 2;MinCost(GS)<+∞ and MinCost(GS)⩽lbmin: we let R=OptRoute(GS) and go to Step 3.Note that in case 2 the subproblem is reinserted in Q with the lower bound MinCost(GS); thus a subproblem cannot be reinserted more than once. Moreover, in case 3 the selection of (lbS,GS) is correct even if we have LB(GS)<MinCost(GS). Since the new algorithm only differs slightly from the algorithm in Fig. 1, we omit a pseudo-code description here.A fast and tight lower bound on the expected cost of the optimal route can be computed by exploiting the reoptimization techniques proposed by Nielsen et al. (2005, 2006), in the context of K shortest hyperpaths procedures. The results in Nielsen et al. (2005, 2006) are technically rather involved, and are not described here. Reoptimization techniques cannot be deployed in full strength in our context, since they are devised for a different branching rule, and for searching in a different solution space. Nevertheless, they turn out to be quite useful in practice, as we shall see in the next section.In this section we report the results of the computational experience with our methods for a priori paths. In our tests we only consider the ranking version of the algorithm; however, we also address problem sap, since we report statistics about the generation of the first (and thus shortest) path. Two optimization criteria are tested, namely, the minimization of expected travel time (referred to as MET) and expected cost (MEC).We address the versions of the ranking algorithm with and without reoptimization, respectively denoted by K-SAPreoptand K-SAP. Both versions have been implemented in C++ and tested on a 2.9GHz Intel Core i7 laptop with 16GB RAM using a Windows 7 operating system (Enterprise 64-bit SP1). The programs have been compiled with the GNU C++ compiler (mingw32-g++) with optimize option -O2.In all our tests, the underlying topological network G is assumed to be a grid of base b and height h, with origin o in the bottom-right corner node and destination d in the upper-left corner node. The choice of grids aims at obtaining challenging benchmarks. Indeed, in a b×h grid the topological length (i.e., number of arcs) of an o–d path is at least b+h−2; moreover, the number of these topologically shorter paths grows exponentially with b and h. A first consequence is that the solution space to be explored is quite dense: even recognizing that the K shortest paths are likely to be topologically short, the number of candidate paths remains large and grows quickly with the grid dimensions. More important, in an STD network, longer paths imply more intermediate nodes and arrival times spread in a wider interval, and this in turns imply more opportunities for an optimal adaptive route to divert from an a priori path; as we shall see, the adaptive behavior of routes makes sapand k-sapharder. A further effect is due to the absence of a final steady state, which requires every feasible route to terminate at d within the time horizon H={0,1,…,tmax}. In order to grant feasibility of the routes of interest for k-sap, tmax cannot be chosen arbitrarily, but must increase with the grid dimensions. In particular, in our instances tmax grows with the topological length of paths, i.e., roughly linearly in b+h. Now suppose that both b and h are increased by a multiplicative factor f, leaving the average value κ(u,v,t) unchanged; since the number of arcs is linear in b×h, the input size κ increases by a factor roughlyf3.All tests are performed on STD networks generated with the TEGP (Time-Expanded Generator with Peaks) generator (Nielsen, 2006). TEGP includes several features inspired by typical aspects of road networks, in particular for the simulation of congestion effects. We consider cyclic time periods (cycles) of 144 time instances (e.g. 12minutes with a time step δ of 5seconds) where each cycle contains one or more peaks. Each peak consists of three parts: a transient part of length ttranswhere the mean travel time (congestion) increases, a pure peak part of length tpurewhere it stays the same, and a transient part of length ttranswhere it decreases again. This feature gives travel time distributions with higher mean and higher standard deviation in peaks. The pattern of the mean travel time μ(u,v,t) on a grid arc (u,v), when two peaks are considered, is shown in Fig. 2. The mean travel time μ(u,v,t) equals the off-peak mean travel time μuvuntil it reaches the transient part of the first peak, where it increases up to (1+ψ)μuv, where ψ denotes the peak increase factor. Next the mean travel time stays the same during the pure peak part and then decreases again to μuvwhere it stays the same until the second peak is reached.The off-peak mean travel time μuvis generated randomly, for each grid arc (u,v), in the interval [2,6]. We somehow take for granted that a wider interval of values for μuvresults in more difficult instances, and we do not explore this possibility in our tests. Given μ(u,v,t), possible travel times are the integers in the interval [⌊0.75μ(u,v,t)⌋,⌈1.25μ(u,v,t)⌉]; probabilities are calculated using a binomial distribution. In most cases, we shall assume a peak increase factor of ψ=1 (100%), i.e., the mean travel time can increase up to 12, and the maximum travel time can be at most 15.Under the MEC criterion peak dependent costs are generated. That is, the travel cost c(u,v,t) follows the same pattern as the mean travel time in Fig. 2. Off-peak costs are generated in the interval [1,1000]; this gives travel costs in the interval [0,2000] during peaks. Note that off-peak costs and travel times are generated independently, and are not correlated to each other. The penalty costs gd(t) are set to zero for each time t.In our instances the time horizon length tmax is computed as an upper bound on the expected travel time along a topologically short o–d path; the computation takes into account all the features described above, see Nielsen (2006) for details. As long as MET is considered, the resulting tmax is large enough to grant feasibility of every route of interest for k-sap. This is no longer guaranteed if MEC is considered: since travel times and costs are not correlated, a cheap path may need a long travel time. Nevertheless, we decided to keep the same tmax for both MET and MEC in our tests, to avoid an unreasonable growth of the problem size. Note that a time horizon of the desired length tmax is obtained considering a sequence of successive cyclic periods, where possibly the last one is truncated to a time instant smaller than 144.In the following, we use the term test class to define a particular setting of the TEGP input parameters; for each class, different STD networks (i.e. different instances of each class) can be generated by choosing different seeds. In our tests, ten instances were generated for each class.The aim of our computational experience is twofold. On the one hand, we try to evaluate the performances of our procedures, pointing out the relevance of reoptimization techniques. On the other hand, we try to explain the behavior of our algorithms on the basis of the optimization criterion considered, the structure of the instances and of the solution sets. The reported statistics can be divided into different groups. The first group considers the performance of the procedures; the abbreviations used in the tables are given in parentheses.•CPU time (cpuK): CPU time in seconds for finding the K shortest paths. Does not include input/output time.•First CPU time (cpu1): CPU time in seconds for finding the shortest path.•Number of iterations (iteK): The number of subproblems selected from the candidate set Q before finding the Kth shortest path, that is, the overall number of iterations of the ranking algorithm.•Number of iterations (ite1): The number of iterations before finding the shortest path.•Average number of subproblems created (aveBT): Average number of subproblems inserted into the candidate set Q when branching, i.e. the average number of nodes added to the branching tree.•Number of reinsertions (reins): For K-SAPreopt, the number of pairs reinserted into the candidate set Q after computing the actual shortest route (see Section 3.3). Reported in percent of the number of iterations iteK.Note that the total number of subproblems inserted in the branching tree is given by iteK·aveBT. The second group of statistics is related to the cost (travel time for MET and travel cost for MEC) of the solutions.•Relative increase in expected cost (inc1−K): The cost increase between the shortest and the Kth shortest path. Reported in percent.•Relative increase route to shortest path (incR−P): The cost increase between the optimal time-adaptive route and the shortest path. Reported in percent.The last group contains one single statistic, related to the structure of the optimal route R returned by the time-adaptive relaxation.•Average number of successor arcs (aveFS): The average number of arcs in the forward star of the nodes in GR, omitting the destination d.Recall that R is a path-route if and only if GRdefines an o–d loopless path, that is, aveFS=1. Therefore, the lower the value of aveFS⩾1, the more “path-like” – i.e., the less “adaptive” – is the route R. Since our algorithms are based on the time-adaptive relaxation, their performance is likely to depend on how adaptive the optimal routes found are. If there are many routes R where GRdoes not resemble a path we may have to branch many times before a path is found. On the contrary if the routes are very “path-like”, i.e. GRis close to a path, the size of the branching tree will be smaller and ranking paths will be faster.

@&#CONCLUSIONS@&#
In this paper we devised a solution method for the a priori shortest path problem in discrete STD networks, and extended this method to finding the K shortest a priori paths. We also devised a faster version exploiting reoptimization techniques to compute fast lower bounds. We evaluated the effectiveness and robustness of our algorithms against a set of hard instances, and we pointed out the impact of the problem structure on the performance of our algorithms. To the best of our knowledge, our paper is the first one addressing the K shortest a priori path problem in STD networks.From a computational point of view, the reported results are quite encouraging. For the minimization of travel times (usually addressed in the literature on STD networks) our algorithms can be expected to be effective for instances arising from (reasonable approximations of) real networks, and rather robust when faced with larger or harder instances. We also addressed the minimization of travel costs, which turned out to be much harder than the problem involving travel times. Note however that we limited ourselves (due to space limitations) to the rather extreme case where travel costs are totally independent from travel times. Further analysis is required to evaluate intermediate situations, where costs and times may be partially correlated.Observe that the implementation of our solution algorithms is rather straightforward: besides reoptimization, we did not exploit any sophisticated data structure or algorithmic technique. Clearly, further enhancements are possible. For example, faster and more effective reoptimization based lower bounds may be devised. Moreover, a smart heuristic rule may be adopted to select the branching path (see Section 3.1) giving priority to more promising sub-paths.Finally, the extension of our approach to other variants or special cases of sapand k-sap(e.g. with correlated travel times) seems to provide a challenging direction for further research.The main definitions introduced throughout the paper are illustrated here. To this aim, we show a very small example and we work out the details of our method, in particular, the computation of the optimal adaptive route and the application of our branching rule. We treat the minimization of expected cost first and in greater detail, and then the case of travel times more briefly. In order to represent STD networks graphically we adopt the time expanded hypergraph representation introduced in Pretolani (2000). However, we use hypergraphs only as a graphic tool, without discussing related theoretical concepts.Consider the topological network G=(N,A) in Fig. 3, where a is the origin node and d is the destination node. We assume that the time horizon is H=[0,6]. In Table 6we list the possible departure times for each arc in G, together with the corresponding arrival times and travel costs. Here a pair ((u,v),t) corresponds to a possible leaving time t from node u along arc (u,v), that is, t∈L(u,v). Clearly, for the origin node a we have L(a)={0}. For the sake of simplicity, we assume that X(u,v,t) has a uniform density, i.e., for each t′∈I(u,v,t), we have θuvt(t′)=1/∣I(i,j,t)∣. For example, if we leave node c at time 2 along arc (c,d), we arrive at node d at time 3 or 4 with the same probability 1/2. We denote by D={3,4,5,6} the set of possible arrival times at destination d. The penalty cost gd(t) is zero for each t∈D and the input size of the problem is κ=13.The representation of the resulting STD network is shown in Fig. 4. We introduce a node (circle) utfor each pair (u,t) with t∈L(u). For each (u,v)∈A and t∈L(u,v) we introduce a hyperarc euv(t) that joins utto the set of nodesvti, with ti∈I(u,v,t). Note that the arrow in euv(t) points towards ut, which represents the departure from node u at time t. The number close to each hyperarc euv(t) is the travel cost c(u,v,t). We also introduce a dummy source s, and dummy arcs from s to each node dtwith t∈D. The aim of these arcs is to carry the penalty costs, which are zero in our example.Hyperarcs in solid lines in Fig. 4 represent the minimum expected cost route R=(DR,sR); that is, for each pair (u,t)∈DRthe optimal successor is the arc (u,v)=sR(u,t) such that euv(t) appears in solid lines. The number close to each node utis the value ER(u,t) obtained from the successor (u,v)=sR(u,t), as shown in Section 2, where we additionally have ER(d,t)=gd(t)=0 for each t∈D. Note that DRcontains all the pairs (u,t) with u≠d except (c,4). This means that a traveller following R cannot arrive at node c at time 4. In fact, time 4 is not a possible arrival time at node c, regardless of the chosen route. The computation of the shortest route R can be done as follows. First, the value ER(d,t)=gd(t)=0 is assigned to each node dt. Then the other nodes utare processed in reverse order of time (i.e., right to left in 4) breaking ties arbitrarily. Each node utis assigned the minimum value ER(u,t) obtained from hyperarcs euv(t) pointing at ut. Take for example node b1: the involved hyperarcs are ebd(1), yielding ER(b,1)=0+9=9; and ebc(1) yielding ER(b,1)=2+(8+2)/2=7. The latter gives the minimum value and thus appears in solid lines, denoting the optimal successor sR(b,1)=(b,c).Note that R is not a path-route, since we have sR(b,1)=(b,c) and sR(b,2)=(b,d). In fact, the graph GRinduced by R coincides with the whole graph G. We have FS(a)={(a,b)} and ∣FS(b)∣=2, thus we have two possible options for the branching path pR, namely, pR=(a,b,c) and pR=(a,b,d). Suppose the latter is chosen: according to Definition 6 we obtain three subgraphs, that we denote by G(i), 1⩽i⩽3, since we have GS=G.The subgraph G(1) is obtained from G by deleting the unique arc (a,b) in FS(a). Clearly, it is not possible to travel from a to d in G(1). Therefore, we have MinCost(G(1))=+∞ in Step 4 of our algorithm, and the subproblem corresponding to G(1) is discarded. The other two subgraphs, with the corresponding STD networks, are shown in Fig. 5. The fixed arcs and the corresponding hyperarcs are shown in bold lines; solid lines represent the shortest a–d route in the subproblem. In both cases the shortest route is a path-route with expected cost 9. Therefore, the branching rule inserts into the candidate set Q the two pairs (9,G(2)) and (9,G(3)). These pairs will be selected (in whatever order) and clearly will not generate further subproblems where d is connected to a.The resulting STD network is represented in Fig. 6. The structure is the same obtained for costs, but the values associated with arcs and hyperarcs change: hyperarcs euv(t) carry a zero cost, while the arc from s to dtcarries the “penalty” gd(t)=t. Solid lines represent the route R yielding minimum expected travel time; note that R is not a path-route and differs from the route minimizing cost. The computation of R is performed as shown before. Taking again node b1: hyperarc ebd(1) yields ER(b,1)=3, while hyperarc ebc(1) yields ER(b,1)=(3.5+4.5)/2=4. In this case the former gives the minimum value, thus sR(b,1)=(b,d).Also in this case the graph GRinduced by R coincides with the whole graph G. Assume that the branching path pR=(a,b,c) is chosen, i.e.the branching operation generates the subgraphs G(i), 1⩽i⩽3, where it is not possible to travel from a to d in G(1). The two subgraphs G(2) and G(3), with the corresponding STD networks and optimal routes, are shown in Fig. 7. In this case, the branching rule inserts into Q the two pairs (4.5,G(2)) and (4.25,G(3)), both corresponding to path-routes. Clearly, the last pair is selected first and adds no pair to Q, thus the latter pair is the next (and last) one selected.