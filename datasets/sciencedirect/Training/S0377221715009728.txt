@&#MAIN-TITLE@&#
Branch-price-and-cut algorithms for the pickup and delivery problem with time windows and multiple stacks

@&#HIGHLIGHTS@&#
We formulate and solve the pickup and delivery problem with time windows and multiple stacks.Two branch-price-and-cut algorithms are implemented to solve the pickup and delivery problem with time windows and multiple stacks.An ad hoc labeling algorithm for the shortest path problem with multiple stacks is proposed.A relaxation of the shortest path problem with multiple stacks is implemented.Instances with up to 75 requests can be solved optimally within 2 hours of computational time.

@&#KEYPHRASES@&#
Vehicle routing with pickups and deliveries,Loading constraints,Column generation,Branch-price-and-cut,Valid inequalities,

@&#ABSTRACT@&#
This paper proposes models and algorithms for the pickup and delivery vehicle routing problem with time windows and multiple stacks. Each stack is rear-loaded and is operated in a last-in-first-out (LIFO) fashion, meaning that when an item is picked up, it is positioned at the rear of a stack. An item can only be delivered if it is in that position. This problem arises in the transportation of heavy or dangerous material where unnecessary handling should be avoided, such as in the transportation of cars between car dealers and the transportation of livestock from farms to slaughterhouses. To solve this problem, we propose two different branch-price-and-cut algorithms. The first solves the shortest path pricing problem with the multi-stack policy, while the second incorporates this policy partly in the shortest path pricing problem and generates additional inequalities to the master problem when infeasible multi-stack routes are encountered. Computational results obtained on instances derived from benchmark instances for the pickup and delivery traveling salesman problem with multiple stacks are reported, and reveal the advantage of incorporating the multi-stack policy in the pricing problem. Instances with up to 75 requests and with one, two and three stacks can be solved optimally within 2 hours of computational time.

@&#INTRODUCTION@&#
This paper proposes two branch-price-and-cut algorithms for the pickup and delivery problem with time windows and multiple stacks (PDPTWMS) and analyzes their performance. In the pickup and delivery problem, vehicles based at a depot are used to satisfy a set of requests which consists of transporting goods (or items) from a specific pickup location, where the item is loaded, to a specific delivery location, where the item is unloaded. We consider an unlimited fleet of identical vehicles with multiple homogeneous compartments of limited capacity. Each compartment is rear-loaded and is operated as a last-in-first-out (LIFO) stack, meaning that when an item is picked up, it is positioned on top of a stack. An item can only be delivered if it is on top of its stack and shifting items between stacks is not allowed. To illustrate, let 0 denote the depot, and leti+andi−be the pickup and the delivery nodes associated with request i. Fig. 1 depicts a route and the load of a two-stack vehicle with respect to the multi-stack policy. Each pickup and delivery location has a specified time window during which the service must start. A vehicle route is feasible if (i) the service at each location starts within the given time windows, (ii) the load in each compartment of the vehicle does not exceed its capacity, (iii) each completed requested is first picked up at its pickup location and then delivered at its corresponding delivery location, and (iv) the loading and unloading of the items respect the LIFO policy for each stack. Two types of costs are considered: a fixed cost for each vehicle used in the solution and a distance-related variable cost. The PDPTWMS consists of determining a set of least-cost feasible routes in which the number of vehicles is first minimized.The PDPTWMS arises in the transportation of heavy or dangerous material for which unnecessary handling should be avoided. In particular, this problem is encountered in the transportation of cars between car dealers with multi-level vehicles, where each level is operated in a LIFO fashion. This problem also arises in the transportation of livestock from farms to slaughterhouses with multi-compartment vehicles, where each compartment is operated in a LIFO fashion. To the best of our knowledge, this problem has not been previously studied, but several of its variants have been investigated, namely the pickup and delivery problem (see Berbeglia, Cordeau, Gribkovskaia, & Laporte (2007), Parragh, Doerner, & Hartl (2008a, 2008b) for surveys), the pickup and delivery problem with time windows (PDPTW) (see Battara, Cordeau, & Iori (2014, Chap. 6), Ropke, Cordeau, & Laporte (2007) for exact algorithms), the traveling salesman problem with pickup and delivery and LIFO loading (TSPPDL) (see Carrabs, Cerulli, & Cordeau (2007), Cordeau, Iori, Laporte, & Salazar González (2010) for exact algorithms), the pickup and delivery problem with time windows and LIFO loading (PDPTWL) (see Cherkesly, Desaulniers, & Laporte (2015) for three exact branch-price-and-cut algorithms), the double traveling salesman problem with multiple stacks (see Alba Martínez, Cordeau, Dell’Amico, & Iori (2013), Lusby, Larsen, Ehrgott, & Ryan (2010), Petersen, Archetti, & Speranza (2010) for exact algorithms and Petersen and Madsen (2009) for a heuristic), the double vehicle routing problem with multiple stacks (see Iori and Riera-Ledesma (2015) for exact algorithms), and the pickup and delivery traveling salesman problem with multiple stacks (PDTSPMS) (see Côté, Archetti, Speranza, Gendreau, & Potvin (2012), Côté, Gendreau, & Potvin (2012) for a branch-and-cut algorithm and a heuristic).Among the algorithms proposed for the variants of the PDPTWMS, two exact algorithms stand out and constitute the basis of this research. Côté, Archetti, et al. (2012) have developed a branch-and-cut algorithm for the PDTSPMS, for which several families of valid inequalities were proposed and tested, and instances with up to 21 requests were solved to optimality within 1 hour of computation time. Cherkesly et al. (2015) have developed a branch-price-and-cut for the PDPTWL and have introduced three relaxations of the pricing problem, for which they developed shortest path labeling algorithms to enforce the LIFO policy. One algorithm solves the pricing problem without the LIFO policy and imposes it through additional constraints in the master problem. Another algorithm solves the pricing problem with a relaxed LIFO policy and additional constraints may be added to the master problem if needed. The last one solves the pricing problem with a complete version of the LIFO policy. Computational results revealed that for harder instances the hybrid algorithm seemed to perform best.The main objective of this paper is to develop, for the first time, different exact branch-price-and-cut algorithms for the PDPTWMS. A branch-price-and-cut algorithm is a branch-and-price algorithm in which the linear relaxation is strengthened through the generation of valid inequalities. Column generation can be adapted to constrained vehicle routing problems and have been shown to provide some of the best known results for the PDPTW (Baldacci, Bartolini, & Mingozzi, 2011; Ropke & Cordeau, 2009) and for the PDPTWL (Cherkesly et al., 2015).The first algorithm developed in this paper solves the pricing problem with the multi-stack policy, whereas the second incorporates it partially in the pricing problem and generates additional inequalities to the master problem in which infeasible multi-stack routes are used in a linear relaxation solution. The results of extensive computational experiments on instances derived from known PDTSPMS instances are reported. Instances with up to 75 requests and with up to three stacks can be solved within 2 hours of computation time. The results show that the first algorithm always performs better than the second.The remainder of this paper is structured as follows. Section 2 proposes a column generation formulation for the PDPTWMS and formally introduces the pricing problem. Section 3 presents our first branch-price-and-cut algorithm in which the pricing problem is solved under the multi-stack policy. Section 4 presents our second branch-price-and-cut algorithm in which the pricing problem is partly solved under the multi-stack policy and through the introduction of additional constraints in the master problem. Extensive computational results are reported in Section 5 and are followed by conclusions in Section 6.We now introduce a set partitioning formulation for the PDPTWMS. Beforehand, we provide the required notation.Let n denote the number of requests. The PDPTWMS can be defined on a directed graphG=(N,A),whereN={0,1,…,2n,2n+1}is the set of nodes and A is the set of arcs. Nodes 0 and2n+1represent two copies of the depot appearing at the start and at the end of a route, respectively. The subsetsP={1,…,n}andD={n+1,…,2n}are the sets of pickup and delivery nodes, respectively. With each request i is associated a pickup node i ∈ P, denoted byi+,and a delivery noden+i∈D,denoted byi−. Note that i ∈ P refers to a pickup node and to its associated request.With each node i ∈ N is associated a demand qito be picked up or delivered, and for each request i ∈ P, qi> 0 andqn+i=−qi. For each request i ∈ P, we refer to the load picked up at node i and delivered at noden+ias an item. Moreover, we assume thatq0=q2n+1=0. A time window[w̲i,w¯i]is associated with each node i ∈ N, wherewiandw¯irepresent the earliest and the latest time at which service at node i can start, respectively. An unlimited set of identical vehicles, each with M identical stacks of capacity Q, is available. A non-negative travel cost cijand a non-negative travel time tijincluding the service time at node i are associated with each arc (i, j) ∈ A. The cost of each arc leaving the origin node, i.e., an arc (0, i) ∈ A, i ∈ P, also includes a large vehicle fixed cost, leading to first minimizing the number of vehicles, and then the total traveled distance. The triangle inequality is assumed to be respected for travel costs and travel times.Let Ω denote the set of all feasible routes with respect to the time window constraints, the capacity constraints, and the multi-stack policy. Let crdenote the cost of route r ∈ Ω, i.e., a fixed vehicle cost and its total traveled distance, and let airbe the number of times node i ∈ P is visited in route r. Defining yras a binary variable equal to 1 if and only if route r is used in the solution, the PDPTWMS can be formulated as(1)minimize∑r∈Ωcryr(2)subjectto∑r∈Ωairyr=1,∀i∈P,(3)yr∈{0,1},∀r∈Ω.The objective function (1) minimizes the total cost and constraints (2) ensure that each request is completed exactly once. Because the model defined by (1)–(3) generally contains a large number of variables, column generation is often used to solve its linear relaxation, also called the master problem (see Desaulniers, Desrosiers, & Solomon, 2005). At each column generation iteration, a restricted master problem (RMP) containing a subset of variables is solved through linear programming, yielding primal and dual solutions. The pricing problem is then solved to identify variables, also called columns, with negative reduced cost. In the PDPTWMS context, the pricing problem is an elementary shortest path problem with time window constraints, capacity constraints, and multi-stack policy. When such columns are identified, they are added to the RMP and a new iteration starts. Otherwise, the process stops with an optimal solution to the master problem.The column generation pricing problem aims at finding feasible routes with a negative reduced cost. In this section, we provide a formulation for this problem.The reduced cost of arc (i, j) ∈ A can be defined as(4)c¯ij={cij−αi,∀i∈P,cij,∀i∈N∖P,where αi, i ∈ P, are the dual variables associated with constraints (2).For each node i ∈ N, let Tibe a variable representing the time at which the service begins at node i. For each arc (i, j) ∈ A, let xijbe a binary variable equal to 1 if and only if arc (i, j) ∈ A is used in the current route. For each request i ∈ P and each stack m ∈ M, letzimbe a binary variable equal to 1 if and only if item i is loaded on stack m in the current route, and letQimbe a variable representing the total load of stack m after leaving node i. In order to define the multi-stack policy, we introduce the following notation. LetR=(i1,…,iρ)be a path such that i1 ≠ 0 andiρ≠2n+1and letN(R)={i1,…,iρ}be its corresponding set of nodes. Let(mie)i∈N(R)be an assignment (indexed by e) to the stacks in M of the items picked up or delivered in R, i.e.,mie∈Mindicates the stack to which item i is assigned. Some of these assignments might yield an infeasible path with respect to the multi-stack policy. Denote by I(R) the set of infeasible item-to-stack assignments for path R. LetRbe the set of all paths R that can have infeasible assignments, i.e., such that I(R) ≠ ∅. The pricing problem for the PDPTWMS can then be modeled as(5)minimize∑(i,j)∈Ac¯ijxij(6)subjectto∑j∈N|(i,j)∈Axij−∑j∈N|(n+i,j)∈Axn+i,j=0,∀i∈P,(7)∑j∈Px0j=1,(8)∑j∈N|(j,i)∈Axji−∑j∈N|(i,j)∈Axij=0,∀i∈P∪D,(9)∑i∈Dxi,2n+1=1,(10)∑μ=1ρ−1xiμ,iμ+1+∑i∈P∩N(R)zimie+∑i∈D∩N(R)zi−nmi−ne≤2|N(R)|−2,∀R=(i1,…,iρ)∈R,e∈I(R)(11)∑j∈N|(i,j)∈Axij=∑m∈Mzim,∀i∈P,(12)Qjm≥Qimxij+qjxijzjm,∀m∈M,(i,j)∈Asuchthatj∈P,(13)Qjm≥Qimxij+qjxijzj−nm,∀m∈M,(i,j)∈Asuchthatj∈D,(14)max{0,qi}zim≤Qim≤min{Q,Q+qi}zim,∀i∈P,m∈M,(15)Tj≥(Ti+tij)xij,∀(i,j)∈A,(16)w̲i≤Ti≤w¯i,∀i∈N,(17)Ti+ti,n+i≤Tn+i,∀i∈P,(18)xij∈{0,1},∀(i,j)∈A,(19)zim∈{0,1},∀i∈P,m∈M.The objective function (5) minimizes the sum of reduced costs. Constraints (6) ensure that the pairing constraints are respected, i.e., the pickup and delivery nodes of a request are visited in the same route. Constraints (7)–(9) define a path structure for each route. More specifically, constraints (7) and (9) ensure that each route starts and ends at the depot, while (8) are flow conservation constraints. The multi-stack policy is imposed through constraints (10) which are stated through infeasible path inequalities. We note that Côté, Archetti, et al. (2012) have proposed an alternate way of formulating these constraints. Constraints (11) state that each picked up item must be assigned to exactly one of the stacks. Constraints (12) and (13) compute the load variables according to the arcs used in the solution and constraints (14) ensure that the capacity of each stack is respected. Constraints (15) and (16) compute the time variables and ensure that the time windows are respected. Constraints (17) impose the precedence constraints, i.e., for each request i the pickup node must be visited before the delivery node. The model is non-linear because of constraints (12)–(15), but can be linearized through the use of large constants – big-M – (see Ropke et al., 2007; Côté, Archetti, et al., 2012).Note that constraints (10) can be replaced by the smaller set of constraints(20)∑μ=1ρ−1xiμ,iμ+1≤|N(R)|−2,∀R=(i1,…,iρ)∈R*,whereR*⊆Ris a subset of infeasible paths such that, for each path, there exists no feasible assignment of the items to the stacks. Solving model (5)–(9), (11)–(19), (20) could yield an infeasible solution given the values taken by thezimvariables at optimality, i.e., these values would provide an infeasible item-to-stack assignment for at least one path inR∖R*,but there exists an alternative feasible solution having the same cost with differentzimvalues.Our first branch-price-and-cut algorithm fully enforces the multi-stack policy in the pricing problem. In this section, we first present path relaxations and labeling algorithms for the corresponding pricing problem. We then discuss valid inequalities for the PDPTWMS and branching strategies.The pricing problem is an elementary shortest path problem with pickups and deliveries, time windows, capacity constraints, and multi-stack policy. It can be solved through a labeling algorithm. A label stores information about a partial path starting at the origin node and ending at some node η. Each element stored in a label is called a component. Starting from an initial label E0 at the origin node 0, a labeling algorithm propagates labels toward the destination node with resource extension functions. To avoid enumerating all feasible paths, some labels are eliminated through a dominance criterion.The pricing problem can be relaxed by allowing cycles in paths, that is, a request can be completed more than once. These relaxations usually yield weaker master problem lower bounds. Paths with cycles cannot be part of a feasible integer solution, hence branching ensures that the final solution contains only elementary paths.Sections 3.1.1 and 3.1.2 describe labeling algorithms for the elementary and non-elementary versions of the pricing problem, respectively.The first version of the constrained shortest path problem respects the elementarity constraints. The ideas presented in this section are non-trivial extensions of those initially proposed by Cherkesly et al. (2015) for the PDPTWL. For a given label E, the following components are stored:•η(E), the end node of the partial path;t(E), the start of service time at node η;c(E), the cumulated reduced cost;U(E), the set of unreachable requests;li(E), ∀i ∈ P, the load in the stack under item i ∈ P (including its own load);Sij(E),∀i,j∈P,the relative positions of items i and j in a given stack;Cij(E),∀i,j∈P,the concurrent presence of items i and j in different stacks.A request i ∈ P is said to be unreachable if i has already been visited on the partial path, or if traveling directly from η to i violates the time window constraints at node i ∈ P. For a given label E, letR(E)=(0,i1,i2,…,iρ=η(E))be the partial path represented by this label. Then(21)U(E)={i∈P|i∈R(E)}∪{i∈P|t(E)+tη(E),i>w¯i}.The relative position of two items i, j ∈ P indicates that item i is on top of item j in the same stack as j, i ≠ j, or that item i is in the vehicle ifi=j,that is(22)Sij(E)={1ifi=janditemiisinthevehicle,1ifitemiisinthesamestackasitemjandontopofit,0otherwise.Moreover, for any two items i, j ∈ P, we need to know whether both are simultaneously onboard and in different stacks, or not, that is(23)Cij(E)={1ifitemsiandjaresimultaneouslyinthevehiclebutnotinthesamestack,0otherwise.This new notation is as powerful as the notation proposed by Cherkesly et al. (2015) for the single-stack case, but is better suited for the multi-stack variant because it eliminates the symmetry between the M identical stacks.Given a label E, its extension along an arc (η(E), j) ∈ A is allowed if one of the following three conditions holds:(24)0<j≤nandj∉U(E),(25)n<j≤2nandSj−n,j−n(E)=1andSi,j−n(E)=0,∀i∈P∖{j−n},(26)j=2n+1andSii(E)=0,∀i∈P.Condition (24) ensures that if j is a pickup node, then it must not have been previously visited, and must be reachable with respect to time windows. Condition (25) ensures that if j is a delivery node, then its corresponding item must be on top of one of the stacks, i.e., the item is in the vehicle and there is no item on top. Condition (26) ensures that if j is the destination node, then all the picked items on the path must have been delivered. Together these three conditions ensure that each request will be completed at most once for any complete path from 0 to2n+1.If the extension to a pickup node is allowed, i.e., condition (24) is fulfilled, then several new labels may result. Indeed, one new label per stack in use can be created. Thus, for a given label E, we define(27)H(E)={i∈P|Sii(E)=1andSji(E)=0,∀j∈P∖{i}}as the top items in the stacks. In particular,|H(E)|is the number of stacks currently in use. If this number is less than the number of stacks, i.e.,|H(E)|<M,then there exists at least one empty stack. In such a case, in order to allow the addition of an item on top of an empty stack, an additional auxiliary top itemh=0is created. We define(28)H0(E)={H(E)∪{0}if|H(E)|<M,H(E)otherwise.In summary, for the extension to a pickup node j ∈ P, one new label Ehfor eachh∈H0(E)is created. If j is a delivery node, j ∈ D, a single new label Ehforh=j−nis generated. If j is a pickup node and all stacks are empty, i.e.,H(E)=∅,a single new label Ehis created for the auxiliary top itemh=0. Thus, given a new label E, an arc (η(E), j), and a top itemh∈H0(E)for j ∈ P, orh=j−nfor j ∈ D, the extension is computed as follows:(29)η(Eh)=j,(30)t(Eh)=max{t(E)+tη(E),j,w̲j},(31)c(Eh)=c(E)+c¯η(E),j,(32)U(Eh)={U(E)∪{j}∪{i∈P|t(Eh)+tη(Eh),i>w¯i}ifj∈P,U(E)∪{i∈P|t(Eh)+tη(Eh),i>w¯i}ifj∈D,(33)lk(Eh)={lh(E)+qmifj∈P,j=k,0ifj∈D,k=j−n,lm(E)otherwise,∀k∈P,(34)Smi(Eh)={1ifj∈P,j=k,Shi(E)=1,1ifj∈P,k=i=j,0ifj∈D,j−n=k,Smi(E)otherwise,∀i,k∈P,(35)Cmi(Eh)={1ifj∈P,j=k,Chi(E)=1,1ifj∈P,i=j,Chm(E)=1,0ifj∈D,j−n=korj−n=i,Cmi(E)otherwise,∀i,k∈P.Eq. (33) states that if j is a pickup node, then the load under it must be the total load in the chosen stack, plus its own load; if j is a delivery node, then the load under itemj−nis 0 because itemj−nis no longer in the vehicle, and otherwise the load under each item remains the same. Eq. (34) updates the positions of items that are in the same stack. If j is a pickup node, then it must be on top of all nodes below h, on top of node h, and must be in the vehicle. If j is a delivery node, then there are no more items belowj−n. The other positions are unchanged. Eq. (35) updates the information about items that are simultaneously in the vehicle but are not in the same stack. If j is a pickup node, then it must be separated from all nodes that are not in the same stack as node h, and if j is a delivery node then there are no more items simultaneously onboard withj−nand in different stacks. The other positions remain the same.A new label Ehis kept if it respects the time windows and the capacity constraints, that is, if(36)t(Eh)≤w¯j,(37)lh(Eh)≤Q.Finally, a label E1 dominates a label E2 if(38)η(E1)=η(E2),(39)t(E1)≤t(E2),(40)c(E1)≤c(E2),(41)U(E1)⊆U(E2),(42)Sij(E1)≤Sij(E2),∀i,j∈P,(43)Cij(E1)≤Cij(E2),∀i,j∈P.Conditions (38)–(42) constitute a valid dominance criterion for the single-stack case, i.e., the PDPTWL (see Cherkesly et al., 2015), if the delivery triangle inequality holds. Note that the definition ofc¯ijin formula (4) does not necessarily ensure the delivery triangle inequalityc¯ij+c¯jk≥c¯ikfor all delivery nodes j ∈ D. In this situation, Ropke and Cordeau (2009) propose a procedure to transform an arbitrary cost matrix into a cost matrix that satisfies the delivery triangle inequality. We apply the same procedure before solving the pricing problem.However, the single-stack dominance criterion is not valid for the multi-stack variant. In fact, without conditions (43), the dominance criterion would not be valid because items in the same stack for label E2 could be in different stacks for label E1. In such a case, the possible extensions of label E2 could be infeasible for label E1 with respect to capacity constraints, yielding wrongly dominated labels. Fig. 2 depicts such a case whereQ=2,q1=1,q2=1,andq3=2. Fig. 2a and b illustrates the configuration of the vehicle for labels E1 and E2, respectively. One can see that item 3 cannot be loaded with the first configuration, but can be with the second one. In that case, conditions (38)–(42) are respected. Conditions (43) are then necessary to allow a proper dominance criterion.Proposition 3.1Conditions(38)–(43)constitute a valid dominance criterion wheneverc¯ijsatisfies the delivery triangle inequality.The proof is similar to that of Proposition 3 in Cherkesly et al. (2015). We show that for every feasible completion of E2 there exists a feasible completion of E1 with no greater reduced cost. Let r be a path extending R(E2) to node2n+1such that (R(E2), r) is feasible with respect to time windows, elementarity constraints, pickup and delivery constraints, capacity constraints and the multi-stack policy. If no such path exists, then clearly one can remove label E2. Let r′ be the path obtained from r by removing the deliveries for each request i ∈ P withSii(E1)=0andSii(E2)=1. Because (R(E2), r) is feasible with respect to elementarity constraints, and pickup and delivery constraints, then so is (R(E1), r′). Because the triangle inequality is assumed for travel times and (R(E2), r) is feasible with respect to the time windows, then so is (R(E1), r′). The capacity constraints for each stack are not violated because items in different stacks for E1 are also in different stacks for E2, and items in the same stack for E1 are also in the same stack for E2, thus the capacity constraints are respected on (R(E1), r′). The multi-stack policy is not violated because the order in which the deliveries are performed on (R(E1), r′) is the same as on (R(E2), r). Because (R(E2), r) is feasible, then so is (R(E1), r′). Because the delivery triangle inequality holds for the reduced cost component c, the cost of r′ does not exceed that of r. Thus, c(E1) ≤ c(E2) implies that the cost of (R(E1), r′) is at most equal to that of (R(E2), r). Hence, label E1 dominates label E2.□The second version of the constrained shortest path problem allows paths to contain cycles under the following two conditions:(i)a pickup cannot be performed again before its corresponding delivery has been completed;the precedence constraints for every request must be respected.In this version of the algorithm, a label E stores the components η(E), t(E), c(E), li(E), i ∈ P,Sij(E),andCij(E),i,j∈P. The extension of a label E along arc (η(E), j) is allowed if E and j satisfy condition (25), (26), or(44)0<j≤nandSjj(E)=0.A label Ehis then created for each top itemh∈H0(E)using the extension function (29)–(31) and (33)–(35). Condition (44) relaxes condition (24) by allowing cycles to occur while forbidding to pick up the same request twice without delivering it in the meantime. The resulting label Ehis kept if it satisfies the time windows (36) and the capacity constraints (37) at node j. If the delivery triangle inequality holds, then the following dominance criterion is valid: a label E1 dominates a label E2 if conditions (38)–(40), and (42)–(43) are respected.The reader can easily adapt the arguments of Proposition 3.1 for this version of the shortest path problem.We now present valid inequalities commonly used to solve the PDPTW and applicable to the PDPTWMS. These are 2-path cut inequalities, rounded capacity inequalities, and subset-row inequalities. We also present a family of cuts based on the branching on the number of vehicles. These inequalities are added within the master problem. For the sake of conciseness, we omit the discussion about the impact on the reduced cost of adding such inequalities (see Desaulniers, Desrosiers, & Spoorendonk, 2011). These inequalities are used for both branch-price-and-cut algorithms.If the number of vehicles is fractional, two branches are created:∑r∈Ωyr≤⌊∑r∈Ωy˜r⌋and∑r∈Ωyr≥⌈∑r∈Ωy˜r⌉,where(y˜1,…,y˜|Ω|)is the computed fractional solution of the master problem. Because we first minimize the number of vehicles, the number of vehicles used in the solution of the master problem is a lower bound on the number of vehicles used in the optimal integer solution. In this case, the inequality(45)∑r∈Ωyr≥⌈∑r∈Ωy˜r⌉is added to the master problem and replaces the branching on the number of vehicles.Kohl, Desrosiers, Madsen, Solomon, and Soumis (1999) have introduced 2-path cuts in the context of the vehicle routing problem with time windows (VRPTW). These were later shown to be valid for the PDPTW (see Ropke & Cordeau, 2009). Let S⊆P ∪ D be a subset of nodes that cannot be served by a single vehicle and letδ(S)={(i,j)∈A|i∈S,j∈N∖S}represent the set of arcs exiting set S. Then the inequality(46)∑r∈Ω∑(i,j)∈δ(S)bijryr≥2is valid, wherebijris a constant equal to the number of times arc (i, j) ∈ A is used in route r. Identifying a subset of nodes that cannot be served by a single vehicle means determining whether the corresponding pickup and delivery traveling salesman problem with time windows is feasible. Because this is an NP-complete problem (see Savelsbergh, 1985), the separation of violated 2-path cuts is achieved by means of a greedy heuristic (see Ropke & Cordeau, 2009).The rounded capacity inequalities are often used for the vehicle routing problem (VRP), the VRPTW, and the PDPTW (see, e.g., Naddef and Rinaldi, 2002, Chap. 3, Cordeau, 2006; Ropke et al., 2007) and have been adapted to the PDTSPMS (see Côté, Archetti, et al., 2012). Let S⊆P ∪ D be a subset of nodes and let ξ(S) be a lower bound on the number of vehicles needed to visit all nodes in S. Then, the inequality(47)∑r∈Ω∑(i,j)∈δ(S)bijryr≥ξ(S)is valid forξ(S)=max{1,⌈q(π(S))SQ⌉,⌈−q(σ(S))SQ⌉},where SQ is the total capacity of the vehicle,π(S)={i∈P|i∉S,n+i∈S}denotes the set of predecessors of S andσ(S)={n+i∈D|i∈S,n+i∉S}denotes the set of successors of S. The lower bound on the load of the vehicles entering S isq(π(S))=∑i∈π(S)qi,and the lower bound on the load of the vehicles leaving S isq(σ(S))=∑n+i∈σ(S)qi. These inequalities are separated by means of a heuristic enumerative procedure (see Ropke et al., 2007).The subset-row inequalities were introduced by Jepsen, Petersen, Spoorendonk, and Pisinger (2008) for the VRPTW and are a special case of the clique inequalities. These inequalities are the rank-1 Chvátal–Gomory inequalities defined as(48)∑r∈Ω⌊1χ∑i∈Sair⌋yr=⌊|S|χ⌋,∀S⊆P,2≤χ≤|S|,where S is a subset of pickup nodes. As in Jepsen et al. (2008) and Desaulniers, Lessard, and Hadjar (2008), we focus on the inequalities defined for subsets of three customers because these can be efficiently separated. These subset-row inequalities can be rewritten as(49)∑r∈ΩSyr≤1,∀S⊆Psuchthat|S|=3,where ΩS⊆Ω is the subset of routes completing at least two requests in S. Because handling the dual prices of the active subset-row inequalities in the subproblem can be highly time-consuming, we limit their usage by generating them only in the first two levels of the branching tree and adding at most 50 cuts at once.In a branch-price-and-cut algorithm, branching is used to obtain integer feasible solutions and should be compatible with the column generation process, especially with the algorithm used to solve the pricing problem. With the dominance criterion (38)–(43), the removal of arcs must preserve the delivery triangle inequality (see Ropke & Cordeau, 2008). Consequently, we propose to branch on the outflow of node subsets (see Naddef & Rinaldi, 2002). This branching strategy adds constraints to the master problem, yielding additional dual prices to be incorporated into the objective function of the pricing problem (see Desaulniers et al., 2011). In this branching strategy, a subset of nodes S is selected such thatf(S)=∑r∈Ω∑(i,j)∈δ(S)bijry˜ris as far as possible from the nearest integer, where f(S) is the total outflow for the set S of the computed fractional solution of the master problem. Two branches are then created by adding the following constraints to the master problem associated with each branch:(50)∑r∈Ω∑(i,j)∈δ(S)bijryr≤⌊f(S)⌋,(51)∑r∈Ω∑(i,j)∈δ(S)bijryr≥⌈f(S)⌉.The exploration of the enumeration tree is achieved through a best-first strategy.This second branch-price-and-cut algorithm deals with the multi-stack policy partly in the set partitioning formulation and partly in the master problem. This pricing problem is easier to solve, but the extended set partitioning formulation is weaker yielding worse lower bounds. As Cherkesly et al. (2015) did in their hybrid branch-price-and-cut algorithm for the PDPTWL, we solve the shortest path problem under relaxed multi-stack constraints, i.e., the LIFO policy must be respected for the last κ items of each compartment. An ejection process is therefore needed: when a pickup node is visited, its corresponding item is put on top of a stack; if the height of the stack exceeds κ, the lowest item is ejected from the stack but is kept in the corresponding compartment. Thus, a compartment can contain stacked items, for which the extension of the partial path needs to respect the LIFO policy, and ejected items, for which the extension of the partial path does not need to respect the LIFO policy. There is no given ordering for the delivery of the ejected items, but these can only be delivered if there are no more stacked items in the compartment. Corresponding infeasible path inequalities are added to the master problem when infeasible multi-stack routes are used in a linear relaxation solution. Fig. 3presents an example, forκ=1,in which the path must respect the LIFO policy for the items in gray. The vehicle contains two compartments and each compartment has a corresponding stack with a maximal size of one item. Note that item 2 is ejected from the second stack in Fig. 3c and item 3 is ejected from the second stack in Fig. 3d because the maximal size is reached.We now describe the modifications to the labeling algorithm, presented in Section 3, that we have implemented to handle this variant. The valid inequalities and the branching decisions used are those of Sections 3.2 and 3.3.In the elementary version of the problem, a label E stores the components η(E), t(E), c(E), U(E), li(E), i ∈ P,Cij(E),andSijEP(E),i, j ∈ P.SijEP(E)is a relaxation ofSij(E)that considers an ejection process. For a given label E,SijEP(E)is defined as(52)SijEP(E)={1ifi=janditemiisinthevehicle,1ifitemsiandjareinthesamestackandiisontopofj,1ifitemsiandjareinthesamecompartment,iisinthestack,andjisejected,0ifitemsiandjareinthesamecompartmentandbothareejected,0otherwise.That is, if two different items i, j ∈ P, i ≠ j, are in the same vehicle compartment, request i is in the stack and nodei+was visited after nodej+,thenSijEP(E)=1andSjiEP(E)=0. If two different items i, j ∈ P, i ≠ j, are in the same vehicle compartment but none of them are in the stack, i.e., if both have been ejected, thenSijEP(E)=SjiEP(E)=0.The extension of a label E along an arc (η(E), j) ∈ A is allowed if it satisfies one of the three conditions, (24)–(26), whereSij(E)is replaced withSijEP(E),∀i, j ∈ P.DefiningH(E)as in Eq. (27),H(E)contains all items that can be delivered, i.e., those that have not been ejected from a stack and are on top of a stack, and those that have been ejected from a stack and are not under an item for which the multi-stack policy needs to be respected. In order to have at most one extension per compartment, the top items are defined as the items for which one of these two conditions is respected:(i)the item is in the stack and no item is on top of it;the item is not in the stack, and is in a compartment that has no item in its stack. One arbitrary item is kept to represent each non-empty compartment. In the following, we choose the item with the smallest index.We defineC(E)as the set of top items for the relaxed multi-stack policy which can be computed as(53)C(E)={i∈H(E)|Cij(E)=1,j<i,j∈H(E)}.Note that if|C(E)|<M,an additional auxiliary top item is added in order to allow loading on top of empty stacks. Thus, we define(54)C(E)0={C(E)∪{0}if|C(E)|<M,C(E)otherwise.The extension of a label E along an arc (η(E), j) will create a new label Eh,∀h∈C(E). Note that in some cases only one label is created (as explained in Section 3.1.1). For each label Eh,O(Eh)is defined as the open requests in the vehicle that have been ejected from the stack, i.e., requests that are currently onboard but for which the extension of the label does not need to respect the multi-stack policy.O(Eh)is computed as(55)O(Eh)={i∈P|Chi(E)=0and(∑j∈PSjiEP(E)≥κor∃j∈P∖{i}suchthatSjjEP(E)=1,Cij(E)=0,SijEP(E)=SjiEP(E)=0)}.Eq. (55) states that i ∈ P is an open request with respect to top itemh∈C(E)0if i and h are in the same vehicle compartment, and if there are at least κ items between the positions of i and h or if i has already been ejected from the stack.The components of label Ehare set with Eqs. (29)–(32), (35) and(56)lk(Eh)={lh(E)+qjifj∈P,j=k,∑i∈O(Eh)qiifj∈P,0ifj∈D,k=j−n,lm(E)otherwise,∀k∈O(Eh),(57)SmiEP(Eh)={1ifj∈P,j=k,∀i∈PsuchthatShiEP(E)=1,1ifj∈P,j=k,∀i∈O(Eh),1ifj∈P,i=k=j,0ifj∈P,0ifj∈D,j−n=k,∀i∈P,SmiEP(E)otherwise.∀k,i∈O(Eh),Eq. (56) replaces Eq. (33); if two requests are in the same compartment but none of them are in the stack, their total loads will be the same. Eq. (57) updates the positions of the items in the compartment. If j is a pickup node then it is on top of the stack, i.e., on top of all other items in the compartment, either in the stack or ejected. If the stack has reached its maximal size, then no order is imposed among all ejected items. If j is a delivery node, then they are no more items linked toj−n. Furthermore, label Ehis kept if it respects the time window constraints (36) and the capacity constraints (37).Finally, a label E1 dominates a label E2 if conditions (38)–(41), (43) and(58)SijEP(E1)≤SijEP(E2),∀i,j∈P,hold.Proposition 4.1Conditions(38)–(41),(43)and(58)constitute a valid dominance criterion wheneverc¯ijsatisfies the delivery triangle inequality.The proof is similar to that of Proposition 3.1. We show that for every feasible completion of E2 there exists a feasible completion of E1 with no larger reduced cost. Let r be a path extending R(E2) to node2n+1such that (R(E2), r) is feasible with respect to time windows, elementarity constraints, pickup and delivery constraints, capacity constraints and relaxed multi-stack policy. If no such path exists, then clearly one can remove label E2. Let r′ be the path obtained from r by removing the deliveries for each request i ∈ P withSiiEP(E1)=0andSiiEP(E2)=1. Because (R(E2), r) is feasible with respect to elementarity constraints, and pickup and delivery constraints, then so is (R(E1), r′). Because the triangle inequality is assumed for travel times and (R(E2), r) is feasible with respect to the time windows, then so is (R(E1), r′). The capacity constraints for each stack are not violated because items in different stacks for E1 are also in different stacks for E2, and items in the same stack for E1 are also in the same stack for E2, thus the capacity constraints are respected on (R(E1), r′). The order in which the deliveries are performed on (R(E1), r′) is the same as the order on (R(E2), r), i.e., each item that is in a stack for E1 is also in the stack for E2, and each item that has been ejected for E1 can be ejected or not for E2. No ejected item for E2 can be in a stack for E1. Thus, the relaxed multi-stack policy is not violated. Because (R(E2), r) is feasible, then so is (R(E1), r′). Because the delivery triangle inequality holds for the reduced cost component c, the cost of r′ does not exceed that of r. Thus, c(E1) ≤ c(E2) implies that the cost of (R(E1), r′) is at most equal to that of (R(E2), r). Hence, label E1 dominates label E2.□The reader can easily adapt this procedure to the non-elementary version of the shortest path problem.When solving the shortest path problem with the labeling algorithm presented in the previous section, we might find a path for which the multi-stack policy is not respected. Fig. 4a and b presents a path and a configuration of the vehicle found with the relaxed multi-stack policy when settingκ=0. This configuration does not respect the multi-stack policy, but the items can be rearranged as in Fig. 4c in order to respect it. Thus, this path is feasible. Fig. 5a and b illustrates a path and a configuration of the vehicle found with the relaxed multi-stack policy when settingκ=0. In such a case, no rearrangement of the items is possible, and this path is infeasible.In order to find out whether a path is feasible with respect to the multi-stack policy even if its current configuration is not, Côté, Archetti, et al. (2012) proposed solving a bin packing problem. Instead, our algorithm solves a shortest path problem with multi-stack policy. The labeling algorithm presented in Section 3 is applied on the reduced graph containing only the arcs used in the current path. If a solution is found, a rearrangement is possible. Otherwise, the path is infeasible and its corresponding infeasible path inequality (20) is added to the RMP. Thus, these inequalities can be reformulated as(59)∑r∈Ω(∑μ=1ρ−1biμ,iμ+1r)yr≤|N(R)|−2,∀R=(i0,…,iρ)∈R*.These constraints are separated through an exact enumerative procedure. For every path in a given optimal solution of the master problem, several of these constraints can be violated. The sequential search is then carried out on each active route r ∈ Ω with yr> 0, and the first identified violated inequality is added to the master problem. Note that the dual variables of (59) affect the reduced cost of the arcs along the corresponding path, but we leave out the details for conciseness reasons.The two branch-price-and-cut algorithms just described were tested on a set of PDPTWMS instances derived from an instance of the TSPLIB. In this section, we report the computational results obtained for these PDPTWMS instances. The instances are solved by considering one, two, and three stacks. All tests were performed on a Linux computer equipped with an Intel(R) Core(TM) i7-3770 processor (3.4 gigahertz). The algorithms were implemented using the GENCOL library using CPLEX 12.4.0.0 to solve all restricted master problems.To test our algorithms, we have generated 198 PDPTWMS instances from the a280 of the TSPLIB, and 440 PDPTWMS instances from the brd14051, d18512, fnl4461, and nrw1379 instances of the TSPLIB by following the ideas of Carrabs, Cerulli, et al. (2007), Carrabs, Cordeau, and Laporte (2007), Cordeau et al. (2010) for the TSPPDL, and of Côté, Archetti, et al. (2012) for the PDTSPMS. In all these instances, we assume thattij=cij,∀(i,j)∈A. Two classes of instances were tested. In the first class, C1, each item has a unit demand, and the total capacity of a vehicle is 6. In the second class, C2, the demand of each item is a random number between 3 and 9, and the capacity of a vehicle is 24 for the one- and two-stack variants, and 27 for the three-stack variant.For the instances derived from the a280 instance, we have generated and tested for both classes a total of 99 instances in which the number of requests ranges from 25 to 75, i.e., the number of nodes ranges from 51 to 151. For an instance with2n+1nodes, we have kept the first2n+1nodes from the a280 instance of the TSPLIB. For each request, a pickup and a delivery node have been randomly paired, and the time windows have been randomly generated. Three time window horizons were tested: (1) settingwi≤ 500, ∀i ∈ P andwi≤ 1000, ∀i ∈ D, (2) settingwi≤ 1000, ∀i ∈ P andwi≤ 1200, ∀i ∈ D, and (3) settingwi≤ 1500, ∀i ∈ P andwi≤ 2000, ∀i ∈ D. The three time horizons are denoted by 500–1000, 1000–1200, and 1500–2000 in the following. For each time window horizon, three different time window lengths were tested, i.e., 15, 30, and 45.For each of the instances derived from the brd14051, d18512, fnl4461, and nrw1379 instances, we have generated and tested for each class a total of 55 instances in which the number of requests ranges from 25 to 75, i.e., the number of nodes ranges from 51 to 151. For an instance with2n+1nodes, we have kept the first2n+1nodes from the original TSPLIB instance. For each request, a pickup and a delivery node have been randomly paired, and the time windows have been randomly generated. One time window horizon was tested by settingwi≤ 3000, ∀i ∈ P andwi≤ 4000, ∀i ∈ D, which is denoted by 3000–4000 in the following. Five different time window lengths were tested, i.e., 45, 60, 75, 90, and 120.In all instances, we first aim to minimize the number of vehicles. To this end, a fixed cost of 100,000 is imposed on each arc (0, j) ∈ A with j ∈ P.Table 1presents the number of instances solved optimally for each algorithm using the elementary shortest path problem. A time limit of 7200 seconds (2 hours) was imposed for the solution of each instance. The algorithms are denoted as follows: BPC MS (branch-price-and-cut algorithm with multi-stack feasible paths) and BPC Relaxed (branch-price-and-cut algorithm with relaxed multi-stack paths). For the latter, we also specify the value of κ. We have tested different values of κ and report those withκ=0andκ=2.For all the instances, any number of stacks and instance class, BPC Relaxed withκ=0is outperformed by BPC MS and by BPC Relaxed withκ=2. In addition, for both classes, BPC MS solves more instances than BPC Relaxed withκ=2,i.e., 485 and 763 instances are solved with BPC MS for classes C1 and C2, while 469 and 759 instances are solved with BPC Relaxed withκ=2for classes C1 and C2. We generally observe that all instances solved with BPC Relaxed withκ=2are also solved with BPC MS. Therefore, we will only present detailed computational results for the BPC MS algorithm. We have also tested an adaptation of the ng-path relaxation proposed by Baldacci, Bartolini, Mingozzi, and Roberti (2010), Baldacci, Mingozzi, and Roberti (2011) for the VRP and adapted by Cherkesly et al. (2015) for the PDPTWL and the non-elementary shortest path problem. Neither of these two relaxations of the pricing problem has a positive impact on the quality of the lower bound or on the computational time. Thus, we do not present these results.For all variants, one can realize that the instances in class C1 are harder to solve than those in class C2. For the instances in class C1, this is probably due to the symmetry between the items, i.e., each item has unit demand.Tables 2–7 present summarized results for the PDPTWMS with one, two, and three stacks, respectively, with the BPC MS algorithm when solving the elementary version of the subproblem in all three cases. Detailed computational results are presented in Appendix A. We present the following information: NbSolved the number of instances solved to optimality within the prescribed time limit; Sec., the average CPU time in seconds; Gap (percent), the average integrity gap in percentage computed as(z*−z̲)/(z*),where z* is the optimal solution value andzis the lower bound at the root node before adding any cuts; Veh, the average minimal number of vehicles; and maxItem, the average maximal number of items simultaneously in a vehicle. All these averages are computed over the solved instances. Furthermore, for each class of instances, we report in the row Weighted average the averages for the class weighted according to the number of instances solved for each set of instances with a specified time window length and horizon.Tables 2, 4, and 6present the results obtained for the a280 instances. In each table we present, for each instance class, summarized results on each set of 11 instances with a specified time window length and horizon. For each of these 11 instances, the number of nodes ranges from 25 to 75. In each table, the first column indicates the width of the length of the time windows (15, 30 or 45), and the time window horizon, i.e., 500–1000, 1000–1200, and 1500–2000. For example, w15-500–1000 refers to instances that have a time window length of 15 and a time window horizon 500–1000.Tables 3, 5, and 7 present the results obtained for the brd14051, d18512, fnl4461, and nrw1379 instances. In each table we present, for each instance class, summarized results on each set of 44 instances with a specified time window length. For each of these 44 instances, the number of nodes ranges from 25 to 75. In each table, the first column indicates the width of the length of the time windows (45, 60, 75, 90 or 120), and the time window horizon, i.e., 3000–4000. For example, w45-3000–4000 refers to all instances that have a time window length of 45 and a time window horizon 3000–4000.We first observe that for both classes of instances and independent of the number of stacks, generally solving instances with larger time windows and with larger time window horizons is harder. In fact, for the a280 instances, 136, 111, and 89 instances are solved with time window lengths of 15, 30 and 45, respectively, and 122, 123, and 91 instances are solved with the time window horizons of 500–1000, 1000–1200, and 1500–2000, respectively. For the brd14051, d18512, fnl4461, and nrw1379 instances, 212, 191, 188, 166, and 154 instances are solved with time window lengths of 45, 60, 75, 90, and 120, respectively.Second, for instances with one, two, and three stacks, instances of class C1 are harder to solve. For the one-stack variant, 291 instances in class C1 and 316 instances in class C2 are solved, for the two-stack variant, 110 instances in class C1 and 238 instances in class C2 are solved, and, for the three-stack variant, 84 instances in class C1 and 209 instances in class C2 are solved. This is probably due to the symmetry between the unit demand items.Third, solving instances in classes C1 and C2 with one stack yields better gaps than with two and three stacks. For class C1, the gaps are on average 0.50 percent, 4.80 percent, and 3.13 percent for the a280 instances, and 0.22 percent, 2.46 percent, and 1.43 percent for the other instances for the one-, two-, and three-stack variants, respectively. For class C2, the gaps are on average 0.46 percent, 3.59 percent, and 4.04 percent for the a280 instances, and 0.19 percent, 2.62 percent, and 2.05 percent for the other instances for the one-, two-, and three-stack variants, respectively. This is probably due to a lower number of feasible paths with one stack, which also explains why solving instances with one stack yields on average more vehicles in a solution. For class C1, the average number of vehicles is 16.86, 8.74, and f7.67 for the a280 instances, and 22.84, 12.66, and 11.22 for the other instances for the one-, two-, and three-stack variants, respectively. For class C2, the average number of vehicles is 17.64, 10.35, and 9.44 for the a280 instances, and 23.23, 15.14, and 13.97 for the other instances for the one-, two-, and three-stack variants, respectively.Fourth, better gaps are yielded for the instances in class C1 with three stacks compared to those with two stacks, i.e., 3.07 percent and 4.80 percent on average for the a280 instances, and 1.43 percent and 2.46 percent on average for the other instances, respectively. We can also observe that the average number of vehicles with three stacks is lower than with two stacks, i.e., 7.67 and 8.74 vehicles on average for the a280 instances, and 11.22 and 12.66 on average for the other instances, respectively. Interestingly, not all feasible solutions with respect to two stacks are feasible with respect to three stacks because the stack capacities differ. In the proposed instances, each vehicle has a capacity of six: with two stacks, each stack has a capacity of three; and with three stacks, each stack has a capacity of two. Thus, from a managerial perspective, it is interesting to see that having more stacks in a vehicle does not necessarily reduce the total costs.Finally, the a280 instances in class C2 with two stacks yield better gaps than those with three stacks, i.e., 3.59 percent and 4.04 percent on average, respectively. On the contrary, better gaps are derived for the other instances in class C2 with three stacks compared to those with two stacks, i.e., 2.05 percent and 2.62 percent on average, respectively. All the instances in class C2 with two stacks yield more vehicles than those with three stacks, i.e., 10.35 and 9.44 vehicles on average for the a280 instances, and 15.14 and 13.97 on average for the other instances, respectively. In the proposed instances, a vehicle with two stacks has a total capacity of 24 and a vehicle with three stacks has a total capacity of 27. Thus, an increase of 12.5 percent of the total vehicle capacity decreases, on average, the number of vehicles by 9.6 percent for the a280 instances, and by 8.4 percent for the other instances, and increases the maximum number of items by 10.8 percent for the a280 instances, and by 4.1 percent for the other instances which seems coherent.Table 8 presents computational results showing the impact of the number of stacks on the total traveled distance, the number of vehicles used, and the maximum number of items simultaneously in a vehicle. These results are only shown for the a280 instances because similar results are obtained for the brd14051, d18512, fnl4461, and nrw1379 instances. Detailed computational results on all the instances are presented in Appendix B. In the table, we compare the results obtained with one stack to the results obtained with two and three stacks. We present the following information: Δ Dist (percent), the average relative difference in the total traveled distance, computed as(Dist2−Dist1)/(Dist1)and(Dist3−Dist1)/(Dist1),whereDistj,j={1,2,3},is the distance with j stacks; Δ Veh (percent) , the average relative difference in the number of vehicles, computed as(Veh2−Veh1)/(Veh1)and(Veh3−Veh1)/(Veh1),whereVehj,j={1,2,3},is the number of vehicles with j stacks; and Δ maxItem (percent), the average relative difference in the maximum number of items simultaneously in a vehicle, computed as(maxItem2−maxItem1)/(maxItem1)and(maxItem3−maxItem1)/(maxItem1),wheremaxItemj,j={1,2,3},is the maximum number of items simultaneously in a vehicle with j stacks.For instances in class C1, the total capacity of the vehicle is 6 independently of the number of stacks. Increasing the number of stacks from one to two and from one to three decreases the total traveled distance by an average of 28.6 percent and 32.3 percent, decreases the number of vehicles used by an average of 39.0 percent and 42.9 percent, and increases the maximum number of items simultaneously in a vehicle by an average of 35.2 percent and 44.4 percent, respectively.For the class C2, the total capacity of the vehicle is 24 for instances with one and two stacks, and 27 for instances with three stacks. Even though the capacity is not the same for the three-stack variant, we present the impact of the number of stacks on the results to show the general trend. We first observe that increasing the number of stacks from one to two and from one to three decreases the total traveled distance by an average of 21.8 percent and 27.2 percent, respectively. It also decreases the number of vehicles used by an average of 35.0 percent and 39.1 percent, and increases the maximum number of requests simultaneously in a vehicle by an average of 15.8 percent and 31.4 percent, respectively.Thus, for both classes C1 and C2, increasing the number of stacks from one to two and from one to three has a positive impact on the total traveled distance and on the minimal number of vehicles needed. Interestingly, the additional gain of three stacks is significantly smaller than increasing the number of stacks from one to two.

@&#CONCLUSIONS@&#
We have introduced the PDPTWMS and described two column generation algorithms to solve it. An ad hoc labeling algorithm for shortest path problems with multiple stacks is proposed and implemented. Moreover, we have adapted the hybrid branch-price-and-cut algorithm of Cherkesly et al. (2015) for the PDPTWL to the PDPTWMS. In addition, we have introduced a new notation to represent a stack in a vehicle which can be adapted to variants of the PDPTW with loading constraints such as the PDPTW with handling costs. Instances involving up to 75 requests and three stacks were solved to optimality within 2 hours of computational time. On the PDPTWL instances, Cherkesly et al. (2015) had shown that, for their instances, the BPC Relaxed seemed to outperform the BPC MS. On our new instances, we obtain the opposite result, i.e., the BPC Relaxed is outperformed by the BPC MS. Our results also show that increasing the number of stacks from one to two has a positive impact on the total traveled distance and on the minimal number of vehicles used, but increasing it from two to three does not yield a significant additional gain.