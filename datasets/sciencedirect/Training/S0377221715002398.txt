@&#MAIN-TITLE@&#
An improved mathematical formulation for the blocks relocation problem

@&#HIGHLIGHTS@&#
Corrects the linear programming model BRP-II.Introduces an alternative model BRP-II-A.Presents a novel pre-processing approach.Improves computational results for small and medium-sized instances.

@&#KEYPHRASES@&#
Blocks relocation problem,Container relocation problem,Integer programming,

@&#ABSTRACT@&#
This paper deals with the blocks relocation problem (also called container relocation problem). First, it corrects the binary linear programming model BRP-II presented in Caserta et al. (2012). Second, it improves the initial model formulation by removing superfluous variables, tightening some constraints, introducing a new upper bound and applying a pre-processing step to fix several variables. Computational results show the efficiency of the improved model for small and medium sized instances.

@&#INTRODUCTION@&#
The blocks relocation problem (BRP) occurs at two-dimensional stacking areas with homogeneous blocks where blocks have to be retrieved in a given order. As an example, consider container terminals where blocks refer to containers and the stacking area corresponds to the yard. Two types of moves are distinguished: retrieval actions (= move a block from the inside to the outside of the stacking area) and relocation actions (= move a block within the stacking area). The next block to be retrieved is called the target block. Only the uppermost block of each stack can be directly accessed. Thus, relocations of blocks within the stacking area become necessary if the target block is located below other blocks. Given the initial layout of the stacking area the objective is to retrieve all blocks in the given order with a minimum number of relocations.This problem finds applications in a broad range of storage systems, e.g., container storage at bays (see above; in this case it is also called container relocation problem) or vessels, handling of pallets, boxes or steel plates in a warehouse. Fig. 1 illustrates the general blocks relocation problem. Different variants of this problem exist. First, priorities may be given among single blocks or among groups of blocks. Second, all blocks may be relocated or only blocks above the target block may be relocated (Assumption A1).Caserta, Schwarze, and Voß (2012) prove that the blocks relocation problem with and without Assumption A1 is NP-hard. Several heuristic solution approaches exist which are mainly based on branch and bound procedures or tree search (Caserta, Schwarze, & Voß, 2009; Caserta & Voß, 2009; Caserta, Voß, & Sniedovich, 2011; Forster & Bortfeldt, 2012; Jin, Zhu, & Lim, 2015; Jovanovic & Voß, 2014; Kim & Hong, 2006; Rei & Pedroso, 2012; Ünlüyurt & Aydin, 2012; Wu, Hernández, & Ting, 2010; Wu & Ting, 2010; Zhang, Guo, Zhu, Lim, & Cheang, 2010; Zhu, Qin, Lim, & Zhang, 2012).Only few exact solution approaches exist. Lee and Hsu (2007) present different integer linear programming models based on a multi-commodity flow problem with a set of side constraints for several stacking problems including the container relocation problem. Caserta et al. (2012) present two binary programming models for the problem with and without Assumption A1. The models contain state variables to represent the bay layout and movement variables to represent retrievals and relocations of blocks. Petering and Hussein (2013) introduce an alternative formulation. Binary variables indicate the stack in which a block is in and real variables its relative position to the top of this stack. Tang, Zhao, and Liu (2012) deal with the plate shuffling problem. Binary variables indicate the stack in which a block is in, if two blocks are in the same stack and if one block is above another one. They minimize the number of relocations and the traveled crane distance. For a survey on the blocks relocation problem as well as related problems see Caserta, Schwarze, and Voß (2011) and Lehnfeld and Knust (2014).This paper is based on the model BRP-II presented in Caserta et al. (2012) where priorities are given among single containers and where only blocks above the target block may be relocated (Assumption A1). In this case, a unique number is assigned to each block which indicates the given retrieval sequence. At any time, the current target block is the block currently in the stacking area with the smallest number. Section 2 recalls the variables used in BRP-II and corrects the model reported in Caserta et al. (2012). Section 3 improves the corrected model further by removing superfluous variables and by reformulating some constraints. Section 4 introduces a new upper bound on the number of relocations and a pre-processing step to fix several variables. Section 5 reports computational results and shows that the modified model is suitable for small and medium sized instances improving upon the current state-of-the-art regarding solving the BRP to optimality. Section 6 concludes the paper.We use the notation and variables introduced in Caserta et al. (2012). The stacking area consists of W stacks and H tiers. Each slot within the stacking area is addressed with coordinates (i, j) where i ∈ {1, …, W} and j ∈ {1, …, H}. The initial configuration contains N blocks, labeled 1, …, N. Blocks have to be retrieved in ascending order.BRP-II is formulated with the help of configuration variables bijntwhich define where blocks are located at any given period and of movement variables xijklntand yijntwhich represent relocations and retrievals of blocks in each period.bijnt={1ifblocknisatposition(i,j)atthebeginningofperiodt,0otherwise;xijklnt={1ifblocknisrelocatedfromposition(i,j)toposition(k,l)inperiodt,0otherwise;yijnt={1ifblocknisretrievedfromposition(i,j)inperiodt,0otherwise;Parameters vntindicate if a block is within or outside the stacking area at a given period.vnt={0ifn≥t,1otherwise.The corrected version of BRP-II is stated below. The constraint numbering is as in Caserta et al., 2012 where BRP-II is denoted by Constraints (1)–(3) and (6)–(10). Constraints (1)–(3), (6), (9) and (10) are unchanged. A minor typing error has been corrected in Constraint (7).11t has to start at t = 2 and not at t = 1.Constraint (8) imposes the last-in-first-out (LIFO) order among blocks relocated in the same period. By Assumption A1, each block can be relocated at most once within one period (namely, from the target stack to a different stack). Thus, in the context of the BRP under Assumption A1, LIFO is ensured if the following is satisfied. If a block n is below block n′ in period t, and, if block n is relocated, then block n cannot be below block n′ in period t + 1. Constraint (8) given in Caserta et al. (2012) has a flaw and is corrected in the sequel. The erroneous version of Constraint (8) is given next.1−∑n=1Nxijklnt≥∑n=1N∑j′=j+1H∑l′=l+1Hxij′kl′nt,i,k=1,…,W,j,l=1,…,H,t=1,…N−1This constraint adds an additional (unwanted) restriction to the model: if there is no relocation from (i, j) to (k, l), then only a single relocation is allowed from all slots above (i, j) to all slots above (k, l). Constraint (8′) relaxes the unwanted restriction with the help of a large number M and is presented below. Finally, we add Constraint (A) to represent Assumption A1.minz=∑i=1W∑j=1H∑k=1W∑l=1H∑n=1N∑t=1Nxijklnt(1)∑i=1W∑j=1Hbijnt+vnt=1∀n=1,⋯,N,t=1,⋯,T(2)∑n=1Nbijnt≤1∀i=1,⋯,W,j=1,⋯,H,t=1,⋯,T(3)∑n=1Nbijnt≥∑n=1Nbij+1nt∀i=1,⋯,W,j=1,⋯,H−1,t=1,⋯,T(6)bijnt=bijnt−1+∑k=1W∑l=1Hxklijnt−1−∑k=1W∑l=1Hxijklnt−1−yijnt−1∀i=1,⋯,W,j=1,⋯,H,n=1,⋯,N,t=2,⋯,T(7′)vnt=∑i=1W∑j=1H∑t′=1t−1yijnt′∀n=1,⋯,N,t=2,⋯,T(8′)M(1−∑n=1Nxijklnt)≥∑n=1N∑j′=j+1H∑l′=l+1Hxij′kl′nt∀i=1,⋯,W,j=1,⋯H−1,k=1,⋯,W,l=1,⋯H−1,t=1,⋯,T(9)M(1−∑j=1Hbijtt)≥∑j=1H∑k=1W∑l=1H∑n=1N∑i′≠iWxi′jklnt∀t=1,…,T,i=1,…,W(10)xijilnt=0∀i=1,⋯,W,j=1,⋯,H,l=1,⋯,H,n=1,⋯,N,t=1,⋯,T(A)∑k=1W∑l=1H∑n=1Nxij+1klnt−∑n=1Nbij+1nt+1≥∑k=1W∑l=1H∑n=1Nxijklnt+∑n=1Nyijnti=1,⋯,W,j=1,⋯,H−1,t=1,⋯,TThe objective function minimizes the total number of relocations. Constraint (1) imposes that each block is either within the stacking area or outside. Constraint (2) makes sure that each slot (i, j) is occupied by at most one block. Constraint (3) prevents gaps within stacks. This makes sure that blocks at positions (i, j′) with j′ > j are relocated if a block is retrieved from position (i, j) and that no blocks are relocated to suspended positions. Constraint (6) ensures the consistency of the stacking area over time. It links the layout at period t with the layout at period t + 1 via the executed retrieval and relocations. Constraint (7′) makes sure that each block is retrieved and Constraint (8′) imposes LIFO. Constraint (9) limits relocations to blocks stored in the same stack as the target block. Constraint (10) makes sure that no block is relocated into the stack from which it is retrieved. Note that the combination of Constraints (9) and (10) prohibits the case that a block is moved into the target stack. Moreover, by Constraints (9) and (10), “unproductive” moves are prevented, i.e., moves that relocate a block n from position (i, j) to position (j, i) in period t and then reverse this move within the same period t. Constraint (A) makes sure that a block can only be moved if the block above is relocated. If the block located at position (i, j + 1) is not relocated (i.e., the LHS becomes 0 since bij + 1nt= 1) then no relocation or retrieval is allowed from position (i, j) (i.e., the RHS has to be 0). Note that Constraint (A) together with Constraint (9) ensures that Assumption A1 is satisfied as Constraint (A) prevents relocations if a block is retrieved from (i, j + 1) (xij + 1klnt= 0 and bij + 1nt= 1).A computational study has been carried out for the corrected version of BRP-II on a Linux Server with Intel Xeon Processor X5570 and 32 gigabytes RAM using IBM ILOG CPLEX 12.1. The results correct columns 0–1 IP of Table 1 given in Caserta et al. (2012) (see Table 1 for details). Note that columns H′ and W in Table 1 indicate the size of the stacking area where W gives the number of stacks and H′ gives the number of tiers that are filled with blocks. The maximum number of tiers is then computed as H = H′ + 2. That is, in the initial configuration, each stack has two empty tiers. Column v indicates the instance number ranging from 1 to 5. Average values are reported in the last line of each instance class. Finally, column No gives the optimal solution and column CPU time reports the computational time in seconds. Whenever the optimal solution was not found (or proved) within a time limit of 18,000 seconds (5 hours) we place an asterisk in column CPU time. In this case, the best found solution is provided in column No. If no feasible solution is found within 18,000 seconds, a dash is placed instead.All small problem instances (with up to 15 containers) have been solved within a time limit of 3600 seconds. For medium problem sizes (with up to 24 containers), 53 percent of all instances have been solved to optimality with an extended time limit of 18,000 seconds. However, the performance of the model may be considerably improved with a few modifications as will be demonstrated in the next section.This section presents the model BRP-II-A which is an improved version of BRP-II. We show that some variables and parameters are unnecessary and can be removed. We also tighten some constraints and add some cuts.Let us start with the observation that at each period t = 1, …, T, block n = t has to be retrieved. This implies that at the beginning of period t, only blocks n = t, …, T are in the stacking area and that only blocks n = t + 1, …, T may be relocated. We define variables yijntonly for n = t, variables bijntonly for n ≥ t and variables xijklntonly for n > t. In addition, period T may be excluded from the model since the only remaining block has to be retrieved and no relocations may occur. Blocks may only be relocated from above the target block. Hence, no relocations from tier 1 may occur and we dismiss variables xi1klntwith j = 1.We use variables yijttto impose that block n = t is retrieved at period t and get rid of parameters vntand Constraint (1) and adapt Constraint (7′). We remove Constraint (10) from the model and use the pre-processing step to impose that in period t no block is relocated into the stack from which it has been retrieved in the same period t. The modified model is presented below.∑i=1W∑j=2H∑k=1W∑l=1H∑t=1T−1∑n=t+1Nxijklnts.t.(2)∑n=tNbijnt≤1∀i=1,⋯,W,j=1,⋯H,t=1,⋯,T−1(3)∑n=tNbijnt≥∑n=tNbij+1nt∀i=1,⋯,W,j=1,⋯H−1,t=1,⋯,T(6a)bijnt+1=bijnt+∑k=1W∑l=2Hxklijnt−∑k=1W∑l=1Hxijklnt∀i=1,⋯,W,j=1,⋯H,t=1,⋯,T−1,n=t+1,⋯,N(6b)bijnt−yijtt=0∀i=1,⋯,W,j=1,⋯H,t=1,⋯,T−1,n=t(7′′)∑i=1W∑j=1Hyijtt=1∀t=1,⋯,T−1(8′)M(1−∑n=t+1Nxijklnt)≥∑n=t+1N∑j′=j+1H∑l′=l+1Hxij′kl′nt∀i=1,⋯,W,j=2,⋯H−1,k=1,⋯,W,l=1,…H−1,t=1,…,T−1(A′)∑j′=1j−1yij′tt≥∑k=1W∑l=1H∑n=t+1Nxijklnt∀i=1,⋯,W,j=2,⋯H,t=1,⋯,T−1(B)∑i=1W∑j=2H∑k=1W∑l=1H∑n=t+1Nxijklnt≤UBt∀t=1,⋯,T−1(11)xijklnt∈{0,1}∀i=1,⋯,W,j=2,⋯H,k=1,⋯,W,l=1,⋯H,t=1,⋯,T−1,n=t+1,⋯,N(12)yijtt∈{0,1}∀i=1,⋯,W,j=1,⋯H,t=1,⋯,T−1(13)bijnt∈{0,1}∀i=1,⋯,W,j=1,⋯H,t=1,⋯,T,n=t,⋯,NThe objective function minimizes the total number of relocations. Constraints (2) and (3) are taken from BRP-II and Constraint (6) is divided into Constraints (6a) and (6b) since variables yijttand xijklntare defined for different time periods. Constraint (7′′) makes sure that block t is retrieved at period t. Like in the corrected BRP-II, Constraint (8′) ensures the LIFO policy.Constraint (A′) replaces Constraint (A). It imposes that only blocks above the target block may be relocated (Assumption A1). We add Constraint (B) to impose an upper bound on the number of relocations per period. This upper bound is described in Section 4.1. Please note that if UBtis too small the problem may become infeasible. Constraints (11)–(13) define the reduced variable domains of binary variables.This section presents a new upper bound on the number of relocations per period and a pre-processing step to fix several variables.To determine an upper bound on the number of relocations per period UBt, we use an existing upper bound UB and an existing lower bound LB on the global number of relocations.The upper bound UB is obtained via the heuristic presented in Caserta et al. (2012). Zhu et al. (2012) present a lower bound LB. It is computed from the initial layout of the stack with the help of LBtand LBt +. LBtrepresents the minimum number of relocations needed to retrieve block t. It counts how many blocks n > t are located above block t in the initial layout which have not yet been counted for an earlier block t′ < t. That is, each block is counted at most once when computing LBtfor t = 1, …, T. LBt + represents the minimum number of additional relocations caused in subsequent periods by relocations in period t. It counts how many blocks n have to be relocated to a stack containing blocks n′ < n. LB equals the sum of LBtand LBt + over all periods t. More formally, the computation of LB is given in Algorithm 1 below.We introduce a new upper bound Rtthat represents the maximum number of relocations per period t for which a solution with UB − 1 relocations may exist. Consequently, if this bound is violated for any period t, then exactly UB relocations are needed in an optimal solution.Lemma 1Consider the following equation.(14)Rt=UB−1−∑k=1t−1LBk−∑k=t+1TLBk−∑k=tTLBk+∀t=1,⋯,TIf there exists an optimal solution with at most UB − 1 relocations, then for any optimal solution Rt is an upper bound on the number of relocations in period t, t = 1, …, T .Note that for each instance, a global upper bound UB as well as lower bounds LBtand LBt + can be computed for each period t = 1 to T. We prove by contradiction. Assume there is an optimal solution with UB − 1 relocations and there is a period t for which Rtis exceeded. Let ξtbe the number of relocations in period t, then we have(15)ξt>Rt(16)⇒ξt>UB−1−∑k=1t−1LBk−∑k=t+1TLBk−∑k=tTLBk+(17)⇒ξt≥UB−∑k=1t−1LBk−∑k=t+1TLBk−∑k=tTLBk+=:LBt*The last inequality holds due to integrality of ξt, UB, LBt, and LBt+. Consequently, LBt*is a lower bound on ξt.Now consider the remaining periodst¯≠tin order to compute a lower bound on the total number of relocations in those periods. In periodst¯≠tat least all sure relocations LBt¯have to be carried out. Moreover, for future periodst^>t,indirect relocations LBk+ need to be considered for k ≥ t. Thus,(18)LBt¯*:=∑k=1t−1LBk+∑k=t+1TLBk+∑k=tTLBk+serves as lower bound on the relocations in periodst¯≠t. Summarizing, a lower bound on the total number of relocations is given by(19)LB*=LBt*+LBt¯*=UBThe last equation contradicts the assumption of having an optimal solution with UB − 1 relocations.□We illustrate the computation of Rtwith the example presented in Fig. 2. The heuristic obtained a solution with 5 relocations and we set UB = 5. The figure reports the values of lower bounds LBtand LBt +. We obtain LB = 4. It also shows the resulting values of Rt.The maximum number of relocations per period UBtis also limited by the number of blocks that may be placed above the retrieval block. Since only blocks above the target block may be relocated, at most H − 1 blocks may be relocated per period and(20)UBt=min(Rt,H−1)∀t=1,⋯,TNote that if UBt= min (Rt, H − 1) is used in Constraint (B), the problem may become infeasible. As argued above, UBt= H − 1 cannot be violated in Constraint (B), thus infeasibility can only occur if∑i=1W∑j=2H∑k=1W∑l=1H∑n=t+1Nxijklnt>Rtis given. This inequality is identical to (15) given in the proof of Lemma 1. However, following the reasoning given there no solution with less than UB relocations exists. Thus, the heuristic solution is optimal in this case.We use information provided by the initial layout to fix several variables xijklntand bijntto zero or one. We use (in, jn) to refer to the initial position of block n. Let πnbe the period when block n is removed from its initial position for the first time. Since only blocks above the target block may be relocated, this happens either when the block is retrieved or when it is relocated to free a target block beneath. Let π(i, j) be the period when position (i, j) is empty for the first time. Either the position is empty in the initial layout or when the block initially located there is removed. Equations (21) and (22) define parameters πnand π(i, j) accordingly.(21)πn=minn′|n′isplacedatanyposition(in,1)to(in,jn)(22)π(i,j)={πn+1ifblocknisplacedatposition(i,j),1ifposition(i,j)isemptyWith the knowledge of the initial position (in, jn) for each block n and the information provided by πnandπ(in,jn)we may fix the following variables:•Block n is at position (in, jn) and nowhere else until period πn. No other block n′ may be located at position (in, jn) until period πn.binjnnt=1∀n,in,jn,t≤πnbijnt=0∀n,i≠in,j≠jn,t≤πnbinjnn′t=0∀n,n′≠n,in,jn,t≤πnPosition (in, jn) is occupied by block n until period πn. Hence, no other block n′ < n may be retrieved from position (in, jn) prior to period πn. No other block n′ may be relocated from or to position (in, jn) until period πn.yinjntt=0∀n,in,jn,t<πnxinjnkln′t=0∀n,n′≠n,in,jn,k,l,t≤πnxijinjnn′t=0∀n,n′≠n,i,j,in,jn,t≤πnIf πn< n, block n is relocated for the first time in period πn. It is not relocated prior to period πnor from a position other than (in, jn) in period πn.xijklnt=0∀n,i,j,k,l,t<πnxijklnt=0∀n,i≠in,j≠jn,k,l,t=πnIf πn= n, block n is never relocated and retrieved from its initial position (in, jn) in period t = n.xijklnt=0∀n,i,j,k,l,t<n|n=πnyijtt=0∀n,i≠in,j≠jn,t=n|n=πnIf πn= n, only blocks in stack inand above jnmay be relocated in period πn(Assumption A1).xijkln′t=0∀n,i≠in,j,k,l,n′,t=πn|n=πnxinjkln′t=0∀n,in,j≤jn,k,l,n′,t=πn|n=πnIf πn= n, position (in, jn) and all positions above have to be empty in period n + 1. No containers can be retrieved or relocated from these positions in period πn+ 1.binjn′t=0∀n,in,j≥jn,n′,t=πn+1|n=πnyinjtt=0∀in,j≥jn,t=πn+1|n=πnxinjkln′t=0∀n,in,j≥jn,k,l,n′,t=πn+1|n=πnWe may fix further variables by using the fact that at each period exactly one block is retrieved. Consequently, the number of blocks remaining in the stacking area at the beginning of period t is given by Nt= N + 1 − t. The number of blocks in the stacking area limits the maximum stack height:•At period t, tiers at height h > Ntmay not be occupied and no containers can be retrieved or relocated from these positions:bijnt=0∀t,i,j>Nt,nyijtt=0∀t,i,j>Ntxijklnt=0∀t,i,j>Nt,k,l,nAt period t, relocation blocks can only be put into tiers h ≤ Nt + 1 = Nt− 1:xijklnt=0∀t,i,j,k,l>Nt−1,nWe also include the fact that no block may be relocated into the stack from which it has to be retrieved (equivalent to Constraint (10) in BRP-II).•Relocations xijklntwith i = k may not existxijilnt=0∀i,j,l,n,tWe test our model on the instances introduced by Caserta et al. (2012). They designed several instance sets H′–W where W indicates the number of stacks and H′ the number of containers per stack (identical for all stacks). In the initial configuration, each stack has two empty tiers and the maximum number of tiers H is set to H = H′ + 2. Each set consists of 40 instances which represent different initial configurations of N = W · H′ blocks.This section discusses the difficulty of these instances and presents the results for BRP-II-A. It also discusses the benefit of the new upper bound and of the pre-processing step.Table 2 provides some indicators to evaluate the difficulty of the used instances. It displays the average number or relocations for the lower bound LB (Avg. LB) and the upper bound UB (Avg. UB) presented in Section 4.1. It also indicates the average gap (Avg. gap) between the lower and the upper bound and the number of trivial instances (Nb. trivial) where the upper bound equals the lower bound.Gaps between lower and upper bounds depend mainly on stack height H and remain similar for different widths W. Bounds are tight for small and medium instances and less tight for bigger instances. For 244 instances, the lower bound equals the upper bound and the heuristic solution is optimal.Experiments are carried out on a computer with Intel(R) Xeon(R) CPU clocked at 3.07 gigahertz, 12.0 gigabytes RAM and operating with Windows 7 Professional. We use Cplex 12.5 to solve the binary programming model and limit the run time to 60 minutes per instance. Unfortunately, we could not compare our results to other existing linear programming models since Petering and Hussein (2013) deal with a slightly different problem (without Assumption A1) and Tang et al. (2012) do not publish results of their linear programming model.Table 3shows the results in an aggregate way: it indicates the number of trivial (LB = UB) and non-trivial (LB < UB) instances per set. The model was only executed for non-trivial instances. The table displays the number of instances that were solved to optimality and the average solution times of these instances. It also displays the number of instances that could not be solved because of time or memory limits. CPU times are given by average values as well as standard deviation.Results show that the model solves all instances up to instance set 5–4 in reasonable time. Most instances of sets 5–5 and 5–6 and several instances of sets 5–7 and 6–6 can be solved, but require longer solution times. Some instances of set 5–7 and most instances of sets 5–8 to 10–10 cannot be solved, mostly due to limited memory.Table 4 analyzes the benefit of the new upper bound Rton the number of relocations per period t. For each instance set, it reports the value of H − 1 and the average value of Rtover all periods t = 1, …, T − 1 for non-trivial instances. It also displays the percentages of how often Rtis tighter, as tight and less tight than H − 1.Results show that the bound Rtis tight if the gap between the lower bound and the upper bound is small. For instance sets 3–3 to 3–8, Rtis tighter than H − 1 for almost all periods. For instance sets 4–4 to 5–4, it is still tighter than H − 1 for 60–70 percent of the periods. For bigger instances, H − 1 is tighter for all instances.Table 5 illustrates the benefit of the pre-processing step. It indicates the number of binary variables in the model with and without the pre-processing step as well as the number of variables removed by the pre-processing step in absolute numbers and percentages. It also displays the number of non-trivial instances solved for both models.Without the pre-processing step the number of variables can be computed from the values of W, H, N and T.22The following variables are added to the model:yijttfor i = 1, …, W, j = 1, …, H, t = 1, …, T − 1, bijntfor i = 1, …, W, j = 1, …, H, t = 2, …, T, n = t, …, N and xijklntfor i = 1, …, W, j = 2, …, H, k = 1, …, i − 1, i + 1, …, W, l = 1, …, H, t = 1, …, T − 1, n = t + 1, …, N.The number of variables that can be fixed during pre-processing depends on the initial layout of the stacking area. The table reports average values for each instance set. The figures show that the pre-processing step removes 65–89 percent of the variables. With fewer variables, less memory space is needed and more instances with more than 25 containers can be solved if the pre-processing step is applied. However, the number of variables for bigger instances remains impractical even if pre-processing is applied.Table 6 illustrates the improvement concerning computational effort when applying the pre-processing step. More detailed, CPU times are given as averages and as standard deviations. This comparison is only provided up to instance class H′ = 5, W = 6 as larger instances have not been solvable without the pre-processing step. It has to be noticed that there are cases where the average running time increases if pre-processing is applied. See for instance H′ = 4, W = 7 where the average CPU time increased from 83.5 to 90.1. To understand this effect, it has to be considered that with pre-processing, a larger number of instances can be solved. This includes instances that require increased computational times and that have not been solved without pre-processing due to time limits. For a fair comparison, results on the pre-processing are added to Table 6 that relate only to instances that have been solvable without pre-processing, see column “inst. solv. (No PP)”. For instance, for H′ = 4, W = 7 the average running time is then given as 23.6 and improves 83.5 which was obtained without pre-processing on the same data set. The column ‘Δ time (percent)’ gives the percental decrease of average running time if the pre-processing step is applied. This figure is computed based on identical data sets, i.e., compares ‘No PP’ and ‘With PP’ only on instances solvable without PP. For H′ = 5, W = 5, this figure is given in parentheses, as there is a single instance in this instance set that has been solved only without pre-processing and thus the instance sets for the comparison do not coincide.

@&#CONCLUSIONS@&#
