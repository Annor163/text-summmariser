@&#MAIN-TITLE@&#
Conservative allocation models for outbound containers in container terminals

@&#HIGHLIGHTS@&#
Two new “conservative” allocation models are proposed.The two proposed models outperform the original “optimistic” model.A rollout algorithm is proposed to tackle the large-scale problems.

@&#KEYPHRASES@&#
Container terminals,Dynamic programming,Location assignment,Simulation,

@&#ABSTRACT@&#
This paper examines location assignment for outbound containers in container terminals. It is an extension to the previous modeling work of Kim et al. (2000) and Zhang et al. (2010). The previous model was an “optimistic” handling way and gave a moderate punishment for placing a lighter container onto the top of a stack already loaded with heavier containers. Considering that the original model neglected the stack height and the state-changing magnitude information when interpreting the punishment parameter and hid too much information about the specific configurations for a given stack representation, we propose two new “conservative” allocation models in this paper. One considers the stack height and the state-changing magnitude information by reinterpreting the punishment parameter and the other further considers the specific configurations for a given stack representation. Solution qualities for the “optimistic” and the two “conservative” allocation models are compared on two performance indicators. The numerical experiments indicate that both the first and second “conservative” allocation models outperform the original model in terms of the two performance indicators. In addition, to overcome computational difficulties encountered by the dynamic programming algorithm for large-scale problems, an approximate dynamic programming algorithm is presented as well.

@&#INTRODUCTION@&#
In container terminals, seeking a proper yard location for a newly arriving outbound container is an important issue. It is a common practice that the heavier containers are loaded earlier than the lighter ones during the loading operations. Therefore, a relocation movement generally occurs when a lighter container is stacked on the top of a heavier one. A proper location-assignment strategy or policy can avoid burying the heavier containers underneath and reduce relocation movements for the upcoming loading operations.To place a newly arriving container onto a stack, the following three decisions at different levels need to be made: (1) allocating yard blocks or sub-blocks to the outbound containers destined for each arriving vessel; (2) allocating yard bays to the containers of the same group (i.e., the containers of the same length, destined for the same destination port and the same vessel); (3) assigning a yard location, within the range of a single yard bay, to each newly arriving container. This paper is concerned about the lowest-level decision. For the higher-level decisions, please refer to Kim and Park (2003), Zhang, Liu, Wan, Murty, and Linn (2003), Lee, Chew, Tan, and Han (2006), Han, Lee, Chew, and Tan (2008), Zhang, Zhang, Zheng, and Miao (2011), Jiang, Lee, and Chew (2012), Yu and Qi (2012) and the papers therein.Kozan and Preston (2006) integrated container transfer model with container location model. In that paper, the models were evaluated by the transfer time between the storage location and the destined vessel. The related research can be found in Preston and Kozan (2001) and Kozan and Preston (1999). Dekker, Voogd, and Asperen (2006) used a simulation method to compare random stacking with category stacking by the number of relocation movements. Kang, Ryu, and Kim (2006) attempted to accommodate all realizations of container arrivals by a stacking strategy, which was also evaluated by the number of relocation movements via simulation. Chen and Lu (2012) proposed a hybrid sequence stacking algorithm and compared it with a random stacking algorithm and a vertical stacking algorithm. Jang, Kim, and Kim (2013) suggested a genetic algorithm to determine the storage location for each arriving container in order to minimize the expected number of relocation movements.Similar to the above papers, Kim, Park, and Ryu (2000) and Zhang, Chen, Shi, and Zheng (2010) also used the number of relocation movements to evaluate the stacking strategy but the difference is that an analytical model rather than (meta-) heuristic algorithms were used to generate the feasible yard location (or the stacking priority sequence called in the referenced papers) for the newly arriving container. This paper is an extension to Kim et al. (2000) and Zhang et al. (2010). The difference between them is that a punishment coefficient, for placing a lighter container onto the top of a stack already loaded with heavier containers, was treated “optimistically” in the previous work while it is treated relatively “conservatively” in this study. In particular, considering that the original model neglected the stack height and the state-changing magnitude information when interpreting the punishment parameter, and hid too much information about the specific configurations for a given stack representation, we propose two new “conservative” allocation models in this paper. One considers the stack height and the state-changing magnitude information by reinterpreting the punishment parameter and the other further considers the specific configurations for a given stack representation. These two new allocation models may lead to better solutions. That is the motivation of this paper. In addition, to overcome computational difficulties encountered by the dynamic programming algorithm for large-scale problems, an approximate dynamic programming algorithm is also presented.In addition, container pre-marshaling (reposition), which is closely pertaining to the location assignment for arriving containers, is another hot research topic. Given a yard layout and a sequence that containers are loaded onto a ship, Lee and Hsu (2007) formulated an integer programming model to reposition the containers to ensure that no extra relocations are needed during the loading operation. For the similar problem, Lee and Chao (2009) proposed a heuristic which consists of a neighborhood search process, an integer programming model and three minor subroutines; Kim and Hong (2006) proposed a branch-and-bound algorithm and a heuristic rule based on dynamic programming results; Caserta, VoB, and Sniedovich (2011) presented a corridor method inspired algorithm; Zhu, Qin, Lim, and Zhang (2012) investigated iterative deepening A* algorithms using new lower bound measures and heuristics; and Huang and Lin (2012) proposed two labeling algorithms for two relocation problems.The remainder of this paper is organized as follows: The original model is presented in Section 2; the two “conservative” allocation models are presented in Section 3, followed by an approximate dynamic programming algorithm in Section 4; the comparisons among models are presented in Section 5; and the conclusions are drawn in the last section.The definitions related to the model are presented as follows:Stage: the total number of empty slots in a yard bay under consideration. The example as shown in Fig. 1is in stage 7, as its total number of empty slots is 7.State: the state of a yard bay which consists of the combination of the number of empty slots in each stack and the combination of the representation of each stack. In particular, in the original model the representation of a stack is represented by the heaviest weight group of its loaded containers. When a stack is full, the stack is conventionally represented as “0” no matter what containers it contains. When a stack is totally empty, it is represented as “*”. Stacks are sorted in the decreasing order of the number of empty slots. When several stacks have the same number of empty slots, the one with the heavier weight group is placed in front of the others. For example, the yard bay as shown in Fig. 1, which has a bay pattern with 6 stacks, 4 tiers and 3 weight groups (heavy (H), medium (M) and light (L)), has a state represented as (221110 LLHHM0) according to the aforementioned rules.The notations related to the model are presented as follows:s: the number of stacks in a yard bay.t: the number of tiers in a stack.N: the total number of stages (not including the stage with zero empty slot) which is equal tos×t.n: the stage number, that is, the number of empty slots.G: the set of weight groups. The elements in G are indexed in the decreasing order of their weight groups.Xn: the input state of the nth stage.kn: the weight group of an arriving container at stage n.pn(kn): the probability that a newly arriving container is with weight groupkn. It is assumed that the probability does not change during the whole receiving process.Dn: the stack number assigned to an arriving container at stage n (a decision variable).rn(Xn,Dn,kn): the punishment coefficient for assigning a newly arriving container with the lighter weight groupknto a heavier stackDnwhen the input state isXn. In particular, in the original model this punishment coefficient is equal to 1 when a lighter container is placed onto a heavier stack and 0 otherwise.tn(Xn,Dn,kn): the state transfer function that mapsXntoXn-1when a newly arriving container with weight groupknis assigned to stackDn.The decision process is shown in Fig. 2, from which we see that a decision (Dn) is made at each input state (Xn) after we know the weight group (kn) of the newly arriving container, with consideration of the impact of the output state (Xn-1) on the subsequent stacking for the remaining empty slots. The objective function is to minimize the total punishment ofrn(Xn,Dn,kn), which is formulated as follows:(1)fn(Xn)=∑knpn(kn)minDnrn(Xn,Dn,kn)+fn-1(Xn-1),n=1,2,…,Nandf0(X0)=0Based on Eq. (1), the optimal solution can be calculated from the last stateX0backwards to the first stateXN. For the detailed computational process, please refer to the examples provided in Kim et al. (2000).The total state size of the original model can be precisely calculated as follows:(2)∑n=1N∑i=1|E(s,t,n)||W(Ei(s,t,n),G)|where|-|represents the cardinality of set-andE(s,t,n)represents the set of the combination of the number of empty slots in each stack.Ei(s,t,n)is the ith element of setE(s,t,n)and is represented as (e1,e2,…,es), whereejrepresents the number of empty slots in stack j subject toej⩾ej+1ande1+e2+,…,+es=n.W(Ei(s,t,n),G)represents the set of the combination of the heaviest weight group in each stack. An element of setW(Ei(s,t,n),G)is represented as (w1,w2,…,ws), wherewjrepresents the heaviest weight group in stack j subject to the following three relationships: (1) ifej=ej+1, thenwjis not lighter thanwj+1; (2) ifej=t, thenwj=*; and (3) ifej=0, thenwj=0.Based on expression (2), the computational complexity of the original model can be estimated by the following theorem:Theorem 1The computational complexity of the original model isO(s2(|G|t)s+1).The size of setE(s,t,n)can be estimated byO(ts)and the size of setW(Ei(s,t,n),G)can be estimated byO(|G|s). There areN=ststages to go through to fully fill a yard bay and therefore the total state size can be estimated byO(st(|G|t)s). For each state, there are|G|types of container arrivals and for each type of arrivals there are at most s possible stacks to consider. Assume that the computational time for obtaining the value ofrn(Xn,Dn,kn)is a constant whenXn,Dnandknare given. Then, the total number to computern(Xn,Dn,kn)isO(st(|G|t)s·|G|s). Therefore, the computational complexity of the original model isO(s2(|G|t)s+1). □As presented previously,rn(Xn,Dn,kn)represents the punishment coefficient for assigning a newly arriving container with lighter weight groupknto a heavier stackDnwhen the input state isXn. Thern(Xn,Dn,kn)values for the stack pattern witht=4and|G|=3are shown in Table 1, from which we see that the differences betweenrn(Xn,Dn,kn)for all stack components is within 1 for the original model, which means a moderate punishment is given to place a lighter container onto the top of a stack already loaded with the heavier containers. That is why we call the original model an “optimistic” allocation model. In the following, we will introduce two new “conservative” allocation models by reinterpretingrn(Xn,Dn,kn)and discriminating the stack representation, respectively.Reinterpretingrn(Xn,Dn,kn)is motivated by the following two shortcomings of the original interpretation ofrn(Xn,Dn,kn). Firstly, the height of the stack on which the newly arriving container is to be placed had not been considered. That is, when a container of a lighter weight groupknis placed onto the top of a heavier stack, no matter how high the stack has already been,rn(Xn,Dn,kn)is set as 1. In fact, the lighter containers are desired to be placed as low as possible so that more upper locations can be reserved for the upcoming heavier containers. Secondly, the changing magnitude of the stack state had not been considered. That is, when a container of a heavier weight groupknis placed onto the top of a lighter stack, no matter how much the weight state of the stack has increased,rn(Xn,Dn,kn)is set as 0. In fact, the weight state of a stack is desired to be increased as little as possible, due to the fact that the relocation probability of a stack is increased when the weight state of the stack is increased.To overcome the two shortcomings mentioned above, we need to propose a new model, for which the additional notations are given as follows:e: the number of empty slots in a stack, which ranges from 0 to t.w: the heaviest weight group of a stack. Whene=0,wis set as 0, and whene=t,wis set as “*”. Then,Dncan be represented by (e,w).α: the punishment coefficient for placing a lighter container onto the top of a heavier stack,α∈[0,1].β: the punishment coefficient for increasing the stack weight group by placing a heavier container onto the top of a lighter stack,β∈[0,1].A new measure way forrn(Xn,Dn,kn)is proposed as follows:(3)rn(Xn,Dn,kn)=α∗(t-e+1),ifkn<w(4)rn(Xn,Dn,kn)=β∗(kn-w)∗(e-1),ifkn⩾wwherekn<w(kn⩾w) represents a newly arriving container with weight groupknis lighter (not lighter) than the heaviest weight group represented by w of stackDn, and (kn-w) represents the index difference betweenknand w. It is implicitly assumed that the empty stack has the same weight group as the lightest weight group in set G. Expression (3) gives a heavier punishment for placing a lighter container onto a higher and heavier stack by multiplying(t-e+1)which represents the tier on which the newly arriving container is to be placed. Expression (4) gives a heavier punishment for increasing the weight group of a lower stack by multiplying(e-1)which represents the number of tiers above the newly arriving container. Thern(Xn,Dn,kn)values for the stack pattern witht=4and|G|=3are shown in the P1 columns in Table 1 whenα=1andβ=0.2, from which we see that thern(Xn,Dn,kn)values are equal to or larger than those by the original model. That is why it is called a “conservative” allocation model.With the new interpretation ofrn(Xn,Dn,kn), the dynamic programming model as shown in (1) is still valid. The computational processes are similar to those illustrated in Kim et al. (2000). The partial solutions of the P1 model for the bay pattern withs=6,t=4and|G|=3, with the equal probability for each weight group, are shown in Table 2.Another shortcoming of the original model is that too much information has been hidden in the original stack representation. For example, a “2,H” stack has 5 configurations as shown in Fig. 3. When a newly arriving container with weight group “L” is placed onto the top of this stack,rn(Xn,Dn,kn)is set 1 no matter which specific configuration is occurred. Maybe discriminating them can produce better solutions. That is the motivation of this section.Enumerating all stack configurations is not viable due to a long computational time. Instead, this paper proposes a relatively simple state representation which still includes two parts. The first part is still the combination of the number of empty slots in each stack, while the original second part, which is the combination of the heaviest weight group in each stack, is replaced by the combination of the weight group components of each stack. The weight group components of a stack mean the specific number of each weight group in the stack. In order to make this specific number as easy as possible, the three weight groups (heavy, medium, light) are respectively represented as (100, 10, 1) instead of (H, M, L) as in the original representation. Fig. 4shows how to represent a bay by using the new representations of weight groups. For example, (M H L) in stack 4 is represented as 10+100+1=111. When the stack is full, the stack is conventionally represented as “f”. Note that the new state representation is also sorted by the number of empty slots in the decreasing order. If a tie exists, the stack with a greater value of the stacking components is placed in front of the other. Note that in practice, t is normally less than 6. That is why we can represent the three weight groups (H, M, L) respectively as (100, 10, 1). Otherwise, ten “L” containers may be seen as an “M” container if t is allowed to be larger than or equal to 10.Based on the new state representation and the idea introduced in Section 3.1, the punishment coefficientrn(Xn,Dn,kn)in this section will be interpreted as “the number of containers which are heavier than the newly arriving one”. This number can be easily obtained by comparing the weight group of the newly arriving container and the value of the stacking components of the stack. For example, when a container of the lightest weight group (which is represented as 1) is going to be placed onto stack 4 in Fig. 4 (which is represented as 111), the corresponding punishment coefficientrn(Xn,Dn,kn)is equal to the sum of those digits whose positions are higher than that of the newly arriving container, i.e., the sum of the first two digits 1+1=2. By contrast, the punishment coefficientrn(Xn,Dn,kn)for the same situation under the original model is equal to 1. That is to say, we give a heavier punishment for placing a lighter container onto the top of a stack already loaded with more heavier containers. Therefore, when compared to the original model, the P2 model is more likely to place a newly arriving container onto the top of a stack with equal or lighter weight groups.In addition, as we see in Table 1, thern(Xn,Dn,kn)values in the P2 columns discriminate the punishment for different stack components of the same original stack representation. For example, for a stack represented as “2,H” under the original model has only one punishment coefficient for the arriving container “M”, i.e.,rn(Xn,Dn,kn)=1, while it has two different punishment coefficients under the P2 model, i.e.,rn(Xn,Dn,kn)=2for the “HH” stack components andrn(Xn,Dn,kn)=1for the “HM” and “HL” stack components. Since thern(Xn,Dn,kn)values obtained by this rule are equal to or larger than those by the original model. That is why this method is also called a “conservative” allocation model.With the new state representation, the dynamic programming model as shown in (1) is still valid. The computational processes are similar to those illustrated in Kim et al. (2000). The partial solutions of the P2 model for the bay pattern withs=6,t=4and|G|=3, with the equal probability for each weight group, are shown in Table 3.The state size of the P2 model can still be precisely calculated by (2). The definition ofE(s,t,n)keeps the same, while the definition ofW(Ei(s,t,n),G)has to change to represent the set of the combination of the stacking components in each stack, rather than the set of the combination of the heaviest weight group in each stack.Before yieldingW(Ei(s,t,n),G), we have to obtain the stacking components of each stack. LetS(ej,t,G)represent the set of the stacking components of a stack with the number of empty slots equal toej. An element of setS(ej,t,G)is represented ass1×G1+,…,+s|G|×G|G|subject tos1+s2+,…,+s|G|=t-ejwheresgrepresents the number of weight group g in the stack. The elements inS(ej,t,G)are sorted in the decreasing order of the value ofs1×G1+,…,+s|G|×G|G|. Then, an element of setW(Ei(s,t,n),G)can still be represented as (w1,w2,…,ws), with the exception thatwjchanges to represent an element of setS(ej,t,G)subject to the following three relationships: (1) ifej=ej+1, thenwj⩾wj+1; (2) ifej=t, thenwj=*; and (3) ifej=0, thenwj=f.In essence, the role of G in the original model is replaced byS(ej,t,G)in the new bay representation. That is, in the original model, each stack has at most|G|kinds of stacking states, while in the new state representation, each stack has at most|S(ej,t,G)|kinds of stacking states. The computational complexity of the dynamic programming method for the P2 model can be estimated by the following theorem:Theorem 2The computational complexity of theP2model isO(|G|s2t(1+|G|)s+1).The size of setE(s,t,n)can still be estimated byO(ts). The size of setS(ej,t,G)can be estimated byO(t|G|). Then, the size of setW(Ei(s,t,n),G)is estimated byO(t|G|s). There areN=ststages to go through to fully fill a yard bay and therefore the total state size can be estimated byO(st·t(1+|G|)s). For each state, there are|G|types of container arrivals and for each type of arrivals there are at most s possible stacks to consider. Assume that the computational time for obtaining the value ofrn(Xn,Dn,kn)is a constant whenXn,Dnandknare given. Then, the total number to computern(Xn,Dn,kn)isO(st·t(1+|G|)s·|G|s). Therefore, the computational complexity of the P2 model isO(|G|s2t(1+|G|)s+1).□From Theorems 1 and 2, we see that the computational complexities of the dynamic programming models increase exponentially with the parameter sizes. The preliminary experiments also show that solution results cannot be obtained for some test problems with a large size of bay patterns within a reasonable amount of time, not to mention using these results for yard allocation of containers. Therefore, we have to seek other methods to deal with such problems.Rollout algorithm is a widely used approximate dynamic programming solution method which was proposed by Bertsekas, Tsitsiklis, and Wu (1997). Its main idea is to use simulation and function approximation to replace the cost-to-go function, i.e., replacingfn-1(Xn-1)in our problem by an approximation functionf‾n-1(Xn-1). Iff‾n-1(Xn-1)is available and is a “good” approximation offn-1(Xn-1), then stackDnis easy to be chosen for a newly arriving container with weight groupknby using Eq. (1).Developing a rollout solution requires the availability of a base policy that terminates starting from any given state and whose cost-to-go function can be efficiently computed. For our problem, we can build a base policy, for example, based on thern(Xn,Dn,kn)values as shown in Table 1. Specifically, based on the increasing order of thern(Xn,Dn,kn)values for the P1 model, we can build the stacking priority sequences as shown in Table 4. And then for a simulated container-arriving sequence “kn-1,kn-2,…,k1”, its cost-to-go function can be calculated by Eq. (5). Specifically, stackDn-1can be chosen for the first newly arriving containerkn-1by searching the stacking priority sequences andrn-1(Xn-1,Dn-1,kn-1)can be obtained accordingly, and then update the bay state toXn-2and repeat the same process until each arriving container in the arriving sequence has been allocated with a yard location.(5)f∼n-1(Xn-1)=pn-1(kn-1)rn-1(Xn-1,Dn-1,kn-1)+pn-2(kn-2)rn-2(Xn-2,Dn-2,kn-2)+⋯+pn-2(kn-2)⋯p1(k1)r1(X1,D1,k1)=pn-1(kn-1)rn-1(Xn-1,Dn-,kn-1)+f∼n-2(Xn-2),n=2,…,Nandf∼0(X0)=0LetSsizedenote the size of the simulated container-arriving sequences, and then the average value off∼n-1(Xn-1), denoted byf‾n-1(Xn-1), can be used as an approximation tofn-1(Xn-1). Given this approximation, stackDnis easy to be chosen for a newly arriving container with weight groupknby Eq. (6). The flow chart for setting theDnby the rollout algorithm is shown in Fig. 5and the specific procedure is shown as follows:Step 1: Generate the stacking priority sequences.Step 2: Choose a candidate stackDnfor the arriving container with weight groupkn, and calculate the correspondingrn(Xn,Dn,kn)and update the bay state fromXntoXn-1.Step 3: Execute the following simulationSsizetimes and calculate its average valuef‾n-1(Xn-1).Step 3.1:Generate a simulated container-arriving sequence “kn-1,kn-2,…,k1”.Calculatef∼n-1(Xn-1)for the simulated container-arriving sequence by Eq. (5).Step 4: Calculatern(Xn,Dn,kn)+f‾n-1(Xn-1).Step 5: Go back to Step 2 until each candidate stack has been tried once.Step 6: Select the stackDnwith the smallestrn(Xn,Dn,kn)+f‾n-1(Xn-1)for a newly arriving container with weight groupknby Eq. (6).Let us analyze the computational complexity of the rollout algorithm with the base policy generated by thern(Xn,Dn,kn)values of the P1 (original) model. First, it is needed to calculate the number of elements included in a stacking priority sequence. For a stack with at least one empty slot, there exist at most|G|kinds of weight groups (states), and a stack has at most t empty slots. Therefore, the number of element included in a stacking priority sequence isO(t|G|), implying that at mostO(t|G|)times of comparisons are needed to determine a stack for the newly arriving container by searching the stacking priority sequence. Assume that the comparison time is a constant and we are only concerned about the total number to execute these comparisons. Then, we have the following theorem.Theorem 3The computational complexity of the rollout algorithm with the base policy generated by thern(Xn,Dn,kn)values of theP1(original) model isO((st)3Ssize|G|).As shown in Fig. 5, for a simulated container-arriving sequencekn-1,kn-2,…,k1, we should search the stacking priority sequence forn-1times, with each time executing comparisons for at mostO(t|G|)times. There areSsizesimulated container-arriving sequences for each candidate stackDnand there are at most s candidate stacks. Therefore, the total number of comparisons, for settling a stackDnfor a newly arriving container with weight groupkn, is equal toO((n-1)sSsizet|G|). Since there are at mostN=ststages to go through to fully fill a yard bay, the total number of comparisons is∑n=1N=s*t(n-1)sSsizet|G|, that is,O((st)3Ssize|G|). □The computational complexity for the rollout algorithm with the base policy generated by thern(Xn,Dn,kn)values of the P2 model can be calculated in the similar way, with the only exception that there exist at mostt|G|, rather than|G|, kinds of stacking components (states) for a stack with at least one empty slot. Therefore, its computational complexity isO((st)3Ssizet|G|)=O(s3t|G|+3Ssize).In the two previous sections, the computational complexities of the original and P2 models have been analyzed analytically. Theoretically, the computational complexity of the P2 model is|G|s2t(1+|G|)s+1/s2(|G|t)s+1=(t|G|/|G|)stimes that of the original model. In this section, we will compare them further by counting their state sizes under different bay patterns. In addition, we also want to know how much benefit the “conservative” allocation models can bring when compared with the original model. In the following experiments, containers with different weight groups are assumed to have an equal arrival probability. All programs are coded in JAVA and run on a computer with a 3.16-GHz Intel Xeon processor and a 16GB RAM.The numerical results related to state sizes are summarized in Table 5where “R” column represents the ratio of the state sizes between the P2 and the original models. From Table 5, we see that the ratio of the state sizes increases withs,tand|G|. In addition, we also see that the computational time for the original model is within 35s, demonstrating its efficiency. However, solution results cannot be obtained for some bay patterns by the P2 model within 12h, and therefore their applications are limited by the size of bay patterns. Fortunately, the typical bay pattern for outbound containers iss=6,t=4and|G|=3, whose computational time is within 5min.The solution results obtained by the original model and the two “conservative” models as shown in Tables 2 and 3 can be used to indicate the assigned stack numberDnfor a newly arriving container with weight groupkn. Locate each arriving container by repeatedly querying the dynamic programming results until a yard bay is fully stacked. Then, based on the full bay, we can compare these three different models. Therefore, the comparison flow chart applied in this paper is shown in Fig. 6: (1) the first step is to calculate the dynamic programming results; (2) the second step is to generate the container-arriving sequence for comparisons; (3) the third step is to construct a full bay according to the dynamic programming results; (4) the fourth step is to evaluate the full bay just constructed according to some performance indicator.In addition, we also compare these dynamic programming methods with a group-based stacking (GS) heuristic which is similar to the one employed in Chen and Lu (2012). GS means stacking containers onto the stack with the same weight group as much as possible. The specific procedure is shown below:Step 1: Stack the arriving container onto the stack with containers whose weight groups are all the same as that of the arriving container. If a tie exists, place it onto such a stack with the smallest number of containers. If there is no such a candidate stack but there is an empty stack available, place the arriving container onto the empty stack.Step 2: If Step 1 is not satisfied, place the arriving container onto the stack with the heaviest weight group that is the lightest among all. If a tie exists, place it onto such a stack with the smallest number of containers.Step 3: Repeat Steps 1 and 2 for the next arriving container until the bay is fully stacked.As for the container-arriving sequence generated for comparisons, for a bay pattern with s stacks, t tiers and|G|weight groups, there are|G|sttypes of container-arriving sequences, corresponding to the|G|stpermutations. Since|G|stis very large, we are concerned about only two kinds of arriving sequences in the experiments: (1) a set of certain sequences: The firstmin{|G|st,1,000,000}arriving sequences in the decreasing order of weight groups, which can produce the reproducible results because of their certain arrival information; (2) a set of random sequences:min{|G|st,1,000,000}arriving sequences randomly generated according to their weight group probability information. That is to say, the value ofTsizein Fig. 6 is set tomin{|G|st,1,000,000}, and only two sets of arrival sequences are employed for comparison for each bay pattern.As for the performance indicator, we suggest using two indicators: One is a static indicator and the other is a dynamic indicator (Chen & Lu, 2012).The static indicator means “the sum of the tier-number difference between the lighter container and the heavier one stacked underneath”. This indicator counts the number of heavier containers stacked underneath and takes into account how deep they are buried underneath. Here we use Fig. 1 as an example to explain how to calculate it. For stacks 1 and 2 in Fig. 1, all containers are the same and therefore there are no heavier containers stacked underneath the lighter ones; the same situation happens to stack 3; for stack 4, container “H” is stacked underneath containers “M” and “L” whose tier numbers are respectively 2 and 1 higher than that of container “H”, and therefore the total tier-number difference of this stack is 2+1=3; for stack 5, container “M” is stacked underneath container “L” and the tier-number difference between them is 1; and for stack 6, there are no heavier containers stacked underneath the lighter ones. Therefore, the sum of the tier-number difference between the lighter containers and the heavier ones stacked underneath for this yard bay is 3+1=4.The dynamic indicator means the number of relocation movements occurring during the whole loading process by simulation. The loading precedence follows the following three rules sequentially: (1) the heavier container is loaded before the lighter one; (2) the containers on the upper tier are loaded before those on the lower tier; and (3) the stack closer to the vehicle lane is loaded before those farther away. This loading precedence is close to the practice. As to the positioning for the relocated containers, we apply the rules which, proposed in Kim and Hong (2006), choose for the relocated container the stack with the minimally added number of relocation movements. For more details, please refer to Kim and Hong (2006).Before comparing the three allocation models, the two parametersαandβused in (3) and (4) need to be given first. Normally, the first parameter is given a higher priority than the second one. Therefore, in the experiments,αis fixed as 1 andβranges from 0 to 1 with an interval equal to 0.1. The numerical results are shown in Tables 6 and 7where the entries are the ratios of the performance indicator between the P1 and the original models. The smaller the entries, the better the results. From the tables, we see that the performance indicators obtain their smallest values approximately atα=1andβ=0.2, we will setαandβas such numbers in the following experiments.The results of model comparisons are summarized in Tables 8–11where the entries in the R1 (R2, R3) column are the ratios of the performance indicator between the P1 (P2, GS) and the original models. From the four tables we see that the average values of R1 and R2 for both performance indicators under two different container-arriving sequences are all less than 1, demonstrating that the “conservative” allocation models indeed improve the solution quality. From these tables, we also see that the time for constructing a yard bay by querying the dynamic programming results for a relatively large bay pattern withs=7,t=4and|G|=3is within33384.3/1,000,000≈0.033seconds, reflecting the efficiency of using the results of the P2 model in practice. In addition, we also notice that in Table 8 some bay patterns obtain the same results for the static performance indicator. For example, bay patterns {5,4,2}, {6,4,2} and {7,4,2} obtain the same values under each allocation model. The reason is that the number of the container-arriving sequences generated for comparisons, i.e.,min{|G|st,1,000,000}, when compared to|G|st, is so small that the extra stacks are all filled with the heaviest containers and have no impact on the stacking for other stacks.In this section, we only test the performance of the rollout algorithm for the bay patterns for which we have not yet obtained the dynamic programming results by the P2 model in Table 5. Since the average time for fully filling a yard bay of pattern withs=7,t=5and|G|=3is 1.32s whenSsize=300by using the rollout algorithm with the base policy generated by GS, it is computationally prohibited to test it on the set ofmin{|G|st,1,000,000}arriving sequences. Alternatively, we test it on a set of 1000 arriving sequences randomly generated according to their weight group probability information. The numerical results are shown in Table 12where the entries in the “ave.” and “stdev.” columns respectively represent the n-run average and standard deviation of the performance indicators. From the table, we see that the performance of the rollout algorithm approximately improves incrementally withSsize, and it can be shown that there is no significant difference between the 10-run and 30-run results. Although the rollout algorithm does not outperform the original model, it is a reasonable choice as long as we can find a good base policy, especially when the dynamic programming results are unavailable or cost-consumable.

@&#CONCLUSIONS@&#
This paper extends the previous work of Kim et al. (2000) and Zhang et al. (2010) by using two conservatively handling ways. As a consequence, a new interpretation ofrn(Xn,Dn,kn)and a new bay representation are suggested. The original and the two new models are compared on two performance indicators. The numerical experiments indicate that both the first and second “conservative” allocation models outperform the original model in terms of the performance indicators. In addition, considering that solution results cannot be obtained for some test problems with a large size of bay patterns within a reasonable amount of time, we propose an approximate dynamic programming algorithm as well. In this paper, the yard bay allocation for the containers of the same group, and the location assignment for each newly arriving container are treated sequentially. Due to their tight connection, solving them together is an important topic for future study. In addition, the base policy of the rollout algorithm has a significant impact on the performance, and therefore seeking a better base policy is also promising for future study.