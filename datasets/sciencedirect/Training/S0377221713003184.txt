@&#MAIN-TITLE@&#
Finding hypernetworks in directed hypergraphs

@&#HIGHLIGHTS@&#
Theoretical and computational relevance of hypernetworks.Relations to other concepts, namely, flow hypergraphs and dominators.A simple and fast method for finding the s-hypernetwork.Linear time methods for s-hypernetworks in acyclic hypergraphs and directed graphs.A linear time method for the (s, d)-hypernetwork in acyclic hypergraphs.

@&#KEYPHRASES@&#
Graph theory,Directed hypergraphs,Hyperpaths,

@&#ABSTRACT@&#
The term “hypernetwork” (more precisely, s-hypernetwork and (s, d)-hypernetwork) has been recently adopted to denote some logical structures contained in a directed hypergraph. A hypernetwork identifies the core of a hypergraph model, obtained by filtering off redundant components. Therefore, finding hypernetworks has a notable relevance both from a theoretical and from a computational point of view.In this paper we provide a simple and fast algorithm for finding s-hypernetworks, which substantially improves on a method previously proposed in the literature. We also point out two linearly solvable particular cases.Finding an (s, d)-hypernetwork is known to be a hard problem, and only one polynomially solvable class has been found so far. Here we point out that this particular case is solvable in linear time.

@&#INTRODUCTION@&#
In the last two decades, hyperpaths in directed hypergraphs have often been used to devise formal models and solution methods in many application areas; see [1,2,5,7–9] to mention a few. Only recently however, Volpentesta [10] investigated some hypergraph structures, referred to as hypernetworks, defined in terms of sets of hyperpaths. In particular, the s-hypernetwork is the union of all the hyperpaths with origin s, while the (s, d)-hypernetwork is the union of all the hyperpaths with origin s and destination d.Hypernetworks were proposed (see [10] and references therein) in the Virtual Enterprise context, where they provide a formal model for a network of (potentially) cooperating economic actors, capable of responding to specific business opportunities. In general, a hypernetwork represents the relevant part of a hypergraph model, that contains all the feasible solutions while excluding redundant components. On the computational side, working on the hypernetwork rather than the whole hypergraph can lead to substantial savings in execution time. This happens in particular when shortest hyperpaths must be repeatedly computed, possibly a huge number of times [5,6]. For example, the preprocessing phase described in [5, Section 4] actually finds an (s, d)-hypernetwork.As shown in [10], the s-hypernetwork Hscontained in a given hypergraph H can be found in polynomial time. However, the algorithm proposed in [10] requires a rather involved analysis, and has a high computational complexity. Here we present a simple and fast method, whose complexity is at most quadratic in the size of H. We also point out that Hscan be computed in linear time for two well known particular classes, namely, directed graphs and acyclic hypergraphs.Opposed to finding Hs, finding an (s, d) hypernetwork is an NP-hard problem, even in the case of directed graphs [10]. In [10] the problem is shown to be polynomially solvable for the class of stratified hypergraphs, but no complexity bound is provided. Here we point out that stratified hypergraphs actually coincide with acyclic hypergraphs, and we show that this case can be solved in linear time.On the theoretical side, we point out the relation between hypernetworks and other known concepts, namely, flow hypergraphs and dominators. These relations were not observed explicitly in [10], even if similar results were given; note that our treatment is different from, and substantially simpler than, the one in [10].The paper is organized as follows. In the next section we introduce our notation and recall some known results. In Section 3 we deal with finding s-hypernetworks, while in Section 4 we deal with (s, d) hypernetworks. Conclusions, and suggestions for further research, are reported in Section 5.A directed hypergraph is a pair H=(V, E), where V is the set of nodes and E is the set of hyperarcs; a hyperarc is a pair e=(T(e), h(e)) where ∅≠T(e)⊂V and h(e)∈V⧹T(e). Clearly, the hypergraphs considered here contain directed graphs as a subclass.In the literature the term hypergraph is often referred to the broader class introduced by Gallo et al. [1], who define a hyperarc as an ordered pair (X, Y) where X and Y are two disjoint subsets of nodes. The hypergraphs addressed in our paper, where ∣Y∣=1 for each hyperarc, are called B-graphs in [1]; the symmetric case where ∣X∣=1 is referred to as F-graphs. Observe that we obtain an F-graph from a B-graph (and vice versa) by reversing the direction of hyperarcs, i.e., by replacing each pair (X, Y) by (Y, X).A hypergraph H′=(V′, E′) is a sub-hypergraph of (or is contained in) H, denoted as H′⊆H, if V′⊆V and E′⊆E; we write H′⊂H if the inclusion is strict, i.e., H′≠H. For each node u∈V we define the forward star FS(u)={e∈E: u∈T(e)} and the backward star BS(u)={e∈E: h(e)=u}. We let n=∣V∣ and m=∣E∣, while the size of hypergraph H is denoted byS(H)=∑e∈E(|T(e)|+1). In the following we take S(H) as the size of the input problem, assuming n+m=O(S(H)); in particular, we have S(H)⩾max{n, m} if there are no isolated nodes, i.e., FS(u)∪BS(u)≠∅ for each u∈V.A path Pstin a hypergraph H is a sequence of nodes and hyperarcs:Pst=(s=v1,e1,v2,e2,…,eq,vq+1=t),where, for i=1,…,q, vi∈T(ei) and vi+1=h(ei). Node t is connected to node s if a path Pstexists in H. A cycle is a path Pst, where t∈T(e1). A hypergraph is acyclic if contains no cycles. Gallo et al. [1, Section 7.2] show1Actually their results are stated for F-graphs, but the translation to B-graphs is straightforward, due to the symmetry between the two classes.1that some well known properties of acyclic directed graphs hold true for acyclic hypergraphs.Property 1Given a hypergraph H=(V, E):i.H is acyclic if and only if there exists at least one topological order V={v1,v2,…,vn} of the nodes such that, for each e∈E(1)vi∈T(e)∧h(e)=vj⇒i<j.It takes linear time O(S(H)) to check wether H is acyclic and, in that case, to obtain a topological order.The concepts of hyperconnection and hyperpath are captured by the following definitions.Definition 1hyperconnectionA node u∈V is hyperconnected to s in H if either u=s or there exists a hyperarc e∈BS(u) such that each node v∈T(e) is hyperconnected to s.A hyperpath from an origin node s to a destination node t (i.e., an s–t hyperpath) is a minimal hypergraph π=(Vπ, Eπ) where t is hyperconnected to s.In Definition 2 minimality of π means that it does not exist any π′⊂π where t is hyperconnected to s. Clearly, t is hyperconnected to s in H if and only if H contains a hyperpath from s to t. Note that a hyperpath in a directed graph is a simple (i.e., non-looping) directed path. The following properties of hyperpaths are well known, see e.g. [6].Property 2Let π=(Vπ, Eπ) be a hyperpath from s to t:i.π is acyclic;for each u∈Vπ⧹{t} there is at least one e∈Eπsuch that u∈T(e), thus there is at least one u–t path in π;for each u∈Vπ⧹{s} there is exactly one e∈Eπsuch that u=h(e);for each u∈Vπ⧹{t}, π contains exactly one hyperpath from s to u.Given a hypergraph H=(V, E) and a distinguished source node s∈V, we denote by Πsthe set of hyperpaths with origin node s in H, and by Πsdthe set of hyperpaths from s to d≠s in H.Definition 3hypernetworksGiven H=(V, E) and s∈V, the s-hypernetwork Hs=(Vs, Es) is the union of all the hyperpaths in Πs, i.e.,Vs=⋃π∈ΠsVπ,Es=⋃π∈ΠsEπ;for each d∈V, d≠s, the (s, d)-hypernetwork Hsd=(Vsd, Esd) is the union of all the hyperpaths in Πsd, i.e.,Vsd=⋃π∈ΠsdVπ,Esd=⋃π∈ΠsdEπ.Clearly, Vsis the set of nodes hyperconnected to s in H; from now on we restrict ourselves to (s, d)-hypernetworks where d∈Vs, i.e., Πsdis not empty. Note that we have Es⊆E(s), whereE(s)={e∈E:T(e)⊂Vs∧h(e)∈Vs}is the set of hyperarcs with nodes in Vs; thus we have Hs⊆H(s), where H(s)=(Vs, E(s)), and this inclusion can be strict, as shown in Example 1.Example 1In the hypergraph H in Fig. 1we have Vs={s, a, b, c, d}; nodes and hyperarcs in dotted lines do not belong to H(s). Hyperarc 6 belongs to H(s), but not to Hs. Indeed, any hyperpath from s to d must contain hyperarc 5, by Property 2.iii; thus a hyperpath containing 6 would contain a cycle (a, 5, d, 6, a), contradicting Property 2.i.Hypernetworks can be related to the concepts of flow hypergraph and dominator. Flow hypergraphs, introduced by Guedes et al. [4], extend the well known concept of flowgraph to the broader class of hypergraphs introduced by Gallo et al. [1]. We say that H=(V, E) is a flow hypergraph with source s∈V if each node in V is hyperconnected to s in H; this can be denoted by H=(V, E, s). It is easy to see that hypernetworks (both Hsand Hsd) as well as the hypergraph H(s)=(Vs, E(s)) are flow hypergraphs. Moreover, the concept of dominator in a flowgraph can be extended to flow hypergraphs.Definition 4Given two distinguished nodes u and v in a flow hypergraph H=(V, E, s), u is a dominator of v if u belongs to every hyperpath from s to v in H.Note that a reflexive version of the dominance relation is referred to as “s-indispensability” in [10]; however, the connection with dominance is not pointed out there.As discussed above, to identify Hswe can proceed as follows: first build the hypergraph H(s)=(Vs, E(s)) and then remove from E(s) all those hyperarcs that do not belong to any hyperpath in Πs. The set Vscan be found in O(S(H)) time, applying procedure B-Visit[1]; given Vs, E(s) can be found in time O(S(H)). Thus building H(s) takes linear time in the size of H.In the following we show how to derive the hypernetwork Hsfrom H(s), first for the general case and then for two easier classes. We exploit the following quite intuitive fact, following from Property 2.iv: a hyperarc e in E(s) belongs to Hsif and only if it belongs to a hyperpath from s to h(e) in H(s). Hyperarcs that do not fulfill this condition are removed, and the remaining ones define Hs.Besides finding hyperarcs to be removed from H(s), our algorithm generates an n×n{0,1}matrix D (the analog of the “s-indispensability matrix” in [10]) where Dij=1 if node viis a dominator of node vjin H(s), and Dij=0 otherwise. Here we assume an arbitary but fixed ordering of the nodes in H(s), i.e., Vs={s=v1,v2,…,vn}.To improve efficiency, all the hyperarcs in the backward star of a node are processed at the same time. Thus the algorithm works in stages, processing a node u∈Vs⧹{s} at each stage; recall that BS(u) is not empty. For each u, a hypergraph Hu=(Vu, Eu) is obtained from H(s) as follows: for each hyperarc e∈BS(u) a new node ueis introduced, and e is replaced by a new hyperarc eu=(T(e), ue). Formally,–Vu=Vs∪{ue: e∈BS(u)}Eu=(E(s)⧹BS(u))∪{eu=(T(e), ue): e∈BS(u)}.The hypergraph H(s) shown in Fig. 1 appears on the left in Fig. 2; on the right, the hypergraph Hufor u=a is shown. The two hyperarcs 1 and 6 in BS(a) are replaced by the new hyperarcs 1aand 6a, respectively, introducing two new nodes a1=h(1a) and a6=h(6a). The nodes hyperconnected to s in Hu(shown in thick lines) are c and a1.Let us denote byVsuthe set of nodes hyperconnected to s in Hu; clearly,u∉Vsu. The setVsuprovides all the necessary information to identify the hyperarcs in BS(u) that must be removed and the nodes dominated by u.Lemma 1Given a hyperarc e∈E(s)with h(e)=u, e∈Esif and only if nodeue∈Vsu.(if) Let π be a hyperpath from s to uein Hu; clearly, π contains hyperarc eu, and does not contain node u, thus by replacing euby e we obtain a hyperpath from s to u in H(s).(only if) Let π⊆H(s) be an s–u hyperpath containing e: by replacing e by euwe obtain a hyperpath from s to uein Hu. □For each node v≠u in Vs, node u is a dominator of v in H(s)if and only ifv∉Vsu.(if) Let π⊆H(s) be an s–v hyperpath: if π contains node u then π is not contained in Hu, otherwise π⊂Hu; thusv∉Vsuimplies that each s–v hyperpath in H(s) contains node u.(only if) Suppose there is an s–v hyperpath π in Hu; clearly, π does not contain u; by Property 2.ii, π does not contain any node ue, thus π⊆H(s).□Consider again the hypergraph Hu, for u=a, in Fig. 2. We havea6=h(6a)∉Vsu, whilea1=h(1a)∈Vsu; indeed, recall that hyperarc 6 does not belong to Hs, while hyperarc 1 belongs to Hs. Moreover, we haveb,d∉Vsu; indeed, node a dominates nodes b and d in H(s).Our algorithm, referred to as FindHs, is described in Table 1. We use a label R to mark hyperarcs to be removed from H(s), in particular, we set Re=true if hyperarc e is removed, and Re=false otherwise. Line 1 writes the first row of D; the main loop starts at line 2, and each stage consists of lines 3–6. Lines 3 and 4 take O(S(H)) time, while lines 5 and 6 take O(m) and O(n) time, respectively. All the step of the algorithm require O(S(H)) space, but a further O(n2) space is required for matrix D. Note however that it is not necessary to store D during the algorithm, i.e., each row i of D can be sent to output and discarded at the end of step 6; in this case, the overall space requirement becomes O(S(H)).Theorem 1Algorithm FindHs finds the hypernetwork Hsand writes the matrix D in O(n·S(H)) time, with an O(S(H)) space requirement.The forward procedure proposed in [10] finds Hswith time complexity O(n2m2T), where T=maxe∈E∣T(e)∣. In general S(H) is O(mT), thus FindHs reduces complexity by a factor nm at least. Moreover, it is easy to define classes of hypergraphs where S(H) is O(m) while T is Θ(n); in these cases the improvement increases to a factor n2m.Combining Lemmas 1 and 2, and taking into account the structure of a hypergraph Hu, we obtain the following relevant relation.Property 3A hyperarc e∈E(s)belongs to Hsif and only if h(e) does not dominate any node v∈T(e) in the flow hypergraph H(s).Property 3 implies that Hscan be determined in linear time O(S(H)) if the matrix D is available. Moreover, even if D is not known, H(s) can be determined in linear time if all the relevant information about dominators in H(s) is available in a suitable form; we exploit this fact to devise linear time methods for two particular classes.The hypernetwork Hscan be found in linear time O(S(H)) for two nontrivial classes of hypegraphs: acyclic hypergraphs and directed graphs. Note that hypergraphs in these classes can be recognized in linear time. The two classes require quite different algorithmic techniques, and we discuss them separately, pointing out the information about dominators that is relevant to each case.Acyclic hypergraphs. This case turns out to be quite simple, since if H is acyclic then Hs=H(s) (the “only if” relation does not hold here). This follows from Property 3, observing that in an acyclic hypergraph the node h(e) does not dominate any node in T(e). More precisely, h(e) does not belong to any hyperpath from s to u∈T(e): if this happens, by Property 2.ii there is a path from h(e) to u, that together with e gives a cycle. Note that, for acyclic hypergraphs, a quite limited information on the dominance relation suffices to find Hs; in fact, we find Hswithout computing the matrix D. We leave as an open question whether it is possible to find D in less than O(n·S(H)) time for an acyclic hypergraph.Directed graphs. This case is definitely more complex. Recall that, in directed graphs, a hyperpath corresponds to a simple directed path, i.e., H(s) is a flowgraph. It is easy to see (and actually follows from Property 3) that an arc (u, v)∈E(s) belongs to a simple path from s to v in H(s) if and only if v is not a dominator of u. Our method checks this condition efficiently, exploiting some known results about dominance in flowgraphs, described below.In a flowgraph G=(N, A, s) a node u is an immediate dominator of node v if there is no dominator w of v such that u dominates w. Each node v≠s in G has a unique immediate dominator, and this implicitly defines a directed spanning tree T=(N, AT), rooted at s, where (u, v)∈ATif u is the immediate dominator of node v. Note that arcs in ATdo not necessarily correspond to arcs in A. The dominators of a node v are the nodes in the unique path from s to v in T. The immediate dominators, and thus the tree T, can be found in linear time O(∣A∣), although this task is definitely far from trivial, see [3] and references therein.Now suppose that we computed the tree T=(Vs, AT) in the flowgraph H(s)=(Vs, E(s)). In order to find the arcs to be removed from E(s) we perform a depth first visit of T. The visit is performed by the recursive procedure DFVisit, shown in Table 2. We maintain a node label l that marks active nodes: a node u is active (i.e., l(u)=true) if and only if the visit of the subtree rooted at u started but did not yet terminate. It is easy to see that, when DFVisit(u) is called and line 1 is executed, the active nodes are exactly those in the path from s to u in T, i.e., u and its dominators. At that point (line 2) we process each arc (u, v)∈E(s): if v is active then we set Re≔true, otherwise we set Re≔false. Then (line 3) we recursively call DFVisit(w) for each successor w of u in T. Initially, all the node labels are set to false; the visit of T is started by the call DFVisit(s). Clearly, the whole process takes linear time O(m).For directed graphs, the matrix D is redundant, since the dominance relation is completely described by T. Observe that, opposed to what happens for acyclic hypergraphs, here we exploit the complete knowledge of the dominance relation to find Hs. We do not know if Hsmay be found in linear time, or at least in less than O(nm) time, without computing T.The problem of finding an (s, d)-hypernetwork in a hypergraph H is in general NP-hard, but it can be solved in linear time if H is acyclic. We prove this result first, and then we point out the relations with stratified hypergraphs.Similar to Hs, finding Hsdis rather simple, and does not require knowledge of the dominance relation. We exploit a general property of acyclic hypergraphs [8, Property 2.1] that in our context can be restated as follows:Property 4An acyclic hypergraph H such that BS(u)≠∅ for each node u≠s in H is a flow hypergraph.Recall that each (s, d)-hypernetwork Hsd=(Vsd, Esd) is contained in Hs, and that Hs=H(s) if H is acyclic. To obtain Hsdit may be necessary to remove some hyperarcs and nodes from H(s). Observe that Hsdcontains at least one path Pudfor each node u∈Vsd, as follows immediately from Property 2.ii. Therefore, we can safely remove a node u∈Vsif there is no path from u to d in H(s). Let us denote by V(sd)⊆Vsthe set of remaining nodes, i.e., u∈V(sd) if and only if d is connected to u in H(s); moreover, letE(sd)={e∈E(s):T(e)⊂V(sd)∧h(e)∈V(sd)}be the set of hyperarcs in E(s) with nodes in V(sd).Theorem 2If H is acyclic, for each (s, d)-hypernetwork Hsd=(Vsd, Esd) we have Vsd=V(sd)and Esd=E(sd).It follows immediately from Property 2.ii that Vsd⊆V(sd), and thus Esd⊆E(sd). It remains to show that E(sd)⊆Esd, which implies V(sd)⊆Vsd. First note that if u∈V(sd) then we have e∈E(sd) for each e∈E(s) such that h(e)=u, which implies that H(sd)=(V(sd), E(sd), s) is a flow hypergraph, due to Property 4. Consider a generic hyperarc e0∈E(sd) with h(e0)=u, and a pathPud=(u=v1,e1,v2,e2,…,eq,vq+1=d)contained in H(sd). Note that it can be q=0, i.e., u=d. Obtain H′⊆H(sd) from H(sd) as follows: for i=1,…,q+1 remove from E(sd) all the hyperarcs in BS(vi) except ei−1. From Property 4, H′ is a flow hypergraph; moreover, by Property 2.iii, every hyperpath from s to d in H′ contains the path Pud, and thus contains e0. In conclusion, e0∈Esd.□The set V(sd) can be easily found in linear time O(S(H)) by a backward version of procedure Visit [1]. It follows that an (s, d)-hypernetwork in an acyclic hypergraph can be found in linear time.The definition of stratified hypergraphs ([10, Definition 4.4]) can be restated as follows.Definition 5A hypergraph H=(V, E) is stratified if V can be partitioned into a sequence of subsets N0,N1,…,Nk, with k>0, satisfying:1.let u∈Niand v∈Nj: if i⩾j then there does not exist any hyperarc e∈BS(v) such that u∈T(e);for each u∈Ni, i=1,…,k, there exists a hyperarc e with h(e)=u and T(e)⊆∪j=0,i−1Nj.Let us say that a hypergraph is nonempty if it contains at least one hyperarc. Note that a stratified hypergraph must be nonempty.Property 5A hypergraph H=(V, E) is stratified if and only if it is a nonempty acyclic hypergraph.(if) Let V={v1,v2,…,vn} be a topological order satisfying (1). Let N0={vi∈V: BS(vi)=∅}, i.e., N0 is the set of nodes with an empty backward star; since H is nonempty, N0⊂V. We sort the nodes in V⧹N0 according to the topological order, i.e., we let V⧹ N0={vo(1),vo(2),…,vo(k)}, where o(i)<o(j) for each 1⩽i<j⩽k. For each e=(T(e), vo(j))∈E, and for each vo(i)∈T(e), we have i<j by Property 1.i. We define Ni={vo(i)} for each i=1,…,k; it is routine to check that the partition N0,N1,…,Nksatisfies conditions 5.1 and 5.2.(only if) It is easy to see that H is acyclic since, for each e∈E, a node u∈T(e) cannot be connected to the node h(e).□Property 5 shows that our linear time method completes a polynomiality result already given in [10]. Note that this polynomiality result exploits some nontrivial theoretical properties of (s, d)-hypernetworks (namely, Theorem 4.1 in [10]) that hold true also if the hypergraph is not acyclic. Our approach is simpler and more direct, since we derive our result from a known property of acyclic hypergraphs, namely Property 4.Remark 1In the original statement of condition 1. in Definition 5, i.e., condition (4.1) in [10, Definition 4.4], the inequality “i>j” appears instead of “i⩾j” (probably due to a typographical error). This actually results in a weaker condition, that allows e.g. a hyperarc e∈E such that T(e)∪{h(e)}⊆Ni. Clearly, the weaker condition defines a proper extension of acyclic hypergraphs. Unfortunately, the polynomiality result does not extend to this broader class, unless P=NP. To see this, consider a generic hypergraph H=(V, E) and a pair of nodes s and d in V. Define a hypergraph H′ adding to H a new node d′ and a new arc (d, d′). Choosing N0=V and N1={d′} we see that H′ is stratified according to the weaker condition. Clearly, every s–d hyperpath in H corresponds to a unique s–d′ hyperpath in H′, and vice versa. Thus finding the (s, d′)-hypernetwork in H′ is as hard as finding the (s, d)-hypernetwork in H, i.e., NP-hard.

@&#CONCLUSIONS@&#
Hypernetworks in directed hypergraphs have been introduced as a formal descriptive tool within a specific application. In our paper we pointed out that finding hypernetworks has a relevant interest, from a computational point of view, in many different contexts.We provided a fast and simple method for finding the s-hypernetwork, and two nontrivial classes solvable in linear time. For one of this two classes we also devised a linear time method for finding the (s, d)-hypernetwork. On the theoretical side, we pointed out the relations between hypernetworks, flow hypergraphs, and dominators.Our results may be extended along two different directions. On one side, find classes where hypernetworks can be identified exploiting a partial knowledge of the dominators, as for acyclic hypergraphs. On the other side, find classes where dominators can be found in less than O(n·S(H)) time. One possible candidate class are the reducible flow hypergraphs [4]. Independently of hypernetworks, we believe that the computation of dominators in flow hypergraphs may be an interesting subject for further research.