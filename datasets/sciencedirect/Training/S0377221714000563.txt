@&#MAIN-TITLE@&#
Minimizing shifts for personnel task scheduling problems: A three-phase algorithm

@&#HIGHLIGHTS@&#
We propose a state-of-the-art algorithm for the personnel scheduling problem.Sorting tasks in the ascending order of their start times yields good initial solutions.The Boltzmann function enables solutions to overcome their local minima.The advantage of the algorithm is significant, especially for large-scale problems.

@&#KEYPHRASES@&#
Scheduling,Shift minimization,Personnel task scheduling problem,

@&#ABSTRACT@&#
The personnel task scheduling problem is a subject of commercial interest which has been investigated since the 1950s. This paper proposes an effective and efficient three-phase algorithm for solving the shift minimization personnel task scheduling problem (SMPTSP). To illustrate the increased efficacy of the proposed algorithm over an existing algorithm, computational experiments are performed on a test problem set with characteristics motivated by employee scheduling applications. Experimental results show that the proposed algorithm outperforms the existing algorithm in terms of providing optimal solutions, improving upon most of the best-known solutions and revealing high-quality feasible solutions for those unsolved test instances in the literature.

@&#INTRODUCTION@&#
Since the pioneering studies of Edie (1954) and Dantzig (1954), the personnel scheduling problem (PSP) has continued to be a topic of interest to researchers and practitioners. The PSP consists of the various decisions which must be made, such as the assignment of tasks and/or shift sequences. On the basis of the planning horizon, current PSPs can be divided into three typical classifications (Baker, 1976): shift scheduling, days off scheduling and tour scheduling. In the shift scheduling problem, a roster across a time-of-day planning horizon is specified to meet the staff requirements regarding each shift; in the days off scheduling problem, a roster is set under the constraint that the length of the operating week in the facility does not match the length of an employee’s working week; and in the tour scheduling problem, which combines the first two types, both the hours of the day and the days of the week in which each employee must work are determined (Van den Bergh, Beliën, De Bruecker, Demeulemeester, & De Boeck, 2013). The three types of PSPs are common in many application areas, such as service systems, manufacturing systems, transportation systems, call centers, airlines, hotels, hospitals and health care systems.The ongoing interest of researchers has been motivated by the opportunities for the widespread applications of PSPs. The literature on the PSP exhibits a wide range of research methodologies which can be classified either as exact methods or as those based on heuristic algorithms. Exact methods, which have appeared in PSP research, include: linear programming (Fowler, Wirojanagud, & Gel, 2008; Hochbaum & Levin, 2006; Hojati & Patil, 2011); constraint programming (Laporte & Pesant, 2004; Qu & He, 2009); goal programming (Azaiez & Al Sharif, 2005; Lin, Chen, Chou, & Liao, 2012; Topaloglu & Ozkarahan, 2004), integer programming (Eiselt & Marianov, 2008; Eitzen, Panton, & Mills, 2004; Seckiner, Gokcen, & Kurt, 2007); mixed integer programming (Firat & Hurkens, 2012; Hertz, Lahrichi, & Widmer, 2010; Yilmaz, 2012); column generation (Al-Yakoob & Sherali, 2008; He & Qu, 2012; Restrepo, Lozano, & Medaglia, 2012); dynamic programming (Beliën & Demeulemeester, 2007; Elshafei & Alfares, 2008); and Lagrange relaxation (Bard & Purnomo, 2007; Pot, Bhulai, & Koole, 2008). Although hundreds of exact methods have been proposed in the literature, the computational requirements for obtaining optimal solutions by exact methods are high, even for a moderate-sized PSP. For large-scale PSPs, exact methods may not quickly produce any feasible solutions.The inherent difficulties of PSPs have encouraged the development of heuristic algorithms for large-scale problems, as required in typical real-world systems, in order to obtain the best solutions within a reasonable computing time (Ernst, Jiang, Krishnamoorthy, & Sier, 2004). The heuristic algorithms in the literature are of two types: constructive heuristics and improvement heuristics. The constructive heuristic is essentially a single pass method which uses a specific rule to assign a priority index to each employee and, in each step, to specify a shift or task. Once an employee’s shift is determined, it is fixed and cannot be reversed (Ying & Liao, 2003). During the last decade, constructive heuristic algorithms have been proposed for a variety of applications with respect to PSPs, such as nurse scheduling problems (Brucker, Burke, Curtois, Qu, & Vanden Berghe, 2010; Wright, Bretthauer, & Cote, 2006), crew scheduling problems (Elizondo, Parada, Pradenas, & Artigues, 2010; Lin et al., 2012) and truck driver scheduling problems (Goel, Archetti, & Savelsbergh, 2012). The major advantage of these constructive heuristics is that they can yield rosters rapidly. However, the quality of the obtained rosters is often not as good as expected, especially for large-scale problems.In contrast, the improvement heuristic method begins with an initial roster and then a scheme is implemented for iteratively generating an improved roster (Ying & Liao, 2004). In improvement heuristics, meta-heuristics form an important methodology for the solving of complex PSPs. In the literature, Tabu search (Di Gaspero et al., 2007; Elizondo et al., 2010; Lucic & Teodorovic, 2007), genetic algorithms (Asensio-Cuesta, Diego-Mas, Canos-Daros, & Andres-Romano, 2012; Beddoe & Petrovic, 2006; Moz & Pato, 2007) and simulated annealing (Akbari, Zandieh, & Dorri, 2013; Cordeau, Laporte, Pasin, & Ropke, 2010; Thompson & Goodale, 2006) are the three meta-heuristics most used in the solving of PSPs. In addition to these three general classes, other popular meta-heuristics have been developed for dealing with PSPs, including the scatter search (Burke, Curtois, Qu, & Vanden Berghe, 2010; Laguna, Casado, & Pacheco, 2005; Maenhout & Vanhoucke, 2010), iterated local search (Bellanti, Carello, Della Croce, & Tadei, 2004; Burke, Curtois, van Draat, van Ommeren, & Post, 2011), variable neighborhood search (Burke, Curtois, Post, Qu, & Veltman, 2008; Burke, Li, & Qu, 2010), particle swarm optimization (Akjiratikarl, Yenradee, & Drake, 2007; Gunther & Nissen, 2010; Nissen & Gunther, 2009), memetic algorithm (Ozcan, 2005), electromagnetic meta-heuristic (Maenhout & Vanhoucke, 2007), neural network (Hao, Lai, & Tan, 2004), ant colony optimization (Gutjahr & Rauner, 2007), greedy random adaptive search procedure (Goodman, Dowsland, & Thompson, 2009), hill-climbing heuristic (Cipriano, Di Gaspero, & Dovier, 2006) and the hyper-heuristic algorithm (Chakhlevitch & Cowling, 2005). The major advantage of these meta-heuristics lies in their effectiveness, i.e., their ability to obtain workable rosters within a limited computing time. However, these meta-heuristics cannot demonstrably produce optimal solutions, nor can they demonstrably reduce the search space (Burke, Li, et al., 2010). For further detailed discussion of the available algorithms proposed by the research community with respect to PSPs, the reader is referred to the review articles of Alfares (2004), Burke, De Causmaecker, Vanden Berghe, and Van Landeghem (2004), Kohl and Karisch (2004), Ernst, Jiang, Krishnamoorthy, Owens, and Sier (2004), Ernst, Jiang, Krishnamoorthy, and Sier (2004) and Van den Bergh et al. (2013).Motivated by the need for practical day-to-day rostering in large service operations, this work has investigated a variant of the PSP, named the shift minimization personnel task scheduling problem (SMPTSP). The characteristics of the SMPTSP are: (1) that the only cost incurred is that owing to the number of workers (shifts) that are required to perform the given set of tasks; (2) that each worker possesses the set of qualifications or skills required in the performance of a subset of, but not all, tasks; (3) that each task is performed by exactly one qualified worker, as indicated by a shift with specified start and end times; and (4) that the objective is to minimize the total number of shifts/workers used. This variant of the PSP is important both as a planning tool, in order to minimize the number of staff members that an organization is required to maintain, and as a day-to-day operational management tool, in order to determine the number of staff members needed to perform all tasks on a particular day.The SMPTSP introduced by Krishnamoorthy, Ernst, and Baatar (2012) was originally derived from a staff rostering problem (Dowling, Krishnamoorthy, Mackenzie, & Sier, 1997) at a large international airport, involving about 500 staff members and a monthly planning horizon. In that study, the authors described a mathematical formulation and proposed a new heuristic based on the volume algorithm (VA) and Wedelin’s algorithm (WA), named VAWA, for solving the SMPTSP. Both the VA and WA allow for some of the harder constraints to be relaxed and, thus, the remaining problem to be easily solved. Therefore, the VAWA is computationally efficient and can be used to solve large-scale problems, such as those found in real-world applications.In the literature, solution algorithms, with respect to PSPs, are heavily skewed towards exact methods and meta-heuristics. Recently, multi-phase approaches and hybrid techniques, which deal with heavily constrained PSPs, have received increased attention from researchers. Therefore, in this study, an effective and efficient three-phase algorithm has been proposed, which combines the respective advantages of a constructive heuristic, a meta-heuristic and an exact method, for solving the SMPTSP. The remainder of this paper is organized as follows: the SMPTSP is defined in Section 2; in Section 3, the proposed three-phase algorithm is described in detail; in Section 4, the effectiveness and efficiency of the proposed algorithm is evaluated using a test problem set and its performance is compared to an existing algorithm, VAWA, drawn from the literature; and finally, in Section 5, this study concludes with recommendations for future studies.The shift minimization personnel task scheduling problem (SMPTSP) can be defined formally as follows. A set of tasks T={t1,…,tn} needs to be allocated to a set of heterogeneous workers W={w1,…,wm} over a specified planning horizon. The processing time interval at which a task has to be performed is determined by a timetable with fixed start and end times. Each worker possesses a number of specific skills or qualifications which enable them to perform a subset of the tasks, but not all of them. The objective is to find an optimal roster in order to minimize the number of shifts/workers required to perform the given set of tasks. Note that the term ‘workers’ may also stand for other resources, such as processors or machines. The following assumptions were made for the SMPTSP considered in this study:•The number of tasks, as well as their start and end times, are fixed and known in advance.Each task is considered an indivisible entity, even though it may be composed of a number of individual units.Preemption of tasks is not allowed.There are no precedence constraints among the tasks.Tasks cannot be carried out by workers who do not possess the specific skills required.Each task is processed once by a qualified worker.Each worker can execute, at most, one assigned task at a time.Each worker operates independently of other workers.Once a worker starts to perform a task, he/she is continuously available throughout the job completion, and there are no interruptions owing to break time or other such causes.Once a task is initiated by a worker, it cannot be transferred to another worker as the entire operation must be completed by the same worker.The SMPTSP described above can be formulated as the following BIP model, which is similar to a model depicted in Krishnamoorthy et al. (2012):(Problem-SMPTSP)(1)Minimizez=∑j=1mywjsubject to∑wj∈Wtixtiwj=1,∀i,(2)∑ti∈ckWxtiwj⩽ywj,∀j,ckW∈CW,(3)ywj∈{0,1},∀j,(4)xtiwj∈{0,1},∀i,j,whereywj(j=1,2,…,m) is a binary decision variable to show whether worker wjis used (ywj=1) or not (ywj=0);Wtirepresents the set of workers that can perform task ti;xtiwjis a binary decision variable to indicate whether task tiis assigned to worker wj(xtiwj=1) or not (xtiwj=0); andckWsignifies the elements of CW, which is a set of maximal cliques.Consider a given interval graph, G=(N,A), where N is the node set, one for each task in T, and A is the arc set. We join two nodes i, i′∊N in G by an arc if the intervals[sti,fti]and[sti′,fti′]overlap, i.e., if tasks tiandti′conflict with each other, wherestiandftiare the start and end times of ti, respectively. Let CWbe the set of maximal cliques in G. That is,CW={c1W,…,clW}consists of setsckW∈N(k=1,…,l), such thatckWis maximal and no task inT⧹ckWwill overlap with any task inckW, nor will any two tasks inckWoverlap for some interval of time. The maximal cliques of CWcan be identified by a polynomial time algorithm proposed by Krishnamoorthy and Ernst (2001), and is provided here (see Fig. 1) for completeness. For further details about the maximal clique algorithm, we refer readers to Krishnamoorthy et al. (2012).In the above BIP model, Constraint (1) ensures a task is performed by only one worker; Constraint (2) is used to prevent overlapping tasks being assigned to the same worker and ensures a task is performed by a worker only if it is assignable to that worker; and Constraints (3) and (4) definextiwjandywjas binary decision variables. As indicated by Krishnamoorthy et al. (2012), the computing time can be improved upon if we substitute Constraint (3) by0⩽ywj⩽1(∀j),i.e., settingywjas a continuous variable. It is obvious that the integer solution property for the relaxed formulation is ensured by Constraints (1), (2), and (4).As shown by Kroon, Salomon, and Wassenhowe (1997), the SMPTSP addressed in this study is strongly NP-Hard. However, the problem can be solved by a polynomial time algorithm, i.e. the forward pass maximal clique algorithm, proposed by Krishnamoorthy et al. (2012), if the qualification constraints in SMPTSP are removed.The proposed approach consists of three phases. In the first phase, a constructive heuristic is used to quickly obtain an initial solution to the SMPTSP. In the second phase, an iterated greedy (IG) heuristic is applied to improve upon the initial solution and obtain a near-optimal schedule. Finally, the near-optimal schedule is set as an initial solution; it represents an upper bound on the objective function for the BIP formulation if it is feasible, and further solves the BIP formulation by using Gurobi, a state-of-the-art mathematical programming solver, for obtaining the optimal solution. The detailed descriptions of the three phases are explained in the following subsections.The procedure for the proposed constructive heuristic which quickly produces an initial solution ξ0 (not necessarily a feasible solution) to the SMPTSP is as follows:Step 1: Construct a Conflict Matrix (i.e., a clash table) for all pairs of different tasks, in which for each pair of tasks, tiandti′(i≠i′),Conflict(ti,ti′)equals 1 if tiandti′cannot be assigned to the same worker owing to the processing time interval of tiandti′overlaps; otherwise,Conflict(ti,ti′)equals 0.Step 2: Construct an Assignment Matrix to record the assignable relationship between all pairs of worker wjand task ti, in which for each pair of wjand ti, Assignment(ti,wj) equals 1 if task tican be assigned to worker wj, i.e.,wj∈Wti; otherwise, Assignment(ti,wj) equals 0.Step 3: Set initialization variables U(ξ0)={t1,…,tn} andTCPwj=0(∀j), where U(ξ0) is the set of unassigned shifts of ξ0; andTCPwjdenotes the total cumulative processing time of worker wj.Step 4: Arrange the unassigned shifts in ascending order of their start times. In case of a tie, sort them using the ascending order of the task index.Step 5: According to the order of tasks obtained in Step 4, try to dispatch the unassigned tasks one by one to an assignable worker until all tasks have been considered. When trying to dispatch task tiof U(ξ0), choose the worker wjwhich satisfies the following three conditions: (1) Assignment(ti,wj)=1, i.e., tican be dispatched to wj; (2)Conflict(ti,ti′)=0,∀ti′∈{ti|xtiwj=1,∀iandi≠i′}, i.e., there is no clash between tiand all tasks which have been assigned to wj; and (3) wjis the worker with the largest total cumulative processing time of all assignable workers that satisfies Conditions (1) and (2). If there is no worker that satisfies the three conditions, put task tiback into U(ξ0). UpdateTCPwjand U(ξ0) after each task has been considered.Step 6: If U(ξ0) is not null, a reassignment procedure, as follows, is repeatedly applied to allocate each task of U(ξ0) to a qualified worker until all tasks have been assigned (i.e., a feasible solution is obtained) or cycling exists for those unassigned shifts (i.e., no feasible solution is obtained).Step 6.1: Arrange the tasks of U(ξ0) in the ascending order of their start times. In case of a tie, sort them using the ascending order of their task index.Step 6.2: Try to reassign the tasks tiof U(ξ0), one by one, to an assignable worker until all tasks in U(ξ0) have been reassigned. The assignable worker wsis selected as follows. Compute the total processing time of the tasks which conflict with task tifor worker wjthat satisfies Assignment(ti,wj)=1. Set the worker with the smallest total processing time of conflict tasks as ws. If no conflict task exists among the assignable workers, set the worker with the smallest index as ws. In order to reassign tito ws, remove all tasks in wsthat conflict with task tibefore implementing the reassigning process.Step 6.3: Add all removed tasks in Step 6.2 into U(ξ0). Use the same procedures as in Steps 4 and 5 to reassign tasks in U(ξ0) to the qualified shifts, one by one, if possible. If the termination condition is not satisfied, go to Step 6.1 to start a new loop.Step 7: Return the initial solution ξ0, including the number of shifts/workers used |S(ξ0)| and the set of unassigned shifts U(ξ0).The IG heuristic, which belongs to the class of heuristics known as very large neighborhood search (VLNS) algorithms (Ahuja, Ergun, Orlin, & Punnen, 2002; Pisinger & Ropke, 2010), is an effective and efficient meta-heuristic proposed by Jacobs and Brusco (1995). The procedures of IG are similar to the paradigm of the ruin and recreate (R&R) method (Schrimpf, Schneider, Stamm-Wilbrandt, & Dueck, 2000). The main difference between these two approaches is that R&R typically obtains new candidate solutions by ruining a considerable part of an incumbent solution, while IG obtains them by destroying only a small part of an incumbent solution. Ruiz and Stützle (2007) developed an IG heuristic which successfully solved permutation flow shop scheduling problems, which increased IG’s popularity. In recent years, applications of IG have provided state-of-the-art solutions for a considerable number of scheduling problems (Lin, Lee, Ying, & Lu, 2011; Ruiz & Stützle, 2008; Ying, 2008, 2009, 2012; Ying & Cheng, 2010; Ying, Lin, & Huang, 2009).In recent studies (Ruiz & Stützle, 2008; Ying, 2008, 2009; Ying et al., 2009), a simple simulated annealing-like acceptance criterion with a constant temperature was integrated into the generic IG heuristic to improve its performance. However, this type of approach may stagnate owing to insufficient diversification (Lin et al., 2011; Ying, Gupta, Lin, & Lee, 2010). As an alternative, in this study, we applied a new acceptance criterion with a reducing temperature that is frequently used in simulated annealing algorithms in order to diversify the searching area and yield a better solution quality. In the following subsection, the solution representation and the main steps of the proposed IG heuristic with a reducing temperature are discussed further.In this study, a solution is represented using a two-dimensional array. There are m rows in this array, in which each row has a string of numbers consisting of certain tasks assigned to a qualified worker. Since the operation sequence of tasks in the same row can be determined by their start times, the sequence of tasks in the same row has no effect. For instance, the solution representation shown in Fig. 2can be interpreted as follows. Fifteen tasks are assigned to three workers, in which the tasks to be assigned to workers 0, 1 and 2 are (t10,t6,t13,t11,t0), (t7,t12,t1,t3,t14,t5) and (t2,t4,t8,t9), respectively.The detailed procedures of the proposed IG heuristic can be described as follows.Step 1: Generate Initial SolutionGenerate an initial solution ξ0 according to the procedure of the constructive heuristic described in Section 3.1. Set ξbest=ξ0 and ξ∗=ξ0, where ξbestand ξ∗ are the best solution and incumbent solution, respectively.Step 2: Destruction and Construction Phases(a)Choose α unrepeated tasks randomly from the incumbent solution, ξ∗. Delete them from ξ∗ and add them into ξRin the order they are chosen, where ξRis a list of the α removed tasks. Meanwhile, set the partial solution of ξ∗ after removing the α tasks as ξD.Sequentially reassign the tasks from the list of ξRto ξDuntil a new solutionξnew∗is obtained. When reassigning a task tiof ξRto a worker of ξD, choose the worker wjthat satisfies the following three conditions: (1) Assignment(ti,wj)=1, i.e., tican be dispatched to wj; (2)Conflict(ti,ti′)=0,∀ti′∈{ti|xtiwj=1,∀iandi≠i′}, i.e., there is no clash between tiand all tasks which have been assigned to wj; and (3) wjis the worker which has the largest total cumulative processing time of all assignable workers of ξDthat satisfies Conditions (1) and (2).Let |U(ξ∗)|,|U(ξnew∗)|and |U(ξbest)| be the number of unassigned shifts of solutions ξ∗,ξnew∗and ξbest, respectively; |S(ξ∗)|,|S(ξnew∗)|and |S(ξbest)| denote the number of shifts/tasks of solutions ξ∗,ξnew∗and ξbest, respectively. Use the following criteria to determine whether the incumbent solution ξ∗ and the best solution ξbestwill be substituted byξnew∗or not.If|U(ξnew∗)|=0and |U(ξ∗)|≠0, thenSetξ∗:=ξnew∗;Else if|S(ξnew∗)|⩽|S(ξ∗)|and|U(ξnew∗)|⩽|U(ξ∗)|, thenSetξ∗:=ξnew∗;Else if|S(ξnew∗)|=|S(ξ∗)|and|U(ξnew∗)|>|U(ξ∗)|, thenLetΔE=|U(ξnew∗)|-|U(ξ∗)|; Generate r∼U(0,1);If r<e(−ΔE/T), then setξ∗:=ξnew∗;Else if|S(ξnew∗)|>|S(ξ∗)|, thenLetΔE=|S(ξnew∗)|-|S(ξ∗)|; Generate r∼U(0,1);If r<e(−ΔE/T), then setξ∗:=ξnew∗;Else discard the generated solutionξnew∗.If |U(ξ∗)|=0 and|S(ξ∗)|<|S(ξBest∗)|, then setξBest∗:=ξ∗; Else if |U(ξ∗)|=0 and|U(ξBest∗)|≠0, then setξBest∗:=ξ∗.Step 3: Termination criteriaThe current temperature T reduces from the initial temperature T0 and decreases from the last temperature whenever a fixed number of iterations (Iiter) is run, according to the formulaT←λT, where0<λ<1. The algorithm iterates through the destruction and construction phases of Step 2 until the number of temperature reductions is greater than the maximum number of temperature reductions (Nnon-improving) in which the best objective function value is not improved.The proposed IG heuristic takes advantage of the reduce temperature in the simulated annealing. In Step 1, an initial solution ξ0 is obtained by the constructive heuristic described in Section 3.1. Steps 2(a) and 2(b) are the destruction and construction phases, respectively, which can be seen as a perturbation mechanism. In Step 2(c), when a new solutionξnew∗is generated, there may be five possible conditions: (1) Ifξnew∗is feasible and ξ∗ is infeasible (i.e.,|U(ξnew∗)|=0and |U(ξ∗)|≠0), ξ∗ will be substituted byξnew∗; (2) If both the number of shifts used and the number of unassigned shifts ofξnew∗are equal to or less than those of ξ∗ (i.e.,|S(ξnew∗)|⩽|S(ξ∗)|and|U(ξnew∗)|⩽|U(ξ∗)|), ξ∗ will be substituted byξnew∗whether they are feasible or infeasible; (3) If the number of shifts used byξnew∗is equal to that of ξ∗ and the number of unassigned shifts ofξnew∗is greater than that of ξ∗ (i.e.,|S(ξnew∗)|=|S(ξ∗)|and|U(ξnew∗)|>|U(ξ∗)|), the Boltzmann function is applied to enable the incumbent solution to escape from the local minima whetherξnew∗and ξ∗ are feasible or infeasible. This process is achieved by generating a random number r∊[0,1] and replacing the ξ∗ byξnew∗if r<e(−ΔE/T), whereΔE=|U(ξnew∗)|-|U(ξ∗)|and T is the current temperature; (4) If the number of unassigned shifts ofξnew∗is greater than that of ξ∗ (i.e.,|S(ξnew∗)|>|S(ξ∗)|), a random number r∊[0,1] will be generated and ξ∗ will be substituted byξnew∗if r<e(−ΔE/T), whereΔE=|S(ξnew∗)|-|S(ξ∗)|; and (5) In other cases, the generated solutionξnew∗will be discarded. In Step 2(d), if ξ∗ is feasible and the number of shifts used of ξ∗ is less than that ofξBest∗,ξBest∗will be replaced by ξ∗. Otherwise, if ξ∗ is feasible andξBest∗is infeasible,ξBest∗will be replaced by ξ∗.To shorten the computing time required for solving the BIP formulation, the solution obtained by the IG algorithm is set as its initial solution. Then, by using Gurobi (version 5.02), a state-of-the-art mathematical programming solver, an optimal solution can be obtained. The initial solution obtained using the IG algorithm acts as an upper bound on the objective function for the BIP formulation, if it is feasible. Thus, most of the solution space is eliminated and the SMPTSP problem can be solved efficiently. This advantage is significant, especially for large-scale, rather than small-scale, SMPTSP problems. It is theoretically possible that the solution obtained by Phase II (or by Phase I) is infeasible. In this instance, Gurobi rejects the initial solution generated by Phase II (or by Phase I) and then attempts to generate a feasible solution itself during the searching procedures.To demonstrate the procedure for the proposed three-phase algorithm, an instance (data_2_24_40_33.dat) of the test problem set generated by Krishnamoorthy et al. (2012) was used. As shown in Table 1, it involved 24 shifts/workers and 40 tasks. In Phase I, after a Conflict Matrix and an Assignment Matrix were constructed and the initialization variables set, the sequence of unassigned shifts was arranged in an ascending order according to their start times, as follows: (t5-t18-t25-t0-t1-t33-t7-t27-t10-t2-t23-t16-t20-t9-t29-t22-t11-t8-t6-t15-t17-t36-t32-t26-t35-t19-t37-t3-t39-t12-t13-t24-t28-t38-t4-t21-t34-t31-t14-t30). Following Step 5 of Phase I, the obtained assignment of tasks and shifts was as shown in the second column of Table 2. Since there was an unassigned task t11, Step 6 of Phase I was applied. Then, after removing t33 to the set of unassigned shifts U(ξ0), t11 could be reassigned to w11 and t33 was reassigned to w19. Since all tasks were now assigned, an initial feasible solution, as shown in the third column of Table 2, was obtained. It is worth noting that, in this study, almost all of the initial solutions obtained by Phase I were feasible.Once an initial solution is quickly obtained by using the constructive heuristic of the first phase, the second phase of the proposed three-phase algorithm is begun. After several iterations of Phase II, a feasible incumbent solution ξ∗ was obtained, as shown in the second column of Table 3. In the next iteration, as shown in the third column of Table 3, tasks t22, t14 and t27 were randomly removed from ξ∗ in the deconstruction phase. Then, in the following construction phase, t22, t14 and t27 were reassigned, one by one, to w18, w23 and w13, respectively. Finally, as shown in the fourth column of Table 3, an optimal solution with |S(ξbest)|=20 was obtained.In the third phase of the proposed three-phase algorithm, the solution obtained in Phase II was set as an initial solution for the proposed BIP formation. After the BIP formulation using Gurobi was solved, an optimal solution matching that obtained in the second phase was obtained.In this section, the computational experiments used to evaluate the performance of the proposed approach are described. The details of the test problems, execution environment, parameter selection and the computational results of the proposed approach as compared to the existing algorithm, VAWA (Volume Algorithm+Wedelin’s Algorithm) (Krishnamoorthy et al., 2012), and the Lower Bound (LB) of the optimal solutions are discussed.To evaluate the effectiveness and efficiency of the proposed approach, computational simulations and comparisons were executed for a test problem set with 137 instances, generated by Krishnamoorthy et al. (2012). These instances were generated by five characteristics motivated by an employee scheduling application that included the number of shifts, the number of tasks, task length, tightness level and multi-skilling level.The number of shifts ranged from 22 to 420, while the number of tasks ranged from 40 to 2105. Three task lengths (long, medium, short) were used, in which the lengths of the long tasks, medium tasks and short tasks were generated by triangular distributions on (200,300,400), (50,200,250) and (50,100,200), respectively. Tasks with longer lengths are relatively easy to solve because the number of tasks in the problem is smaller. Since those instances with lower tightness levels are generally easier to solve, only one level of tightness, i.e., 90%, was used. Two multi-skilling levels were used. Each staff member performs about 2/3 and 1/3 of the tasks on average for the first and second multi-skilling levels, respectively. The files for these test instances are available via the OR-Library (http://people.brunel.ac.uk/~mastjjb/jeb/orlib/ptaskinfo.html). The name of a data file includes the file number, the number of shifts, the number of tasks and the multi-skilling level.The proposed three-phase algorithm was coded in C++ under the Windows 7 (64 bits) operating system and run on an Ultrabook with an Intel® Core™ i5-3317U @1.70gigahertz processor with 4 cores and 4gigabytes of RAM. In the preliminary experiments, the following combinations of parameters were tested:λ=0.93,0.95,0.97and 0.99; Iiter=10,000, 20,000, 30,000 and 40,000; Nnon-improving=30, 50, 70, and 100; T0=0.4, 0.6, 0.8, 1.0, 1.2 and 1.5;α=⌊β×Numberoftasks/Numberofshifts⌋, where⌊⌋denotes the largest integer smaller or equal to the enclosed number; and β=1.0, 1.5, 2.0, 2.5 and 3.0. The pilot experiments showed that the parameter selection influenced the solution quality of the proposed three-phase algorithm, in which the settingsλ=0.95, Iiter=10,000, Nnon-improving=50, T0=1.0 and β=2.0 elicited high-quality solutions within an acceptable computing time; therefore, these settings were used for further computational study. For example, in order to show the convergence trend of Phase II, we used the test instance Data_77_180_688_33 as an example. The evolution of the objective function values of the obtained best solutions for this test problem is displayed in Fig. 3. As can be seen, the objective function value (i.e., the number of shifts/workers used) decreased when the number of total iterations increased, and there was no further improvement in the obtained best solution after a certain number of total iterations. Thus, overly large numbers of Iiterand Nnon-improvingmay not enhance the IG solution quality.The solutions obtained by the VAWA approach were included for purposes of comparison. Krishnamoorthy et al. (2012) implemented the VAWA approach on a 2.93gigahertz Xeon processor with 4MB of cache, 64gigabytes of RAM and 16 cores, with the computing time limit set at 1800seconds. In the present study, each test instance was solved once by Phase I, Phase II, Phase III (i.e. Phase III without an initial solution), Phases I+III (i.e. Phase III with an initial solution from Phase I), and Phases I+II+III (i.e. the three-phase algorithm) of the proposed algorithm. To match the computing time limit employed by VAWA, the maximum computing time for executing Phase III, Phases I+III and Phases I+II+III using Gurobi was also set to 1800seconds (including the processing time of Phase I and Phase II for generating an initial solution if it was used). All solutions obtained by Phase I, Phase II, Phase III, Phases I+III and Phases I+II+III can be downloaded from the web site (URL: http://swlin.cgu.edu.tw/data/SMPTSP.zip).

@&#CONCLUSIONS@&#
