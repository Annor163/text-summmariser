@&#MAIN-TITLE@&#
Formal model-driven engineering of critical information systems

@&#HIGHLIGHTS@&#
Model-driven tools can reduce the cost of development and verification.Information systems can be produced automatically from object oriented designs.A formal, model-driven approach is proposed for use in safety critical systems.A framework is provided for the correctness of model transformations.

@&#KEYPHRASES@&#
Model-driven engineering,Formal methods,Critical systems,Information systems,Data migration,

@&#ABSTRACT@&#
Model-driven engineering is the generation of software artefacts from abstract models. This is achieved through transformations that encode domain knowledge and implementation strategies. The same transformations can be used to produce quite different systems, or to produce successive versions of the same system. A model-driven approach can thus reduce the cost of development. It can also reduce the cost of verification: if the transformations are shown or assumed to be correct, each new system or version can be verified in terms of its model, rather than its implementation. This paper introduces an approach to model-driven engineering that is particularly suited to the development of critical information systems. The language of the models, and the language of the transformations, are amenable to formal analysis. The transformation strategy, and the associated development methodology, are designed to preserve systems integrity and availability.

@&#INTRODUCTION@&#
Our society is increasingly dependent upon the behaviour of complex software systems. Errors in the design and implementation of these systems can have significant consequences. In August 2012, a ‘fairly major bug’ in the trading software used by Knight Capital Group lost that firm $461m in 45 minutes [1]. A software glitch in the anti-lock braking system caused Toyota to recall more than 400,000 vehicles in 2010 [2]. The total cost to the company of this and other software-related recalls in the same period was estimated at $3bn. In October 2008, 103 people were injured, 12 of them seriously, when a Qantas airliner dived repeatedly as the fly-by-wire software responded inappropriately to data from inertial reference sensors [3].In critical systems development, processes are put in place to detect errors and to mitigate their effects. Incidents such as those listed above have many contributing causes, many of which will be identified as failures of process. For example, only one of the eight causes given for the loss of the $125m Mars Climate Orbiter satellite [4] was directly related to development: “verification and validation process did not adequately address ground software”; the others were failures of communication and procedure. There is nevertheless considerable advantage to be gained from the adoption of automatic tools and techniques that promote correctness in development; if these can be used to eliminate certain kinds of error, then the dependency upon other processes is reduced; expensive, manual effort can be focused upon surrounding issues of management and validation.Information systems typically contain large amounts of valuable data subject to complex constraints. The value of the data will usually exceed that of the system: the consequences of data loss, data corruption, or inappropriate access may be unthinkable. This is not simply a matter of deletion. Consider, for example, a clinical system that holds information about doctors and patients. Such a system might hold, as part of a staff record, a list of patients allocated to a particular doctor. The allocation of a doctor may appear also as part of a patient record. If the system reaches a state in which patient A appears on the staff record for doctor B, but doctor B is not listed on the patient record for patient A, then information has been lost. If that information were required for a subsequent decision, then the consequences could be unfortunate.The constraints upon the data in the system may be representation or type invariants: if these fail to hold, then the behaviour of the system may be unpredictable. Alternatively, they may be semantic constraints or business rules. The symmetric relationship between allocation data on patient and doctor records is a simple example of a semantic constraint: if it fails to hold, then the meaning of the data within the system is unclear. A constraint that no patient is allocated to more than one doctor might be seen as a business rule: if the allocations are properly, symmetrically recorded, then the meaning may be clear, but the rule has been broken. This may mean that some function on the system fails to work as expected. These categories are not exclusive: depending upon the implementation architecture, some business rules may correspond also to representation invariants.We might hope to establish, by way of formal specification and proof, that each operation on a system could be guaranteed to satisfy the data constraints. We might proceed by: writing a formal specification Op for each operation; writing a formal specification C for each constraint; and proving that Op preserves the conjunction of all Cs. However, this approach has three, significant shortcomings: the specification of an operation may not be accurately reflected in its implementation; the system requirements, and hence the data constraints, may change, requiring that any existing proof be revisited; the proof may be difficult and expensive. It is also quite likely, on any particular iteration, that Op does not satisfy C, and one or both specifications will need to be revised.A scalable model-driven approach to development, in which software artefacts are generated automatically from precise, abstract models, offers a potential solution. If the implementation of each operation is generated automatically from its specification, and if the generation process is correct, then we can be sure that the specifications are correctly implemented. If the data constraints can be translated and incorporated, automatically, as part of the specifications, then we can be sure that these constraints will be satisfied in operation.The initial expression of the constraints, and the initial specification of each operation, would still need to be validated. Furthermore, some formal proof may be required to determine whether the results of the translation process—extended versions of the operation specifications that are guaranteed to satisfy the data constraints—correspond to expectations. However, this validation and proof can be conducted at a higher level of abstraction, with many details delegated to a once-only proof of the generation and translation processes. The cost of developing critical information systems, where data integrity can be guaranteed and functionality is predictable, is thus greatly reduced.In this paper, we introduce a formal language, Booster, for the specification of data constraints and operations upon information systems. This language is inspired by earlier formal techniques, and set in the context of object-oriented design. We use the Z notation [5] to show how abstract models of information systems can be translated into more concrete designs, and then compiled into complete, working implementations, and how the processes of translation and compilation can be formally verified. We present a simple methodology for the iterative development of critical information systems. We discuss the application of the methodology in the context of critical systems development, exemplified by the development of a system for patient monitoring and self-management in long-term conditions.This paper builds upon a contribution to the Formal Techniques for Safety Critical Systems workshop (FTSCS 2012) [6]: a methodology for establishing the correctness of the compilation process, from concrete design to working implementation, in the context of critical systems. That paper contains additional details of the generation of SQL code; this paper presents a substantially updated version of the methodology, extended to address transformation from abstract design to implementation. That paper contains a worked example based upon a hotel booking system; this paper contains an extract from the design of an actual critical information system developed using Booster: fully implemented, and relied upon by thousands of users.This paper complements a contribution on Success Stories in Model-Driven Engineering[7]: a report upon the application of the approach to the development of three different information systems. In that paper, we outline the original version of the Booster language and methodology and discuss lessons learned in its application to three case studies. The version of the language presented here is quite different from that of [7] and other, earlier papers [8,9]: framing information and other ‘compiler directives’ are no longer required; the constraint language is now the full first-order predicate calculus, rather than three classes of ‘programming constraint’; operations are now characterised as a single predicate, and may be composed using operation references. The transformations are now implemented in a declarative, functional language, more amenable to verification, and can be targeted at different platforms.Booster is an object modelling notation: the structure of a system is described as a collection of associated classes, in the style of the Unified Modeling Language (UML) [10]. The semantics of Booster are entirely consistent with the semantics of class diagrams in UML, and it is perfectly possible to use UML as an alternative means of presenting Booster models. The key difference lies in the way that operations are described. In most applications of UML, this is achieved using an imperative programming notation. In Booster, each operation is characterised by a single, logical predicate: describing the relationship between the values of attributes before and after the operation is performed.UML has its own language of predicates: the Object Constraint Language [11]. This is an object-oriented language, with operation and property calls that can be used to specify structural constraints, pre- and postconditions, and guards upon the transitions in state machines. An OCL postcondition can contain references to the values of attributes before an operation is performed, and can thus be used—for primitive operations—in the same way as a Booster operation predicate. For compound operations, it would be perfectly feasible to extend the OCL language specification [12] to allow references to the pre- and postconditions of other operations, treating each OCL ‘context’ as a property of the operation. Existing UML tools, however, do not support this usage.The syntax of OCL is considerably more verbose than that used within conventional predicate logic, reflecting in part a decision to make every aspect of the context of definition explicit. More importantly, the semantics of OCL is only partially defined when it comes to the specification of operations, reflecting the fact that UML sets out to support a range of different paradigms for interaction. In Booster, we are able to settle on a single paradigm, one that admits both abstraction and compositionality in design: every operation is implemented as an atomic transaction upon the state of the system—and not merely the current object. This greatly simplifies the interpretation of the predicate language.We may observe that the behavioural semantics for UML is not compositional with regard to abstraction and concurrency: that is, if we allow concurrent execution of operations, then it is not possible to derive a behavioural specification of a compound model from the behavioural specifications of its components—unless that specification contains every detail of the implementation, and thus has no abstraction at all. In particular, if we allow concurrent execution, then a characterisation of operations in terms of pre- and postconditions is not compositional. This is a particular problem in automated model-driven engineering, where we need to derive the implementation of an object from the specifications of operations, and the implementation of a system from the specifications of its component classes and associations.For these reasons, we have chosen to give Booster its own syntax and semantics, rather than adapt and extend those of UML. The syntax is based closely upon that of the B Method [13]: specifically, the Abstract Machine Notation (AMN). The semantics, and the means of distinguishing between values of attributes before and after an operation, is based upon that of the Z notation [5]. Object-oriented extensions have been proposed for each of these formal methods—most notably, UML-B [14] and Object-Z [15]—but again these have taken quite a different approach to behavioural semantics, supporting manual operation-by-operation design but not the automatic derivation of an implementation for a system from specifications of its component classes.An essential feature of the Booster approach is the decision that every operation should be implemented as a transaction upon the system, rather than the local object. This makes Booster unsuitable for the development of object-oriented programs in general, where concurrent execution of operations—even upon a single object—is standard practice. Booster is intended instead for the development of information systems, where concurrent access is limited to preserve semantic consistency, expressed in terms of essential relationships between different items of data. Information systems are often designed using UML: the classification and association of entities, the stratification of models and meta-models, and the description of the intended effect of operations upon them, offering significant advantages over earlier entity-relationship (ER) approaches.A Booster model is comprised of a series of class declarations, each of which introduces a number of attributes, associations, operations, and constraints. Attributes may be of four primitive types: String, Int, Float, or DateTime; they may also take values from user-defined enumerations. Associations are declared in the usual, textual way: by declaring association ends of appropriate type. The multiplicity of an association is given by the declarations of the association ends: types may be introduced as mandatory, optional, or set-valued; the last of these has an optional, additional multiplicity constraint. Mandatory associations are declared without decoration; optional associations are declared using square brackets; set-valued associations are declared using the keyword set.In Booster, all associations are paired. Without the ability to navigate in both directions, we may need to consider all of the objects of the source class when implementing an operation of the target class: we would not be able to refer directly to the set of currently-linked objects. As the normal mode of editing is textual rather than visual, the name of the mirror association is included as part of the declaration as an aide-memoire.As an example, consider the following pair of class declarations, illustrated in Fig. 1:classA{classB{attributesattributesm:Intn:Intb:[B.a]a:[A.b]}}An operation is declared as a single predicate on the values of expressions involving attributes, inputs, and outputs. Simple predicates are built from expression relational operators including equality (=), inequality (/=), set membership (:), and set non-membership (/:). Complex predicates may be constructed using the usual Boolean combinators of conjunction, disjunction, implication, and negation: &, or, =>, and not. Universal and existential quantifiers may be used over finite sets of values, forall x : X @ p and exists x : X @ p, with bound variables x being introduced for the scope p. As in the Z notation, attribute names may be decorated with a prime (') to indicate that we are referring to the value of that attribute after the operation has been performed.The name of another operation, qualified if necessary by a path to the object on which the operation is defined, can be included within an operation predicate. The effect is to include all of the constraint information of that operation, including the specified transformation of any attributes. This constraint information may be conjoined, disjoined, qualified, quantified, or negated, depending upon the way in which the other operation is being used as part of the operation being defined. It is possible also to combine predicates, and hence operations, using relational composition: p ; q denotes an operation that behaves as if there were an intermediate state, related to the initial state by p and to the final state by q.Value expressions may be constructed using arithmetic, set, and sequence operators. The expression syntax is that of the Abstract Machine Notation. For example, \/ denotes set union, /\ denotes intersection, and card denotes the cardinality function. The same collection of expressions may be used also in constraints: invariant properties introduced within class declarations to represent integrity constraints or business rules. All associations are navigable at the model level and a constraint may refer to attributes declared in associated classes. Access control is enforced through interface specifications.For example, the earlier class declarations may be extended to produce the complete model shown in Fig. 2. Here, class A has a single operation Inc, whose intended effect is described by the predicate m' = m + 1. Whenever this operation is performed, the value of attribute m afterwards should be one greater than it was before. A similar operation is declared in class B. Class A contains an invariant insisting that, in any object of class A, the value of attribute m should always be strictly less than 10. The invariant in class B insists, in any object of that class, that the value of n should be strictly greater than the value of m in a linked object a of class A. As a is declared as an optional attribute of B, this constraint will apply if and only if such a linked object exists.The predicate presented as part of an operation declaration is only a partial characterisation: each operation is constrained also by the constraints of the model, and further constraints may be added by the transformation rules—reflecting heuristics about the interpretation of the original, user-supplied predicates in the context of a particular application domain. In this example, the invariant within A constrains the action of A.Inc. Whenever the operation is performed, it is not only the case that m must be incremented; it must also be true that the new value of m is strictly less than 10. It would be problematic to perform A.Inc when the current value of m is 9: we cannot both meet the constraint of the operation and satisfy the model invariant.In general, we expect the availability of an operation to be determined in part by constraints declared elsewhere in the model. For example, the availability of a.Inc, for an instance a of class A, is determined partly by the constraint a.m < n declared in the associated class B: if there is a linked object b of class B for which m is one less than the value of attribute b.n, then to increment m without also incrementing b.n would violate that constraint. The transformation rules outlined in the following section ensure that operations cannot be performed when the resulting state would violate integrity constraints or business rules. In an implementation, this can be achieved through an exception mechanism, or by blocking an operation invocation, depending upon the target platform technology. In systems where a matching user interface is generated, any operation that is inapplicable in the current state of the system can be ‘greyed out’ or otherwise made unavailable to the user.A Booster model might be characterised as a computation independent model, in the sense of the Model-Driven Architecture [16, §2.2]: it sets out what the system is expected to do, but does not explain how this is to be achieved. For example, the operation specificationOp{x:s'}A set of model transformations are used to translate a Booster model into a model that is platform independent but no longer computation independent. The target language is a variant of the language of guarded commands proposed by Dijkstra [17], and generalised by Nelson [18]. The core concrete syntax of this language is shown below:Command::=skip|Path:=Expression|newId:Id|Constraint->Command|Command[]Command|Command||Command|Command;Command|allId:Expression.Command|anyId:Expression.Commandskip is a command that is always available, and has no effect upon the state of the system. The assignment a := e assigns the value of expression e to attribute a, which may be qualified by a navigation path in the usual way. new is used to denote the creation of a new, named object reference in the course of an operation: the new reference (first identifier, of type Id) points to a data structure representing a newly-initiated object of a particular class (second identifier). These and any other commands may be guarded (->) by a constraint, with the result that they are available only when the constraint is satisfied.The [] operator represents a prioritised choice between two guarded commands. In the command p [] q, if the guard for p is satisfied, then the command will behave as p. If not, the program behaves as q, and if the guard for q is not satisfied, the command as a whole will not proceed. The command thus proceeds if the disjunction of the two guards is satisfied. In contrast, || represents parallel composition. In p || q, each of the commands p and q will proceed, subject to the satisfaction of the conjunction of their guards. The [] and || operators have generalised equivalents in any and all: the first operand declares a bound variable name; the second operand is an expression which denotes a finite set of object references; the third operand is a command which may be applied to any or all of the objects—in any order—referred to in the expression. Finally, the ; operator allows the sequential composition of commands within a single transaction: the effect of p ; q is that of executing p and then q.The first stage of the translation process is the extension of each operation specification to include any other constraints upon the inputs and attributes involved. This involves the computation of a ‘transitive closure’ of related constraints: an attribute mentioned in the specification may be constrained relative to another that is not; other constraints upon that other attribute may need to be considered; those other constraints may involve further attributes, and so on. The applicability of an operation may depend upon the value of an attribute appearing in a different part of the object model: the transformation rules make any such dependency explicit, so that the operation can be correctly implemented. It may be that the dependency is unintended and unwanted, in which we case we might expect the model to be revised following inspection of the extended specification and/or analysis of the implementation.The second stage is the generation of a command for each operation. Each conjunct of the operation specification is mapped to a statement in the guarded command language. For example, a conjunct stating simply that a' = e will be mapped to the assignment a := e. If there is no obvious translation, then the conjunct is mapped to skip: the condition must then be established by some other part of the command; either that, or it must hold when the operation is invoked, and be preserved by the generated implementation; if this is not the case, then the operation will be unavailable.The third stage of the translation process is the generation of initial guards: for every choice command, and for every ‘completed’ guarded command. In each case, this is the weakest precondition for the command to achieve the extended operation specification, viewed as a constraint upon attribute values and outputs after the command is performed. For the subset of the guarded command language used, these preconditions may be calculated automatically: in the current version of Booster, we do not permit recursive definitions. The generated guards are strong enough to ensure that whenever a sequential command p ; q is executed, the result of executing p will be a state in which the guard of q is satisfied.Similarly, the guards are strong enough to ensure that whenever a parallel command p || q is executed, the specified result is guaranteed despite the potential for interference between p and q. These two commands may access the same variables, they may even assign to the same variables, but the effect of doing so within the same transaction can be calculated, and the necessary constraint upon attribute values and inputs imposed. For example, the specificationx′=y&x′=3will be translated to the commandy=3->(x:=y||x:=3)In the current version of Booster, assignments to expressions referring to the values of attributes after an operation is performed are mapped to skip. It would be possible to perform a topological sort of conjuncts, to determine whether there is an order in which the corresponding assignments or substitutions might sensibly be performed. However, the advantage of doing so is quite marginal, and would seem to conflict with the overall approach or philosophy. The translation process is intended to make the consequences of decision intentions explicit, and to automate routine aspects of development, in a way that helps the developer to discover errors in design, or to safely implement a design that is already correct. The fact that the specificationx′=y′&y′=3is mapped to the guarded commandx=3->(skip||y:=3)x=3->y:=3In most cases, the translation of each individual conjunct is quite straightforward. The value of the Booster approach lies in this process of discovery, modification, and automatic implementation. The calculated guards take full account of class invariants, symmetry and multiplicity restrictions upon associations, attribute type constraints, and potential aliasing of attribute names, as well as the original specification of the operation—and the specifications of any other operations included in its definition. For example, the operation predicateInc{m'=m+1}Inc{m<9&(b/=null=>b.n>m+1)->m:=m+1}A second set of model transformations are then used to produce a platform specific model, tailored to a particular implementation architecture. In our initial work with Booster [7], we generated bespoke, in-memory databases. The current version targets instead commonly-used relational database platforms; this has the benefit of reducing the “proof surface”: the extent of code that needs to be certified, verified, or validated; in the context of medical applications we are able to assume that the underlying database engine can be trusted, having been “proven” through global commercial use.The object model is translated into a relational schema, and implemented as a series of SQL statements. Each operation program is translated into a stored procedure which has the corresponding effect upon the state. Different transformations have been implemented to target specific relational database platforms; however, the subset of the SQL language used is such that only minor variations are required—for the most part, concerning naming restrictions. The same approach can be used to target other technologies with quite different notions of transaction: such as document stores and distributed file systems.The structural aspects of the translation are relatively straightforward: similar translations are performed by various object-relational bridging tools such as Hibernate [19]. In Booster, classes and associations are mapped to individual tables; attributes translated to columns, and the inheritance hierarchy—not discussed in this paper—is flattened. For example, our running example might produce the following MySQL script extract for creating tables and columns:createtableA(idintauto_incrementprimarykey);createtableB(idintauto_incrementprimarykey);createtableA_b(idintauto_incrementprimarykey);createtableB_a(idintauto_incrementprimarykey);altertableBaddcolumnnint;altertableAaddcolumnmint;altertableA_baddcolumnAint;altertableA_baddcolumnBint;altertableB_aaddcolumnBint;altertableB_aaddcolumnAint;In the generated database, classes A and B are implemented as tables in which each row represents the state of an object instance, storing the values of primitive attributes for which the multiplicity is either 1 or 0..1. The first column of each table stores a unique integer-valued primary key, which will be used for object-references. Attributes that are set-valued, or which denote associations, are held in separate tables. The bidirectional association also gives rise to a pair of symmetric tables: the table A_b stores links corresponding to the references in attribute b of class A; the table B_a stores links corresponding to the references in attribute a of class B.A greater challenge lies in the definition of appropriate procedures: the feature set available in a particular vendor's implementation of SQL may not support all of the obvious translations. In such cases, part of the required functionality may need to be implemented at the next layer of the design, as part of an applications programming interface (API) to the data store. A simple example is afforded by the treatment of input parameters in MySQL: it is not possible to verify that an input is of a particular, primitive type; this check must be performed by the API.For example, the operation A.Inc specified above would be implemented as:createprocedureA_Inc(inthisint)begindeclareexithandlerforsqlwarning,sqlexception,notfoundbeginrollback;end;starttransaction;if(selectmfromAwhereid=this)<9and((selectcount(*)fromA_bwhereA=this)=1and((selectnfromBwhereid=(selectBfromA_bwhereA=this))>(selectmfromAwhereid=this)+1)or(selectcount(*)fromA_bwhereA=this)=0)thenset@m=(selectmfromAwherethis=id);updateAsetm=@m+1wherethis=id;endif;commit;end//Here, the generated procedure checks to see whether the guard given in the specification holds for the current state of the database: whether the value of m for the current object reference this is less than 9, and also more than one less than the value of b.n for any associated data corresponding to a linked object of class B. If this is the case, then the update can be performed.The benefits of the approach could be quantified in terms of the number of statements needed at each level of description. In the above example, a single statement within the specification of an operation gave rise to four statements in a guarded command description, and twelve statements in a SQL implementation. The relative complexity of expression evaluation in SQL, where the original specifications involve object navigation paths, means that an increase of at least an order of magnitude should be expected. The increase will be greater for models including class and association invariants, including constraints upon multiplicity. The current implementation of Booster includes more than 1200 rules to support the two levels of translation, 300 of these are used for SQL implementation. Most of these rules are trivial, and most can be considered independently of the others. A small number of rules involve complex pattern matching and calculation, and need careful consideration. Once proved correct, however, they will serve for the production of many different systems.

@&#CONCLUSIONS@&#
