@&#MAIN-TITLE@&#
Loading, unloading and premarshalling of stacks in storage areas: Survey and classification

@&#HIGHLIGHTS@&#
Survey of loading, unloading, and premarshalling of stacks and combined problems.New classification scheme.Survey of complexity results, solution algorithms, and computational results.

@&#KEYPHRASES@&#
Loading,Unloading,Premarshalling,Storage,Stack,Classification scheme,

@&#ABSTRACT@&#
Problems of loading, unloading and premarshalling of stacks as well as combinations thereof appear in several practical applications, e.g. container terminals, container ship stowage planning, tram depots or steel industry. Although these problems seem to be different at first sight, they hold plenty of similarities. To precisely unite all aspects, we suggest a classification scheme and show how problems existing in literature can be described with it. Furthermore, we give an overview of known complexity results and solution approaches.

@&#INTRODUCTION@&#
The interim storage of items in a storage area leads to different kinds of optimization problems. On the one hand, if incoming items arrive at a storage area, they need to be assigned to positions which causes loading problems. On the other hand, unloading problems arise if outgoing items need to be retrieved from the storage area and one has to decide which items will leave the storage in which order and which relocations are performed. Premarshalling occurs if items have to be sorted inside the storage area such that all items can be retrieved without any further reshuffle afterwards. If incoming items need to be stored while outgoing items need to be retrieved, combined loading/unloading problems appear.In this paper, we concentrate on storage problems where the storage area is organized in stacks and items are put on top of each other in these stacks. Each stack may have a limited height and its own fixed position in a two-dimensional area. The items are assumed to be cuboids, e.g. containers or wooden/steel plates. Problems dealing with the storage of round items require another layout and other stacking conditions(cf. Tang, Zhao, and Liu (2012) and Zäpfel and Wasner (2006)).A storage area can either be a yard, a warehouse or a tram/bus depot, but also a container ship where containers are stored in the bunt. For a comparative survey of different stacking policies in container terminals see Dekker, Voogd, and van Asperen (2006). An overview of warehouse management problems and different warehousing models can be found in van den Berg and Zijm (1999). De Koster, Le-Duc, and Roodbergen (2007) provide a survey of how to retrieve items in high rack warehouses where items are stored in racks and accessible from the side. High rack warehouses with movable shelves are also called “puzzle-based storage systems”(cf. Gue and Kim (2007) and Alfieri, Cantamessa, Monchiero, and Montagna (2012))since the problem of moving a shelf to the exit is similar to the so-called 15-puzzle (a classical children’s game).In practice, all operations to move and get items are executed by cranes located above the stacks so that direct access is possible only to the topmost item of any stack, i.e. the items are arranged in LIFO-order (last in, first out). This implies that if an item stacked below has to be retrieved, so-called reshuffling (or relocation) is necessary. We assume that once a required item is the topmost item of a stack, it can be retrieved instantaneously. An example with two stacks and four items is given in Fig. 1. If the gray item at the bottom of the left stack has to be retrieved, two reshuffling operations are needed to free this item. Since reshuffling operations are usually very time-consuming, they should be avoided as often as possible.Loading problems deal with the storage of incoming items. Each item reaching the storage area has to be assigned to a feasible location. In a pure loading problem, it is assumed that no outgoing item is retrieved during the loading phase. Loading problems typically arise in container terminals where containers arrive by truck, train or vessel and have to be stored until they are required to be retrieved. Since the individual retrieval times of the items are usually unknown at the time of loading, the objective often aims at minimizing the number of expected reshufflings(cf. Jang, Kim, and Kim (2013) and Kim, Park, and Ryu (2000)).Unloading problems deal with the retrieval of items from a storage area. Depending on the type of problem one has either to define the order in which items are retrieved or decide which items are to retrieve in order to fulfil certain requests. Additionally, the way, how relocations are performed, has to be determined. In Fig. 2, an example for an unloading problem with 8 items can be found. Given an area with four stacks, each limited to hold three items at the most, the items have to be retrieved in the order1,2,…,8. In order to do this, 4 reshuffles are needed in total. This is the minimum number of reshuffles since item 4 needs to be reshuffled to get access to item 2, item 6 needs to be reshuffled to get access to item 3, item 8 needs to be reshuffled to get access to item 1 and no matter which stack item 8 will be reshuffled to, at least one more reshuffle becomes necessary.In a pure unloading problem, it is assumed that there are no incoming items during the unloading phase. Many storage unloading problems are inspired by retrieving containers from container terminals to store them onto vessels, trains or trucks(for an overview see e.g. Caserta, Schwarze, and Voß (2011a)). Other practical applications for storage unloading occur in steel industry or tram/bus depots. In the former, steel slabs are stored in stacks and have to be retrieved in a given order to a hot rolling mill. In the latter, items are stored on sidings with dead ends, so they can be modeled as (vertical) stacks, organized in LIFO-order. The waggons stored on the sidings have to be retrieved to join several waggons to one tram. Since access is only possible from one end of the siding, shunting might be necessary to retrieve a required waggon. For example, Blasum et al. (1999), Gallo and Di Miele (2001) and Gatto, Maue, Mihalák, and Widmayer (2009) deal with shunting problems in tram/bus depots. In both, steel industry and tram depots, items are often grouped into families. Then, a retrieval request does not ask for a specific item, but for any item of a specific family(cf. for example Tang, Liu, Rong, and Yang (2002)).Premarshalling problems occur if items inside a storage area have to be sorted such that they can be retrieved without any additional reshuffle afterwards. The difference to an unloading problem is that during premarshalling no item leaves the storage area, i.e. the area always contains the same set of items(cf. for example Lee and Hsu (2007), Caserta and Voß (2009a) and Bortfeldt and Forster (2012)). In Fig. 3, one can find an example for a premarshalling problem with 8 items. The initial layout is the same as in Fig. 2 with an area of four stacks each limited to hold at most three items. The items have to be sorted such that they can be retrieved in the order1,2,…,8. This can again be done with 4 reshuffles in total (which is the minimum number of reshuffles, see the explanation above).Combined problems mostly occur as a combination of loading and unloading, which means that new items arrive and need to be stored simultaneously to the retrieval process. Predominantly, combined problems can be found in container stowage planning where vessels are used to transport containers and call sequentially at several ports(see e.g. Aslidis (1989) and Avriel, Penn, Shpirer, and Witteboon (1998)). The containers’ departure and destination ports are known in advance determining the loading and unloading processes, respectively. Other combined problems occur as a combination of loading and premarshalling(see Malucelli, Pallottino, and Pretolani (2008)). In this case, several sets of incoming items have to be stored sequentially. During the loading process, premarshalling may be performed with the goal that at the end of the loading process all items can be retrieved without any additional reshuffle.Since storage problems originate from a wide range of practical applications, a lot of scientific literature exists dealing with problems motivated from practice. Although these problems are described in different terms and notions, they share several similar features. For example, both in warehouses and in container yards, items are piled up on each other accessible from the top only. A main difference is that warehouses have higher stacks (30–40 items may be stacked in contrast to approximately 4–5 containers in a container yard) and handle much more items. Furthermore, the item flow of retrieving and storing is done in parallel while in container yards these operations are done one after another(cf. Caserta et al. (2011a)).Reviews dealing with various optimization problems in container terminals can be found in Vis and De Koster (2003), Carlo, Vis, and Roodbergen (2014a, 2014b), Steenken, Voß, and Stahlbock (2004); and Stahlbock and Voß (2008). Vis and De Koster (2003) give an overview of different processes at a container terminal involving the arrival, unloading and loading of a ship as well as the transport and stacking of containers. They deal with berth allocation for vessels, assignment of containers to locations, crane scheduling and vehicle routing problems. Further overviews have recently been published by Carlo et al. (2014a, 2014b). In the former, the authors propose a classification scheme for storage yard operations in container terminals including yard design, material handling equipment selection and routing, as well as storage space design. In the latter, the authors focus on transport operations such as selecting, routing and dispatching of vehicles. Another extensive survey can be found in Steenken et al. (2004). The authors provide detailed problem descriptions for different (sub) problems arising in container terminals involving a detailed literature review for each of the subproblems. An update can be found in Stahlbock and Voß (2008), additionally including an overview of integrative approaches like analytical, simulation and multi-agent approaches.Bierwirth and Meisel (2010) focus on the berth allocation and crane scheduling problem and integrated approaches. In the former, different layouts, temporal constraints and objectives are considered. After the crane assignment has been done (i.e. cranes are assigned to vessels such that all tasks can be executed), the crane scheduling problem has to be solved defining starting and ending times for every task while usually minimizing the makespan. Integrated approaches avoid to solve these problems sequentially, but try to find a solution for the problem on the whole. The authors propose classification schemes for each of these three problems.Crane scheduling problems in warehouses are treated in van den Berg and Gademann (1999). It is assumed that sets of incoming and outgoing items are given and their locations are known. The problem is to sequence the crane moves such that the total traveling distance is minimized. This problem is equivalent to the traveling salesman problem and hence in general isNP-hard. However, in van den Berg and Gademann (1999) a special case of the TSP is identified which can be solved in polynomial time.In the problems considered in the paper at hand, it is assumed that loaded containers have to be treated. The problem how to pack smaller three-dimensional items into a three-dimensional container is surveyed in Bortfeldt and Wäscher (2013). The authors classify problems into several problem types with various constraints, e.g. weight limits, loading priorities and stacking constraints. They give an overview of modeling approaches as well as exact and heuristic algorithms. Another survey for cutting and packing problems can be found in Wäscher, Haußner, and Schumann (2007). The authors describe the structure of cutting and packing problems and provide an improved typology on the basis of the typology suggested in Dyckhoff (1990). They differentiate several assortments, and categorize basic, intermediate and refined problem types.In order to classify practical problems and existing literature, it is always helpful to have a clear (and more abstract) description combining all basic characteristics. Classification schemes have been proposed for several kinds of optimization problems(e.g. Graham, Lawler, Lenstra, and Rinnooy Kan (1977) for machine scheduling, Desrochers, Lenstra, and Savelsbergh (1990) for vehicle routing and Boysen, Fliedner, and Scholl (2007) for assembly line balancing problems). To the best of our knowledge, no such scheme exists for loading, unloading and premarshalling problems so far. In this paper, we suggest a scheme which is applicable to all three problem classes and combinations thereof. Its objective is to have a clear description combining the characteristics of problems considered in practice or literature in a unified way. Moreover, in combination with elementary reductions it simplifies drawing the borderline betweenNP-hard and polynomially solvable problems.The remainder of this paper is organized as follows: In Section 2, we describe basic problem variants and possible constraints more formally. A classification scheme is presented in Section 3 which is applied to existing literature in Section 4. There we summarize known complexity results and solution approaches for loading, unloading, premarshalling, combined and further problems. The paper concludes with some remarks in Section 5.In this section, we describe the studied problems in more detail. In Section 2.1 we define the general storage layout and some basic assumptions. In Section 2.2 we discuss several ways how incoming and outgoing items may be specified. Different problem variants and constraints that occur in connection with loading, unloading and premarshalling problems are presented in Section 2.3.We focus on problems where the storage area is arranged in stacks and each stack has its own fixed position in a two-dimensional area. This means that one cannot decide where to position a stack in the area but which stack to use for putting an item. In contrast, Jaehn (2013) considers a storage loading problem occuring in rail–road terminals where the storage area does not contain fixed positions for the stacks but is divided into parallel lanes. Then a stack can be opened at any (continuous) position in a lane with respect to safety distances.LetM={1,…,m}be the set of stacks. The set of all items is denoted asI={1,2,…,n}where normally the inequalitym<nholds, i.e. some items have to be stacked on other ones. In practice, items might be of different size (e.g. 20-feet and 40-feet containers). Since containers with different lengths are usually not stored in the same subarea, we assume that all items have the same size. The items are moved by one or more cranes which are located above the stacks. Therefore, the cranes limit the height of the presented stacks so that one stack cannot hold more than a certain number b of items.It is assumed that the stacks are arranged in a single line, i.e. the storage area is only 2-dimensional (although in reality it is 3-dimensional since the columns themselves are arranged in a 2-dimensional area). This is illustrated in Fig. 4: While in (a) the 3-dimensional area is shown, the corresponding stacks are depicted in two dimensions in (b).An item is said to be blocked if one or more items with later retrieval times (so-called blocking items) are stacked above it. To retrieve the current target item, all blocking items need to be removed from the current stack and pushed onto other ones until the target item is free (i.e. it is the topmost item). Moving an item from one stack to another is counted as one reshuffling (or relocation) operation.In some applications(e.g. Aslidis (1989) and Avriel et al. (1998)), the storage area is represented as a rectangular bay which is divided into C columns, each having R rows (levels) which are filled from the bottom levelr=1to the top levelr=R. Relating C and R to our notation, C defines the number of stacks m and R corresponds to the number of items in each stack, i.e. the height b.In container terminals, items are usually stored in “bays” and “blocks” where a bay consists of several stacks and a block consists of several bays. If items are reshuffled within the same bay, the number of relocations is normally taken as measure of workload for the cranes. Since the distance between two bays of the same block or even two blocks is much higher than between items inside the same bay, one has to sum up the number of relocations and the traveling distances for the cranes. In this paper, we do not distinguish between relocations between bays and blocks. If problems with relocations between bays of the same block or different blocks have to be classified, the objective function will cover the number of relocations and transportation costs.A very important feature of storage problems is the way how incoming and outgoing items are specified. In the following, we describe how this is typically done in practical applications (considering loading, unloading and combined problems).•In loading problems, it is common to store a set of incoming items since for example a train containing several containers has to be unloaded. In this case, the sequence of storage operations does not matter, but all items in the set have to be loaded to the storage area.A sequence of incoming sets is given if several trains arrive consecutively at the storage area and have to be unloaded in the order of their arrival. In this case, all items belonging to the same train have to be loaded before any item of another set can be stored.In unloading problems, items often have to be retrieved in a predefined sequence given by the order in which trucks arrive or items are needed for production. A pure unloading problem where a sequence of items has to be retrieved while minimizing the total number of reshuffles, is also called blocks relocation problem (BRP), see e.g. Caserta et al. (2011a).Another common feature is that a sequence of outgoing item sets is given(named the container relocation problem (CRP) in Forster and Bortfeldt (2012a)). A typical example is a container terminal where stowage plans of several container ships are given determining which vessel has to be loaded with which containers (but with unknown sequence for each vessel). Other practical applications are based on items which are grouped according to destination or customer, length or weight class and which have to be delivered consecutively in these groups.Sometimes, a set of sequences may be of special interest. This applies for example in storehouses where (wooden) plates need to be delivered to two or more saws for cutting, with one sequence for every saw. In this case, the sequences themselves have to be respected but might be mixed in delivery (by determining a schedule for a single crane).To get an overview of the different ways in which outgoing items can be specified, look at the example in Fig. 5where the retrieval of a sequence, a set, a sequence of sets and a set of sequences is illustrated. We assume that the storage area consists of three stacks each limited to hold at most three items. The initial storage layout is given in Fig. 5a.–In Fig. 5b, the retrieval process for the retrieval sequenceπout=(1,2,3,4,5,6,7)is depicted. It requires three reshuffles in total.In Fig. 5c, two reshuffles are necessary to retrieve the setIout={1,2,3,4}. Since the order of retrievals does not matter in this case, item 4 can be retrieved at first. Afterwards, items 5 and 6 are reshuffled so that items1,2and 3 can be retrieved in any order.In Fig. 5d we are given a set of sequences,{πout}2={(1,2,3,4),(5,6,7)}, where the retrieval order for each sequence has to be respected. In this example, no reshuffle is necessary because items 5 and 6 can be retrieved first (respecting the order ofπ2out), items1,2,3,4are retrieved afterwards (respecting the order ofπ1out) and, finally, item 7 is retrieved (as last item of sequenceπ2out).In Fig. 5e, we are given a retrieval sequence of sets,(Iout)2=({1,2,3,4},{5,6,7}). First, the set{1,2,3,4}has to be retrieved (in any order) which requires two reshuffles. Second, set{5,6,7}can be retrieved without any reshuffle.In combined problems, sequences of sets are often given. For example, in the container stowage problem (CSP), a vessel is considered calling sequentially at K different ports. At each port, a set of containers needs to be retrieved from the vessel while another set of containers needs to be stored into it(see e.g. Aslidis (1989) and Avriel and Penn (1993)). So, we are given a sequence consisting of K entries, where each entry contains a tupel (set of outgoing items, set of incoming items). These sets can be extracted directly from the upper triangular transportation matricesTijwhich specify the number of containers going from port i to port j. In each row i, one can identify all items that have to be loaded at port i, in each column j, one can identify all items that have to be unloaded at port j. Consider the example in Fig. 6where a transportation matrix is given on the left and the corresponding sets of incoming and outgoing items are depicted on the right. The set of incoming items at port i is denoted byIiin, the set of outgoing items at port j is denoted byIjout. If h items are going from port i to port j, they will be namedij1,…,ijh.In this subsection, we describe variants and additional constraints that occur in loading, unloading and premarshalling problems.•Pushing back items: After having retrieved the current target item, two procedures are conceivable. It is either possible to push-back all reshuffled items so that the stack is in the same order as before except the missing retrieved item, or to let the items stay in the stacks they have been pushed onto(cf. Tang et al. (2002)). In the former, the items are pushed back immediately after the target item has been retrieved. Relocating an item and pushing it back is counted as two reshuffle moves. In the example of Fig. 1, pursuing push-back will enforce putting back the two reshuffled items to the first stack after having retrieved the gray one. Although in the push-back strategy additional relocations are necessary, sometimes this procedure is preferred (e.g. if some items may only be stored in certain stacks or to avoid that items change their initially assigned stacks).Forced vs. voluntary moves: For storage loading and unloading problems two kinds of reshuffling moves are distinguished(cf. Caserta, Schwarze, and Voß (2012)): forced and voluntary ones(also called “cleaning moves” in Petering and Hussein (2013)). In an unloading problem, forced moves only reshuffle blocking items in order to retrieve the next outgoing item, while voluntary moves allow relocations of arbitrary items. In a loading problem, forced moves only handle incoming items (and put them on top of a stack), while voluntary moves may relocate arbitrary items (by this, incoming items may also be put inside a stack). The notions do not apply for pure premarshalling problems since there are no incoming or outgoing items. In combined loading/premarshalling problems, the distinction between forced and voluntary moves may be used in the loading phase.To differentiate between strategies that only use forced moves or additionally allow voluntary moves, we give a small example of unloading stacks. Consider a storage area consisting of three stacks each able to hold at most three items. The items are numbered according to the sequence in which they have to be retrieved. In a rather simple strategy for relocations, a blocking item will be put on the nearest stack which does not contain three items yet. If several such stacks are available, the stack with the highest number of the topmost item will be chosen to avoid further relocations (this might not be the best strategy but suffices for this small example). If the current target item is freed, it will be retrieved immediately.Consider the retrieval process in Fig. 7where the items have to be retrieved in the order1,2,…,6and only forced moves are allowed. In the first step, items 4 and 3 are put on the stack nearby to free item 1. After item 1 has been retrieved, items 3 and 4 have to be reshuffled again to get access to item 2. Since afterwards items 2, 3 and 4 can be retrieved without any further relocation, there is only one more reshuffle to provide access to item 5. In total, 5 relocation moves are needed to retrieve the six items in sequence.If also voluntary moves are allowed, only 4 relocations are needed in total (cf. Fig. 8): in the first step, put item 2 on the third stack such that items 4 and 3 do not block it on stack two. Afterwards, items 1 to 4 can be retrieved without any further relocations such that only one more reshuffle is needed to free item 5.As the example shows, using voluntary moves may lead to a reshuffling process with less relocations. However, often in practice and in most of the literature only forced moves are considered in order to simplify the process and reduce the number of possible movements in each step.Grouping of items into families: In many problems, all items are assumed to be unique. But it is also possible that items of the same specifications are grouped into item families. This situation arises in warehousing of wooden plates or iron sheets where several plates of same size and type of wood/iron may exist(see e.g. Tang et al. (2012)). Other practical applications where items occur in families can be found in tram yards/railway stations(cf. Blasum et al. (1999) and Freling, Lentink, Kroon, and Huisman (2005), for example). If we look at an unloading problem where items are grouped into families and the retrieval asks for one specific family, all items of that family serve as potential candidates for retrieval. In this situation, one has to decide which candidate will be chosen. In Fig. 9an example for an unloading problem with families is shown. We assume that the sequenceπout=(1,2,3,4)of outgoing items has to be retrieved. On the left, the storage area contains two stacks each able to hold at most three items. In this case, all items are unique so that three reshuffles are needed to retrieve the items in the given sequence. On the right, items are grouped into families. We assume that there are four familiesFiwithFi={i1,i2}fori=1,…,4. In each step i of retrieving, we can choosei1ori2to retrieve one element from familyFi. Thus, if we choose the sequence(11,22,31,42), one can retrieve all items in the desired sequence without any reshuffle.An additional temporary storage area: In some problems, a temporary storage area is available for the interim storage of items that need to be removed from the stack to retrieve the current target item. If the temporary storage area is large enough, sorting can easily be done since every item can be assigned to an own stack in the temporary storage area and all items can be pushed back to the stack in a sorted order. In this case, putting an item to the temporary storage area and pushing it back is counted as two relocation moves. For example, such an (unlimited) temporary storage area is often implicitly assumed in combined problems where a vessel calls at many ports in sequence (each port has such an area) and in problems where the storage area contains only one stack since otherwise no reshuffling would be possible(cf. Malucelli et al. (2008)).Stacking restrictions have to be respected if not every item may be stacked on any other item (for example, an item with a larger weight may not be stacked on top of a lighter one).Location restrictions: Sometimes, especially in container stowage planning, items may only be placed to some of the locations (described by tuples(stack,level)) in the stacking area. For example, reefer containers need a power plug, so only locations with an appropriate configuration are possible for storage. Such location restrictions may be given as hard or soft constraints.Objective functions: Various objective functions arise in storage loading or unloading problems. Typically, reshuffles are very time-consuming and therefore form the bottleneck of storage processes. That is why it is conventional to minimize the number of reshuffles. In storage loading problems where retrieval times are unknown but can be estimated by a probability distribution, the number of expected reshuffles often serves as objective.Sometimes, not the exact number of required reshuffles is determined but a lower bound value. For this purpose, “unordered stackings” are counted (e.g. the total number of blocking items with respect to retrieval times). As another objective, one may want to minimize costs for assigning items to specific locations, e.g. given by travel costs or penalty costs for violated (soft) location restrictions. A further possibility is to penalize assignments where items belonging to the same ship or having the same destination port are not stored nearby.The minimization of hatch overstows is a further objective which occurs in the context of container ship stowage planning. The storage area inside a ship is separated in “below deck” and “on deck” by so-called hatches. If a container below deck has to be retrieved, all containers on the hatch have to be removed first. Therefore, overstowage between containers below and on deck should be avoided(cf. Tierney, Pacino, and Jensen (2014)).In this section we propose a classification scheme which is applicable to loading, unloading, premarshalling problems and combinations thereof. Its objective is to have a clear and abstract description combining characteristics of the most common problems considered in practice or literature. It is designed in such a way that it is easily extendable to capture additional hard or soft constraints for further (more specific) problems. Additionally, we present some elementary reductions which in combination with known complexity results imply further results. If on the one hand, a problem is polynomially solvable, also all special cases are polynomially solvable. If on the other hand, a problem isNP-hard, then also all generalizations areNP-hard.The scheme we suggest consists of three fieldsα|β|γ. Theα-field specifies the problem type (loading/unloading, premarshalling, combined problem) and contains information about the parameters describing the storage area, e.g. number of stacks and their maximum stacking height. Theβ-field includes details of the items themselves, e.g. stacking restrictions or other additional constraints, where at last theγ-field holds the objective function. The empty symbol∘is always used to represent the standard situation.Theα-fieldThe first parameter in theα-field isα1∈{L,U,P,LU,LP}. It states whether we look at a loading, unloading, premarshalling or combined (loading/unloading or loading/premarshalling) problem.α1=Lifaloadingproblemisconsidered,Uifanunloadingproblemisconsidered,Pifapremarshallingproblemisconsidered,LUifacombinedloading/unloadingproblemisconsidered,LPifacombinedloading/premarshallingproblemisconsidered.A LP problem is defined as loading items in several stages such that at the end of the complete loading process, all items can be retrieved without any additional reshuffle. During loading, premarshalling is allowed. Note that it does not make sense to define a combined premarshalling/unloading problem in an analogous way since it decomposes into several independent premarshalling problems.To specify the parameters of the storage area, we useα2=m=m′ifthenumbermofstacksisequaltoafixednumberm′∈N,m⩾nifthenumberofstacksislargerorequaltothenumberofitems,∘ifthenumberofstacksmisgivenaspartoftheinput,andα3=b=b′ifthelimitbonthenumberofitemsineachstackisgivenbyafixednumberb′∈N,b=∞ifnolimitonthenumberofitemsineachstackisgiven,∘ifthelimitbonthenumberofitemsineachstackisgivenaspartoftheinput.The distinction whether m and b are part of the input or are fixed values may be important for complexity considerations. For example, if m is fixed, an algorithm with complexityO(nm)can be classified as polynomial. Besides writingm=2orm=3with a specific number we also writem=m′in order to indicate that m is an arbitrary, but fixed value.In order to specify the size of a temporary storage area, we useα4=Stmp=(m̃,b̃)ifatemporarystorageareaconsistingofm̃stackswithlimitb̃isavailable,∘ifnotemporarystorageareaisavailable.Fig. 10shows elementary (polynomial-time) reductions between the entries of the parametersα2toα4. In this graph there is an arc between two possible entriesαi′,αi″of one parameterαiifαi′reduces toαi″(i.e.αi′is a special case ofαi″).Theβ-fieldAs described in Section 2, incoming and outgoing items can be specified either as a sequence, a set, a sequence of sets or a set of sequences.For loading problems we useβ1=πinif a sequence of incoming items is given,Iinif a set of incoming items is given,(Iin)Kif a sequence of lengthKcontaining setsof incoming items is given,{πin}Kif a set ofKsequences of incoming items is given.Note thatπinis a special case of(Iin)Kwhere each setIinonly contains one element. Obviously,Iinandπinare special cases of(Iin)Kand{πin}K, respectively withK=1.For unloading problems we useβ1=πoutif a sequence of outgoing items is given,Ioutif a set of outgoing items is given,(Iout)Kif a sequence of lengthKcontaining sets ofoutgoing items is given,{πout}Kif a set ofKsequences of outgoing items is given.In unloading problems where items are grouped in families, a subscriptedFwill be added, so that we haveπFout. The special case of disjoint families is indicated byπdisj-Fout. If the retrieval times of items are unknown and estimated by past statistics, we will useπ̃outto indicate a stochastic output sequence.For combined loading/unloading problems, often several iterations of loading/unloading take place. We useβ1=(πin,πout)if at first one sequence of incoming items andafterwards one sequence of outgoing items is given,((Iin)K,(Iout)K′)if at first one sequence of lengthKcontaining sets of incoming items andafterwards one sequence of lengthK′containing sets of outgoing items is given,(Iin,Iout)Kif a sequence of lengthKcontaining sets of incoming and outgoing items is given.Note that in the third case some of the sets may also be empty (i.e. we may have several incoming or outgoing sets consecutively). For combined loading/premarshalling problems, no combination of incoming and outgoing items occurs (specifying the incoming items is sufficient in this case).Stacking restrictions may be encoded by a 2-dimensional matrixS∈{0,1}n×nwheresij=1if itemiis stackable on top of itemj,0otherwise.In the classification scheme we useβ2=sijif stacking restrictions have to be respected,∘otherwise.Sometimes, items may have additional characteristics like weights or heights. Then, in addition to the number b that limits the number of items in each stack, one has a height or weight limit for each stack. We useβ3=weight-limitif the total weight of each stack is limited,∘otherwiseandβ4=height-limitif the total height of each stack is limited,∘otherwise.Note that if all items are of the same height, it is sufficient to specify the limit b.β4=height-limitis only used if items have different heights. In this case,α3can either containb=∞or a limited b. In the former, only the height-limit has to be respected while in the latter, each stack has to respect the height-limit and the limit b for the number of items.If location restrictions have to be respected, we may assume that for each item i a setLiis given which contains all locations in the storage area to which i may be assigned. We useβ5=Liif location restrictions for the items are given,∘otherwise.In storage loading and unloading problems, forced moves are always allowed. To indicate whether also voluntary moves are allowed, we useβ6=v-movesif voluntary moves are allowed,∘otherwise.To denote that items have to be pushed back after they have been reshuffled to retrieve a target item, we useβ7=push-backif items have to be pushed back,∘otherwise.Fig. 11shows elementary (polynomial-time) reductions for theβ-field.Theγ-fieldTheγ-field involves the objective function:•-: Decide whether a feasible solution for the given problem exists.#RS: Minimize the number of reshuffles.#RS=0: Decide whether the problem can be solved without any reshuffles.E(#RS): Minimize the expected number of reshuffles. This applies to problems where the retrieval times are unknown but can be estimated by a probability distribution.TC: Minimize transportation costs, mostly given as workload for cranes. The workload consists of the time needed to lift up and lower down an item, the time needed per shuffle and the time to retrieve an item.#US: Minimize the number of unordered stackings (sometimes also called “mis-overlays” or “overstowage”) with respect to retrieval orders given byπoutor(Iout)K. In the following, we present different possibilities to measure unordered stackings. For illustration we use the example in Fig. 12where the items have to be retrieved according to non-decreasing numbers.–#USadj: Every two adjacent items in a stack are counted as unordered if the upper item blocks the lower one. It is easy to see that this number is a lower bound on the total number of reshuffles in order to retrieve all items in a given sequence(i.e. for the BRP, cf. Voß (2012)). In the example, in the left stack item 3 blocks item 1; in the right stack, item 6 blocks item 5 which in turn blocks item 4. Therefore,#USadj=3.#USdep: For each stack we determine the largest depth (counted from above where the top element is assumed to have depth 0) in which a blocked item occurs. The sum of these depths gives a lower bound on the total number of reshuffles in a premarshalling problem(cf. Lee and Chao (2009)). In the example, the depth is 1 for the left stack (item 1 in depth 1 is the deepest blocked item). In the right stack, the depth is 3 (caused by item 4). Therefore, the sum amounts to#USdep=4.E(#USadj(w̃)): Minimize the number of expected unordered stackings with respect to estimated weightsw̃of the items. This objective occurs in some loading problems where the weight (or weight group) of an arriving item is uncertain and estimated by past statistics. Since often heavier containers have to be retrieved earlier (e.g. when storing them on a ship afterwards), they should not be stacked below lighter ones.#HO: Minimize the number of hatch overstows. One hatch overstow occurs if items are stored on a hatch and have to be removed to retrieve an item below it.f: Minimize a given objective function f.The introduced functions can be considered independently or in a combined way. For example,w1#RS+w2TCdenotes a weighted sum of the number of reshuffles and transportation costs with associated weightsw1,w2⩾0.

@&#CONCLUSIONS@&#
