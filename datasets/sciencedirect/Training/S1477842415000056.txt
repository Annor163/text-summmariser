@&#MAIN-TITLE@&#
Neverlang: A framework for feature-oriented language development

@&#HIGHLIGHTS@&#
This paper presents Neverlang: a framework for modular development of programming languages.Neverlang fosters language composition and restriction.Neverlang supports separate compilation and dynamic extension of the programming languages.Neverlang has been compared with other frameworks with similar aims.Neverlang has been evaluated against significant case studies as an implementation of javascript.

@&#KEYPHRASES@&#
Domain specific languages,Language development,Modularity,

@&#ABSTRACT@&#
Reuse in programming language development is an open research problem. Many authors have proposed frameworks for modular language development. These frameworks focus on maximizing code reuse, providing primitives for componentizing language implementations. There is also an open debate on combining feature-orientation with modular language development. Feature-oriented programming is a vision of computer programming in which features can be implemented separately, and then combined to build a variety of software products. However, even though feature-orientation and modular programming are strongly connected, modular language development frameworks are not usually meant primarily for feature-oriented language definition. In this paper we present a model of language development that puts feature implementation at the center, and describe its implementation in the Neverlang framework. The model has been evaluated through several languages implementations: in this paper, a state machine language is used as a means of comparison with other frameworks, and a JavaScript interpreter implementation is used to further illustrate the benefits that our model provides.

@&#INTRODUCTION@&#
The problem of extending programming languages through new constructs has never lost interest in the industry and in the research community. Modern general purpose programming languages are multiparadigm, progressively converging towards a hybrid between object-orientation and functional programming. Languages from both the communities cross-pollinate each other with features. Languages that were born with pure object-orientation in mind nowadays tend to include functional constructs. This tendency to contamination between different programming styles can be read as the symptom of a need for more flexibility.Traditionally, the design and implementation of a programming language is more of a top-down activity, where most of the time is spent on the design of a consistent set of features; extensibility of the compiler, although desirable, is not a strict requirement. But when today people speak about language development, they often mean developing a new programming language with specific requirements in mind. We could even dare to say that problem-tailored programming language development is more of a bottom-up activity, because, in some sense, the language specification rises from the problem that the developers are trying to solve. Intuitively, a top-down design phase is still important, because it is important that the language consists of a coherent set of features; but in a domain-specific language (DSL [1–3]), this phase can be often reduced to a minimum: even more so, if it were possible to implement new languages using off-the-shelf components.A technique to implement languages is embedding; this technique is part of the idiom of many modern programming languages such as Scala, Ruby, and Groovy which, in some sense, are following the lead of veterans such as LISP, the “programmable programming language” [4], and Smalltalk. Embedded DSLs [5] are really just a byproduct of choosing a particular API design style that Fowler and Evans dubbed a fluent interface[6]. Fluent APIs are often used to embed query languages within the body of a general purpose programming language (cf. Spring Data׳s Query DSL [7]) or to describe graphical user interfaces (cf. JavaFX׳s APIs [8]).11Literature has also shown how to support true language embedding through library-based, possibly type-driven language preprocessing [9,10].This technique has clear benefits: first of all it is easy to implement; second, it guarantees a high-degree of code reuse, because an embedded language is just a library. The main limit is that the expressivity of the language is inevitably dictated by the host programming language. External DSLs, on the other hand, are instead usually developed using dedicated toolsets, and work as stand-alone programming languages. The traditional route to external DSL development is to implement the front-end through parser generators such as good old yacc, ANTLR [11] or, more recently, parser combinators [12,13], and then implementing the semantics of the language. For this purpose, the variety of techniques ranges from attribute grammars [14,15] to simple syntax-directed translation [16] to term-rewriting [17]. The object of our research of the last few years has been geared towards realizing techniques and tools to implement componentized language implementations with the final “grand vision” of a world where general-purpose and domain-specific programming languages can be realized by composing together linguistic features the same way we combine together the pieces of a puzzle. And, just like each piece of a puzzle lives and exists on its own, each linguistic feature should be something that we can describe and implement in isolation and separately.In fact, empiric evidence shows that many general-purpose languages share similar syntax and similar semantics for the same concepts: for instance, C-like programming languages such as C++, Java, and C# etc. all share a similar syntax for for loops, if branches, variable declarations, etc. The ultimate goal is to maximize reuse of syntactic and semantic definitions across different language implementations to the point where end users may be even able to generate a language implementation by picking features from a curated list: programming languages à la carte.Contribution: Most of our experience in feature-oriented definition of programming languages have been carried out using our own framework, called Neverlang. Our contribution with this work is1.an abstract model for feature-oriented language implementation,a description of our implementation of this model in Neverlang,showing that the model can be supported by most of the existing tools for modular language implementation,showing that the native implementation of this model strengthens the benefits of a modular language implementation.Organization: Section 2 gives a brief overview of the background information. Section 3 presents the abstract model. Section 4 introduces the Neverlang implementation of this model. Section 5 presents a full example (a state machine language). Section 6 is devoted to evaluate the model in a variety of contexts: the state machine language is re-implemented in other frameworks to show how the model can be reproduced; the benefits of using this model are then showed by describing the experience of extending Neverlang׳s JavaScript implementation neverlang.js; a DESK language implementation is briefly given to exemplify the expressive power of the Neverlang framework; finally, this section describes the experience of modeling variability in programming language family, by automatically mining data from a collection of pre-implemented features. Finally, Section 7 briefly discusses related work and Section 8 draws the conclusions and describes the future work.

@&#CONCLUSIONS@&#
Modular language implementation is the first step towards bringing language implementation to a wider audience. The model we presented can be easily implemented using many of the already existing tools and we showed that a native implementation of this model gives a greater range of possibilities. Separate compilations make it possible to redistribute pre-compiled components. In neverlang.js (Section 6.2) we showed that language extensions can be developed, and tested and integrated in parallel and in isolation. The variability management experience (Section 6.4) has shown that multiple language components can be mined to simplify the definition of language variants from pre-built artifacts.The Neverlang framework has been successfully employed in real-world projects. TheMatrix[77] is a Java framework to query and manipulate Italian׳s national healthcare databases to produce statistics on the prevalence of chronic diseases and estimate the standards of care across the country. The Tyl Language is an experimental business-oriented DSL for the development of ERP software.1818http://www.mate.it/index.php/en/tylThe same implementation of Neverlang׳s compiler nlgc (Section 4.1.1) and of the interpreter for a complete, modern programming language (neverlang.js, Section 6.2) are a testament to the strengths of Neverlang and its underlying model. We are also completing the implementation of a modular Java language pre-processor, in the style of Polyglot [78], SugarJ [56], and ableJ [46]. Other experiments involved experimenting with a simple implementation of the Logo programming language. Moreover, because the core API is entirely Java 6 compatible, we were able to successfully port the entire Neverlang implementation onto Android (an example use case would be the Recipe language described in [20]), where its dynamic loading capabilities could be useful to separately distribute plugins for a core language implementation.Nevertheless, in Neverlang there is still much room for improvement. Future work will concentrate both on its expressive power and ease of use. Runtime evolution and a DSL for tree rewriting are already in development, and thanks to the architecture of the framework they should be available soon. The language plugin system makes it possible to support new programming languages for semantic actions, and the dynamic mapping between parse trees and semantic actions would simplify support to dynamic dispatching of alternative actions.Composition between language components is also a matter of establishing a set of guidelines: Section 3 gave an overview of the principle of dependency between language components. Even though Neverlang provides renaming and remapping capabilities (Section 4), guidelines on naming and factorization of language components are still an open problem that affects any modular language implementation tool. Our plan is to explore this problem more through field studies and further experiences.