@&#MAIN-TITLE@&#
Visual tracking of non-rigid objects with partial occlusion through elastic structure of local patches and hierarchical diffusion

@&#HIGHLIGHTS@&#
We propose a tracking method to solve both the problem of partial occlusions and non-rigid deformations in real-time.The target object is modeled through an elastic structure of local patches for robust performance.Hierarchical diffusion method is proposed to obtain an acceptable solution in real time.Extensive evaluation shows that the proposed method outperforms state-of-the-art.

@&#KEYPHRASES@&#
Visual tracking,Local patches,Markov random field,Particle filtering,Hierarchical diffusion,

@&#ABSTRACT@&#
Graphical abstract

@&#INTRODUCTION@&#
Object tracking is an important computer vision problem which can be used for various applications such as robot vision, video analysis, behavior recognition, home automation, and visual surveillance [1]. In order for the whole system to work properly for these applications, accurate tracking results are required. Various tracking methods have been tried [2–5] during the last decade and they have proven to be successful for these applications. However, the applicability of these algorithms is somewhat limited when applied to objects undergoing various disturbances in real-world scenarios.The limitations of conventional methods arise from the fact that they have strong assumptions about the input video sequence, such as constant movements of the target object and consistent views. In real-world scenarios, occlusions may occur frequently with the target object showing non-rigid deformations, degrading the performance of conventional methods. For instance, it is easy for people walking nearby to occlude each other. Furthermore, people show non-rigid movements as well, making it extremely difficult for conventional methods to track the target person successfully throughout the image sequence.Kernel-based tracking [6] is widely used for its simplicity and computational efficiency. The method is generally known to provide tracking results very efficiently, suitable for real-time purposes. However, the method uses local optimization techniques; therefore, it is easy for the tracker to fall into local maxima (or minima). Also, the method gets easily distracted by the background (known as the background clutter problem) and has no clear way of adapting to scale and illumination changes. Particle filtering based methods are another class of methods which became popular after its first introduction in [7]. These methods try to solve the tracking problem with Monte Carlo (MC) simulation. Unlike kernel-based trackers, particle filtering based methods can be easily extended to track objects showing movements other than translational movements, such as affine motions. Many variations have been proposed [8–10], each with different measurement models. Among these, subspace-based measurements [8], inspired by the work of Black et al. [11], have proven to be successful. These methods are able to adapt to various changes such as changes in views and illumination and changes within the model by modeling the target object with a subspace-based representation. However, the methods assume slow changes of the target object and do not consider occlusions during learning, causing the trackers to drift.Adam et al. [12] proposed a fragments-based tracking method to solve occlusion problems. Their method represents objects with multiple image fragments and combines the votes from each fragment to obtain a tracking result. The method extends traditional kernel-based methods to be robust to partial occlusions, but it is still limited to tracking translational movements. Mei and Ling [13] treated visual tracking as a sparse approximation problem under the particle filtering framework. They address occlusions and corruptions through a set of trivial templates. Each target candidate is then sparsely represented through l1 minimization and the candidate with the smallest projection error is taken as the tracking target. The sparse representation considers occlusions through trivial templates and it is, therefore, more robust to partial occlusions than other traditional particle filtering methods. However, the results of their method are not reliable when the target object shows non-rigid movements.To solve the problem of non-rigid object tracking, Kwon and Lee [5] proposed a method which models the target object as a collection of local patches. In [5], the target object is described with a star model of local patches, and Adaptive Basin Hopping Monte Carlo (A-BHMC) sampling is used to minimize the energy of the model. The patches in the model used to describe the target object are consistently updated through a heuristic scheme. This enables the tracker to adapt to drastic changes in the appearance and the shape of the target. A-BHMC reduces the number of particles required for tracking, making the computation time tractable. However, their method tends to have trouble when tracking objects showing large displacements, and still requires large amount of computation even with A-BHMC. Godec et al. [14] proposed a tracking method based on the generalized Hough transform. They extended the idea of Hough Forests to the online domain and coupled the voting based detection and back-projection with a rough segmentation based on GrabCut [15]. Their method gets rid of the bounding-box limitation and returns tracking results which contain only the target object. However, their method is limited to handling non-rigid deformations only, and has problems when tracking objects under occlusions.Recently, methods trying to solve tracking problems with the “tracking by detection” scheme have drawn attention. Grabner et al. [4] proposed a method to train a discriminative classifier in an online manner using online boosting to separate the object from the background. Their method treats the tracking result as a positive sample and nearby region as negative samples. Using these samples, the method continuously updates the classifier. However, due to occlusions or slight inaccuracies, the performance of the classifier tends to degrade over time as the classifier is updated. To solve this drift issue, Babenko et al. [16] employed multiple instance learning, which updates the classifier with multiple positive examples rather than just one. Also, instead of using multiple instance learning, Stalder et al. [17] proposed a multiple classifier system which consists of an off-line classifier, a supervised on-line classifier, and a semi-supervised on-line classifier to prevent the tracker from drifting. However, both methods, [16] and [17], do not consider occlusions, making the methods vulnerable to them. Kalal et al. [3] proposed a method using both a tracker and a classifier to create training sets with structural constraints. Their method collects training samples and uses them only when the structural constraint meets, i.e., only when the classifier and the tracker agree. Through this procedure, their method becomes robust to drifting problems. Unfortunately, their method has weaknesses against occlusions as well.Our method is targeted to solve both the problem of partial occlusions and the problem of non-rigid deformation in real-time on a modern desktop personal computer (PC). The proposed algorithm models the target object through a structure of local patches with spring-like connections, formulated in a Markov Random Field (MRF) style framework. Each local patch is considered to be connected with its neighbors as the local structures of the target object are embedded into the MRF structure.The advantage of our method is that when partial occlusions occur, un-occluded patches will enforce the maintenance of the local structures, owing to the spring-like connections among local patches. As a result, occluded patches will be directed to their correct positions through the relationship among neighboring patches, thus making our method robust against partial occlusions. Non-rigid deformations are also well described since they can be explained as a collection of local movements of patches. Unlike other methods which concentrate on occlusions [12,13], or methods which focus on non-rigid movements only [5,14], our method addresses both problems simultaneously. In addition, to achieve real-time performance on a modern desktop PC, which is critical in many tracking applications, a hierarchical diffusion approach is proposed to overcome the curse of dimensionality.The proposed model is similar to the deformable models used for 3D shape recovery tasks [18,19], but differs in the fact that the structure is not restricted to regular or repetitive grids. Also, for visual tracking tasks, the shape of the tracked object is not known in advance, thus the applicability of methods for 3D shape recovery tasks [18] are limited. Our method is also closely related to pictorial structure frameworks [20,21] in the fact that we model the entire object as a collection of parts. Pictorial models have been successfully applied to object recognition and detection tasks [22]. In our work, we focus on the visual tracking task, where we are not provided with a prior dataset to learn about the target object, in contrast to the object recognition and detection task.To demonstrate the effectiveness of our method, we have experimented with a number of challenging image sequences. The experimental results show that our method is the most robust against both partial occlusions and non-rigid deformations, compared with other methods. Especially, our method runs in real-time (20 to 50 frames per second), whereas other state-of-the-art methods capable of tracking non-rigid objects proposed in [5] and [14] run only a few frames per second.A preliminary version of this paper has been presented in [23]. In this version, we extend the preliminary work with a new likelihood function based on linear Support Vector Machine (SVM) [24,25] and logistic fitting [26]. We also provide thorough analysis of the method's performance through comparison with other methods both qualitatively and quantitatively on a number of challenging image sequences.The proposed tracking method is based on a sequential Bayesian inference framework. We denote the object state at time t as Xt, where Xt=(Xt1,Xt2,⋯,XtN) and Xtkdenotes the state of the kth local patch of the object (e.g., the position of the patch) among the N local patches used to describe the object. Then, if we denote the observations up to time t as Y1:t, the problem of object tracking can be defined as findingX^tsuch that,(1)X^t=argmaxXtPXt|Y1:t.For sequential Bayesian inference, the posterior probability P(Xt|Y1:t) is sequentially updated as the following:(2)PXt|Y1:t∝PYt|Xt∫PXt|Xt−1PXt−1|Y1:t−1dXt−1.Here, P(Yt|Xt) is the conditional probability of the current observation Ytgiven the current state Xt, which is referred to as the likelihood term, and P(Xt|Xt−1) is the transition probability from Xt−1 to Xt.Typically, for object tracking, since we consider many types of movements (e.g., translation, rotation, scale, and affine motions), obtaining an exact analytic solution is not an easy task. Also, when the model is applied, the probabilistic distribution in the solution space is non-convex leading to difficulties when using local optimization based techniques. Therefore as in [7], we use particle filtering (also known as sequential Monte Carlo sampling) to solve the problem. If we denote the lth sample in particle filtering as Xt,[l], then Eq. (1) can be re-written as(3)X^t=Xt,l^,where(4)l^=argmaxlPYt|Xt,l.Note that since we are performing particle filtering, the likelihood of each particle P(Yt|Xt,[l]), after diffusion according to the transition probability and re-sampling, corresponds to the posterior probability. Thus, the problem of object tracking is now the problem of simulating the posterior distribution P(Xt|Y1:t) with particle filtering, and then taking the particle with the best probability as a solution.Our method differs from the traditional particle filtering methods due to the fact that the likelihood P(Yt|Xt) is obtained through an MRF-style manner. Through this MRF-style method, both the individual likelihood of each patch and the relationship among them are maximized while tracking. The MRF-style elastic structure of local patches, which will be explained in Section 2.2, has the advantage that the resultant posterior distribution considers both the underlying local structures and the non-rigid deformations simultaneously. To allow the proposed method to perform the tracking procedure within the real-time constraint and to avoid from using excessive number of particles when covering the high dimension solution space, we adopt a hierarchical diffusion scheme which benefits from the assumption that local deformation is not large between consecutive frames. Details of the proposed hierarchical diffusion are explained in Section 2.6.In our work, we treat the target object as a collection of local parts, rather than treating the target object as a whole. Local parts are described with n×n size local patches, and local patches are assumed to be connected with nearby neighbors forming an elastic structure as in Fig. 1. This model of the target object is realized through an MRF-style framework. The likelihood of each local patch is considered to be the unary likelihood of the MRF, and the structure among them is considered to be the neighborhood relationship of the MRF. Since each local patch is connected with its neighbors forming an MRF, our model prefers solutions with the local structure of the target object preserved. Therefore, even if some of the patches are occluded, other un-occluded patches will drive occluded patches to the correct positions, causing the proposed model to be robust against partial occlusions. Also, since we describe the target object using local patches, we are able to represent non-rigid deformations as a collection of movements of local patches.We consider the initial patch positions and connections are given in the first frame. This initial setting can be given manually or automatically by some other detection system or by some certain strategy (e.g., dividing the target bounding box into equal grids and considering each grid to be connected to its direct neighbors). The given patches should cover most of the target object with connections describing the structure of the target object.The likelihood P(Yt|Xt) in Eq. (2) is modeled with the probability of the MRF configuration describing the structure of local patches. Therefore, P(Yt|Xt) is designed as(5)PYt|Xt∝∏k=1NPYt|Xtk∏j∈NkPXtk|Xtj,where P(Yt|Xtk) is the likelihood of a single patch, P(Xtk|Xtj) is the prior probability describing the relationship among neighboring patches, and Nkdenotes the neighbors of the kth patch. Note that P(Yt|Xt) is referred to as the posterior probability in MRF literature, but in our case, it is the likelihood of a single configuration. Since we are based on sequential Bayesian inference, the posterior probability for our model is shown in Eq. (2). We are also following the standard MRF configuration and are assuming conditional independence among patches which are not neighbors, as well as the independence among unary likelihoods of each patch P(Yt|Xtk). (See [27] for more details on MRFs.)In the energy form, if we denote the total energy of the configuration as E(Yt;Xt), the energy of a single patch as E(Yt;Xtk), and the energy from the relationship between patches as E(Xtk,Xtj), we can write the total energy of the MRF model (which is simply the sum of the observation and neighborhood energy of all patches) as(6)EYtXt=Z+∑k=1NEYtXtk+∑j∈NkEXtkXtj,where Z is a normalizing constant which is not needed to be computed during optimization as only the relative difference of energy between the states is used. Here, the relationship between Eqs. (5) and (6) is that Probability∝exp(−λEnergy), assuming the Gibbs distribution. Here, λ is a design parameter controlling the smoothness of the posterior distribution. Now, with Eq. (6), Eq. (4) can be re-written as(7)l^=argmaxlPYt|Xt,l=argminlEYtXt,l.Also, the sample weights for particle filtering is now(8)wl∝PYt|Xt,l∝exp−λEYtXt,l.Generally speaking, if λ is large, the posterior distribution becomes spiky and particles become concentrated near the MAP solution, whereas if λ is small, the posterior distribution becomes smooth and more particles far away from the MAP survive the re-sampling process. We empirically found that λ=10 works well in most cases.In order to obtain the energy of a single patch E(Yt;Xtk), we model each individual patch using a linear classifier in 21 dimensional space. The first nine dimensions are HOG (Histogram of Oriented Gradients) features. We build our HOG by dividing the orientation into eight equal bins, and one bin to denote gradients with response 0. To obtain image gradients, filter kernels−101and−101Tare used. When applying these filters, if the responses were below 10 on a 0 to 255 scale, we considered the response to be 0 to increase robustness to noise. We then assigned the image gradients to one of the eight bins according to their orientations, or the ninth bin if both filter responses were 0. For simplicity, we assigned each gradient to one of the nine bins without weighing them.For the remaining 12 dimensions, we divide a single local patch into four equal parts (upper left, upper right, bottom left, and bottom right) and obtain the mean RGB values for each sub region as in Fig. 2(3 dimensions for each sub region). More sub regions may be used depending on the level of accuracy required for a single local patch tracking. This feature is similar to the one used in [28], but one feature is assigned to a single patch not a single pixel as in [28]. The advantage of using this 21 dimensional feature is that this feature can be obtained efficiently using integral images.For each patch, we use the classifier score of the observed 21 dimensional vector to obtain the energy of a single patch, E(Yt;Xtk) in Eq. (6). The classifier is trained so that it gives high scores when the observation is likely to be the modeled patch, and gives low scores (possibly negative) when it is not likely. For the classifier, we use linear SVM [24,25] with logistic fitting performed on the classification score [26] to perform scaling. Training strategies for both linear SVM and logistic fitting are described in detail in Section 2.5.If we let fckdenote the 21 dimension feature vector of the current observation for the kthpatch, let sk(fck) denote the linear SVM classification score for fck, and let Akand Bkdenote the learned logistic parameters, then(9)EYtXtk=1−11+eAkskfck+Bk.Note that the logistic fitting [26] scales the classifier scores to be in range [0,1], considering the distribution of scores from the training data. This prevents the problem of certain patches having higher priority than others due to different score range when using raw classifier scores. We also use the classification result of each patch when updating the model to prevent drifting (detailed in Section 2.5).The relationship between neighboring patches is modeled so that the local structures among neighboring patches are preserved while tracking. To deal with non-rigid deformations, patches behave as if they are connected by springs. Also, to be robust to partial occlusions, the springs of each patch behave as if they are connected to the patch's expected positions from its neighbors. As in Fig. 3, if we consider an observed patch (patch j in Fig. 3) and its neighbor (patch k in Fig. 3), then in our model, the observed patch j tends to return to its expected position from its neighbor k (expected position is denoted by the dotted box) by the restoring force of a virtual spring connection between the expected position and patch j, which is length zero at rest. In other words, the energy of the connection between the two neighboring patches k and j is defined as the elastic energy of this spring. If we denote the vector difference between jth and kth patches of the current observation and the model as vc(j,k) and vm(j,k), respectively, then the displacement change x of this virtual spring is(10)x=vcjk−vmjk2.Also, to make close patches have more effect on one another, the strength of this spring is designed to be inversely proportional to the squared distance between the neighbors. Therefore, the spring constant κ is designed as(11)κ=2vmjk22β,where the neighbor strength β is a design parameter controlling the trade-off between the flexibility to adapt to non-rigid motion and the ability to keep the structure against occlusion. Details on the effect of β will be addressed in Section 3.1. Then, the elastic energy between connected local patches E(Xtk,Xtj) in Eq. (6) is defined as(12)EXtkXtj=12κx2=βvcjk−vmjk22vmjk22.The model of the target object needs to be updated consistently in order for the tracker to be able to adapt to various changes in the target object. Illumination changes and deformations of the target object must be learned by the model to correctly evaluate Eq. (5). In our case, the model update is performed in two steps: (1) updating the linear classifiers and the logistic parameters for each patch, and (2) updating the neighborhood connection parameters. To prevent the model from drifting, the update is performed only when the observed patch is classified as the model, i.e. for patch k, only when sk(fck)>0. Also in case of the neighborhood relationship, we only update when the observation for both patches forming the relationship are classified as the model.The way we update the linear classifiers is through updating training samples. For each patch, we keep a pool containing positive and negative training samples of size 2M (M positive samples and M negative samples). The positive samples represent the target object and the negative samples are simply the 21 dimension feature vectors drawn randomly from nearby. At the initial frame, we initialize the positive pools with M identical copies of the initial patches of the target object. For each frame, after obtaining the local patch tracking results, we add the tracking results to the positive pools and take out the oldest samples from the positive pools. When taking samples out from the positive pools, to prevent drifting, we make sure that at least one sample is from the first frame (i.e. one sample representing the patch from the initial frame is never taken out for each pool). Then we completely discard the previous negative pools and refresh negative samples from random nearby patches. Again, for each patch, the classifier from the previous frame is discarded and a new classifier is trained using the new training pools. Note that for each pool, since we update one positive sample at a time, the pool size M acts as a design parameter controlling the update speed of the target object model. When M is large the model is updated slowly and when M is small the model is updated quickly. In general, we empirically found that M=100 gives good performance as well as low computational cost for the update process.For the relationship update, we simply update vm(j,k) by weighted averaging, but only when both patches are classified as the model. In other words, for all j and k, if(13)sjfcj>0∧skfck>0,then(14)vmjk←1Mvcjk+1−1Mvmjk.Note that the learning rate is1Mso that the update rate would be the same as for the training pools for the classifiers.In our model, the dimension of the solution space is too large to apply simple motion models such as the random-walk model. The required number of particles grows exponential according to the number of patches used. For example, if we were to need 100 particles to track an object with only one patch using the random-walk motion model, then with N patches we would require 100Nparticles to track the target object with our model. This is already an astronomical number even with only a few numbers of patches, making our method impossible to run in real-time. Therefore, we propose an efficient hierarchical diffusion method.To use a small number of samples, we focus on sampling from the region where the actual solution would exist with high probability. In case of tracking situations the deformation of the target object is not large between subsequent frames. Considering this as an assumption, we diffuse particles hierarchically in two steps: globally for the motion of the whole object and locally for the deformations of the target object. We first diffuse the position of all local patches equally according to the Gaussian distribution with a relatively large variance, and then diffuse the position of each patch separately according to the Gaussian distribution with a relatively small variance (illustrated in Fig. 4).In the global step, the samples are diffused so that the relative positions between local patches in the sample are preserved. Then, in the local step, each local patch is diffused independently. Mathematically the proposed hierarchical diffusion method can be described as(15)Xt,lk=Xt−1,lk+Δl+δk,l,where, Xt,[l]kdenotes the state of the kth local patch of the lth sample at time t, Δ[l] denotes the 2-dimensional global diffusion (translation in x, y direction for the whole object) for the lth sample, and δk,[l] denotes the 2-dimensional local diffusion (translation in x, y direction for a local patch) for the kth local patch of the lth sample. Here,(16)Δl∼N0σG2,and(17)δk,l∼N0σL2,whereN0σ2denotes a Gaussian distribution with zero mean and standard deviation σ. σGand σLare parameters for the diffusion. The optimal choice of σGand σLmay vary depending on the image sequence but we empirically found that σG=8 and σL=4 work well for most cases. The proposed diffusion produces an accurate solution with a relatively small number of particles compared to the simple random walk approach, which allows the proposed method to achieve real-time performance. Details and discussion on experimental results regarding the effectiveness of hierarchical diffusion are given in Section 3.8.The proposed method uses particle filtering to get an MAP solution for the object tracking problem. Given the initial patches and connections {fmk,vm(j,k);∀j,k,}, the proposed method can be summarized as Algorithm 1.Algorithm 1Tracking with local patches (for each frame).

@&#CONCLUSIONS@&#
A new tracking method based on sequential Bayesian inference has been proposed. The proposed method tackled both the problem of partial occlusions and non-rigid deformation when tracking objects, by modeling the target object with an elastic structure of local patches, and by performing hierarchical diffusion in the solution space. By modeling the target object with an elastic structure of local patches, the proposed method was able to track objects with partial occlusions and non-rigid deformations. Also, through hierarchical diffusion, the tracking procedure was performed in real-time on a desktop PC. The method was evaluated against state-of-the-art trackers through twelve image sequences with large occlusions and non-rigid deformations. The experimental results showed that the proposed method outperformed all other methods that were compared against. The robustness of the proposed method was also demonstrated against various situations including partial occlusion, non-rigid motion, abrupt motion, translation, rotation, and illumination change.As discussed in the experiments, even with a simple grid initialization strategy, we were able to obtain good results with the proposed method. However, with better initialization, the performance of our method would be enhanced. Therefore, providing sophisticated initializations would be one of the most beneficial directions for future research. Recently, detecting and recognizing objects with part-based models and pictorial structures have drawn much interest [21,31,22]. As a result, the importance of part-based tracking methods is increasing. Incorporating part-based detection and recognizing methods for the initialization of our method would be a promising way to enhance initialization. Also, our method uses the same measurements for tracking the target object and determining the update. We believe that having an independent strategy for determining the update as in [3] would further enhance the performance of the proposed method. Finally, the neighborhood connection strength parameter β needs to be predetermined by the user in our method. Learning strategies for automatic selection of the parameter β would be an interesting direction for future research.