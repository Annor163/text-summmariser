@&#MAIN-TITLE@&#
Generating synthetic benchmark circuits for accelerated life testing of field programmable gate arrays using genetic algorithm and particle swarm optimization

@&#HIGHLIGHTS@&#
Generating circuits for accelerated life testing of field programmable gate arrays.The problem involves multi-variable optimization.Proposed a genetic algorithm for the purpose mentioned above.Proved empirically that particle swarm optimization can be used to enhance the quality of results yielded by a GA.Showed that GA aided by PSO not only reduces time (from months to hours) but can also yield better results than the hand-crafted SBC.

@&#KEYPHRASES@&#
Synthetic benchmark circuits (SBC),Accelerated life testing (ALT),Field programmable gate arrays (FPGA),Genetic algorithms (GA),Particle swarm optimization (PSO),

@&#ABSTRACT@&#
Accelerated life testing (ALT) of a field programmable gate array (FPGA) requires it to be configured with a circuit that satisfies multiple criteria. Hand-crafting such a circuit is a herculean task as many components of the criteria are orthogonal to each other demanding a complex multivariate optimization. This paper presents an evolutionary algorithm aided by particle swarm optimization methodology to generate synthetic benchmark circuits (SBC) that can be used for ALT of FPGAs. The proposed algorithm was used to generate a SBC for ALT of a commercial FPGA. The generated SBC when compared with a hand-crafted one, demonstrated to be more suitable for ALT, measured in terms of meeting the multiple criteria. The SBC generated by the proposed technique utilizes 8.37% more resources; operates at a maximum frequency which is 40% higher; and has 7.75% higher switching activity than the hand-crafted one reported in the literature. The hand-crafted circuit is very specific to the particular device of that family of FPGAs, whereas the proposed algorithm is device-independent. In addition, it took several man months to hand-craft the SBC, whereas the proposed algorithm took less than half-a-day.

@&#INTRODUCTION@&#
Programmable Logic Devices (PLD) are widely used as basic building modules in high integrity systems, considering their robust features such as gate density, performance, speed, etc. Field programmable gate array (FPGA) and complex programmable logic device (CPLD) are some of the popularly used PLDs. A FPGA consists of an array of programmable logic modules (LM) and a programmable interconnect area. In modern FPGAs the LMs are realized using Lookup Tables (LUTs). Typically, PLDs are used to (1) program a bus interface logic; (2) programme a glue logic; (3) as a co-processor to the CPU; and/or, (4) as a custom hardware that can offload some of the work done by a CPU with an objective to achieve higher performance levels. The reliability of FPGAs on the other hand, especially when they are used to build safety-critical systems, has been an increasingly interesting phenomenon drawing attention of the industry, researchers and consumers. The reliability of a PLD is so critical that it needs to be quantified and certified by the manufacturers. Many manufacturers use the Mean Time Between Failure (MTBF) value to quantify the reliability of their devices. The MTBF value needs to be very high for FPGAs used in construction of safety-critical systems. One common procedure to validate the MTBF value is to subject the given FPGA to an accelerated life test (ALT). The ALT effort involves the following steps:1.Generating a design that when configured on the given FPGA under test shall•maximize the usage of logic and routing resources for the device;maximize the usage of I/O pins for the device;maximize the frequency at which it can execute on the device;maximize the dynamic power dissipation on execution; anddetect faults in the circuit.Subjecting the device programmed with such a circuit to different combinations of environmental parameters.This paper addresses the problem stated in step (1) above. The challenge is to arrive at such a design as stated in step (1) above that shall stress the given FPGA under test. Typically benchmark circuits are used for this purpose. Hand-crafting such a design is a herculean task as the conditions that need to be satisfied to stress many of the parameters mentioned above are orthogonal to each other demanding a complex multivariate optimization. This paper presents a genetic algorithm (GA) aided by particle swarm optimization (PSO) methodology to generate synthetic benchmark circuits (SBC) that can be used for ALT of FPGAs. The proposed algorithm is device-independent and can be used to generate SBCs for ALT of any FPGA.The rest of this paper is organized as follows: Section 2 presents a literature survey on SBCs. Section 3 presents the proposed GA for generating SBCs for ALT of FPGAs and the corresponding experimental results. Section 4 presents the PSO-based enhancement to the GA and the corresponding experimental results. Section 5 concludes the paper.Evolution of new FPGA architectures and EDA tools is important and necessary to meet the requirements of tomorrow's designs. What are tomorrow's designs? How big and complex will they be? Realistic answers to these questions are needed to tune the evolution process mentioned above to the futuristic requirements. The industry and academia addresses the same using SBCs.One of the earliest reported results that has formed the basis of many SBC generation techniques is Rent's law[1]. This empirical law advocates the following relationship between the average number of elementary blocks B in the modules of a partitioned circuit, and the average number of external connections (terminals) T from modules:T=tBp;where t is the average number of terminals per logic block and p is called the Rent exponent. The Rent exponent p, is a measure of the interconnection complexity of the circuit (0<p<1). A larger value of p indicates larger interconnection complexity. Thus, Rent's law addresses the notion of interconnection complexity of the circuit. It is interesting to observe that, over years the real designs indeed followed Rent's law in terms of interconnect complexity except in some cases where a deviation to Rent's rule was observed for large values of T and B. These cases were said to belong to the Rent's II region. The first attempt towards generating SBC is reported in [2], wherein, the proposed technique generated a random mapped circuit rmc. It was based on a top-down recursive partitioning approach. In this method, the design is considered in its entirety to start with and further partitioned into sub-blocks based on certain criteria. Generally the criteria will be to minimize the number of net-cut, i.e., the number of nets crossing the borders of the sub-blocks in the partition. It has been observed that minimizing the number of terminals is a better criterion than minimizing the number of net-cut and that both these criteria are not equal for multi-terminal external nets. The drawback of the rmc method was that it could not generate a realistic sequential circuit. Even the targeted Rent's exponent was not achieved. This showed that more focused methods were needed for generating SBCs.The recent SBC generation methods can be broadly classified into two: cloning-based and mutant-based. In the cloning approach, a minimal set of characteristic parameters are identified and the SBC is derived from them. In the mutant approach, a circuit is drawn from a set of all possible circuits and perturbed to arrive at the new SBC. This derived circuit shall meet the new requirements of the user while adhering to some properties of the original circuit.Many cloning-based approaches are reported in the literature. In [3] a bottom-up clustering approach named gnl (generate netlist) is presented, which is based on Rent's rule. In this method, first a set of primitive modules are selected. Then, two different primitive modules are combined to form a cluster or a new module. Two different clusters are combined to form a new cluster. They were successful in generating true sequential circuits, but failed in Rent region II. Hutton et al [4] came out with two tools named CIRC and GEN. The CIRC was used to analyse the sequential circuits to generate a profile which in turn was used by GEN to generate the SBC. The delay distribution of the circuits generated by GEN and CIRC was more realistic than what was realized in randomly generated circuits. The delay distribution of a given circuit is a collection of the maximum path delay values for all inputs of its sequential gates and all its primary outputs [5]. However, the drawback of CIRC was that it was not able to extract the Rent characteristic of the analysing circuit.Ghosh et al [6] introduced the mutant-based SBC generation approach named signature invariant mutants. They further classified them as the wiring signature-invariant (WSI) classes and functional perturbation-invariant (FPI) classes. WSI mutants were derived by doing the wiring perturbation, whereas FPI mutants were derived by adding extra logic to the existing circuit.In addition to Rent's law, some approaches [7,8] attempt to build SBCs with net-degree distributions similar to those in given set of real circuits. The first attempt to validate whether a generated SBC is indeed a representative of the real circuits that shall be encountered in future or not was made in [7]. In addition, the methodologies discussed so far used only the topological parameters. On the other hand, there is a need to generate SBCs that have certain functional properties. This is needed, for example, in the case of validating logic synthesis/optimization tools. Such an attempt is reported in [8].In 2005, Pecenka et al [9] introduced an evolutionary algorithm for generating SBCs targeted for ATPG tools. They were able to generate RTL circuits with 150, 000 gates. A benchmark suite named FITTest_BENCH06 set, consisting of 20 synthetic sequential circuits with maximum 310, 610 gate complexity was proposed in [10]. A methodology for generating benchmark circuits with predefined testability was proposed in [11,12]. The fitness function used in [12] for grading the chromosomes included testability of the generated circuits as a component. The testability values of the generated circuits as computed using the above fitness function were validated using commercial ATPG tools and polynomial-time testability analysis methods that employed the controllability and observability [13] parameters. The results obtained were comparable.To the best of our knowledge, the only result reported in literature for ALT on any FPGA using SBCs is in [14]. The paper proposed a design which when configured on an Actel (A42MX36PQ208I device) FPGA caused 81% logic utilization (defined as number of LMs used) while maintaining a threshold on the number of simultaneous switching outputs. The structure of the design was a control path comprising a Finite State Machine (FSM) and a data path comprising pipelined multiplexers. The data-path was fed with a series of inputs generated by an internal module in the circuit. The control path checked the outputs of the data-path for errors due to failure of the device under test. The paper employed the Electronic Design Automation (EDA) tool flow of Actel for converting the given Hardware Description Language (HDL) level representation of the generated SBCs into a representation that can be configured on the target FPGA. However, this hand-crafted circuit was very specific to the particular device of the ACTEL family of FPGAs and took more than nine man months to be generated.The subsequent section presents the GA to generate a SBC for ALT of a FPGA.As mentioned in Section 1, the objective of this paper is generating a design that when configured on the given FPGA under test shall•maximize the usage of logic and routing resources for the device;maximize the usage of I/O pins for the device;maximize the frequency at which it can execute on the device;maximize the dynamic power dissipation on execution; anddetect faults in the circuit.This issue is tackled by a hybrid GA-PSO approach. The GA is a commonly used evolutionary technique for solving highly non-linear optimization problems with a large solution space [15]. The ALT problem of FPGAs fall into this category. The ALT problem involves several goals as mentioned above. Many of them are non-linear optimization problems. As an example, maximizing the frequency of execution of a design on the FPGA requires a placement of the different modules of the design on the logic modules of the FPGA such that the overall timing due to delay in the interconnects (wires) connecting them is minimized. This is called the timing driven placement problem and is non-linear [16].The standard GA works as follows: An initial population of Chromosomes is generated where each chromosome is a string that encodes a viable solution for the problem. The chromosomes are evaluated by a fitness function, which measures its goodness as a solution to the problem. Part of the less fit chromosomes is discarded following the principle of survival of the fittest. New chromosomes are generated by subjecting the remaining chromosomes to crossover and mutation operations. The evolution process goes on until a stop criterion has been reached. The stop criterion in our case is the generation of a chromosome with a fitness value greater than or equal to a desired threshold. This chromosome, in turn, represents a desired solution to the problem.Thus, developing a GA framework involves, encoding solutions as a string (defining the chromosomes), defining the crossover and mutation operations, and, the fitness function. The remaining of this section shall elaborate on the above steps.Let us assume that the given FPGA architecture has n primary input bit-wires (PIs), m primary output bit-wires (POs), programmable combinational elements with Cinpinput bit-wires and one output bit-wire, and, programmable sequential elements with Sinpinput bit-wires and one output bit-wire. These bit-wires (each carrying a bit) including the PIs and POs are labelled uniquely using integers. The chromosome structure is a simple one-dimensional array that comprises a sequence of locations storing these integer labels; the first n of them represent the n primary inputs, and, the next m of them represent the m primary outputs. The remaining part of the chromosome can be viewed as a sequence of blocks (each block in turn, is a sequence of consecutive locations). Each block represents a sequential or a combinational element of the given FPGA architecture. Fig. 1illustrates a typical combinational and sequential blocks of the target FPGA architecture. A sequential block that represents a sequential element has Sinp+2 locations, wherein, the first location denotes the type of the block (0 denotes combinational block and 1 denotes sequential block) and is set to 1. The next Sinplocations represent the inputs of the elements; and the last location represents the output of the element. Similarly, a combinational block that represents a combinational element has Cinp+2 locations, wherein, the first location denotes the type of the block and is set to 0. The next Cinplocations represent the inputs of the elements; and the last location represents the output of the element. The structure of a chromosome is illustrated in Fig. 2. Thus, there are two types of entries in the chromosome array, ones that represent the wires (wire-entries (input/output terminals of blocks)) and the others that represent the type of blocks – combinational or sequential (type-entries). Fig. 3shows a circuit with n=3 (PIs), m=2 (POs), Cinp=2 and Sinp=3. Each wire of this circuit is labelled uniquely with an integer marked within parenthesis as shown in Fig. 3. The corresponding chromosome is shown below the circuit in Fig. 3.In Fig. 3, entries 5, 9 and 13 in the chromosome array are type-entries while the others are wire-entries. The wire-entry i in the chromosome array stores the integer label of the wire that drives wire i in the given circuit. For example, in Fig. 3 the primary input bit-wire labelled 1 in the circuit drives the bit-wire labelled 6. Thus, the entry 6 in the chromosome array stores the integer 1. The two primary output bits PO0 and PO1 are labelled with integers 3 and 4, respectively (refer Fig. 3) and are driven, respectively, by the wires labelled 8 and 17. Thus, the wire-entries 3 and 4 in the chromosome array in Fig. 3 store 8 and 17, respectively. The primary inputs in the circuit shown in Fig. 3 are labelled with integers 0, 1 and 2. Since they are driven from outside the circuit, the wire-entries 0, 1 and 2 in the chromosome array are blank. Similarly, the wires labelled 8, 12 and 17 in the circuit shown in Fig. 3 are outputs of the combinational/sequential blocks and hence not driven by any other wire in the circuit. Hence the wire-entries 8, 12 and 17 in the chromosome array are blank.The first step in any GA is to generate an initial pool of random chromosomes. While generating the initial chromosome pool, the number of combinational and sequential elements is chosen to be lesser than the actual numbers available on the target FPGA architecture, though the algorithm will run if they are made equal to the actual number available on the target FPGA. This is done to widen the search space as explained in Section 3.3. In this case, it amounts to generating random circuits. The following algorithm ALG_INITIAL_GA describes the procedure that generates the initial chromosomes.The Crossover operation is as shown in Fig. 4. The operation involves choosing two chromosomes CH1 and CH2 at random. The crossover operation involves splitting both of them at block-boundaries close to the middle block in each of them and mutually swapping the second half of each chromosome to create two new chromosomes. The point (block boundary) of split on the chromosomes is allowed a variation of 5% on either side of its middle. This ensures that the size of the new chromosomes can change. The length of a chromosome is directly proportional to the resource utilization. Note that resource utilization is not the only criteria that we need to optimize. For example, as stated in Section 1, we need to also maximize the power dissipation. As it will be evident from the experimental section that follows, circuits with different resource utilization give different power dissipation and there is no correlation between the two. Thus, there is a need to have chromosomes of variable lengths. In addition, from the experiments we observed that when the maximum number of elements is set to the maximum number available in the FPGA the success rate of the mating operators falls down significantly. This is because any chromosome which exceeds the maximum available FPGA limit will be treated as an invalid solution. The basic intuition is that the best circuit that shall satisfy a given property need not necessarily occupy all combinational and sequential blocks on the FPGA. The above mechanism works towards satisfying this intuition.From the input specification of Algorithm ALG_INIT_GA it is clear that the initial chromosomes, though fixed in size, do not represent circuits that occupy all combinational and sequential elements of the target FPGA. This in turn allows the crossover operator to generate new chromosomes that have higher number of combinational and/or sequential elements than their parents and still within the maximum limits as imposed by the target FPGA architecture. The following algorithm ALG_CHK_CHROMOSOME describes the checks that need to be performed on all newly generated chromosomes.AlgorithmALG_CHK_CHROMOSOMEInput: A chromosome CH.Output: Validated chromosome or invalid signal.begin1.Check if the number of combinational and sequential blocks in CH are lesser than or equal to the respective numbers available on the target FPGA architecture. If not, return (invalid);Remove all connections to inputs of combinational blocks in CH that are driven by outputs of combinational blocks that are higher than the former. This shall remove all combinational loops, if any;Perform the step 2(e) of Algorithm ALG_INITIAL_GA for only unconnected outputs of combinational blocks in CH;Perform the step 2(f) of Algorithm ALG_INITIAL_GA for only unconnected outputs of sequential blocks in CH;For all unconnected inputs of combinational and sequential blocks in CH perform the steps 2(h) and 2(g) of Algorithm ALG_INITIAL_GA, respectively;Check using the EDA tool if the SBC corresponding to CH can be successfully configured (placed and routed) on the target FPGA architecture. If not, return (invalid);return (CH);end (ALG_CHK_CHROMOSOME).The mutation operation is as shown in Fig. 5. The operation selects a random number of modules in a chromosome and, converts them from sequential to combinational and vice versa. Note that the crossover operation preserves the ordering of the combinational and sequential blocks of the parent chromosomes to a large extent. The mutation provides the way to change this ordering resulting in the generation of chromosomes that are significantly different from their parents, thereby, enabling increased exploration of the solution space. After the mutation operation the resulting chromosome should be checked for validity using the Algorithm ALG_CHK_CHROMOSOME. It is important to note that the mutation does not change the resource utilization of the generated circuit as it does not vary the chromosome size.After generation of the initial chromosomes and also after every crossover and mutation operations, the fitness of the new chromosomes need to be evaluated. Based on this evaluation, a decision will be made whether to retain the chromosome in the pool or to discard. The fitness is evaluated using a function that is derived based on the objectives of the optimization problem. The objectives were stated in the beginning of Section 3 of this paper. As seen earlier, we need to satisfy the triple objectives of maximizing block (resource) utilization, dynamic power dissipation, and testability.The dynamic power dissipated by a CMOS-based circuit is given by the formula P=αFCV2, where, α is the switching activity factor, C is the switched capacitance, V is the supply voltage and F is the frequency of operation [17]. The switching activity factor is directly proportional to the number of toggles (number of wires that change their logical state at a given instance) in the circuit. Thus, maximizing power dissipation can be achieved either by increasing the switching activity or by increasing the frequency of operation. Based on these, the fitness function for the given problem is defined as follows:F=βU+γ1A1+γ2A2+δFwhere U denotes the block utilization, A1 is average switching activity of the entire circuit, A2 is the average switching activity at output pins, and, F is the frequency of operation. The constants β, γ1, γ2 and δ are the weights assigned to the corresponding components in the fitness function. The maximum value of U is fixed at 100%, while that of A1 and A2 are set to 1 (ideal case when all nets toggle). The maximum value of F is determined empirically by configuring several generated SBCs on the target FPGA architecture using the EDA tool and computing the maximum attained operational frequency. For any generated SBC the values of these parameters are computed and normalized with respect to their corresponding maximum values. These normalized values are used for computing the fitness function. In addition, as stated in Section 3, the generated circuit needs to be easily testable. In other words, the observability of the internal wires need to be high. The observability of an internal wirewin a circuit C is a measure of ease by which any change in its state could be propagated and observed in any one of the primary outputs of C[18]. A circuit which shows higher toggling activity at the output pins tend to have more observable internal wires than those that have less toggling activity at its outputs. Hence, the former are more testable. To capture this factor, the average toggling at output pins (A2) is considered separately in the fitness function evaluation. Thus, the fitness function takes into account all the three factors, namely, power dissipation, testability and resource utilization, to grade a chromosome.Computing the fitness function of a given chromosome CH involves converting the same into its equivalent circuit representation on the target FPGA architecture, CR, in the Verilog Hardware Description Language. A logic simulation of CR is performed for a large number of randomly generated inputs and the mean of the activity observed at all the wires and the primary outputs over all these inputs is taken as the average switching activity A1 of the entire CR and the average switching activity (A2) of the outputs of CR, respectively. This approach is validated by the law of large numbers and is similar to the one proposed in [19].The CR is also processed using the EDA design flow of the target FPGA architecture to compute the value of block utilization (U) and the maximum operational frequency (F). An interesting point worth reporting is that the commercial FPGA placement and routing tool that was used in the evaluation of both the resource utilization and the maximum operation frequency components of the fitness function, failed to layout the best generated circuits initially. However by changing the input random seeds, the tool was able to layout the same circuits successfully after some number of trials. The reason for such behaviour is that the commercial FPGA tools employ heuristic-based approaches to solve problems like logic synthesis, placement and routing that are NP-complete [20]. For large and complex circuits the change in the quality of solutions across different runs is significant. The best generated circuits took more than 10 trials. This reflects the complexity of the generated SBCs. However, this ensured that close to 70% of the generated chromosomes were valid. The final structure of the GA is as described in ALG_GA.Algorithm ALG_GAbeginGenerate initial N chromosomes and store in Chromosome pool;repeatGenerate crossover chromosomes from chromosome pool;Generate mutation chromosomes from chromosome pool;Calculate fitness functions for the crossover and mutation chromosomes;Retain the top N fittest chromosomes in Chromosome pool;until (a chromosome of desired fitness is generated or iteration-limit reached)output(the chromosome with best fitness value);end (ALG_GA).

@&#CONCLUSIONS@&#
