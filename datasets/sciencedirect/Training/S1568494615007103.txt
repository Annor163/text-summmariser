@&#MAIN-TITLE@&#
Cryptographic Boolean functions: One output, many design criteria

@&#HIGHLIGHTS@&#
Analysis on the efficiency of EAs when evolving cryptographic Boolean functions.Three fitness functions, four evolutionary algorithms.Wide set of experiments with different algorithm parameter values.The best results are obtained with GP and CGP.We show the problem representation plays a crucial role for reaching top solutions.

@&#KEYPHRASES@&#
Evolutionary algorithms,Boolean functions,Cryptography,Comparison,Analysis,

@&#ABSTRACT@&#
Boolean functions represent an important primitive in the design of various cryptographic algorithms. There exist several well-known schemes where a Boolean function is used to add nonlinearity to the cipher. Thus, methods to generate Boolean functions that possess good cryptographic properties present an important research goal. Among other techniques, evolutionary computation has proved to be a well-suited approach for this problem. In this paper, we present three different objective functions, where each inspects important cryptographic properties of Boolean functions, and examine four evolutionary algorithms. Our research confirms previous results, but also sheds new insights on the effectiveness and comparison of different evolutionary algorithms for this problem.

@&#INTRODUCTION@&#
In the last few decades there has been significant research on Boolean functions, for cryptography as well for other uses like algebraic coding and sequence design [1–4]. Accordingly, there exist many different approaches for the construction of Boolean functions as well as numerous rationales behind the choice of properties relevant for such functions. Although Boolean functions in cryptography have a less prominent position than 20 or more years ago, they still represent an important cryptographic primitive. In this paper, we concentrate on the use of Boolean functions as building blocks in filter and combiner generators [4].Boolean functions are often the only nonlinear element in stream ciphers and without them a cipher would be trivial to break. Therefore, it is not surprising that there exists a substantial body of work on methods of generating Boolean functions. However, such applications of Boolean functions in cryptography are not the only ones. For instance, they can be also used to resist side-channel attacks. When discussing side-channel countermeasures, one important class contains masking schemes. In masking schemes, one randomizes the intermediate values that are processed by the cryptographic device. One obvious drawback of such an approach is the masking overhead that can be substantial in embedded devices or smart cards. It has been shown that correlation immune Boolean functions that have minimal Hamming weight reduce the masking overhead [5,6]. However, most of the algebraic constructions are designed to produce balanced or bent Boolean functions and are therefore not suitable for this task. Consequently, it would be beneficial to have some other method of constructing Boolean functions.We distinguish between three main approaches for generating Boolean functions for cryptographic usages: algebraic constructions, random generation and heuristic constructions (and various combinations of these approaches) [7]. Algebraic constructions use some mathematical procedure to create a Boolean function with good cryptographic properties. One example of such a construction is the Maiorana-McFarland construction [4]. Random generation of Boolean functions also has its strong points, the most prominent being that it is easy and fast. However, the resulting Boolean functions usually have suboptimal properties for cryptographic usages [8]. Heuristic methods offer an easy and efficient way of producing a large number of Boolean functions with very good cryptographic properties [2]. Among different heuristic approaches, evolutionary computation (EC) and more specifically evolutionary algorithms (EAs) offer highly competitive results when generating Boolean functions for cryptography [9,10]. It is worth mentioning that EAs can be used either as the primary or the secondary construction method. In primary constructions one obtains new functions without using known ones. In secondary constructions, one uses already known Boolean functions to construct new Boolean functions (either with different properties or sizes) [4].In this paper, we experiment with several different EAs in order to explore their efficiency in the evolution of Boolean functions with properties necessary for use in cryptography. More precisely, we investigate Genetic Algorithms (GAs), Genetic Programming (GP), Cartesian Genetic Programming (CGP), and Evolution Strategies (ES). Furthermore, instead of concentrating on only one objective, we investigate three objectives, represented with different fitness functions. Since we experiment with several methods and fitness functions, it is not feasible to conduct experiments with all possible parameter combinations. Therefore, we restrict our attention to combinations which, based on our previous results and usual settings for those algorithms, provide acceptable results.Since an investigation of any one of the four aforementioned algorithms on a single objective could easily constitute a whole paper, this work should be regarded as a practical guide and not as an in-depth analysis. However, it is worth noting that we perform more than 30,000 independent experimental runs for various EAs in order to conduct statistical analysis. We concentrate here only on Boolean functions with eight inputs. Eight inputs is a relatively small size for Boolean functions for stream ciphers (it is commonly considered that 13 is a strict minimum for resisting algebraic attacks), but we still believe it is an interesting case. Indeed, for instance ciphers RAKAPOSHI [11] and Achterbahn [12] use Boolean functions of that size. Evolving Boolean functions is a challenging task because there exist22npossible Boolean functions of n inputs (for eight inputs this gives 2256 candidate solutions). Therefore, with anything more than five inputs it is impossible to do an exhaustive search. Furthermore, with larger sizes of Boolean functions the search space grows, but also the computational complexity of their various properties grows. Thus, it is unrealistic to expect that EAs can work for much larger sizes than 13 inputs. This is because the computation of some properties like the algebraic immunity, and even more the fast algebraic immunity, becomes rapidly prohibitive for large numbers of inputs.The rest of this paper is organized as follows. In Section 2, we present several applications of stochastic algorithms when generating Boolean functions appropriate for cryptographic usages. Section 3 presents relevant representations and cryptographic properties of Boolean functions. Next, in Section 4 we give fitness functions used in our experiments. Section 5 deals with the experimental setup and EAs we use. In Section 6, we give results for each of the objective functions as well as a short discussion on the results. Finally, we end with a short summary in Section 7.

@&#CONCLUSIONS@&#
In this paper, we discuss how to use EAs to evolve cryptographically suitable Boolean functions. We concentrate on three fitness functions and we compare four EAs and the random search as a baseline case.In all the cases, GP and CGP perform the best, which indicate that the TT representation is not the most appropriate one when evolving cryptographically suitable Boolean functions. Naturally, that observation is valid with fitness functions we used in the experiments. We also show that for these fitness functions and algorithm configurations, 500,000 evaluations presents a reasonable stopping criterion. We can observe certain improvements with additional evaluations, but only in the case of GP that improvement could justify significantly longer running time. We give a short discussion for each of the fitness functions where we also note some possible research avenues. Since here we consider only functions of eight inputs, one natural research avenue would be to work with larger sizes (this applies for all objectives we investigate in this paper). Another option is to experiment with other unique representations of Boolean functions (e.g. Walsh–Hadamard transform). As evident from the Section 2, this is one extremely well researched area when considering the total number of applications of EC to cryptology-related problems. However, we still believe there is much room for improvement, especially in the systemization of the current knowledge.