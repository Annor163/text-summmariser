@&#MAIN-TITLE@&#
Versatile digit serial multipliers for binary extension fields

@&#HIGHLIGHTS@&#
We propose versatile multiplier architectures supporting multiple binary extension fields.We analyze the increase in the cost due to supporting multiple fields.We study a multiplier design supporting five binary fields recommended by NIST for elliptic curves.

@&#KEYPHRASES@&#
Binary extension fields,Digit serial multiplier,Polynomial basis,Elliptic curve cryptography,

@&#ABSTRACT@&#
This work investigates the digit serial polynomial basis multipliers performing multiplication in multiple binary extension fieldsF2m1,F2m2,…,F2mλ. Designing such versatile multipliers encounters a number of difficulties. First of all, the element sizes of the supported fields are different from each other, and thus the elements are represented with different number of bits for each field. To deal with different sized elements, designs with left or right justified operands are investigated. Secondly, each field multiplication involves modular reduction with a different irreducible polynomial, and thus the complexity can increase rapidly with the number of supported fieldsλ. To prevent this, two methods are studied: Using sparse irreducible polynomials and unifying the modular reduction computation of the fields by choosing the irreducible polynomials suitably. Our work shows that multiple fields can be supported at the cost of anO(λ)increase in area and anO(λ)increase in time.

@&#INTRODUCTION@&#
The arithmetic of the binary extension fieldF2mis commonly used in cryptography and coding theory applications [1,2]. Important cryptographic applications such as elliptic curve cryptography need large number of field multiplications inF2mto perform cryptographic transformations [3,4]. Also, these applications use quite large fields. For example, the field size m is typically selected from the range160⩽m⩽1000in elliptic curve cryptography. Thus, efficient hardware and software implementations of the field multiplication is crucial to reduce the cost of cryptographic systems.In this work, we present digit serialF2mmultiplier architectures supporting multiple field sizes m. The proposed architectures support a set of field sizesm1,m2,…,mλ, i.e. work in any one of the fieldsF2m1,F2m2,…,F2mλaccording to the user selection. We also analyze the increase in the cost due to supporting multiple fields. Moreover, as a case study, we investigate the multipliers supporting the five NIST fieldsF2163,F2233,F2283,F2409, andF2571, recommended for elliptic curve cryptography [5,6].The proposed digit serial multipliers use polynomial basis. That is,F2melements are represented by the binary polynomials of degree less than m{a(x)=∑i=0m-1aixi|ai∈F2}where x represents the root of some degree m irreducible polynomialxm+g(x)called generator. The productf(x)of any two elementsa(x)andb(x)is computed by the polynomial multiplicationa(x)b(x)modulo the generator polynomialxm+g(x). The digit serial multipliers keep the coefficients of each polynomial operand in an array of digits. One of the operands is multiplied by the digits of the other operand, one digit at a time. Each of these partial product computations is interleaved with a modular reduction step and an accumulation step.There are several works studying polynomial basis digit serial multipliers in the literature [7–13] but these multipliers have been developed to support a particular field size m. The work in [7] introduces efficient digit serial multipliers using polynomial basis. The work in [11] investigates optimum digit sizes and the effects of using multiple accumulators. The work in [12] proposes using T flip flops in the accumulators instead of D flip flops to reduce the area complexity.The versatility is an important feature for hardware designs since the ASIC circuits cannot be altered after fabrication. Flexible implementations are possible with reconfigurable FPGA devices but FPGAs cannot compete with the ASIC in terms of performance, cost and power consumption. Naturally, customizable elliptic curve systems [14] and versatile multipliers [15–19] have been proposed in the literature but the proposed multipliers are all bit serial and there is not much work about versatile digit serial multipliers.Let the supported field sizes bem1<m2<…<mλ. Then, the number of the bits used in the representation must be large enough to representmλcoefficients. When a field with smaller sizemk<mλis selected, the elementsa(x)=∑i=0mk-1aixi∈F2mkmust be justified either to the right or to the left. Whena(x)is right justified, the leadingmλ-mkcoefficients are set to zero as follows.a(x)=0xmλ-1+⋯+0xmk+a(x)In left justified representation,a(x)is shifted, then the trailingmλ-mkcoefficients are set to zero as follows.a^(x)=xmλ-mka(x)+0xmλ-mk-1+⋯+0x+0Also, the fieldsF2m1,F2m2,…,F2mλsupported by the multipliers use different generator polynomialsxmk+g(k)(x)fork=1,2,…,λ. Naturally, the modular reduction by eachxmk+g(k)(x)can be performed with a separate circuit. Nevertheless, the reduction circuits can be unified when the generator polynomialsxmk+g(k)(x)are appropriately chosen.The paper is organized as follows. Section 2 introduces the basic polynomial basis digit serial multipliers supporting a single field size and presents a detailed analysis of their complexities. Section 3 proposes digit serial multiplier architectures supporting multiple field sizes. Some of these work with right justified operands and some of them work with left justified operands. Also, some of these employ separate reduction circuits and some of them employ unified reduction circuits. Section 4 studies the complexities of the proposed multipliers. Section 5 presents a discussion of our results.Naturally, m bits are sufficient to represent an elementa(x)=∑i=0m-1aixiin the fieldF2m. This is because each binary valued coefficient ofa(x)can be stored in a bit. Let the hardware digit size be w bits. A digit serial multiplier divides one of the operands, sayb(x), into⌈m/w⌉digits as follows.b(x)=∑i=0m-1bixi=∑j=0⌈m/w⌉-1BjxwjwhereBj=∑i=0w-1bwj+ixi, is the jth digit ofb(x)and holds its consecutive w coefficients. Then,(1)a(x)b(x)modxm+g(x)=∑j=0⌈m/w⌉-1a(x)Bjxwjmodxm+g(x)gives the field product. The multiplier computes this product, accumulating the partial products of the digitsBjin⌈m/w⌉iterations. Thus, the multiplier gets faster as the digit size w increases. However, its area also increases because the digitsBj, and thus their partial products get larger. In each iteration, one of the partial productsa(x)Bjis computed and added to an intermediate resultI(x)wheredeg(I(x))<m+w. The intermediate resultI(x)can be split into degreew-1andm-1polynomials as follows.(2)I(x)=∑i=0m+w-1Iixi=q(x)xm+r(x)whereq(x)=∑i=0w-1Im+ixiandr(x)=∑i=0m-1Iixi. The generatorxm+g(x)is usually chosen such that(3)deg(g(x))=μ⩽m-w.for fast modular reduction. Then, the intermediate result can be reduced without division as follows.(4)I(x)modxm+g(x)=q(x)xm+r(x)modxm+g(x)=g(x)q(x)+r(x)This can be done becausedeg(g(x)q(x))<mfor any degreew-1polynomialq(x)when Eq. (3) holds.The most significant digit first multipliers compute the field product in (1), starting from the most significant digitBM-1as illustrated in the following algorithm.Algorithm 1MSD first field multiplicationInputs:a(x)=∑i=0m-1aixi,g(x)=∑i=0μgixi,b(x)=∑i=0m-1bixi=∑j=0⌈m/w⌉-1BjxwjwhereBj=∑i=0w-1bwj+ixiOutput:f(x)=a(x)b(x)modxm+g(x)1:I(x)=02:forj=⌈m/w⌉-1to 03:f(x)=I(x)modxm+g(x),I(x)=a(x)Bj+xwf(x)4:f(x)=I(x)modxm+g(x)In this algorithm,I(x)is the accumulated sum of the partial products.I(x)is initialized to zero in the beginning and reduced moduloxm+g(x)in each iteration. The reduced resultf(x)≡∑i=j+1⌈m/w⌉-1a(x)Bixw(i-j-1)modxm+g(x)xwf(x)is added with the partial producta(x)Bjto updateI(x)in the jth iteration. After all partial products are added,I(x)is reduced one last time. Fig. 1illustrates MSD first multiplication. Here, it is chosen thatdeg(g(x))=μ⩽m-w. Thus, the reductionI(x)modxm+g(x)=g(x)q(x)+r(x)as shown in (4) whereq(x)andr(x)are higher and lower terms ofI(x).These multipliers compute the field product in (1), starting from the least significant digitB0, as follows.Algorithm 2LSD first field multiplicationInputs:a(x)=∑i=0m-1aixi,g(x)=∑i=0μgixi,b(x)=∑i=0m-1bixi=∑j=0⌈m/w⌉-1BjxwjwhereBj=∑i=0w-1bwj+ixiOutput:f(x)=a(x)b(x)modxm+g(x)1:J(x)=02:forj=0to⌈m/w⌉-13:ifj=0thenI(x)=a(x)elseI(x)=A(x)4:A(x)=I(x)xwmodxm+g(x),J(x)=I(x)Bj+J(x)5:f(x)=J(x)modxm+g(x)In the jth iteration of the LSD first multiplication,I(x)≡xwja(x)mod(xm+g(x)),J(x)≡∑i=0ja(x)Bixwimodxm+g(x)Fig. 2illustrates this computation. Here, it is chosen thatdeg(g(x))=μ⩽m-w. Thus,xwI(x)andJ(x)can be reduced without division as shown in (4). For this,I(x)andJ(x)are split as followsI(x)=∑i=0m-1Iixi=q(x)xm-w+r(x),J(x)=∑i=0m+w-1Jixi=q′(x)xm+r′(x)to computexwI(x)mod(xm+g(x))=g(x)q(x)+xwr(x)andJ(x)mod(xm+g(x))=g(x)q′(x)+r′(x).Now, we study the complexities of the multipliers, using the results of the following theorem.Theorem 1LetΔ(x),u(x), andv(x)be three binary polynomials such thatΔ(x)=∑i=0ω-1Δixi,u(x)=∑i=0ℓ-1uixi,v(x)=∑i=0ℓ′-1vixiwheredeg(v(x))⩾deg(Δ(x)u(x)). LetTANDandTXORdenote an AND gate delay and an XOR gate delay, respectively. The multiply operationΔ(x)u(x)has the following area requirement and critical path delay.ωℓAND gates,(ω-1)(ℓ-1)XOR gates,TAND+TXOR⌈log2(min(ω,ℓ))⌉The multiply–add operationΔ(x)u(x)+v(x)has the following area requirement and critical path delay.ωℓAND gates,ωℓXOR gates,TAND+TXOR⌈log2(min(ω,ℓ)+1)⌉Letu(x)have at mostτnonzero terms, i.e.u(x)=∑i=0ℓ-1uixi=∑i=1τuμixμifor some distinct integersμisuch that0⩽μi<ℓ. Then, the multiply–add operationΔ(x)u(x)+v(x)has the following area requirement and critical path delay.ωτAND gates,ωτXOR gates,at mostTAND+TXOR⌈log2(min(ω,τ)+1)⌉The caseω=min(ω,ℓ,τ)is analyzed in this proof. At the end, the results are extended to the general case. Note that the productΔ(x)u(x)is a polynomial of degreeℓ+ω-2and its terms are as follows.Δ(x)u(x)=∑j=0iΔjui-jxi,0⩽i<ω-1∑j=0ω-1Δjui-jxi,ω-1⩽i<ℓ∑j=i+1-ℓω-1Δjui-jxi,ℓ⩽i<ℓ+ω-1=∑j=0iΔjui-jxi,0⩽i<ω-1∑j=0ω-1Δjui-jxi,ω-1⩽i<ℓ∑j=i+1ω-1Δjuℓ+i-jxℓ+i,0⩽i<ω-1As seen,Δ(x)u(x)has the terms∑j=0ω-1Δjui-jxiforω-1⩽i<ℓ. Computing the coefficient of eachxirequiresωAND gates and(ω-1)XOR gates. Thus, computing all these terms requiresω(ℓ-ω+1)AND gates and(ω-1)(ℓ-ω+1)XOR gates. Also,Δ(x)u(x)has the following terms.∑j=0iΔjui-jxi,∑j=i+1ω-1Δjuℓ+i-jxℓ+ifor0⩽i<ω-1.Computing the coefficients of eachxiandxℓ+ipair requiresωAND gates and(ω-2)XOR gates. Thus, computing all these terms requiresω(ω-1)AND gates and(ω-2)(ω-1)XOR gates.As a result, all the coefficients ofΔ(x)u(x)are obtained byω(ℓ-ω+1)+ω(ω-1)=ωℓAND gates and(ω-1)(ℓ-ω+1)+(ω-2)(ω-1)=(ω-1)(ℓ-1)XOR gates. The coefficient computation∑j=0ω-1Δjui-jcauses the largest delay. Thus, the critical path delay isTAND+TXOR⌈log2ω⌉. WhenΔ(x)u(x)+v(x)is computed instead ofΔ(x)u(x), XOR gate count increases from(ω-1)(ℓ-1)to(ω-1)(ℓ-1)+deg(Δ(x)u(x))+1=ωℓand the critical path delay becomesTAND+TXOR⌈log2(ω+1)⌉.In the corollary, we consider the caseu(x)has at mostτnonzero coefficients, i.e.u(x)=∑i=0ℓ-1uixi=∑i=1τuμixμi. Then,ω(ℓ-τ)AND gates andω(ℓ-τ)XOR gates are redundant. Thus, AND and XOR gate requirements each reduces fromωℓtoωτ. Also, the critical path delay remains the same or reduces.The complexities ofΔ(x)u(x)andΔ(x)u(x)+v(x)have already been analyzed for the case thatΔ(x)has less terms thanu(x), i.e.ω=min(ω,ℓ,τ). SinceΔ(x)u(x)=u(x)Δ(x), the same analysis can be repeated just by swappingΔ(x)withu(x)for the case thatΔ(x)has more terms thanu(x). Then, the complexities can be found by swappingωwithℓ, andωwithτ. Naturally, the area complexities(ω-1)(ℓ-1),ωℓ, andωτremain the same. However, the time complexities change and the general case time complexities are obtained by replacingωwithmin(ω,ℓ)andωwithmin(ω,τ).□The area and time complexities of the MSD first multiplier can be found by inspecting Fig. 1.Computing the producta(x)Bjcorresponds the multiplication in Theorem 1 for the caseω=wandℓ=m. Thus, it requires wm AND plus(w-1)(m-1)XOR gates, and has the delayTa(x)Bj=TAND+TXOR⌈log2w⌉.Computing the reductionf(x)=g(x)q(x)+r(x)corresponds the multiply–add operation in Theorem 1 for the caseω=w,ℓ=μ+1, andℓ′=m. Thus, it requiresw(μ+1)AND plusw(μ+1)XOR gates and has the delayTf(x)=TAND+TXOR⌈log2(min(w,μ+1)+1)⌉.a(x)Bjism+w-1bits andf(x)is m bits. Thus, computing and storingI(x)=a(x)Bj+xwf(x)requirem-1XOR gates plusm+wflip flops and has the delayTXOR. Then, the critical path delay(5)Tdelay=TXOR+maxTa(x)Bj,Tf(x)=TAND+TXOR+TXOR⌈log2(w+1)⌉.Actually,Tdelay=TAND+TXOR+TXOR⌈log2w⌉whenw>μ+1but we ignore this minor improvement.The area and time complexities of the LSD first multiplier can be found by inspecting Fig. 2.ComputingI(x)Bj+J(x)corresponds the multiply–add operation in Theorem 1 for the caseω=w,ℓ=m, andℓ′=w+m-1. Thus, it requires wm AND plus wm XOR gates and has the delayTI(x)Bj+J(x)=TAND+TXOR⌈log2(w+1)⌉.Computing the reductiong(x)q(x)+xwr(x)corresponds the multiply–add operation in Theorem 1 for the caseω=w,ℓ=μ+1, andℓ′=m. Thus, it requiresw(μ+1)AND pluswμXOR gates. Actually, notwμXOR gates butw(μ+1)XOR gates are needed according to the theorem. Nevertheless, w XOR gates can be saved since the least significant w bits ofxwr(x)are zero.Computing the final reductiong(x)q′(x)+r′(x)corresponds the multiply–add operation for the caseω=w-1,ℓ=μ+1, andℓ′=m. Thus, it requires(w-1)(μ+1)AND plus(w-1)(μ+1)XOR gates.StoringA(x)andJ(x)requires2m+w-1flip flops. MultiplexingA(x)anda(x)requires m-bit multiplexer. Also, the critical path delay(6)Tdelay=TMUX+TI(x)Bj+J(x)=TAND+TMUX+TXOR⌈log2(w+1)⌉.Tables 1 and 2summarize the complexity analyses of the MSD first and LSD first multipliers. Table 1 gives the area complexities for both general and t-nomial generator polynomials. The general and t-nomial generator polynomials are respectively given byxm+g(x)=xm+∑i=0μgixi,xm+g(x)=xm+∑i=1t-1xμi.whereμi,μ⩽m-wto satisfy the restriction (3). The complexity results for general generator polynomials are obtained from the previous analyses in the paper. Also,μ+1additional flip flops are needed to store the generator coefficientsgifori=0,1,…,μin general case as seen from Table 1. On the other hand, a t-nomial is a constant coefficient polynomial with t nonzero terms. Since the coefficients are constant, they do not need to be stored. Also, reduction with a t-nomial requires only hardwiring and XORing. This computation is very efficient when t is small. Note that the fast modular reduction in (4) becomesq(x)xm+r(x)mod(xm+g(x))=r(x)+q(x)g(x)=r(x)+∑i=1t-1q(x)xμiwhen the generator polynomialxm+g(x)is a t-nomial. As seen, reduction modulo a t-nomial requires 0 AND gates andw(t-1)XOR gates wheredeg(q(x))⩽w. Our previous analyses in the paper show that modular reduction requiresw(μ+1)AND gates andw(μ+1)XOR gates when a general generator polynomial withdeg(g(x))=μis used. Therefore, the complexities in Table 1 for the t-nomial case are obtained from the complexities for the general case in two steps.•First, the AND gates used in the reduction are excluded from the total AND count because reduction with constant coefficient t-nomials does not need any AND gates.Secondly,μin the XOR count is substituted witht-2because XOR complexity isw(t-1)for the t-nomial case while XOR complexity isw(μ+1)for the general case.Table 2 gives the time complexities of the multipliers. The delay of the partial product computation dominates the delay of the modular reduction as seen from (5) and (6). Thus, using sparse t-nomial generator polynomials cannot decrease the critical path delay here.In this section, MSD first multipliers supporting multiple fields are proposed. MSD first multiplication is preferred to LSD first multiplication in the proposed design because the former requires less area than the latter as seen from Table 1.Let the supported field sizes bem1<m2<…<mλ. Then, at leastmλbits are required to represent the field elements. When the multiplier works in the fieldF2mk, its inputs and output aremkbits and they must be stored inmλbits with a proper alignment. Letu(x)be a multiplier input or output. As seen from Fig. 3,u(x)can be either right justified by zero extending or left justified by zero padding as follows.(7)u^(x)=xmλ-mku(x)=xmλ-mk∑i=0mk-1uixi.Note that the digit serial multiplication in (1) can be written for anyΔ⩾0as follows.xΔf(x)=∑j=0⌈mk/w⌉-1xΔa(x)BjxwjmodxΔ+mk+xΔg(x)Then, whenΔ=0and whenΔ=mλ-mk, the digit serial multiplication becomes(8)f(x)=∑j=0⌈mk/w⌉-1a(x)Bjxwjmodxmk+g(x),f^(x)=∑j=0⌈m/w⌉-1,a^(x)Bjxwjmodxmλ+g^(x)respectively. Here,a(x),b(x),g(x),f(x)are the right justified anda^(x),b^(x),g^(x),f^(x)are the left justified operands. Fig. 4illustrates the multipliers working with both the right and the left justified operands. As seen, the left justified alignment is advantageous sinceI(x)is reduced modulo a degreemλpolynomial, regardless of the selected field sizemk. However, when the operands are right justified, the reduction ofI(x)is performed modulo a degreemkpolynomial, and thus dependent on the selected field size.In this section, the MSD first multiplier in Fig. 1 is modified to support multiple field sizes. The modified multiplier has right justified inputs and output.The MSD first multiplier in Fig. 1 must extract the digitsBjfromb(x). For this,b(x)is put in aw⌈m/w⌉bit shift register. As the register shifts left by w bits at each clock, the most significant w bits are extracted to obtain the digitsBjone by one. When the multiple fields are supported, the digits ofb(x)are extracted as shown in Fig. 5. The circuit in Fig. 5 extracts the followingwλbits ofb(x)in each cycle.(9)bw⌈mk/w⌉-i,0<i⩽w,1⩽k⩽λ.Let the selected field size bemk0. Then, only the following bits are needed among the extracted bits.Bj={bw⌈mk/w⌉-i|0<i⩽w,k=k0}.Thus, the extracted bits are ANDed with the selection bitssk=δ[k-k0]and the results are XORed to produce the digitBjas shown in Fig. 5.The MSD first multiplier in Fig. 1 splits the accumulated sumI(x)into the polynomialsq(x)=∑i=0w-1Im+ixiandr(x)=∑i=0m-1Iixiand reduces it tof(x)=I(x)mod(xm+g(x))=q(x)g(x)+r(x).Fig. 6illustrates the reduction ofI(x), when the multiple field sizes are supported and the operands are right justified. In the figure,I(x)is split into(10)q(x)=∑i=0w-1Imk0+ixi,r(x)=∑i=0mk0-1Iixiwheremk0is the selected field size. The selection bitssk=δ[k-k0]are used to select the correctq(k)(x)=∑i=0w-1Imk+ixi. Thus,q(x)in (10) is computed in Fig. 6 as follows.q(x)=∑k=1λskq(k)(x)=q(k0)(x)=∑i=0w-1Imk0+ixiAlso,r(x)in (10) is computed in Fig. 6 as follows.r(x)=∑i∉[mk,mk+w)for1⩽k⩽λIixi+∑i∈[mk,mk+w)for1⩽k⩽λ-1Iisk‾xisk‾=1-skis the negation of the selection bit. Thus,sk‾=0whenk=k0andsk‾=1whenk≠k0. Then,r(x)=∑i∉[mk0,mk0+w)Iixi=∑i=0mk0-1Iixias given by (10). Note thatIi=0formk0+w⩽i<mλabove, because the operands are right justified.The polynomialsxmk+g(k)(x)are the generators of the fieldsF2mkfor1⩽k⩽λ. Let the field sizemk0be selected. Then, the polynomial used in the reductiong(x)=∑k=1λskg(k)(x)=∑k=1λδ[k-k0]g(k)(x)=g(k0)(x)andf(x)=I(x)mod(xmk0+g(x))=q(x)g(x)+r(x)can be computed as shown in Fig. 6. For example,(11)xm1+g(1)(x)=x163+x38+x12+x2+1,xm4+g(4)(x)=x409+x38+x9+x2+1,xm2+g(2)(x)=x233+x38+x12+x2+1,xm5+g(5)(x)=x571+x22+x12+x2+1xm3+g(3)(x)=x283+x38+x12+x2+1,are irreducible polynomials and can be used as generator polynomials for the NIST fields. Then,(12)g(x)=g(k0)(x)=s5‾x38+s5x22+s4‾x12+s4x9+x2+1.Here,g(x)is a polynomial withτ=6terms andsk=δ[k-k0]are the bits selecting the field.The appropriate reduction polynomialg(x)is stored in a register and used in the reductionq(x)g(x)+r(x)as shown in Fig. 6. However, the reduction can also be carried out separately for each field by using its generator polynomialxmk+g(k)(x)as shown in the same figure.When the reduction is carried out separately for each field, the irreducible polynomialsxmk+g(k)(x)must be chosen as sparse as possible to reduce the complexity. An irreducible pentanomial existsxm+g(x)=xm+xμ1+xμ2+xμ3+1for each field sizem⩾4[20]. When pentanomials are used as generators, the area requirement and the worst case critical path delay of the reductions are as follows.(13)w(2λ-1)ANDs,4wλXORs,TAND+TXOR⌈log2(4λ+1)⌉.These complexities can be found by inspecting Fig. 6. When the generator polynomials are pentanomials,g(k)(x)=xμ1(k)+xμ2(k)+xμ3(k)+1.Thus,∑k=1λq(k)(x)g(k)(x)+r(x)is equal to the following, which needs4deg(q(k)(x))λ=4wλXOR gates.r(x)+∑k=1λq(k)(x)xμ1(k)+q(k)(x)xμ2(k)+q(k)(x)xμ3(k)+q(k)(x)Also, the worst case critical path delay isTXOR⌈log2(4λ+1)⌉. Note that, when w andλare small, the delay can be decreased by choosingμi(k)suitably. Also, as seen in Fig. 6, obtainingr(x)fromr′(x)and selecting the correctq(k)requirew(λ-1)pluswλAND gates and has a delay ofTAND.In this case, the irreducible polynomialsxmk+g(k)(x)generating the supported fieldsF2mkare chosen such that their trailing coefficientsg(k)(x)=∑i=1τgμi(k)xμican be nonzero only for the sameτterms.Let the selected field size bemk0. Then,g(x)=g(k0)(x)is stored into aτbit register and used in the reduction computationq(x)g(x)+r(x)as seen in Fig. 6. The area and delay are as follows.(14)w(τ+2λ-2)ANDs,w(τ+λ-1)XORs,τflip flops,2TAND+TXOR(⌈log2λ⌉+⌈log2(min(w,τ)+1)⌉)whereτis the nonzero term count ofg(x). These are the complexities of storingg(x), obtainingq(x)andr(x), and computingg(x)q(x)+r(x). As seen from Fig. 6, obtainingq(x)andr(x)needsw(2λ-1)AND plusw(λ-1)XOR gates and has a delay ofTAND+TXOR⌈log2λ⌉. Also, the area and delaywτAND,wτXOR,TAND+TXOR⌈log2(min(w,τ)+1)⌉are needed to computeg(x)q(x)+r(x)due to Corollary 1. But, we can save w AND gates above. This is becauseg(x)=g(k0)(x)wherexmk0+g(k0)(x)is an irreducible and thus, its zeroth termg0=1always.The nonzero term countτofg(x)must be as small as possible to decrease the complexities in (14).(15)τ⩽log2mλ+3is guaranteed actually where the largest field sizemλ⩽1000. This is because it is an experimental fact that there always exists an irreduciblexm+∑i=1τgμixμiin the following forms.xm+∑μ∈{0,1,…,9}⧹{4,7}gμxμform⩽133,xm+∑μ∈{0,1,…,11}⧹{8,9}gμxμform⩽372,xm+∑μ∈{0,1,…,12}⧹{3,8}gμxμform⩽658,xm+∑μ∈{0,1,…,12}⧹{8}gμxμform⩽1000.As seen above,τcan be as small as 8, 10, 11, and 12 form⩽133,m⩽372,m⩽658, andm⩽1000, respectively. As a result,min(τ)⩽log2m+3for the polynomials in the cryptographic range of interest. Also, always an irreducible polynomialxm+g(x)exists form⩽2000such thatdeg(g(x))⩽log2m+3[21].These practical facts are natural consequences of the following heuristic argument: Let m be an integer large enough so that(1+1/m)m≈e(saym>50). Letμ1,μ2,…,μτbe some distinct integers such thatμ1=0<μi<μi+1<mfor2⩽i⩽τ. The probability of none of the polynomialsxm+g(x)g(x)=∑i=1τgμixμi=g0+∑i=2τgμixμibeing irreducible is approximately equal to(1/e)2εwhenτ=log2m+εfor someε⩾0. This is because a binary polynomial of degree m is irreducible with1/mprobability [1]. Then, the probability of none of the polynomialsxm+∑i=1τgμixμibeing irreducible is1-1m2τ=1-1m2log2m+ε=1-1mm2ε≈1e2ε.In this section, the MSD first multiplier in Fig. 1 is modified to support multiple field sizes. The modified multiplier has left justified inputs and output as illustrated in Fig. 3.When the left justified operands are used instead of the right justified ones, the circuit in Fig. 5 must be replaced with the one in Fig. 7. In Fig. 7, the followingwλbits ofb(x)are extracted in each cycle.(16)bw⌈mk/w⌉-i+Δ,0<i⩽w,1⩽k⩽λ.whereΔ=mλ-mk. Note that, letϕk=(-mkmodw)+mλ, then these bits can also be given as follows.bw⌈mk/w⌉-i+Δ=bϕk-i,0<i⩽w,1⩽k⩽λ.Let the selected field size bemk0. Then, only the following bits are needed among the extracted bits.Bj={bw⌈mk/w⌉-i+Δ=bϕk-i|0<i⩽w,k=k0}Thus, the extracted bits are ANDed with the selection bitssk=δ[k-k0]and the results are XORed to produce the digitBjas shown in Fig. 7.Fig. 8illustrates the reduction ofI(x), when the multiple field sizes are supported and the operands are left justified. The modular reduction circuit in Fig. 8 is much simpler than the one in Fig. 6 for the right justified operands since the left justified operands have the factorxmλ-mkwheremλis the largest field size. Thus, regardless of the field sizemk, the most significant ith bit of an operand is stored in the bitmλ-iof its representation andq(x)is stored in the bitsmλ+iofI(x)for0⩽i<w. Thus,q(x)=∑i=0w-1Imλ+ixi,r(x)=∑i=0mλ-1Iixias shown in Fig. 8. Also, if the generators of the fieldsF2mkarexmk+g(k)(x)for1⩽k⩽λ,g^(k)(x)=xmλ-mkg(k)(x),xmλ+g^(k)(x)=xmλ-mk(xmk+g(k)(x)).Let the field sizemk0be selected. Then,g^(x)=∑k=1λskg^(k)(x)=∑k=1λδ[k-k0]g^(k)(x)=g^(k0)(x)andI(x)can be reduced intof^(x)=I(x)mod(xmλ+g^(x))=q(x)g^(x)+r(x)as shown in Fig. 8. Here, the outputf^(x)is left justified since the modulus is a left justified generator polynomial.For example, the irreducible polynomials(17)xm1+g(1)(x)=x163+x40+x27+x21+1,xm4+g(4)(x)=x409+x286+x176+x126+1,xm2+g(2)(x)=x233+x110+x91+x70+1,xm5+g(5)(x)=x571+x448+x429+x408+1,xm3+g(3)(x)=x283+x160+x141+x120+1can be used as generators for the NIST recommended fields. Then, the left justified generator polynomialsxmλ+g^(k)(x)=(xmk+g(k)(x))xmλ-mkand the reduction polynomialg^(x)are as follows.(18)xmλ+g^(1)(x)=x571+x448+x435+x429+x408,xmλ+g^(2)(x)=x571+x448+x429+x408+x338,xmλ+g^(3)(x)=x571+x448+x429+x408+x288,xmλ+g^(4)(x)=x571+x448+x338+x288+x162,xmλ+g^(5)(x)=x571+x448+x429+x408+1g^(x)=g^(k0)(x)=x448+s1x435+s4‾x429+s4‾x408+(s2+s4)x338+(s3+s4)x288+s4x162+s5.Here,g^(x)is a polynomial withτ=8terms andsk=δ[k-k0]are the bits selecting the field.The appropriate reduction polynomialg^(x)is stored in a register and used in the reductionq(x)g^(x)+r(x)as seen in Fig. 8 but the reduction can also be carried out separately for each field by using its left justified generator polynomialxmλ+g^(k)(x)as seen in the same figure.When the reduction is carried out separately for each field as seen in Fig. 8, the generator polynomials must be chosen as sparse as possible to reduce the complexity. When the generators are pentanomials, the area requirement and worst case critical path delay can be found as follows.(19)wλAND,4wλXOR,TAND+TXOR⌈log2(4λ+1)⌉.g^(k)(x)=xmλ-mkg(k)(x)=xmλ-mk(xμ1(k)+xμ2(k)+xμ3(k)+1)when the generatorsxmk+g(k)(x)are pentanomials, Thus, the reductionf^(x)=∑k=1λskq(x)g^(k)(x)+r(x)is equal to the following.r(x)+∑k=1λskq(x)xmλ-mk+μ1(k)+skq(x)xmλ-mk+μ2(k)+skq(x)xmλ-mk+μ3(k)+skq(x)xmλ-mkNote thatdeg(q(x))<w. Therefore, computingskq(x)fork=1,2,…,λrequireswλAND gates and computing the additions above requires4wλXOR gates. All these computations have a worst case critical path delay ofTAND+TXOR⌈log2(4λ+1)⌉. Also, when w andλare small, the delay can be reduced by choosingμi(k)suitably.In this case, the irreducible polynomialsxmk+g(k)(x)generating the supported fieldsF2mkare chosen such that the coefficients of the polynomialsg^(k)(x)can be nonzero only for the sameτterms as follows.g^(k)(x)=g(k)(x)xmλ-mk=∑i=1τgμi(k)xμi+mλ-mkLet the selected field size bemk0. Then,g^(x)=g^(k0)(x)is stored into aτbit register and used in the reduction computationq(x)g^(x)+r(x)as seen in Fig. 8. The area requirement and the critical path delay are as follows.(20)wτANDs,wτXORs,τflip flops,TAND+TXOR⌈log2(min(w,τ)+1)⌉whereg^(x)hasτnonzero terms. These are the complexities of storingg^(x)and computingq(x)g^(x)+r(x). As seen from Fig. 8,q(x)andr(x)are obtained by just wiring without any cost since the operands are left justified. Due to Corollary 1, the cost of computingq(x)g^(x)+r(x)iswτAND,wτXOR,TAND+TXOR⌈log2(min(w,τ)+1)⌉.Note that the nonzero term countτofg^(x)must be as small as possible to decrease the complexities in (20). Actually, the probability of finding a value of(21)τ⩽log2m1+ε+λ-1is very high for a small positive numberεwhere the supported field sizes arem1<m2<…<mλ.We finish the section with a heuristic proof of this claim. Let the irreducible generator polynomials for the supported fields bexmk+g(k)(x)for1⩽k⩽λ. Let the terms ofg(k)(x)with degree larger thanmk-m1form the polynomialα(k)(x)xmk-m1. Then, the polynomialsg(k)(x)=α(k)(x)xmk-m1+∑i=0mk-m1gi(k)xi,g^(k)(x)=α(k)(x)xmλ-m1+∑i=0mk-m1gi(k)xi+mλ-mk.We can ease the modular reduction by setting some polynomial terms to zero as follows.g(k)(x)=∑j=1ρανj(k)xνj+mk-m1+∑j=1kgmk-mj(k)xmk-mj,g^(k)(x)=∑j=1ρανj(k)xνj+mλ-m1+∑j=1kgmk-mj(k)xmλ-mj.Now, the polynomialsg^(k)(x)can be nonzero only for the followingρ+kterms where1⩽k⩽λ.(22)xμ,μ∈{νj+mλ-m1|j=1,2,…,ρ}xμ,μ∈{mλ-mj|j=1,2,…,k}Also, remember thatm1<m2<…<mλ. Thus,mλ-m1>mλ-m2>…>mλ-mλ=0. We can classify the terms of the left justified polynomialsg^(k)(x)into the two following groups.•High order termsg^i(k)xiwith degreei>mλ-m1.Low order termsg^i(k)xiwith degreei⩽mλ-m1.As seen from (22), theρhigh order terms of the polynomialsg^(k)(x)are allowed to be nonzero. Also, among the low order terms ofg^(k)(x), only the termsxmλ-m1,xmλ-m2,…,xmλ-mλ=1are allowed to be nonzero. These low order terms cannot be eliminated sincexm+g(k)(x)for1⩽k⩽λare all binary irreducible polynomials. Thus,g0(k)=1and the termsg^mλ-mk(k)xmλ-mk=g0(k)xmλ-mk=xmλ-mkcannot be set to zero for allk=1,2,…,λbut allowing the other low order terms ofg^(k)(x)to be nonzero is not useful sinceg^(k)(x)=g(k)(x)xmλ-mkare left justified. Thus, their many low order terms are already zero.Then, the coefficients of the left justified polynomials can be nonzero only for the sameρ+ktermsg^(k)(x)=g(k)(x)xmλ-mk=∑i=1ρ+kg^μi(k)xμias seen from (22). Then, the probability of none of the polynomialsxmk+g(k)(x)g(k)(x)xmλ-mk=∑i=1ρ+kg^μi(k)xμibeing irreducible is(1-1/mk)2ρ+kbecause binary polynomial of degreemkis irreducible with1/mkprobability [1]. Whenρ+k=log2mk+ε, this probability is1-1mk2log2mk+ε=1-1mkmk2ε≈1e2ε.As a result, finding an irreduciblexmk+g(k)(x)for each k is very likely when we chooseρ=max1⩽k⩽λ(log2mk-k)+ε.The supported fieldsm1<m2<…<mλsatisfymk<2k-1m1in practical applications. Then,ρ=max1⩽k⩽λ(log2mk-k)+ε⩽log2m1-1+εandτ⩽max(ρ)+max(k)=log2m1-1+ε+λas in (21).In this section, the complexities of the proposed multipliers are analyzed.Table 3gives the area requirements of the MSD first multipliers supportingλdifferent fields. Table 3 also gives the area requirement of a usual MSD first multiplier supporting the single field sizem=mλand using a generator polynomial witht=5terms (pentanomial). The complexity of the multiplier supporting single field is obtained from Table 1. The complexities of the multipliers supporting multiple fields are obtained by adding the complexities of the three main computations shown in Fig. 4. These three computations and their area requirements are as follows.•Obtaining the digitsBjfromb(x)(or fromb^(x)for the left justified operands) is the first computation. It requireswλANDs andw(λ-1)XORs regardless of whether the operands are right or left justified. This can be seen from Figs. 5 and 7 easily.Computing and accumulating the partial productsxwf(x)+a(x)Bj(orxwf^(x)+a^(x)Bjfor the left justified operands) is the second computation. It requireswmλANDs andw(mλ-1)XORs regardless of whether the operands are right or left justified. This follows from Theorem 1. According to this theorem, accumulating the products ofωbit andℓbit operands requiresωℓAND plusωℓXOR gates. The maximum supported field size ismλ. Thus,ℓ=mλbits are used to represent the field elementa(x)andω=wbits are used to represent the digitsBj. Then,wmλAND andwmλXOR gates are needed to accumulate the productsa(x)Bj(ora^(x)Bjfor the left justified operands). However, we can save w XOR gates since we do not need to add the termsx0,x1,…,xw-1in the sumxwf(x)+a(x)Bj(orxwf^(x)+a^(x)Bjfor the left justified operands).The modular reductionf(x)=I(x)mod(xmk+g(x))(orf^(x)=I(x)mod(xmλ+g^(x))for the left justified operands) is the third computation. The area requirements of two different modular reduction schemes are given by (13) and (14) (or (19) and (20) for the left justified operands).The critical path delays of the proposed multipliers can be given as follows.(23)2TAND+⌈log2λ⌉+⌈log2w⌉+1TXORwhereλis the number of the supported fields and w is the digit size in bits. This fact can be explained as follows. As seen from Fig. 4, the critical path delay of the proposed design cannot be smaller than the sum of the delays of the following three computations.•The first one is the extraction of the digitBjfromb(x)(or fromb^(x)for the left justified operands). This has the delayTAND+TXOR⌈log2λ⌉as seen from Figs. 5 and 7.The second one is themλ×wbit partial producta(x)Bj(ora^(x)Bjfor the left justified operands). This has the delayTAND+TXOR⌈log2min(w,mλ)⌉=TAND+TXOR⌈log2w⌉according to Theorem 1.Third one is the accumulation of the partial products, which has oneTXORdelay.The total delay due to these computations isT=2TAND+⌈log2λ⌉+⌈log2w⌉TXOR+TXORand equal to (23). As seen from Fig. 4, the critical path delay is actuallymax(T,Treduction+TXOR)whereTreductionis the delay of the modular reductionf(x)=I(x)mod(xmk+g(x))(orf^(x)=I(x)mod(xmλ+g^(x))for the left justified operands).Treductionis given by (13), (14), (19), and (20) for four different cases. A simple investigation shows that the critical path delay isT=max(T,Treduction+TXOR)and equal to (23).Table 4gives the area complexities of the MSD first multipliers when they support the five binary fields recommended by NIST. The number of the NIST fieldsλ=5and the largest NIST field sizemλ=571. The complexities in the table are obtained from Table 3 for these NIST parameters.The modular reduction can be unified for the NIST fields by using a common reduction polynomial. When the field elements are right justified, the polynomial withτ=6termsg(x)=g38x38+g22x22+g12x12+g9x9+g2x2+g0given by (12) can be used as reduction polynomial. Also, when the field elements are left justified, the polynomial withτ=8termsg^(x)=g^448x448+g^435x435+g^429x429+g^408x408+g^338x338+g^288x288+g^162x162+g^0given by (18) can be used as reduction polynomial. The coefficients of these polynomials are determined by the selected field as seen from (12) and (18).Table 4 shows that supporting multiple fields instead of a single field does not increase the cost much and working with the left justified operands is slightly advantageous. Also, because the number of the fieldsλ=5is small for the NIST case, using a separate reduction circuit for each field is affordable. The delay of the multipliers supporting the NIST fields can be obtained from (23) by substitutingλ=5.Table 5gives the space and time complexities of several digit serial multipliers. The space complexities of the proposed architectures in the table are obtained from Table 3 by substitutingτwith the upper bounds in (15) and (21). As seen, the complexities of the multipliers supporting a single field are very similar and the usual MSD first multiplier shows one of the best performances. Note that the MSD first multiplier needswmλANDs,wmλ+3wXORs,mλ+wlatcheswhere the size of the working fieldmk=mλ. If this area and the areas of the proposed multipliers supportingλfields are analyzed, we reach the following conclusions.•The area increases linearly withλ.wλAND gates can be saved when the multiplication is performed with left justified operands.Unifying the modular reductions of the supportedλfields causes the termslog2m1orlog2mλto appear in the area complexities additionally but also, decreases5λterm in the XOR complexity to2λ. Thus, the multipliers with unified reduction circuit can be advantageous for largeλ.Compared to the digit serial multipliers, the versatile bit serial multipliers [15–19] require less area and their critical path delays are also smaller. However, they need at leastmkcycles to finish the multiplication while many digit serial multipliers need approximately⌈mk/w⌉cycles.Table 6gives the FPGA implementation results of the usual MSD first multiplier and proposed multipliers. These results were synthesized using Xilinx ISE Webpack version 14.7 for the Xilinx Virtex xc5vlx50-11ff1153. As seen, the areas of the proposed multipliers are not significantly larger than the area of the usual MSD first multiplier, even though they support five NIST fields. However, there is a considerable increase in the minimum clock period. Also, the area needed for the multipliers using unified reduction strategy is larger than the area needed for the ones using separate reduction strategy. This is because the number of the supported fieldsλ=5is small compared tolog2mλ. The unified reduction strategy becomes more advantageous asλincreases.

@&#CONCLUSIONS@&#
