@&#MAIN-TITLE@&#
Thermal-aware floorplanner for 3D IC, including TSVs, liquid microchannels and thermal domains optimization

@&#HIGHLIGHTS@&#
We have designed an effective algorithm to optimize the placement of functional units and through silicon vias.We have also integrated an approximated (but accurate) thermal model inside the optimization loop.We have added an optimizer for active cooling (liquid channels).We propose a novel technique based on air channel placement designed to isolate thermal domains.

@&#KEYPHRASES@&#
3D architecture,Thermal-aware floorplan,Air channels,Through silicon vias,Evolutionary algorithms,

@&#ABSTRACT@&#
3D stacked technology has emerged as an effective mechanism to overcome physical limits and communication delays found in 2D integration. However, 3D technology also presents several drawbacks that prevent its smooth application. Two of the major concerns are heat reduction and power density distribution. In our work, we propose a novel 3D thermal-aware floorplanner that includes: (1) an effective thermal-aware process with three different evolutionary algorithms that aim to solve the soft computing problem of optimizing the placement of functional units and through silicon vias, as well as the smooth inclusion of active cooling systems and new design strategies, (2) an approximated thermal model inside the optimization loop, (3) an optimizer for active cooling (liquid channels), and (4) a novel technique based on air channel placement designed to isolate thermal domains have been also proposed. The experimental work is conducted for a realistic many-core single-chip architecture based on the Niagara design. Results show promising improvements of the thermal and reliability metrics, and also show optimal scaling capabilities to target future-trend many-core systems.air channeldynamic voltage and frequency scalingfunctional unitintegrated circuitliquid channelsmulti-objective evolutionary algorithmmulti-objective floorplanning algorithmprinted circuit boardresistance–capacitancethrough silicon via

@&#INTRODUCTION@&#
The process of continuous scaling over the past decades has led to important improvements in size and performance of electronic products, but it has also led to several challenges such as communication problems and temperature management.The shift to the many-core architectures has been driven by the advances in semiconductor technologies. Besides, the increase in power dissipation has been tailored by dynamic techniques like Dynamic Voltage and Frequency Scaling (DVFS) [1], using several clock domains [2] or task migration policies [3]. These techniques, however, may also impact negatively the performance of the system. Design-time approaches like the one proposed in this paper are able to mitigate the effect of high temperatures and, also, are compatible with any other existing dynamic technique applied to maintain or even increase the performance of the system.One important mechanism to overcome physical limits in Integrated Circuit (IC) design underlies on the design of multi-level ICs using advanced processes. These techniques boost the concept of three dimensional integrated circuits (3D ICs). 3D designs improve the performance of the system by reducing interconnect delays and increasing the density of the logic. Through Silicon Vias (TSVs) connect multiple layers of the stack reducing distances between Functional Units (FUs), hence decreasing the communication delay. This fabrication technology also allows the integration of multiple and disparate technologies, such as radio frequency and mixed signal components, with traditional computing technologies.However, 3D integration exacerbates the problem of temperature in the chip, specially temperature in inner layers. These thermal problems are increasingly affecting the performance and the reliability of electronic systems. [4] reported that over 50% of electronic product failures are caused by thermal issues and the presence of hotspots. Increasing the temperature decreases lifetime of the chip exponentially. Furthermore, higher temperature can cause slower devices, can increase leakage current, and can reduce the performance due to the impact in the metal resistivity.Considering these facts, it is desired to keep the components and the chip structure as cool as possible for maximum reliability. However, the absolute temperature of the chip is not the only factor that affects performance; moreover, the thermal gradients that appear on the chip surface degrade the system reliability through the promotion of dangerous electro-migrations [5].One way in which hardware designers have tried to address the thermal problem is with the use of thermal-aware floorplanners such as [6] (that proposed a thermal-driven floorplanning algorithm for 3D ICs) or [7] (where the authors implemented a multi-objective floorplanning algorithm for 2D and 3D ICs, combining linear programming and simulated annealing). Some other authors have also considered the placement of thermal vias in these 3D stacks to optimize the thermal profile of ICs [8]. The careful placement of active modules in a 3D stack can optimize the wire length that connects FUs by reducing the communication delays, and can also provide a homogeneous temperature distribution across the chip. Apart from static approaches of thermal optimization, dynamic techniques are required to manage the high power densities found in these architectures. While the conventional air cooling has proved to be insufficient for 3D-ICs, the interlayer micro-channel liquid cooling provides a better option to address this problem. Some works like [9,10] have focused in thermal modeling with active cooling. These works have studied the effect of allocating liquid channels between active layers and their cooling effect.Some of the goals in the design of 3D stacks are to achieve a reduction in area and also to decrease the length of the interconnections, that would be translated into improved data transfer times and power consumption. Fig. 1summarizes our proposed concept of a 3D-IC architecture. Based on [11], the 3D stack is built over a Printed Circuit Board (PCB), which is considered to be adiabatic. Then, several layers are stacked, as can be seen in Fig. 1. Every layer of the stack is composed of silicon and silicon dioxide. Liquid Channelss (LCs) is used as an active cooling system. These channels are placed in the silicon dioxide just over the active layers. Liquid channels absorb heat produced by FUs with a high power density, reducing the temperature of inner layers. LCs contain a coolant (generally water) that is pumped into the chip. In this paper we also propose a novel architectural set-up based on isolation channels or Air Channels (ACs). Air channels are etched in silicon and filled with low pressure air. Since heat spread is mainly diffusive, air channels prevent cold areas to be affected by the power dissipated in other regions of the chip, creating temperature domains or regions. The use of air channels has the major purpose of isolating thermal regions. This could seem counter intuitive as the heat flow from hotter modules could not be dissipated by the cooler ones. However, the idea behind this is the optimization of the active cooling mechanism (liquid channels), whose placement, number and required cooling energy are benefited by the air channels. More in detail:1Since the chip is split in several independent regions, the thermal distribution of every domain can be defined attending to design constraints. In this way, it is easier to obtain a homogeneous distribution, or a pattern of alternate warm and cold regions, that help on achieving a more controlled thermal profile in the design phase.If high temperatures are located in certain regions, dissipation mechanisms can be applied in those areas where the thermal problems are exacerbated, minimizing technological costs and optimizing the cooling properties of the different techniques.All this architectural diversity encourages the research on the design of optimization algorithms to place automatically FUs, TSVs, as well as liquid and air channels, minimizing maximum temperature and total wire length. The efficient management of all these input variables, and the multiple optimization criteria given by several objectives that have to be accomplished at the same time, requires innovative algorithms capable of evaluating all these parameters and returning the best set of solutions. In the case of 3D IC design, incremental optimization is a promising way to handle multi-objective optimization with complicated constraints and to facilitate the design reuse technology. Many works have been published with this approach, however, none took into account thermal-aware floorplanning. Most multi-objective floorplanning algorithms in the literature are developed using Genetic Algorithms or Simulated Annealing, where the main problem relies on the formulation of the representation. Common representations for the floorplanning problem are polish notation [12], combined bucket array [6] and O-tree [13]. Most of these representations do not perform well in our scenario because they were initially developed to reduce area, whereas our problem is based on minimizing temperature. To this end, we extend in this paper our previous algorithm for floorplanning optimization named Multi-objective Floorplanning Algorithm (MFA) [14], in which we formulated a multi-objective optimization problem for 3D thermal aware floorplanning that is able to reduce peak temperature, eliminate hotspots, and hence decrease reliability risks related to temperature. MFA allows the incremental placement of FUs and TSVs.In this paper, we will denote this algorithm with MFAFU. From our previous work in [14], as Fig. 2introduces, we have enhanced the TSVs placement developing the new MFAFU* that slightly extends MFAFU to obtain solutions where at least one TSV configuration can be reached. We have also developed two new evolutionary algorithms. These algorithms solve the integration of active cooling systems within the 3D IC using liquid channels by optimizing their placement in those areas where the temperature is higher. The second new algorithm can manage the optimization of FU and TSV in the 3D IC design with air channels, taking into account new placement restrictions in the model. Results show that the inclusion of isolation channels creates temperature regions, decreasing the energy overhead imposed by the active cooling system.This paper makes major contributions in the area of thermal optimization in 3D-integrated circuits. As compared with previous approaches, the work presented here achieves a practical and effective solution in the field of interest, outperforming the results obtained by these works. This paper also extends our previous work presented in [14] with the following major upgrades:•The proposal of a novel structure, called air isolation channels, as an effective mechanism for thermal isolation in 3D chips.The development of the required thermal models for these structures that enable their control by the optimization algorithm.The extension of the MFA algorithm presented in [14] with two new evolutionary algorithms, to consider the new design constraints and technologies, achieving better results in terms of thermal profile and fabrication costs.The rest of the paper is structured as follows: Section 2 describes both the thermal model and current implementation of MFA. Then, Section 3 continues with an explanation of the proposed optimizer. The experimental set-up used for our scenario is then described in Section 4 and finally, results and conclusions are presented in Sections 5 and 6, respectively.The equation governing heat diffusion via thermal conduction in a 3D stack is [15]:(1)ρc∂Tr→,t∂t=∇k(r→)∇T(r→,t)+p(r→,t)subject to the boundary condition(2)k(r→,t)∂T(r→,t)∂ni+hiT(r→,t)=fi(r→,t)Regarding Eq. (1), ρ is the material density, c is the mass heat capacity,T(r→,t)andk(r→)are the temperature and thermal conductivity of the material at positionr→and time t, andp(r→,t)is the power density of the heat source. With respect to Eq. (2), niis the outward direction normal to the boundary surface i, hiis the heat transfer coefficient and fiis an arbitrary function at the surface i.Numerical thermal analysis can be accomplished by applying a seven points finite difference discretization method to Eq. (1), which decomposes the 3D stack into numerous rectangular parallelepipeds of non-uniform sizes and shapes if necessary. In this way, each element has a power dissipation, temperature, thermal capacitance and thermal resistance to adjacent elements, which interact via heat diffusion. The discretized equation at an inner point of a grid element is:(3)ρcVTi,j,lq+1−Ti,j,lqΔt=−2(Rx+Ry+Rz)Ti,j,lq+RxTi−1,j,lq+RxTi+1,j,lq+RyTi,j−1,lq+RyTi,j+1,lq+RzTi,j,l−1q+RzTi,j,l+1q+Vpi,j,lwhere i, j and l are discrete offsets along the x, y and z axes, Δt is the discretization step in time t, Δx, Δy and Δz are discretization steps along the x, y and z axes, and V=ΔxΔyΔz. Finally, Rx, Ryand Rzare the thermal conductivities between adjacent elements, defined as follows: Rx=kΔyΔz/Δx, Ry=kΔxΔz/Δy, and Rz=kΔxΔy/Δz.For a 3D stack with N discretized elements, Eq. (3) can be summarized as follows:(4)CdT(t)dt+RT(t)=Pu(t)where the thermal capacitance matrix C is an N×N diagonal matrix, the thermal conductivity matrix R is an N×N sparse matrix, T(t) and P are N×1 temperature and power vectors, and u(t) is the unit step function.Eq. (4) can be characterized by a 3D resistance–capacitance (RC) model as the one presented in [16]. Voltage differences are analogous to temperature differences, and the electrical resistance is analogous to thermal resistance. The thermal modeling of the stack in Fig. 1 can be performed splitting the chip into small cubic unitary cells.Silicon and silicon dioxide cells are modeled with six thermal resistances and one thermal capacitance as it can be seen in Fig. 3a. Four of these resistances connect each cell to its lateral neighbors (those on the same layer), while the two remaining resistances connect the cell with the upper and bottom cell, respectively. The capacitance represents the heat storage inside the cell.Air channels also have a diffusive behavior. Despite the fact air is a fluid, the dimensions of the cavity and the absence of forced convection methods, make the fluid to behave as a diffusive material. We have considered channels fabricated and filled with low pressure air, which decreases thermal conductivity, making isolation much more efficient.Liquid channels are electrically modeled as it can be seen in Fig. 3b. This difference with the diffusive cell comes because, in cells circulating a coolant, the mechanism that dominates the heat transfer is the forced convection. This mechanism can be translated into our RC model using two voltage controlled current sources, as it is profusely covered in [17].Heat diffusion to the surrounding environment is also considered by the RC model. This diffusion occurs in the edge of the chip and in the top layer. Different chip packages and heat sinks can be integrated in Eq. (4) by tuning the capacitance and resistance parameters of the model. As the PCB base is considered to be adiabatic, no heat transfer occurs in the bottom direction of the first layer.The interface material that exists in between two silicon layers, used as a glue, is modeled as an epoxy layer, a pure resistant material. The existence of TSV is considered in the model, also as a resistance element.All these cell types are integrated in Eq. (4), which is solved using an iterative method (Forward Euler) to validate the results given by our 3D floorplanner. The main thermal properties of the material and dimensions used in the model are listed in Tables 1 and 2.MFA was first proposed by David Cuesta et al. [14]. This algorithm performs an incremental floorplanning divided in two phases. First, FUs are placed by running MFAFU. Secondly, MFATSV is executed, placing TSVs. These two processes are independent. Thus, MFAFU tends to obtain floorplans where the insertion of TSVs is not possible. In this section we describe all the algorithms implied in the design flow shown in Fig. 2, including these two sub-algorithms for self-content purposes. We also improve MFAFU to reach feasible solutions for the insertion of TSVs.MFAFU is a MOEA based on NSGA-II [18]. The foorplanner manages coded solutions that are gradually improved in the evolutionary process to provide configurations optimized both in performance and thermal response for the target architecture. To this end, MFAFU simultaneously minimizes the following three objectives:•F1: Number of topological constraints violated (overlapping between different blocks, or components out of the borders of the chip).F2: Wire length, approximated as the Manhattan distance between interconnected blocks C:(5)F2=∑i,j∈C:i<j|xi−xj|+|yi−yj|+|zi−zj|, where (xi, yi, zj) are the coordinates of FU i.F3: Maximum temperature of the chip. The computation of this objective depends on the chosen thermal model. In the case of MFAFU, the contribution to the maximum temperature of two FUs i, j is simplified as the cross product of their power densities pi, pjdivided by the corresponding Euclidean distance. Thus, having n FUs, F3 is defined as:(6)F3=∑i<j∈1…npi·pj(xi−xj)2+(yi−yj)2+(zi−zj)2By minimizing F3 the algorithm will try to place hottest blocks as far as possible. This process reduces maximum temperature, as it is demonstrated in [14].MFAFU can be classified as a hybrid foorplanning approach because the decoding heuristic implements an incremental foorplanning inspired in constructive techniques, while the MOEA on top of the heuristic is essentially iterative.We use a permutation encoding [19], in which every chromosome is a string of records representing the different FUs of the target architecture. These records gather information relative to a FU, namely label, width, and length. Managing the width and length of the blocks allows to perform rotations, granting further degrees of freedom to the optimization process. Additional characteristics of the FUs such as power densities, connections, etc. must be managed by the algorithm. However, this information does not need to be codified in the chromosomes as it is common to all the individuals. Fig. 4a depicts the representation of a chromosome used in MFAFU. The example shows a candidate solution (individual) of a platform composed of 8 FUs: 4 cores Ci(i=1, 2, 3, 4) and 4 memories Mi(i=1, 2, 3, 4). The order C3, M2, M4, C1, M1, C4, M3, C2 determines the placement sequence. Thus, C3 will be placed first, followed by M2, M4 and so on.All the chromosomes must have size n, where n is the number of FUs to be placed. Therefore, the cardinality of the considered solution space is n!. The operators designed according to the representation are depicted in Fig. 4 and briefly described below:•Selection: The selection operator implements a binary tournament strategy. To this end, random couples of individuals are formed and the best solution of each pair is selected for crossover.Crossover: A cycle crossover is used to produce the offspring, this operator must take into account that all the components must appear once and only once in the chromosome (see Fig. 4b).Mutation: The mutation of the solutions is performed in two ways. The first one consists in swapping the position of two blocks in the chromosome, resulting in a change of the placement sequence of the mutated individual. The effect of the second is the rotation of a FU (see Fig. 4c).Algorithm 1MFAFURequire: G is the number of generations. N is the population size.function main()P = initialize() {P is the first random population}evaluate(P) {P is evaluated}forg=1 toGdoPˆ=∅{New empty population}forn=1 toN/2 doPˆs= select(P) {Select two individuals,}Pˆc= crossover(Pˆs) {perform crossover...}Pˆm= mutation(Pˆc) {and mutation}Pˆ=Pˆ∪Pˆmend forevaluate(Pˆ)P=P∪Pˆreduce(P) {Standard NSGA-II reduction mechanism}end forfunction evaluate(P)for allI∈Pdofori=1 tondoBi←Ii{The i-th gene in individual I (Ii) represents the i-th block/functional unit (Bi) to be placed in the current 3D candidate design}fi*←∞,xi*←0,yi*←0,zi*←0{0≤li≤L,0≤wi≤Wand 0≤hi≤H are the length, width and height of block i, respectively}for all(xi∈[0..L−li],yi∈[0..W−wi],zi∈[0..H−hi])doF1i←checkTopologyConstraints(xi, yi, zi, i) {Number of topology constraints violated with the previous i−1 blocks already placed}ifF1i=0thenF2i←manhattan(xi, yi, zi, i) {This function computes wire length according to Manhattan distances between connected blocks in the range [1..i]}F3i←computeTemp(xi, yi, zi, i) {Compute (6) with i<j∈1..i}ifBiis a core thenfi←F3ielsefi←F2iend ififfi<fi*thenfi*←fixi*←xi,yi*←yi,zi*←ziend ifend ifend forBi←xi*,yi*,zi*{Assign best coordinates to each block}end forF1← checkTopologyConstraints() {Number of topology constraints violated in the current 3D IC}F2← manhattan() {Total wire length}F3← computeTemp() {Compute (6)}I←F1,F2,F3{Assign multi-objective values to each individual}end forAlgorithm 1 shows the implementation of MFAFU. As Fig. 2 indicates, the initial population is built from a list of components to be placed in the floorplan, along with their dimensions and interconnectivity. Each chromosome is defined just as a random sequence of these components (see Fig. 4a). A heuristic is in charge of the placement of the different elements of the architecture (decoding of the solutions). The heuristic performs an incremental floorplanning in which the components are sequentially placed in the 3D stack following the order implied by the solution encoding. In fact, as the exhaustive heuristic alone is capable of obtaining well performing solutions, the MOEA is designed to obtain the optimal order of the components given the placement heuristic. In this heuristic, every block i is placed considering all the topological constraints, the wire length, and the maximum temperature of the chip with respect to all the previously placed blocks j:j<i, named as(F1i,F2i,F3i). The best location for each block is selected depending on whether the block is a relative heat sink or a heat source. For a heat source (like a core, for example) the best position is the one with lowestF3ito ensure an even thermal distribution. If the block is a heat sink (like a memory) the best position is the one with lowest wire lengthF2i. With this procedure, the authors try to ensure a correct thermal optimization. This approach is highly reasonable in terms of thermal profile, since large 3D stacks with more than 48 cores reach prohibitive temperatures (more than 400K, as can be seen in [14]). Thus, every block is fixed in the remaining position (xi, yi, zi). Once the placement has finalized, the obtained configuration is evaluated according to the three defined objectives (F1, F2, F3). In order to help the algorithm to find feasible solutions, the multiobjective function can be transformed to (F1, (1+F1)·F2, (1+F1)·F3). Although the first objective can be removed in this case, we keep it to easily check if the algorithm is not able to find feasible solutions.As aforementioned, this algorithm is responsible of the placement of TSVs to allow vertical communications. As in MFAFU, MFATSV is based on NSGA-II. In the original version of MFA, this algorithm is the step executed immediately after MFAFU. Since TSVs insertion is not checked in the first algorithm, it could happen that MFATSV did not find a feasible distribution of TSVs. To solve this issue, we improve MFAFU in the next subsection. In the following, we describe the MFATSV algorithm.Technologically, and due to fabrication process constraints, TSVs can only be built from one specific layer to any other. In this regard, MFATSV considers the top layer as the initial one.To encode a solution, MFATSV examines the remaining free cells in the MFAFU resultant stack. Then, MFATSV builds an array of x–y coordinates where TSVs can be drilled, as the array of coordinates in Fig. 5shows. Given a 3D IC with N layers, a first region of this array contains the coordinates where a TSVs between layers Top and 1 can be built; a second region in the same array contains the coordinates where TSVs between layers Top and 2 can be built, and so forth. Next, a 0-1 chromosome of length equal to the array of coordinates is created. If a gene contains a 1, a TSV is inserted in the corresponding (x, y) position, between the layers that belong to the corresponding region. In this way, Fig. 5 encodes 7 TSVs in four layers (N=4): 1 TSV drilled between layers 4 and 1, 2 TSVs between layers 4 and 2, and 4 TSVs between layers 4 and 3. As a result, the initial population is a set of binary chromosomes randomly generated. The corresponding (x, y) coordinates are stored in a separate array of coordinates.Algorithm 2 shows a pseudocode for MFATSV. This algorithm returns a set of solutions, considering the number of TSVs F4 and the new total wire length F5. This set constitutes a Pareto front approximation, and the designer will have the chance to select the best solution in terms of economic cost and wire length reduction, considering that a minimum number of TSVs must be included in the design in order to fulfill the communication constraints. The minimum number of TSVs is calculated attending to the communication bandwidth needs of cores. We have calculated the data that is transferred by an FM modulation/demodulation application as the one explained in [3]. The minimum number of TSVs is given by the technological parameters of the TSVs and the volume of data to transfer [20].Algorithm 2MFATSVRequire: I is the current individual to be evaluated (see Fig. 5). C is the set of connections in the floorplan.function evaluate(I)F4←∑i=1 …NIi{Number of TSVs.}F5←0for all (Bi, Bj)∈Cdodz←|zi−zj|ifdz=0 thend← manhattan(xi, yi, xj, yj) {Manhattan distance between blocks i and j}F5←F5+delsed← findBestTsv(I, i, j) {This functions takes all the candidate TSVs in I and compute the Manhattan distance in the path block i → TSV → block j. At the end, it returns the best distance}F5←F5+dend ifend forI←F4,F5{Assign multi-objective values to this individual}In this section, we slightly modify MFAFU to obtain solutions where at least one TSV configuration can be reached by MFATSV. To this end, we present Algorithm 3. We only show the evaluation function because the main function is identical to MFAFU. The modification is performed including the R matrix. R contains all the free cells in the 3D stack. Thus, given a floorplan, it is quite easy to check if a TSV can be drilled to connect two blocks placed at different layers. If this is not possible,F2iis set to infinity.Algorithm 3MFAFU*Require:G is the number of generations. N is the population size.function evaluate(P)for allI∈PdoR←1 {Matrix L×W×H with free cells in the 3D-IC, i.e., where FUs can be placed}fori=1 tondoBi←Ii{The i-th gene in individual I (Ii) represents the i-th block (Bi) to be placed in the current 3D candidate design}fi*←∞,xi*←0,yi*←0,zi*←0for all(xi∈[0..L−li],yi∈[0..W−wi],zi∈[0..H−hi])doF1i←checkTopologyConstraints(xi, yi, zi, i) {Number of topology constraints violated with the previous i−1 blocks already placed}ifF1i=0thenF2i←manhattan(xi, yi, zi, i, R) {This function computes wire length according to Manhattan distances between connected blocks in the range [1…i]. It also asserts that a TSV can be created if two blocks are placed on different layers (it is easily computed using R)}F3i←computeTemp(xi, yi, zi, i) {Compute (6) with i<j∈1…i}ifBiis a core thenfi←F3ielsefi←F2iend ififfi<fi*thenfi*←fixi*←xi,yi*←yi,zi*←ziend ifend ifend forBi←xi*,yi*,zi*{Assign best coordinates to each block}update(R, Bi)end forF1← checkTopologyConstraints() {Number of topology constraints violated in the current 3D IC}F2← manhattan() {Total wire length}F3← computeTemp() {Compute (6)}I←F1,F2,F3{Assign multi-objective values to each individual}end forIn the following subsections we present two new subalgorithms of MFA, named MFALC and MFAAC. MFALC has been developed to place liquid channels in the 3D IC. MFAAC has been designed to divide the 3D stack into regions isolated by air channels. It is worth noting that the following two algorithms receive as input the resultant 3D IC obtained either by MFAFU or MFAFU*+MFATSV, as Fig. 2 shows.Once the 3D IC has been thermally optimized placing FUs or TSVs, we run our accurate thermal model in Eq. (4) to evaluate the temperatures in the chip, computing the temperature matrix T. TSVs have been already incorporated into this equation as a set of cells disposed vertically in the 3D IC. The temperature values and the floorplan information are the inputs to our proposed liquid channel optimizer, shown in Algorithm 4.Since liquid channels are placed right above FUs, the only topological constraint is the possible collision between liquid channels and TSVs. As was done for the placement of TSVs, a set of available (x, z) coordinates is built. The initial population is also a random set of binary chromosomes indicating the presence or not of a liquid channel at a given position. The evaluation function of MFALC takes into account the cooling effect of a liquid channel. In order to evaluate this cooling effect, several thermal simulations were conducted. Liquid channels are able to reduce temperature not only in the active cells under the channel, but also in their neighbors. This reduction follows a logarithmic tendency with the chip temperature that can be seen in Fig. 6. Introducing these data in the evaluation of our proposed evolutionary algorithm, we can find optimized solutions.The optimization of the number of microchannels in the design is a major constraint from the point of view of technological and operating costs. Adding liquid microchannels in the design implies not only fabrication costs but also additional energy for the pumping system, as shown in [21].Algorithm 4MFALCRequire: I is the current individual to be evaluated. T is the set of temperatures obtained with the thermal model.function evaluate(I)F6←∑i=1..NIi{Number of liquid channels.}F7←0Tˆ←Tfor allIi∈IdoifIi=1 then(xi, zi)←Ii{Every gene is referred to a concrete (xi, zi), where ziis the current layer for the i-th channel and xiits x coordinate}foryi=0 toW−1 doTˆ(xi,yi,zi)=342.46ln(Tˆ(xi,yi,zi))−1664.4Tˆ(xi−1,yi,zi)=321.28ln(Tˆ(xi−1,yi,zi))−1541.5Tˆ(xi−2,yi,zi)=293.60ln(Tˆ(xi−2,yi,zi))−1380.8Tˆ(xi+1,yi,zi)=321.28ln(Tˆ(xi+1,yi,zi))−1541.5Tˆ(xi+2,yi,zi)=293.60ln(Tˆ(xi+2,yi,zi))−1380.8end forend ifend forF7=∑xi,yi,ziTˆ((xi,yi,zi))I←F6,F7{Assign multi-objective values to this individual}Our proposal of creating thermal domains in a chip is a revolutionary method to keep heat concentrated in certain areas preventing, with air isolation channels, heat spread from hot to cold regions. If this design technique is combined with the deployment of liquid channels, better results in terms of energy saving and fabrication cost are obtained.Since the thermal conductivity of air is lower than the silicon, the channels can create thermal domains isolating regions with high temperatures from other areas of the 3D stack. With this set up a more homogeneous thermal distribution is obtained with a reduced investment in any other active cooling mechanisms. The creation of thermal domains implies a reduction in the number of liquid microchannels and consequently a reduction in fabrication and working costs.When the chip is isolated by air channels, the optimization placement process is guided. This process works like the one described before, but restricting certain areas of the chip to chosen FUs accordingly to their power consumption. Hot areas would be composed of FUs that have a high power density. On the other hand, elements with a lower power consumption will be placed, all together, in cold regions.The considered algorithm is the same that the one described in Algorithms 1 or 3, but different topological constraints are included in the checkTopologyConstraints function. Obviously, neither FUs nor TSVs can occupy cells previously designed as air channels. The initial population is generated as in MFAFU or MFAFU*. However, as Fig. 2 shows, feasible solutions obtained with these two algorithms could be incorporated as a starting point for the MFAAC optimization process.The definition of the topology is given by the designer and hence, is an input to the optimization system as shown in Fig. 2. After that, it is the designer who specifies where isolating air channels should be routed.Niagara2 and Niagara3 architectures are the base of our tests. This distribution has been modified to include 48 SPARC cores. These 48 cores have been distributed in four layers, composed of 8-core original Niagara2 in layers one and two and 16-core original Niagara3 in layers three and four. This scenario will be used in the following for all the optimizations and simulations and also to compare different optimization strategies.The floorplan has also been modified in order to include an increased number of cores which are placed in several layers of the 3D stack. Since MFA can place a variable number of cores in every layer, the power consumption of the crossbar is scaled accordingly to the number of cores found in every layer and their required bandwidth. The inter-layer communication is resolved with a set of TSVs that route the communication signals from one layer to another.Worst case scenario has been set for power consumption. In our two realistic floorplans, power consumption is set to 84W and 139W for Niagara2 and Niagara3 respectively [22].As has been shown in Section 3, MFAFU* will place the FUs that compose the 3D multi-processor architecture to minimize the temperature parameters. The area is set from the beginning of the optimization, and the original distribution of components defines the area of the optimization. The thermal results obtained by our floorplanner will be compared with the stacks composed by the two original layers, based on Niagara2 and Niagara3, presented in Fig. 7. These two layers are disposed in order to build a 48 core system. Niagara2 is placed in first and second layer, and Niagara3 is used for layers 3 and 4. The cores (C), memories (L2), shared memories (L2B) and crossbar (Crossbar) are disposed in 4 layers.Our experimental work will be focused on the analysis of the thermal optimization achieved by the floorplanner and the additional temperature reduction by the liquid cooling system. Additional modifications have been conducted. We have created two isolated thermal domains including air channels in the active layers. These channels isolate an area of the chip creating “hot islands” that will be then cooled with liquid channels. These air channels are placed at 5400μm for layers 1 and 3 from the left side of the chip, and the same distance for layers 2 and 4 from the right side. Heat sources will be placed by the floorplanner in these areas, whereas FUs with lower power density will be placed in the warm region.On the other hand, MFAs are configured with different parameters. Both MFAFU* and MFAAC are configured with a population of one hundred individuals and number of generations equal to the number of FUs, which prevents the algorithm from stacking in a local optimum. In both algorithms, crossover probability is set to 0.90 and the mutation probability is set to 1/number of FUs as recommended in [18].MFATSV and MFALC are configured with a maximum population of one hundred individuals, and a maximum number of 250 generations. The probability of mutation is set depending on the number of variables; in this particular case, it is the inverse of the number of available points to insert TSVs or liquid channels, respectively. Then, we set a single point crossover with a probability of 0.90 and the tournament selection method, following the guidelines given in [18].

@&#CONCLUSIONS@&#
This work proposes a novel and an effective optimization process that combines three different evolutionary algorithms to enhance our previous and related work in the field. In this sense, our algorithms are capable of optimizing the placement of functional units and TSVs, taking into account their thermal contribution to the entire 3D stack. The optimization in the placement reduces thermal metrics in 3D IC. The complete floorplanner is demonstrated to achieve excellent results when placing FUs and TSVs. These results are widely improved by adding other design solutions such as the use of active cooling, using liquid channels whose locations have been also optimized with our proposed evolutionary algorithms. The floorplanner interfaces with an accurate thermal model, which calculates the results in the minimization of thermal and reliability parameters.Experimental results have been obtained for a realistic many-core single-chip, resembling Niagara floorplan.The addition of air channels to isolate thermal domains in the chip is an important contribution presented in this paper. The isolation helps on the cooling process, because our liquid channels can be placed in those areas with higher temperatures. This strategy reduces the number of deployed liquid microchannels to achieve the same thermal profile. This reduction directly impacts on fabrication costs and on the energy designated for the pumping system. In other words, the creation of hot regions using air channels inside the chip has resulted in an improvement of the thermal parameters, saving technological and energy costs.