@&#MAIN-TITLE@&#
Branch-and-price-and-cut for the multiple traveling repairman problem with distance constraints

@&#HIGHLIGHTS@&#
Introduced a new TRP variant that considers multiple vehicles and distance constraint.Designed a tailored branch-and-price-and-cut algorithm for the problem.Proposed a bounded bi-directional label-setting algorithm for the pricing subproblem.Identified the best branch-and-price-and-cut implementation by extensive experiments.Produced benchmark results for future researchers of the problem.

@&#KEYPHRASES@&#
Branch-and-price,Branch-and-price-and-cut,Traveling repairmen problem,Distance constraint,

@&#ABSTRACT@&#
In this paper, we extend the multiple traveling repairman problem by considering a limitation on the total distance that a vehicle can travel; the resulting problem is called the multiple traveling repairmen problem with distance constraints (MTRPD). In the MTRPD, a fleet of identical vehicles is dispatched to serve a set of customers. Each vehicle that starts from and ends at the depot is not allowed to travel a distance longer than a predetermined limit and each customer must be visited exactly once. The objective is to minimize the total waiting time of all customers after the vehicles leave the depot. To optimally solve the MTRPD, we propose a new exact branch-and-price-and-cut algorithm, where the column generation pricing subproblem is a resource-constrained elementary shortest-path problem with cumulative costs. An ad hoc label-setting algorithm armed with bidirectional search strategy is developed to solve the pricing subproblem. Computational results show the effectiveness of the proposed method. The optimal solutions to 179 out of 180 test instances are reported in this paper. Our computational results serve as benchmarks for future researchers on the problem.

@&#INTRODUCTION@&#
The traveling repairman problem (TRP) has been extensively studied by a large number of researchers (e.g., Afrati, Cosmadakis, Papadimitrious, Papageorgiou, & Papakostantinou (1986), García, Jodrá, & Tejel (2002), and Salehipour, Sörensen, Goos, & Bräysy (2011)); this problem is also termed the minimum latency problem (Arora & Karakostas, 2003; Archer, Levin, & Williamson, 2008; Blum et al., 1994), the traveling deliveryman problem (Fischetti, Laporte, & Martello, 1993; Méndez-Díaz, Zabala, & Lucena, 2008; Minieka, 1989) and the cumulative traveling salesman problem (Bianco, Mingozzi, & Ricciardelli, 1993). The TRP is defined on a complete graph G=(V, E), where V={0,1,…,n,n+1} is the vertex set and E={(i, j): i, j∈V, i≠j, i≠n+1, j≠0} is the edge set. Vertices 0 and n+1 represent the exit from and the entrance to the depot, respectively. We denote the vertices representing the set of n customers by VC={1,…,n}. The repairman (henceforth referred to as vehicle) is assumed to travel at a constant speed. Each edge (i, j) has a non-negative length di,jand requires a non-negative traversing time ti,j, which is symmetric, i.e., ti,j=tj,i, and satisfies the triangle inequality rule. The objective of the TRP is to find a Hamiltonian tour on G, starting from vertex 0 and ending at vertex n+1, which minimizes∑i∈VCli, where lidenotes the waiting time of customer i after the vehicle leaves vertex 0. A direct generalization of the TRP is the multiple traveling repairman problem (MTRP) that considers K identical vehicles (Fakcharoenphol, Harrelson, & Rao, 2007). Applications of the TRP and MTRP can be found in routing pizza deliverymen, routing automated guided vehicles through cells in a flexible manufacturing system or scheduling machines to minimize mean flow time for jobs (Fischetti et al., 1993).This paper studies an extension of the MTRP by involving a distance constraint that the route length (or duration) of each vehicle cannot exceed a predetermined limit L. This type of constraint usually stems from regulations on working hours for workers or arises in the home delivery of perishable products. We call the resulting problem the multiple traveling repairman problem with distance constraints (MTRPD) whose objective is to find K routes such that each vertex is visited exactly once, the distance constraint is respected and the total waiting time of all customers is minimized. Examples of other vehicle routing models that incorporate the distance constraint can be found in Laporte, Nobert, and Desrochers (1985), Li, Simchi-Levi, and Desrochers (1992), and Erera, Morales, and Savelsbergh (2010).The MTRP can be viewed as a variant of the multiple traveling salesman problem (m-TSP) (Bektas, 2006; Svestka & Huckfeldt, 1973). Although many researchers have studied the TRP, the literature on the MTRP is surprisingly limited. The only prior study we can find in existing literature is Fakcharoenphol et al. (2007). They presented a polynomial-time 8.497γ-approximation algorithm for the MTRP, where γ denotes the best polynomial-time approximation factor possible for the k minimum spanning tree (k-MST) problem (Arora & Karakostas, 2006).Apart from the MTRPD, there exist several other extensions of the MTRP in the literature. Bennett and Gazis (1972) introduced a school bus routing problem (SBRP) in which a fleet of school buses is dispatched to take pupils from pick-up points to school. Each bus has a fixed capacity and each pick-up point has a given demand, represented by the number of pupils. The objective of this problem is to minimize the weighted sum of the total bus travel time and the total pupil travel time. Li and Fu (2002) described a case study of routing school bus for Hong Kong kindergartens. They formulated the problem as a multi-objective combinatorial optimization problem with four types of objectives, which are prioritized in the following order: (1) minimize the total number of buses required; (2) minimize the total travel time spent by all pupils; (3) minimize the total bus travel time; and (4) balance the loads and travel times among all buses. For an overview of the SBRP, we refer the reader to Park and Kim (2010).In the SBRP, it is obvious that the demand at each pick-up point must be integer. When the vertex demand is allowed to be a real number, the resulting problem is called the cumulative vehicle routing problem (CumVRP) (Kara, Kara, & Yetiş, 2008; Ngueveu, Prins, & Wolfler Calvo, 2010; Ribeiro & Laporte, 2012). The CumVRP is the same as the classical capacitated vehicle routing problem (CVRP) (Toth & Vigo, 2002) except that the cost of traversing an edge is the product of length and flow of the edge. It has been shown that the MTRP is a special case of the delivery formulation of the CumVRP; we refer the reader to Kara et al. (2008) for details of the proof. The CumVRP can be further regarded as a special case of the weighted vehicle routing problem (WVRP) proposed by Zhang, Tang, Pan, and Yuan (2010). The total cost to be minimized in the WVRP consists of three components: (1) the fixed cost of dispatching a vehicle; (2) the cost per unit travel distance; and (3) the constant surcharge per unit weight per unit distance. Later, the WVRP was extended to include multiple depots by Zhang, Tang, and Fung (2011).When the surcharge per unit weight per unit distance is a function of the vehicle weight, the WVRP is generalized to the vehicle routing problem with toll-by-weight scheme (VRPTBW) (Shen, Qin, & Lim, 2009; Zhang, Qin, Zhu, & Lim, 2012). To date, over twenty-five Chinese provinces have implemented the toll-by-weight schemes, all of which are monotonically increasing functions of the vehicle weight. Denoting by the decision variable wi,jthe weight of the vehicle traversing edge (i, j) and assuming the surcharge per unit distance is calculated based on a toll function f(wi,j), the objective of the VRPTBW is to minimize∑i∈V∑j∈Vdi,jf(wi,j). Consider the case where the toll function has the following form:f(wi,j)=0ifwi,j=0αwi,j+βifwi,j>0where α and β are non-negative parameters. If α=0 and β=1, then VRPTBW reduces to the classical CVRP problem. If α=1 and β=0, then VRPTBW reduces to the CumVRP. If α>0 and β=0, then∑i∈V∑j∈Vdi,jf(wi,j)can be written as∑i∈V∑j∈Vαdi,jwi,j, which is actually the third cost component of the WVRP (Zhang et al., 2010).The workover rig routing problem (WRRP) introduced by Aloise et al. (2006) is another variant of the MTRP. In the WRRP, a set of onshore oil wells needs maintenance service from a fleet of heterogeneous workover rigs. For each well, its production loss equals the product of the production loss rate and the time at which its required service is completed. The objective of this problem is to find a route for each workover rig such that the total production loss of the wells over a finite horizon is minimized. In recent years, the WRRP has also been studied by several other researchers, such as Pacheco, Ribeiro, and Mauri (2010), Ribeiro, Laporte, and Mauri (2012), and Ribeiro, Desaulniers, and Desrosiers (2012).After reviewing prior studies with regard to the MTRP and its variants, we find that almost all relative articles except Ribeiro, Desaulniers, et al. (2012) proposed near-optimal algorithms, such as approximation algorithm (Fakcharoenphol et al., 2007), heuristics (Bennett & Gazis, 1972; Li & Fu, 2002), scatter search algorithms (Zhang et al., 2010, 2011), simulated annealing algorithm (Shen et al., 2009) and variable neighborhood search (Aloise et al., 2006). In Ribeiro, Desaulniers, et al. (2012), the authors proposed a branch-and-price-and-cut algorithm for the WRRP, where their column generation pricing subproblem was solved by a mono-directional label-setting algorithm.In this paper, we provide an exact branch-and-price-and-cut algorithm for the MTRPD. The pricing subproblem of the MTRPD is called the resource-constrained elementary shortest path problem with cumulative costs. Although label-setting algorithms have been successfully applied to similar pricing subproblems in several previous articles, e.g., Ribeiro, Desaulniers, et al. (2012) and Ioachim et al. (1998), our work is the first attempt to develop bounded bidirectional label-setting algorithm for solving it. To the best of our knowledge, branch-and-price-and-cut method is the most successful exact algorithm for the vehicle routing models (Baldacci, Christofides, & Mingozzi, 2008; Fukasawa et al., 2006), such as the vehicle routing problem with time windows (VRPTW) (Desaulniers, Lessard, & Hadjar, 2008; Jepsen, Petersen, Spoorendonk, & Pisinger, 2008), the split delivery VRPTW (Archetti, Bouchard, & Desaulniers, 2011; Desaulniers, 2010), the capacitated location-routing problem (Contardo, Cordeau, & Gendron, 2011), the heterogeneous fleet vehicle routing problem (Pessoa, Uchoa, & de Aragão, 2009) and the pickup and delivery problem with time windows (Ropke & Cordeau, 2009).The remainder of the paper is structured as follows. Section 2 presents an arc-flow formulation and a set-covering formulation for the MTRPD. This is followed in Section 3 with a description of column generation, consisting of the pricing subproblem, the label-setting algorithm for solving the pricing subproblem and three acceleration strategies. Subsequently, we present other main components of the branch-and-price-and-cut algorithm in Section 4. Our experimental results are given in Section 5, and we conclude our paper in Section 6 with some closing remarks.The arc-flow formulation of the MTRPD uses two types of decision variables: a binary decision variable xi,j,kthat equals 1 if vehicle k directly travels from vertex i to vertex j, and 0 otherwise; and a non-negative variable yi,kthat represents the time at which vehicle k arrives at vertex i. We denote by V+(i)={j∈V∣(i, j)∈E} and V−(i)={j∈V∣(j, i)∈E} the immediate successors and predecessors of vertex i in G. Letting F be the set of K vehicles and M be a sufficiently large positive number, the arc-flow formulation is given as:(1)z=min∑k∈F∑i∈VCyi,k(2)s.t.∑k∈F∑j∈V+(i)xi,j,k=1,∀i∈VC(3)∑j∈V+(0)x0,j,k=1,∀k∈F(4)∑j∈V+(i)xi,j,k=∑j∈V-(i)xj,i,k,∀k∈F,i∈VC(5)∑i∈V-(n+1)xi,n+1,k=1,∀k∈F(6)yj,k⩾yi,k+ti,j+M(xi,j,k-1),∀k∈F,(i,j)∈E(7)∑k∈F∑(i,j)∈E:i∈V⧹S,j∈Sxi,j,k⩾1,∀S⊂VC(8)0⩽yi,k⩽L,∀k∈F,i∈Vxi,j,k∈{0,1},∀k∈F,(i,j)∈EThe objective function (1) aims at minimizing the total waiting time of all customers. Constraints (2) ensure that each customer must be visited exactly once. Constraints (3) and (5) guarantee that each vehicle starts from vertex 0 and ends at vertex n+1. Constraints (4) are the flow conservation constraints. The relationship between the arrival times at two consecutive vertices visited by the same vehicle should satisfy Constraints (6) and each arrival time is restricted within interval [0, L] by Constraints (8). Constraints (7) are subtour elimination (SE) cuts that are redundant but can tighten the linear relaxation of the formulation. If we remove Constraints (7), the remaining formulation can be directly handled by some commercial integer programming solvers, e.g., ILOG CPLEX.After conducting some preliminary experiments, we find that the size of the instances optimally solved by CPLEX is quite limited. To achieve optimal solutions for instances of practical size, we reformulate the problem as a set-covering model through Dantzig–Wolfe decomposition and develop an exact branch-and-price-and-cut algorithm to solve it. Let Ω be the set of all feasible routes for the vehicles. A route r∈Ω can be written as r=(v0,v1,…,v∣r∣,v∣r∣+1), where ∣r∣ is the number of vertices covered by route r, v0=0 and v∣r∣+1=n+1. The cost of route r is known in advance by:cr=∑i=1|r|∑j=0j=i-1tj,j+1We denote by parameters ai,rand bi,j, rthe number of times route r visits customer i∈VCand the number of times route r traverses edge (i, j), respectively. In our problem, each customer can be visited exactly once, so parameters ai,rand bi,j, rmust be binary. If the routes containing cycles are allowed, these parameters can take integers greater than one. Moreover, for each route r∈Ω we define a binary variable θrwhich takes one if this route is selected in the solution, and zero otherwise. Obviously, each θrcorresponds to a column ar=(a1,r,…,an,r). For the sake of brevity, we further define θ to be a vector variable that contains all θr. With the above notations, the set-covering formulation is as follows:(9)z=min∑r∈Ωcrθr(10)s.t.∑r∈Ωai,rθr⩾1,∀i∈VC(11)∑r∈Ωθr⩽K(12)θr∈{0,1},∀r∈ΩThe objective function (9) minimizes the total cost of the selected routes. Constrains (10) ensure that every customer is visited at least once, which enlarges the feasible region of the original problem by allowing each customer to be visited more than once. However, the optimal solutions of the modified problem must be the same as those of the original problem if the triangle inequality rule is satisfied. In other words, the optimal solutions of the set-covering formulation would not visit any customer more than once. Since only K vehicles are available, Constraint (11) applies. Like Constraints (7) in the arc-flow formulation, we can also incorporate the SE cuts to tighten the set-covering formulation, which has the following form:(13)∑(i,j)∈E:i∈V⧹S,j∈S∑r∈Ωbi,j,rθr⩾1,∀S⊂VCIn practice, even for a small-size instance, model (9)–(13) contains a huge number of variables (i.e., columns) and SE cuts, which cannot be written out explicitly. Hence, this model cannot be directly handled by CPLEX. Our proposed branch-and-price-and-cut algorithm is not required to enumerate all columns but generate new columns as needed. Moreover, we relax all SE cuts at the beginning of the algorithm, and add some of them into the model over the course of the branch-and-bound search process. The branch-and-price-and-cut algorithm uses a branch-and-bound framework, where at each search tree node column generation is applied to compute a lower bound and SE cuts are dynamically added to further improve the lower bound.In the remaining paper, we distinguish between the terms node and vertex, which are usually considered the same and are used interchangeably in standard graph terminology; we specify that node refers to the branch-and-bound search tree node, while vertex refers to the vertex in graph G.Column generation (Desaulniers, Desrosiers, & Solomon, 2005) is applied to solve the linear relaxation of the model (9)–(12) augmented by appropriate branching decisions and SE cuts, which is called the linear master problem (LMP). The optimal solution value of the LMP is a lower bound of its associated branch-and-bound node. Column generation cannot directly solve the LMP due to its inability to enumerate all columns. Instead, it is an iterative procedure that alternates between solving a restricted linear master problem (RLMP) and a pricing subproblem. The RLMP is the LMP restricted to a subsetΩ¯⊆Ωof columns, which can be optimally solved by simplex method. The goal of solving the pricing subproblem is to identify the columns inΩ⧹Ω¯that have negative reduced costs with respect to the dual optimal solution of the current RLMP. If no such column is found, we terminate the column generation procedure with an optimal solution of the LMP, which equals the optimal solution of the current RLMP. Otherwise, we incorporate the identified negative reduced cost columns into the current RLMP and restart the column generation iteration.In this section, we focus on describing the column generation procedure applied to the LMP at the root branch-and-bound node, which does not involve branching constraints. We first present the pricing subproblem and then describe a basic (mono-directional search) label-setting algorithm to optimally solve it. Subsequently, we detail four strategies to accelerate the column generation procedure, which are tabu search column generator, bounded bidirectional search, state space relaxation and decremental state-space relaxation. The LMPs at other branch-and-bound nodes can be solved using this column generation procedure with minor modifications, which is elaborated in Section 4.4.At each branch-and-bound node, the column generation procedure and the cut separation algorithm are performed alternatively. The cut separation algorithm is invoked immediately after the column generation procedure. Once new SE cuts are added into the RLMP, the column generation procedure is restarted to solve the modified RLMP. We assume that at the root node some columns and SE cuts have already been added into the RLMP, which therefore has the following form:(14)zRLMP=min∑r∈Ω¯crθr(15)s.t.∑r∈Ω¯ai,rθr⩾1,∀i∈VC(16)∑r∈Ω¯θr⩽K(17)∑(i,j)∈E:i∈V⧹S,j∈S∑r∈Ω¯bi,j,rθr⩾1,∀S∈Γ(18)0⩽θr⩽1,∀r∈Ω¯where each element in set Γ is a subset of VC, representing an individual SE cut.We check whether the solution of the LMP reaches optimality by solving the pricing subproblem. Below we will use π=(π1,…,πn), μ andλ=(λS1,…,λS|Γ|)as the dual variables associated with Constraints (15)–(17), respectively. Assuming that (πˆ,μˆ,λˆ) is the dual optimal solution of the current RLMP, the reduced costc¯rassociated with route r∈Ω is calculated by:(19)c¯r=cr-∑i∈VCπˆiai,r-μˆ+∑S∈ΓλˆS∑(i,j)∈E:i∈V⧹S,j∈Sbi,j,rBased on the above expression, we can formulate the pricing subproblem as follows:(20)zPS=min∑i∈VCyi-πˆi∑j∈V+(i)xi,j-∑S∈Γ∑(i,j)∈E:i∈V⧹S,j∈SλˆSxi,j+μˆ(21)s.t.∑j∈V+(0)x0,j=1(22)∑i∈V-(n+1)xi,n+1=1(23)∑j∈V+(i)xi,j=∑j∈V-(i)xj,i⩽1,∀i∈VC(24)yj⩾yi+ti,j+(xi,j-1)M,∀(i,j)∈E(25)0⩽yi⩽L,∀i∈V(26)xi,j∈{0,1},∀(i,j)∈Ewhere variable yidenotes the arrival time at vertex i and variable xi,jrepresents the number of times edge (i, j) is traversed. The objective function (20) aims to achieve the minimal reduced cost of all feasible routes. The reduced cost consists of three parts: (1) the arrival time yiof each visited customer, (2) the prize-πˆiat each visited customer; and (3) the prizes associated with some edges traversed by the route. Constraints (21) and (22) require that the route must start from vertex 0 and end at vertex n+1. Constraints (23) ensure that each customer can be visited at most once. Constraints (24) define the relationship between the arrival times of two consecutively visited vertices. The length of the route is restricted to be less than or equal to L by Constraints (25). Solving the pricing subproblem is essentially equivalent to enumerating all feasible routes in Ω. This pricing subproblem has been shown to beNP-complete in Appendix A, implying that optimally solving its instances is computationally expensive.In many articles that proposed branch-and-price algorithms for solving the vehicle routing models, the pricing subproblems are usually the elementary shortest path problem with resource constraints (ESPPRC) (Feillet, Dejax, Gendreau, & Gueguen, 2004). A path is called elementary if each vertex is visited at most once. Examples of the ESPPRC can be found in Desrochers, Desrosiers, and Solomon (1992), Gutiérrez-Jarpa, Desaulniers, Laporte, and Marianov (2010) and Azi, Gendreau, and Potvin (2010). Our pricing subproblem is different from the traditional ESPPRC since it considers a cumulative cost yiat each visited customer i. It is a special case of the pricing subproblem of the WRRP Ribeiro, Desaulniers, et al. (2012). Moreover, its version that allows the routes with cycles can be regarded as a special case of the shortest path problem with time windows and time costs (SPPTWTC) introduced by Ioachim, Gélinas, Soumis, and Desrosiers (1998). Both the SPPTWTC and the pricing subproblem of the WRRP have been solved by mono-directional label-setting algorithms. However, we do not find previous articles that applied the label-setting algorithms armed with bidirectional search strategy to solve them or similar problems.In Ribeiro, Desaulniers, et al. (2012), the authors claimed that the bidirectional search strategy cannot be applied to the pricing subproblem of the WRRP. We cannot make a conclusion on whether there exists a bidirectional label-setting algorithm for their pricing subproblem. However, after carefully analyzing the structure of our pricing subproblem, we find that it can still be solved by a tailored bounded bidirectional label-setting algorithm, which will be detailed in this section.We optimally solve the pricing subproblem using a label-setting algorithm, which has been applied to the ESPPRC (Feillet et al., 2004; Righini & Salani, 2008) and the shortest path problem with resource constraints (SPPRC) (Irnich & Desaulniers, 2005). The aim of solving the pricing subproblem is to identify the negative reduced cost columns. In our label-setting algorithm, a multi-dimensional label Si= (Ci,Li,Vi,1,…,Vi,n) is defined to represent a state associated with a partial route from vertex 0 to vertex i, where:•Ciis the reduced cost of this partial route;Liis the amount of distance the vehicle has traveled;Vi,k(1⩽k⩽n) is a dummy resource indicating whether customer k has already been visited.At vertex 0, the values of L0 and all V0,k(1⩽k⩽n) are initialized to zero and the value of C0 is set toμˆ. The value of Vi,kwould be set to one when vertex k either is covered by the route or cannot be visited in any extension due to the distance constraint. Each vertex may have multiple labels and the optimal solution of the pricing subproblem can be achieved by identifying the minimum-cost label at vertex n+1. Note that labels do not contain any information regarding the order in which the vertices have been visited.A label Si=(Ci,Li,Vi,1,…,Vi,n) can be extended to vertex j∈V+(i), generating a new label Sj=(Cj,Lj,Vj,1,…,Vj,n). We first identify all vertices j that cannot be reached from Si, namely Li+ti,j>L, and accordingly set Vi,j=1. For the remaining vertices in V+(i), the labels Sjare created according to the following extension functions:Lj=Li+ti,jCj=Ci+Lj-πˆj-∑S∈Γ:i∈V⧹S,j∈SλˆSVj,k=Vi,k+1,ifk=jVi,k,ifk≠jwhere we setπˆ0=πˆn+1=0since each route must start from vertex 0 and end at vertex n+1. In the course of the label-setting algorithm, we cyclically examine all vertices, at each of which all labels that do not have successors would be extended.Extending a label at vertex i may create as many new labels as the number of its successors. Undoubtedly, the number of labels would increase exponentially with the extension of the labels. To avoid enumerating all labels, a dominance rule is employed in our label-setting algorithm to identify and eliminate the dominated labels. Given two labels SiandS‾i,S‾iis dominated by Siand thus can be safely discarded ifCi⩽C‾i,Li⩽L‾i,Vi,k⩽V‾i,kfor all 1⩽k⩽n, and at least one of the above inequalities is strict. We arbitrarily discard one of two identical labels.We have implemented the following four techniques to speed up the column generation procedure.The tabu search algorithm (Glover & Laguna, 1998) we develop for solving the pricing subproblem is similar to the one proposed by Desaulniers et al. (2008). We run the tabu search algorithm multiple times with different initial routes, derived from the basic variables in the optimal solution of the current RLMP. Three local search operators are used: (1) inserting a vertex into the current route, (2) removing a vertex from the current route, and (3) swapping two vertices, one visited by the route and the other unvisited. Each operator corresponds to a neighborhood of the current route and only the neighbors satisfying the distance constraint are retained. The tabu search algorithm keeps a tabu list to prevent the search process from being trapped in local optima. Moves specified by the tabu list are not allowed for ξ iterations, where ξ is a controlling parameter.The tabu search process iteratively proceeds to the best allowable neighbor (i.e., the neighbor with the least reduced cost) of the current route until the number of iterations exceeds maxIter. We terminate the tabu search algorithm when either all initial solutions have been used up or maxCol routes with negative reduced cost have been obtained. The tabu search stage is able to rapidly identify high quality solutions to the pricing subproblem, whereas we cannot prove whether these solutions are optimal or not. As a result, when the tabu search algorithm fails to identify a negative reduced cost route, we still need to invoke the exact label-setting algorithm.The bounded bidirectional search strategy is a useful technique for accelerating the label-setting algorithm (Righini & Salani, 2006, 2008); the resulting algorithm is called the bounded bidirectional label-setting algorithm (BBLS). In the BBLS algorithm, partial routes are originated from both vertices 0 and n+1, and accordingly associated labels are called forward labelsSifwand backward labelsSjbw. Moreover, each forward (resp. backward) partial route can be extended only if its length is less than L/2, i.e.,Lifw<L/2(resp.Ljbw<L/2). At vertex 0, we setC0fw=μˆ/2,L0fw=0andV0,kfw=0for all 1⩽k⩽n. The extension functions and dominance rule on forward labelsSifw=(Cifw,Lifw,Vi,1fw,…,Vi,nfw,Vi,n+1fw)have been described in Section 3.2. Hereafter, we describe the extension functions and dominance rule for backward labels.We use a labelSjbw=(Cjbw,Ljbw,Djbw,Vj,1bw,…,Vj,nbw)to represent a state in backward extension. TheVj,kbwassociated with all unreachable vertices k from vertex j are set to 1. Compared with the forward label, the backward label has an extra elementDjbwthat denotes the number of customers the backward partial route has visited upon arrival at vertex j. The value ofCn+1bwis set toμˆ/2and the values ofLn+1bw,Dn+1bwandVn+1,kbwfor all 1⩽k⩽n are set to zero. Fig. 1pictorially shows the forward and backward extensions. When the backward label is extended from vertex j to vertex j+1, the waiting time ljof vertex j equals the waiting time lj+1 of vertex j+1 plus tj+1,j. However, we are not able to know the actual waiting time of each vertex on the backward partial route unless the complete route is achieved. Consequently, we can only say that the waiting time of vertex j is at least tj+1,j. When the label is further extended to vertex j+2, the waiting time of vertex j would become lj+2+tj+2,j+1+tj+1,j, and the waiting time of vertex j+1 is lj+2+tj+2,j+1; thus, the total waiting time should be at least 2tj+2,j+1+tj+1,j. Based on the above observations, whenLjbw+ti,j⩽L, we derive the functions for the backward extension from vertex j to vertex i as:Cibw=Cjbw+Djbwti,j-πˆi-∑S∈Γ:i∈V⧹S,j∈SλˆSLibw=Ljbw+ti,jDibw=Djbw+1Vi,kbw=Vj,kbw+1,ifk=iVj,kbw,ifk≠iThe costCjbwof the backward partial route counts in the already known minimum waiting times rather than the actual waiting times of all visited customers. LabelSjbwdominates labelS‾jbwifCjbw⩽C‾jbw,Ljbw⩽L‾jbw,Djbw⩽D‾jbw,Vi,kbw⩽V‾i,kbwfor all 1⩽k⩽n and at least one of these inequalities is strict. We also arbitrarily discard one of two identical backward labels.A forward labelSpfw=(Cpfw,Lpfw,Vp,1fw,…,Vp,nfw)and a backward labelSqbw=(Cqbw,Lqbw,Dqbw,Vq,1bw,…,Vq,nbw)can be joined together to form a complete feasible route if both of the following conditions hold:Lpfw+Lqbw+tp,q⩽LVp,kfw+Vq,kbw⩽1,∀1⩽k⩽nWhen a backward labelSqbwis concatenated to a forward labelSqfw, the waiting time at each ofDqbwcustomers visited by the backward partial route must increase byLqfw+tp,q. Hence, the cost of the resulting complete route is:Cpfw+Cqbw+Dqbw×(Lqfw+tp,q)-∑S∈Γ:p∈V⧹S,q∈SλˆSThe minimum cost among all complete routes is the optimal solution value of the pricing subproblem. Usually, the BBLS algorithm can find a number of negative reduced cost columns and therefore we specify that at most maxCol columns can be added intoΩ¯.Another common way to accelerate the label-setting algorithm is to relax the elementarity requirements of all vertices, which was first introduced by Christofides, Mingozzi, and Toth (1981) under the name state space relaxation. If vertices are allowed to be visited more than once, optimally solving the pricing subproblem can be done in pseudo-polynomial time and therefore requires less computation time. However, with state space relaxation the label-setting algorithm may generate some columns with cycles, which are infeasible to the original problem. When Ω is redefined to include routes with cycles, the resultant LMP would have an optimal objective value not greater than that of the original LMP, i.e., the lower bound at each branch-and-bound node may be weakened. Allowing routes with cycles may increase the computational burdens on the branch-and-price-and-cut algorithm because the weaker lower bound reduces the efficiency of fathoming nodes, increasing the number of the branch-and-bound tree nodes. Briefly speaking, there is a tradeoff between the computation speed of the pricing subproblem and the scale of the branch-and-bound tree.In the BBLS algorithm with state space relaxation, forward and backward labels are defined asSifw=(Cifw,Lifw)andSjbw=(Cjbw,Ljbw,Djbw), respectively. The manners employed to extend labels, judge dominance relationships and join labels are the same as those described in Section 3.3.2 except that all Vj,k(1⩽k⩽n) are not considered any more.The decremental search state-space relaxation was introduced independently by Boland, Dethridge, and Dumitrescu (2006) and Righini and Salani (2008). It starts from solving the pricing subproblem with the elementary requirements of all customers being relaxed, i.e., each customer can be visited more than once in a route. If the computed least-cost path is nonelementary, the customers that are visited more than once are required to be elementary and the pricing subproblem is solved again. This process is repeated until an elementary least-cost route is found. Our implementation of the decremental state-space relaxation technique is the same as the one described in Righini and Salani (2008). This acceleration technique has also been employed in the branch-and-price algorithms for solving several other vehicle routing models, such as the VRP with discrete split deliveries and time windows (Salani & Vacca, 2011), the VRP with deliveries, selective pickups and time windows (Gutiérrez-Jarpa et al., 2010) and the multi-depot VRPTW (Bettinelli, Ceselli, & Righini, 2011).In this section, we first describe an approach for generating a set of initial columns and an upper bound for the problem. Next, we present a separation algorithm to identify the violated SE cuts. This is followed by search and branching strategies that guide the exploration of the branch-and-bound tree.We obtain a set of initial columns and an upper bound for the problem from a feasible solution produced by a cheapest insertion (CI) heuristic. The upper bound is updated over the course of the branch-and-bound search process.A state in the CI heuristic is a feasible partial solution consisting of unvisited vertices and a set of feasible routes, one of which is designated as the current route. The CI heuristic begins with an empty route as the current route. We repeatedly insert into the current route the best unvisited vertex in terms of increased cost. When no further vertex can be inserted without violating the distance constraint, we continue with another empty route. The above process is repeated until all vertices are inserted.To identify the violated SE cuts, we apply the polynomial-time separation algorithm introduced by Kohl, Desrosiers, Madsen, Solomon, and Soumis (1999); this algorithm is reviewed as follows. Assuming thatθˆis an optimal solution of the LMP, the flow on each edge (i, j) can be calculated according toxˆi,j=∑r∈Ω¯bi,j,rθˆr. To check whether there exist some violated SE cuts, we consider the graph G and impose a capacityxˆi,jon edge (i, j). For each vertex i∈VC, we solve a minimum cut problem with source vertex 0 and sink vertex i on graph G. Let Smindenote the vertex set that contains vertex i and is separated by the minimum cut. If the total capacity of the minimum cut is less than one, namely∑(i,j)∈E:i∈V⧹Smin,j∈Sminxˆi,j<1, then the SE cut corresponding to Sminis violated, which is thereupon added into the RLMP (i.e., add Smininto Γ); otherwise, all SE cuts are satisfied. Finding a minimum cut in a directed graph is equivalent to solving a maximum flow problem (Ahuja, Magnanti, & Orlin, 1993), which can be done in polynomial time.The branch-and-bound tree is explored according to a best-first policy; specifically, the “best” unexamined tree node is the one with the smallest lower bound, and would be given the highest priority. We have tested the depth-first policy in some preliminary experiments and obtained inferior results in terms of the number of the optimally solved instances within the same amount of computation time.At each branch-and-bound node, we achieve an optimal solution of the LMP using the column generation procedure and the separation algorithm; the value of this solution is a lower bound at that node. If this lower bound is not less than the current upper bound, the associated node is pruned; otherwise, branching must take place. If the optimal solution of the LMP is integral and the optimal solution value is less than the current upper bound, we update the upper bound. The integral optimal solution of the LMP must contain only acyclic routes even if routes with cycles are allowed. This is because we can always find acyclic routes to replace the routes with cycles in an integral feasible solution and generate another integral feasible solution with less objective value. However, it should be noted that the fractional optimal solution of the LMP may include routes with cycles if they are allowed.As explained in Desaulniers et al. (1998), we can hardly branch on master problem variables θrsince fixing such variables at 0 requires preventing label-setting algorithms from generating the corresponding routes, which significantly increases the complexity of solving the pricing subproblem. Therefore, it is better to choose branching strategies compatible with the algorithms for the pricing subproblems, i.e., the pricing subproblems at the nodes resulting from such branchings could be solved in a way similar to the one used at their parent node. This requires that branching constraints do not change the structure of the pricing subproblem. In our branch-and-price-and-cut algorithm, we choose two branching strategies, namely branching on the number of vehicles and on arcs.Branching on the number of vehicles. The number of vehicles used in the optimal solution of the LMP can be calculated bym′=∑r∈Ω¯θr. If this value is fractional, we branch the current node into two child nodes with constraints∑r∈Ω¯θr⩽⌊m′⌋and∑r∈Ω¯θr⩾⌈m′⌉, respectively. The pricing subproblems at these two child nodes have the same structure as that at their parent node.Branching on arcs. We next branch on the edge (i, j) with fractional flowxˆi,jthat is farthest to an integer. Two child nodes are created by fixing xi,j=1, implying that edge (i, j) must be used, and xi,j=0, implying that edge (i, j) is forbidden. In the former case, we delete from E all edges (i, j′) and (i′, j) with j′≠j and i′≠i, and remove from the RLMP all variables θrand columns associated with routes that contain at least one of the above deleted edges. In the latter case, we delete edge (i, j) from E and remove from the RLMP all variables θrand columns associated with routes that contain edge (i, j). Obviously, this type of branching only alters the structure of the underlying graph and removes some of variables from the RLMP, which does not require to modify the label-setting algorithm when solving the pricing subproblems at the child nodes.We implemented two column generation procedures; the first one is called CG1 that employs the tabu search column generator and the BBLS algorithm with decremental state-space relaxation, and the second one is called CG2 that only employs the BBLS algorithm with state space relaxation. Specifically, CG1 invokes the BBLS algorithm only when the tabu search algorithm fails to identify negative reduced cost columns. In this section, we only report and analyze the results of two branch-and-price-and-cut implementations that employs CG1 and CG2, which are called BPC1 and BPC2, respectively. Both of the BPC1 and BPC2 outperform the branch-and-price-and-cut implement that utilizes the BBLS algorithm without using any accelerating strategy.We conducted experiments on a data set derived from six TSP instances fnl4461, brd14051, d15112, d18512, nrw1379 and pr1002 of TSPLIB (Reinelt, 1991). For each of these TSP instances, ten subsets of n+1 vertices were randomly selected, where n=29, 39 and 49. One arbitrary vertex was designated as the depot. Each instance group is identified by the name of its TSP instance and the number of vertices; for example, instance group brd14051-30 contains ten 30-vertex instances generated from TSP instance brd14051. We denote bydmax=maxi∈VC{d0,i+di,n+1}the greatest distance for any route involving a single customer and imposed on each vehicle a travel distance limit L=2.0×dmax. Next, we performed the CI heuristic to construct an initial solution for each vertex set and recorded the number of used vehicles as Kini. Finally, we set the number of available vehicles to K=max{Kini, ⌈n/5⌉}, thereby generating 180 test instances. All instances as well as detailed solutions are available in the online supplement to this paper at: www.computational-logistics.org/orlib/mtrpd.All algorithms were coded in Java and all experiments were conducted on a Dell server with an Intel Xeon E5520 2.26gigahertz CPU, 8gigabytes RAM and Linux operating system. The linear programming model RLMP was solved by simplex algorithm implemented by ILOG CPLEX 12.0. Computation times reported are in CPU seconds on this server.We imposed a time limit of 10,800seconds on each run of the branch-and-price-and-cut algorithm. The parameters used in this paper were fixed as: ξ=10, maxIter=200 and maxCol=100. According to some preliminary experiments, we observed that only the value of ξ affected the performance of the proposed tabu search algorithm while all these parameters had little impact on the performance of the branch-and-price-and-cut algorithm.

@&#CONCLUSIONS@&#
In this work, we propose an exact branch-and-price-and-cut algorithm for solving the MTRPD, which is a natural extension to the MTRP that considers a limit to the travel distance of the vehicle. The key component in the branch-and-price-and-cut algorithm is the algorithm used to solve the pricing subproblem, which is an elementary resource-constrained shortest path problem with cumulative cost. We have obtained the optimal solutions for all but one instance within 10,800seconds. The branch-and-price-and-cut implementation with state-space relaxation consumed less computation time than the other implementation with tabu search column generator and decremental state-space relaxation. The experimental results and analysis presented in this study serve as benchmarks for future researchers. Our work is the first attempt at designing bounded bidirectional label-setting algorithm for the pricing problems with cumulative cost. Future research may consider either studying other exact algorithms to improve our results for the MTRPD or designing exact algorithms for other routing problems with cumulative cost.