@&#MAIN-TITLE@&#
An effective co-evolutionary artificial bee colony algorithm for steelmaking-continuous casting scheduling

@&#HIGHLIGHTS@&#
We study a new steelmaking-continuous casting scheduling problem.The problem is modeled as a combination of a charge scheduling and a cast scheduling.A cooperative co-evolutionary artificial bee colony (CCABC) algorithm is presented.The effectiveness of the CCABC is demonstrated by extensive experiments.

@&#KEYPHRASES@&#
Scheduling,Hybrid flowshop,Parallel machine scheduling,Artificial bee colony,Cooperative co-evolution,

@&#ABSTRACT@&#
This paper addresses a new steelmaking-continuous casting (SCC) scheduling problem from iron and steel production processing. We model the problem as a combination of two coupled sub-problems. One sub-problem is a charge scheduling problem in a hybrid flowshop, and the other is a cast scheduling problem in parallel machines. To solve this SCC problem, we present a novel cooperative co-evolutionary artificial bee colony (CCABC) algorithm that has two sub-swarms, with each addressing a sub-problem. Problem-specific knowledge is used to construct an initial population, and an exploration strategy is introduced to guide the CCABC to promising regions during the search. To adapt the search operators in the classical artificial bee colony (ABC) to the cooperative co-evolution paradigm, an enhanced strategy for onlookers and a self-adaptive neighbourhood operator have been suggested. Extensive experiments based on both synthetic and real-world instances from an SCC process show the effectiveness of the proposed CCABC in solving the SCC scheduling problem.

@&#INTRODUCTION@&#
There has been growing interest in solving real-world scheduling problems in recent years (Tang, Guan, & Hu, 2010). This paper considers a realistic and typical scheduling problem that integrates a charge scheduling problem in a hybrid flowshop and a cast scheduling problem in parallel machines. The problem is found in a very important industrial process of the world economy, which is the steelmaking-continuous casting (SCC) process. The SCC process includes three consecutive production stages, namely steelmaking, refining, and continuous casting, and it is usually the bottleneck in iron and steel production (Tang, Liu, Rong, & Yang, 2001, Tang, Wang, & Chen, 2014). Effective scheduling methods for the SCC process are crucial to improving the productivity of the modern iron and steel industry (Chang, Chang, & Hong, 2000, Cowling and Rezig 2000, Tang, Liu, Rong, & Yang, 2000, Tang, Lub, Liu, & Fang, 2002).SCC scheduling is known to be one of the most difficult industrial scheduling problems. Researchers and practitioners have approached SCC scheduling problems mostly by mathematical programming and artificial intelligence (Pacciarelli & Pranzo, 2004). For mathematical programming methods, Tang et al. (2002) presented a combination of Lagrangian relaxation, dynamic programming and heuristics for an SCC problem, to ensure continuity of the production process and just-in-time delivery of the final products. Bellabdaoui and Teghem (2006) presented a mixed-integer programming model to minimize the total completion time of the sequences for scheduling an SCC process with two parallel machines at each stage in Arcelor Group in Liege, Belgium. Xuan and Tang (2007) established an integer programming model and presented a batch decoupling based on a Lagrangian relaxation algorithm for an SCC scheduling problem, to minimize a given criterion with respect to the completion time. Missbauer, Hauber, and Stadler (2009) introduced a computerized scheduling system for an SCC process from a steel plant in Austria, where a schedule is improved by a linear programming model. Sun and Wang (2013) proposed a scheduling method that consists of an equipment assignment algorithm based on a dynamic programming technique and a conflict elimination algorithm based on a linear programming technique, to guarantee that the charges are continuously processed on the same caster. Recently, Mao , Pan, Pang, and Chai (2014a) studied an SCC scheduling problem for minimizing the total weighted earliness/tardiness penalties and job waiting and presented a Lagrangian relaxation approach while relaxing the machine capacity constraints. Mao , Pan, Pang, and Chai (2014b) addressed an SCC rescheduling problem with machine break-down and processing time variations and developed a time-index formulation and an effective Lagrangian relaxation approach with machine capacity relaxation.Using artificial intelligence methods, Pacciarelli and Pranzo (2004) formulated the scheduling of stainless ingots in a production line in central Italy by an alternative graph and solved the problem using a beam search procedure. Kumar, Kumar, Tiwari, and Chan (2006) developed a combinatorial auction-based approach to resolve an SCC scheduling problem for minimizing the waiting time and maximizing the number of steel slabs that are produced. Atighehchian, Bijari, and Tarkesh (2009) investigated an SCC scheduling problem from Mobarakeh Steel Company in Isfahan with the objective of minimizing the casting interruption cost, molten steel temperature drop cost, cost of poor quality and maximum completion time cost, and they presented a hybrid algorithm based on ant colony optimization and non-linear optimization methods. Zhu, Zheng, and Gao (2010) proposed an optimization model that is combined with a parallel-backward inferring algorithm and genetic algorithm to improve the efficiency and performance of production scheduling in an SCC process. Recently, Pan, Wang, Mao, Zhao, and Zhang (2013) considered an SCC scheduling problem to minimize the penalty caused by sojourn time and the earliness/tardiness of cast starting, using an artificial bee colony algorithm. Later, Li, Pan, Mao, and Suganthan (2014) presented an effective fruit fly optimization algorithm to solve the same SCC scheduling problem, and they improved the results. More recently, Tang, Zhao, and Liu (2014) presented an improved differential evolution algorithm with a real-coded matrix representation to re-optimize the assignment, sequencing, and timetable of a set of existing and new jobs among various production stages for a new environment in which unforeseen changes occurred in the production system.In the above literature, one of the basic assumptions is that the assignment and sequencing of the casts (i.e., a given sequence of charges) in the continuous casting stage are fixed in advance and remain unchanged, and the researchers concentrated on the sequence and scheduling of the charges in the steelmaking and refining stages and the timing of the charges on casters in the continuous casting stage. Unlike the above studies, this paper assumes that the schedule of the casts are not given in advance and to be determined by the scheduling algorithm. That is, we address a new SCC scheduling problem that optimizes charge scheduling in the steelmaking and refining stages and cast scheduling in continuous casting stage simultaneously to minimize the makespan and charge waiting times over the whole SCC process. This approach will lead to a much higher degree of flexibility, which can significantly enhance the productivity. Furthermore, we consider multiple refining phases in the refining stage, which is an approach that has a much wider application to real-world problems.Artificial bee colony (ABC) is a fairly new optimizer that has been shown to be as competitive as other population-based algorithms for continuous function optimization, but it has the advantage of employing fewer control parameters (Karaboga & Akay, 2009). It has gradually become more and more popular and has been successfully used in scheduling problems, including the lot-streaming flowshop (Pan, Suganthan, Tasgetiren, & Chua, 2011), flexible job shop (Li et al. 2011), and many others. In our previous work (Pan et al., 2013), we presented an effective ABC algorithm for solving a three-stage SCC scheduling problem with the assumption of a fixed cast schedule at the continuous casting stage. Whereas, this paper applies ABC to the new SCC scheduling problem, which consists of two coupled sub-problems: a charge scheduling problem in the steelmaking and refining stage and a cast scheduling problem in the continuous casting stage. We extend the ABC to a cooperative co-evolutionary paradigm by dividing the artificial bees into two sub-swarms, each addressing a scheduling problem. Furthermore, we introduce new techniques to enhance the performance of the cooperative co-evolution ABC (CCABC), including a problem-specific knowledge-based initialization, a new exploration mechanism, and a self-adaptive neighbourhood operator. Extensive simulations and comparisons demonstrate the effectiveness of the CCABC for the new SCC problem.The remainder of this paper is organized as follows. In Section 2, a realistic SCC scheduling problem is formulated. Section 3 introduces the basic ABC briefly, which is followed by a description of the presented CCABC in Section 4. The simulation results and empirical comparisons are provided in Section 5. Finally, Section 6 concludes the paper and suggests some future work.Basically, an SCC process consists of three consecutive production stages: steelmaking, refining, and continuous casting (seeFig. 1).In the steelmaking stage, hot molten iron is turned into molten steel by a Linz–Donawitz–Verfahren converter (‘LD’ in Fig. 1), which reduces the carbon, sulphur, silicon, and other impurity content to desirable levels. In the refining stage, the impurities are further eliminated, and the required alloy ingredients are added to the molten steel. To produce high grade steel, multiple refining stages always exist, such as the Ruhrstahl Heraeus (‘RH’ in Fig. 1) and Ladle Furnace (‘LF’ in Fig. 1). Charges are the basic production units in the steelmaking and refining stages, which refers to concurrent smelting in the same furnace. The continuous casting stage is responsible for casting the liquid steel into solid slabs. At this stage, a sequence of charges must be continuously cast on the same continuous caster (‘CC’ in Fig. 1) in accordance with a given precedence and without a break. Thus, a sequence of charges (or a cast) is the basic production unit. To accelerate the production and to balance the interflow of the charges, identical parallel machines are configured at each stage.Following Atighehchian et al. (2009), Tang et al. (2002), and many others, we consider the situation in which all of the charges follow the same process route: steelmaking, refining, and then continuous casting. In the refining stage, the charges undergo refining stage one and then refining stage two, until the last refining stage. A charge or cast can be processed on any one of the parallel machines at the same stage. The production process is a complex hybrid flowshop, which is very common in modern iron and steel enterprises in China. The other cases in which the charges have different refining routes, for example, some from RH to LF, others from LF to RH, or a charge goes through some refining stage twice will be studied in the future.A sequence-independent and separable setup time is needed when a new cast is prepared for processing. However, no setup time is required between the adjacent charges in a cast. The transportation times between the stages must be considered. We address the static scheduling problem in this paper and assume that the processing times of all of the charges, the transportation times between stages, and the setup times of all of the casts are known, deterministic, and uninterrupted. The dynamic scheduling problem, which addresses unforeseen real-time events and is solved by varying processing time and other methods (see Mao et al., 2014b; Tang, Zhao et al., 2014), is beyond the scope of this paper.With the above assumptions, the SCC scheduling problem can be characterized as two closely coupled sub-problems, i.e., charge scheduling and cast scheduling. The former is a hybrid flowshop scheduling problem with transportation times involved, whereas the latter involves parallel machine scheduling with separable setup times. The charge scheduling sub-problem is to assign charges to converters and refining furnaces and also to sequence them on the assigned facilities as well as to determine the timetable for the charges. The cast scheduling sub-problem is to allocate the casts to casters and also to sequence them on the allocated caster as well as to determine the timetable on the caster for their charges. The technological constraints require that a cast consists of a sequence of charges. The charges and the precedence among them are given in advance. The processing of a cast is without a break. Because it is important to complete all of the casts as soon as possible and to avoid a large temperature drop, which could result in an additional cost for reheating, we aim to minimize the makespan and charge waiting times. In the following, a mathematical formulation of the SCC scheduling problem is presented.Parameters and constants:k=1,2,…,K: Charge index, where K is the total number of charges.s=1,2,…,S−1: Stage index, where S is the total number of stages.ms: The total number of machines at stage s.pk, s: Processing time of charge k at stage s.ts: Transportation time from stages−1to stage s.H: A very large positive number.ψ1: Penalty coefficient for the makespan.ψ2: Penalty coefficient for the total waiting times.Decision variables:xk, s, m: 0/1 variable, equal to 1 if and only if charge k is allocated to machine m at stage s.yk1,k2,s: 0/1 variable, equal to 1 if and only if charge k1 precedes k2 to be processed at stage s.ck, s: Completion time of charge k at stage s.Constraints:Each charge must pass through the steelmaking and refining stages and must be processed by exactly one machine at each stage.(1)∑m=1m2xk,s,m=1,k=1,2,…,K,s=1,2,…,S−1.For two consecutive operations of a charge, the next operation can be started only after the previous one is completed and the charge is transferred to the current machine.(2)ck,s−pk,s≥ck,s−1+ts,k=1,2,…,K,s=2,…,S−1For any two different operations at the same stage, there exists a precedence relationship(3)yk1,k2,s+yk2,k1,s≤1,k1,k2∈{1,2,…,K}∧k1≠k2,s=1,2,…,S−1For any two operations on the same machine, only when the preceding operation is finished, the next one can be started.(4)ck2,s−pk2,s−ck1,s+(3−xk1,s,m−xk2,s,m−xk2,s,m−yk1,k2,s)H≥0,k1,k2∈{1,2,…,K}∧k1≠k2,m∈{1,2,…,ms},s=1,2,…,S−1The start times must be non-negative.(5)ck,1−pk,1≥0,k∈{1,2,…,K}Parameters and constants:z=1,2,…,Z: Cast index, where Z is the total number of casts.lz: The last charge index in cast z; we havel0=0andlZ=K, andz={lz−1+1,lz−1+2,…,lz}.Tz=∑k=lz−1+1lzpk,S: Processing time of cast z.qz: Setup time of cast z.Decision variables:χz, m: 0/1 variable, equal to 1 if and only if cast z is allocated to caster m.γz1,z2: 0/1 variable, equal to 1 if and only if cast z1 is to be processed preceding z2.Cz: Completion time of cast z, equal to the completion time of the last charge in the cast, i.e.,Cz=clz,S.Constraints:A cast can be assigned to exactly one caster.(6)∑m=1mSχz,m=1,z=1,2,…,ZFor any two different casts, there exists an operation precedence relationship(7)γz1,z2+γz2,z1≤1,z1,z2∈{1,2,…,Z}∧z1≠z2For any two casts that are assigned to the same caster, only when the preceding cast is finished, the next one can be set up.(8)Cz2−Cz1−Tz2−qz2+(3−χz1,m−χz2,m−γz1,z2)H≥0,z1,z2∈{1,2,…,Z}∧z1≠z2To continuously cast, when a charge in the cast is completed, the next one should arrive at or wait on the caster. For this purpose, the starting time of cast z should satisfy(9)Cz−Tz≥max{clz−1+1,S−1,maxk=lz−1+2,…,lz{ck,S−1−∑k′=lz−1+1k−1pk′,S}}+tS,z=1,2,…,Z,No machine idling time exists between two adjacent charges in a cast.(10)ck,S=Cz,k=lzck,S=ck+1,S−pk+1,S,k=lz−1,lz−2,…,lz−1+1(11)minF=ψ1·maxz=1Z{Cz}+ψ2·∑k=1K∑s=2S(ck,s−pk,s−ck,s−1−ts)wheremaxz=1Z{Cz}is the makespan, and∑k=1K∑s=2S(ck,s−pk,s−ck,s−1−ts)is the total waiting time.Consider an instance with a single refining phase. There are two converters (1# LD and 2# LD), two refining furnaces (1# RH and 2# RH) and one continuous caster (1# CC). Two casts are to be processed. The first includes charges 1 and 2, whereas the second includes charges 3, 4 and 5. The transportation times aret2=10andt3=10. The setup times for two casts areq1=35andq2=15. The processing times of these five charges at every stage are given as follows:[pk,s]5×3=[452565453025707040858540555545]The Gantt chart of a solution is shown in Fig. 2, where the makespan is 330 and the total waiting time is 110. Suppose thatψ1=10andψ2=1; then, the objective value isF=10×330+1×110=3410.As a new optimizer that is designed for function optimizations, ABC simulates the intelligent foraging behaviour of honeybees in finding nectar sources around their hives (Karaboga & Akay, 2009). ABC starts with a population of initial food sources (i.e., solutions) and, then, iteratively undergoes the employed bee phase, onlooker bee phase, and scout phase until a termination condition is satisfied.An initial population consists of PS food sources or solutions, each of which is represented by a D-dimensional real-valued vector. Letαi={αi,1,αi,2,…,αi,D}be the ith solution, which is generated as follows:(12)αi,d=B̲+(B¯−B̲)×rand(0,1),d=1,2,…,Di=1,2,…,PSwhere rand(a, b) is a uniform random number in the range of [a, b]; andB̲andB¯are the lower and upper bounds, respectively.In the employed bee phase, each employed bee is associated with a solution or food source. Each bee is responsible for finding a new solution in its neighbourhood. Suppose that αiis the current solution. The new solutionαi′is produced as follows:(13)αi,d′=αi,d+(αi,d−αi′,d)×rand(−1,1)wherei′∈{1,2,…,PS}∧i′≠i,d∈{1,2,…,D}, is a randomly chosen index. If the fitness ofαi′,f(αi′), is better than f(αi), then it will replace αiand become a new member of the swarm; otherwise, αiis retained andαi′is discarded.In the onlooker bee phase, an onlooker bee evaluates the fitness of the solutions found by the employed bees and selects a solution αiwith a probability ρi, which is calculated byρi=f(αi)/∑i′=1PSf(αi′). Clearly, the higher the fitness f(αi) is, the more likely αiis selected. Once the onlooker has selected a solution αi, it produces a modification to αiusing the same method that the employed bees use. If the modified solution is better than αi, then it will replace αiand become a new member of the swarm.In the scout phase, if a solution αicannot be further improved through a predefined maximum number of trials θ, it will be abandoned and the corresponding employed bee becomes a scout. The scout produces a solution randomly using Eq. (12). At each cycle of the ABC algorithm, at most one scout goes outside to search for a new food source.A natural approach to addressing the SCC scheduling problem is to utilize a divide-and-conquer (or decomposition) strategy. The cooperative co-evolution approach is such a strategy, and it has attracted much attention in recent years (Li & Yao, 2012). This section presents a cooperative co-evolutionary ABC (CCABC) for solving the SCC problem. CCABC starts with two sub-swarms, each of which tackles one sub-problem. Then, CCABC evolves the two sub-swarms alternately. When one sub-swarm is being evolved, the other is fixed. To evaluate an individual that is generated for a sub-swarm, we take the best individual from the other sub-swarm as the context vector. An overall solution is constructed by concatenating the individual and the context vector. The constructed solution is evaluated, and its objective value is also the objective value of the generated individual. Then, the generated individual undergoes a competing and updating process in the current sub-swarm.We divide the representation of the SCC problem into two parts, one for the charge scheduling sub-problem and the other for the cast scheduling sub-problem. We denote an individual or solution using a vectorI=(λ,μ)that contains a charge list λ and a cast list μ. The cast list μ is a complete permutation of all of the casts, which represents the order in which the casts are launched into the continuous casting stage. The charge list λ is a permutation of all of the charges. It indicates the order in which the charges are processed at the steelmaking and refining stages. Instead of using the charge indices in the list λ, we use the cast indices to represent the charges. A cast index z appears exactly ‖z‖ times in the list, where ‖z‖ represents the number of charges in cast z. The list λ is interpreted from left to right. The first appearance of z corresponds to the first charge of cast z, and the second appearance of z corresponds to the second charge of the cast, and so on. For the example in Fig. 2,I=(11222,12)is a solution, whereλ=(11222)andμ=(12). In λ, from the left to the right, λ is interpreted as the charge permutation (1 2 3 4 5).We present a method to decode an individualI=(λ,μ)into a complete schedule in the reverse order. We first consider the cast list μ and launch its casts in the continuous casting stage from the end to the front. Each cast is assigned to the first available caster and is started as late as possible. Afterward, the charge list λ is applied to both the refining and steelmaking stages. In these stages, the charges are sequentially taken out from λ from the end to the front and allocated to the first available refining furnace or converter and started as late as possible. Fig. 3(a) shows the schedule in the form of a Gantt chart decoded from the individualI=(11222,12), which is discussed in Section 2.3. In Fig. 3(a), we set the completion time of the last cast in μ at time 0, and the casts and charges are presented in reverse order along the coordinate axis. For the cast listμ=(1,2), we first assign cast 2 to 1# CC and start it at time−T2=−(p3,3+p4,3+p5,3)=−125. Then, we assign cast 1 to 1# CC and start it at time(−125−q2)−T1=(−125−q2)−(p1,3+p2,3)=−230. In the refining stage, according to the charge permutation (1 2 3 4 5) obtained fromλ=(11222), charge 5 is first considered. Both 1# RH and 2# RH are free now. 1# RH is selected, and charge 5 is started at time−(p5,2+t3+p5,3)=−110. We then consider charge 4. Because the first available refining furnace is 2# RH for charge 4, we assign it to 2# RH and start it at time−(p4,2+t3+p4,3+p5,3)=−135. Next, we consider charge 3, charge 2, and charge 1. After the refining stage, we also address the steelmaking phase according to (1 2 3 4 5), using a similar method. Finally, we obtain a schedule with a makespan that is equal to 330 and a total waiting time equal to 70. In the figure, the starting times of the casts and charges are negative. We can shift the whole schedule to the right at an offset value that is equal to the makespan to satisfy the constraints in (5). Note that this schedule is different from the schedule shown in Fig. 2, which is presented in a forward manner.The above decoding method shifts the operations to the right as compactly as possible, which leads to a semi-active schedule according to Pinedo (2012). To further decrease the total waiting time, we fix the operations at the steelmaking stage and shift the operations in the refining and continuous casting stages to the left as compactly as possible without changing the operation sequence on each machine. After shifting operations, the total waiting time of the schedule shown in Fig 3(a) is decreased to 50. The new Gantt chart is shown in Fig. 3(b).An initial population that contains diverse and promising candidate solutions always results in a faster convergence to good results. A common practice for population initialization in the scheduling literature is to construct a few good solutions using heuristics and to generate the remainder randomly (Ruiz & Maroto, 2006). The largest processing time (LPT) rule is commonly used in the scheduling literature. LPT gives a higher priority to the job that has the larger processing time. We present an LPT heuristic for the SCC problem as follows:Algorithm 1. The LPT heuristicStep 1: Sort all of the casts in decreasing order of their processing timeTz,z=1,2,…,Z, and generate a cast listμ.Step 2: Schedule the casts in reverse order according to the cast listμ.Step 3: Compute the starting time for each charge in the continuous casting stage.Step 4: Sort all of the charges in increasing order of the start times, and generate a charge listλ.Step 5: Schedule the charges in the steelmaking and refining stages according to the charge listλin the reverse order.The LPT heuristic is very straightforward, and it can be completed in a time complexity ofO(K(logK+∑s=1Sms)). We take advantage of the LPT heuristic to generate a promising initial solution and produce the remainder randomly. However, if both the charge list λ and the cast list μ of a solutionI=(λ,μ)are randomly generated, the solution is most likely poor because the inherent relationship between λ and μ is not considered. To address this problem, we generate a cast list μ randomly but produce the charge list λ using Steps 3–5 of the LPT heuristic. The initialization method is given as follows.Algorithm 2. InitializationOutput: context vectorI¯=(λ¯,μ¯), cast list sub-swarmU, charge list sub-swarmΛStep 1: LetU={}andΛ={}.Step 2: Generate a cast listμby the LPT rule and letU=U∪{μ}.Step 3: Produce a cast listμrandomly. LetU=U∪{μ}ifμis different from all of the existing ones. Repeat this step until∥U∥=PS.Step 4: Fori=1,2,…,PS, generate the charge listλiforμi∈Uusing Steps 3∼5 of the LPT heuristic, and letΛ=Λ∪{λi}.Step 5: Fori=1,2,…,PS, evaluateIi=(λi,μi). The best one is set as the context vectorI¯=(λ¯,μ¯).Step 6: Fori=1,2,…,PS, calculatef(λi,μ¯)andf(λ¯,μi).As a matter of course, the initial population is divided into two sub-swarms U and Λ, with U for the cast scheduling sub-problem and Λ for the charge scheduling sub-problem.In the employed bee phase, each employed bee is associated with a charge list or cast list. The employed bee searches promising neighbours for the associated list. The charge list sub-swarm Λ and the cast list sub-swarm U are evolved alternately. To evolve Λ, each employed bee i generates a new charge listλi′by performing a neighbourhood operator on its associated list λi. Then, a solution(λ′i,μ¯)is constructed by concatenatingλi′and the context vectorμ¯. If the objective value of(λ′i,μ¯)is smaller than its counterpart(λi,μ¯), the new list is accepted, i.e.,λi←λi′. We also compare(λ′i,μ¯)with(λ¯,μ¯)to update the context vector. A similar procedure is performed to update each μiin U.In the basic ABC, an onlooker bee selects a solution using a fitness proportional selection scheme. This selection operator is slow because the fitness of every individual and a mapping calculation are needed. Therefore, following our previous work (Pan et al., 2013), we change the fitness proportional selection to the tournament selection due to the simplicity and ability to escape from local optima of the tournament operator. The tournament selection involves running several “tournaments” among a few individuals that were chosen at random from the swarm. The winner of each tournament is selected. For our CCABC, two charge lists (or cast lists) are picked up randomly from the sub-swarm and compared to each other, and then, the better one is chosen to be an onlooker. We repeat this selection PS times and associate a list for every onlooker. After selection, the onlooker utilizes the same method as the employed bees to yield a new neighbouring charge list or cast list.Unlike the basic ABC, which employs a greedy selection mechanism between the old and new candidate solutions, we consider an enhanced strategy to promote the exploitation capability of the onlookers. As shown in our previous work (Pan et al., 2013), a steady state updating procedure where the offspring replace the worst individuals in the population produces much better results than the scheme where offspring directly replace their parents. We adopt the steady state updating procedure here. At the same time, clones in the population are not allowed. In other words, the new neighbour of the current charge list λi(or cast list μi) will only replace the worst charge list (or cast list) in the sub-swarm if it is better than the worst and no other identical lists exist. This steady state scheme gives potential solutions (i.e., individuals that can produce better neighbouring solutions) more opportunity to be further explored and excludes non-potential solutions such as the worst individuals. The steady state scheme also helps to maintain the diversity of the sub-swarms, to avoid premature convergence.The scout phase aims to enhance ABC's exploration. Following the basic ABC, CCABC abandons a charge list λior a cast list μiif it has not been improved in θ consecutive iterations. (If there exist multiple such lists, we randomly select one for updating). CCABC then randomly generates a charge list or cast list to enter the sub-swarm. However, the primary experiments show that CCABC yields worse results than without the scout phase.One can argue that this finding can be attributed to the method used to generate a scout solution. A randomly generated charge list (or cast list) is most likely a very poor solution for such a complex problem. This approach misleads the CCABC. Thus, we consider generating a promising scout solution by taking advantage of the knowledge acquired in the evolutionary search. An abandoned individual often carries useful information that is collected during the search process because it survives many generations. The search space around this individual could be the most promising region. Following our previous work (Pan et al., 2013), we generate a scout solution by performing a few moves on the abandoned solution. From our primary experiments, however, even with this enhanced method to generate a scout solution, CCABC still cannot generate better results than without the scout phase. The scout phase of CCABC does not work as expected. This finding suggests that the exploration capability of the scouts cannot help the algorithm escape from local optima. Hence, we skip the scout phase in the proposed CCABC.In CCABC, the ineffectiveness of the scouts can mainly be attributed to the co-evolution mechanism. For example, if a new charge list or cast list is introduced into the sub-swarms by a scout, it must perform a search toward the best match with its context vector. This approach limits the diversity of the search and easily drives the search back to the area in which the algorithm stalls. To move CCABC into an unexplored area, we present an exploration mechanism that changes not only the context vector but also the current sub-swarms as well. CCABC restarts the search process with the new context vector and sub-swarms.Because the context vectorI¯=(λ¯,μ¯)is the best solution found in this round of exploitation, the search around it indicates promising areas to search for the optimal solution. We generate a group of PS new solutions by performing a small number of moves on the context vectorI¯=(λ¯,μ¯). The best one among them is set as the new context vectorI′¯=(λ′¯,μ′¯). AfterI′¯=(λ′¯,μ′¯)is determined, the new charge list sub-swarm Λ′ and new cast list sub-swarm U′ are yielded by performing a number of moves toλ′¯andμ′¯, respectively. In the above procedure, the number of moves is critical. A too-small value will be inadequate for CCABC to escape from local optima, whereas a too-large value will result in a randomized local search. We set the value to three based on preliminary simulation results. This value has shown to work well for a large group of instances that have different sizes. The exploration strategy is outlined as follows:Algorithm 3. An exploration schemeInput: the current context vectorμ¯.Output: new context vectorλ′¯andμ′¯, new charge list sub-swarmU′, and new cast list sub-swarmΛ′.Step 1: Fori=1,2,…,PS, generate a cast listμiby performing a small number of moves toμ¯.Step 2: For eachμi,i=1,2,…,PS, generate a charge listλiusing Steps 3∼5 of the LPT heuristic.Step 3: Fori=1,2,…,PS, evaluateIi=(λi,μi). Set the best one as the new context vector, i.e.,(λ′¯,μ′¯)=arg(mini=1,..,PSf(λi,μi)).Step 4: LetU′={}. Fori=1,2,…,PS, generate a cast listμi′by performing a small number of moves toμ′¯, and setU′=U′∪{μi′}.Step 5: LetΛ′={}. Fori=1,2,…,PS, generate a charge listλi′by performing a small number of moves toλ′¯, and setΛ′=Λ′∪{λi′}.Step 6: Fori=1,2,…,PS, calculatef(λi′,μ′¯)andf(λ′¯,μi′).We must decide when the exploration procedure should be performed. For this purpose, we introduce a new parameter θ′. If the context vector is not improved in θ′ consecutive iterations, the exploration procedure will be introduced. The parameter θ′ controls the balance between exploitation and exploration. A large θ′ value is in favour of an intensive search, whereas a small θ′ value helps explore a large solution space.ABC generates a new solution in the neighbourhood of the current solution in the employed bee and onlooker phases. A neighbourhood operator plays an important role when developing an effective ABC for solving the SCC problem. In the scheduling literature, shift and pairwise exchange are two commonly used neighbourhood operators for the permutation-based representation. The shift operator relocates a randomly selected job to another random position in the permutation. Jobs between these two positions move along. The pairwise exchange performs random pairwise exchanges to an individual. Note that when performing a pairwise exchange to a charge list λ, we should select two charges from different casts to avoid an ineffective move.The two neighbourhood operators lead to distinct neighbourhood structures for the SCC problem. An optimal neighbourhood should be different in various instances and in different search phases of the same instance. Hence, a self-adaptive approach is proposed here to determine a neighbourhood operator. We associate a charge list λi(or a cast list μi) with a neighbourhood operator by which the list is generated. To generate a new listλi′(orμi′), the list selects its operator as follows: A random number is generated by using a uniform distribution in the range of [0, 1]. If the random number is less than a control parameter ϑ, the associated operator is selected. Otherwise, a shift or pairwise exchange is selected with an equal probability of 50 percent. The new listλi′(orμi′) is also associated with the operator that generates it. We setϑ=0.75based on preliminary simulation results. This value works robustly for a large group of instances that have different sizes.The pseudo code of the CCABC is shown in Algorithm 2, where PS is the size of each sub-swarm, θ′ is the maximum number of consecutive iterations in which the context vector is not improved, and the function f(λ, μ) returns the objective value forI=(λ,μ).Algorithm 4. The CCABC algorithmParameter:PSandθ′Output:bestsofarSet parametersPSandθ′Initialize the sub-swarms{λ1,λ2,…,λPS}and{μ1,μ2,…,μPS}and the context vectorI¯=(λ¯,μ¯)Repeat//Employed bee phasefori=1,2,…,PSdoGenerateλi′forλiusing the self-adaptive neighbourhood operatoriff(λi′,μ¯)<f(λi,μ¯)thenλi←λi′iff(λi′,μ¯)<f(λ¯,μ¯)thenλ¯←λi′endfori=1,2,…,PSdoGenerateμi′forμiusing the self-adaptive neighbourhood operatoriff(λ¯,μi′)<f(λ¯,μi)thenμi←μi′iff(λ¯,μi′)<f(λ¯,μ¯)thenμ¯←μi′end//Onlooker bee phasefori=1,2,…,PSdoSelect a charge listλrusing tournament selectionGenerateλr′forλrusing the self-adaptive neighbourhood operatoriff(λr′,μ¯)<f(λw,μ¯)thenλw←λr′//λwis the worst individual inΛiff(λr′,μ¯)<f(λ¯,μ¯)thenλ¯←λr′endfori=1,2,…,PSdoSelect a cast listμrusing tournament selectionGenerateμr′forμrusing the self-adaptive neighbourhood operatoriff(λ¯,μr′)<f(λ¯,μw)thenμw←μr′//μwis the worst individual inUiff(λ¯,μr′)<f(λ¯,μ¯)thenμ¯←μr′end// Perform the exploration schemeCall Algorithm 3 ifI¯has not been improved inθ′iterations// Update the best solution found thus farbestsofar←I¯iff(I¯)<f(bestsofar)Until a termination criterion is met

@&#CONCLUSIONS@&#
In this study, we address a new SCC scheduling problem that has received little attention in the literature but can be commonly found in real-world SCC processes in the modern iron and steel industry. The scheduling problem can be regarded as an integration of charge scheduling in a hybrid flowshop and cast scheduling in parallel machines. To solve this problem, CCABC, a cooperative co-evolutionary artificial bee colony algorithm, is proposed. To the best of our knowledge, this investigation is the first time that a cooperative co-evolutionary ABC has been proposed for scheduling problems. To enhance the performance of the CCABC, several new techniques, including a heuristic-based initialization procedure, a new exploration mechanism, an enhanced onlooker strategy, and a self-adaptive neighbourhood operator, have been suggested. We generate a total of 240 test instances based on a realistic production process and conduct a series of comparative studies to examine the performance of the proposed methods. Our simulation results demonstrate that the proposed CCABC, especially in combination with the improved techniques, is very effective at solving the SCC scheduling problem. The effectiveness of the CCABC has been further confirmed on the instances from real-world SCC processes. In the future, we will extend the CCABC to other scheduling problems, including hybrid flowshops, multi-objective flowshops, and flexible job shop problems.