@&#MAIN-TITLE@&#
A multi-agent based cooperative approach to scheduling and routing

@&#HIGHLIGHTS@&#
Developed a generic open source agent based system for scheduling and routing.Each agent can instantiate a different metaheuristic and local heuristic combination.Proposed system allows agents to share partial solutions during the search.A cooperative approach based on this generic system is evaluated on two domains.Improving results for vehicle routing and up to date for permutation flowshop.

@&#KEYPHRASES@&#
Combinatorial optimization,Scheduling,Vehicle routing,Metaheuristics,Cooperative search,

@&#ABSTRACT@&#
In this paper, we propose a general agent-based distributed framework where each agent is implementing a different metaheuristic/local search combination. Moreover, an agent continuously adapts itself during the search process using a direct cooperation protocol based on reinforcement learning and pattern matching. Good patterns that make up improving solutions are identified and shared by the agents. This agent-based system aims to provide a modular flexible framework to deal with a variety of different problem domains. We have evaluated the performance of this approach using the proposed framework which embodies a set of well known metaheuristics with different configurations as agents on two problem domains, Permutation Flow-shop Scheduling and Capacitated Vehicle Routing. The results show the success of the approach yielding three new best known results of the Capacitated Vehicle Routing benchmarks tested, whilst the results for Permutation Flow-shop Scheduling are commensurate with the best known values for all the benchmarks tested.

@&#INTRODUCTION@&#
Heuristics often come with a set of parameters, each requiring tuning for an improved performance. Moreover, different heuristics can perform well on different problem instances. Hence, there is a growing number of studies on more general methodologies which are applicable to different problem domains for tuning the parameters (Hutter, Babic, Hoos, & Hu, 2007; López-Ibánez, Dubois-Lacoste, Stützle, & Birattari, 2011; Ries & Beullens, 2015), generating or mixing/controlling heuristics (Burke et al., 2013; Ross, 2014). In this study, we take an alternative approach and use cooperating agents, where each agent is enabled to take a different method with different parameter settings.By cooperative search we mean that (meta)heuristics, executed in parallel as agents, have the ability to share information at various points throughout a search. To this end, we propose a modular agent-based framework where the agents cooperate using a direct peer to peer asynchronous message passing protocol. An island model is used where each agent has its own representation of the search environment. Each agent is autonomous and can execute different metaheuristic/local search combinations with different parameter settings. Cooperation is based on the general strategies of pattern matching and reinforcement learning where the agents share partial solutions to enhance their overall performance.The framework has the following additional characteristics. By using ontologies (see Section 3.2), we are aiming to provide a framework that is flexible enough to be used on more than one type of combinatorial optimisation problem with little or no parameter tuning. This is achieved by using our scheduling and routing ontology to translate target problems into an internal format that the agents can use to solve problems. So far, this approach has been applied successfully to Capacitated Vehicle Routing (CVRP), Permutation Flow shop Scheduling (PFSP), reported here and Nurse Rostering reported in Martin, Ouelhadj, Smet, Vanden Berghe, and Özcan (2013).The aim of this study is to develop a modular framework for cooperative search that can be deployed, with little reconfiguration, to more than one type of problem. We also test whether interaction between (meta)heuristics leads to improved performance and if increasing the number of agents improves the overall solution quality.The interest in cooperative search has risen due to successes in finding novel ways to combine search algorithms. Cooperative search can be performed by the exchange of states, solutions, sub-problems, models, or search space characteristics. For a general introduction see, for example, Blum and Roli (2003), Clearwater, Hogg, and Huberman (1992), Crainic and Toulouse (2008), Hogg and Williams (1993), Talbi and Bachelet (2006) and Toulouse, Thulasiraman, and Glover (1999). Several frameworks have been proposed recently which incorporate metaheuristics such as Meignan, Creput, and Koukam (2008), Meignan, Koukam, and Créput (2010), Milano and Roli (2004) and Talbi and Bachelet (2006), or hyper-heuristics, as in Ouelhadj and Petrovic (2010). Also, El Hachemi, Crainic, Lahrichi, Rei, and Vidal (2014) explore a general agent-based framework for solution integration where distributed systems use different heuristics to decompose and then solve a problem.In an effort to find ways to combine different metaheuristics in such a way that they cooperate with each other during their execution, a number of design choices have to be made. According to Crainic and Toulouse (2008) an asynchronous framework in particular could result in an improved search methodology; communication can then either be many-to-many (direct), where each metaheuristic communicates with every other, or it can be memory based (indirect), where information is sent to a pool that (other) metaheuristics can make use of as required.Most cooperative search mechanisms in the OR literature deploy indirect communication through some central pool or adaptive memory. This can take the form of passing whole, or possibly partial, solutions, to the pool. Malek (2010), Milano and Roli (2004), Meignan et al. (2008, 2010) and Talbi and Bachelet (2006). Aydin and Fogarty (2004b) applied this approach to job shop scheduling. Recently, (Barbucha, 2014) has proposed an agent-based system for Vehicle Routing Problems where agents instantiate different metaheuristics which communicate through a shared pool.Direct communication is used only in Vallada and Ruiz (2009) and Aydin and Fogarty (2004a), where whole solutions are passed from one process to another in an island model executing a genetic or an evolutionary simulated annealing algorithm respectively, and in Ouelhadj and Petrovic (2010), where a similar set-up is used for a hyper-heuristic. All three papers addressed the PFSP. Also, this approach is to an extent present in the evolutionary system of Xie and Liu (2009), who investigated the Travelling Salesman Problem. Kouider and Bouzouia (2012) propose a direct communication multi agent system for job shop scheduling where each agent is associated with a specific machine in a production facility. Here a problem is decomposed into several sub-problems by a “supervisor agent”. These are passed to “resource agents” for execution and then passed back to the supervisor to build the global solution.Little work has been done on asynchronous direct cooperation where partial solutions are rated and their parameters are communicated between autonomous agents all working on the total problem. So far, no direct cooperation strategy has been applied to more than one problem domain in combinatorial optimisation. To this end, the agents are truly autonomous and not synchronised. There is a gap in the literature regarding agents cooperating directly and asynchronously where the communication is used for the adaptive selection of moves with parameters.The outline for the rest of the paper is as follows. Section 2 provides formal problem statements for the two case studies. Section 3 describes the proposed modular multi-agent framework for cooperative search, while Section 4 describes how it is implemented. In Section 5 we discuss the experimental design. In Section 6 we report the results of the tests where, to the best of our knowledge, for three of the Capacitated Vehicle Routing instances we achieved better results than have been reported in the literature. Finally, Section 7 presents conclusions and suggestions for future work.In this section we offer brief problem descriptions of the case studies applied to the agent-based framework proposed in this paper. We chose these instances as they are representative scheduling and routing problems. The algorithms instantiated by the framework are state-of-the-art implementations (Juan, Ruíz, Lourenço, Mateo, & Ionescu, 2010b; Juan, Faulin, Jorba, Caceres, & Marquès, 2013; Juan, Faulin, Ruiz, Barrios, & Caballé, 2010a; Juan, Lourenço, Mateo, Luo, & Castella, 2014). These are all examples of Simheuristics (Juan, Faulin, Grasman, Rabe, & Figueira, 2015). This makes them a good fit with the partial solutions identified by the system.Let us assume that we have a set of n jobs,J={1,...,n},available at a given time 0, and each to be processed on each of a set of m machines in the same order,M={1,...,m}. A job j ∈ J requires a fixed but job-specific non-negative processing time pj, ion each machine i ∈ M. The objective of the PFSP is to minimise the makespan. That is, to minimise the completion time of the last job on the last machine Cmax(Pinedo, 2002). A feasible schedule is hence uniquely represented by a permutation of the jobs. There are n! possible permutations and the problem is NP-complete (Garey, Johnson, & Sethi, 1976).A solution can hence be represented, uniquely, by a permutationS=(σ1,...,σj,...,σn),where σj∈ J indicates the job in the jth position. The completion timeCσj,iof job σjon machine i can be calculated using the following formulae:(1)Cσ1,1=pσ1,1(2)Cσ1,i=Cσ1,i−1+pσ1,i,wherei=2,...,m(3)Cσj,i=max(Cσj,i−1,Cσj−1,i)+pσj,i,wherei=2,...,m,andj=2,...,n(4)Cmax=Cσn,mThe Capacitated Vehicle Routing Problem (Dantzig & Ramser, 1959) can be defined in the following graph theoretic notation. Let G(V, E) be an undirected complete graph whereV={v0,v1,v2,...,vn}is the vertex set and where E is a set of edges.Let the setvi(wherei={1,...,n})represent the customers who are expecting to be serviced with deliveries and let v0 be the service depot. Also associated with each vertex vjis a non-negative demand dj. This value is given each time a delivery is made. For the depot v0 there is a zero demand d0.The set E represents the set of roads that connect the customers to each other and the depot. Thus each edge e ∈ E is defined as a pair of vertices (vi, vj). Associated with each edge is a cost ci, jof the route between the two vertices.Finally there is also a set of unlimited trucks each with same loading capacity. The aim is to service all the customers visiting them once only and using as few trucks as possible. In any potential delivery round a customer’s demand has to be taken into account. The total demands of customers on the round must not exceed the capacity of the vehicle. This means that it is normally not possible to visit all customers with one truck. As a consequence each delivery round for a truck is called a route.The goal of the CVRP problem is to minimise the overall travelling distance to service all customers with varying demand using a given number of trucks, each with the same fixed capacity.This problem is NP-Hard Garey and Johnson (1979).We used the following benchmark instances for testing the experiments described in Section 5. For PFSP, we selected 12 benchmark problems from Taillard (1993). Each Taillard PFSP benchmark instance is labelled astaiX_j_m,where X is the instance number and (j, m), where j indicates the number of jobs, and m the number of machines. In order to facilitate our analysis, we selected 12 of the harder instances as follows: two from the (50, 20) pool, two from the (100, 20) pool and then three from the (200, 10) and (200, 20) pools and finally three from the (500, 20) pool of instances for which an optimal solution is not known. For CVRP, we tested 12 problems from the benchmarks of Augerat et al. (1995). Each instance of this benchmark is denoted as A-nM-kL, where M and L indicate the number of delivery points including the depot and the target number of routes, respectively.We describe a general agent-based distributed framework where each agent implements a different metaheuristic/local search combination. An agent continuously adapts itself during the search process using a cooperation protocol based on the retention partial solutions deemed as possible constituents of future good solutions. These are shared with the other agents.The framework makes use of two types of agent: launcher and metaheuristic agents.•The launcher agent is responsible for queueing the problem instances to be solved for a given domain, configuring the metaheuristic agents, successively passing a given problem instance to the metaheuristic agents and gathering the solutions from the metaheuristic agents. To achieve this it converts domain specific problem instances into the agent messaging protocol using an ontology for scheduling and routing (see Section 3.2). However the launcher agent plays no actual part in the search, its job is to prepare and schedule problems to be solved by the other agents.A metaheuristic agent executes one of the metaheuristic/local search heuristic combinations that are available. These combinations and their parameter settings are all defined on launching. In this way each agent is able to conduct searches using different combinations and parameter settings from the other agents employed in the search. Each metaheuristic agent conducts its search using the messaging structure defined in the ontology for scheduling and routing and uses no problem specific data and as such is generic.A search proceeds with the launcher reading a number of problem instances into memory. It converts them into objects that can be defined by the Ontology for scheduling and routing (Section 3.2 below) and then sends each object, one at a time, to the metaheuristic agents to be addressed. For a given problem instance, the metaheuristic agents participate in a communication protocol which is in effect a distributed metaheuristic that enables them to search collectively for good quality solutions. This is a sequence of messages passed between the metaheuristic agents and each message is sent as a consequence of internal processing conducted by each agent. One iteration of this protocol is called a conversation and is based upon the well-known contract net protocol (FIPA, 2009). In order to arrive at a good solution the agents will conduct 10 such conversations.To understand the pattern matching protocol it is necessary to explain the proposed model for scheduling and routing used throughout the framework.The ontology (Gruber, 1993) plays an important role within our framework. It defines a set of general representational primitives that are used to model a number of scheduling and routing problems. The communication protocol and the heuristics are all based on data structures developed from these primitives. This means the framework is modular in that new (meta)heuristics can be easily developed and then deployed on different problems.The ontology used by the framework generalises these notions as abstract objects.•SolutionElements: A SolutionElement is an abstract object that can represent a problem specific object such as a job in PFSP or, a customer or depot in CVRP.Edge: An Edge object contains two SolutionElements objects. These are used to represent pairs of jobs or customers in a permutation that will be in the cooperation protocol to identify good patterns in improving permutations.Constraints: The Constraints interface is between the high level framework and the concrete constraints used by a specific problem. These are used to verify a valid permutation.NodeList: A NodeList object is a list of SolutionElements objects or Edges. It represents a schedule of jobs in the PFSP. In the case of CVRP, a NodeList represents a Route and is therefore a sub-list of a full permutation.SolutionData: A SolutionData object is a list of NodeList objects and therefore is the permutation that is optimised by the framework. In this study it represents a schedule of jobs in PFSP, or a collection of routes in CVRP.All message passing in the framework, including the whole ontology, is written in XML. This can be advantageous as many benchmark problems are also in XML making the interface between problem definition and ontology seamless in practice. Fig. 1shows the structure of the ontology and how SolutionElements are the interface between the framework and a concrete problem.The framework features a method of Edge selection and short-term memory. A conversation, as has been explained already, is a type of distributed heuristic. Its purpose is to identify constituent features of incumbent solutions that are likely to lead to the building of improving solutions.This is achieved by using objects defined in the ontology. The solutionData object in the ontology is built from the sub-objects of NodeLists and Edges and SolutionElements. Thus, to represent a permutation of n jobs for PFSP, a SolutionData object is built from one NodeList object and which itself is made upn−1Edge objects which are themselves built from n SolutionElements. Similarly a CVRP representation of n customers is one Solution Data object with x (this number is determined during the search) NodeLists. The NodeLists are built ofn−1Edges and n SolutionElements.If we take a permutation of the unique ID numbers of each the SolutionElements objects we can represent a SolutionData object with 10 elements as follows: (3, 4, 6, 7, 5, 8, 9, 0, 1, 2). Furthermore we can break this permutation into a collection of Edge objects:(3,4),(4,6),(6,7),(7,5),(5,8),(8,9),(9,0),(0,1),(1,2),(2,3)During a conversation, each agent runs its metaheuristic and produces a new incumbent solution. Each agent then breaks this solution into Edge objects and sends then to one of the metaheuristic agents that has been designated as the “initiator” for the duration of that conversation only. All metaheuristic agents are exactly the same and have the potential to take on the role of an initiator in a conversation.The initiator agent collects all the Edge objects from all the other agents into a list and scores them by frequency. Here, frequency is the number of times an Edge appears in the initiators list. The only Edge objects that are retained are the ones that have the same score as the number of agents that are participating in the conversation. The idea here is that if an Edge occurs frequently in all incumbent solutions, it is likely to be an Edge that will be part of an improving solution. These retained good Edges are then shared by the initiator with the other agents.Another feature is the learning mechanism where each agent keeps a short-term memory of good Edges. This is a queue of good Edges that operates somewhat like a Tabu list. An agent’s queue is populated during the first conversation with edges from the incumbent solution produced by its metaheuristic. Thereafter the queue is maintained at a factor, that is 20 percent, of the size of the candidate solution for the problem instance at hand. In subsequent conversations, as new edges not already in the list arrive, they are pushed onto the front of the queue while other edges are removed from the back of the queue so that the size of the list does not change.The Edges in the short-term memory are used at the start of each conversation to modify the performance of the agent’s metaheuristic to enable it to find better solutions.The basic idea of this learning mechanism is that both the RandNEH and RandCWS heuristics of Juan et al. (2015) used in this study make use of ordered lists to construct new solutions. These heuristics use biased random functions to choose items from these lists. We use the Edges identified by the learning mechanism to reorder these lists and so influence the way new solutions are constructed.

@&#CONCLUSIONS@&#
