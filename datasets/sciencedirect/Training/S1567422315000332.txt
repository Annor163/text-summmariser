@&#MAIN-TITLE@&#
A Secure M-Commerce System based on credit card transaction

@&#HIGHLIGHTS@&#
The SMoSS does not require extra restrictions and resources on cash flow.Credit card fraud can be effectively avoided.Our analysis shows that the SMoSS is indeed a feasible mobile shopping system.The SMoSS can still protect a mobile phone, even the mobile phone is lost.The SMoSS can ensure the communication privacy, integrity, and non-repudiation.

@&#KEYPHRASES@&#
M-commerce,Binary adder,Data Connection Core,Secure Sockets Layer,Secure Electronic Transaction,

@&#ABSTRACT@&#
Nowadays the demands for wireless Internet shopping are increasing. But credit card fraud has been serious, and SET and SSL have their own problems. To enhance the security of online shopping, in this paper, we propose a secure m-commerce scheme, called the Secure M-Commerce System (SMCS for short), with which users can create a safe credit-card transaction for Internet shopping. Basically, the SMCS coordinates the cash flow of a trading system and its credit card entities to effectively protect the issued transactions against different attacks and avoid information leakage. The proposed system also employs a Data Connection Core (DCC for short) to link the card-issuing bank and consumers before their wireless communication starts so as to significantly improve the security level of our m-commerce environment. Theoretical analysis shows that the SMCS is more secure than SET and SSL. The performance analysis indicates that the SMCS is indeed a feasible m-commerce system.

@&#INTRODUCTION@&#
Recently, the convenience and security of wireless communication have been greatly improved (Nabi 2005). Many people enjoy online shopping with their credit cards. But due to the infrastructure of a wireless system, the transactions issued are created via wireless. On the other hand, credit card fraud nowadays is serious (Mahmoudi and Duman 2015; Gold 2014), which significantly reduces online shopping attraction for some people. Also, owing to vigorous development of wireless networks, current mobile devices, such as mobile phones, tablet PCs and laptops, have provided users with diverse features and services, which have colored our everyday life and gradually changed people’s shopping habits. Generally, a secure credit-card mechanism for m-commerce should securely protect the corresponding transactions and personal information. At present, when shopping in a wireless environment, e.g., to pay something by using the Secure Sockets Layer (SSL), one must send the card number, expiration date and other information to the merchant. In fact, SSL can ensure peer-to-peer delivery safety, but it cannot confirm the identities of the underlying users (Oppliger et al. 2008; Das and Samdaria 2014).To solve this problem, the Card network organizations Visa and MasterCard put forward an electronic payment system specification for Secure Electronic Transaction (SET) (Lu and Smolka 1999). However, SET has its own problem, e.g., a consumers needs to apply for a certificate (Bella et al. 2003). That means on user side, the corresponding information of the credit card must be stored in a hard disk. Also, to improve its security level, SET takes a long time to calculate complicated asymmetric encryption and decryption key (Shedid and Kouta 2010; Yong and Jindi 2010), thus giving users an inconvenient m-commerce experience. Today, the increasing demands for m-commerce motivate us to construct a safe and convenient m-commerce mechanism. Therefore, in this study, we propose a secure m-commerce scheme, named the Secure M-Commerce System (SMCS for short) which coordinates the cash flow of a trading system and credit card entities to develop a safe and convenient m-commerce environment for users, without increasing extra restrictions and resources on the cash flow and credit card entities. Basically, we produce a credit-card dynamic authentication code to substitute for the credit card information so that the trading merchant cannot know the credit card number and its details. The SMCS also employs a Data Connection Core (DCC for short) to link the card-issuing bank and consumers before their wireless communication starts. Furthermore, the card-issuing bank authenticates the credit card’s dynamic authentication code and merchant’s dynamic authentication code rather than directly authenticating the credit card and merchant information. This can efficiently make sure the legitimation of the consumer and trading merchant so as to effectively increase the security level of the SMCS. Theoretical analysis shows that the SMCS is more secure than SET and SSL. The performance analysis indicates that the SMCS indeed a feasible m-commerce system.The rest of this paper is organized as follows. Section 2 introduces background and related work of this study. Section 3 describes the proposed system. Performance and security are analyzed and discussed in Section 4. Section 5 concludes this paper and outlines our future studies.Generally, the most important feature of a credit-card transaction is to transform the relationship on trading from “seller to buyer” into a series of contractual relations. Due to away from face-to-face purchase, the authorization and security will be the two major concerns. In such a transaction, after confirming the identity of a buyer, the seller receives guaranteed payment from the acquiring bank, and the acquiring bank also receives guaranteed payment from international organizations. The card-issuing bank then judges the authorization of the payment based on the payer’s up-to-date credit, and promises to fulfill the payment to the international organizations. Finally, the credit card holder (buyer) is obligated to settle the money with the card-issuing bank based on his/her credit-card contract. This seemingly complicated process, in fact, greatly simplifies the trading relationships between buyers and sellers, because the time difference between the payment and settlement system is no longer a problem, and the information flow and cash flow are separated when the bank and the new contractual relationship intervene (CreditCards.com, http://www.creditcards.com/). Also, the corresponding information flow can be recognized by the merchant immediately to authorize the transaction. Although the seller is requested to pay around 3% of total trading amount of price, this mechanism can greatly increase sale opportunities.Meanwhile, the merchant is licensed with a message to confirm whether the transaction is completed, and authorization is only an instant of the information flow. Regarding the cash flow, for each day, all the network transactions from different participating member banks will be calculated later by the international organizations. After the member banks are recognized on the date of the network shopping, they will use the “real-time gross settlement system” to transfer the funds to the international organizations, and the international organizations transfer funds to the card-issuing bank. From this moment, you can say that the importance of the role a bank plays in this process is lower, since cash flow is really performed sometimes later after the information flow, and the purchase is completed after the accomplishment of information flow. VISA proves a thing “the information of money is sometimes more important than the money itself!”SSL has two main features. The first is the use of a public-key and private-key mechanism to connect two sides of a network connection. With this mechanism, they can securely exchange encrypted messages with each other. The second is making use of the third party certification to enable both sides of the connection to confirm each other’s information (Bicakci et al. 2014; Badra and Urien 2004).SSL secures electronic transaction specification by using the consumer’s credit card number and expiration date or cardholder relevant information as the certification parameters, and transmits encrypted messages to the merchant. The merchant reuses the encrypted messages to request card-issuing bank for payment. The consumers prefer this way, because the system does not request users applying for an electronic wallet and a safety certification from the card-issuing bank.But SSL has two shortcomings. The first is that the two sides of an SSL connection can only determine whether or not the other side is allowed to use the SSL mechanism. That means the consumer does not know who the merchant is, a legitimate merchant or a hacker. The merchant does not know the identity of the consumer, either, and also cannot confirm whether the consumer’s credit card number is correct or not (Bisel 2007).The second is that although SSL is convenient for consumers to perform Internet shopping through a wireless system, when SSL is invoked by a transaction, the card number and cardholder’s related information can be clearly seen on the merchant side, thus possibly being unscrupulous businesses use. Besides, if the card number and other relevant information are stolen by hackers, they may be illegally used for Internet shopping, causing the loss upon not only the cardholder, but also the merchant who would lose the unpaid products if the cardholder submits relevant evidences to deny this transaction. When SSL completes a transaction, the merchant cannot determine whether this transaction is completed before receiving the receipt from the funding or certified bank. The SSL handshake process on Credit card transaction has four stages (Zhao and Liu 2009; Du et al. 2009; Petridou and Basagiannis 2012). In the first stage, consumer informs merchant what version of the SSL, an encryption-algorithm list and a compression-algorithm list that his/her terminal device supports. The merchant chooses the highest versions of SSL, an encryption algorithm and a compression algorithm for use. In the second stage, the merchant sends his/her own certificate and Diffie–Hellman’s public key to the consumer. In the third stage, the consumer delivers its own certificate and Diffie–Hellman’s public key to the merchant. With merchant’s (consumer’s) public key and consumer’s (merchant’s) own private key, consumer (merchant) can derive the Diffie–Hellman common secret key. In the fourth stage, a message is transmitted from acquiring bank to the merchant to prove that the key exchange and authentication process has been successfully completed.SET was jointly developed by the VISA, MasterCard, IBM and other organizations (Venkataiahgari et al. 2006). Like SSL, it uses the public key and private key as the basis to secure message exchange process. However, SET requires that both consumer and merchant apply for SET’s certification and obtain the SET’s electronic certification and software from card-issuing bank, and then use the software to complete a transaction online.The greatest advantage of SET, unlike that in SSL, is that both trading sides of a connection can confirm each other’s identity. In addition, SET can protect consumers’ credit data, since the merchant only requires the consumer’s SET credential before it can bill the card-issuing bank (Guan 2009; Li 2008; Sherif et al. 1998).With the SET mechanism, if a consumer wants to transact, his/her computer needs to install electronic wallet software (Chaudhary et al. 2014), which like a real purse, is responsible for the storage of electronic cash. Before the transaction, the consumer has to first withdraw some amount of electronic cash from the bank. The bank then verifies the identity of the consumer, deducts the amount of money from the consumer’s account, and deposits the amount of electronic cash to the consumer electronic wallet. After that, the consumer can purchase goods from manufacturers or shops. The above process is not very friendly to consumer since it is not an “enjoy-first-pay-later” mechanism. It has not achieved the stage of convenience for m-commerce anywhere (Chaudhary et al. 2014).The binary adder, denoted by +2, is a new encryption method, which adds two binary numbers of the same length. When encrypting one of its two operands X (which is the plaintext) with the other operand K (which is the encryption key), it undergoes normal binary addition of X and K to generate ciphertext C, but ignores the overflow bit. To decrypt C, it compares C and K. If K is smaller, it binary subtracts K from C. Otherwise, it adds the two’s complement of K to C. Also, assume that both the two binary numbers X and K are m bits in length, then the probability p of recovering the values of (X,K) from intercepted X+2K on one trial is p=1/2m(Huang et al. 2013; Huang et al. 2015). This encryption method provides a new choice for encrypting data (e.g., X) by using a key K. If we employ both the binary adder and exclusive-or operators to encrypt data, the security level of the underlying system will be greatly enhanced.From security viewpoint, in a wireless communication environment, there are two basic characteristics. (1) Wirelessly transmitted messages are insecure since hackers, the wireless system’s legitimate staffs and users can receive the messages at the same time. (2) A wireless system needs to confirm the identities of those presented correspondents. If the system and one of its users do not have any link before their wireless communication, the two entities at the beginning of their communication cannot create a secure channel for exchanging messages. Of course, the two entities also cannot mutually confirm each other’s identities by exchanging safe messages. This will cause serious problems, like credit card fraud or communication data leakage (Wei et al. 2013).One of the methods to solve this problem is establishing an identity authentication mechanism between the two entities beforehand. We call the security mechanism the DCC, which is used to pre-link the wireless system and its users. For different security systems and communication mechanisms, DCC has different contents. In this system, DCC is used to link the consumer and card-issuing bank.In this section, we will introduce the SMCS. Section 3.1 describes system parameters and functions employed in the SMCS. Section 3.2 presents the system pre-procedure before wireless communication starts. Section 3.3 lists the trading steps and their working principles.The system parameters utilized in the SMCS are listed below.(1)UserID: consumer’s ID.e, d, N: RSA encryption/decryption keys for an individual consumer.Card No: the credit card number of the consumer.CAK: the consumer’s authentication key.MAK: the merchant’s authentication key.BAK: the card-issuing bank’s authentication key.PW: the password given by the consumer.Kpw: the password key derived from PW through a one-way hash function.Data Connection Core: (DCC): the set of parameters that pre-link the consumer and card-issuing bank.On the mobile device side: UserID, e, N, KPW, CAK.On the card-issuing bank side: UserID, e, d, N, Credit-Card No., PW, KPW, CAK.Xa, Xa1, Xa2, Xa3: the consumer’s private keys.PXa: the consumer’s public key.Xb,Xb1: the merchant’s private keys.PXb: the merchant’s public key.CSK: the common secret key shared by the consumer and merchant.Credit card’s dynamic authentication code: EAES(Xa3⊕CAK; Xa2).Merchant’s dynamic authentication code: EAES(Xa1⊕MAK; CSK).Consumer’s order number: the number generated by the merchant for the consumer’s m-commerce order.Mdate, Mtime: the date and time on merchant side when it receives the consumer’s m-commerce order.Pre-purchase items: the format is the consumer’s order number//Mdate//Mtime//shopping list, where // represents concatenation.Consumer’s order confirmation message: the format of this message is the consumer’s order number//Mdate//Mtime//merchant’s code, where the merchant’s code is an authorization code issued by the merchant’s acquiring bank.Shopping association message: the format is consumer’s order confirmation message//business registration certificate//shopping items detail//total amount//merchant’s acquiring bank’s code//POS No.//EAES(Xa1⊕MAK; CSK), where business registration certificate is issued by a trustable organization or government.M-commerce payment request message: the format is CSK//Xa1//EAES(Xa1⊕MAK; CSK)//consumer’s order confirmation message//business registration certificate//total amount//merchant’s acquiring bank’s code//POS No.Tnonce: the timestamp of current time.KCT: A current–time encryption key which is defined as a sequence obtained by concatenating the following current–time items, including nanosecond, second, minute, hour, month, and year, and duplicating the above sequence again when necessary to make |KCT|=the key length of the underlying system.Trading result message: indicating the trading success or failure. If it is trading failure, the reason is then generated and added.Bdate,Btime: the date and time when the card-issuing bank authorizes a transaction.The functions employed by the SMCS are defined below.(1)Exclusive-or operator ⊕:Encryption: c=p ⊕ K.Decryption: p=c ⊕ K.Binary adder operator +2:Encryption: c=p +2K, where plaintext p and encryption key K undergo the binary addition, ignoring the overflow bit.Decryption:p=c-2K=c-K,ifc≧Kc+K‾+1,ifc<Kwhere -2 denotes the binary subtraction, andK‾is the one’s complement of K.RSA encryption/decryption function:Encryption: RSA_En(x, e)=xemod N, where x is a random key.Decryption: RSA_En(y, d)=ydmod N, where y=RSA_En(x, e).En1(a, b; x)= (x⊕a)+2b, where x is the a key to be protected, and a and b are encryption keys.InvEn1(a, b; y) = (y-2b)⊕a is the inverse function of En1(), where y=En1(a, b; x).En2(a, b; str)= (s1⊕a)+2b // (s2⊕a)+2b // (s3⊕a)+2b //...// (sn⊕a)+2b, in which a and b are encryption keys and str=s1 // s2 // s3 //…// sn.InvEn2(a, b; Cstr)= (cs1-2b)⊕a // (cs2-2b)⊕a // (cs3-2b)⊕a //…// (csn-2b)⊕a, in which a and b are decryption keys and Cstr=En2(a, b; str)=cs1 // cs2 // cs3 //…// csn.EAES(y⊕AK; x): x is the plaintext to be encrypted, y is a random parameter, and AK is the authentication key. Each time before encryption, y is first exclusive-oved with AK to generate a dynamic encryption key, which is utilized as the AES’s parent key. Then x is encrypted by AES to generate EAES(y⊕AK; x).For example: in this system, the credit card’s dynamic authentication code EAES(Xa3⊕CAK; Xa2) as shown in Fig. 1is generated by invoking AES and inputting the consumer’s random dynamic key Xa2and the result of exclusive-oring Xa3and the consumer’s authentication key CAK.OP_Code: In the SMCS, different messages are generated for different purposes. Each message has its own unique operation code (OP_code for short) to indicate the designate function of the message. It can reduce the authentication time and complexity. Table 1lists definitions of the employed OP_codes.Status: each subsystem installed in the consumer, merchant, and card-issuing bank has its own internal parameter (i.e., status), which is used to indicate the state that the SMCS will achieve at the next moment. When status is used in conjunction with OP_Code, they can effectively improve system performance on certification, and protect the underlying system against replay attacks. Table 1 also lists the statuses and their descriptions.HMAC(K): a specific integrity function employing a cryptographic hash function and a secret key K to produce a hash-based message authentication code (HMAC for short) which ensures accuracy, integrity, and non-repudiation of the corresponding message (Naqvi and Akram 2011; Najjar and Najjar 2006).Each of card-issuing bank, merchant and consumer has its own pre-procedure.The card-issuing bank initially submits an identity-authentication-key application to the CA. CA generates an authentication key BAKand sends the key to the card-issuing bank. After that, the card-issuing bank and CA establish a communication channel by using BAKand communicate with each other through the channel.The merchant who has a qualified Business registration certificate issued by government (or a trustable organization) sends a message to CA to apply for an identity authentication key. After inspecting the application documents and confirming that the merchant is a legitimate company, CA creates an authentication key MAKand deliveries the key to the merchant. After that, CA periodically contacts the merchant to make sure the legitimation of the merchant.The consumer’s pre-procedure has three steps.(1)The consumer applying for the DCC from the card-issuing bank.The consumer applies for a DCC from the card-issuing bank with over-the-counter service. But, the consumer needs to provide his/her personal information, including user name, personal ID, birthday, residence address, email address, photocopy of the front and back of him/her identity card (in Taiwan), proof of financial statement and his/her own password (PW).Generating the DCCIf the card-issuing bank confirms the identity of the credit card owner, then depending on the consumer’s credit card number and password, the bank creates the consumer’s DCCs, issues the consumer’s DCC, i.e., (UserID, e, N, KPW, CAK), to the consumer’s mobile device, and keeps the DCC for the consumer, i.e., (UserID, e, d, N, Card No., PW, KPW, CAK), in its local database.The m-commerce APP program is downloaded to the mobile device.Fig. 2illustrates an overview of the communication steps of the SMCS. Steps 1.1–1.4 comprise the m-commerce order confirmation stage. Steps 2.1 and 2.2 are the m-commerce payment stage. The card-issuing bank authorization stage includes Steps 3.1 and 3.2. Step 4 itself is the electronic invoice delivery stage.Pre-procedure for m-commerce:(1)When the mobile device is in its standby mode, it activates the m-commerce APP installed in it.Visiting and browsing the merchant’s web page under the guidance of the APP.Step 1.1: The consumerAfter browsing the merchant’s web page, the consumer moves all his/her favorite products into the shopping cart, and sends a message, denoted by Message 1 carrying the shopping list, to the merchant. The format of this message is as follows:OP-code|PXa| shopping list,in which OP-code=1, and PXais the consumer’s public key. Also, the consumer’s status is set to 2.Step 1.2: The merchantAfter receiving this message, the merchant uses its own private key Xband the consumer’s public key Pxato calculate the common secret key CSK, whereCSK=PXaXbmodp, and sends a m-commerce reply, denoted by Message 2, to the consumer. The format of Message 2 is as follows:OP-code|PXb|CSK⊕Xb1|En2(CSK, Xb1; pre-purchase items)|HMAC(CSK+2Xb1),in which OP-code=2. The merchant then sets status to 3 as the status of the consumer’s m-commerce order.Step 1.3: The consumerAfter receiving Message 2, the consumer checks to see whether OP-code=?status. If not, it discards this message and waits for a valid one. Otherwise, the consumer knows that the message is a m-commerce reply and then computes CSK whereCSK=PXbXamodp. The consumer further decrypts CSK⊕Xb1 by using CSK to obtain Xb1 and verifies the message by checking to see whether HMAC(CSK+2Xb1)c=?HMAC(CSK+2Xb1)rwhere the subscript c means that the HMAC() is derived from the consumer’s internal parameters, and the subscript r represents that the HMAC() is retrieved from Message 2. If they are not equal, the consumer discards this message and waits for a valid one. Otherwise, the consumer uses CSK and Xb1 to decrypt En2(CSK, Xb1; pre-purchase items) to recover the pre-purchase items which include the consumer’s order number, Mdate, Mtimeand shopping list. If the consumer does not confirm the list, the process goes back to Step 1.1. Otherwise, the consumer sends Message 3 to the merchant. The format of this message is as follows.OP-code|consumer’s order number|En1(CSK, Xb1; Xa1)|En2(CSK, Xa1; consumer name//delivery address//shopping items detail//consumer phone number)|HMAC(Xa1+2CSK)in which OP-code=3. The consumer’s status is then set to 4.Step 1.4: The merchantWhen receiving Message 3, the merchant retrieves the Consumer’s order number from this message and the consumer’s status, and tests whether OP-code=?status. If not, the merchant discards the message and waits for a valid one. Otherwise, meaning this is a m-commerce order, the merchant decrypts En1(CSK,Xb1; Xa1) by using CSK and Xb1 to obtain Xa1, and certifies the message by testing whether HMAC(Xa1+2CSK)c=?HMAC(Xa1+2CSK)rwhere the subscript c means HMAC(Xa1+2CSK) is calculated by using the merchant’s internal parameters, and the subscript r represents that HMAC(Xa1+2CSK) is retrieved from Message 3. If they are not equal, the merchant discards this message and waits for a valid one. Otherwise, the merchant uses CSK and Xa1 to decrypt the message to obtain the consumer name, delivery address, shopping items detail and consumer phone number. It then sends the m-commerce order confirmation message (Message 4) to the consumer. The format of Message 4 is as follows.OP-code|En2(Xa1, Xb1; shopping association message)|HMAC((CSK⊕Xb1)+2Xa1) in which OP-code=4. The merchant’s status is set to 5.Step 2.1: The consumerWhen receiving Message 4, the consumer tests whether OP-code=?status. If not, the consumer discards the message and waits for a valid one. Otherwise, showing that the message is the m-commerce order confirmation, the consumer certifies the message by testing whether HMAC((CSK⊕Xb1)+2Xa1)c=?HMAC((CSK⊕Xb1)+2Xa1)rwhere the subscripts c and r are respectively the same as those mentioned above. If they are not equal, the consumer discards this message and waits for a valid one. Otherwise, he/she uses Xa1 and Xb1 to dcrypt En2(Xa1, Xb1; shopping association message) to obtain shopping association message which contains the consumer’s order confirmation message, business registration certificate, shopping item detail, total amount, merchant’s acquiring bank’s code, POS No., and EAES(Xa1⊕MAK; CSK). If the consumer confirms the information and is ready to purchase, the m-commerce APP will ask the consumer to input his/her own password (PW), accordingly compute the corresponding password key Kpw,cbased on the established algorithms beforehand and then compare the key with Kpw, i.e., the consumer’s password key stored in the DCC. If they are not equal, the APP asks the user to input the password again. If the user cannot pass the authentication for three times, the system will shut off the m-commerce APP. If login is successful, the consumer sends the m-commerce payment request message, denoted by Message 5, to the card-issuing bank. The format of this message is as follows.OP-code|Tnonce|UserID|RSA_En(Xa2,e)|En1(Xa2, Xa2⊕Kpw; Xa3)|En2 (Xa2, Xa3⊕KCT; m-commerce payment request message)|Xa1⊕EAES(Xa3⊕CAK, Xa2)|HMAC((CSK⊕Xa2)+2Xa3) in which OP-code=5. The consumer’s status is set to 6.Step 2.2: The card-issuing bankUpon receiving Message 5, the card-issuing bank retrieves the consumer’s status (the value is 5) stored in the card-issuing bank’s system based on the UserID, and tests whether OP-code=?status (the first authentication). If not, the card-issuing bank discards the message and waits for a valid one. Otherwise, the card-issuing bank verifies Treceived−Tnonce<ΔT (the second authentication). If not, it discards the message. If yes, it derives KCTfrom Tnonce. Furthermore, by UserID, the card-issuing bank retrieves the consumer’s RSA encryption/decryption key (e, d, N) from the consumer’s DCC, decrypts RSA_En(Xa2,e) to obtain Xa2, decrypts En1(Xa2, Xa2⊕Kpw; Xa3) by using Xa2 and Kpwto recover Xa3, and at last decrypts En2(Xa2, Xa3⊕KCT; m-commerce payment request message) by utilizing Xa2, Xa3 and KCTto obtain the m-commerce payment request message which conveys CSK, Xa1, EAES(Xa1⊕MAK, CSK), consumer’s order confirmation message (from which to retrieve consumer’s order number), business registration certificate, total amount, merchant’s acquiring bank’s code and POS No. It performs the third authentication by testing whether HMAC((CSK⊕Xa2)+2Xa3)c=?HMAC((CSK⊕Xa2)+2Xa3)r. If they are not equal, the bank discards this message and waits for a valid one. Otherwise, according to the business registration certificate, the card-issuing bank retrieves MAKfrom its database. If MAKdoes not exist in its database, the bank will ask CA for MAK, and store it in the card-issuing bank’s database. After obtaining MAK, the card-issuing bank performs the fourth authentication by checking to see whether EAES(Xa1⊕MAK, CSK)c=?EAES(Xa1⊕MAK, CSK)r. If they are not equal, it discards this message and waits for a valid one. Otherwise, the card-issuing bank uses Xa1 to decrypt Xa1⊕EAES(Xa3⊕CAK, Xa2) carried in Message 5 to obtain the credit card’s dynamic authentication code EAES(Xa3⊕CAK, Xa2)r, retrieves CAKfrom the consumer’s DCC to generate EAES(Xa3⊕CAK, Xa2)c, and then performs the fifth authentication by testing whether EAES(Xa3⊕CAK, Xa2)c=?EAES(Xa3⊕CAK, Xa2)r. If they are not equal, the bank discards the message and waits for a valid one. Otherwise, the bank retrieves the consumer’s credit card number from the consumer’s DCC. After checking the consumer’s credit, the card-issuing bank determines whether to authorize the transaction. Also, no matter whether the transaction is successfully authorized or not, the card-issuing bank will inform the consumer of the trading results by sending the m-commerce payment reply (Message 6) to the consumer. The format of Message 6 is as follows.OP-code|En2(CSK, Xa1; consumer’s order confirmation message//trading results message//Bdate//Btime) |HMAC(Xa3⊕Xa2), in which OP-code=6. The card-issuing bank further sends Message 7 to the acquiring bank. The acquiring bank will transfer this message to inform the merchant of the trading results. If the transaction fails, the card-issuing bank provides reasons for the failure in Message 7. The format of this message will be described later.When receiving Message 6, the consumer tests whether OP-code=?status. If not, the consumer discards the message and waits for a valid one. Otherwise, meaning the message is the m-commerce payment reply, the consumer certifies the message by testing whether HMAC(Xa3⊕Xa2)c=?HMAC(Xa3⊕Xa2)r. If they are not equal, the consumer discards this message and waits for a valid one. Otherwise, the consumer employs CSK and Xa1 to decrypt the message to obtain the consumer’s order confirmation message, trading results message, Bdateand Btime. If the transaction fails, the reason for the failure is shown and this transaction is terminated. Otherwise, the consumer sets status=8, and waits for the merchant to send the electronic invoice.Step 3.1: The card-issuing bankThe card-issuing bank payment message (Message 7) is sent by the card-issuing bank to the acquiring bank via a wired credit-card communication channel. Therefore, the message and content are encrypted by using the channel’s encryption method. The format of this message is as follows.OP-code|consumer’s order confirmation message|POS No.|trading results message|card number|authorization code|total amount|Bdate |BtimeIn which OP-code=7.Step 3.2: The acquiring bankWhen the acquiring bank receives Message 7, it identifies the merchant of this transaction based on the merchant’s code and POS No., and then transfers the message to the merchant to inform him/her of the trading results (Message 8). The format of this message is as follows:OP-code|consumer’s order confirmation message|authorization code|trading results message|Bdate|Btime|POS No.In which OP-code=7. When receiving the message, this merchant retrieves this transaction’s status according to the consumer’s order number (carried in consumer’s order confirmation message), and tests whether OP-code=?status. If not, the merchant discards the message and waits for a valid one. Otherwise, the merchant knows that the message is the card-issuing bank payment, which includes the trading results. If the transaction fails, the merchant terminates this transaction. Otherwise, products and the electronic invoice are shipped to the consumer by executing Step 4.Step 4 The merchantThe merchant sends the electronic invoice (Message 9) to the consumer. The format of this message is as follows:OP-code|electronic invoice|HMAC(CSK+2Xa1⊕Xb1)in which OP-code=8. The merchant also sets status of the consumer’s order number to 9. After receiving the message, the consumer tests whether OP-code=?status. If not, the consumer discards the message and waits for a valid one. Otherwise, the consumer tests whether HMAC(CSK+2Xa1⊕Xb1)c=?HMAC(CSK+2Xa1⊕Xb1)r. If not, the consumer discards the message and waits for a valid one. Otherwise the consumer saves the electronic invoice, and sets status=9 to complete this transaction.In the following, we will analyze and discuss features of the SMCS on security and performance.

@&#CONCLUSIONS@&#
