@&#MAIN-TITLE@&#
Fast approximation algorithms for bi-criteria scheduling with machine assignment costs

@&#HIGHLIGHTS@&#
A framework allowing for trade-offs between time-related and cost-related objectives.Analysis of bi-criteria scheduling problems that involve timings as well as costs.Prioritization schemes providing intuition and insights into schedules generated.Tight worst case ratios of proposed heuristics.

@&#KEYPHRASES@&#
Bi-criteria scheduling,Maximum machine cost,Total machine cost,Makespan,Total completion time,Heuristics,

@&#ABSTRACT@&#
We consider parallel machine scheduling problems where the processing of the jobs on the machines involves two types of objectives. The first type is one of two classical objective functions in scheduling theory: either the total completion time or the makespan. The second type involves an actual cost associated with the processing of a specific job on a given machine; each job-machine combination may have a different cost. Two bi-criteria scheduling problems are considered: (1) minimize the maximum machine cost subject to the total completion time being at its minimum, and (2) minimize the total machine cost subject to the makespan being at its minimum. Since both problems are strongly NP-hard, we propose fast heuristics and establish their worst-case performance bounds.a¯†:a1=⋯=am-1=1,am>1.ρ‡: an approximation ratio for the parallel machine scheduling problem to minimize the makespan.

@&#INTRODUCTION@&#
In traditional scheduling theory, most problems are concerned with the minimization of certain functions of the completion times of the jobs. This type of objectives relate in certain ways to customer satisfaction since they tend to result in schedules that have either early completion times or on-time completions of the jobs. In reality, there are other important aspects in the evaluation of schedules, namely, aspects that are related to the machines themselves. When a job is assigned to a machine, the assignment results in a cost (or profit) that depends on the job as well as on the machine. The machines’ objective may be the minimization of the total cost incurred by all the machines or the maximum cost incurred by any machine.This type of multi-criteria scheduling problem occurs nowadays quite often in manufacturing as well as in services industries. Consider, for example, a manufacturing company with multiple plants in different locations. The production cost of a customer order at one plant may be completely different from the production cost at another plant. The company has to worry about the timing of the production (in order to provide good customer service) as well as the production cost (in order for the company to remain profitable).In the services industries also, such multi-criteria scheduling problems have become more and more important in recent years. Consider, for example, an organization that provides professional services and has, say, m service providers (e.g., medical doctors, teams of consultants, lawyers, etc.) and n tasks (e.g., patients, projects, legal cases, etc.). Each task has to be handled by one of the service providers. A service provider could be regarded as a “machine” and a task may be regarded as a “job”. The service providers in such an environment are typically not identical, i.e., different providers have different skill sets and different experience levels and charge therefore differently. The tasks may also be different in such a way that each may require a provider with a specific skill set. From the organization’s point of view (e.g., a clinic, a consulting company, a legal firm, etc.), the objective is to minimize the total completion time of the tasks or to minimize the latest completion time so as to increase the clients’ satisfaction levels, while at the same time minimize the total service providers’ cost in order to maximize the organization’s profit or minimize the maximum profit of any service provider in order to balance the profits over the service providers. Balancing the profits of the service providers is an important goal in maintaining the morale of the employees in the company.Clearly, the framework considered in this paper applies to any organization that has to assign a resource to a specific task or project while taking into account objectives related to customer satisfaction levels as well as objectives related to the costs of utilization of resources.In this paper we consider such bi-criteria scheduling problems with the second objective (either maximum machine cost or total machine cost) to be minimized subject to the constraint that the first objective (either makespan or total completion time) is at its minimum.Many papers have dealt with bi- or multi-objective scheduling problems and there are several survey papers in this area. T’kindt and Billaut (2001) and T’kindt and Billaut (2006) presented a review on scheduling problems with various different machine environments including single machine, parallel machines, and flowshop environments. Hoogeveen (2005) paid more attention to due-date related objectives and scheduling with controllable processing times. Lei (2009) provided a more recent review. Nonetheless, most research initiatives focused on two or more scheduling objectives that are all related to the customers’ perspectives. Thus, all the objectives are typically functions of the completion times.Typical examples are papers that focus on minimizing two traditional scheduling objectives. Smith (1956) considered a single machine scheduling problem to minimize the total completion time subject to the constraint that all jobs should be completed at their due dates or before. Leung and Young (1989) studied a parallel machine scheduling problem to minimize the makespan subject to the constraint that the total completion time is at its minimum. Leung and Pinedo (2003) considered a parallel machine scheduling problem to minimize the total completion time subject to the constraint that the makespan is at its minimum.Multi-objective scheduling can be found in many different settings. There are studies on agent scheduling problems that focus on multiple objectives which agents selfishly optimize; see, for example, Agnetis, Mirchandani, Pacciarelli, and Pacifici (2004), Agnetis, Pacciarelli, and Pacifici (2007), Lee, Choi, Leung, and Pinedo (2009) and Leung, Pinedo, and Wan (2010). Distributed scheduling can also lead to multi-objective scheduling problems in which each job’s objective as well as the overall objective function are optimized at the same time. Several other papers focus on coordination mechanisms; see, for example, Lee, Leung, and Pinedo (2011) and Lee, Leung, and Pinedo (2012).In the scheduling literature, there are two streams of research that deal with service providers’ objectives. The first and most popular stream involves a machine activation cost. The number of machines used is a variable and the overall objective is to minimize the sum of a traditional scheduling objective (e.g., makespan) and the cost of activating machines; see, for example, Imreh and Noga (1999) and Dòsa and He (2004).Another approach assumes a machine assignment cost. When a job is scheduled on a machine, a machine assignment cost is incurred. In most cases, the objective is either the sum of a scheduling objective and the total machine assignment cost or a prioritization of the two objectives; see, for example, Shmoys and Tardos (1993), Vignier, Sonntag, and Portmann (1999), T’kindt, Billaut, and Proust (2001), Khuller, Li, and Saha (2010), and Leung, Lee, and Pinedo (2012). Khuller et al. (2010) considered a problem with machine activation cost as well as machine assignment cost. Shmoys and Tardos (1993) formulated a general bi-objective scheduling problem with machine assignment costs as a generalized assignment problem. They considered a prioritization of the two objectives and provided an approximation approach by combining a linear programming algorithm with a rounding technique. Leung et al. (2012) described a bi-objective scheduling problem to minimize the scheduling objective and the total machine assignment cost at the same time. The makespan and the total completion time were considered as scheduling objectives and both non-preemptive and preemptive versions were dealt with. They considered weighted combinations of the two objectives as well as prioritizations of the two objectives. They restricted themselves to an analysis of the problems in terms of their time complexity under different assumptions; they proved NP-hardness for some cases and presented polynomial time algorithms for other cases.In this paper, we will follow in our problem formulations the framework presented in Leung et al. (2012). However, we consider several aspects that are different. Unlike Leung et al. (2012), we only focus on a prioritization of objectives, which implies that we try to optimize one objective first and then try to optimize the second one with the first one being at its minimum. Also, we develop approximation algorithms with their worst-case performance analyses.In Section 2, we formally describe the problem and introduce notations. We provide in Section 3 approximation algorithms for the problem in which the total completion time and maximum machine cost have to be minimized. We present in Section 4 approximation algorithms for minimizing the makespan and the total machine cost. We conclude the paper in the last section with a discussion on future research directions.We consider the problem of scheduling n jobs on m identical machines to minimize at the same time a customers’ objective and a service providers’ objective. The processing time of job j ispj. LetCjdenote the completion time of job j. The customers’ objective is to minimize either the total completion time (∑Cj) or the last completion time, commonly referred to as the makespan (Cmax). In addition, a costcijis incurred when jobj,1⩽j⩽n, is processed on machinei,1⩽i⩽m. Letxij=1if job j is processed on machine i andxij=0otherwise. Thus, the total machine cost, for short TMC, is∑i=1m∑j=1ncijxij, and the maximum machine cost, for short MMC, ismaxi=1m{∑j=1ncijxij}. The service providers’ objective is to minimize either TMC or MMC. The goal is to find a schedule that minimizes either the total completion time or the makespan in addition to the total machine cost or the maximum machine cost. We consider in what follows only nonpreemptive scheduling models. LetM={1,2,…,m}denote the set of m machines andJ={J1,J2,…,Jn}denote the set of n jobs.We consider three types of cost functions:(i)cij=cj,cij=ai+cj, andcij=ai×cj,Basically, the bi-criteria problems we study can be referred to as LEX (γ1,γ2). In LEX (γ1,γ2), theγ1represents the primary objective and theγ2represents the secondary objective; i.e., the problem is to minimize objectiveγ2subject to the constraint that objectiveγ1is at its minimum.Since we consider either∑CjorCmaxas the customers’ objective, and consider either TMC or MMC as the service providers’ (machines’) objective, we have four possible combinations: (∑Cj,MMC), (∑Cj,TMC), (Cmax, MMC) and (Cmax,TMC). Leung et al. (2012) already showed that LEX (∑Cj,TMC) can be solved optimally in polynomial time. The problem LEX (Cmax,MMC) is not completely investigated, but a special case of this problem was considered by Lee, Leung, and Pinedo (2013). In this paper we will focus on the following two problems:1.LEX (∑Cj,MMC); i.e., minimize the maximum machine cost subject to the constraint that∑Cjis minimized.LEX (Cmax,TMC); i.e., minimize the total machine cost subject to the constraint thatCmaxis minimized.The two scheduling problems above can be shown to be unary NP-hard via a simple reduction from the 3-Partition problem (Garey & Johnson, 1979). For LEX (Cmax,TMC), the primary objective can be reduced from the 3-Partition problem. For LEX (∑Cj,MMC), the secondary objective can be reduced from 3-Partition.Because of the computational complexity of the problems, we are interested in fast heuristics. We say that heuristicAis an(α,β)-approximation for problem LEX (γ1,γ2) ifAproduces a schedule whereγ1(A)⩽α×γ1∗andγ2(A)⩽β×γ2∗. Here,γ1∗is the optimal value for the first objective, andγ2∗is the optimal value for the second objective provided that the schedule attains the optimal value (γ1∗) for the first objective. For example, ifAis a(32,2)-approximation for LEX (Cmax,TMC), thenCmax(A)⩽32×Cmax∗andTMC(A)⩽2×TMC∗, whereTMC∗is the optimal value for the total machine cost provided that the makespan of the schedule isCmax∗.Shmoys and Tardos (1993) consider a bi-objective scheduling problem that is more general than those we consider; they assume processing timespij(i.e., the processing time depends on the job as well as on the machine), and assignment costscij(i.e., the assignment costs depend also on the job as well as on the machine). They do develop a polynomial time approximation algorithm for this framework; however, their algorithm has a higher time complexity than ours. Moreover their algorithm seems to be hard to implement, since it depends on the solution of a Linear Program, followed by the solution of a matching problem. We will compare our results with their results in the conclusion section.The following notation will be used throughout this paper. Letpmax=max(p1,…,pn)andcmax=max(c1,…,cn).For a given set of jobsJ′, letP(J′)=∑j∈J′pjandV(J′)=∑j∈J′cj. LetCmax∗and∑Cj∗be the optimal objective values of the makespan and the total completion time, respectively. LetTMC∗andMMC∗be the optimal objective values of TMC and MMC, respectively, when the primary objective is at its minimum.In this section we consider the problem LEX (∑Cj,MMC). It is well-known that the Shortest-Processing-Time first (SPT) rule yields an optimal schedule for∑Cj; see Pinedo (2012). The SPT rule, in its most general form, operates as follows: Let integer k be such thatn=(k-1)m+ℓfor some integerℓ,1⩽ℓ⩽m. Sort the jobs in ascending order of their processing times, i.e.,p1⩽p2⩽…⩽pn. We refer to the last m jobs (i.e., jobsn-m+1,n-m+2,…,n,) as the rank-k jobs, the second last m jobs (i.e., jobsn-2m+1,…,n-m) as the rank-(k-1) jobs, and so on; the firstℓjobs (i.e., jobs1,…,ℓ) are the rank-1 jobs. The rank-1 jobs are assigned first, one job per machine, followed by the rank-2 jobs, again one job per machine. This process is repeated until jobs in the last rank (rank-k) are assigned. Clearly, there may be many different schedules that can be generated according to this SPT rule and all these schedules have a minimum∑Cj. A schedule generated by the SPT rule is referred to as an SPT schedule. While limiting ourselves to SPT schedules, we try to find for the problem LEX (∑Cj,MMC) a(1,β)-approximation algorithm with the smallest possibleβ.In order to guarantee a minimum∑Cj, we will only consider SPT schedules. The following procedure to setup ranks will be used as a subroutine in the algorithms proposed.Setup Ranks(1)Sort the jobs in ascending order of their processing time; i.e.,p1⩽p2⩽⋯⩽pn. Letn=(k-1)m+ℓ, where1⩽ℓ⩽m.Assign the last m jobs to setRk, the second last m jobs to setRk-1, and so on. Assign the firstℓjobs to setR1.Return〈R1,R2,…,Rk〉.Note that the Setup Ranks procedure returns a possible rank composition and there may be a different rank composition for SPT schedules when there are jobs with equal processing times.We first consider the cost functioncij=cjfor all1⩽i⩽m. We consider a heuristic, H1, that schedules jobs according to SPT, but jobs in each rank are judiciously assigned to the machine so as to minimize the maximum machine cost. For each1⩽i⩽m, we letBidenote the set of jobs assigned to machine i. Below is a description of H1.Heuristic H1(J,M)(1)Call Setup RanksBi≔∅for each1⩽i⩽m.For r from 1 to k doSort the machines in ascending order of their costs; i.e.,V(Bl1)⩽V(Bl2)⩽⋯⩽V(Blm).Let{Ji1,Ji2,…,Jiy}be all the jobs inRr(i.e.,Rrhas y jobs) where the jobs are sorted in descending order of their costs; i.e.,ci1⩾ci2⩾⋯⩾ciy.For each j from 1 to y doBlj≔Blj∪{Jij}.The analysis of the performance bound for heuristic H1 is similar to the analysis of a list scheduling algorithm for the classicalP‖Cmaxproblem. Before we prove the bound for heuristic H1, we need to prove the following lemma.Lemma 1LetV(i,r)denote the total cost of jobs assigned to machine i after assigning the jobs in rank r by heuristicH1. Then, we have0⩽|V(i,r)-V(h,r)|⩽cmaxfor1⩽i,h⩽m.We will prove the lemma by induction on r. The base case,r=1, is obvious. This is because each ofBiandBhhas at most one job and thus0⩽V(i,1)⩽cmaxand0⩽V(h,1)⩽cmax. Thus, we have0⩽|V(i,1)-V(h,1)|⩽cmax.Assume the lemma is true for all ranks up tor-1. We want to show that the lemma is true for rank-r. IfV(i,r-1)=V(h,r-1), then it immediately holds that|V(i,r)-V(h,r)|⩽cmax. Otherwise, by symmetry, we may assume thatV(i,r-1)>V(h,r-1). Then, from the induction hypothesis, we have0<V(i,r-1)-V(h,r-1)⩽cmax.By heuristic H1, the job assigned to machine h has a cost that is at least as large as the cost of the job assigned to machine i. Since the cost of the job assigned to machine h is simplyV(h,r)-V(h,r-1)and the cost of the job assigned to machine i is simplyV(i,r)-V(i,r-1), we haveV(h,r)-V(h,r-1)⩾V(i,r)-V(i,r-1),and henceV(i,r)-V(h,r)⩽V(i,r-1)-V(h,r-1)⩽cmax.Moreover,V(i,r)-V(h,r)⩾V(i,r-1)-V(h,r)⩾V(i,r-1)-(V(h,r-1)+cmax)⩾(V(i,r-1)-V(h,r-1))-cmax⩾-cmax,where the last inequality is due to the fact thatV(i,r-1)>V(h,r-1). Therefore, we have|V(i,r)-V(h,r)|⩽cmax.By induction, the lemma holds for all r. □HeuristicH1is a (1,2-1/m)-approximation for the problem LEX (∑Cj,MMC) whencij=cjfor all1⩽i⩽m. Moreover, the bound is tight.Since heuristic H1 schedules jobs according to the SPT rule, it generates an optimal solution for the∑Cjobjective. Consider now the MMC objective. By Lemma 1, we havemaxi∈M{V(i,k)}-mini∈M{V(i,k)}⩽cmax⩽MMC∗.There are two cases to consider.Case 1:mini∈M{V(i,k)}⩽m-1mMMC∗. In this case, we havemaxi∈M{V(i,k)}⩽mini∈M{V(i,k)}+cmax⩽m-1mMMC∗+MMC∗=2-1mMMC∗.mini∈M{V(i,k)}>m-1mMMC∗.We now consider the cost functioncij=ai+cj. We propose a different heuristic, H2, which is slightly more complicated.First, the Setup Ranks routine is called to obtain a possible rank composition for the minimum total completion time objective. In a SPT schedule with k ranks such thatn=k(m-1)+ℓ,ℓmachines have k jobs each and(m-ℓ)machines have(k-1)jobs each. Thus, the cost at machine i is|Bi|ai+V(Bi)where|Bi|=kor(k-1). The basic idea of heuristic H2 is to construct two schedules – the first one for jobs in rank 1 and the second one for jobs in ranks2,…,k– and combine these to create a final schedule.For the first schedule, the jobs inR1are sorted in descending order of their costs; i.e.,cj1⩾cj2⩾⋯⩾cjℓ. Then, for each1⩽i⩽ℓ, jobJjiis assigned to machine i andAiis set to bek×ai+cji. For eachℓ+1⩽i⩽m,Aiis set to be(k-1)×ai. Then, the machines are sorted in descending order ofAi; i.e., the machinesl1,l2,…,lmare such thatAl1⩾Al2⩾⋯⩾Alm.Now, heuristic H1 is then called to generate the second schedule with the set of jobsR2∪R3∪⋯∪Rk. When heuristic H1 returns, letBibe the set of jobs assigned to machine i. Then, theBi’s are sorted in an ascending order of the total cost of the jobs inBi; i.e.,V(Bi1)⩽V(Bi2)⩽⋯⩽V(Bim).Finally, for the minimum maximum cost, for each1⩽h⩽m, the jobs inBihare assigned to machinelh. The cost of machinelhisAlh+V(Bih). Shown below is a description of heuristic H2.Heuristic H2(J,M)(1)Call Setup RanksLet{Jj1,Jj2,…,Jjℓ}be the jobs inR1, sorted in descending order of their costs; i.e.,cj1⩾cj2⩾⋯⩾cjℓ.Sort the machines in ascending order ofai; i.e.,a1⩽a2⩽⋯⩽am.For i from 1 toℓ, assign jobJjito machine i and letAi=k×ai+cji.For i fromℓ+1to m, letAi=(k-1)×ai.SortAivalues such thatAl1⩾Al2⩾⋯⩾Alm.Call heuristic H1(R2∪R3∪⋯∪Rk,M) to schedule jobs inR2∪R3∪⋯∪Rkon m identical machines. When heuristic H1 returns, letBibe the set of jobs assigned to machine i in the schedule produced by heuristic H1.Sort theBiin ascending order ofV(Bi); such thatV(Bi1)⩽V(Bi2)⩽⋯⩽V(Bim).For each1⩽h⩽m, assign the jobs inBihto machinelhand let the cost of machinelhbeAlh+V(Bih).HeuristicH2is a (1,2-1/m)-approximation for the problem LEX (∑Cj,MMC) whencij=ai+cjfor all1⩽i⩽m. Moreover, the bound is tight.For each1⩽i⩽m, letVibeV(Bi)for simplicity. Recall thatBiis the set of jobs scheduled on machine i fromR2∪R3∪⋯∪Rk. Thus, the cost of machine i isAi+Vi.We claim thatmaxi∈M{Ai}⩽MMC∗by the following reason. We consider another set of jobsJ′where all costs of jobs in rank 1 is the same as the original problem instance and all costs of jobs in ranks2,…,kbecome zero. Then,maxi∈M{Ai}is the optimal MMC value forJ′. Obviously, the optimal MMC value for J is greater than or equal to the optimal MMC value forJ′. Therefore,maxi∈M{Ai}⩽MMC∗.Thus,|Ai-Ah|⩽MMC∗for1⩽i,h⩽m. By Lemma 1, we have|Vi-Vh|⩽MMC∗for1⩽i,h⩽m.Without loss of generality, we may assume thatAi⩾Ah. Thus,0⩽Ai-Ah⩽MMC∗. SinceAi⩾Ah, we haveVi⩽Vh, by the nature of heuristic H2. Thus, we have(Ai+Vi)-(Ah+Vh)⩽Ai-Ah⩽MMC∗,and(Ai+Vi)-(Ah+Vh)⩾Vi-Vh⩾-MMC∗.Therefore, we have|(Ai+Vi)-(Ah+Vh)|⩽MMC∗. We now consider two cases. LetAi+Vi=maxl∈M{Al+Vl}andAh+Vh=minl∈M{Al+Vl}.Case 1:Ah+Vh⩽m-1mMMC∗. In this case, we haveAi+Vi⩽Ah+Vh+MMC∗⩽m-1mMMC∗+MMC∗=2-1mMMC∗.Case 2:Ah+Vh>m-1mMMC∗. In this case, we haveAi+Vi+(m-1)(Ah+Vh)⩽∑l∈M(Al+Vl)⩽m×MMC∗.Therefore, we haveAi+Vi⩽m×MMC∗-(m-1)(Ah+Vh)<m-(m-1)2mMMC∗=2-1mMMC∗.The set of jobs achieving a tight bound in Theorem 1 can be used to show the tight bound for this theorem as well. Simply letai=0for all i. □We now consider the cost functioncij=ai×cj. Recall that we assume thata1=1andai⩽ai+1fori=1,…,m-1. We can assume thatn=km; otherwise without changing the problem structure we can add⌈n/m⌉m-ndummy jobs with zero processing times and zero costs.We consider the third heuristic, H3, which is similar to heuristic H1. Again, jobs are ordered according to the SPT rule, rank by rank. Jobs within the same rank are assigned to machines as follows: Jobs are considered in descending order of their costcj. When job j is being assigned, we consider all the eligible machines and assign job j to that machine i that results in the smallest total cost on machine i. After job j is assigned to machine i, machine i becomes ineligible until we deal with the jobs in the next rank. The heuristic is described as follows.Heuristic H3(J,M)(1)Call Setup RanksBi≔∅for each1⩽i⩽m.For r from 1 to k doLetM′={1,2,…,m}be the eligible machines.LetRi={Ji1,Ji2,…,Jim}, sorted in descending order of their cost; i.e.,ci1⩾ci2⩾⋯⩾cim.For each j from 1 to m dol≔argminf∈M′{V(Bf)+af×cij}, with ties broken by choosing the machine with a largeraf.Bl≔Bl∪{Jij}.M′≔M′⧹{l}.Even though heuristic H3 looks reasonable, its theoretical bound may be poor. We can derive a lower bound of the ratio from the literature. Cho and Sahni (1980) considered a list scheduling algorithm for a uniform parallel machine scheduling problem to minimize the makespan. They showed that the worst case performance ratio of the list scheduling algorithm is at leastO(logm)by presenting a problem instance. We can construct a problem instance from the prohlem instance in Cho and Sahni (1980) and show that the approximation ratio of heuristic H3, for problem LEX (∑Cj,MMC) whencij=ai×cjfor all1⩽i⩽m, is at least (1,O(logm)). However, we will prove an unbounded approximation ratio of heuristic H3 in the following theorem.Theorem 3The approximation ratio of heuristicH3, for problem LEX (∑Cj,MMC) whencij=ai×cjfor all1⩽i⩽m, is at least (1,O(am)).Since heuristic H3 schedules jobs according to SPT, it generates an optimal solution for the∑Cjobjective. Thus, we will prove the lower bound ofMMC(H3)/MMC∗by providing an example.Consider two machines and four jobs. The four jobs have identical processing times, say 1 unit. Their costs are:c1=c2=1,c3=c4=a, wherea≫1. For machine 1,a1=1and for machine 2,a2=a.Suppose the algorithm puts jobs 1 and 2 in the first rank, and jobs 3 and 4 in the second rank, thenV(B1)=V(B2)=a+1. In this case, we haveMMC(H3)=a(a+1).On the other hand, the optimal solution puts jobs 1 and 3 in the first rank, and jobs 2 and 4 in the second rank. Then we assign the job with the smallest cost in each rank to machine 2. In this case, we have jobs 1 and 2 in machine 2, and jobs 3 and 4 in machine 1. We haveMMC∗=2a.The approximation ratio isa(a+1)/(2a)=(a+1)/2, which approaches infinity when a gets large. This completes the proof. □Since heuristic H3 does not have a constant approximation ratio, we consider a special case of LEX (∑Cj,MMC) wherecij=ai×cj,a1=⋯=am-1=1andam⩾1. This setting implies that there is only one inefficient machine. For this special case, we present an approximation algorithm with a constant ratio.The basic idea is that we consider two cases for theamvalue separately. Whenamis not so large, we just use heuristic H1 and modify the schedule. Whenamis large, we need to assign jobs with small costs to machine m within the structure of SPT schedules. However, if we fix ranks by Setup Ranks like heuristics H1, H2 and H3, it might be impossible to assign jobs with small costs to machine m. Therefore, we first consider a procedure to assign a job from each rank to machine m to minimize the total cost of jobs assigned to machine m among all possible rank compositions. The algorithm can be described as follows:Minimum Cost for Machinem(1)Call Setup RanksConstruct a weighted bipartite graphG=(U1∪U2,E;w)where(a)U1={j|Jj∈J},U2={1,…,k+1}E1={(μ,ν)|minj∈Rν{pj}⩽pμ⩽maxj∈Rν{pj}forμ∈U1,ν∈U2⧹{k+1}},E2={(μ,k+1)|μ∈U1}andE=E1∪E2.wμ,ν=cμforμ∈U1,ν∈U2⧹{k+1}.Solve the following transportation problem on G and obtain an optimal solutionyμ,ν∗.minimize∑(μ,ν)∈E1wμ,νyμ,νsubjectto∑ν:(μ,ν)∈Eyμ,ν=1forμ∈U1∑μ:(μ,ν)∈E1yμ,ν=1forν∈U2⧹{k+1}∑μ:(μ,k+1)∈E2yμ,k+1=n-kyμ,ν∈{0,1}for(μ,ν)∈EJobJμis scheduled on rankνof machine m if and only ifyμ,ν∗=1for(μ,ν)∈E1.Instead of solving the mathematical program described above through a transportation algorithm, we will solve it by an alternative procedure that will significantly reduce the running time. This alternative procedure is described in the Appendix. Its running time isO(nlogn).Note thatV(Bi)is the sum ofcjvalues of the jobs assigned to machine i. The cost of machine i isV(Bi)fori=1,…,m-1and isamV(Bm)fori=mand thusMMC=max{max{V(Bi)|i∈{1,…,m-1}},amV(Bm)}.Now, we are ready to present an algorithm with a constant ratio for LEX (∑Cj,MMC) wherecij=ai×cj,a1=⋯=am-1=1andam⩾1.Heuristic H4(1)Ifam⩾2,(a)Call Minimum Cost for Machinem. LetJ′be the set of jobs scheduled on machine m.Apply H1(J⧹J′,M⧹{m})for the schedule of the remaining jobs on machines1,…,m-1.If1⩽am<2,(a)Apply H1(J,M) and obtainBifori∈M.Leth≔argmin{V(Bi)|i∈M}. SwapBmandBh.HeuristicH4is a(1,2-12(m-1))-approximation for problem LEX (∑Cj,MMC) whencij=ai×cj,a1=⋯=am-1=1andam⩾1.Case 1. Suppose thatam⩾2. We consider two sub-cases: (i) MMC is determined at machine m, and (ii) MMC is determined at machine i, fori≠m.(i)If MMC is determined by machine m, by the property of the schedule by Minimum Cost for Machinem, the current schedule is optimal.Suppose that MMC is determined by a machine that is not machine m. By Lemma 1,|V(Bi)-V(Bh)|⩽cmaxfori,h∈M⧹{m}.(i) Suppose that MMC is determined at machine m. IfV(Bm)>1m(m-1+1am)MMC∗, then∑i∈MV(Bi)>(m-1+1am)MMC∗, which is a contradiction. IfV(Bm)⩽1m(m-1+1am)MMC∗, then we haveamV(Bm)⩽ammm-1+1amMMC∗=am(1-1m)+1mMMC∗⩽2-1mMMC∗.(ii) Suppose that MMC is determined at a machine that is not machine m. By Lemma 1,|V(Bi)-V(Bh)|⩽cmaxfori,h∈M. IfV(Bm)⩽1-1mMMC∗, thenmaxi∈M⧹{m}{V(Bi)}⩽V(Bm)+cmax⩽2-1mMMC∗.IfV(Bm)>1-1mMMC∗, then consider the relationshipmaxi∈M{V(Bi)}+(m-1)V(Bm)⩽V(J)⩽(m-1+1/am)MMC∗.Thus, we havemaxi∈M{V(Bi)}⩽(m-1+1/am)MMC∗-(m-1)1-1mMMC∗=1am+m-1mMMC∗⩽2-1mMMC∗.Note that2-1m⩽2-12(m-1)form⩾2. The proof is complete. □In this section we consider the problem LEX (Cmax,TMC). For the cost functioncij=cj, this problem is equivalent to the problemP||Cmax, for which many heuristics have been proposed and analyzed. Therefore, we will not consider this special case here.On both cost functionscij=ai+cjandcij=ai×cj, we will obtain an upper bound of the optimal makespan by the following steps. We first order the n jobs on the m machines according to the Largest-Processing-Time (LPT) rule, ignoring the cost of the jobs. The LPT rule schedules the jobs in descending order of their processing times. The next job will be assigned to the machine that finishes the earliest. The makespan of the LPT schedule is denoted by L and is used as an upper bound for the optimal makespan. It is well known thatL⩽(43-13m)Cmax∗, whereCmax∗is the optimal makespan; see Graham (1969).Since the primary objective, the makespan, is hard to optimize, we may consider using LPT to optimize the primary objective. Unfortunately, such an algorithm can perform very poorly with regard to the secondary objective for both cost functionscij=ai+cjandcij=ai×cj.For the cost functioncij=ai+cj, we consider an example with two machines havinga1=0anda2=a>0and n jobs, where n is even andn⩾6. The job information is as follows:p1=p2=1/2andp3=⋯=pn=1/(n-2)andc1=⋯=cn=0. Obviously,Cmax∗=1. In the LPT schedule, jobsJ1andJ2are scheduled on different machines and the remaining jobs are evenly scheduled on both machines. Thus,TMC(LPT)=n/2×a. However, in the optimal schedule, jobsJ1andJ2are scheduled on machine 2 and the other jobs are scheduled on machine 1. Thus,TMC∗=2×a. Therefore,TMC(LPT)/TMC∗=O(n).For the cost functioncij=ai×cj, we consider an example with two machines havinga1=1anda2=a>1and n jobs, where n is even andn⩾6. The job information is as follows:p1=p2=1/2andp3=⋯=pn=1/(n-2)andc1=c2=c/2andc3=⋯=cn=0. Obviously,Cmax∗=1. In the LPT schedule, jobsJ1andJ2are scheduled on different machines and the remaining jobs are evenly scheduled on both machines. Thus,TMC(LPT)=c2(1+a). However, in the optimal schedule, jobsJ1andJ2are scheduled on machine 1 and the other jobs are scheduled on machine 2. Thus,TMC∗=c. SinceTMC(LPT)TMC∗=1+a2and a can be arbitrarily large,TMC(LPT)/TMC∗is unbounded. Therefore, we need to design an algorithm that considers both objectives simultaneously.For the cost functioncij=ai+cj, we propose a fast heuristic, heuristic H5, which works as follows. Let the makespan of the LPT schedule be L. Then the jobs are sorted in ascending order of their processing times; i.e.,p1⩽p2⩽⋯⩽pn. The jobs are scheduled on the machines, starting with the first machine. Specifically, the firstλjobs are scheduled on machine 1, whereλis the smallest index such that the total processing time of the firstλjobs is larger than L. We then delete theλjobs and machine 1 from consideration, and repeat the process on machine 2. This process is repeated until all jobs have been scheduled. Shown below is a description of heuristic H5.Heuristic H5(J,M)(1)Disregarding the cost of the jobs, schedule the n jobs on the m machines according to LPT. Let L denote the makespan of the LPT schedule.Sort the jobs in ascending order of their processing times. LetJ=(J1,J2,…,Jn)be a list of the n jobs such thatp1⩽p2⩽⋯⩽pn.Seti=1.If the total processing time of the jobs in J is less than or equal to L, then schedule all jobs in J on machine i and stop.Letλbe the smallest integer such that the total processing time of the firstλjobs is larger than or equal to L.Assign the firstλjobs on machine i.Delete the firstλjobs from J.i≔i+1.Goto Step 4.LetBibe the set of jobs assigned to machine i in the schedule generated by heuristicH5. Then, we have∑h=1iP(Bh)⩾min{i×L,∑j=1npj}for alli∈M.IfP(Bh)⩾Lfor allh,h=1,…,i, then we have∑h=1iP(Bh)⩾i×L. Otherwise, there is a machine f such thatP(Bf)<Lfor1⩽f⩽i. This means that all n jobs have been scheduled on machines1,2,…,f. Thus, we have∑h=1iP(Bh)=∑j=1npj. □We are now ready to prove Theorem 5.Theorem 5HeuristicH5is a ((73-13m),1)-approximation for problem LEX (Cmax,TMC) whencij=ai+cj.First, we want to show that heuristic H5 would be able to schedule all the jobs on m machines so that each machine finishes by timeL+pmax. Suppose not. Then there is a job that cannot be scheduled on any machine such that it completes by timeL+pmax. Sincepj⩽pmaxfor all j, no machine becomes available before time L when this job is being considered for scheduling. This means that the total processing time of all the jobs that have been scheduled so far is more than mL. This is impossible sinceL⩾Cmax∗. By the result of Graham (1969), we haveCmax∗⩽L⩽43-13mCmax∗.Furthermore, we havepmax⩽Cmax∗. Therefore, we haveCmax(H5)⩽73-13mCmax∗.We now consider the TMC objective. We will show thatTMC(H5)⩽TMC∗, whereTMC∗is the optimal total machine cost among all schedules with makespan equal toCmax∗.Letni=|Bi|andni∗=|Bi∗|. Note that∑i∈Mni=∑i∈Mni∗=n. Let S andS∗be the schedule produced by heuristic H5 and the optimal schedule, respectively. In schedule S, the smallest∑h=1inhjobs, with respect to processing times, are scheduled on machines1,…,i. Suppose that, in scheduleS∗,∑h=1inh∗>∑h=1inh. Then, obviously, we have∑h=1iP(Bh∗)>∑h=1iP(Bh). By Lemma 2, we have∑h=1iP(Bh)⩾i×Lor∑h=1iP(Bh)=∑j=1npjfor alli∈M.If∑h=1iP(Bh)⩾i×L, then we have∑h=1iP(Bh∗)>∑h=1iP(Bh)⩾i×L⩾i×Cmax∗,which contradicts the fact thatCmax∗is the optimal makespan.If∑h=1iP(Bh)=∑j=1npj, then∑h=1iP(Bh∗)>∑h=1iP(Bh)=∑j=1npj,which again leads to a contradiction. Thus, we have∑h=1inh⩾∑h=1inh∗for alli∈M. Now,TMC(H5)=∑i∈Mni×ai+∑j=1ncj. Since∑j=1ncjis a constant independent of the assignment, we will show that∑i∈Mni×ai⩽∑i∈Mni∗×ai, and henceTMC(H5)⩽TMC∗.Leta¯i=ai-ai-1for alli∈M, wherea0=0. Sinceai⩾ai-1, we havea¯i⩾0for alli∈M.∑i∈Mniai=n1a¯1+n2(a¯1+a¯2)+⋯+nm∑h=1ma¯h=(n1+n2+⋯+nm)a¯1+(n2+⋯+nm)a¯2+⋯+nma¯m=na¯1+(n-n1)a¯2+(n-n1-n2)a¯3+(n-n1-n2-⋯-nm-1)a¯m=n(a¯1+a¯2+⋯+a¯m)-∑i=1m-1∑h=1inha¯i+1.Sincen(a¯1+a¯2+⋯+a¯m)is a constant,∑h=1inh⩾∑h=1inh∗for alli∈Manda¯i⩾0for alli∈M, we haveTMC(H5)⩽TMC∗. □We now consider the cost functioncij=ai×cj. We propose a heuristic, heuristic H6, which works as follows. Like in heuristic H5, let the makespan of the LPT schedule be L. We then sort the jobs in descending order of the ratiocjpj; i.e.,c1p1⩾c2p2⩾⋯⩾cnpn. Jobs are now assigned to the machines, starting with the first machine. The firstλjobs will be assigned to machine 1, whereλis the smallest index such that the total processing time of the firstλjobs is larger than L. Theseλjobs and machine 1 will be deleted from consideration, and we proceed to schedule jobs on machine 2. This process is iterated until all jobs are assigned. Below is a description of heuristic H6.Heuristic H6(J,M)(1)Disregarding the cost of the jobs, schedule the n jobs on the m machines by the LPT rule. Let L denote the makespan of this schedule.Sort the jobs in descending order of the ratioscjpj. LetJ=(J1,J2,…,Jn)be a list of the n jobs such thatc1p1⩾c2p2⩾⋯⩾cnpn.Seti=1.If the total processing time of the jobs in J is less than or equal to L then assign all jobs in J to machine i and stop.Letλbe the smallest integer such that the total processing time of the firstλjobs is greater than or equal to L.Assign the firstλjobs to machine i.Delete the firstλjobs from J.i≔i+1.Goto Step 4.In the proof of Theorem 6, we will assume that the jobs have been sorted in descending order ofcjpj(i.e.,c1p1⩾c2p2⩾⋯⩾cnpn). LetBiandBi∗be the sets of jobs assigned to machine i in the schedule generated by heuristic H6 and in the optimal schedule, respectively. Thus,TMC(H6)=∑i=1mai×V(Bi)andTMC∗=∑i=1mai×V(Bi∗).Theorem 6HeuristicH6is a ((73-13m),1)-approximation for the problem LEX (Cmax,TMC) whencij=ai×cjfor all1⩽i⩽m.Similar to the proof of Theorem 5, we can show that heuristic H6 must be able to schedule the n jobs on the m machines so that each machine finishes by timeL+pmax. SinceL⩽(43-13m)Cmax∗andpmax⩽Cmax∗, we haveCmax(H6)⩽(73-13m)Cmax∗. We now show thatTMC(H6)⩽TMC∗, whereTMC∗is the optimal total machine cost among all schedules with a makespan ofCmax∗.The ratiocj/pjis the cost per unit processing time. Letλj=cj/pjfor each1⩽j⩽n; hencecj=λj×pj. We haveλ1⩾λ2⩾⋯⩾λn. Since heuristic H6 schedules jobs on each machine with total processing time larger than L and sinceL⩾Cmax∗, we have for each1⩽i⩽m,∑h=1iP(Bh)⩾∑h=1iP(Bh∗).Now,∑h=1iV(Bh)=∑j∈(B1∪⋯∪Bh)cj=∑j∈(B1∪⋯∪Bh)λj×pj.Since heuristic H6 schedules the jobs in ascending order of the indexes (and hence largerλjvalues) and since∑h=1iP(Bh)⩾∑h=1iP(Bh∗), we have∑h=1iV(Bh)⩾∑h=1iV(Bh∗).Leta¯i=ai-ai-1for alli∈M, wherea0=0anda1=1. Sinceai⩾ai-1, we havea¯i⩾0for alli∈M.∑i∈Mai×V(Bi)=V(B1)a¯1+V(B2)(a¯1+a¯2)+⋯+V(Bm)∑h=1ma¯h=(V(J))a¯1+(V(J)-V(B1))a¯2+⋯+V(Bm)a¯m=V(J)(a¯1+a¯2+⋯+a¯m)-∑i=1m-1∑h=1iV(Bh)a¯i+1.SinceV(J)(a¯1+a¯2+⋯+a¯m)is a constant,∑h=1iV(Bh)⩾∑h=1iV(Bh∗)for alli∈M, anda¯i⩾0for alli∈M, we haveTMC(H6)⩽TMC∗. □In heuristics H5 and H6, we calculate an upper bound for the optimal makespan by using LPT and thus have a competitive ratio of(1+43-13m,1)for our problems. However, if we use a better approximation algorithm for the makespan with a worst-case performance ratio ofρ, we can have a(1+ρ,1)-approximation algorithm. For example, if we compute an upper bound by MULTIFIT, we have a(1+13/11,1)-approximation algorithm because the worst-case performance ratio of MULTIFIT is 13/11 by Yue (1990).The MULTIFIT algorithm is an approximation algorithm forP||Cmax, which operates as follows. First, it computes a lower bound (LB) and an upper bound (UB) forCmax∗. An obvious lower bound isLB=maxpmax,∑j=1npjm, and an obvious upper bound isUB=2×LB. It then conducts a binary search in the interval [LB,UB]. For each value C obtained in the binary search (i.e.,C=LB+UB2), it tries to schedulle the jobs by the First-Fit-Decreasing (FFD) rule so that no job completes after time C. If it is successful in scheduling all n jobs, then it sets UB to be C; otherwise, it sets LB to be C. This process is iterated untilUB=LB+1. Now, if all jobs can be scheduled by the FFD rule so that no job completes after time LB, then it returns LB; otherwise, it returns UB.Shmoys and Tardos (1993) considered the following scheduling problem: job j on machine i requires a processing timepijand incurs a costcij. Assume T is given as an upper bound of the makespan, what is the machine-job assignment that minimizes the total assignment cost? They modeled this as the following linear program. Given T and C, for anyt⩾T, integer solutions to the linear program, LP (T,C:t), have a one-to-one correspondence with schedules that have a cost of at most C and a makespan of at most T. The LP (T,C:t) problem can be formulated as follows:∑i=1m∑j=1ncijxij⩽C,∑i=1mxij=1forj=1,…,n,∑j=1npijxij⩽Tfori=1,…,m,xij⩾0fori=1,…,m,j=1,…,n,xij=0ifpij>t,i=1,…,m,j=1,…,n,They proved that if LP (T,C:t) has a feasible solution, then there exists a schedule that has a makespan of at mostT+tand a cost of at most C. They also provided an algorithm that converts a feasible solution to LP (T,C:t) into the required schedule.We can apply their result to our problem LEX (Cmax,TMC). Note that in our problempij=pjandcij=ai+cjorcij=ai×cj, which implies that the model in Shmoys and Tardos (1993) is more general than ours. According to the above result, we can get an(1+ρ,1)approximation algorithm by the following procedure whereρis an approximation ratio of any approximation algorithm for minimizing the makespan in an environment with identical machines in parallel.Step 1. Apply an approximation algorithm for minimizing the makespan with identical machines in parallel and obtain the makespanT′. (For example, when LPT is applied, we haveT′such thatCmax∗⩽T′⩽(43-13m)Cmax∗).Step 2. Regard C as a variable, solve LP (T′,C:pmax) with the objective C to be minimized and get an optimal valueC′.Step 3. Convert an optimal solution to LP (T′,C′:pmax) into a feasible solution.SinceT′⩾Cmax∗and we allow split jobs to multiple machines in a linear program solution, we haveC′⩽TMC∗. Furthermore,pmax⩽Cmax∗andT′⩽ρCmax∗. The optimal solution from Step 2 is feasible to LP (T′,C′:pmax), and thus, we can get a schedule with a makespan of at mostT′+pmaxand cost at mostC′, which implies we have a(1+ρ,1)-approximation algorithm for LEX (Cmax,TMC).However, to find such an approximation, it is necessary to apply two procedures (which determine the overall time complexity), namely, a linear programming algorithm in order to obtain a fractional matching solution (in Step 2) and a weighted bipartite matching algorithm for the rounding (in Step 3). This LP is considered a fractional packing problem and thus can be solved inO(mn2logn); the weighted bipartite graph hasO(n)nodes andO(n)edges and thus the weighted bipartitie matching can be solved inO(n2logn). Therefore, the overall time complexity isO(mn2logn).The proposed algorithms for our problem LEX (Cmax,TMC) are in both cases (i.e.,cij=ai+cjandcij=ai×cj) much simpler and easier to implement; their time complexity isO(nlogn).

@&#CONCLUSIONS@&#
We consider bi-criteria scheduling problems where customers’ objectives as well as service providers’ objectives have to be optimized at the same time. As a customers’ objective, we consider either the total completion time or the makespan and as a service providers’ objective, we consider either the total assignment cost or the maximum assignment cost. The primary objective is the customers’ objective and the secondary objective is the service providers’ objective. For three machine assignment cost functions (cij=cj,cij=ai+cj, andcij=ai×cj), we provide(α,β)-approximation algorithms.Our models are all special cases of the more general model considered by Shmoys and Tardos (1993), who did provide a polynomial time approximation algorithm that is applicable to all models within their framework. However, their approximation scheme is clearly computationally slower than those we propose and it does not provide any intuitive insights into the respective problems. Our schemes are based on prioritization and are therefore more intuitive and easier to implement (see Table 1). All the heuristics proposed in this paper run inO(nlogn), whereas the algorithm developed by Shmoys and Tardos runs inO(mn2logn). Our worst case approximation ratios are in three cases better than the ratio in Shmoys and Tardos; in two other cases they are the same and in one case we were not able to determine a bounded worst case approximation ratio.We have considered only traditional scheduling objectives that are functions of completion times as the primary objective. However, considering MMC or TMC as the primary objective may lead to different approximation ratios. We have only considered cases where eitherα=1orβ=1. Finding an(α,β)-approximation algorithm forα>1andβ>1may be a very promising research topic.For SPT schedules, we sort the jobs in non-decreasing order of their processing times and in case of a tie we sort the jobs in non-decreasing order of their costs. When there are jobs with identical processing times, those jobs may be eligible to multiple consecutive ranks. Thus, we defineFr′,r″to be the set of jobs that can be scheduled in rank r forr′⩽r⩽r″. Since the number of jobs inFr′,r″that can be scheduled on machine m in ranks[r′,r″]is at mostr″-r′+1, we can defineF‾r′,r″to be the set of (r″-r′+1) jobs with minimum costs fromFr′,r″. Now, the problem is to select and assign jobs fromF‾r′,r″to rank r forr′⩽r⩽r″such that each rank has exactly one job and the total cost of assigned jobs is minimum.Ifr″⩾r′+2, then ranksr′+1,r′+2,…,r″-1must be filled by jobs inF‾r′,r″. So, we can assign(r″-r′-1)jobs to those ranks first and redefine the problem by taking off those ranks along with the scheduled jobs. Thus, without loss of generality, we can say thatr″=r′orr″=r′+1. Moreover,F‾r,rhas at most one job andF‾r,r+1has at most two jobs. The number of possible(r′,r″)pairs forF‾r′,r″is bounded byk+(k-1)=2k-1and the number of jobs inF‾r′,r″is bounded byk+2(2k-1)=5k-2.In order to describe the subsequent steps, we use following notation.•Letc1(F‾r,r)be the cost of the job inF‾r,rif|F‾r,r|=1and∞otherwise.Letc1(F‾r,r+1)be the cost of the job with the lower cost inF‾r,r+1if|F‾r,r+1|⩾1and∞otherwise.Letc2(F‾r,r+1)be the cost of the job with the higher cost inF‾r,r+1if|F‾r,r+1|=2and∞otherwise.We define the following shortest path problem from a source node(0,0)to the destination node(k+1,k+1)in a layered graph (See Fig. 1).Nodes are defined as follows:•Node (0, 0) is a dummy source node.Node (k+1,k+1) is a dummy destination node.Node(r,r+1)denotes that rank r is assigned from a job inF‾r,r+1forr=1,…,k-1.Node(r,r)denotes that rank r is assigned from a job inF‾r,rforr=1,…,k.Node(r,r-1)denotes that rank r is assigned from a job inF‾r-1,rforr=2,…,k.The arcs and their costs are defined as follows:•(k,k)and(k+1,k+1)are connected and the arc cost is 0.(k,k-1)and(k+1,k+1)are connected and the arc cost is 0.(r-1,r)and(r,r+1)are connected and the arc cost isc1(F‾r,r+1).(r-1,r-1)and(r,r+1)are connected and the arc cost isc1(F‾r,r+1).(r-1,r-2)and(r,r+1)are connected and the arc cost isc1(F‾r,r+1).(r-1,r)and(r,r)are connected and the arc cost isc1(F‾r,r).(r-1,r-1)and(r,r)are connected and the arc cost isc1(F‾r,r).(r-1,r-2)and(r,r)are connected and the arc cost isc1(F‾r,r).(r-1,r)and(r,r-1)are connected and the arc cost isc2(F‾r-1,r).(r-1,r-1)and(r,r-1)are connected and the arc cost isc1(F‾r-1,r).(r-1,r-2)and(r,r-1)are connected and the arc cost isc1(F‾r-1,r).From the arcs of a shortest path, we can construct an optimal solution.Now, consider the running time of the proposed algorithm. It takesO(nlogn)time to sort the jobs. It takesO(n)time to constructFr′,r″andF‾r′,r″. As for the shortest path problem, the number of arcs is less than9k=O(k)⩽O(n)and a shortest path can be obtained inO(n)time. Therefore, the proposed algorithm can be implemented inO(nlogn)time.