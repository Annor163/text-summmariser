@&#MAIN-TITLE@&#
Scheduling a hybrid assembly-differentiation flowshop to minimize total flow time

@&#HIGHLIGHTS@&#
Hybrid assembly-differentiation flowshop scheduling problem with total flow time.A mixed integer programming model for the HADFSP-TFT.Some properties of the optimal solutions for the HADFSP-TFT.Two fast heuristics and three hybrid meta-heuristics for the HADFSP-TFT.A lower bound for the HADFSP-TFT to evaluate the proposed algorithms.

@&#KEYPHRASES@&#
Scheduling,Hybrid assembly-differentiation flowshop,Hybrid meta-heuristics,Total flow time,

@&#ABSTRACT@&#
This study considers a hybrid assembly-differentiation flowshop scheduling problem (HADFSP), in which there are three production stages, including components manufacturing, assembly, and differentiation. All the components of a job are processed on different machines at the first stage. Subsequently, they are assembled together on a common single machine at the second stage. At the third stage, each job of a particular type is processed on a dedicated machine. The objective is to find a job schedule to minimize total flow time (TFT). At first, a mixed integer programming (MIP) model is formulated and then some properties of the optimal solution are presented. Since the NP-hardness of the problem, two fast heuristics (SPT-based heuristic and NEH-based heuristic) and three hybrid meta-heuristics (HGA-VNS, HDDE-VNS and HEDA-VNS) are developed for solving medium- and large-size problems. In order to evaluate the performances of the proposed algorithms, a lower bound for the HADFSP with TFT criteria (HADFSP-TFT) is established. The MIP model and the proposed algorithms are compared on randomly generated problems. Computational results show the effectiveness of the MIP model and the proposed algorithms. The computational analysis indicates that, in average, the HDDE-VNS performs better and more robustly than the other two meta-heuristics, whereas the NEH heuristic consume little time and could reach reasonable solutions.

@&#INTRODUCTION@&#
In a two-stage assembly flowshop, there is a finite set J of n jobs to be processed. Each job requires m different components which are processed on m parallel machines at the first stage. At the second stage, a single assembly machine is used to assemble the components which are produced at the first stage. It has widely industrial applications such as fire engine assembly plant (Lee, Cheng, & Lin, 1993), distributed database systems (Allahverdi & Al-Anzi, 2006a, 2006b) and personal computer manufacturing (Potts, Sevastjanov, Strusevich, Wassenhove, & Zwaneveld, 1995).The two-stage assembly flowshop scheduling problem (TSAFSP) with makespan criteria has been proved to be strongly NP-hard by Lee et al. (1993) and Potts et al. (1995), respectively. Some recent efforts are made to schedule jobs with different objectives in the two stage assembly production environment. Lee et al. (1993), Potts et al. (1995), Koulamas and Kyparisis (2001), and Allahverdi and Al-Anzi (2006a, 2006b) considered the TSAFSP to minimize makespan. Tozkapan, Kirca, and Chung (2003) studied the problem with objective of minimizing the total weighted flow time. Allahverdi and Al-Anzi (2006a, 2006b) addressed the problem to minimize lateness. Al-Anzi and Allahverdi (2007) also studied the TSAFSP with lateness criteria considering setup times. Mozdgir, Fatemi Ghomi, Jolai, and Navaei (2013) discussed the problem to optimize makespan and mean flow time simultaneously.However, all the above research neglected the differentiation operations, which arise from various industrial applications (Herrmann & Lee, 1992; Riane, Artiba, & Elmaghraby, 2002; Cheng, Lin, & Tian, 2009; Lin & Hwang, 2011; Liu, Fang, & Lin, 2012; Wang & Liu, 2013). For example, in a PC manufacturing plant, components are assembled on a common stage station, no matter which kind of computers is to be processed. After the assembly stage, the computers will be transported to the differentiation stage where different types of computers are packaged on several package machines. Another example is car manufacturing (Wang & Liu, 2013), when a car model is finished assembly, it will be sent to the paint shop where several parallel paint machines are installed for painting different colors. In the aspect of differentiation flowshop scheduling problem (DFSP), Herrmann and Lee (1992) show that the DFSP is NP-hard even if there are only two dedicated machines at stage two. Riane et al. (2002) studied the DFSP in which there are two dedicated machines in the second stage. Its objective is to minimize the makespan. They proved that the problem is strongly NP-complete and presented three heuristics and a dynamic programming algorithm. Cheng et al. (2009) considered the DFSP to minimize the weighted sum of machine completion times (WMT). They proved that the problem is strongly NP-hard and gave an O(n3) polynomial time algorithm to solve the special case where the sequences of jobs per type are fixed. Also, they developed an approximation algorithm with a tight performance ratio for the general case. Lin and Hwang (2011) presented a dynamic programming algorithm for the DFSP with fixed sequences per job type. Liu et al. (2012) proposed a branch and bound algorithm for DFSP to minimize the makespan. Computational results show that their algorithm can substantially reduce the computing efforts to find optimal solutions. Wang and Liu (2013) considered the same problem with makespan criteria. They proposed a heuristic method based on branch and bound algorithm and given some lower bounds, upper bounds and dominance properties. Experimental results showed the effectiveness of their algorithm. Although there are some research works on the DFSP as above, the process of components manufacturing for assembly operation is neglected. In this situation, comprehensively considering the DFSP and the TSAFSP, we address a novel three-stage production scheduling problem which we called the hybrid assembly-differentiation flowshop scheduling problem (HADFSP). At the first stage, m different components required by a job are processed on m different machines in parallel. When all of the components are completed, a common single machine at the second stage assembles the components together into a model. Subsequently, the model is processed on one of several dedicated machines at the last stage. The first two stages (stage 1 and stage 2) and the last two stages (stage 2 and stage 3) can be regarded as a two-stage assembly flowshop (TSAF) and a differentiation flowshop, respectively. Our objective is to find an optimal or near-optimal permutation schedule for the HADFSP to minimize the total flow time (HADFSP-TFT). To the best of our knowledge, there are no published papers for dealing with this problem.Obviously, the HADFSP-TFT is strongly NP-hard since its special cases (TSAFSP (Allahverdi & Al-Anzi, 2009), DFSP (Cheng et al., 2009), and three machine flowshop scheduling problem (Pinedo, 2002) are all strongly NP-hard). It is unlikely to find a polynomial time algorithm to obtain the optimal solution for the HADFSP-TFT. Recently, many meta-heuristics have been developed to provide optimal or near-optimal solutions for NP-hard problems in a reasonable execution time. The meta-heuristics include simulated annealing algorithm (SA, Eglese, 1990), genetic algorithm (GA, Holland, 1975), differential evolution (DE, (Storn & Price, 1997)), estimation of distribution algorithm (EDA, Muhlenbein & Paass, 1996), ant colony optimization (ACO, Dorigo & Gambardella, 1997), iterated greedy algorithm (IGA, Ruiz & Stutzle, 2007, 2008), variable neighborhood search (VNS, Mladenovic & Hansen, 1997) and tabu search (TS, Glover, 1996), etc. As an NP-hard problem, it is difficult to know the optimal solution of HADFSP-TFT and hence, to verify the effectiveness and preference of a meta-heuristic algorithm against others meta-heuristics if there are no other meta-heuristics for comparison. Since a skilled combination of different meta-heuristics can improve the performances of many combinatorial problems (Allahverdi & Aydilek, 2014; Chen, Pan, & Lin, 2008; Figielska, 2014; Li, Ong, & Nee, 2004; Murata, Ishibuchi, & Tanaka, 1996; Naderi & Ruiz, 2014; Tseng & Lin, 2009; Wang, Wang, Xu, Zhou, & Liu, 2012), we proposed three hybrid meta-heuristics (HGA-VNS, HEDA-VNS and HDDE-VNS) and compared them with each other for this novel scheduling problem.The remainder of this paper is organized as follows. Section 2 describes and formulates the HADFSP-TFT under consideration. Subsequently, some properties of the optimal solutions are given. Two constructive heuristics (a SPT-based heuristic and a NEH-based heuristic), three hybrid meta-heuristics (HGA-VNS, HEDA-VNS and HDDE-VNS) and a lower bound for the problem are presented in Section 3. Section 4 shows computational results for the problem. Section 5 concludes the paper and gives suggestions for future research.The problem studied here can be defined as follows. There are n jobs to be processed. They can be divided into g disjoint sets of jobsN1={J1,J2,…,Jn1},N2={Jn1+1,Jn1+2,…,Jn1+n2},…, andNg={Jn1+n2+⋯+ng-1+1,Jn1+n2+⋯+ng-1+2,…,Jn1+n2+⋯+ng-1+ng}. Each set consists of a specific type of jobs and Nhcontains nhtype h jobs. Let N=N1∪N2∪⋯∪Ngbe the set of all jobs. All jobs must be processed in three stages. Each job Jjhas m components to be processed on m different machines in parallel at the first stage. When all of these m components are completed, they are assembled into Job Jjon the same machine at the second stage. At the third stage, there are g dedicated machines M3,1,M3,2,…,M3,g. If a job Jjbelongs to type h, then it will be processed on machine M3,h.In this paper, we only discuss permutation schedules. That is, job components are to be processed on each machine at the first stage in the same order. Under the same order, jobs are assembled at the second stage while the job sequence on the dedicated machine at the third stage can be determined by the first-come, first-served (FCFS) rule.Several assumptions are done as follows.•All machines are available at time zero.Each machine can process at most one job at a time.Each job can be processed on at most one machine at a time.Setup times and transportation times are neglected.The processing time on both machines in three stages are known constants.Job processing cannot be preempted before it is finished.There are unlimited buffers between the machines of the stage one and two and the stage two and three.Fig. 1shows a simple HADFSP example with m=3 and g=2. At the first stage, three different components required by a job are processed on M1,1, M1,2, and M1,3, respectively. At the second stage, all of three components are assembled into a job on the assembly machine. At the last stage, there are two dedicated machines M3,1 and M3,2, each of which processes a special type job.Suppose that there are n=4 jobs J1, J2, J3, and J4 to be processed. Jobs J1 and J2 belong to type 1 whereas Jobs J3 and J4 belong to type 2. Table 1lists the processing time of jobs in all three stages. For a given a permutation schedule S=(J1,J4,J2,J3), its Gantt chart is shown in Fig. 2.For convenience and readability, some additional notation for HADFSP-TFT is introduced below:Model indices and input parameterskmachine index at the first stage, k=1,2,…,m;M1,kmachine for processing component k of all the jobs in the first stage, k=1,2,…,m;M2assembly machine in the second stage;i, i′job position indices, i, i′=1,2,…,n;Φa large number;pj,k(1)processing time of job Jjon machine M1,kat the first stage;pj(2)assembly time of job Jjon assembly machine;pj,h(3)processing time of job Jjon machine M3,hat the third stage.pj,h(3)>0ifJj∈Nh; 0, otherwise.Decision variablesxj,[i]binary variable. xj,[i]=1 if job Jjis assigned in position i at the first two stages; 0, otherwise;C[i],k(1)completion time of the job in position i on machine M1,kat the first stage;C[i](2)completion time of the job in position i on assembly machine M2 at the second stage;C[i],h(3)completion time of the job, which is in position i at the first two stages, on machine M3,hat the third stage, i=1,2,…,n;TFTtotal flow time,TFT=∑h=1g∑i=1nC[i],h(3).According to the above-mentioned notations and assumptions, the HADFSP-TFT can be formulated as follows.(1)minimizeTFT(2)Subject to∑j=1nxj,[i]=1∀i=1,2,…,n(3)∑i=1nxj,[i]=1∀j=1,2,…,n(4)TFT=∑h=1g∑i=1nC[i],h(3)(5)C[1],k(1)⩾∑j=1nxj,[1]·pj,k(1)∀k=1,2,…,m(6)C[i+1],k(1)⩾C[i],k(1)+∑j=1nxj,[i+1]·pj,k(1)∀i=1,2,…n-1;k=1,2,…,m(7)C[1](2)⩾∑j=1nxj,[1]·pj(2)(8)C[i+1](2)⩾C[i](2)+∑j=1nxj,[i+1]·pj(2)∀i=1,2,…n-1(9)C[i](2)⩾C[i],k(1)+∑j=1nxj,[i]·pj(2)∀i=1,2,…n;k=1,2,…,m(10)C[i],h(3)⩾C[i](2)+∑j∈Nhxj,[i]·pj,h(3)+∑j∈Nhxj,[i]-1·Φ∀i=1,2,…,n;h=1,2,…,g(11)C[i],h(3)⩽∑Jj∈Nhxj,[i]·Φ∀i=1,2,…,n;h=1,2,…,g(12)C[1],h(3)⩾∑Jj∈Nhpj,h(3)·xj,[1]+∑Jj∈Nhxj,[1]-1·Φ∀h=1,2,…,g(13)C[i],h(3)⩾C[i′],h(3)+∑Jj∈Nhpj,h(3)·xj,[i]+∑Jj∈Nhxj,[i]-1·Φ∀i=2,3,…,n;i′<i;h=1,2,…,g(14)xj,[i]∈{0,1}(15)C[i],k(1),C[i](2),C[i],h(3)⩾0The objective function (1) shows the total flow time. Constraints (2) ensure that each position in the sequence of jobs is assigned to only one job. Constraints (3) indicate that each job is assigned only to one position in the sequence of jobs. Constraints (4) calculate the value of total flow time. Constraints (9) state that the assembly of a job in position at the second stage can only start when all the components of the same job are finished. Constraints (10) ensure that the processing of a job in position i at the third stage can only start when the same job on the second stage is finished. As each job can only be process on its dedicated machine, it has no processing time and completion time on other machines. Thus, in order to calculate TFT conveniently, constraints (11) ensure thatC[i],h(3)=0,ifJ[i]∉Nh. Constraints (12) calculate the completion time of the job, which is in the first position at the first two stages, on dedicated machine M3,h. Constraints (5) and (7) calculate the job in the first position at the first two stages, respectively. (6), (8), and (13) control that, for each production stage, each job can start only after the previous job assigned to the same machine is finished. Constraints (14) and (15) define the domain of the decision variables.If no third stage, HADFSP-TFT is TSAFSP-TFT. If the first stage is neglected, the problem is a DFSP-TFT. If there is only one machine at both the first and third stages, the problem HADFSP-TFT is a flow shop scheduling problem with three machines to minimize TFT. Since the latter three problems are all strongly NP-hard (Allahverdi & Al-Anzi, 2009; Cheng et al., 2009; Pinedo, 2002), the HADFSP-TFT is also strongly NP-hard.Let S be a job sequence, job j in position i, andCj(1)(S)=C[i](1)(S)=maxk=1,2,…,m∑r=1i-1p[r],k(1)+pj,k(1). Then we have Lemma 1 as follows.Lemma 1Let Ja and Jb be two jobs which satisfypb,k(1)⩽pa,k(1),∀k=1,2,…,m, and S1 and S2 be job sequences. In S1, Ja immediately precedes Jb. S2 is generated from S1 by interchanging Ja and Jb. Then,∑j=1nCj(1)(S2)⩽∑j=1nCj(1)(S1).Suppose that, for sequence S1, the jobs in positions τ and τ+1 are Jaand Jb, respectively. We have(16)Ca(1)(S1)=C[τ](1)(S1)=maxk=1,2,…,m∑r=1τ-1p[r],k(1)+pa,k(1),(17)Cb(1)(S1)=C[τ+1](1)(S1)=maxk=1,2,…,m∑r=1τ-1p[r],k(1)+pa,k(1)+pb,k(1),(18)Cb(1)(S2)=C[τ](1)(S2)=maxk=1,2,…,m∑r=1τ-1p[r],k(1)+pb,k(1).(19)Ca(1)(S2)=C[τ+1](1)(S2)=maxk=1,2,…,m∑r=1τ-1p[r],k(1)+pb,k(1)+pa,k(1).It can be seen from Eqs. (17) and (19) that,C[τ+1](1)(S1)=C[τ+1](1)(S2). Since S2 is generated from S1 by interchanging Jaand Jb, we have(20)∑j=1nCj(1)(S1)-∑j=1nCj(1)(S2)=C[τ](1)(S1)-C[τ](1)(S2)=maxk=1,2,…,m∑r=1τ-1p[r],k(1)+pa,k(1)-maxk=1,2,…,m∑r=1τ-1p[r],k(1)+pb,k(1)⩾0,ifpb,k(1)⩽pa,k(1),∀k=1,2,…,m. Thus,∑j=1nCj(1)(S2)⩽∑j=1nCj(1)(S1)and hence Lemma 1 is proved.□Although the HADFSP-TFT is NP-hardness, in some special cases, some properties of the optimal solution can be obtained as follows.Lemma 2For HADFSP-TFT, if one of the following two conditions holds (i)minJj∈Nh{pj(2)}⩾maxJj∈Nh{pj,h(3)},∀h=1,2,…,gor (ii) n = g then the minimization of TFT is equivalent to the minimization of∑j=1nCj(2).With condition (i) or (ii), a job can be processed on its dedicated machine immediately after it is finished at the second stage. Thus, we haveCj,h(3)=Cj(2)+pj,h(3),ifJj∈Nh. Therefore,TFT=∑h=1g∑Jj∈NhCj,h(3)=∑j=1nCj(2)+∑h=1g∑Jj∈Nhpj,h(3). Note that the term∑h=1g∑Jj∈Nhpj,h(3)is a constant. Thus, for a HADFSP, the minimization of TFT is equivalent to the minimization of∑j=1nCj(2). The proof is completed.□For HADFSP-TFT, ifp1,k(1)⩽p2,k(1)⩽…⩽pn,k(1),∀k=1,2,…,m,minj=1,2,…,nmaxk=1,2,…,mpj,k(1)⩾maxj=1,2,…,n{pj(2)}, andminJj∈Nh{pj(2)}⩾maxJj∈Nh{pj,h(3)},∀h=1,2,…,gor n=g hold, then the job sequence (J1,J2,…,Jn) is optimal.SinceminJj∈Nh{pj(2)}⩾maxJj∈Nh{pj,h(3)},∀h=1,2,…,gor n=g, with Lemma 2, it is enough to consider the minimization of∑j=1nCj(2). Sinceminj=1,2,…,nmaxk=1,2,…,mpj,k(1)⩾maxj=1,2,…,npj(2), the jobs at the second stage always have idle time. Then, we haveCj(2)=Cj(1)+pj(2). Thus,∑j=1nCj(2)=∑j=1nCj(1)+∑j=1npj(2). Note that∑j=1npj(2)is a constant, it is enough to consider only the first stage schedule. The results of Lemma 1 will be hold for any two adjacent jobs in the job sequence (J1,J2,…,Jn), ifp1,k(1)⩽p2,k(1)⩽…⩽pn,k(1),∀k=1,2,…,m. Thus, the job sequence (J1,J2,…,Jn) is optimal.□For HADFSP-TFT, if relationsp1(2)⩽p2(2)⩽⋯⩽pn(2),maxk=1,2,…,mp1,k(1)=minj=1,2,…,nmaxk=1,2,…,m(pj,k(1)),maxj=1,2,…,nmaxk=1,2,…,mpj,k(1)⩽minj=1,2,…,npj(2), andminJj∈Nh{pj(2)}⩾maxJj∈Nh{pj,h(3)}or n=g hold, then the job sequence (J1,J2,…,Jn) is optimal.Ifmaxj=1,2,…,n{maxk=1,2,…,m{pj,k(1)}}⩽minj=1,2,…,n{pj(2)}, andminJj∈Nh{pj(2)}⩾maxJj∈Nh{pj,h(3)}or n=g hold, thenC[i],h(3)=C[1],h(1)+∑s=1ip[s](2)+p[i],h(3). Therefore,(21)∑h=1g∑J[i]∈NhC[i],h(3)=nC[1],k(1)+∑i=1n∑s=1ip[i](2)+∑h=1g∑J[i]∈Nhp[i],h(3)=nC[1],k(1)+∑i=1n(n-i+1)·p[i](2)+∑h=1g∑J[i]∈Nhp[i],h(3)=np[1],k(1)+∑i=1n(n-i+1)·p[i](2)+∑h=1g∑J[i]∈Nhp[i],h(3).Note that∑h=1g∑J[i]∈Nhp[i],h(3)is a constant, the minimization of∑h=1g∑J[i]∈NhC[i],h(3)is equivalent to the minimization ofnp[1],k(1)+∑i=1n(n-i+1)·p[i](2). The term∑i=1n(n-i+1)·p[i](2)can be optimized by using the SPT rule. Sincemaxk=1,2,…,mp1,k(1)=minj=1,2,…,n{maxk=1,2,…,m(pj,k(1))}andp1(2)⩽p2(2)⩽…⩽pn(2), the termsnp[1],k(1)and∑i=1n(n-i+1)·p[i](2)can be optimized simultaneously. The proof is completed.□Theorems 1 and 2 show that, in some special cases, the optimal solution of the HADFSP-TFT can be obtained by the SPT rules.For small size instances of the HADFSP-TFT, the optimal solutions can be obtained by solving the MIP model. However, it is difficult to obtain an optimal or near-optimal solution within a reasonable computational time by the proposed MIP model for the medium and large size instances of the HADFSP. Therefore, in the next section, we proposed two fast heuristics (SPT-based algorithm and NEH-based algorithm) and three hybrid meta-heuristics (HGA-VNS, HEDA-VNS and HDDE-VNS) for solving the medium- and large size instances of the problem.In this section, we present two fast heuristics, three meta-heuristics and a lower bound for the HADFSP-TFT. At first, two fast heuristics (SPT-based algorithm and NEH-based algorithm), are presented in Section 3.1. Then, three meta-heuristics are developed in Sections 3.2–3.4. The first one is a hybrid genetic algorithm-variable neighborhood search (HGA-VNS) algorithm which is presented in Section 3.2. The second one proposed in Section 3.3 is a hybrid differential evolution algorithm with VNS local search (HDDE-VNS). In Section 3.4, a hybrid estimation of distributed algorithm with VNS-based local search (HEDA-VNS) is designed. Finally, in order to evaluate the proposed algorithms, a lower bound for the HADFSP-TFT is developed in Section 3.5.Inspired by the fact that SPT rules guarantees the optimum for the single machine case (Pinedo, 2002), combining with the hybrid assembly-differentiation flow shop environments, we proposed a SPT-based heuristic for the HADFSP-TFT as follows.SPT-based heuristic:Step 1: Generate six job sequences S1, S2, S3, S4, S5 and S6 in increasing orders ofmaxk=1,2,…,m{pj,k(1)},pj(2),pj,h(3),maxk=1,2,…,m{pj,k(1)}+pj(2),pj(2)+pj,h(3), andmaxk=1,2,…,m{pj,k(1)}+pj(2)+pj,h(3), respectively.Step 2: Select the best one of the six job sequences as the solution. Then output it and its TFT value.For multi-stage permutation flow shop scheduling problem, the NEH heuristic can be adapted to solve not just for the makespan objective but also for the TFT objective (Brah & Loo, 1999; Framian, Leistenb, & Ruiz-Usanoa, 2002; Nawz, Enscore, & Ham, 1983). Thus, in order to get a fast solution for our problem, we also designed a NEH-based heuristics. The basic steps of the NEH-based heuristic are as follows.NEH-based heuristic:Step 1: Obtain a job sequence S0 in ascending order ofmaxk=1,2,…,m{pj,k(1)}+pj(2)+pj,h(3),Jj∈Nh, j=1,2,…,n.Step 2: Set r=2. Select the first two jobs from S0 and schedule them to minimize the total flow time as if there are only two jobs. Set the best one as a current solution S1.Step 3: While r<n+1 doSet r←r+1. Generate r candidate sequences by inserting the rth job in the job sequence S0 in each slot of the current solution. Select the best one with the least partial total flow time. Update the best one as a current solution S1.End whileStep 4: Output the current solution S1 and its TFT value.The two heuristics (SPT-based algorithm and NEH-based algorithm) serves not only the base for performance comparisons but also the initial solution for the meta-heuristics.Genetic algorithm (GA) is a population-based optimization method which has been proved to be effective for many combinatorial optimization problems (Murata et al., 1996; Ruiz, Maroto, & Alcaraz, 2006; Giovanni & Pezzella, 2010; Jia, Fuh, Nee, & Zhang, 2007; Xing, Han, Zhou, & Wang, 2012). At first, genetic algorithms generate initial population of individuals that will be evaluated. When the evolution of individuals is performed, the operations such as selection, crossover and mutation are carried out to generate a new generation of individuals. For the solution to escape from the local optima, a VNS-based local search procedure is performed on each individual with a probability PM, and then another one is performed on the best individual. The main part of the HGA-VNS is comprised of chromosome representation and population initialization, selection, VNS-based local search, crossover, and mutation, etc. These parts will be introduced in the following subsections.In our HGA-VNS algorithm, a chromosome is encoded as a permutation sequence of n jobs.Fig. 3shows an example of solution representation of the HADFSP-TFT with 10 jobs. Assume that the jobs belong to three different types: N1={J1,J2,J3}, N2={J4,J5,J6,J7}, and N3={J8,J9,J10}. The job sequence on each machine at the first stage is the same as that at the second stage. At the third stage, the jobs belong to the same type will be processed on a special dedicated machine. Fig. 4shows an example of the decoding process. It can be seen from Fig. 4 that at the last stage the jobs (1, 2 and 3) belongs to type 1 are assigned to M3,1; The jobs (4, 5, 6, and 7) belongs to type 2 are assigned to M3,2; The jobs (8, 9, and 10) belongs to type 3 are assigned to M3,3. It also can be seen from Fig. 4 that the job sequences on machine M3,1, M3,2 and M3,3 are (123), (4576), and (1098), respectively.LetPSdenote the population size. In our experiments, we construct two permutation sequences by using the SPT-based algorithm and the NEH-based algorithm, respectively, and then select the better one as an initial solution. Subsequently, the remaining PS−1 solutions of the population are randomly generated.In the developed HGA-VNS algorithm, we evaluate the chromosome’s fitness value by the following equations:(22)fit(chmj)=Max{TFT(chmj)}-TFT(chmj)+1Max{TFT(chmj)}-Min{TFT(chmj)}+1,j=1,…,PSwhere TFT(⋅) is the objective function of chromosome chmj; TFT(chmj) is the objective function value of chromosome chmj; fit(chmj) is the fitness value of chromosome chmj; Max{TFT(chmj)} and Min{TFT(chmj)} denote the maximum and minimum objective function values of the population in current generation, respectively.Variable neighborhood search (VNS) is a meta-heuristic for solving global and combinatorial optimization problems whose basic idea is to enhance the performance of a local search method by systematic changing the neighborhood structure (Mladenovic & Hansen, 1997). Applications of VNS are rapidly increasing in many combinatorial optimization fields (Hansen & Mladenovic, 2001; Lejeune, 2006; Liao & Cheng, 2007; Roshanaei, Naderi, Jolai, & Khalili, 2009; Yazdani, Amiri, & Zandieh, 2010). Aiming at achieving a well balance between local search and global search, two kinds of VNS-based local search methods (VNSL-I and VNSL-II) are used in our hybrid GA algorithm. In VNSL-I, two neighborhood operators (Insert and Swap) are applied alternately on each individual with a probability PM, whereas in VNSL-II, four neighborhood operators alternately (Insert, Swap, Inverse and Or-Opt) are used alternately on the best individual of the current generation.Let x=[x1,x2,…,xn] denote a solution for an instance of the HADFSP-TFT, where xiis job index in position i. The four neighborhood operators (Insert, Swap, Inverse, and Or-Opt) are defined as follows:(1)Insert(x,u,v): Insert move.The process of insert move is as follows. Move the job in position u to position v, whereas all jobs in position k, with k=u+1,…,v, are shifted one position forward along solution x. Fig. 5shows an example of insert operation. u=3 and v=8 are two positions which are chosen in a solution x=[41571069283]. Move the job in position 3 (job 5) to position 8, whereas all jobs in position k, with k=4, 5, 6, 7, 8, are shifted one position forward along the solution. Then a new solution x′=[41710692583] is obtained.(2)Swap(x,u,v): Swap move.The swap move is to swap the job in position u and the job in position v of solution x. Fig. 6illustrates an example of the swap operation. In Fig. 6, u=3 and v=8 are two positions which are chosen in a solution x=[41571069283]. Move the job in position 3 (job 5) to position 8. Simultaneously, move the job in position 7 (job 2) to position 3. Then a new solution x′=[41271069583] is obtained.(3)Inverse(x,u,v): Inverse move.The inverse move is to inverse the jobs between positions u and v of solution x. Fig. 7shows an example of inverse operation. u=3 and v=8 are two positions which are chosen in a solution x=[41571069283]. At first, the jobs between positions 3 and 8 are inversed. Then a new solution x′=[41296107583] is obtained.(4)Or-opt(x,u,v): Or-opt move.The process of Or-opt move is as follows. Insert the job in position u and the job in position u+1 between position v and v+1, whereas all jobs in position k, with k=u+2,…,v, are shifted two positions forward along solution x. Fig. 8shows an example of or-opt operation. u=3 and v=8 are two positions which are chosen in a solution x=[41571069283]. Move jobs in position 3 and 4 to positions 7 and 8, respectively, whereas all jobs in position k, with k=5, 6, 7, 8 are shifted two positions forward along the solution. Then a new solution x=[41106925783] is obtained.The procedure of VNSL-I is as follows.Step 1: Input initial solution x and set maximum iteration number Iter1.Step 2: Set loop←0 and flag←0.Step 3: While loop<Iter1 doStep 3.1: Randomly choose two positions u and v, where u<v.Step 3.2: If flag==0, then x′←Insert(x,u,v);Else x′←Swap(x,u,v);End IfStep 3.3: If TFT(x′)<TFT(x), then x←x′, flag←0;Else flag←(flag+1) mod 2;End IfStep 3.4: loop←loop+1.End WhileThe procedure of VNSL-II is as follows.Step 1: Input initial solution x and set maximum iteration number Iter2.Step 2: Set loop←0 and flag←0.Step 3: While loop<Iter2 doStep 3.1: Randomly choose two positions u and v, where u<v.Step 3.2: If flag==0, then x′←Insert(x,u,v);Elseif flag==1 then x′←Swap(x,u,v);Elseif flag==2 then x′←Inverse(x,u,v);Else x′←Or-opt(x,u,v);End IfStep 3.3: If TFT(x′)<TFT(x), then x←x′, flag←0;Else flag←(flag+1) mod 4;End IfStep 3.4: loop←loop+1.End WhileThe selection phase is to choose the chromosome for reproduction. In our approach, the roulette-wheel method is applied to select the chromosome. It uses a probability distribution for selection in which the selection probability of a given schedule is proportional to its fitness.When the chromosomes for reproduction have been selected, the crossover and mutation operators are used to produce the offspring. Crossover operator is applied to generate offspring by exchanging some genes of two parents, while mutation operator is performed on single individuals.Many crossover operators had been proposed in recent years. In this paper, the two-point crossover methods are used since its effectiveness on the permutation-based scheduling problem (Murata et al., 1996). Fig. 9shows an example of the two-point crossover method. It can be seen from the figure that the jobs between two randomly selected positions u=4 and v=7 are always inherited from one parent to a child, and the other jobs are placed in the order of their appearance in the other parent.Mutation operation can be seen as a perturbation to the individual during the evolution process and it is essential to avoid falling into local optimum. In our method, mutation operation is randomly chosen from three kinds of operators (insert, swap and inverse) for each individual.Fig. 10shows the flowchart of the proposed HGA-VNS algorithm.In this section, at first basic differential evolution algorithm (DE) is introduced in Section 3.3.1. Subsequently, a hybrid discrete DE with VNS-based local search is presented in Section 3.3.2.The differential evolution algorithm (DE), proposed by Storn and Price (1995), is a stochastic population-based meta-heuristic which operates in continuous search spaces. It is mainly comprised of four steps: initialization, mutation, crossover and selection. In a DE, a real-valued encoding method is developed for each individual. At first, PS target individuals are randomly generated as a population. Secondly, mutation and crossover operators are performed on them and then PS new individuals are generated. Finally, the new target individuals are selected to the next generation by selection operators. These steps continue until a stop criterion is met. Let Xi,ge=[xi,1,ge,xi,2,ge,…,xi,n,ge], Vi,ge=[vi,1,ge,vi,2,ge,…,vi,n,ge] and Ui,ge=[ui,1,ge,ui,2,ge,…,ui,n,ge] represent the ith target individual, the ith mutant individual and the ith trial individual at iteration ge, respectively. The procedure of the basic DE algorithm is as follows.Step 1:Initialization. Set the population size (PS), scale factor (F), crossover probability (CR), and the maximum iterations g_max. Randomly generate PS individuals of a population. Let bestit be the best individual found so far, and ge←0.Step 2:While ge<g_max doStep 2.1: Mutation phase. Mutant individual Vi,ge, is generated as follows:(23)Vi,ge←Xa,ge+F×(Xb,ge-Xc,ge),where i=1,2,…,PS, a, b and c are three different integers randomly selected between [1,PS].Step 2.2: Crossover phase. Trial individual Ui,geis generated as follows:(24)ui,j,ge+1←vi,j,ge+1,if(rand⩽CR)orj=Ej,xi,j,ge,otherwise.where i=1,2,…,PS,CR∈(0,1)is a crossover probability, rand is a uniform random number between [0,1), and Ejdenotes an integer randomly chosen between [1,n].Step 2.3: Selection phase. Each new target individual is selected as follows:(25)Xi,ge+1←Ui,ge+1iff(Ui,ge+1)<f(Xi,ge),Xi,geotherwise,where f (⋅) is the objective function.Step 2.4: update bestit and f(bestit).Step 2.5: Set ge←ge+1.End WhileStep 3:Output bestit and f (bestit).Since permutation job sequence cannot be generated by the basic DE algorithm which is originally designed for continuous optimization problems, we proposed a hybrid discrete differential evolution algorithm combined with VNS-based local search (HDDE-VNS) for the HADFSP-TFT. In our approach, solution representation, initialization, and VNS-based local search are the same as those in HGA-VNS. Mutation, crossover, selection and flowchart of the HDDE-VNS will be presented in detail as follows.(1)Mutation operatorIn our HDDE-VNS, mutation operator is adopted as follows.(26)Vi=Xa⊕F⊗(Xb⊖Xc),where⊖,⊗and⊕denote three operators, namely subtraction, multiplication, and addition operators, respectively, and they are defined as follows.Definition 1Subtraction operator⊖Let X1=[x1,1,x1,2,…,x1,n] and X2=[x2,1,x2,2,…,x2,n] be two n dimension vectors wherex1,j,x2,j∈{1,2,…,n}. Define X1⊖X2 to be an n dimension vector Ω=[ω1,ω2,…,ωn], where ωj=x1,jif x1,j≠x2,j; ωj=0, otherwise.Let X=(x1,x2,…,xn) be an n dimension vector wherexj∈{0,1,2,…,n}, c=(c1,c2,…,cn) be an n dimension vector where cjis a uniform random number generated between [0,1] and z be a real number between (0,1). Definez⊗Xto be an n dimension vector Δ=(δ1,δ2,…,δn) where δj=xjif z>cj; δj=0, otherwise.Let X1=(x1,1,x1,2,…,x1,n) and Δ=(δ1,δ2,…,δn) be two n dimension vectors wherex1,j∈{1,2,…,n}andδj∈{0,1,2,…,n}, j=1,2,…,n. DefineX1⊕Δto be an n dimension vector V=(v1,v2,…,vn), wherevj∈{1,2,…,n}. V is computed as follows. At first, set vj=x1,j, j=1,2,…,n. Then compare vjand δjfor eachj∈{1,2,…,n}. If δj≠0, find the position j′ in which vj′=δj, and then swap vjand vj′; otherwise, vjremains unchanged.Therefore, the mutation operator can be performed on the proposed individual by Definitions 1–3 and formula (26). For easy understanding, a simple example for the mutation operation is illustrated as follows. Suppose that n=5, F=0.5, X1=[2,4,3,5,1], X2=[3,5,2,1,4] and X3=[5,1,2,4,3]. Let Ω=X2X3=(ω1,ω2,ω3,ω4,ω5), Δ=F⊗Ω=(δ1,δ2,δ3,δ4,δ5), and V=X1⊕Δ=(v1,v2,v3,v4,v5).At first, Ω=X2X3 can be calculated by comparing each position of X2 and X3 from left to right. If x2,j==x3,j, ωj=0; otherwise, ωj=x2,j. For example, at the first position, x2,1=3≠x3,1=5. Thus, we have ω1=x2,1=3. At the second position, x2,2=5≠x3,2=1, we have ω2=x2,2=5. At the third position, x2,3=x3,3=2, we have ω3=0. The other positions of Ω can be determined by the same approach. After comparing all the positions, we derive Ω=[3,5,0,1,4].Secondly, we calculate Δ. Suppose that F=0.5 and randomly generated a vector c=[c1,c2,c3,c4,c5]=[0.4067,0.9355,0.8169,0.4103,0.6936]. Δ can be obtained by Definition 2. For example, at the first position, F>c1, we have δ1=3; at the second position, F<c1, we have δ2=0. After computing all the positions, we obtain Δ=[3,0,0,0,4].Finally, we calculate V=X1⊕Δ. At the first position, since x1,1=2 and δ1=3, find the position j in which xj=3. Obviously, the position j=3. Then swap jobs in position 1 and 3, we have a new vector [3,4,2,5,1]. At the second position, since x1,2=4, and δ2=0, the job in the second position of the new vector will not be changed. The jobs in other positions can be determined by the same approach as above. After determining all positions, we have V=[3,1,2,5,4].(1)Crossover operatorIn our HDDE-VNS, the similar crossover operator as that of in HGA-VNS is adopted and the crossover points are selected with a probability CR. An example of the crossover operation for HDDE-VNS is shown in Fig. 11, where CR is set to 0.5. It can be seen that the jobs in position 2, 3, 6 and 9, which are randomly chosen with the crossover probability CR, are always inherited from one target individual Vito a trial individual, and the other jobs are placed in according with the order of their appearance in the mutant individual Xi.(3)Flowchart of the proposed HDDE-VNS algorithmFig. 12illustrates the flowchart of the proposed HDDE-VNS algorithm for the HADFSP-TFT. In the algorithm, each new target individual is selected according to formula (25).EDA is a stochastic population-based heuristic for global optimization that explores the space of potential solutions by building and sample explicit probabilistic models of promising candidate solutions (Muhlenbein & Paass, 1996). EDA has been successfully applied to many combinatorial optimization problems (Chen & Chen, 2013; Hauschild & Pelikan, 2011; Jarboui, Eddaly, & Siarry, 2009; Pan & Ruiz, 2012; Wang et al., 2012). The Framework of the basic EDA can be presented as follows (Muhlenbein & Paass, 1996). Repeat the following steps until a stopping criterion is met. Starting with a randomly generated initial population which including PS individuals. Subsequently, subpopulation of Sub_PS parent individuals are selected through a selection method based on the fitness function. Next, a probabilistic model is established by estimating the probability of distribution of the selected parents. Then, new individuals are generated by sampling the probabilistic model. Finally, some individuals in the current population are replaced with newly generated offspring.Recently, Wang, Wang, Liu, and Xu (2013) proposed a simple and effective probability model for solving permutation-based scheduling problems such as hybrid flowshop scheduling and distributed permutation flowshop scheduling. They designed the probability model as a probability matrix PR. The element pri,jof the probability matrix PR represents the probability that job j appears in or before position i of the solution sequence at generation ge. The value of prijimplies the importance of a job when deciding the job order. For all i and j, pri,jis initialized to pri,j(0)=1/n.For each generation, the probability matrix PR is updated as follows (Wang et al., 2013).(27)pri,j(ge+1)=(1-θ)pri,j(ge)+θi×Sub_PS×∑k=1Sub_PSρi,j,k(ge+1),∀i,j,where ρi,j,kis the indicator function of the kth individual in the sub-population. ρi,j,kis 1 if job j appear in or before position i; 0, otherwise. θ is the learning rate of PR.In this paper, we designed a hybrid EDA combined with VNS-based local search method (HEDA-VNS). In our approach, solution representation and initialization are the same as those in HGA-VNS and HDDE-VNS. We applied the same probability model as that in Wang et al. (2013) owing to its effectiveness for solving permutation-based scheduling problems. In each generation of our HEDA-VNS, VNSL-II is performed on the best individual. Fig. 13shows the flowchart of HEDA-VNS.In this section, we develop a lower bound for the HADFSP-TFT. The lower bound is used for evaluating the performances of the proposed heuristics or meta-heuristics when the exact solution cannot be obtained within a reasonable computation time. The lower bound is based on the condition that there is no wait for differentiation machines at the third stage.Lemma 3Consider a hybrid assembly-differentiation flowshop scheduling problem. The valueLB3(2)is a lower bound of the term∑j=1nCj(2), where,LB3(2)=max{LB1(2),LB2(2)},LB1(2)=n·r(1),k(1)+∑t=1n(n-t+1)·p(t)(2)andLB2(2)=maxk=1,2,…,m∑s=1n(n-s+1)·p(s),k(1)+∑i=1npj(2).p(s),k(1),p(s)(2)andr(s),k(1)are the s-th smallest processing times in{p1,k(1),p2,k(1),…,pn,k(1)},{p1(2),p2(2),…,pn(2)}and{maxk=1,2,…,m{p1,k(1)},maxk=1,2,…,m{p2,k(1)},…,maxk=1,2,…,m{pn,k(1)}}, respectively, where, 1⩽s⩽n.In the hybrid assembly-differentiation system, the first two stages can be seen as a two stage assembly flow shop system. The completion time of the job in position i at the second stage can be calculated as follows (Potts et al., 1995).(28)C[i](2)=maxu=1,2,…,imaxk=1,2,…,m∑t=1up[t],k(1)+∑t=uip[t](2).It follows that(29)C[i](2)⩾maxk=1,2,…,m{p[1],k(1)}+∑t=1ip[t](2),∀i=1,2,…,n.Therefore,(30)∑i=1nC[i](2)⩾n·maxk=1,2,…,m{p[1],k(1)}+∑t=1n(n-t+1)·p[t](2).From Eq. (30), it follows that∑i=1nC[i](2)⩾n·r(1),k(1)+∑t=1n(n-t+1)·p(t)(2), wherep(s)(2)andr(s),k(1)are the s-th smallest processing times in{p1(2),p2(2),…,pn(2)}andmaxk=1,2,…,m{p1,k(1)},maxk=1,2,…,m{p2,k(1)},…,maxk=1,2,…,m{pn,k(1)}, respectively. Thus, theLB1(2)value is a lower bound of the term∑j=1nCj(2), whereLB1(2)=n·r(1),k(1)+∑t=1n(n-t+1)·p(t)(2).From Eq. (28), it also follows that(31)C[i](2)⩾maxk=1,2,…,m∑t=1ip[t],k(1)+p[i](2),∀i=1,2,…,n.Thus, we have(32)∑i=1nC[i](2)⩾∑i=1nmaxk=1,2,…,m∑t=1ip[t],k(1)+∑i=1np[i](2)⩾maxk=1,2,…,m∑i=1n∑t=1ip[t],k(1)+∑i=1np[i](2)=maxk=1,2,…,m∑t=1n(n-t+1)·p[t],k(1)+∑i=1np[i](2).From Eq. (32), it follows that(33)∑i=1nC[i](2)⩾maxk=1,2,…,m∑t=1n(n-t+1)·p(t),k(1)+∑j=1npj(2),wherep(t),k(1)is the t-th smallest processing times inp1,k(1),p2,k(1),…,pn,k(1),1⩽t⩽n.Therefore, theLB2(2)value is also a lower bound of the term∑j=1nCj(2), where(34)LB2(2)=maxk=1,2,…,m∑t=1n(n-t+1)·p(t),k(1)+∑j=1npj(2).LetLB3(2)=max{LB1(2),LB2(2)}. Then the valueLB3(2)is a lower bound of the term∑j=1nCj(2). The proof is completed.□The valueLB(3)is a lower bound for the HADFSP-TFT, whereLB(3)=LB3(2)+∑h=1g∑Jj∈Nhpj,h(3).IfJj∈Nh, thenCj,h(3)⩾Cj(2)+pj,h(3). Thus, from Lemma 3, it follows thatTFT=∑h=1g∑Jj∈NhCj,h(3)⩾∑j=1nCj(2)+∑h=1g∑Jj∈Nhpj,h(3)⩾LB3(2)+∑h=1g∑Jj∈Nhpj,h(3).Therefore, the value,LB3(2)+∑h=1g∑Jj∈Nhpj,h(3), provides a lower bound for the HADFSP-TFT. Theorem 3 is proved.□

@&#CONCLUSIONS@&#
This paper studies a novel hybrid assembly-differentiation flowshop scheduling problem to minimize the TFT. Some properties of the problem are presented. In order to deal with this problem, an effective MIP model is formulated and several algorithms including two heuristics and three hybrid meta-heuristics (HGA-VNS, HDDE-VNS, and HEDA-VNS) are proposed. A lower bound is developed for evaluating the performances of the proposed algorithms. For the best of our knowledge, this study is the first attempt to deal with the problem.Computational experiments are conducted to test the performances of the MIP model, the proposed heuristics and meta-heuristics. Experimental results show that the MIP model is effective for small-size instances. The obtained results indicate that HDDE-VNS performs more efficiently and robustly than HGA-VNS and HEDA-VNS. Statistically results show that HDDE-VNS and HGA-VNS are not much affected by n and m. The effectiveness of the local search steps in HGA-VNS, HEDA-VNS and HDDE-VNS have been examined. Experimental results also reveal that all the proposed algorithms combined with VNS-based local search obtain much better performances than those without local search.It is hard to know which algorithm is better before compared and tested. Thus, based on three classical meta-heuristics (GA, DEA and EDA), we proposed three hybrid meta-heuristics and compared them each other for determining their preferences. By simulation and comparison, we know that the performance of HDDE-VNS is best, while both HGA-VNS and HEDA-VNS can solve HADFSP-TFT effectively. For small-size instances, all three meta-heuristics can reach the optimum for 43 of 48 instances. For the medium-size instances, the performances of all the proposed meta-heuristics are very close. Moreover, the performances of the HGA-VNS and the HDDE-VNS are very close for the large-size instances.It also demonstrates that, the results obtained by the proposed meta-heuristics are apparently better than those by the NEH heuristic. However, the NEH can generate reasonable solutions within a very little computing time. That is to say, the meta-heuristics reach better solutions than the NEH, whereas, the NEH consume much less computing time than the proposed meta-heuristics. Therefore, in the real industry environment, the meta-heuristics or the NEH can be selected to meet diverse demands.In future work, we will focus on developing more efficient constructive heuristics and meta-heuristics for the HADFSP-TFT. In order to balance out the often encountered conflict objectives, we will consider a multi-objective approach for HADFSP. Also, it is promising to apply our proposed algorithms for other permutation-based optimization problems. Finally, it is also worth developing a more efficient lower bound for evaluating the proposed algorithms.