@&#MAIN-TITLE@&#
Efficient processing of keyword queries over graph databases for finding effective answers

@&#HIGHLIGHTS@&#
We define a new measure of relevance of a node in the graph to a keyword query.We propose an extended answer structure for a top-k query over graph databases.We propose an inverted list index and search algorithm to find top-k answer trees.We enhanced the basic method for more efficient and scalable processing the query.Experiments show that the proposed method can find effective top-k answers efficiently.

@&#KEYPHRASES@&#
Graph database,Keyword search,Top-k query processing,

@&#ABSTRACT@&#
In this paper, we study on effective and efficient processing of keyword-based queries over graph databases. To produce more relevant answers to a query than the previous approaches, we suggest a new answer tree structure which has no constraint on the number of keyword nodes chosen for each keyword in the query. For efficient search of answer trees on the large graph databases, we design an inverted list index to pre-compute and store connectivity and relevance information of nodes to keyword terms in the graph. We propose a query processing algorithm which aggregates from the pre-constructed inverted lists the best keyword nodes and root nodes to find top-k answer trees most relevant to the given query. We also enhance the method by extending the structure of the inverted list and adopting a relevance lookup table, which enables more accurate estimation of the relevance scores of candidate root nodes and efficient search of top-k answer trees. Performance evaluation by experiments with real graph datasets shows that the proposed method can find more effective top-k answers than the previous approaches and provides acceptable and scalable execution performance for various types of keyword queries on large graph databases.

@&#INTRODUCTION@&#
Recently, graph-structured data are widely used in many applications such as XML, bio-informatics, semantic web, ontologies, and social networking services. Keyword-based query over graph-structured databases has been attracting much attention since it enables users to represent their information need using only a set of keyword terms, instead of using a query language and understanding the underlying database schema (Chen, Wang, Liu, & Lin, 2009; Dalvi, Kshirsagar, & Sudarshan, 2008; Golenberg, Kimelfeld, & Sagiv, 2008; He, Wang, Yang, & Yu, 2007; Kacholia et al., 2005; Kargar & An, 2011; Kim, Park, & Lee, 2011; Li, Ooi, Feng, Wang, & Zhou, 2008; Park, 2013; Tran, Rudolph, Cimiano, & Wang, 2009). Keyword-based query processing has also been studied extensively in the literature of relational databases, where relational data can be modeled as a directed graph of tuples based on the foreign-key relationships among tuples (Agrawal, Chaudhuri, & Das, 2002; Baid, Rae, Li, Doan, & Naughton, 2010; Balmin, Hristidis, & Papakonstantinou, 2004; Bergamaschi, Domnori, Guerra, Lado, & Velegrakis, 2011; Bhalotia, Hulgeri, Nakhe, Chakrabarti, & Sudarshan, 2002; Ding et al., 2007; Hristidis, Gravano, & Papakonstantinou, 2003; Hristidis & Papakonstantinou, 2002; Li, Zhou, Feng, & Wang, 2009; Liu, Yu, Meng, & Chowdhury, 2006; Luo, Lin, Wang, & Zhou, 2007; Qin, Yu, & Chang, 2009; Qin, Yu, Chang, & Tao, 2009).Keyword-based search on a graph-structured database usually returns a set of connected structures derived from the database, which represent how the data containing query keywords are interconnected in the database. In most approaches, a sub-tree of the graph is used to describe an answer to a given query. Since there can be a significant number of answer structures in a large graph database, a relevance scoring function is often used to rank the candidate answers and return top-k ones most relevant to the query.The problem of answering keyword-based queries over graph-structured databases is described as follows. Let G=(V, E) be a directed graph representing a graph-structured database, where each node is labeled with some text. The nodes and edges in G may have weights on them. Given a keyword query Q over G consisting of a set of keywords, denoted by Q={k1, k2, …, kl}, an answer to Q is defined as a sub-tree T of G satisfying the following properties: there exists a set of nodes in T called keyword nodes, where each node contains at least one keyword in Q, and the leaf nodes of T only come from those keyword nodes. Given a relevance scoring function rel(T), which maps an answer sub-tree T to a numeric score value measuring goodness of T or relevance to Q, top-k processing of Q should find k best answers with the highest values of rel(T).To evaluate and rank the answer sub-trees, various scoring functions have been proposed in the literature based on different semantics, which will be described in Section 2. In this paper, we adopt distinct root-based semantics, where the weight of a sub-tree is computed as the sum of the shortest distance from the root to each keyword node and at most one sub-tree rooted at each node is considered an answer to the query (Dalvi et al., 2008; He et al., 2007; Kacholia et al., 2005). This approach can deal with top-k query processing over very large graph databases more efficiently than the other approaches based on Steiner tree-based semantics. It also enables effective indexing on the graph (He et al., 2007).For example, suppose that a keyword query Q={volcano, ocean} is given on a graph-structured data G in Fig. 1(a). As indicated in the figure, nodes K, L, M, O, and R are keyword nodes containing keyword volcano and nodes S and U are keyword nodes for ocean. Fig. 1(b) shows some possible answer trees rooted at node B, C, or D. Under the distinct root-based semantics, only one among the sub-trees TB1, TB2, and TBwhich are rooted at node B can be returned as an answer to Q. Note that in the previous approaches, only sub-trees including exactly one keyword node for each query keyword, such as TB1, TB2, TC1, and TD1, have been considered candidate answer trees. However, we consider that sub-trees which have more than one keyword node for each query keyword, such as TBand TC, also can be possible answers to Q.The main contributions of our work are as follows:•To produce more effective and relevant search result for a given query, we propose an extended structure of answer trees and a new relevance metric and ranking mechanism for the answer trees. Different from the existing approaches, the proposed answer structure has no such constraint that it should include one and only one keyword node for each keyword in the query. That is, an answer tree is allowed to contain a part of query keywords and to have more than one node containing the same keyword, and based on the new measure of relevance, more extended and relevant answers can be generated.For efficient finding of top-k answers in the proposed structure, we design an inverted list-style index to the keywords and nodes in the graph, which stores information on the connectivity and relevance of a node to each keyword term. Then we present a basic query processing algorithm which exploits the pre-constructed inverted lists to aggregate most relevant keyword nodes for each candidate answer tree with a distinct root and find top-k answer trees most relevant to the given query.Aiming at improving the efficiency of the basic approach, we extended the above inverted list index to store at each entry additional relevance information of another entry related in the same list. We also introduce a relevance lookup table which pre-computes and stores the largest relevance value of each node to each keyword term in the graph. Then we present an enhanced search algorithm based on the extended inverted list and the relevance lookup table. It estimates the worst and best relevance scores of a node more closely to its actual score and thus can find top-k answer trees rooted at different nodes more efficiently than the basic approach.The rest of the paper is organized as follows. Section 2 presents related work and motivation of our study. Section 3 defines a new answer structure and relevance measure for keyword queries over graph databases. In Section 4, we propose an inverted list index for keywords and nodes in the graph and a top-k query processing algorithm using the index. In Section 5, we improve the proposed indexing scheme and present a more efficient search method. We provide experimental results on the effectiveness and performance of the proposed method in Section 6 and draw a conclusion in Section 7.There has been much work on keyword search over relational databases (Agrawal et al., 2002; Baid et al., 2010; Balmin et al., 2004; Bergamaschi et al., 2011; Bhalotia et al., 2002; Ding et al., 2007; Hristidis & Papakonstantinou, 2002; Hristidis et al., 2003; Li et al., 2009; Liu et al., 2006; Luo et al., 2007; Qin, Yu, Chang, 2009; Qin, Yu, Chang, Tao, 2009). Many approaches, however, use underlying schema information to generate candidate expressions on the schema graph and then translate them into SQL queries to be executed on the database to get answer trees of tuples (Agrawal et al., 2002; Baid et al., 2010; Balmin et al., 2004; Bergamaschi et al., 2011; Hristidis & Papakonstantinou, 2002; Hristidis et al., 2003; Liu et al., 2006; Luo et al., 2007; Qin, Yu, Chang, 2009). Thus, they are only applicable to querying on relational data. Other approaches are schema-agnostic and materialize a relational database as a graph, and thus they can be applied to any graph-structured data (Bhalotia et al., 2002; Ding et al., 2007; Li et al., 2009; Qin, Yu, Chang, Tao, 2009).Most of the studies on keyword-based search over graph databases find minimal connected sub-trees as succinct answers to a given query (Bhalotia et al., 2002; Dalvi et al., 2008; Ding et al., 2007; Golenberg et al., 2008; He et al., 2007; Kacholia et al., 2005) while some recent approaches search for sub-graphs to provide more informative answers (Kargar & An, 2011; Li et al., 2008; Qin, Yu, Chang, Tao, 2009). In this paper, we adopt a tree-based approach for efficient query processing over a large volume of graph data.To evaluate and rank sub-trees satisfying answer conditions, weight functions have been proposed in the literature based on two different semantics, namely Steiner tree-based semantics and distinct root-based semantics (Yu, Qin, & Chang, 2010). The Steiner tree-based semantics defines weight of an answer tree as the total weight of the edges in the tree. Under this semantics, finding an answer tree with the smallest weight is a well-known optimal group Steiner tree problem, which is NP-complete (Hwang & Richards, 1992). Since there can be exponentially many candidates to consider to select the optimal Steiner tree, the previous approaches proposed a heuristic backward search algorithm to find an l-approximation of the optimal answer where l is the query size (Bhalotia et al., 2002) or a dynamic programming algorithm to find the optimal answer for small-sized queries efficiently (Ding et al., 2007). Another work presented an algorithm to enumerate answers in a 2-approximate order by height with polynomial delay (Golenberg et al., 2008). Li et al. (2009) proposed a polynomial time approximate solution for answering top-k queries over relational databases based on Compact Steiner Tree structure and the capabilities of relational DBMS. Those methods, however, cannot produce top-k Steiner tree-structured answers efficiently over large-scale graph databases.As an alternative to the Steiner tree semantics, other approaches adopted easier semantics, namely distinct root semantics, to find answer trees rooted at distinct nodes (Dalvi et al., 2008; He et al., 2007; Kacholia et al., 2005). For each node in the graph, only a single sub-tree which has a minimal weight among those rooted at the node is considered a candidate answer to the query. The weight of a sub-tree is defined as the sum of the shortest distances from the root to the keyword nodes chosen for each query keyword. Under this semantics, given a graph having n nodes, there can be at most n answer trees and thus we can deal with queries over very large graph databases more efficiently than under the Steiner tree semantics. A bi-directional search algorithm proposed in Kacholia et al. (2005) performs backward explorations of the graph starting from nodes containing query keywords like BANKS (Bhalotia et al., 2002), as well as executing forward explorations from the potential roots of answer sub-trees toward keyword nodes. It uses a heuristic activation strategy to prioritize nodes to expand during the bi-directional search while it does not take advantage of any prior knowledge on the connectivity between nodes in the graph. Thus it may lead to poor performance on certain complex graphs. In BLINKS approach (He et al., 2007), indexing schemes and query processing algorithms were proposed to speed up the bi-directional exploration of the graph with a good performance guarantee. A single-level index consisting of sorted keyword-node lists and a node-keyword map pre-computes and indexes all the shortest paths and distances from nodes to keywords in the graph. By accessing the sorted lists of nodes relevant to the given keywords in parallel and exploiting the node-keyword map, the search method of BLINKS performs backward and forward expansions efficiently and finds top-k answers in a time and space efficient manner. To reduce index space for large graph, they also suggested graph partitioning strategies and a bi-level indexing scheme. Dalvi et al. (2008) considered the issue of keyword search on graphs that are larger than main memory. They proposed to create and exploit a multi-granular representation of graph data to minimize I/O by directing search toward limited areas of the graph resident in memory. They suggested two approaches to extending existing search algorithms such as BANKS (Bhalotia et al., 2002) and bi-directional search (Kacholia et al., 2005) to work on multi-granular graphs. As described in the paper, any in-memory graph search algorithm can be used in their approach. Thus, their strategy of exploiting a multi-granular representation of the graph in search process is orthogonal to our work based on a new answer structure and indexing scheme.The previous approaches including those mentioned above have a common constraint on the answer structure employed: it should have one and only one keyword node for every keyword in the query. In Fig. 1, for example, sub-tree TB1 of G is a possible answer to query Q={volcano, ocean}, which is rooted at node B and has keyword nodes K and S chosen for keywords volcano and ocean, respectively. Note that, besides node K, there are other keyword nodes L, M, and O in G which contain volcano and are reachable from node B, but an answer tree rooted at node B should have only one of them in the previous approaches. Moreover, the distinct root semantics allows at most one answer tree rooted at a certain node hence another candidate answer tree TB2 rooted at node B cannot be returned with TB1 at the same time. As shown in Fig. 1(b), there are other candidate answer trees, such as sub-tree TC1 rooted at C and containing {O, U} as keyword nodes and sub-tree TD1 rooted at D and having {R, U} as keyword nodes. Based on the distinct root semantics where the weight of a sub-tree is computed as the sum of the shortest distance from the root to each keyword node selected, answer trees TB1 and TB2 have a larger weight, and thus lower relevance score, than answer tree TC1. On the other hand, TB1 and TB2 have the same weight or relevance score as TD1 since they have the same distances from the root to the keyword nodes in them. However, we observe that node B has connections to more nodes containing query keywords than node C or D have, and we consider that we can obtain a more relevant answer by including more paths from B to the keyword nodes in a single sub-tree rooted at B.To improve the quality of query result based on the consideration, we propose a new answer structure which has no constraint on the number of keyword nodes chosen for each query keyword, so that an answer tree can have more than one keyword node for some keywords while it may include no keyword node for other keywords. To restrict an answer tree to an acceptable size, we limit the number of pairs of a keyword and keyword node for it in an answer tree. For instance, allowing maximum 4 pairs of a keyword and keyword node to be included in an answer tree for the query in Fig. 1, we have a new candidate answer tree TBwhich is extended from the conventional answer trees TB1 and TB2 by containing keyword nodes M in addition to K and L for volcano, as shown in Fig. 1(b). A sub-tree TCrooted at node C with four keyword nodes M, O, S, and U also can be a candidate answer to the query. To search for the best answer trees for a given query, we will propose an effective relevance measure for the candidate answer trees in Section 3. According to the metric, TBis considered more relevant to the query than TCor TD1 in our approach.In this section, we propose a structure of answer trees and a relevance measure for them. Given a data graph G=(V, E), let K be the set of keyword terms extracted from the nodes in V(G). We first define relevance of a node in V(G) to a keyword term in K contained in a specific node in the graph. When a node contains a keyword term, the relevance of the node to the keyword is computed based on the tf-idf weighting scheme (Buttcher, Clarke, & Cormack, 2010) which is popularly used in information retrieval. The relevance of a node n to another node m in the graph is calculated based on the shortest distance from n to m1For the simplicity of description, we do not consider weight on edges in the graph.1. We consider that even if a node does not contain a keyword k, n is relevant to k if there is a path from n to another node s which contains k, i.e., a keyword node for k. Its relevance is formally defined as follows.Definition 1Relevance of a node n to a keyword k contained in a node sGiven a keyword k∈K and a node s∈V(G), let tf(k,s) be the number of occurrences of k in s and df(k) be the number of nodes in V(G) which contain k. The relevance of s to k is defined byAccording to the above definition, when s does not contain k or there is no path from n to s, rel(n, s, k) becomes 0. Also note that if n and s denote the same node, rel(n, s, k) equals to the relevance of s to k, i.e., rel1(s, k). A node n is called relevant to a keyword k if and only if there exists a keyword node s for k such that rel(n, s, k)>0. Given a keyword query, an answer tree to the query is defined based on rel(n, s, k) as follows.Definition 2Answer tree for a queryGiven a keyword query of size l, Q={k1, k2, …, kl}, on the data graph G and a constant integer p greater than or equal to l, let V(Q) be a set of keyword nodes in G which contain a keyword in Q. For a node n in V(G), Topp(n,Q) is defined as a set of at most p pairs of a node s in V(Q) and a keyword k in Q where the relevance of n to k contained in s is in the p highest over all the pairs of a node in V(Q) and a keyword in Q. Formally,Note that based on the distinct root semantics, our approach finds at most one answer tree Tnrooted at each node n in the graph. It is derived from at most p pairs of a query keyword k and a keyword node s for k to which its root node n is most relevant. For ranking candidate answer trees with different root nodes, we propose a relevance measure for them as follows.Definition 3Relevance measure for answer treesGiven an answer tree Tnfor query Q rooted at node n, the relevance of Tnto Q, denoted by rel(Tn,Q), is the sum of the relevance of n to k contained in s for all pairs of (s, k) in Topp(n,Q) shown in Definition 2, i.e.,Given a keyword query Q={volcano, ocean} on the graph G in Fig. 1(a), the set V(Q) of the keyword nodes for Q is {K, L, M, O, R, S, U}. Assuming that p=4, we have Topp(B, Q)={(K, volcano), (L, volcano), (M, volcano), (S, ocean)} and Topp(C, Q)={(M, volcano), (O, volcano), (S, ocean), (U, ocean)} based on Definition 2, and thus two possible answer trees TBand TCrooted at nodes B and C, respectively, can be derived from the graph as shown in Fig. 1(b). Supposing that the relevance rel1(s, k) of keyword node s to each keyword k in Q are the same as 1,rel(TB,Q)=13+13+13+14=1.25andrel(TC,Q)=14+15+13+13=1.12based on Definition 3 hence answer tree TBis considered more relevant to Q than TCis.In this section, we present an indexing scheme and query processing algorithm to find k best answers to a given keyword query based on the answer structure and relevance measure defined in the previous section.To enable efficient search of top-k answer trees in a graph database, we suggest an inverted list-style index which pre-computes and stores information on the relevant nodes for each keyword term in the database. We first find all keyword nodes and relevant nodes for each keyword term in the graph, pre-compute relevances of the nodes to the keyword as defined in Definition 1, and then build an inverted list per keyword which can be formally defined as follows.Definition 4Inverted list L(k)for a keyword k). For a keyword term k in the graph, let S(k) be the set of nodes in V(G) which contain k. The inverted list for k, denoted by L(k), is a list of triples (n, s, rel(n, s, k)) obtained from all the pairs of nodes n∈V(G) and s∈S(k) such that rel(n, s, k)>0. The list entries are sorted in a non-increasing order of their relevance values. Formally,We call an entry (n, s, r) in the list an entry of node n. As defined above, L(k) stores entries of the nodes that either contain keyword k or have a path to a keyword node for k in a decreasing order of relevance to k. Therefore, we can identify the nodes that are most relevant to k in terms of relevance measure rel(n, s, k) by reading the entries in L(k) in order. Note that the proposed inverted list is different from the conventional one used for ranked search over documents or multi-dimensional data (Bruno, Gravano, & Marian, 2002; Fagin, Lotem, & Naor, 2003; Güntzer, Balke, & Kießling, 2001) in that L(k) not only has entries of the keyword nodes for k but also has entries of the nodes that do not contain k. The proposed inverted list structure is also distinguished from the keyword-node list used in BLINKS (He et al., 2007) since our inverted list may have multiple entries of the same node n, one for each keyword node reachable from n, while the latter has only a single entry per node n which stores a keyword node in the shortest distance from n. In order to compute the amount of relevance of a node to the keywords in a given query, we should aggregate a set of the most relevant entries of the same node in the inverted lists according to the query keywords. The query processing algorithm exploiting the proposed inverted list index will be detailed in the following section.Our query processing model is based on the threshold algorithm (Fagin et al., 2003; Güntzer et al., 2001), which is popularly used for evaluating top-k queries on multi-dimensional data, such as similarity search on multimedia objects (Best, Majumdar, Schenkel, Theobald, & Weikum, 2006; Bruno et al., 2002; Theobald, Weikum, & Schenkel, 2004). It performs sequential scans on the pre-computed index lists which are sorted in descending order of per-attribute scores of data and searches for top-k data items having the highest total scores aggregated from the index lists.Given a query Q={k1, k2, …, kl}, let L(Q) be the set of pre-constructed inverted lists for the keywords in Q, i.e. L(Q)={L(ki) | ki∈Q}. The query processor performs sequential scans on the lists in L(Q) in parallel by reading their entries in a round-robin manner. During the scans, it maintains the relevance values of the entries at the current scan position in each list L(ki), denoted by curScorei(1⩽i⩽l). The largest one among those is called maxCurScore, i.e.maxCurScore=max1⩽i⩽lcurScoreiNote that since the entries in the lists are stored in a non-increasing order of their relevances, maxCurScore can serve as an upper bound for the relevances of the entries which have not been read yet from the lists in L(Q).While reading the lists, the query processor also maintains a priority queue per a root node n of a candidate answer tree, called a relevance queue of n and denoted by qn. It stores at most p entries of n which have the highest relevance values among the entries of n retrieved from the lists. From an entry (n, s, r), only the pair of s and r is stored in qn. Since qnmaintains the current top-p relevance values of n found from the lists, the sum of the current values in qncan be a lower bound for the relevance rel(Tn, Q) of an answer tree Tnrooted at n when the lists in L(Q) are scanned. Thus, we define the worst score of n as follows:(1)worstScore(n)=∑r∈qnrOn the other hand, the best score of n can be calculated using the relevances in qnand maxCurScore. Let Rnbe a multi-set of the relevance values in qnthat are greater than or equal to maxCurScore, i.e. Rn={r|(s,r)qn,rmaxCurScore} Since maxCurScore is an upper bound for the relevances of the entries currently unseen from the lists in L(Q), it is guaranteed that the relevance values in Rnbelong to the p highest of all the entries of n in the lists while the other relevance values in qncan be outweighed by relevance values which will appear in the lists. Assuming that all the currently unknown ones among the top-p relevances of n are the same as maxCurScore, an upper bound of the relevance rel(Tn, Q), called the best score of n, can be defined as follows:(2)bestScore(n)=∑r∈Rnr+maxCurScore·(p-|Rn|)Note that since maxCurScore monotonically decreases as entries are retrieved from the lists, worstScore(n) increases whereas bestScore(n) decreases monotonically during the list scan. When the relevance queue qnhas p entries and all the relevance values in them are no less than maxCurScore (i.e., |Rn|=p), both bestScore(n) and worstScore(n) are equal to rel(Tn, Q).Example 2Given a graph G and a keyword query Q={k1, k2, k3, k4}, Fig. 2shows an example of computing worst and best scores of a node n in G when we process Q using the inverted lists in L(Q). In the figure, lines represent inverted lists for the query keywords, scanned from left to right in a round-robin manner. On the lists, the entries of n are indicated by closed dots. Assuming that scanning of the lists has proceeded to the entries denoted by rectangles, curScorei′s (1⩽i⩽4) are 2.4, 3.0, 1.5, and 2.2, respectively, and maxCurScore=3.0. Given p=6, the relevance queue of n currently has 5 entries of n retrieved from the lists, i.e. qn=[(s1, 4.0), (s2, 3.5), (s4, 3.0), (s3, 2.3), (s5, 1.7)], and a multi-set Rnof the relevance values in qnthat are greater than or equal to maxCurScore is {4.0, 3.5, 3.0}. Consequently, based on Eqs. (1) and (2), we have worstScore(n)=∑r∈qnr=14.5 and bestScore(n)=∑r∈Rnr+3.0 · (6–3)=19.5.As scanning the lists in L(Q), we can find the nodes which are roots of top-k answer trees using two priority queues:•Top-k queue T stores at most k nodes with the highest worst scores over the nodes that have been found from the lists. The nodes in T are sorted by their worst scores in a descending order. The minimum (i.e., rank-k) worst score value from the current top-k nodes in T is called min-k, i.e.,min-k=minn∈T{worstScore(n)},if|T|=k0,otherwiseCandidate queue C maintains candidate nodes which have a worst score smaller than min-k but could still make it into the top-k queue T. A node whose best score is also smaller than min-k cannot belong to the final top-k nodes and thus is rejected or removed from C. The nodes in C are sorted in a descending order of their best scores to facilitate looking up a candidate node having the maximum best score.Whenever the worst and best scores of a node change as a new entry of the node is read from a list, we check if the node can be entered into top-k queue T or it should be maintained in candidate queue C. Query processing can terminate safely with the correct top-k relevant nodes in T when the maximum best score in C as well as the best score of any node nucurrently unseen from the lists is no higher than min-k, i.e., when(3)|T|=kandmax{maxm∈C{bestScore(m)},bestScore(nu)}⩽min-k,where bestScore(nu)=maxCurScore · p. Then, using the nodes in T and the keyword nodes stored in their relevance queues, we can derive top-k answer trees from the graph database as defined in Definition 2. Specifically, for each node n in T, an answer tree Tnrooted at n is constructed by merging the nodes and edges in the shortest paths from n to each keyword node in qn.Fig. 3shows a pseudo-code algorithm of the basic query processing scheme described above. At each step of reading an entry from an inverted list, the following tasks are performed repeatedly. Given an entry of a node n read, it is ignored if the correct top-p relevances of n had been found from the lists or node n had been already rejected from candidate queue C (Line 7). In Line 8∼10, the current entry is inserted into relevance queue qn, and worstScore(n) and bestScore(n) are computed based on the relevance values in qnand maxCurScore. If the current entry is the first entry of n found from the lists, n can be inserted into top-k queue T or candidate queue C depending on its worst and best scores as well as the current min-k value in T (Line 11∼13). If n is already in T, T should be re-organized considering the new worstScore(n) (Line 14∼15). Otherwise, if n exists in C, it is moved into T or remains in C or is eliminated from C depending on the new worstScore(n), bestScore(n), and min-k value (Line 16∼20). As mentioned earlier, if Eq. (3) is satisfied after the current entry is processed, the algorithm stops immediately and top-k answer trees are derived from the graph using the top-k relevant nodes in T and the keyword nodes stored in their relevance queues (Line 22 and 26).In our method, the worst and best scores of the nodes in top-k queue or candidate queue may change as the list scan proceeds since they depend on maxCurScore determined from the entries at the current scan position of each list. However, a naïve approach to re-calculating the worst and best scores of all the nodes in the queues and to conducting re-organization of the queues at every time of reading an entry from a list would result in very high performance overhead. Instead, we adopt a strategy of periodic updates and cleaning of the queues after every pre-defined number of entries is read from the lists. As shown in Line 23, procedure updateQueues is invoked periodically, which performs rebuilding of top-k queue and candidate queue based on maxCurScore (Refer to the pseudo-code of the procedure in Fig. 3).In the basic method described in Section 4, the worst score and best score of each node n are estimated assuming that all the unknown relevances of the entries of n unseen from the inverted lists are equal to the largest of the relevances of the entries at the current scan positions of the lists, i.e. maxCurScore. This strategy, however, is too conservative since the actual relevance of an entry of n unseen from a list L(ki) can be much smaller than curScorei, the relevance of the entry at the current scan position in the list L(ki). We consider that if we can look ahead at the relevance of the next entry of the same node n stored after the current scan position in each list, we can predict its worst score and best score more closely to the actual relevance rel(Tn, Q) by exploiting the next relevance value instead of maxCurScore. Based on the consideration, we extend the inverted list structure to store in each entry a relevance of the next entry of the same node appearing in the list. Then we propose an enhanced search algorithm which can compute a narrower range of relevance score for each node in the graph and identify top-k answer trees for a given query earlier than the basic query processing algorithm.For more efficient processing of a keyword query, we extend the index structure defined in Definition 4 as follows.Definition 5Extended inverted list L′(k)for a keyword k). Given a keyword term k, let S(k) be a subset of nodes in V(G) which contain k. For a node n in V(G), let L(n, k) be an ordered list of quadruples (n, si, ri, r′i) which are derived from all nodes siin S(k) and sorted in a non-increasing order of ri, the relevance of n to k contained in si, i.e. rel(n, si, k). Formally,The extended inverted list for k, denoted by L′(k), is a list of quadruples merged from the lists L(ni, k) for all nodes niin V(G), which are sorted in a non-increasing order of their relevance values.The extended inverted list L′(k) defined above is different from the original inverted list L(k) in that when an entry ei=(n,si,ri,ri′)of a node n is read from the list, we can see not only the relevance ri=rel(n, si, k) but also the relevance ri+1=rel(n, si+1, k), i.e. the relevance of the next entry ei+1=(n,si+1,ri+1,ri+1′)of n which follows eiin the list sinceri′in eiis equal to ri+1 in ei+1. For the first entry of n, however, we do not know its relevance until we retrieve the entry in the sequential scan of the list. Thus, for more efficient query evaluation, we also consider constructing a lookup table to store relevance of the first entry of each node appearing in the list for each keyword term.Definition 6Relevance lookup table for a graph GGiven a graph G=(V, E), let K be a set of keyword terms in V(G). The relevance lookup table RT is a hash table which stores for each node n in V(G) and keyword k in K, the largest relevance rel(n, s, k) among all keyword nodes s containing k in G. Formally,The overall query processing strategy is similar to the basic method described in Section 4.2. Assuming that L′(Q) be the set of extended inverted lists for a given query Q={k1, k2, …, kl}, i.e. L′(Q)={L′(ki)|ki∈Q}, the entries in the lists in L′(Q) are sequentially read in a round-robin manner and the top-p relevant entries of each node n are aggregated using its relevance queue qn. The current top-k relevant nodes and candidate nodes for the query answers are maintained in a top-k queue T and candidate queue C until the final top-k nodes are identified.However, different from the basic method, the enhanced approach exploits next relevance values in the entries of the extended inverted lists, as well as the relevance lookup table, to estimate the worst and best scores of each node more exactly. When an entry of a new node n is found from a list, the relevances of the first entries of n in the other lists in L′(Q) are also looked up from the relevance lookup table and inserted into the relevance queue qnof n in advance. Whenever an entry (n, s, r, r′) of a node n is read from a list, not only its relevance r but also the next relevance r′ is stored in qnif it belongs to the current top-p relevance values of n. Since qnhas at most p highest relevances of n which have been found from the lists, the sum of those values in qngives a lower bound for the relevance rel(Tn, Q) of an answer tree Tnrooted at n. Thus, the worst score of n is defined as(4)worstScore(n)=∑r∈qnrFor each node n in top-k queue T and candidate queue C, the query processor maintains its next relevance value for each query keyword kiin Q, which is either retrieved from the list L′(ki) most recently or looked up from RT(G). Denoted by nextScoren,i, it indicates the relevance in an entry of n which will appear next in the list L′(ki) and the largest of nextScoren,i′s, denoted by maxNextScoren, represents the highest relevance of n stored in the remaining parts of the lists in L′(Q). Thus, assuming that all the unknown relevances are the same as maxNextScoren, an upper bound for the relevance rel(Tn, Q), called the best score of n, can be computed based on maxNextScoreninstead of maxCurScore as follows:(5)bestScore(n)=∑r∈Rn′r+maxNextScoren·(p-|Rn′|)where R′nis a multi-set of the relevance values in qnwhich are no less than maxNextScoren, i.e.Rn′={r|(s,r)∈qn,r⩾maxNextScoren}.Note that while the worst score of n is computed by all the known relevances of n including the next relevance values looked ahead, the best score of n is calculated using only the relevances greater than or equal to maxNextScoren. Since the entries in each list are stored in a descending order of relevance, nextScoren,i′s (1⩽i⩽l) and maxNextScorenmonotonically decrease as entries are read from the lists. Therefore, we ensure that for each node n, worstScore(n) monotonically increases while bestScore(n) monotonically decreases during the list scan.Example 3Fig. 4shows an example of computing the worst and best scores of a node n when evaluating a query Q over graph data using extended inverted lists. Suppose that graph data and the given query are the same as in Example 2 and the extended inverted lists in L′(Q) have been scanned to the same positions on the inverted lists in L(Q) in Fig. 2, denoted by rectangles. With an extended inverted list, however, the relevance of the next entry of n which will appear after the current scan position is already available from the recent entry of n or from the relevance lookup table. In Fig. 4, the next relevances of n represented by nextScoren,i(1⩽i⩽4), are 2.0, 2.5, 1.0, and 1.5, respectively, and thus maxNextScoren=2.5. Note that nextScoren,4 is obtained from RT because no entry of n has been found from L′(k4) yet. Moreover, the relevance queue of n stores p highest relevances not only from the entries of n retrieved from the lists but also from the next relevances provided by nextScoren,i′s. Thus, assuming p=6, the next relevances of n in L′(k1) and L′(k2), i.e. nextScoren,1 and nextScoren,2, are maintained in qninstead of the second entry of n read from L′(k3), which results in qn=[(s1, 4.0), (s2, 3.5), (s4, 3.0), (−, 2.5), (s3, 2.3), (−, 2.0)]. According to Eqs. (4) and (5), we have worstScore(n)=∑r∈qnr=17.3 and bestScore(n)=∑r∈Rn′r+2.5 ·(6–4)=18.0 since maxNextScoren=2.5 and R′n={4.0, 3.5, 3.0, 2.5}. Note that this range of relevance score [17.3, 18.0] is narrower than the range [14.5, 19.5] obtained by the basic method in Example 2.Fig. 5shows a pseudo-code of the enhanced query processing algorithm based on the extended inverted lists and relevance lookup table. The overall structure of the algorithm is the same as the basic one presented in Fig. 3. Besides curScorei, nextScoren,iis introduced to maintain the next relevance of each node n in each list Lifor keyword ki(in Line 11 and 16). Suppose that an entry of a node n has been read when scanning the extended inverted lists and without loss of generality, it was from list Li. If the entry is the first entry of n found from the lists in L′(Q), nextScoren,jfor all the other lists Ljin L′(Q) is initialized by the values looked up from RT using (n, kj) as a search key. They are also inserted into relevance queue qnof n with their keyword nodes unspecified (Line 8∼14). The relevance r and next relevance r′ of the current entry are en-queued into qnin Line 15. Note that if the current entry is not the first entry of n from the list Li, an item in qnpreviously inserted with a next relevance value and no keyword node for the current entry should be updated using the keyword node in the entry. Then, the next relevance r′ is maintained as nextScoren,iand the worst score and best score of n are computed from the relevances in qnand maxNextScoren, regardless of the relevance curScoreiat the current scan position in each list Liin L′(Q) (in Line 16∼17). Processing the current node in the top-k queue or candidate queue and checking the fulfillment of termination condition in Eq. (3) are the same as in the basic algorithm (Refer to Line 11∼22 of Algorithm 1), but the correct root nodes of top-k answer trees can be determined much earlier than the basic method. It should be also noted that since the worst and best scores of the nodes in the top-k queue or candidate queue do not change except the node whose entry is currently read from a list, we do not have to conduct periodic update and re-organization of the queues shown in Line 23∼24 in Basic query processing algorithm in Fig. 3 and thus can process queries more efficiently than the basic method.As defined earlier in Section 3, the proposed answer structure has no such constraint that an answer tree should contain all the keyword terms in the query, and our relevance measure is to find answer trees having the keyword nodes most relevant to the root nodes, regardless of which query keywords are concerned. For that reason, in the query processing algorithm presented above, a relevance queue for each root node maintains top-p pairs of a keyword and keyword node most relevant to the root node without considering keywords. However, if a user’s information need underlying the given keyword query is to find sub-trees which contain all the keywords, the proposed answer structure cannot fully satisfy the user’s need.To handle keyword queries with AND semantics effectively, we modify our method to search for a restricted form of answer trees which include at least one keyword node for every keyword in the queries. Specifically, the relevance queue structure and the worst and best score metrics should be changed in the query processing scheme.As mentioned above, the first entry of a node n in the inverted list for a keyword k, denoted by firstEntry(n, k), provides a keyword node for k which is the most relevant to n. Thus, given a query Q of l keywords with AND semantics, the keyword nodes in firstEntry(n, ki)′s for all keywords ki(1⩽i⩽l) in Q should be included in the answer tree rooted at node n. Considering this, we store the pairs of the keyword node and relevance in firstEntry(n, ki)′s separately from the relevance queue qnof n to maintain them until the list scan terminates. As shown in the enhanced search algorithm, all the relevance values in firstEntry(n, ki)′s can be obtained either from the entries themselves or from the relevance lookup table when an entry of n is first retrieved from an inverted list in L(Q). The relevance queue qnmaintains at most p−l entries of n which are most relevant to n besides firstEntry(n, ki)′s, where p is the parameter for the answer structure defined in Definition 2.The worst and best score metrics in Eqs. (4) and (5) are also changed in order that the relevance values in firstEntry(n, ki)′s are always considered in computation of the worst and best scores of n. Assuming that firstRels(n) is a multi-set of the relevance values in firstEntry(n, ki)′s for all kiin Q andRn′={r|(s,r)∈qn,r⩾maxNextScoren}, we have(6)worstScore(n)=∑r∈firstRels(n)r+∑r∈qnrand(7)bestScore(n)=∑r∈firstRels(n)r+∑r∈Rn′r+maxNextScoren·(p-l-|Rn′|)When the scanning of the lists terminates, the keyword nodes in firstEntry(n, ki)′s as well as those in qnare used to derive an answer tree rooted at node n if n belongs to top-k queue T.

@&#CONCLUSIONS@&#
