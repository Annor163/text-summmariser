@&#MAIN-TITLE@&#
Birational 2D Free-Form Deformation of degree 1×

@&#HIGHLIGHTS@&#
A method is proposed for creating a planar free-form deformation of degree1×nthat has a rational inverse.The control points can be freely positioned, and weights are computed that produce a birational map.Weight computation is simple, and can be performed in real-time as the control points are moved.

@&#KEYPHRASES@&#
Free-Form Deformation,Birational map,

@&#ABSTRACT@&#
This paper shows that generic 2D-Free-Form Deformations of degree1×ncan be made birational by a suitable assignment of weights to the Bézier or B-spline control points. An FFD that is birational facilitates operations such as backward mapping for image warping, and Extended Free-Form Deformation. While birational maps have been studied extensively in the classical algebraic geometry literature, this paper is the first to present a family of non-linear birational maps that are flexible enough to be of practical use in geometric modeling.

@&#INTRODUCTION@&#
Free-Form Deformation (FFD) is an artist-friendly tool for deforming geometric models and graphical images by warping the ambient space (Sederberg and Parry, 1986). FFD is used in numerous applications such as geometric modeling (Hoffmann, 1989), shape optimization (Manzoni et al., 2012), character animation (Chadwick et al., 1989), facial animation (Kalra et al., 1992), image morphing (Lee et al., 1995), medical imaging (Frangi et al., 2001), shape registration (Huang et al., 2006), and sheet metal forming (Lingbeek et al., 2005).2D-FFD is illustrated in Fig. 1. As a preprocess, the scene in Fig. 1.a is enclosed in a rectangle (Fig. 1.b) which is parametrized by(s,t)=(x−x0x1−x0,y−y0y1−y0). To explain the 2D-FFD illustrated in Fig. 1.c, we introduce the following notation. Upper-case bold letters denote elements ofP2and bold lower-case letters denote elements ofR2. GivenP=(Px,Py,Pw), the projection operatorΠ:P2→R2is definedΠ(P)=(Px/Pw,Py/Pw). The result of projection is denoted by the corresponding lower-case letter, for example,p=Π(P). Define(1)P(s,t)=(px(s,t),py(s,t),pw(s,t))=∑i=0m∑j=0nwijPijBim(s)Bjn(t)where control pointsPij=(xij,yij,1)havepij=(xij,yij)Cartesian coordinates,wijare weights, andBkd(u),u∈{s,t}, is the kth Bernstein polynomial of degreed∈{m,n}. The FFD is given by(2)(x,y)=p(s,t)=Π(P(s,t))=(px(s,t)pw(s,t),py(s,t)pw(s,t)).Artists typically manipulate an FFD by moving the control points. Changing the weightswijwill also modify an FFD, but this is rarely done in practice because the influence of the weights is limited—for non-negative weights, the deformation will never escape the convex hull of the control points. Fig. 2shows the subtle effect of changing weightw32in the FFD in Fig. 1.c from one to two.We define a preimage of a given(x,y)to be any(s,t)for whichp(s,t)=(x,y). Computing FFD preimages is required in many applications — such as Extended FFD (Coquillart, 1990) and Directly Manipulated FFD (Gain and Dodgson, 2001) — and is useful in other applications, such as backward mapping for image warping.A preimage(s,t)of a given(x,y)satisfies the equations(3)g1(s,t)=xpw(s,t)−px(s,t)=0(4)g2(s,t)=ypw(s,t)−py(s,t)=0.Computing preimages usually involves solving (3) and (4) using numerical methods such as multivariate Newton iteration, or using algebraic methods such as resultants or Gröbner bases. In the simple case of a bidegree1×1FFD, (3) and (4) can be solved using algebraic substitution. For the FFD in Fig. 3,x=12s(1−t)+8(1−s)t+12sty=6(1−s)t+4stfrom which we can solve(5)s=x−4y+36±f(x,y)24,t=−x+4y+36±f(x,y)32wheref(x,y)=x2−8xy+16y2−72x−96y+1296. For(x,y)=(8,4)there are two preimages,(s,t)=(13,34)and(s,t)=(2,2), i.e.,P(13,34)=P(2,2)=(8,4). A generic FFD of bidegreem×nis a2mn:1map.11This can be seen as follows. For a fixed(x,y), the polynomialsg1(s,t)andg2(s,t)are bidegreem×n. The preimages of(x,y)are the values of(s,t)that satisfyg1(s,t)=0andg2(s,t)=0. The s-coordinates of these preimages are the roots of the polynomial obtained by taking the resultant ofg1(s,t)andg2(s,t)with respect to t. Bezout's resultant in this case is the determinant of ann×nmatrix whose elements are polynomials of degree 2m in s.Sederberg and Zheng (2015) shows that if the FFD in Fig. 3.b is modified by assigningw01=53(Fig. 3.c), the map becomes1:1and(6)s=3x−4y26−4y,t=2y20−x.Now, the unique preimage of(8,4)is(s,t)=(25,23).A functionp(s,t)is called a birational map (or a Cremona transformation) if an inversep−1(x,y)exists that satisfiesp−1(p(s,t))≡(s,t), where bothp(s,t)andp−1(x,y)are rational maps fromR2→R2. Every nonsingular linear or projective transformation is a trivial birational map. Non-linear birational maps have been studied for over 150 years and enjoy an extensive literature in classical and algebraic geometry, much of it cataloged in Hudson (1927).We define a birational FFD to be an FFD in which an artist can freely move all the control points in the conventional manner, and the FFD can be made to be birational by then adjusting the weights. Birational FFDs were not studied in the classical literature on Cremona transformations, probably because the application to design and graphics did not yet exist. Furthermore, Hudson (1927) predates Bézier and B-spline curves and surfaces. While Hudson (1927) presents numerous specific Cremona transformations such asp(s,t)=(1s,1t),p−1(x,y)=(1x,1y),simply converting such special cases to Bernstein polynomials does not constitute a birational FFD as we have defined it. Likewise, birational FFD has not been studied in the previous FFD literature, probably because nobody realized it was possible.The result presented in Sederberg and Zheng (2015) can be interpreted as a birational FFD of degree1×1because the four control points can be moved to any general position, and the map is birational if the weights satisfy(7)w00w11w01w10=|P˜01P˜00P˜10‖P˜10P˜11P˜01||P˜11P˜01P˜00‖P˜00P˜10P˜11|whereP˜ij=(xij,yij,1)and|RST|=det(R,S,T). An artist can move the four control points and can even assign three weights; the fourth weight can then be computed from (7).Section 6 extends the result in Sederberg and Zheng (2015) by showing that 2D FFDs of degree1×nare birational FFDs, that is, the control points can be moved to any general position, and weights can be determined such that the map is birational. A key preliminary result used in this procedure, presented in Section 2, is that a planar Bézier curve of any degree can be changed into a monoid by fixing the control points, specifying the location of the multiple point, and then solving for the weights.Before we can consider monoid curves, we need to discuss representations for points and lines. LetP=(px,py,pw)andX=(x,y,w). A triple such as P can represent either a point or a line.Point(P)denotes a point whose Cartesian coordinates areΠ(P)=(px/pw,py/pw)—assumingpw≠0. Ifpw=0,Point(P)is the point at ∞ in the direction(px,py).Line(P)denotes the line defined by the equationP⋅X=pxx+pyy+pww=0.Line(P1)andLine(P2)intersect atPoint(P1×P2)andPoint(P1)andPoint(P2)lie onLine(P1×P2). IfP1⋅P2=0,Point(P1)lies onLine(P2).GivenR(t)=(rx(t),ry(t),rw(t))∈P2[t],Point(R(t))is a rational curve defined by the parametric equations(x,y)=Π(R(t))=r(t).Line(R(t))is called a moving line (Sederberg et al., 1994), i.e., a line that moves as a function of t, defined by the equationrx(t)x+ry(t)y+rw(t)w=0. IfR1(t)⋅R2(t)≡0,Point(R1(t))andLine(R2(t))are said to follow each other. DefineDeg(R(t))to be the maximum of the degrees ofrx(t),ry(t),rw(t). IfDeg(R(t))=d1andrx(t),ry(t),rw(t)have a common factorf(t)of degreed2,R(t)˜=R(t)/f(t)is degreed1−d2andPoint(R(t))≡Point(R(t)˜). Given curvesPoint(R1(t))andPoint(R2(t))of degreed1andd2respectively,Line(R1×R2˜)is a moving line of degree≤d1+d2(Sederberg et al., 1994). Ifd1=0,Line(R1×R2˜)is an axial moving line of degree≤d2that pivots aboutPoint(R1). We will dispense with the descriptors Point and Line if no ambiguity results.GivenA=(ax,ay,aw)andP(t)=(px(t),py(t),pw(t))(wherePoint(P(t))is a properly parametrized curve),Point(A)is called a point of multiplicity n onPoint(P(t))if the equationsawpx(t)−axpw(t)=0andawpy(t)−aypw(t)=0have n common roots, counting multiplicity. Ifn=0,Point(A)does not lie onPoint(P(t)).Point(A)is called a simple point ifn=1, a double point ifn=2, a triple point ifn=3, etc. A generic degree n planar rational curve always has(n−1)(n−2)/2double points, where a generic point of multiplicity m counts asm(m−1)/2double points (Salmon and Cayley, 1879). A monoid is a degree n planar curve that has a point of multiplicityn−1and no other multiple points (Sederberg, 1983).We now state the following theorem, which appears as Theorem 1 in Song et al. (2007), and which we will use in the proof of our Theorem 2.3:Theorem 2.1Ais a singular point of multiplicityk≥2of a rational planar curveP(t)of degree n if and only if there is an axial moving line of degreen−kwith axisAthat follows the curveP(t).Thus a rational planar curveP(t)of degree n is a monoid curve with a singularity of multiplicityn−1at the pointAif and only if there is an axial moving line of degree one with axisAthat follows the curveP(t).Given control pointsPi=(xi,yi,1)of a generic rational Bézier curve(8)P(t)=(px(t),py(t),pw(t))=∑i=0nwiPiBin(t),chooseA=(ax,ay,aw),Q0=(q0x,q0y,1), andQ1=(q1x,q1y,1)(seeFig. 4) subject toA×Q0⋅P0=0,A×Q1⋅Pn=0,(Π(Q0)−Π(A))⋅(Π(P0)−Π(A))>0and(Π(Q1)−Π(A))⋅(Π(Pn)−Π(A))>0. DefineQ(t)=(1−t)Q0+tQ1and(9)L(t)=A×Q(t)=(1−t)A×Q0+tA×Q1.Then there exist weightswifor whichLine(L(t))followsPoint(P(t)), and those weights make the curve a monoid with a point of multiplicityn−1atA.Line(L(t))followsPoint(P(t))if(10)L(t)⋅P(t)=∑i=0n+1riBin+1(t)≡0.Since the Bernstein basis functions are linearly independent, (10) is true if and only if allri=0. By hypothesis,r0=A×Q0⋅P0=0andrn+1=A×Q1⋅Pn=0. Therefore,L(t)⋅P(t)=0if and only if(11)ri=(ni)wiA×Q0⋅Pi+(ni−1)wi−1A×Q1⋅Pi−1(n+1i)=0,i=1,…n.(11) can be satisfied by settingw0=1and(12)wi=−iA×Q1⋅Pi−1(n+1−i)A×Q0⋅Piwi−1,i=1,…n.With this choice of weights,L(t)is a degree 1 moving line with axis A that follows the curvePoint(P(t)). Therefore by Corollary 2.2, if the weights ofPoint(P(t))satisfy (12),Point(P(t))is a monoid and A is a point of multiplicityn−1.  □The effect of choosing weights according to (12) is illustrated in Fig. 5. To visualize multiple points on a Bézier curve, we usually must extend the curve beyond its normal[0,1]domain. Fig. 5.a shows the three double points on a degree-four Bézier curve with weights all one, and Fig. 5.b shows the monoid that results from assigning weights to satisfy (12). Note that the portion of the curve over the[0,1]domain — that is, the segment of the curve fromP0toP4— is not altered dramatically, while outside the[0,1]domain, the three double points coalesce into a single triple point at A.Definition 2.4The control points of a monoid curve are in constrained general position if the control polygon only intersects line A-P0atP0and line A-PnatPn.DenotingX=(x,y,1), the parameter value τ for whichLine(L(t))containsPoint(X)is the t value for whichL(t)⋅X=0. Solving from (9),(13)t(x,y)=A×Q0⋅XA×Q0⋅X−A×Q1⋅X=|AQ0X||A(Q0−Q1)X|.(13) is an inversion equation: for all simple points X onP(t),p(t(x,y))≡(x,y).Given a curveP(t)=(px(t),py(t),pw(t))whose weights satisfy (12), define a triangleAQ0Q1with|AP0Q0|=|APnQ1|=0(Fig. 6.a). A generic monoid curve can be implicitized using any of the standard methods for implicitizing a rational curve — such as resultants (Sederberg et al., 1984) or moving lines (Sederberg et al., 1994) — or by using the special approach in Chen and Sederberg (2002) for curves with high-order singularities. We now derive an implicit equationf(x,y)=0for the monoid curveP(t)that has a simpler structure than the more general previous methods.We begin by parametrizingΔAQ0Q1with “triangle” coordinates(t,u)(14)X=(1−u)A+u[(1−t)Q0+tQ1]where (14) is a special case of a birational bilinear map (Sederberg and Zheng, 2015) with inverse(15)t=|AQ0X||A(Q0−Q1)X|,u=|AQ0X|t|AQ0Q1|=|A(Q0−Q1)X||AQ0Q1|.Fig. 6.b shows some isoparameter lines for this parametrization. Since each t-isoparameter line (i.e., a line where t is held constant and u varies) is equivalent toL(t)as defined in (9),P(t)lies on its corresponding t-isoparameter line inΔAQ0Q1. Replacing X withP(t)/pw(t)in (15), the u triangle coordinate for each point onP(t)is thus(16)u=|AQ0P(t)|t⋅pw(t)|AQ0Q1|.We can obtain an implicit equationF(t,u)=0of curveP(t)in terms of triangle coordinates(t,u)by rewriting (16) as(17)F(t,u)=u⋅pw(t)|AQ0Q1|−|AQ0P(t)|t=0.Notice that t divides|AQ0P(t)|. Indeed, leth(t)=|AQ0P(t)|t, orh(t)=|AQ0P0|(n0)(1−t)n+|AQ0P1|(n1)(1−t)n−1t+…+|AQ0Pn|(nn)tnt.Then since|AQ0P0|=0,|AQ0P(t)|is divisible by t, and(18)h(t)=∑i=0n−1hiBin−1(t)wherehi=n|AQ0Pi+1|i+1.The implicit equation of the curveP(t)in terms of(t,u)coordinates can now be written(19)F(t,u)=u⋅pw(t)|AQ0Q1|−h(t)=0.An implicit equation in terms of(x,y)is obtained by replacing(t,u)with the inversion formulae from (15). Denotingχ=|A(Q0−Q1)X|, we havet=|AQ0X|χandu=χ|AQ0Q1|so(20)F(|AQ0X|χ,χ|AQ0Q1|)=χ⋅pw(|AQ0X|χ)−h(|AQ0X|χ)=0.Sincepw(t)andh(t)are polynomials in Bernstein form, our discussion is assisted by introducing the notation(21)cn[α,β]=∑i=0nci(ni)αn−iβi=〈c0,c1,…,cn〉n[α,β].Observe that(1−t)=|Q1AX|χ. Then,F(|AQ0X|χ,χ|AQ0Q1|)=χ⋅pwn[|Q1AX|χ,|AQ0X|χ]−hn−1[|Q1AX|χ,|AQ0X|χ]=0.Clearing the denominator by multiplying byχn−1yields the implicit equation(22)f(x,y)=pwn[|Q1AX|,|AQ0X|]−hn−1[|Q1AX|,|AQ0X|]=0.Given a degree-4 Bézier curve with control pointsP0=(0,2,1),P1=56(0,3,1),P2=23(2,4,1),P3=1013(5,3,1),P4=813(5,2,1),withA=(3,0,1),Q0=P0=(0,2,1)andQ1=P4=(5,2,1). The weightsw0=1,w1=56,w2=23,w3=1013,w4=813satisfy (12), so the curve is a monoid withpw4[α,β]=〈1,56,23,1013,813〉4[α,β]. From (18),h3[α,β]=〈4|AQ0P1|,4|AQ0P2|2,4|AQ0P3|3,4|AQ0P4|4〉3[α,β]=〈−10,−403,−403,−8013〉3[α,β].We have|Q1AX|=2x−2y−6, and|AQ0X|=−2x−3y+6, so from (22), the implicit equation isf(x,y)=〈1,56,23,1013,813〉4[2x−2y−6,−2x−3y+6]−〈−10,−403,−403,−8013〉3[2x−2y−6,−2x−3y+6]=0.An explicit curve is a parametric curve for whichx≡t. All degree n explicit curves have a point of multiplicityn−1aty=∞, that is, any explicit curve is a monoid withA=(0,1,0). It is well-known that a polynomial Bézier curve (weights are all one) is explicit if and only ifxi=i/n,i=0,…,n. A Bézier curve for whichx0=0andxn=1, but the other control points are arbitrarily positioned, can be created by settingA=(0,1,0)and assigning weights using (12), whereQ0=(0,c0,1)andQ1=(1,c1,1), yieldingL(t)=(−t,0,1).A rational explicit curve has an inversion equationt=x, and an implicit equation(23)y=py(x)/pw(x)ory⋅pw(x)−py(x)=0.Fig. 7shows three examples of explicit rational curves. Poles occur at values oft=xfor whichpw(t)=0. If the control points are in constrained general position (that is,0<xi<1,i=1,…,n−1) all weights will be positive and there will be no poles forx∈[0,1]. In Fig. 7.a and b, poles occur whenpw(t)=0. In Fig. 7.c, the curve for which the weights are all one is shown to have three double points, but for weights that satisfy (12), the singularity becomes a triple point aty=∞.An FFD of degree1×nhas two degree-n boundary curvesPj(t)=∑i=0nwijPijBin(t),j=0,1and the FFD equation, obtained by settingm=1in (1), can be written(24)P(s,t)=(1−s)P0(t)+sP1(t).Referring to Fig. 8, chooseA=(P0,0×P1,0)×(P0,n×P1,n).Choose any pointsQ0=(xq0,yq0,1)andQ1=(xq1,yq1,1)that satisfy(25)P0,0×P1,0⋅Q0=0,P0,n×P1,n⋅Q1=0,Π(Q0),Π(Q1)≠Π(A).Make sure that the respective sets of control points for the two boundary curvesP0(t)andP1(t)are in constrained general position, and then use the results in Section 2 to compute weightswijforP0(t)andP1(t)such that the boundary curves each followL(t). The resulting FFD is birational, as we will now prove by presenting the inversion formulae,t(x,y)ands(x,y). SinceP0(t)⋅L(t)≡P1(t)⋅L(t)≡0,t(x,y)is given by (13):t(x,y)=|AQ0X||A(Q0−Q1)X|.Given a point(x,y), its preimage s coordinate can be found procedurally by computing t from (13), then s can be computed by setting(x,y)=P(s,t)in (24). If we combine the steps in this procedure, we discover an interesting relationship between the inversion equations(x,y)and the implicit equations of the boundary curves. If we denote byfi(x,y)=0the implicit equation of boundary curvePi(t)as derived in Section 4,(26)s(x,y)=f0(x,y)f0(x,y)−f1(x,y).Let's use the acronym BR-FFD to be an FFD for which all the control points can be freely placed in constrained general position, and then weights can be computed that will make the FFD birational. We have shown that 2D FFDs of degree1×nare BR-FFDs. The weight computation is simple enough that, as an artist moves the control points, the weights can be computed so as to display the BR-FFD in real time. With this feedback, an artist's experience using this tool should feel similar to a conventional FFD. Furthermore, the difference between a conventional FFD (with weights all one) and a BR-FFD with the same control point positions is not excessive because, in both cases, the boundary curves are tangent to their respective control polygons at the corners of the FFD, and in both cases, the FFD lies in the convex hull of the control points.A BR-FFD can also be defined even if the control points are not in constrained general position, but the weights will not all be non-negative. Future research might explore if this is useful.BR-FFD offers opportunities for future work that can apply classical algebraic geometry to a practical tool in CAGD. The authors have shown that 2D FFDs of pure-degree two (six control points in a triangular lattice) are BR-FFDs, and this will be written up in a subsequent paper. We believe that tensor product 2D FFDs of degreem×n,m,n>1are not BR-FFDs. However, perhaps a useful tool could be devised in whichr<(m+1)(n+1)control points can be freely positioned, and then the weights and remaining control point positions are computed to create a birational map. We suggest referring to such a tool as a constrained BR-FFD, or CBR-FFD.We have also explored 3D FFDs and have concluded that the simplest tensor-product case of degree1×1×1is not a BR-FFD. However, our preliminary work convinces us that a 2D or 3D FFD of any degree can be a CBR-FFD, if enough of the control points are constrained. The work needing to be done in this area is to develop CBR-FFD tools in which an artist can move enough control points to be productive, and for which the constraints are simple enough to be computed and imposed in real time.

@&#CONCLUSIONS@&#
