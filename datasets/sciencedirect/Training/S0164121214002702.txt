@&#MAIN-TITLE@&#
A separation-based UI architecture with a DSL for role specialization

@&#HIGHLIGHTS@&#
We propose a new DSL and separation-based architecture and development methodology.The approach separates front-end UI concerns from back-end implementation concerns.A climate science application illustrates the approach and verifies its validity.Evaluation of the approach includes comparative analysis and usability studies.The approach increases developer productivity and enhances UI design flexibility.

@&#KEYPHRASES@&#
Domain specific language,Model driven engineering,User experience,

@&#ABSTRACT@&#
This paper proposes an architecture and associated methodology to separate front end UI concerns from back end coding concerns to improve the platform flexibility, shorten the development time, and increase the productivity of developers. Typical UI development is heavily dependent upon the underlying platform, framework, or tool used to create it, which results in a number of problems. We took a separation-based UI architecture and modified it with a domain specific language to support the independence of UI creation thereby resolving some of the aforementioned problems. A methodology incorporating this architecture into the development process is proposed. A climate science application was created to verify the validity of the methodology using modern practices of UX, DSLs, code generation, and model-driven engineering. Analyzing related work provides an overview of other methods similar to our method. Subsequently we evaluate the climate science application, conclude, and detail future work.

@&#INTRODUCTION@&#
In software development there are many deadlines, dead ends, long hours, and other difficulties. We believe that a large amount of the accidental complexity (Brooks, 1995) contained in the development of a software project lies at the boundaries between programmers and higher level designers. Our focus was specifically on the gap between User Interface (UI) designers and programmers, which we believe is becoming more complex due to two trends: (i) the desire to attract and keep users is resulting in increasing complexities in the UI and (ii) the diversity of UI platforms is growing due to new devices such as tablets, smartphones, Google glass, and others that will be created in the future. The current status quo of UI development is to allow a UI designer to specify the UI while the programmer uses a UI builder and associated framework to create the UI. We believe that this status quo will become increasingly difficult to deal with due to the aforementioned trends. This exchange is hampered by a communication gap between those two groups, an accidental complexity that we have identified and attempted to rectify in our approach.We address the UI–Code interface of the traditional separation based UI architecture (Fig. 1) in order to simplify that interface and thereby alleviate a number of difficulties pertaining to developing software. In contrast to other approaches, we attempt to determine the design of the UI–Code interface by basing it on specialized roles rather than solely on the code and some principle such as don’t repeat yourself (DRY; Hunt and Thomas, 1999). Our architecture emphasizes specialized roles involving User Experience (UX) professional designers and programmers. The architecture and the resulting methodology based on it benefit from automated code generation and are generic and flexible enough to be applied in numerous software development projects. Our main premise is that specialization, combined with a mechanism for integration and bridging knowledge domains such as a Domain Specific Language (DSL) can be particularly effective in software applications with significant UIs.We combined existing methods and technologies in order to fashion a software development approach to address the difficulties involved with changes of the UI that inevitable occur when UI design and programming are happening concurrently. The techniques used in our approach include Interaction Design (IxD), DSLs, code generation, Graphical User Interface (GUI) builders, and Integrated Development Environment (IDE)s. Due to time constraints, we focused on the tools as they are today and did not attempt to greatly modify them for our specific purposes.The significance of this work stems first from addressing problems that arise from the current status quo in developing software with a UI. We see four problems that will become worse with trends (i) and (ii). The first two problems are related to the people developing the software: (1) UX professionals are resigned to an advisory role and, (2) communication gaps between UX professionals and programmers cause confusion and loss of productivity. Another set of problems relates to the technology, namely (3) UI dependence upon a framework, and (4) UI creation dependence on knowing programming. Take note that these problems are not orthogonal and that (1) is a result of (4). Our software development methodology addresses and alleviates each of these problems thereby providing a new status quo to deliver developers to a more productive future.The paper is structured as follows. The derivation and description of the approach is presented in Section 2. The creation of an application using the methodology is described in Section 3. Section 4 provides an evaluation of the methodology as compared to similar approaches. The application we created is evaluated in Section 5 with a usability analysis, a code generation assessment, and a comparative analysis. Finally, Section 6 presents our conclusions and future work. This paper is based upon Gibbs (2013), which can be probed for further details of the proposed methodology.This section describes the essential aspects of our proposed approach. The approach is a combination of a separation-based UI architecture, UX considerations, and Model-Driven Engineering (MDE). We identify the premises we used to base our architectural decisions on and illustrate our deductive process to create the architecture. The approach is then described in detail with regards to how it should be implemented. The role of the developers is explained and the tools and techniques we used are described.Michael Jordan was a top athlete in professional basketball, who decided to play baseball. However, he was mediocre in baseball. Surprisingly he decided to go back to basketball and again became a top athlete. Why would Michael Jordan meet with less success in baseball than basketball? The problem here is specialization—people adapt to their environment and the more adapted they become to one environment the less adapted they will be to another environment. Though mental abilities are not as apparent as physical ones they are still there and without getting into a Darwinian discussion of heredity versus environment, we propose that mental abilities can limit the effectiveness of a person to a particular environment.The Johnson O’Connor Research Center has measured the aptitudes of software engineers (Burke and Fitzgerald, 2003) and they have also done this for psychologists (Condon and Schroeder, 2005). Since UX designers often may have a background in psychology as they need detailed understanding of human users, we assume the aptitude profile of the UX designer to be close to that of a psychologist, in lieu of a better comparison. Fig. 2provides evidence that the skills needed by UX designers and programmers are very different, thereby indicating poor performance of those individuals working in the wrong area. To sum up our perspective, we think the invariant of role specialization in humans increases productivity and success.A communication gap occurs when the sender and receiver have different conceptual meanings for words. A common phrase in advertising is “Nothing is too good for our customers.” Gause and Weinberg (1990) Upon a close inspection, we can derive two different meanings for this statement: (1) “Our customers deserve so much that nothing in the world can actually meet this requirement”, or (2) “Our customers are so undeserving that giving them nothing would be giving them too much.” Another example Cooper et al. (2007) is when a user asks the computer to “Find restaurants in Virginia and Georgia,” the user wants (restaurants in Virginia) AND (restaurants in Georgia). However, a computer programmer would set up the UI to interpret the phrase so as to finding restaurants in (Virginia AND Georgia)—an impossibility. So, the looseness of language contributes to possible confusions during communication.The communication gap problem is complex and multiple models of communication have been proposed, such as the one shown in Fig. 3. A prime candidate for the illustration of communication gaps is provided by the creation of user interfaces by programmers. A popular UX professional writes“Our first four textual bloopers are about poor writing in the text displayed by software. They are the result of giving the job of writing text to the wrong people: Programmers.” Johnson (2000)Numerous examples of programmers failing to write software to communicate well with customers illustrates the fact that programmer skill sets are distinct and do not generally enable programmers to communicate clearly with the general population (Cooper, 1999). However, many programmers are not aware of the apparent fact that the sender and receiver of a message could have entirely different encoding/decoding mechanisms (Fig. 3).We found that in any piece of software there are many communication gaps that can be identified. In this paper, we attempt to classify the different communication gaps that we are aware of and to address only the largest of those gaps in order to reduce complexity in that way. Software constitutes whatever we insert in between the user and the machine. Therefore, we can consider this communication gap to be represented by CG. If we illustrate the software using a separation based UI architecture, then we notice that we actually have three separate communication gaps; cg1, cg2, and cg3 (Fig. 4). Here, we can find the largest communication gap by specifying the actual knowledge domains that each component belongs to (see Fig. 5). It is this communication gap, cg2, that we will address in order to alleviate some of the problems posed by communication gaps.There are ways to eliminate or reduce a communication gap, such as having one person learn the jargon of the other, having both people learn the others jargon, or providing an interpreter. From premise 1, we believe that attempting to educate the programmer regarding user knowledge is the wrong direction. The same applies to attempting to make the user learn more about machine knowledge. Instead, we subscribe to an interpreter option, and that interpreter is a UX professional who understands the realm of Human–Computer Interaction (HCI) theory (Rogers, 2012). The UX professional serves as the interpreter between the user and the code and is not required to understand machine knowledge.By isolating our professionals in their respective knowledge domains, we also isolate their communication to that of a discussion of one communication gap between their knowledge domains—the largest communication gap of the architecture shown in Fig. 4 (Premise 3). This isolates much of the confusion and allows for a focused effort to be put on bridging the largest communication gap (Premise 2).In an effort to tackle this gap, we will bridge it with a DSL in order to use a technology that already exists and has available literature describing it (see Fig. 6). This DSL will also eliminate the need for the UX professional to understand machine knowledge or how to program, thereby supporting Premise 1.Our approach brings together three different ideas, that of UX , DSLs, and code generation. We believe that much of current industrial practice for software creation follows (Fig. 7). The designer is responsible for defining the user’s needs and specifying what needs to be done with the UI. The programmer then translates this specification into a program consisting of two parts—the UI and Code.Our approach differs in that it specifies a UX designer instead of a general designer and the role specialization is isolated with a DSL. In order to further increase productivity for the machine knowledge domain, we use MDE code generation techniques to quicken software development, reduce errors, and increase flexibility (Fig. 8).The UX designer will be an expert in user interfaces and is not required to understand how to program. The UI will be created by the designer through the use of a simple GUI builder or by directing a programmer. Though there exist numerous GUI builders, we have not found many that do not require some understanding of programming languages and these also have limitations in expressivity which detract from the creation of some UIs. The UI designer will interact with the DSL in order to communicate with the application.The programmer will need to understand programming and DSL creation. The DSL will be defined by the stakeholders during the requirements and design stages of development. The programmer will create the DSL (another option would be to have this created by a language designer if resources exist). All technical issues arising during the UX design can also be solved by the programmer. The ultimate responsibility of the programmer is to create the software application code through code generation and manual edits.The overall process is shown in Fig. 9. We begin with gathering requirements for the application and then create the software requirements specification (SRS; Sommerville, 2010) with a specific vocabulary of terms, precisely defined, in order to prepare for our eventual DSL creation. From there, the design will be created to describe how a technical solution will be reached to meet the SRS and here we also focus on specifying terms exactly for the next stage. The critical stage of creating the DSL then gives the design a formal description from the perspective of a UI interacting with an application, because the intention of creating the DSL is to make a well defined interface between the UI and the application. For example, in an ATM application, requirements such as “USER deposits MONEY,” “USER withdraws MONEY,” and “USER closes ACCOUNT” clearly indicate an interface between the USER and the ATM machine, which can be formalized with a DSL. Now the benefits begin to show up because the code creation and UI creation may now progress independently. The UI may be prototyped, tested with users, and finalized. Consequently, the DSL can be used to generate partial code in lieu of full generation, such that code can be added by the programmer after the generation phase. After the UI and code have been created, they will be integrated to create the final product. At this point, we note that the integration phase consists of merging a UI which interfaces with a human and produces a DSL script to communicate to the application, while the application is controlled via the DSL commands. The flexibility here is that two or more separate UIs can be integrated with the same application in order to accommodate different environments such as an instance running on an individual workstation or one running in a web browser. The connection between the UI and application can be managed via a connector component which handles the details of routing messages to and fro, thereby allowing both UI and the application to be ignorant of their distance from each other.The code creation process shown in Fig. 9 is a DSL-based code generation process that uses several development tools that we have selected. Fig. 10presents a much more detailed code generation diagram highlighting our choice of using the Xtext tool. The first step is to take the DSL from the DSL specification and distill it into a grammar for Xtext. Once we have an understanding of the form of the grammar, we start a new Eclipse Xtext project and then enter the grammar. The creation of this grammar enables us to generate the parser, the metamodel, and an Eclipse editor tool via the ‘Generate Xtext Artifacts’ command. In the next stage, we create templates for the code generation; these templates are coded in Xtend. The Modeling Workflow Engine 2 (MWE2) tool then allows us to generate either a generator or an interpreter for our DSL. When we take the interpreter path, we start a new Eclipse instance that incorporates the editor tool created earlier and that tool provides syntax corrections while writing our DSL script (Fig. 11). After the DSL script has been created, we can then build that script which results in the creation of the generated code. Subsequently, the generated code is built to give us the final application. Here, we have only explained the Eclipse plugin branch of the code generation process, but if the readers desire to learn the details of the Stand Alone branch, they are referred to Bettini (2013).The creation of the UI will be largely performed by experienced UX designers. We closely followed the methods of IxD (Cooper et al., 2007) such as design ethnography and sketching the UI. Our ideal is for the UX professional to use tools such as GUI builders that will not require the understanding of programming; such as the MetaCase MetaEdit tool (MetaCase, 2013) or Meta-Gui-Builders (Luyten et al., 2008). The end result of this work is that the UI provided will be capable of generating scripts in the defined DSL and thereby communicate with the application code.There are a number of well-defined steps which, if followed correctly, will allow the implementer to design software that conforms to our proposed approach (Fig. 12). Our approach does not replace traditional requirements analysis, and other design processes but instead enhances the design during use case construction, architecture design, and code production. Step 1 is to analyze the use cases and to determine what the actual gaps are that the software is being asked to address. Then, in Step 2, the implementer separates the tasks of the use cases into a two columned table identifying if the particular task is in the User domain or in the Machine domain. With this table, the UX professional and the programmers can work out what information needs to be communicated between the machine and the user with the DSL (Step 3). Once the DSL has been specified, the UI and Code development can carry on independently with Steps 4a and 4b. Finally, in Step 5, the two artifacts from Step 4 are integrated with the formalized DSL.To illustrate the application of our methodology we chose to work on a problem which affected climate scientists—that of the subsetting of NETwork Common Data Form (NetCDF; Unidata, 2014c) files. Although the application was kept relatively short for simplicity, it is nevertheless intended to give the reader a comprehensive view of how the methodology works in practice. The current section is structured according to the flow of the methodology shown in Fig. 12.In order to learn how the user interacted with NetCDF files, the UX professional performed a number of ethnographic interviews (Rogers et al., 2011). With the information our UX professional collected, a Persona was created (Table 1) for reference and a use case to subset data from a NetCDF file was written (Table 2). In performing this use case, the scientists were accomplishing their goal of analyzing climate data for their research needs.Our UX professional and programmer got together and discussed the steps of the subsetting task in order to categorize those steps as shown in Table 3into their respective domains. This categorization was to illustrate our methodology with a simple example and there are many potential categorizations that could be chosen with this use case. With this identification of domains, we have separated the work of the team and can benefit from role specialization.Our UX professional and programmer worked together to enhance Table 3 to that of Fig. 13to show the messages to bridge the domains. This DSL will later be formalized, but for now it is only important to hash out the details of exactly what needs to be communicated.The UX professional created a prototype UI to get feedback from climate scientists. This first prototype was a drag and drop GUI that allows a climate scientist to create a workflow out of components that are familiar to them. The prototype was sketched, wireframed, and implemented. In order to be faithful to the methodology, we identified the MetaEdit + application which could be used as a GUI builder without requiring the user to understand programming. The resulting MetaEdit + prototype is shown in Fig. 14. Unfortunately, the UI had a number of problems: (1) it required user to have MetaEdit + installed, (2) it did not have a clear area for the tool icons for NetCDF files and the filters, and (3) it contained all MetaEdit + controls rather than only the controls needed to create a NetCDF subsetting model. The limitations of this GUI builder motivated the UX professional to delegate the UI creation to a programmer.A second prototype attempted to present the database contents as a node-link tree to the user; see Fig. 15. In searching a database, such as a library catalog, the user is presented with a textual hierarchy, but it is easy to lose yourself in the hierarchy. Our goal here was to be able to present a node-link tree that indicated how much data a particular node contained (Fig. 16) and allow the user to click on that node to show the sub-nodes. To specify a subset of the data, the user would choose a particular combination of nodes.Though we feel that this interface had some promise, it had some real downsides regarding our methodology. First, the creation of this browser required some significant programming. We were using Sparx Enterprise Architect (Sparx Systems, 2014) to create the code and we used the D3 JavaScript Visualization package (Bostock et al., 2011). A second downside is that we ran into difficulties in how to display node contents and in getting information passed between the server and node-link tree in an efficient manner. Eventually after spending a significant time on this idea, we abandoned the effort.A usability study informed us that a non-graphical approach is more effective than a graphical one for a climate science Search User Interfaces (SUI) in some cases. Three UI sketches were created: a graphical SUI, a text-oriented one, and a natural language output (Cooper et al., 2007) one. When tested with users and analyzed with GOMS (Card et al., 1983), the natural language output version was the most popular and efficient (Fig. 17).At this point the UX professional began to test the UI with users to begin the iterative process of evolving the UI. Our testing for the application showed a marked improvement over earlier SUI designs. The eventual prototype consisted of a local desktop application which allowed the user to drag and drop NetCDF files to it. Once a file was dropped, the file would appear in a file list (Fig. 18). If the user chose the file in the file list, appropriate details and search terms would appear (Fig. 19).The DSL specified in Table 3 was formalized for all messages that must be passed between the UI and Code components. Fig. 20shows a couple of these formalized messages.Our programmer used Xtext on the Eclipse platform with the Ecore architecture. The complex process of creating the textual DSL is shown in Fig. 10 and further details are provided in Bettini (2013). Using Xtext, we defined a grammar for our textual scripts (Fig. 21), wrote the program in Xpand and Java, and incorporated that code into our Xtext project as templates. We then generated the parser code (see Table 6) and tested scripts by feeding them into our parser and generating Java code.Our DSL served as the glue to connect the UI and Code components and this worked well. The actual climate scientist user would enter data into our SUI. Any user action that required information from the Code component would create a DSL script and query the Code component. For example, when the user presses the “Execute” button, the UI creates a script (Fig. 22) which is then fed into our parser (Fig. 23), which in turn places the parsed information into our code templates and then generates the Java source code for the specified workflow (Fig. 24). These files are then compiled into an executable program which is run to execute the workflow.

@&#CONCLUSIONS@&#
We have presented a new methodology, described its specific concepts and steps, and provided a detailed example of applying the methodology. We have also evaluated the methodology through comparison with related work, usability studies, and analysis of its results. Our assertion (Section 2.1.4) has been that a separation-based UI architecture can enhance the process of software development. A key to our proposed approach is the use of a DSL to bridge the gap between UI design and writing code. Much of the research, development, and testing conducted has been promising regarding the validity of our assertion, but inherently more work remains to be done to fully prove our methodology.We have shown that there is a clear communication gap between a UX professional and programmer working on a software development project. Our architecture addresses this communication gap and the associated methodology illustrates how to use this architecture in a development process. With regards to problem (4) and its resulting effect of problem (1), we did not find an adequate GUI builder that does not require programming knowledge and therefore were not able to address these problems in this work. The use of a DSL to separate the UI and Code components provides a significant tool to reduce the communication gap and thereby addresses problem (2) of the current status quo. Secondly, the DSL also provides separation of concerns between the UI and Code components and therefore addresses problem (3) of the current status quo.We expect that our approach contributes to reducing the gulfs of execution and evaluation as described by Norman (2013). Specifically, they can be reduced because the UX designer knows how the software is expected to behave (by the user), and the programmer knows how to implement the software to make that happen.In considering future work, we must discuss both work on the architecture and the developer’s experience. In the case of the UI component, we did not find a suitably flexible GUI builder that would not require the need to understand code. Having a suitable UI builder could really make our approach easier to implement. Though we have shown how to create the DSL, we still want to find a generic solution for passing the DSL messages back and forth from the UI and Code components. And, with regards to the Code component, we could work with different code generation techniques to find a best of breed. In addition, more testing may further specialize the architecture, with three major roles rather than just two: UX professional, DSL designer, and code programmer. And although our methodology looks promising in the climate science environment, we still need to test to determine if it is effective in other areas.