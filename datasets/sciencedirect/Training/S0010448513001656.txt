@&#MAIN-TITLE@&#
Geometric computation and optimization on tolerance dimensioning

@&#HIGHLIGHTS@&#
LPGUM model is extended to propose a new complete representation of tolerances.A new analysis method for the tolerance estimation via geometric computations.A new optimization method for improving a dimension scheme to reduce tolerances.

@&#KEYPHRASES@&#
Tolerance analysis,Process planning,Geometric optimization,

@&#ABSTRACT@&#
This paper presents an efficient geometric method of tolerance analysis for optimizing dimensioning and providing an optimal processing plan for a discrete part. Geometric primitives are used to represent part features, and dependencies in the dimensions between parts are represented by a topological graph. The ordering of these dependencies can have a significant effect on the tolerance zones in the part. To obtain tolerance zones from the dependencies, the conventional parametric method of tolerance analysis is decomposed into a set of geometric computations, which are combined and cascaded to obtain the tolerance zones in the geometric representations. Geometric optimization is applied to the topological graph in order to find a solution that provides not only an optimal dimensioning scheme but also an optimal plan for manufacturing the physical part. The applications of our method include tolerance analysis, dimension scheme optimization, and process planning.

@&#INTRODUCTION@&#
In parts manufacturing, the quality of finished parts is determined by both design and manufacturing tolerances, which determine the dimensional and geometric properties of the part  [1]. Engineers are required to select appropriate machining processes and equipment so that the requirements of the design tolerances are met. This process is usually called the process planning. The traditional way to design an appropriate process plan is a time consuming task that requires the engineer to iterate the process of designing, testing, and modifying the solution until all the design requirements are satisfied. Recently, computer aided process planning (CAPP) has drawn considerable attention as a way to simplify this process. Key techniques related to CAPP include tolerance modeling, tolerance analysis, and tolerance allocation. The tolerances determined in the design phase serve as the basis for the manufacturing tolerances, which are used to reflect individual manufacturing operations. The focus of this paper is on design tolerances.A key part of tolerance modeling is representing the zone within which geometric characteristics of a model may vary. These tolerance zones are usually represented as simple geometric entities that are guaranteed to bound the features of the model  [2,3]. They can be thought of as a representation of the uncertainty in the geometric position. Geometric variations can also be modeled as higher dimensional geometric objects, such as polytopes or dual-cones, which represent the region as intervals of the coefficients of their algebraic parameterization  [4–6]. Tolerances of part features such as form, orientation, and size can be represented in this way, though further computation on such models can be very complicated.Tolerance analysis covers the techniques that compute the variations of tolerances for the worst case estimation or statistical expectation. Broad reviews of the area are available  [7,8]. Though many techniques can be employed for tolerance analysis in the design phase, tolerance propagation is the core part of process planning. Tolerance propagation refers to the determination of one tolerance zone based on others. When manufacturing one feature of a part, engineers have to use other features as the geometric or dimensioning references. Thus, tolerances in the references must be propagated to the feature referring to it. Typically the propagation involves a series of computational geometry operations. However, because the tolerances are modeled in different spaces (world space and local part-centric space), the representation and the transformation of tolerances are not straightforward. For high-dimensional representations, the computation of tolerance propagation relies on computational techniques in high dimension that are notorious for the difficulty with implementation and robustness. Several lines of prior research have proposed methods addressing propagation.Tolerance charting methods, which evaluate tolerance propagation based on engineers’ experience, are a traditional way of handling tolerances. Computer-aided tolerance charting methods  [9] have been developed to reduce the iteration of physical trial-and-error runs. Shortcomings of tolerance charting are that it cannot deal with complex spatial tolerance propagation issues or geometrical tolerances. To overcome this problem, methods for modeling tolerance propagation in higher dimensions have been presented [10–13]. One kind of method uses small displacements torsor (SDT)  [14] to model the process planning  [10]. Another kind of method, Technologically and Topologically Related Surfaces (TTRS), forms any part as a tree representing the succession of surface associations  [11]. Tolerance information can be tracked along the stacking chain in the graph. The stacking up of parts could be simulated by a Monte Carlo method to estimate tolerance propagation  [12,13]. This has the advantage of simplicity and flexibility, however the drawbacks of such methods are that it can be very time consuming and have poor computational accuracy at small to medium sample sizes. A third kind of method tries to find a feasible assembly plan on a graph structure by representing the related parts with the consideration of tolerances  [15]. This method bridges the gap between its generalized tolerance model and previous models so that it could be incorporated with the previous assembly planning methods. Though this method formulates a general framework for tolerance estimation, its contribution to the optimal planning is limited.Regardless of the representation of the zones themselves, the most common and straightforward implementations represent the tolerance zones independently. Unfortunately, as tolerances are propagated the dependencies between zones is then lost, causing over-estimation of the zones. One way of exploiting dependencies between the tolerance zones is by analyzing sensitivity to parametric variations  [16,15]. Recently, a new method for describing dependencies of geometric uncertainties has been proposed [17,18], though to our knowledge it has not been implemented in any general way, including by the original authors, prior to our work presented here. This method, called LPGUM (Linear Parametric Geometric Uncertainty Model), uses a first-order approximation of the uncertainty zones of geometric primitives. The dependencies of uncertainties are derived from sensitivity matrices. Despite the promise of LPGUM and similar methods, they have to this point been shown to handle only very simple operations on very basic primitives, and thus have not been practical for modeling tolerance zones of real parts. Further, no tolerance propagation model has been designed, and thus tolerance zones cannot be cascaded. As a result, these methods were not (yet) suitable for tolerance analysis during the process planning phase.In this paper, we present a new geometric model for tolerance modeling and propagation, geared towards the tolerance analysis in process planning. Our aim is to decompose a big chunk of analytic computations of conventional tolerance analysis into a series of geometry computations. We first decompose the part into basic geometric primitives, or features. Because those primitives are to be manufactured in a common part, we know they are related and that there are dependencies between them, which could be represented by a graph structure. We first decouple the primitives into several co-related primitive groups. In each group, the geometric position of a certain primitive (target primitive) is decided by the remaining primitives (reference primitives). This allows us to use the LPGUM model  [17] to model the tolerance zone for the target primitive, because all its variations have been obtained. Next, we formulate a method for cascading the decoupled primitive groups, so that the tolerances can be transferred between groups. Using those cascading techniques, we could obtain the tolerance zones for all primitives by traversing the embedded graph structure representing the dependencies. The tolerance zones thus obtained provide a worst case estimation on dimensions, represented as a geometric polytope. Finally, we provide a computational optimization method which can improve the quality of the existing process plan so that the tolerance of the parts could be minimized as much as possible. The optimization problem itself is an NP hard problem. We propose an efficient approximated dynamic programming solver which utilizes the optimal substructure.To summarize the contributions of this paper:–we expand the LPGUM model to propose a complete representation of tolerances that is suitable for use in process planning and can exploit the dependencies within the dimensioning scheme.building on our tolerance model, we describe the tolerance analysis based on geometric computations that provide a worst-case estimation and a straightforward geometric representation of the tolerance zone.we describe a tolerance optimization approach that can improve an existing dimensioning scheme so that relative tolerances can be relaxed and thereby reduce manufacturing cost. The optimization result, which is a dependency graph of dimensions, indicates the processing order of features on the part.although the tolerance optimization problem is NP hard, we propose an efficient approximated solver with much lower complexity.In order to simplify the tolerance analysis model, a group of basic geometric primitives, points, lines, and planes, are selected, and these are used to represent all features on the part, both linear and nonlinear  [19]. This decomposition into basic primitives occurs before the tolerance analysis. Dimensions are used to build the dependencies among those primitives. Specifically, each dimension is associated with at least two primitives; one of them is the target primitive,t, which is specified relative to the reference(s), denoted by a set{mi},1≤i≤n. This dependency between the references and the target could be represented by a map{mi}→t. The variation zone oftis caused by tolerances in the dimension(s) and in the propagated variation of the reference(s). We introduce two notations of tolerance zones of the target. One is the relative tolerance zone, denoted byR(t,{mi})orR(t)for short, which shows the tolerance zone oftby assuming positions of references are exact (i.e. the tolerance zone is based solely on the tolerance in the dimensioning). The other is the global (real) tolerance zone, denoted byZ(t,{mi})orZ(t), which shows the tolerance zone fortwith consideration of all variations of dimensions, including that propagated from references.This paper is organized as follows. Section  2 explains the computation of relative tolerance zones on primitives. Section  3 explains cascading of relative tolerance zones. Section  4 explains the optimization on an augmented dependency graph of dimensions. Section  5 shows the experimental results.Note that, our work will be described and analyzed in only 2D. We can think of no fundamental reason why our methods would not extend to 3D (and some contributions are entirely dimension-independent), but we have not yet implemented all parts of our system in 3D, and thus will leave such extension to future work.When computing relative tolerances, we assume the references{mi}have an exact position. Thus, the tolerance zone of the targettis only caused by variations of dimensions connectingtand{mi}. Wheni=1, we name the dependency{m1}→tsingle dependency, which indicates that the targettis only affected by one primitive. Ifi>1, we name the dependency{mi}→tmultiple dependency, which implies that the targettis affected by two or more primitives. We present tolerance evaluation techniques for both cases.We assume that a point and line segment are sufficient for representing all features. This is always true within some tolerance (which we in fact have), and given that we linearize our nonlinear constraints, this is even more appropriate. The relative tolerance zoneR(t,{mi})could be computed analytically via an explicit formulation on a certain parameterization or approximated by the linearization of variances  [17]. We adopt the second approach since it allows us to convert the analytical computation to the corresponding geometric computation. Though the linearization is a first-order approximation of the exact tolerance zone, this minor accuracy trade-off can be neglected because of the tiny values of tolerances. We compute the tolerance zones for combinations of the point, denoted byp, and the segment, denoted by its two endsab. We usep′to denote another point and usea′b′to denote another segment.The linearization model in  [17] is built on the variational zone of a point. For one fixed pointp, the tolerance zone is approximated by(1)Z(p)≈Z(p̄)+Jδi,whereJis the (Jacobian) sensitivity matrix of uncertainties and whereδi,1≤i≤ndefine variations ofntolerances. When consideringR(p,{p′}),p′tries to lock all degrees of freedom (DOF) ofp. So we haven=2for 2D and the zone is a quadrangle as shown in Fig. 1a. Similarly, we can obtain tolerance zones for the remaining combinations. ForR(p,{ab}), the tolerance zone would be a band along the segment as shown in Fig. 1b. ForR(ab,{p}), the local tolerance frame still has two DOFs, so the tolerance zone, in Fig. 1c, is similar to that ofR(p,{p′}). ForR(ab,{a′b′}), we can apply several kinds of geometric constraints, such as parallelism or perpendicularity. Fig. 1d shows the tolerance zone for parallelism.When the references set{si}has more than one primitive, we have a multiple dependency. We examine three cases where the target is a point or a segment as shown in Fig. 2.Fig. 2a shows the point target case. Pointsaandbcould be two point primitives or points on other primitives. DOFs ofcare locked by bothaandb. We can obtainR(c)by applying the linearization in (1) using the variations of dimensions betweena,candb,c. The number of vertices ofR(c)is decided by the corresponding sensitivity matrix. In Fig. 2b, pointsaandbare also two point primitives or points on other primitives. DOFs ofcare locked byaand DOFs ofdare locked byb. We can decompose this case into two independent groups of point dependencies:{a}→cand{b}→d. The tolerance zone for segmentcdis the convex hull ofR(c)andR(d). In Fig. 2c, pointscanddare both decided byaandbtogether. We decompose this relation into two interleaved dependencies{ab}→cand{ab}→dand treatcanddas point targets.For single dependency, the relative tolerance operation is not commutative, i.e.,R(t,{m})≠R(m,{t}). Therefore, we define the inverse operationR−1(t,{m})=R(m,{t}). The computation rule is that we viewtas the reference and build the tolerance zone aroundm. We could easily use the models in Fig. 1 to obtain the inverse dependency for each case of the single dependency. For example,R−1(p,{ab})=R(ab,{p}), which indicates that operations in Fig. 1b and c are inverses of each other. The inverse for Fig. 1a is in Fig. 3a. We can obtain the inverse operation for the two-segment case similarly.If a multiple dependency can be decomposed into a set of independent single dependencies, we define the inverseR−1(t,{mi})=∪iR(mi,{t}). The case in Fig. 2b can be inverted by invertingR(a,{c})andR(d,{b})respectively and computing their union as in Fig. 3b. The case in Fig. 2a usually cannot be inverted: becausec’s DOFs are locked by two different objects, we cannot invert the dependency, just as we cannot invert a multivariate function. The same applies to the case of Fig. 2c.Notice that inverting dependencies changes the tolerance zones even though the dimensioning scheme itself is unchanged. This noncommutative nature of dependencies and tolerances provides the potential that we could improve an existing dimensioning scheme to a more optimal one by selectively inverting dependencies. Related techniques will be presented in Section  4 in detail.While relative dependencies assumed that references had exact positions, in reality the references themselves may have their own tolerance zones. These variations in the references might need to transfer to any target they lock. Given an existing dimensioning scheme, we can define a directed acyclic graph (DAG) of dimension dependencies based on the single and multiple dependencies on the individual primitives. The graph nodes are primitives. Each edge of the graph starts from the references and points to the target. Note that there might be many possible dependency graphs for the same physical part. To begin, we use a dependency graph that captures the intention of tolerance design and that can be easily interpreted during manufacturing. Usually this will have been provided by the designer, e.g. during the design process, but if no design is provided, we can use some simple heuristics to order the dependencies into a graph. In Section  4, the dependency graph will be augmented so that it covers a larger portion of the space of dependency graphs and an optimal dependency graph will be chosen from that subspace.We show an example for building a dependency graph in Fig. 4. Fig. 4a is a simple rectangular part with three position constraints. One possible dependency graph is that in Fig. 4b. The graph includes single dependency, such as{s1}→s2and{s1}→s3, and multiple dependencies such as{s1,s2}→p1and{s2,s3}→s4. This graph is acyclic since it has no back edge. There are tolerance chains such ass1→s3→s4, which means the tolerance zone ofs4also partially depends ons1throughs3.We classify dependency chains into one of the two types. If the entire chain consists of single dependencies (e.g. the chaina→b→cin Fig. 5a), we call it single dependency cascading, while if there are multiple dependencies in the chain (e.g. the chain ind→b→cFig. 5b) we call it hybrid dependency cascading.In single dependency cascading, each primitive is decided by only one reference along the dimension chain.The basic chain pattern ism1→m2→m3, wheremiare primitives. The key problem is how to transfer the tolerance ofm1tom3throughm2.Transferring tolerances through a point (see Fig. 6) is straightforward. For each level,R(b)andR(c)can be evaluated. Assume that the chain rootais exact (i.e.Z(a)=aandZ(b)=R(b)). Since the variations of dependencies{a}→band{b}→care independent,Z(c)is the cascading of{a}→band{b}→c, which is equal to the Minkowski sum ofR(b)andR(c).Cascading through a segment is based on cascading through points:Definition 1The tolerance zone of the segment is the convex hull of the tolerance zones of its two endpoints.Assume that we have a pointcand segmentab. We mapctoabto get a new pointdon the segment. We computeZ(d). ThenZ(c)is obtained by the Minkowski sum ofZ(d)andR(c,{d}). Following this idea, we can describe perpendicularity or angularity constraints, as shown in Fig. 7a and b. Note thatZ(d)can be obtained by interpolatingZ(a)andZ(b). We use a linear interpolation:(2)Z(d)=Minkowski sum(Z(a)|bd||ab|,Z(b)|ad||ab|),where|⋅|indicates the segment length, and the scalar multiplication means scaling one tolerance zone along directions starting from the origin and pointing to their vertices.We want to comment on the definition of the segment and related computations on tolerance zones. Notice that if we use two ends of the segment to define a line  [17], then the tolerance zone of the line will fully cover the tolerance zone of the segment. This means that our definition of the segment tolerance is compatible with that of the line it embeds. Furthermore, since tolerance zones of the two ends are both convex, it is not hard to deduce that the tolerance zone for any segment point is also convex and would also be covered by the zone of the segment if using linear interpolation. Therefore, the tolerance zones of the segment point and the segment are compatible, which provides the theoretical support for our cascading techniques. We can thus cascade the geometric primitives along a dimension chain having single dependencies.Multiple dependencies are an important part of the dependency DAG. If a multiple dependency can be decoupled into several single dependencies, such as in Fig. 2b, we can apply single dependency cascading on each so that the tolerance can be transferred through those primitives. Otherwise, multiple dependency cascading has to be applied. We examine the case in Fig. 2a since it is the basic building block for this problem. We need some theoretical preparations for deriving this type of cascading.As we know, for an equationf(x1,…,xn)=0and one of its solutionsp̄, the sensitivity matrix associated withp̄is the Jacobian offatp̄. The bases of the tolerance zone ofp̄are the column vectors of the sensitivity matrix. We have the following conclusion about the variations of the tolerances: the variations of tolerances could be an explicit scale range or an implicit range decided by some functions. Regardless, the shape, defined by angles of adjacent edges of the tolerance zone, as well as the convexity, is kept. The Appendix provides a related proof.This conclusion indicates that the tolerance zone of the pointpin (1) is centered atp̄and is spanned by the column vectors of the sensitivity matrix. The variations ofδionly affect the magnitude of the span along the bases. Having this shape consistency allows us to decompose the computation of the tolerance zone of the target in the multiple dependency into a few steps:–compute the target shape, i.e. compute the sensitivity matrix at pointp̄.compute the transferred tolerance zone in the target by finding the min/max ranges of the reference variations along the bases of the target shape determined earlier.compute the zone formed by independent variations of the individual references.zoneZ(p)is the Minkowski sum between the transferred tolerance zone and the zone spanned by independent variations.We show an example in Fig. 8. Pointcis decided by bothaandbwith the angular dimension constraintsθ1andθ2as in Fig. 8a. The column vectors of the sensitivity matrix indicate the bases are along the directionsθ1andθ2. In Fig. 8b, by estimating the ranges of variations, we know the transferred tolerance zone is the pink parallelogram spanned by two bases. Anglesθ1andθ2also have variations, which spans another (small) parallelogram. We knowZ(c)is the octagon formed from the Minkowski sum of two parallelograms.The dependency graph described earlier connects all primitives and represents dependencies of dimensions. For each primitive, its global tolerance zone can be obtained by applying the techniques for computing the relative tolerance zones and those for tolerance zone cascading. However, the dependency graph is not unique with respect to one dimensioning scheme. In this section, we present a technique for finding the dependency graph having minimum tolerances. In order to define it formally, we formulate this problem as an optimization problem.Given an existing dimensioning diagram, we could decompose it into geometric primitives. Each primitivemis associated with a global tolerance zoneZ(m), which is yielded by a corresponding dependency graph. We define the cost functionEfor optimization in terms of the dependency graphGas(3)E(G)=∑i=1nwi⋅‖Z(mi)‖,wherewiis the weight associated with the primitivemiand where‖⋅‖means a scaling function (e.g. the zone area) that mapsZ(mi)to a scale value. Thewiwill generally be specified by the engineer to indicate (by assigning larger values to thewi) which primitives are a priority to minimize.The optimization on tolerancing is usually motivated by cost requirements, functional requirements, assembly requirements, etc. Here we minimize the tolerance associated with one part. For each primitive on the part, we allow the designer to adjust its weight in optimization. The objective function in (3) has a two-fold meaning. One is that the tolerance is minimized so that the processing cost could be reduced without requiring more precision engineering machines or processes. The other is that designers could reflect the design intentions by adjusting the weights on primitives, so that the functional or assembly requirements could be met.Though the dependency graph can represent the dependencies between primitives, two factors prevent us from finding an optimal solution on it directly. One is the tolerancing ambiguity. Take Fig. 4b as an example. The chains1→s2→s4could be two levels of single dependency cascading or could be a part of a hybrid dependency cascade. The other is reasonableness of the optimized scheme. The solution space of the optimization is the space consisting of all dimensioning schemes. However, many of them are unreasonable in engineering because they are far from an acceptable scheme in practice, though they may seem to have lower cost. Our goal is to find a structure to present schemes that are practical for design and manufacturing without causing any dimensioning ambiguity. Therefore, we build an augmented graph from a given dependency graph, which represents the set of reasonable schemes “nearby” the original dependency graph among the whole solution set. We will also see that any ambiguity is resolved in this new representation. By applying the optimization on this subspace, we will have an optimized and reasonable engineering scheme. The augmentation steps are as follows:–create new nodes to represent multiple dependencies. Let us color the nodes of the original dependency gray and color the new type of nodes red. For a given multiple dependency{m1,m2}→t, we first create a red nodem12; then we replace the original edges of the multiple dependency with three directed edgesm1m12,m2m12andm12t;decompose the multiple dependency, if possible, into several single dependencies. If a given multiple dependency{m1,m2}→tis decomposable we add two directed edgesm1tandm2tinto the graph;add additional edges for inverse dependencies. For a single reference{m}→t, we add the directed edgetm; for a multiple reference{m1,m2}→t, if it is invertible we add two directed edgestm1andtm2into the graph;repeat until we cannot add more node or edge into the graph.Note that we do not add any duplicated directed edges into the graph. To illustrate the process, consider the part in Fig. 4a; we will create the augmented graph in Fig. 9. First, we create red nodess23,s121,s122ands123representing the multiple dependencies, remove the original edges for those dependencies, and add the associated directed edges for the red nodes accordingly. Second, the multiple dependencies of nodes23can be decomposed. Two edgess2s4ands3s4should be added (note that these edges existed previously but were removed in the prior step). Third, we invert the dependencies as much as possible. We add edgess2s1,s3s1,s4s3, ands4s2into the graph. We repeat all steps. The earlier process causeds1to have two edges pointing to it, and we thus create a red nodes23representing a new multiple dependency.The goal of the optimization is to find a dependency graph of which the cost function in (3) could be minimized. The input is the augmented graph and the output is a dependency graph which can be translated to a new dimensioning scheme as well as a processing plan.Since it is a DAG, the dependency graph must have some nodes as roots (no in-edges). For example,s1is the sole root for the DAG in Fig. 4b. The root(s) guarantee reachability, meaning that non-root nodes could be reached via the graph that starts from those roots. Our optimization process aims to (1) identify appropriate root nodes, and (2) for those root nodes, determine an order of evaluation of the dependencies. In this way, a dependency DAG is extracted from the augmented graph, and our goal is to find the dependency DAG that minimizes (3).Assume that a root node(s) has been determined in the augmented graph. The root node is assumed to have an exact dimension, and thus the tolerance zone will only be a point. Given root nodes, a dependency chain can be created and tolerance zones propagated in the augmented graph: gray nodes will be determined by the evaluation methods for primitives. Red nodes can be evaluated (i.e. the gray node the red node points to can be evaluated) only once all gray nodes pointing to it have been evaluated.To find the optimal dependency graph, we will do the following:–choose a set of root nodes. Note that a user may also specify the root nodes directly if the situation dictates it (e.g. a fixture point). All other nodes must be reachable from the root(s). We will typically consider using only one or two root nodes, since this is all that is typically allowed in practice. It also makes an exhaustive check feasible. Notice that a trivial “optimal” solution will be to make every node a root node. Our goal is to find an optimal dependency graph, and keeping a minimal set of roots is a part of that;for the given root node(s), compute the minimized cost for the remaining nodes. This is the major part of the optimization. We attempt to exploit the optimal substructure for this problem. In (3), the cost for nodepis‖(Z(p))‖. Assume the reference nodes that points toparepi,1≤i≤n. We have(4)‖(Z(p))‖=min{‖Cascade(Z(pi),R(p))‖}.IfZ(pi)also yields the minimal cost for nodepi, then formula (4) defines the optimal substructure of the optimization. This means the subproblems are overlapping and therefore we can use dynamic programming to solve this problem efficiently. Whether optimal substructure holds depends on the selection of the scaling function, which will be discussed later;evaluate the overall cost function; if this is a new minimum, determine the associated dependency graph and store it as the current best graph;repeat the process by choosing a new root candidate until all candidates have been determined.Selecting the scaling function is the key problem for our evaluation method. Ideally, this function will be compatible with the optimal substructure in formula (4) so that we can overlap subproblems during optimization. In practice, however, it is usually hard to find such a function which satisfies the requirement strictly. We therefore propose to use the area of the tolerance zone as the scaling function. This selection makes the original optimization becomes an NP hard problem because the optimal substructure is broken and enumerating the solution set is the only way to compute the optimal solution. However, we show that for most cases, this selection adapts well to the optimal substructure criteria.First note that points form the basis for most of the computations, both as direct feature positions and as segment endpoints. From experimental observation we found that the cascaded tolerance of points tends to approach circularity. This is caused by (1) the convexity of relative tolerance zones and (2) the random distribution of the directions of bases spanning the tolerance zones. We mostly use Minkowski sum to cascade tolerance zones and thus the cascaded zones expand in every direction in a uniform way, and become more circular as the tolerances cascade. We can easily verify that if the tolerance zones are circular, then the optimal structure is always satisfied by using the area as our scaling function. We take the perpendicularity in Fig. 7a as an example. IfZ(a)andZ(b)are both circles, thenZ(d)is also a circle. If we decrease the size ofZ(a)orZ(b)thenZ(d)will also be decreased (as well asZ(c)). The inverse of this procedure also holds. As a result, the area tends to be a good scaling function; though not guaranteeing optimality, it is close to doing so, and thus allows us to apply dynamic programming and achieve good results.We show that our dynamic programming paradigm has a polynomial complexity bounded byO(n4), wherenis the number of nodes in the augmented graph. The complexity for choosing root candidates isn2. For evaluating non-root nodes, we use the bottom up scheme. If one node can be evaluated, we compute its tolerance zone and mark it as evaluated. We try to evaluate all non-evaluated nodes. This could be achieved with complexityO(n2). Therefore, the complexity of the whole algorithm is bounded byO(n2⋅n2)=O(n4).

@&#CONCLUSIONS@&#
