@&#MAIN-TITLE@&#
Implementation of a parallel finite-element library: Test case on a non-local continuum damage model

@&#HIGHLIGHTS@&#
New finite-element code based on a hybrid object/vector design.Parallel implementation showing a close to perfect scalability on integral type localization limiter algorithms.Results in agreement with theoretical predictions and comparable to other numerical approaches in terms of energies and fragments’ shapes are obtained with an explicit time-integration scheme and non-local continuum damage.

@&#KEYPHRASES@&#
Finite element method,Parallel computing,Continuum damage,Non-local approach,

@&#ABSTRACT@&#
This paper presents an efficient method to implement a damage law within an explicit time-integration scheme, in an open-source object-oriented finite-element framework. The hybrid object/vector design of the framework and implementation choices are detailed in the special case of non-local continuum damage constitutive laws. The computationally demanding aspect of such constitutive laws requires efficient algorithms, capable of using High Performance Computing (HPC) clusters. The performance of our approach is demonstrated on a numerically and physically challenging 3D dynamic brittle-fragmentation test case. An almost perfect scalability is achieved on parallel computations. The global dynamics and energy terms are in good agreement with classical cohesive models’ predictions.

@&#INTRODUCTION@&#
Understanding the different mechanisms involved in the fracture of brittle materials under dynamic loading, such as crack branching, or the transition between different types of crack propagation (trans/intra-granular) is key in the design of new materials. A way to study these mechanisms is by the use of numerical methods. Many numerical approaches can be found in the literature, such as peridynamics [1,2], eigenerosion [3], or finite-element methods with additions to represent a discontinuity like cohesive models [4], the eXtended Finite-Element Method (X-FEM) [5], or continuum damage with localization limiters such as delayed damage [6], second gradient [7] or non-local integral [8].In the context of this paper, the continuum damage with non-local integral type limiters will be used due to its ease of implementation and the fact that it is well-established for at least static-fracture mechanics problems [8,9]. This method however is computationally demanding, since in the constitutive law a neighborhood of each material point has to be taken into account. Therefore, the use of parallelism in the implementation of such a method can decrease the execution times considerably. To the author׳s knowledge there are only pure C++ object-oriented or pure Fortran implementations for the explicit non-local method implementation as shown in [10] or [11]. Contrasting such single programming paradigm implementations, this paper will present a new code developed by the authors and named Akantu [12], that aims to combine the advantages of both views: the genericity and extensibility of the object-oriented paradigm of C++, and the vectorial efficiency present in Fortran. In this code we included parallelism capabilities with the idea of combining performance with ease of implementation of complex algorithms.This paper is organized in three major sections. First it presents some reminders on the finite-element method, particularly in the context of non-local continuum damage. Second, it explains the implementation details in the case of library Akantu. Third, it presents a 3D fragmentation test-case that validates the method.In this paper we will assume the case of continuum solid mechanics with an explicit time-integration scheme. If we consider a central difference scheme, the finite-element formulation can be reduced to the following equations that must be solved iteratively:(1)Mu¨n+1=fextn+1−fintn+1(2)un+1=un+Δtu̇n+12Δt2u¨n(3)u̇n+1=u̇n+12Δtu¨n+12Δtu¨n+1In these equations,un,u̇nandu¨nrepresent the approximations of the displacement, velocity and acceleration at a time tn,Mis the mass matrix, andfextn,fintnare the external and internal forces respectively. Finally,Δtis the time step defined such thattn+1=tn+Δt. In order to have a stable explicit time-integration,Δtis submitted to the Courant–Friedrichs–Lewy condition [13].Eqs. (2) and (3) are usually rewritten in a predictor/corrector way, which leads to a possible separation of a time iteration in four stages: prediction of the kinematic variables, computation of the new internal forces, resolution of the acceleration and correction of the kinematic variables.In this formulation, the material׳s behavior is taken into account in the computation of the internal forces.The forces are computed from the stress at each material point. Therefore, for all such points, the constitutive law has to be defined.In the simplified case of a linear elastic and brittle material, isotropic damage can be represented by a scalar variable d, which varies from 0 to 1 for no damage to fully broken material respectively. The stress–strain relationship then becomesσ=(1−d)C:εwhereσandεare the Cauchy stress and strain tensors, andCis the elastic stiffness tensor. This formulation has been proven to lead to a localization of the strain-softening region [14].As previously mentioned, there exists many localization limiters. In this paper, we will only consider the integral non-local approach. This approach consists in replacing a variable v in the constitutive law with its averagevnlon the direct neighborhood (4). In continuum damage models this is usually done on a scalar variable that is used as a criterion for damage evolution.(4)vnl(x)=∫Nα(x,ω)v(ω)dωwhere N is the neighborhood of interest andα(x,ω)is the weight function defined as(5)α(x,ω)=αo(∥x−ω∥)∫Nαo(∥x−η∥)dηThe non-normalized actual weight function αocan have different expressions [15]. One that is commonly used is the bell-shaped function (6).(6)αo(r)={(1−r2R2)2forr≤R0otherwiseIn this weight function, R defines the radius of the sphere N. In some cases it can be related to a material parameter, but in most cases R is an internal parameter that has to be chosen carefully to get meaningful results.To completely define the damage model, we still have to define an evolution law for the damage d. Many evolution laws can be found in the literature. For the purposes of this paper, we will use a simple isotropic damage evolution based on an energy criterion [16,17].(7)Y=12ε:C:ε(8)F=Y−Yd−Sd(9)d={min(Y−YdS,1)ifF>0unchangedotherwiseIn this formulation Y is the strain energy release rate, Ydis the rupture criterion and S is the damage energy. The non-local version of this damage evolution law is constructed by averaging the energy Y.We implemented an efficient general purpose finite-element library called Akantu [12]. As a demonstration of the possibilities of this library, we implemented in it the model presented in the previous section. This open-source object-oriented library distinguishes itself from other finite-element codes by its hybrid object/vector architecture. It uses the object-oriented view for “high-level” algorithms. This abstraction endows the code with properties such as re-usability, genericity, and ease-of-extension. But for “low-level” processes, such as loops on elements, nodes or material points, the mechanisms of object-oriented programming such are virtual calls can be slow. Consequently, in Akantu the choice was made to code these critical loops in a vectorial way, i.e. similar to a C or Fortran manner. This hybrid implementation style uses the advantages of both the object-oriented and the procedural programming paradigms. To understand better this hybrid view, Fig. 1presents the different representations of a mesh in the case of the three paradigms, 1(a) the object-oriented view where every part of the mesh is an object, (b) the vectorial view where the mesh exists virtually through the vectors storing its data, and finally (c) the hybrid that mixes both views.To achieve better performance, we developed parallel computation capabilities in Akantu. This parallelism is based on a regular domain decomposition method and message-passing communications. The mesh is split in order to balance the number of elements per processor – since the computation is proportional to this number – and to reduce the size of the interface between processors since the amount of communication is linked to this size [18]. In addition to this mesh partitioning, Akantu uses a layer of ghost elements to define the communication scheme as shown in Fig. 2. For an explicit time-integration scheme, as previously indicated, Eqs. (1)–(3) can be rewritten in four stages: prediction, computation of internal forces, resolution of the acceleration, and correction. In the cases where ghost elements are used, the parallelism appears only in the computation of internal forces as described in Algorithm 1. The three other stages are done locally on each processor by simple iterations on all nodes to conserve the contiguity of the data in memory.Algorithm 1Parallel computation of internal forces.•evaluation of non-ghost elements stressesstarting synchronization of ghost elements stresses (dark brown arrows in Fig. 2)assembling non-ghost elements contributions to the internal forcesfinishing the communicationsassembling ghost elements contributions to internal forcesIn this algorithm, the communications that are marked by arrows are overlapped with the assembly of forces for local elements. This is important because, by making the choice of having ghost elements instead of the more commonly used shared nodes, extra computations are involved but simpler communications are needed. The internal forces are computed for each ghost element, as many times as an element is shared. The advantage of using ghost elements is that it simplifies most of the parallel algorithms, since most of the computations are element-based. A direct example of this is our implementation of non-local damage.For the integral non-localization it has been shown in Section 2.2 that the stresses computation needs to take into account a neighborhood. In the case of Eq. (6) this neighborhood is a sphere of radius R. This implies the ability to identify the neighbors of a given material point, which can be done by pre-computing the neighbors׳ list for each point. For this, we use a regular spacial grid to accelerate the search of the neighbors, which is an algorithm fast enough for a spatial search that is done only once at the initialization step. Once the pairs of neighbors are determined, the associated weights can be computed. Depending on the type of weight function used, updates of the weights could be performed during the simulation.After completion of these steps, everything is in place to compute the internal forces based on a non-local variable. For the computation of internal forces, only the part concerning the evaluation of the stress is then modified. In fact, the variable on which the damage depends has to be computed and averaged before the damage, and therefore the stress, can be computed. In the case of the damage law used in this paper (7), this variable is Y.In the parallel version of the code, we need to add new layers of ghost elements, in order to have enough information to average a variable on the border elements (see Fig. 3). Since we pre-compute the neighbors, the corresponding communications scheme is also pre-computed.These additional ghost elements need to be synchronized during the computation of the stresses in order to compute the correct averages of the non-local variable. This modifies the first step of Algorithm 1. The changes in the algorithm are presented in Algorithm 2. We wrote this algorithm to non-localize any state variable of a given constitutive law even if in this paper we present only the example of a damage law. In the description of the algorithm we are using the notations of Eq. (4).Algorithm 2Parallel computation of internal forces with non-local contributions.•computation of the local variable v on the non-ghost elementsstarting synchronization of v for ghost and extra ghost elements (light orange arrows in Fig. 3)integration of non-ghost elements contributions tovnlthe non-local variablefinishing the communication of vintegration of all the ghost elements contributions to thevnlevaluation of non-ghost elements stresses based onvnlstarting synchronization of ghost element stresses (dark brown arrows in Fig. 3)assembling non-ghost element contributions to the internal forcesfinishing the communicationsassembling ghost element contributions to the internal forcesHere again the communications are shown with arrows and are overlapped with computations on the local elements. To simplify the constitutive laws code, the communications and the averaging are always performed, even if there is no damage. This choice should not impact the performances since the communications are overlapped. Updating the neighbor list would be more expensive. The verification and the efficiency of this algorithm and our implementation will be discussed in the next section.Basic validity tests were performed by Wolff [19], using our code Akantu with a different damage law. A mesh convergence study was conducted and a Nooru-Mohamed [20] test was simulated. In [19], it was also shown that the damage patterns are not mesh dependent. Material parameters were explored to see their influence on the crack patterns and crack velocities. Therefore in this section the simulations will be focused on the parallelism performance. In order to check the approach for the non-local continuum damage implementation in parallel, and to assess its efficiency, we will use a fragmentation test presented by Levy in [21], in which a cohesive element approach (also called discrete approach) was used. The results obtained by Levy give information during the simulation that can be used as a benchmark. Relevant quantities include the number of fragments as a function of strain rate, and the various energy terms. Even if the cohesive element method suffers from mesh dependency, the predictions obtained with this method are in good agreement with experiments [22,23]. Furthermore the cohesive element method has been shown to be in good agreement with energy based model predicting fragment size [24].The fragmentation text presented by Levy consists of a 3D dome exposed to an explosive loading. The parameters for this test have been taken from [21]. Because of the problem׳s symmetries, we can simulate only a quarter of the dome (see Fig. 4). The normal displacements are blocked on each flat face of the quarter dome and a velocityv0(x)=ε̇0xis initially set. The material used is an aluminum oxide,Al2O399.5%. This material is characterized by its Young׳s modulusE=370MPa, density ρ=3900kg/m3, and Poisson ratio ν=0.22. The damage law is defined by a uniform distribution of Ydbetween 94kJ/m3 and 103.4kJ/m3, S=757.6kJ/m3 and R=0.1mm. The non-constant values for Ydcorrespond to an introduction of defects. The parameters Ydand S are computed from the critical stressσc=264MPaand the fracture energyGc=50N/mas follows:Yd=σc2/2EandS=EGc2/2R2σc2+Yd[17].In order to have a sufficient number of neighbors in the radius of 0.1mm a fine mesh has to be used. These simulations have been run on a mesh with 1,460,670 linear tetrahedrons, which leads to an average of 14 neighbors per material point.The simulations were performed on a Sandy Bridge cluster composed of 16-core nodes (2 octo-core processors) with 32GB of RAM. The nodes were interconnected with an Infiniband network. Up to 21 nodes were used.

@&#CONCLUSIONS@&#
