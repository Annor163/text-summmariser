@&#MAIN-TITLE@&#
Analysis of an EMST-based path for 3D meshes

@&#HIGHLIGHTS@&#
We analysed sensitivity of the EMST structure to obtain a more robust synchronization.We computed how a vertex can be moved without changing the connections.We present a new theoretical analysis and a way to visualize EMST robustness.We detect fragile area and to predict the 3D object robustness.Keywords are Euclidean minimum spanning tree, Sensitivity analysis, Synchronization.

@&#KEYPHRASES@&#
Euclidean minimum spanning tree,Sensitivity analysis,Synchronization,

@&#ABSTRACT@&#
For several 3D data applications such as data-hiding or compression, data ordering is a major problem. We need to know how to achieve the same 3D mesh path between the coding and decoding stages. Various algorithms have been proposed in recent years, but we focus on methods based on Euclidean Minimum Spanning Trees (EMST). In this paper, we analyse the sensitivity of the EMST structure to obtain a more robust synchronization. We present a new theoretical analysis and a way to visualize EMST robustness. Moreover, this analysis can be useful in 3D data-hiding in order to detect fragile area and to predict the 3D object robustness during transmission on a noisy channel.

@&#INTRODUCTION@&#
Internet is very useful for broadcasting multimedia information. There are more and more 3D object exchanges in computer graphics, CAO and video games. Therefore, it is essential to produce efficient techniques for protecting, visualizing, sharing, printing and modifying these 3D objects. For these applications, it could be important to have a single 3D mesh path which orders the vertices. In this domain, this vertex ordering step is often called the synchronization step. Indeed, contrary to the 2D imaging field, where there is a trivial path with rows and columns, the case of 3D objects is more complex, even though the 3D mesh is semi-regular or regular. For example, in 3D data-hiding, it is essential to locate where the binary embedded data is distributed. This kind of path is used for synchronization with the aim of keeping the same order at inserting and extracting stages. A survey of 3D watermarking techniques has been proposed by Wang et al.  [1]. Watermarking techniques are interesting to protect the file content and also to embed meta-data. Data-hiding may be a way to have new functionalities, i.e. keeping the standard format without increasing the size. Another example of the benefits of having a single 3D mesh path is to produce a deterministic traversal of the mesh for 3D compression, as presented in a survey by Peng et al.  [2].The step which gives a mesh order is one of the main difficulties in compression, watermarking or visualization. Furthermore, in some specialized areas (medicine, industry), the position of vertices and the connectivity between them (in the 3D mesh) should not be affected by the path building process. Various methods have been proposed, but we are interested by the Euclidean Minimum Spanning Tree (EMST) method proposed by Amat et al.  [3]. The authors proposed a scheme which does not move any mesh vertex. They used an EMST to be able to scan the mesh in a unique manner for data synchronization.Since the method is fragile, an EMST sensitivity analysis is necessary to determine the robustness threshold of an EMST-based on a 3D mesh. In this paper, we analysed the EMST sensitivity by computing how a vertex can be moved without changing the connections in the EMST. Since the problem is very difficult, we made some assumptions in order to make it tractable. It may also be interesting to quantify the EMST robustness. A sensitive analysis can be useful for some applications such as 3D reconstruction  [4], 2D object recognition and classification  [5], watermarking  [3,6], compression  [7] and segmentation  [8]. For example, the proposed analysis could be used to improve the choice of the mark vertex selecting proposed by Wang et al.  [9].The rest of the paper is organized as follows. In Section  2, we deal with the 3D path building issue. We present various classes of techniques, such as the synchronization by data structure (EMST). In Section  3, we present the problem of EMST sensitivity. Then, in Section  4, we propose a new approach to this problem by analysing the displacement of the vertex at each step of Prim’s algorithm  [10]. We assessed our theory in order to quantify the displacement of the vertices. The results are given in Section  5 and our approach is validated. The discussion is concluded in Section  6 and future work directions are mentioned.3D processing is a comparatively new multimedia research field. One of the main problems in these applications is the ordering of 3D model data. In this section, we present ordering techniques based on a single path of 3D model. First, we present methods which only perform a path on a part of the mesh. Then we introduce some methods which order the patches created on the mesh. Finally, we present techniques that define a path along all vertices of the mesh.One of the first paths for data-hiding watermarking techniques was proposed by Ohbuchi et al.  [11]. The algorithm and synchronization of the embedded message are quite simple. The idea, illustrated in Fig. 1, consists of duplicate facets of the mesh along a band that encodes the message. To start the duplication, a starting edge and an orientation of the triangles must be defined. To encode a ‘0’, from the current edge, they have to duplicate the first edge they meet during the exploration, and for embedding a ‘1’ they have to duplicate the second edge. The duplicated edge becomes the current one and the algorithm continues until all bits of the message are embedded.With this approach, the mark is robust to geometrical modifications such translation, rotation and scaling. But it is visible and easily detectable, i.e. the algorithm is not secure. Moreover, vertices and facets are added and the size of the mesh increases as a function of the message size. Nevertheless, it is one of the first paths proposed for 3D blind data-hiding methods.The idea behind creating a band, or performing a scan on the mesh to synchronize the hidden message is classic reasoning. For example, Mao et al.  [12] and Cayre et al.  [13] proposed almost the same approach to scan the mesh.In the approach proposed by Mao et al., they built a triangle path in the mesh to synchronize the data to be embedded, as illustrated in Fig. 2. They selected a starting triangleΔ, an edgeeofΔ, and an orientation of this triangle. At each step, they choose one of the neighbour triangles as a function of the orientation and the previous step. From the current edgec, they scan the triangle in the direction of the orientation and select the last edgeeof the current triangleΔ. Then they select the neighbouring triangleΔ′, if it exists, such thateis the common edge betweenΔandΔ′. ThenΔ′becomes the current triangle, and will be scanned in the opposite direction. The orientation to scan the triangle alternates as illustrated in Fig. 2. The operation continues until we do not need triangles to embed the hidden message.In principle, this method does not create geometric error. However, the watermark can be detectable because it is a high density area in the mesh. Furthermore, such methods are obviously not robust against connectivity attacks.In this section, we present some methods that create patches on the 3D mesh. This is an interesting approach to deal with certain constraints in the 3D mesh area such as malicious attacks or visible deformations induced by watermarking for example. In segmentation areas, a 3D mesh is partitioned following the model semantics. For example, Tierny et al.  [14] proposed a method based on construction of the skeleton of the mesh that produces a small number of patches. These patches are quite semantically correct, but there are few of them and they are not ordered. Defining a path in a mesh requires a higher number of patches and a very deterministic algorithm.Luo and Bors  [15] proposed an efficient watermarking scheme based on regions of equal geodesic distance. These distances are calculated from a chosen vertex (in red in Fig. 3).Each strip in Fig. 3(b) is used for embedding a single bit, while the region around the source, which is shown in blue, is trimmed away. Patches are created thanks to their geodesic distance from a vertex, so they are ordered by construction.Wang et al.  [16] proposed another synchronization for their watermarking method that is based on generating a cylindrical system patch by discretizing itshandθdomains. Patches are ordered according to their spatial locations. In another paper, Wang et al.  [17] proposed to use manifold harmonics and to quantify the amplitudes of some low frequencies coefficients in order to hide a 16-bit watermark (see Fig. 4).The Edgebreaker mesh compression algorithm proposed by Rossignac  [18] is a mono-resolution algorithm, i.e. it does not allow access before full load. It puts the vertices and facets in order at the same time without redundancy, as illustrated in Fig. 5. The scan is also unique, as it depends on the first vertex and the first triangle chosen.This technique is based on region growing that incrementally encodes facets and their relations. Thanks to this algorithm, we obtain a unique sequence of vertices that totally defines the mesh.To illustrate the need for a well defined order in a 3-D mesh, we present two watermarking techniques which are based on previous synchronization methods. The watermarking of Bogomjakov et al.  [19] is based on swapping elements in the file. The synchronization step can be done by any kind of deterministic mesh traversal and they use the traversal performed by the Edgebreaker   [18] algorithm. This example shows that ordering vertices of a 3-D mesh in a robust way is a relevant goal to produce more and more applications in this area. Another method proposed by Wang and Men illustrates that the synchronization is determined only by the file ordering  [20].In the method proposed by Amat et al.  [3], data embedding in the mesh is based on modification of the connection between the vertices in the mesh, without moving the vertices. In order to synchronize the message, an EMST is computed. Fig. 6(a) illustrates the EMST of a horse mesh (504 vertices). The EMST is unique, depending on a seed vertexv0, while the path of vertices is also unique. This can be a synchronization tool because we can scan the EMST with a single path. Amat et al.  [3] selected quadruples, a vertex and its three sons in the EMST to embed one bit per quadruple, if possible. In order to avoid visual distortion and desynchronization, the quadruples must verify three conditions: coplanarity, the measure of the angle formed by the two triangles must be close to 0; convexity, to scan the same geometrical space; and if two quadruples are neighbours or overlapped, then only one of them is used for the embedding.However, this method produces fragile watermarking, i.e. if the mesh is modified then the watermark is not extractable. The problem is to know how this method is stable. Indeed, if it is fragile enough to detect any modification. Conversely, we want to know how the method is robust against vertex displacement in order to find new tracks for robust watermarking. We focus on this original method to quantify the fragility of the data synchronization by studying the robustness of the EMST. Indeed, as we can see Fig. 6(b) which is the EMST of the noisy horse mesh withσ=10−2, the EMST computed on a mesh is very sensitive to vertex displacement. Fig. 6(c) illustrates the comparison between the original horse mesh and the noisy one. The problem is well known in the graph theory for the minimum spanning tree (MST), but has not been very well studied in the geometrical case (i.e. EMST). We discuss the state of the art of the analysis of the MST sensitivity in Section  3.In this section, we present how the problem of EMST sensitivity may be defined with various approaches.As per this paper, we have taken a cloud of verticesVand explored how we can move a vertex in space without changing the connectionsEin the Euclidean minimum spanning treeT=(V,E). LetG=(V,E)be a graph withnnodes andmedges. An EMST is MST which is based on the Euclidean distance, i.e, a treeT=(V,ET)which joins all the vertices of a graphG=(V,E)using the edgesei={vs,vt}∈E, with a weightω(ei)∈R+, that minimizes the total weight∑ei∈ETω(ei).Our approach is based on Prim’s algorithm in order to have an incremental algorithm. At each step we have a sub-treeTi=(Vi,Ei)of the final EMST. The algorithm starts with a seed vertexv0∈V. We note(Ti)i≤n=((Vi)i≤n,(Ei)i≤n)the tree sequence representing the EMST construction pattern.With these notationsT0=({v0},0̸). At each stepi>0, the algorithm adds the closest vertexvi∈V¯i−1toVi−1and toEi−1it adds the connection betweenviand the closest vertex ofviinVi−1that we call its “father” and denote byf(vi).Hence, we deduce:(1)Vi=Vi−1∪{vi};(2)Ei=Ei−1∪{vi,f(vi)}.The Minimum Spanning Tree (MST) is a well-known problem in graph theory. It is a polynomial problem that is solved by two famous algorithms, i.e Prim’s  [10] and Kruskal’s  [21]. For a given MSTT, it is interesting to know which connections are fragile, and which are not. The MST sensitivity problem may answer this question. MST sensitivity is also a polynomial problem. In this section, we have presented an approach for solving the problem and we draw a conclusion for our application.For Gordeev  [22,23], the MST sensitivity analysis is an optimization problem based on matroids. The aim is to determine the maximum intensity of a disruptive vector such that the solution of the optimization problem remains a solution after the perturbation. Gordeev considers the following model: letDm={T1,…,Tq}, with(q>1)being a system of subsets ofEcalled trajectories;A=(a1,…,am)⊂Rmsuch that∀iai=ω(ei), the weight of the edges of the graphGandω(TA)a functional called the trajectory length forA, such thatω(TA)=∑ei∈Tai. Therefore, the combinator problem is defined with the pair(E,Dm),Ais the variable to optimize in order to minimize the functionalω(TA). Gordeev models the MST problem withDm, the set of all spanning trees ofGin which the MST is a trajectory that minimizes the functionalω(TA).Letψ(A)be the index setiof the optimal trajectoriesτiof the problem for a givenA, andB∈Rm, such that forϵ∈R+∗,‖B‖<ϵis a perturbation vector. Gordeev talks aboutϵ-stability whenψ(A+B)⊂ψ(A). In the MST problem, for a given noise intensityϵ, some MST are always solutions of the MST problem after the perturbation. He deduces a stability radiusρ(A)=supϵ, such thatAisϵ-stable for the problem. Its algorithm is polynomial and its complexity isO(n3mlog(n2m))and for a complete graphO(n5).For Dixon et al.  [24] the sensitivity analysis problem is, for a given graphG=(V,E)andT=(V,ET)its MST, to know how each edge value can be modified (forei∈ETandei∈E∖ET) without changing the connections ofT. They divide the problem into two parts. For∀ei∉ET, they compute how much they can decreaseω(ei)without changing the MST and, for all the edgesei∈ET, they compute how much they can raise the weight ofei,ω(ei)without changing the MST. This step has a linear time complexity as a function of the number of edges.The aim of Yaman et al.  [25] is to introduce a robust version of the MST where the edge costs are specified as interval numbers. It is a spanning tree such that the weight of the tree minimizes the maximum deviation from the MST. They introduce the notion of a weak tree, and it is an MST for some scenarios. In other words, for different edge valuations, the weak tree is not always an MST. Then, an edge is a weak edge if it lies on some weak tree. On the contrary, an edge is a strong edge if it lies on an MST for all possible edge evaluations. Their goal is to define a robust spanning tree, so they introduce two robustness measures for the MST problem, “absolute robustness” and “relative robustness”. These measures are used to characterize the worst case scenario, and then they use mixed integer programming to find a robust spanning tree. This method is very interesting for small graphs but it has huge complexity.For each step of the Prim’s algorithm, we want to compute the area in which the vertexvi∈Vican be moved without changing the connection in the EMST. This area depends on the seed vertex (denotedv0) and the vertices selected beforevi. Fig. 7illustrates that the EMST changes when a vertex moves too much. Distinguish EMST between the vertex ordering is necessary to well understand the analysis. Nevertheless, we point out that the ordering given by Prim’s algorithm is dramatically dependent of the EMST stability.To compute this area we make the following simplification assumptions on the disruption of vertices:Assumption 3.1At the stepi>0of Prim’s algorithm, we will disturb only the position of the vertexvi, resulting in the disturbed vertexv∗;Assumption 3.2The geometric disruption will be restricted to only be along the half-line]f(vi);vi).After the perturbation,Ti∗=(Vi∗,Ei∗)denotes the graph sequence withVi∗={v0∗,v1∗,…,vi∗}. Suppose that∀k;k<ithe EMST at stepkis always the same (Tk=Tk∗). This is an important hypothesis, and we note that it is not always verified. Indeed, we simplified the problem by taking into account these assumptions, in order to compute the intrinsic vertex properties. At the stepi, supposing thatTk∗≠Tk,∀k≠i, implies that the radiusriofvidepends of the previous ones.Then, to keep the same connections in the EMST, we need to verify these two conditions:1.v∗=vi∗,v∗is selected at theith step of Prim’s algorithm;f(v∗)=f(vi∗), the father ofv∗is still the father ofvi.In this section, we propose to analyse the sensitivity of the EMST by analysing the vertex displacement. In this paper, we limit the vertex displacement analysis along the half-line]f(vi);vi). To compute the possible displacement of each vertex without changing the connection in the EMST, we divide the problem into two parts. In Section  4.1, we present how the vertexvican come up tof(vi). We compute a minimum distance limit ofω({v∗,f(vi)})denoted bydi−and deduce a displacement radiusri−. In Section  4.2, we explain howvican move away fromf(vi). We also compute a maximum distance limit ofω({v∗,f(vi)})denoted bydi+and deduce a displacement radiusri+. Then, in Section  4.3 we show how to keep the EMST stable at the stepi+1. Finally, in Section  4.4, we define a global displacement radius denoted byr.In this section, we are interested in the approximation ofvito its fatherf(vi). As we know,f(vi)is the closest vertex ofviinVi−1, as illustrated in Fig. 8. Obviously,f(vi)was selected beforeviin Prim’s algorithm. Letf(vi)=vkandVk={vj:j≤k}, then we deal with the verticesvj∈Vi∖Vkand the edgesej∈Ei−1∖Ekto verify the following properties.Proposition 4.1LetTi=(Vi,Ei)be the state of the EMST at theith step of Prim’s algorithm, with the previous notations, ifEi−1∖Ek≠0̸, we have:(3)∀ej∈Ei−1∖Ek;ω(ej)<ω({f(vi),vi}).Proposition 4.2Letdi−be the minimum distance betweenf(vi)andv∗, then in order to keep the same connections in the EMST we must haveω(v∗,f(vi))>di−with:(4)di−=max{ω(ej):ej∈Ei−1∖Ek}.This proposition guarantees thatTk+1∗=Tk+1,…,Ti∗=Ti, underAssumption  3.1, i.e.Tj∗=Tj,j∈{0,…,k}. We deduce the displacement radius:(5)ri−=ω({f(vi),vi})−di−.ProofLetel={f(vl),vl}be the edge, if it exists, verifyingel=maxej∈(Ei−1∖Ek)ω(ej). If this edge does not exist,di−=0, so we can move the vertexvias close as we want tof(vi). We suppose that there is at least one edgeel:di−=ω(f(vl),vl).It is important to note thatk≤l<i, in other words, in the chronological vertex selection in Prim’s algorithm,vkis selected beforevl, andvlbeforevi. To demonstrate reductio ad absurdum, Proposition 4.2 must be verified to keep the same order in the sequence(Vj∗)j≤i.Supposing:ω(f(v∗),v∗)≤di−⇒ω(f(v∗),v∗)≤ω(f(vl∗),vl∗). At the(l−1)th step of Prim’s algorithm, we knowf(vi∗),f(vl∗)∈Vl−1. According to the hypothesisω(f(v∗),v∗)≤ω(f(vl∗),vl∗), sov∗will be chosen at the(l−1)thstep. That is in contradiction with the EMST stability.Obviouslyviis the closest node off(vi)inV∖Vi, if we movevialong the half-line]f(vi);vi)closer tof(vi), then the resulting vertexv∗∈V∖Viis the closest node off(vi). In conclusion, the father ofviis also the father ofv∗with this displacement.□Now we are interested in the distance ofvifrom its fatherf(vi). In order to keep the EMST connections up to stepiof Prim’s algorithm, we divide this problem into two cases. Firstly, we are looking for the second closest vertexs(vi)toVi−1to select vertexv∗at theith step, as illustrated in Fig. 9(a). We consider the distanceω((f∘s)(vi),s(vi)).Proposition 4.3LetTibe the state of the EMST at theith step of Prim’s algorithm, then in order to keep the connection of the EMST at stepiwe need to verify this first condition:(6)ω(f(vi),v∗)<ω((f∘s)(vi),s(vi)).We denotedi1=ω((f∘s)(vi),s(vi)).Secondly, to keep the same fatherf(vi), we compute the intersectionx(vk)between the half-line]f(vi);vi)and the perpendicular bisector of the segment[f(vi),vk](vk∈Vi−1,vk≠f(vi)), as illustrated in Fig. 9(b).Proposition 4.4LetTibe the state of the EMST at theith step of Prim’s algorithm, then in order to keep the connection of the EMST at stepiwe need to verify this second condition:(7)ω(f(vi),v∗)<min{ω(f(vi),x(vk)):vk∈Vi−1,vk≠f(vi)}.We denotedi2=min{ω(f(vi),x(vk)):vk∈Vi−1,vk≠f(vi)}.Proposition 4.5LetTibe the state of the EMST at theith step of Prim’s algorithm, then in order to keep the connection of the EMST at stepiwe need to verifyω(f(vi),v∗)<di+, with:(8)di+=min{di1,di2}.UnderAssumptions  3.1 and 3.2, i.e.Tj∗=Tj,j∈{0,…,i−1}. We deduce the displacement radius:(9)ri+=di+−ω(vi,f(vi)).ProofLet us demonstrate reductio ad absurdum thatω(f(v∗),v∗)<di1must be verified to keep the same order in the sequence(Vi∗)0<i<n.We supposeω(f(v∗),v∗)≥di1=ω(s(vi),(f∘s)(vi)). According to this hypothesis,viis the closest vertex ofVi−1, ands(vi)the second one. Thenviis disturbed inv∗but the other vertices do not move. Moreover(f∘s)(vi),f(v∗)∈Vi−1ands(vi),v∗∈V∖Vi−1. Prim’s algorithm at stepichooses the closest vertex ofVi−1which iss(vi).v∗is too far fromf(vi), so to verify the condition of our EMST stability problemω(f(v∗),v∗)<di1.□Letvk∈Vi−1be a vertex satisfying the relationω(vk,x(vk))=minvj∈Vi−1ω(vj,x(vj)). Obviously, on the line(f(vi),vi), the vertices{f(vi),vi,x(vk)}are aligned in this order.Moreover,x(vk)is the equidistant vertex betweenf(vi)andvk. It clearly separates the half-line]vi;x(vk))into two parts:•∀v∗∈]vi;x(vk)[,ω(f(vi),v∗)<d(f(vi),x(vk)),v∗is closer tof(vi)thanvk;∀v∗∈]x(vk);∞),ω(f(vi),v∗)>d(f(vi),x(vk)),v∗is closer tovkthanf(vi).It proves the proposition.□The stability of the EMST, requires also that the next vertex is still the same. Suppose thatviis selected at theith step of Prim’s algorithm, the next chosen vertex isvi+1,vi+1=argminvj{w(vk,vj):vk∈Vi,vj∈V∖Vi}. We have shown that under some assumptionsvi=vi∗, in the same way, we show that we can restrict the displacement ofvito have the same next vertex and maintain the EMST at thei+1thstep of Prim’s algorithm. We divide this problem in two cases, indeed the next chosen vertex iss(vi), described in the previous section, or is given byvi+1=argminvj{w(vi∗,vj):vj∈V∖Vi}. Thus this case, is included in the previous analysis.In the second case, to keep the same next vertexvi+1, we compute the intersectionx(vk)between the half-line]f(vi);vi)and the perpendicular bisector of the segment[vi+1,vk](vk∈V∖Vi,vk≠vi+1), as illustrated in Fig. 10.Proposition 4.6LetTibe the state of the EMST at theith step of Prim’s algorithm, then in order to keep the connection of the EMST at stepi+1, we need to verify:(10)ω(v∗,vi+1)<min{ω(vi,x(vk)):vk∈V∖Vi,vk≠vi+1}.We denotedi3=min{ω(vi,x(vk)):vk∈V∖Vi}.Proposition 4.7LetTibe the state of the EMST at theith step of Prim’s algorithm, then in order to keep the connection of the EMST at stepiwe need to verifyω(v∗,vi+1)<di3, we deduce the displacement radius:(11)ri2=di3.In Sections  4.1 and 4.2, we defined two radii of displacementr+andr−. In order to have a single measure of the possible vertex displacement without changing the EMST, we need to verify all the conditions that allow us to compute these parameters independently of the displacement direction.Letri=ri=min{ri+,ri−,ri2}be the displacement radius of the vertexvialong the half-line]f(vi);vi). Thenx=1‖f(vi).vi‖(vi−f(vi))denotes the normalized director vector of the half-line]f(vi);vi).Therefore, ifv∗∈]vi−r⋅x;vi+r⋅x[the EMST will not be modified at theith step of Prim’s algorithm. We have defined a scope where the EMST does not change, in this context the vertex ordering done by the Prim algorithm is stable. However, we are aware that modifying the EMST could change dramatically the order defined, even if the percentage of common edge is high.

@&#CONCLUSIONS@&#
