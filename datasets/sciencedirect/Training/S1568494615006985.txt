@&#MAIN-TITLE@&#
Multicores and GPU utilization in parallel swarm algorithm for parameter estimation of photovoltaic cell model

@&#HIGHLIGHTS@&#
Better estimation of parameters, on two models.In this work here, we successfully identified the relevant parameters of two photovoltaic models. To prove the efficacy of the proposed method, we included a comparison study.Utilization of multicores and GPU facilities.We have implemented the parallel swarm algorithm utilizing the multicores and GPU computing capabilities of a computer.

@&#KEYPHRASES@&#
Graphic processing units (GPUs),Multicores,Photovoltaic cell model,Parameter estimation,Parallel swarm algorithm,

@&#ABSTRACT@&#
Bio-inspired metaheuristic algorithms have been widely applied in estimating the extrinsic parameters of a photovoltaic (PV) model. These methods are capable of handling the nonlinearity of objective functions whose derivatives are often not defined as well. However, these algorithms normally utilize multiple agents in the search process, and thus the solution process is extremely time-consuming. In this regard, it takes much time to search the possible solutions in the whole search domain by sequential computing devices. To overcome the limitation of sequential computing devices, parallel swarm algorithm (PSA) is proposed in this work with the aim of extracting and estimating the parameters of the PV cell model by utilizing the power of multicore central processing unit (CPU) and graphical processing unit (GPU). We implement this PSA in the OpenCL platform with the execution on Nvidia multi-core GPUs. Simulation results demonstrate that the proposed method significantly increases the computational speed in comparison to the sequential algorithm, which means that given a time requirement, the accuracy of a solution from the PSA can be improved compared to that from the sequential one by using a larger swarm size.photocurrent generated by photovoltaic cellsaturation current of a diodediode ideality constantseries resistanceparallel resistance

@&#INTRODUCTION@&#
Solar energy is a clean and renewable energy source that has been increasingly popular due to its ease of maintenance and cost-saving in the long term usage. It is widely known that the initial cost of photovoltaic (PV) system is normally high, an accurate investigation and analysis for the electrical characteristic of the applied PV component is of critical importance in the design stage. From previous experiences on working with maximum power point tracking (MPPT) algorithm in [1,2], we found that an accurate model is crucial to obtain desirable results.Over the past years, a variety of PV cell models has been developed to predict the electrical characteristics of PV cells. They are normally analytical equations predicting the values of the operating current I and voltage V of the PV cell with a series of model parameters, which are constant quantities that characterize the PV cell model. For instance, the single-diode model [3] is widely applicable in simulation tools such as PSIM [4] and PVsyst [5] due to its simplicity. PV cell model cannot be explicitly applied due to the lack of proper model parameters characterizing the PV cells. The parameter estimation is a discipline that provides tools for the efficient use of data assisting the mathematical modeling and estimation of parameter values existing in the model. In general, the methods of parameter estimation can be classified into two groups [6]:i.Analytical method[7,8]: it is a traditional approach that predicts parameters by mathematical expressions;Numerical extraction[9,10]: it fits the operating points on the I–V characteristic curves via a numerical method.More recently, the computational intelligence methods, such as cuckoo search (CS) [11], particle swarm optimization (PSO) [12], genetic algorithm (GA) [13], simulated annealing (SA) [14], bacterial foraging algorithm (BFA) [15], and differential evolution (DE) [16] are applied to determine the values of the model parameters. Albeit accurate and feasible output, these methods applied multiple agents or particles in a random search process, which consumed excessive time in a sequential computing platform. Thus, the approaches were impractical for online applications.Today's computing environments are becoming more multifaceted, exploiting the capabilities of a range of multi-core microprocessors, central processing units (CPUs), digital signal processors (DSPs), reconfigurable hardware: field programmable gate arrays (FPGAs), and graphic processing units (GPUs) [17]. To distribute the workload of PSO appropriately to the available computing device, this paper proposes a parallel swarm algorithm (PSA) based parameter estimation method for PV cell models. Error and statistical analysis are carried out to illustrate the accuracy and efficiency of the proposed method. Henceforth, we organize the remaining part of this paper as follows. Section 2 briefly introduces the single-diode PV cell model. The development environment for parallel algorithms in general is introduced in Section 3. This section provides useful tips in adopting parallel tools in an optimization work. Further, in Section 4, the PSA – based parameter estimation is described. This is followed by Section 5, which discusses the simulation results, and finally is the conclusion, presented as Section 6.When a PV cell that is connected to an external circuit, is exposed to incident light, the reverse current is generated across the p–n junction, this current is the photocurrent Ipv, shown in Fig. 1. By eliminating the effect of photocurrent, a PV cell behaves like a normal diode. Its I–V characteristics can be simply modeled as a linear independent current source in parallel to the diode. The single-diode model improves the simple model by recognizing the series resistance Rsand parallel resistance Rp, illustrated in Fig. 1. Take note that many literatures [16,18–21] denote parallel resistor as the shunt resistor, which is somehow confusing to many readers. The notation Rsis for serial resistance, not shunt resistance, which is denoted as Rp(parallel resistance). This confusion can be avoided by using the word parallel resistance rather than shunt resistance. In Fig. 1, there exists a single diode in parallel with Rpresistor. The three elements in parallel are then connected in series with Rsresistor. The corresponding equivalent Thevenin circuit equation is mathematically expressed as:(1)I=Ipv−Ip−Id=Ipv−Ioeq(V+IRs)nkT−1−V+IRsRpwherekis the Boltzmann constant with a value of 1.38065×10−23J/K,is the electron charge, equal to 1.60218×10−19C,is the temperature,is the saturation current, andis the diode ideality constant.By definition, a PV module comprises PV cells connected in series. Therefore, should a PV module consists of Nsseries-connected cells, the expression of the terminal current (1) can be rewritten as follows:(2)I=Ipv−Ioeq(V+IRs)nNskT−1−V+IRsNsRpNsHereby, the five parameters existing in the single-diode model are Ipv, Io, n, Rsand Rp. For this simple reason, the single-diode model is also known as the five-parameter model. The true values for these parameters are tabulated in Table 1.This section aims to provide general guidelines for anyone who would like to convert their sequential works to parallel platform. The parallel platform in this context does not mean linking a cluster of computers in parallel to perform a task. In fact, the context of parallelism here covers the utilization of multi-core and graphic processing units (GPUs) computation capabilities. The motivation to apply the existing work in [22,23] to parallel platform is based on this simple ideology: the computing capability of a single computer has improved tremendously and is moving away from being an esoteric pursuit. Hence, to take the full advantage of this shifting paradigm in computing devices, any sequential algorithm should be converted to the parallel algorithm to utilize fully the computing power of a single device. However, the conversion may be tedious with a non-experience programmer. Thus, hereby we provide basic guidelines that are adequate for anyone who is interested in exploring this powerful tool. To avoid lengthy discussions, we limit this to only CUDA and OpenCL development kits, described in the following subsections.CUDA is an acronym for Compute Unified Device Architecture. It is a computing platform for parallel programming created by Nvidia [24]. The parallel model is implemented by GPUs that Nvidia produces. CUDA architecture grants direct access to the virtual instruction set and memory of the parallel computational elements in GPUs. CUDA enables efficient applications across platforms that contain both CPU and GPUs. Since 2006, the release of the graphics processor has been equipped with GPUs that are CUDA-enabled. In general, the GPUs are all CUDA-capable; with a comprehensive list available at [25]. In the usual case, 256MB of graphics memory are available for developers.A CUDA-enabled GPU and Nvidia's device driver are necessary before compiling CUDA C code. Since CUDA C executes an application on both CPU and GPUs, two compilers are required to compile codes on CPU and GPUs respectively. To do this, the CUDA Toolkit is necessary and is available at no cost via the official link [26]. Two versions of the toolkit are available: the 32- and 64-bit for three major platforms: Windows, Linux and Macintosh OS X. Also, the GPU Computing SDK package is available for download, which contains a wealth of useful sample codes. For further details, the concise handbook on programming in CUDA C, available in [27] will be of much help. In the context of the work here, an interesting work on the evaluation of parallel particle swarm optimization using CUDA architecture has been accomplished in [28].Besides CUDA, the OpenCL, which is the acronym for Open Computing Language, is an alternative framework for program execution utilizing CPUs, GPUs, DSPs and FPGAs [17]. The OpenCL comes with a language based on C99, plus application programming interfaces (APIs). OpenCL provides parallel computation via either data-based or tasked based. OpenCL has been adopted by many prominent companies such as Apple, Intel, Qualcomm, Nvidia, Altera, etc. In fact, OpenCL was originally developed by Apple, but now is maintained by The Khronos Group [29], which also maintains a number audiovisual media's open standards. Similar to CUDA, the OpenCL is based on the C programming language and it lets application developers to tap into the GPU computing power that was previously available to only graphics applications.To execute codes on this platform, one has to download an software development kit (SDK). One recommendation for Windows platform is the Intel SDK for OpenCL Applications 2013, available for free download via its official link at [30]. For Mac OS X, the good news is OpenCL is fully supported by Apple's SDK in XCode. The OpenCL programming guide for Mac is available from one of the items found at [31].In this section, the concept of the particle swarm optimization (PSO) algorithm is introduced, which is then followed by the parallel implementation of the PSO algorithm.The PSO was developed by Kennedy and Eberhart [32], inspired by the swarming behavior of moving fishes and birds. Unlike the GA, PSO does not use mutation or crossover operators but the real number randomness and emphasize on the global communication among particles. Its high efficiency and simplicity make the PSO a popular algorithm and widely applicable on a wide range of engineering optimization. For instance, the PSO has been applied to grinding process optimization [33,34], power flow in an electric network [35,36], unit commitment in power generation [37], drilling optimization [38], and many more.The basic idea of PSO is to search the space governed by the objective function, acting as the fitness function to evaluate every individual in the population. The PSO works by adjusting the trajectories of particles. These particles have the tendency to move towards the global best, gbest and the personal best, pbestiof a relevant particle i.The simplicity of the PSO is astounding as it just works based on two very simple equations:(3)vit+1=wvit+2·α1xit−gbestt+2·α2xit−pbestitand(4)xit+1=xit+vit+1wheretis the iteration counter,is the velocity of ith particle,is the inertia weight, usually a value below unity, or preferably 0.5–0.9,is the position of ith particle,is the best solution (global best),is the best position that particle i ever encounter from the history of exploration,are independent uniform random number generators within [0, 1].Usually, when a variable xiexceeds its pre-specified boundary, a reinitialization is done to avoid searching beyond the boundary limits; either upper or lower boundary. Then the respective particle is evaluated via the fitness function, which is frmsin this case. The fitness function in this work is in fact an error value, given by (5). Therefore, the whole exploration and exploitation process seek to minimize this fitness function. After a particle undergoes evaluation through (5), the updates of pbest and gbest are done subsequently. The similar process will be repeated until a stopping criterion has been met. The entire scenario is described in Algorithm 1, with the algorithm's flow chart shown in Fig. 2. In this algorithm flow, the shaded box can be further expanded, given in Fig. 3. In this figure, the serial execution consists of one frmswhereas parallel execution involves multiple fitness evaluations (frms).Algorithm 1Pseudocode of parallel swarm algorithmData: a set of population P(X)Result: best solution gbest1:BEGIN2:initialize population P(X)3:whilestopping criteriondo4:update velocityvivia (3)5:update position xivia (4)6:ifboundary violationthen7:reinitialize8:end if9:P(X)←frms(X): Parallel evaluation via (5),10:update pbestiand gbest,11:end while12:ENDA general parallel computing platform implementation using the PSO was first introduced by Schutte [40] in 2004. It provides a computing manner that the objective function of all particles in the PSO can be easily evaluated by using parallel operations on a multi-processor machine. It is desirable that the PSA outperforms the equivalent sequential process in two aspects:i.PSA is scalable. In other words, more computational units can be utilized in optimization.The computational speed tends to be faster than the serial PSO with the same work load.The program starts with the algorithm initialization as the sequential PSO. As the fitness evaluations for particles are performed independently, the algorithm is decomposed to perform the evaluations concurrently on a parallel computing device, as illustrated in Fig. 3. Global synchronization or barrier function is applied to ensure that all of the fitness evaluations are completed before the computation process of determining the local best and global best. If the stopping criterion is not satisfied, the algorithm will continue with the parallel evaluation of fitness function.During the evolutionary process of PSA to extract the relevant parameters, the difference between measured and calculated current will be gradually minimized by adjusting PV parameters. If there is N experimental data used in the estimation, the objective function can be formulated by a root-mean-square error, denoted by the objective function frmsin this work, which is(5)frms=1N∑i=1Nfi(V,I,X)2,where the vector X = [Ipv, Io, n, Rs, Rp]. The V and I are vectors representing the measured data of terminal voltage and current of the PV module respectively. In this regard, f(V, I, X) is the homogenous form of (2), which can also be written as:(6)f(V,I,X)=Ipv−Ioeq(V+IRs)nNskT−1−V+IRsRp−IHence, in parallel implementation, the PSA adopts (5) as its fitness function. In theory, parallel computation is only performed during fitness evaluations and therefore the final solution should be close to the outcome of the sequential implementation.As mentioned in Section 3.2, OpenCL is managed by the nonprofit technology consortium Khronos Group, is a heterogeneous programming framework for developing applications that execute across a range of device types manufactured by third party vendors [17]. It supports a wide range of levels of parallelism and efficiently maps to a variety of computing devices, such as multi-core central processing units, digital signal processors, field programmable gate arrays, graphics processing units, and heterogeneous accelerated processing units. Thus the OpenCL is chosen for the implementation of the PSA.A host language and a device-side language are both defined in the OpenCL. The former provides a management layer that supports efficient plumbing of complicated concurrent programs while the latter maps the heavy work load to a wide range of memory systems. In this work, the main program is written in C. The context for management of the execution of OpenCL commands is created by the applications programming interface (API). The OpenCL kernel represents the parallel evaluation. The generalization of the OpenCL interface and the low-level kernel language allows efficient mapping to a wide range of hardware [17].With the aim of studying the efficiency and accuracy of the PSA for parameter estimation, a 57mm diameter commercial (R.T.C. France) silicon solar cell is modeled by the single-diode model. The experimental data containing the I–V available from [11] is adopted in the parameter estimation of the PV cell.To further evaluate the parallel performance of the proposed PSA algorithm, the speedup of PSA on some multicore computing devices is analyzed. The relevant devices adopted in this experiment is listed in Table 2.

@&#CONCLUSIONS@&#
In this paper, the parallel swarm algorithm (PSA) has been applied to estimate the parameters of a single-diode model. The fitness evaluation functions are written in OpenCL kernel, and they are executed on the multicore central processing unit (CPU) and graphical processing units (GPUs). The feasibility and efficiency of the proposed method have been validated by parameter estimation results on a commercial PV cell. Simulation results prove the significant speedup and acceleration when utilizing both CPU and GPUs. In terms of accuracy, PSA significantly reduces the root-mean-square (RMS) error when performed on a larger swarm size. In future work, the PSA could be incorporated in tackling the Maximum Power Point Tracking (MPPT) problem. It is expected that PSA will be able to improve the estimation results in terms of speed and accuracy.