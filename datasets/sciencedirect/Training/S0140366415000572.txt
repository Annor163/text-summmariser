@&#MAIN-TITLE@&#
Achieving efficient and privacy-preserving multi-feature search for mobile sensing

@&#HIGHLIGHTS@&#
We propose a secure multi-feature search scheme with low cost on the mobile terminals.We propose an extended scheme to personalize query based on historical search information.We prove the security of the proposed scheme on privacy protection of index and trapdoor and unlinkability of trapdoor.

@&#KEYPHRASES@&#
Mobile sensing,Multi-feature,Searchable encryption,Preference weight,

@&#ABSTRACT@&#
Currently, more and more mobile terminals embed a number of sensors and generate massive data. Effective utilization to such information can enable people to get more personalized services, and also help service providers to sell their products accurately. As the information may contain privacy information of people, they are typically encrypted before transmitted to the service providers. This, however, significantly limits the usability of data due to the difficulty of searching over the encrypted data. To address the above issues, in this paper, we first leverage the secure kNN technique to propose an efficient and privacy-preserving multi-feature search scheme for mobile sensing. Furthermore, we propose an extended scheme, which can personalize query based on the historical search information and return more accurate result. Using analysis, we prove the security of the proposed scheme on privacy protection of index and trapdoor and unlinkability of trapdoor. Via extensive experiment on real-world cloud systems, we validate the performance of the proposed scheme in terms of functionalities, computation and communication overhead.

@&#INTRODUCTION@&#
Currently, more and more mobile terminals are equipped with an increasing range of sensing, computational, storage and communication resources [1]. They not only serve as mobile device for computing and communication, but also come with a rich set of embedded sensors [2,3]. More users’ activities are monitored, such as walking, driving and sitting. This is approved by people who want to obtain more preferable services. For this goal, users’ states should be aggregated and classified to provide accessible service to search entities. The different search entities can filter mobile users and sell the corresponding personalized services [4].Unfortunately, since the states of users may contain privacy information (e.g., location), malicious use toward it threatens the users’ privacy [5], thereby limits the application of sensing information. It is significantly important to find a method to use the information with privacy preservation. Considering the limited capability of the mobile terminals, the method must achieve both privacy preservation and efficiency. Searchable symmetric encryption (SSE) allows confidential search over encrypted data and can achieve more efficiency than other searchable encryption schemes. This method outsources some encrypted indexes and then generates encrypted trapdoor to match. Many SSE schemes in cloud environment have been proposed in order to achieve the same search functionalities as plaintext search. Cao et al. [6] propose a searchable encryption scheme based on secure k-nearest neighbor (kNN) computation [7], which supports coordinate matching, i.e., as many matches as possible. And Yu et al. [8] propose a multi-keyword top-k retrieval scheme with fully homomorphic encryption, which can return ranked results and achieve high security.However, searchable encryption application in mobile sensing has not been studied well. In this paper, we propose an efficient and privacy-preserving multi-feature search scheme for mobile sensing, which can not only achieve secure and efficient multi-feature search, but also return preferable result based on relevance feedback [9–11]. In our scheme, mobile terminals generate some features according to their own states, then encrypt and outsource them to a cloud server. The search entities can also create an encrypted trapdoor to query those encrypted features. Overall, we summarize our original contributions in two aspects as follows:•We propose an efficient and privacy-preserving multi-feature search scheme for mobile sensing. Security analysis shows that the proposed scheme can achieve privacy protection of index and trapdoor and unlinkability of trapdoor. Extensive experiment results demonstrate the performance of the proposed scheme in terms of functionalities, computation and communication overhead.To accurately provide personalized service, we propose an extended scheme by embedding relevance feedback. With the feedback of historical search information, we add preference factor in new query to achieve more precise search.As shown in Fig. 1, our scheme consists of four entities.•Mobile user: The mobile user represents mobile terminal which may be mobile phone and mobile computer, etc. It can receive mobile services for some corresponding service providers. Some features, represent its own state, can be used to get more personalized services. It outsources its encrypted features to re-encryption agency. To protect feature privacy, the mobile user encrypts the original features through secure encryption algorithm, and generates an index for efficient search. After that, the mobile user sends its identity and the corresponding index to the re-encryption agency.Re-encryption agency: The re-encryption agency is used to re-encrypt the indexes generated by mobile users and then outsources the re-encrypted indexes to the cloud server. With such an agency, we can avoid key sharing problem of the mobile users. The secret keys of mobile users will not be the same. A mobile user cannot identify the index generated by another mobile user. Besides, the re-encryption agency only has re-encryption keys, thus it cannot get any privacy information from the indexes.Cloud server: The cloud server is an intermediate entity which stores the identities of mobile users and the encrypted indexes, and then provides access and search services to authenticated search entities. When a search entity sends a trapdoor to the cloud server, it would return a collection of matching identities based on certain operations.Search entity: An authenticated search entity can be any mobile or fixed entity in the real world. When it wants to search the outsourced information stored in the cloud server. It will generate a search feature set. Then according to the feature set, the search entity uses corresponding secret keys to generate a trapdoor and sends it to the cloud server. Finally, it can receive a result collection of matching identities from the cloud server.In this paper, the cloud server is considered as semi-trust, i.e., it may try to attain sensitive information from the queries of search entities while performing the keyword-based search. We define the security requirements as follows:•Privacy protection of index and trapdoor: It is the most basic security feature in general searchable encryption schemes. Without the privacy protection of them, searchable encryption is out of the question. Namely, our scheme should achieve this security requirement.Unlinkability of trapdoor: We define the unlinkability of trapdoor in a harsh model, Known Background Model[12], to study more comprehensive security of our scheme. In this case, the cloud server is more powerful and can possess more statistical information from a known comparable dataset, such as the information of all indexes and trapdoors. Even some keyword information has been leaked, we should achieve that there would not produce any link between any information, and prevent more losses even if a part of the information has been leaked.Access pattern: Access pattern is the retrieval of sequential searches, consisting of the returned identity sets according to the corresponding search feature sets. Some searchable encryption proposals, e.g., [13], have been proposed to hide the access pattern using private information retrieval (PIR) technique [14]. However, our proposal is not specifically designed to protect the access pattern, because any PIR based technique must “touch” the whole dataset outsourced on the server which is inefficient in the large scale cloud system.In order to realize our searchable encryption scheme for mobile sensing, the following goals should be achieved:•Strong security: The first goal is to achieve the security requirements mentioned in Section 2.2. Without this, the searchable encryption of mobile sensing is out of the question.Multi-feature search: The second goal is to achieve multi-feature search over encrypted cloud data. Compared with general single feature search, multi-feature search can better meet requirements of search entities and achieve better search efficiency.Preference search: In general search engines, multiple features that a search entity input are treated as the same weight. However, it may not meet the requirement of the search entity. Some features may be more important than others. We introduce the preference weight of feature to our scheme, to achieve more precise search.We adopt the work of Wong et al. [7] as our foundation. Wong et al. propose a secure k-nearest neighbor (kNN) scheme which can confidentially encrypt two vectors and compute Euclidean distance of them. Firstly, the secret keys(S,M,M′)should be generated. The binary vector S is a splitting indicator to split plaintext vector into two random vectors, which can confuse the value of plaintext vector. And M andM′are two invertible matrices, which are used to encrypt the split vectors. The correctness and security of secure kNN computation scheme can be referred to [7].•U– the mobile user collection, denoted as a set of N usersU=(U1,U2,…,UN).F– the feature dictionary, denoted as a set of m featuresF=(F1,F2,…,Fm).I– the index stored in cloud server, which is built from the features of each mobile user and re-encrypted by the intermediate agency, denoted asI=(I1,I2,…,IN).K– the re-encryption key stored in the re-encryption agency, denoted asK={K1,K2,…,KN}F∼– the search feature set generated by a search entity, which is a subset ofF.TF∼– the trapdoor for feature setF∼.ID– the result collection for a query, containing identities of the most matching mobile users.In this section, based on the secure kNN computation scheme [7], we present our proposed a scheme to achieve searchable encryption for mobile sensing.•Setup Firstly, a key generation center randomly generates secret keys(1)secretkeys=(S,M1,M1′,…,MN,MN′,M,M′)where S is an m-dimensional binary vector, and the other are allm×minvertible matrices. The binary vector S is a splitting indicator to split plaintext vector into two random vectors, which can confuse the value of plaintext vector. Then it computesK={K1,K2,…,KN}, whereKj=(Mj-1M,Mj′-1M′). Finally, the key generation center distributes the secret keys as shown in Table 1.GenIndex (Pj,S,Mj,Mj′) The mobile userUjgenerates an m-dimensional binary vectorPjaccording to its corresponding features, wherePj[i]indicates whetherUjhas the i-th feature of dictionaryFi, i.e.,Pj[i]=1indicates yes andPj[i]=0indicates No. Then the vectorPjwill be encrypted by the secure kNN scheme: the mobile user uses vector S to splitPjinto two m-dimensional vectors (pa,pb), where the vector S functions as a splitting indicator. Namely, ifS[i]=0(i=1,2,…,m),pa[i]andpb[i]are both set asPj[i](Pj[i]=pa[i]=pb[i]); ifS[i]=1(i=1,2,…,m), the value ofPj[i]will be randomly split intopa[i]andpb[i](Pj[i]=pa[i]+pb[i]). Then, a semi-finished index of mobile userUjcan be calculated as(2)Ij∗=(MjTpa,Mj′Tpb)Finally,Ujsends(Ij∗‖IDUj)to the re-encryption agency, whereIDUjis the identity of the mobile userUj.ReEnc (Ij∗,Kj) After receiving all the semi-finished indexes of mobile users, the agency re-encrypts them to get the indexes and finally outsources them to the cloud server. Specifically, forUj, after receiving(Ij∗‖IDUj)the agency generates the indexIjas follows:(3)Ij=KjT·Ij∗=(Mj-1M,Mj′-1M′)T·(MjTpa,Mj′Tpb)=(MTpa,M′Tpb)Then the agency outsources(Ij‖IDUj)to the cloud server.GenTrapdoor (F∼,S,M,M′) When a search entity needs to query the encrypted indexes, firstly, it generates the search feature setF∼for searching. Then, it creates an m-dimensional binary vector Q according toF∼, whereQ[i]indicates whether the i-th feature of dictionaryFiis inF∼, i.e.,Q[i]=1indicates yes andQ[i]=0indicates No. Then the search entity can split Q into two m-dimensional vectors(qa,qb): ifS[i]=0(i=1,2,…,m), the value ofQ[i]will be randomly split intoqa[i]andqb[i]; ifS[i]=1(i=1,2,…,m),qa[i]andqb[i]are both set asQ[i]. Thus, the trapdoorTF∼can be generated as(4)TF∼=(M-1qa,M′-1qb)Query (Ij,TF∼) Before searching, the cloud server will store all the indexes previously. After receiving a trapdoor, it can calculate the matching score between the trapdoorTF∼and the indexIjas follow:(5)Score(TF∼,Ij)=IjT·TF∼=(MTpa,M′Tpb)T·(M-1qa,M′-1qb)=pa·qa+pb·qb=Pj·QThe larger score indicates the corresponding indexIjis more relevant to the search feature setF∼, hence the identity collection of mobile users with top scoresIDcan be chosen. And the corresponding result will be returned to the search entity:(6)result=Enc(ID)whereEnc()can be a symmetric encryption algorithm (e.g., AES [15]) shared between the cloud server and the search entity. Since the symmetric encryption algorithm is not our focus, we do not detail.Many searchable schemes based on the secure kNN computation adopt the previous method to query the encrypted documents [12,8], i.e., using a binary vector to create a query. However, it is very imprecise to set all the bits as only 0 and 1. For the search entity, some features may be more important than others. To achieve more precise search, the value of each dimension should not be the same. But it is usually difficult for a search entity to express its information need precisely; thus the value defined by itself may not be accurate. To overcome this impreciseness, the technique of relevance feedback is used [9–11].It is the process of automatically adjusting an existing query using information feedback by the search entity about the preference of previously retrieved documents.Do not change any phase of our previous scheme, we use relevance feedback technique to optimize the query vector by replacing each dimension with preference weight of feature. One method is Rocchio[16]:(7)Qopt=Q+β1NR∑j∈URPj-γ1NN∑j∈UNPjwhereNRis the number of relevant mobile usersURin the returned result set andNNis the number of non-relevant onesUN;Pjis feature vector of mobile userUj;βand γ are suitable constants [9,10]. In Rocchio method, the search entity can define its preference weights according to the feature vectors retrieved in advance. The optimal queryQoptcan be created by putting more weights on the relevant features and less weights on the non-relevant features.Therefore, to define the preference weight using the historical information, the cloud server should not only send the identities of the most matching mobile users, but also return the feature vectors of them, i.e., the query result should be(8)result=Enc(ID)||⋃IDUj∈IDIjAfter receiving the result set, the search entity can decryptIjusing(M,M′)and obtain the feature vectors of the mobile users. Further, the search entity can use the feature vectors to personalize its query vector generated later.In this section, we will analysis the security properties of our proposed scheme. In particular, following the security requirements discussed earlier, our analysis will focus on how the proposed scheme can achieve privacy protection of index and query, and unlinkability of trapdoor. Because our proposal does not focus on protecting the access pattern, we do not analysis it in detail. More depth description can refer to [13].In our scheme, both the index and the trapdoor are m-dimensional vectors, each dimension of index indicates whether the mobile user has a feature and each dimension of the trapdoor represents the preference weight of a search feature. Both the vectors are encrypted by the secure kNN computation scheme, and its security can refer to [7]. The cloud server can only know the inner product of the two vectors, but it cannot get any more information. Each dimension of vector has many possible values, thus the inner product appears a random number to the cloud server.In general kNN search schemes, each user shares a same secret keyK=(S,M1,M2). However, it causes a security issue, i.e., key sharing. The trapdoor generated by a user can be decrypted by other users, which will disclose the privacy information of user. Therefore, we use an re-encryption agency to solve this problem in our mobile sensing scheme. We consider the security of the semi-finished indexIj∗generated by the mobile user. For each mobile userUj, it just has the part of the secret keys, i.e.,(S,Mj,Mj′). And the invertible matrices of each user(Mj,Mj′)are different. Therefore, the semi-finished index ofUjcannot be decrypted by the other mobile users. After being generated, the semi-finished indexIj∗is sent to the agency and re-encrypted byKj=(Mj-1M,Mj′-1M′). Without the secret keys(Mj,Mj′)or(M,M′), the agency cannot get any information of the semi-finished index. Hence, our scheme can achieve privacy protection of index and trapdoor.Although the cloud server cannot directly recover the features, some stronger security should be studied. We consider the linkability of trapdoor which may also cause disclose of privacy information. Under Known Background Model, we further consider (1) whether two trapdoors search the same feature; and (2) whether two features are simultaneously searched in a trapdoor.In this model, the cloud server can possess the statistical information from a known comparable dataset which bears the similar nature to the targeting dataset.For the first problem, our scheme adopts the relevance feedback technique to re-process the preference weight vector. The trapdoor would be affected by the previous retrieval features of mobile users. Due to the randomness of the retrieval result, even if two search feature sets are the same, the trapdoors will not be the same. Further, we consider a strong assumption that the search feature sets and the retrieval result are all the same. The trapdoors are also different due to the non-deterministic of secure kNN computation, i.e., Q is randomly split into two vectors(qa,qb)according to the splitting indicator S.And for the second problem, the preference weight vector is split into two random vectors which then are multiplied by two matricesM,M′. Even if the preference weight of a feature is leaked, it is impossible to calculate the weight of another feature. The security is proven in [7]. Therefore, it is also impossible to deduce whether two features are simultaneously searched in a trapdoor.Hence, our scheme can achieve the unlinkability of trapdoor.In summary, we present the comparison of security level in Table 2. It can be seen that all schemes can achieve privacy protection of index and trapdoor. However, [17,18] use OPE [19] to encrypt their indexes, they cannot achieve the unlinkability of trapdoor very well because of the similarity relevance mentioned in [8].

@&#CONCLUSIONS@&#
