@&#MAIN-TITLE@&#
Real-time magnetic dipole detection with single particle optimization

@&#HIGHLIGHTS@&#
We propose a novel single particle algorithm to detect in real-time a moving dipole.We validate the approach by means of an experimental setup consisting of 3 sensors.A custom GUI shows in real-time the estimated position and orientation of the dipole.The proposed approach is faster and more robust than state-of-the-art methods.

@&#KEYPHRASES@&#
Magnetic dipole detection,Single particle optimization,Online optimization,Real-time optimization,Computational intelligence,

@&#ABSTRACT@&#
In recent years, the use of magnetic field measurements has become relevant in several applications ranging from non-invasive structural fault detection to tracking of micro-capsules within living organisms. Magnetic measurements are, however, affected by a high noise due to a number of causes, such as interference from external objects and the Earth magnetic field. Furthermore, in many situations the magnetic fields under analysis are time-variant, for example because generated by moving objects, power lines, antennas, etc. For these reasons, a general approach for accurate real-time magnetic dipole detection is unfeasible, but specific techniques should be devised. In this paper we explore the possibility of using multiple 3-axis magnetic field sensors to estimate the position and orientation of a magnetic dipole moving within the detection area of the sensors. We propose a real-time Computational Intelligence approach, based on an innovative single particle optimization algorithm, for solving, with an average period of 2.5ms, the inverse problem of magnetic dipole detection. Finally, we validate the proposed approach by means of an experimental setup consisting of 3 sensors and a custom graphical application showing in real-time the estimated position and orientation of the magnetic dipole. Experimental results show that the proposed approach is superior, in terms of detection error and computational time, to several state-of-the-art real-parameter optimization algorithms.

@&#INTRODUCTION@&#
For many industrial applications it is desirable to obtain an accurate characterization of a ferromagnetic object (or a set of objects), by measuring the magnetic fields induced by it. Magnetic field detection can be used, for example, for identifying vehicles based on their magnetic profile, or for detecting defects, e.g. inner cracks or micro-holes, in metallic structures (rails, steel beams, etc.). Broadly speaking, all those applications which rely on the analysis of magnetic field measurements require that the magnetic dipoles (or in general, magnetic domains) present in the structure under study are precisely localized. In addition to that, in some cases it might be needed to detect a time-variant magnetic field in real-time, e.g. when one wants to track a magnetic dipole whose position and orientation change with time. A paradigmatic example of a real-time application of this kind would be a magnetic-based motion tracking system, where one or more dipoles are attached to a moving object and their position/orientation must be estimated online. Such a system could be used, for instance, in video gaming, motion capture, 3D painting, or interactive path-planning of industrial robots.Despite the broad potential applications, the problem of detecting and interpreting magnetic fields in real-time still represents an open challenge. The reasons are manifold, namely: (1) the high noise which usually affects magnetic measurements; (2) the effect of the static earth magnetic field; (3) the interference due to the magnetic fields generated by surrounding electrical currents and objects, such as computers and other electronic devices; (4) the real-time constraints imposed by the sensor data acquisition frequency and, in case of moving magnetic dipoles, their speed.In recent years, several methods have been developed for localizing magnetic dipoles, and have been applied to various contexts ranging from engineering to biomedicine. These methods are based, in general, on the solution of the inverse magnetic problem by means of different optimization strategies, such as Computational Intelligence algorithms or classic local search methods. In [1], an array of 3-axis magnetic sensors is used to track a magnet, modeled as a single dipole, inside a capsule endoscope for the interactive diagnosis of the gastrointestinal tract; in this case, the localization is solved by means of a combination of a linear localization algorithm [2] and the Levenberg–Marquart method [3], where the first provides a valid initial guess and the latter tries to improve upon it. In [4], the same authors extend this approach for detecting position and orientation of a rectangular magnet in a capsule endoscope by means of basic genetic algorithm (GA) [5] and particle swarm optimization (PSO) [6]. In both studies it was obtained, in simulation, a high localization/orientation accuracy and computational time in the order of tenths of a second – up to 2s – depending on the desired accuracy. Paper [7] proposes a similar approach for tracking, by means of an adhesive magnet, the tongue movements within the 3-D oral space; in this case PSO was compared with three local search methods, namely the DIRECT [8], Powell [9], and Nelder–Mead [10] algorithms, with the Powell algorithm resulting in the highest accuracy and an average processing time of 43.9ms/sample.Some alternative approaches, which do not make use of an explicit optimization algorithm, have also been proposed in the literature. For example, in [11], a real-time localization technique is described, based on the Euler homogeneity equation. In [12], a Hopfield neural network [13] was applied to the estimation of magnetic moments, while a self-adaptive evolutionary algorithm was used for training the model by minimizing the least-squares error between the observations and the data produced by the neural network. Also in these cases, the proposed approaches display a high accuracy, a good robustness, and a relatively simple implementation.Most of the methods from the literature, however, either make problem-specific assumptions or they are not suitable for fast real-time tracking of moving magnetic objects (i.e. in the order of few milliseconds per sample), because for instance they require an offline learning phase or an offline data processing. To fill this gap, in this paper we present a novel optimization-based method for fast detection of position and orientation of a single magnetic moment in space. The proposed optimization algorithm, named SPORE, is characterized by a single particle which explores the parameter space according to an extremely simple self-adapting search logic. Thanks to its simplicity, SPORE is way faster than other methods previously proposed in the literature, being able to obtain sufficiently good results in a remarkably short computational time (on average, 2ms, that is from two to three orders of magnitude smaller than other methods in the literature). Additionally, since our method employs a single particle at every step of the optimization process, its memory footprint is dramatically lower than, for example, population-based algorithms such as GA or PSO (as used in [4]), or other modern algorithmic structures employing covariance matrices or solution archives. Thus our method not only is suitable for fast real-time magnetic moment detection, but also allows for possible implementations on embedded systems endowed with limited CPU power and memory. This might be, for example, the case of portable biomedical detectors or portable magnetic scanners that could be used in structural non-invasive inspection.To test the proposed approach, we built an experimental setup composed of three off-the-shelf 3-axis magnetic field sensors, and designed a Java Graphical User Interface (GUI) in which the position and orientation of the magnetic moment is displayed, in a 3-D environment, on the screen of a computer connected to the sensors via USB. An optimization process is performed in background every time a new set of sensor data (3 samples X–Y–Z, one per sensor) is available for fitting, and the GUI is updated in real-time while the magnetic moment moves around the sensors’ detectable area. To asses the superiority of our method in terms of computational time and fitting error, we compared it with a selection of state-of-the-art real-parameter optimization algorithms, including recent variants of PSO and differential evolution (DE), as well as some modern single solution optimization algorithms and classic local search methods.The remainder of this paper is organized as follows. The next section describes the physical model of a single dipole moment and how its inverse formulation can be interpreted as a real-parameter optimization problem. Section ‘Experimental setup’ describes the experimental setup used for tests, while in Section ‘Single Particle Optimization with Restarted Exploration’ we describe our new single particle optimization algorithm. Section ‘Experimental Results’ presents the experimental results obtained with SPORE in comparison with other real-parameter optimization algorithms. Finally, Section ‘Conclusions and future works’ gives the conclusion of this study and suggests a few possible industrial applications that might be investigated in the future.In order to find the location, orientation and spatial structure of magnetic objects simply by measuring the magnetic fields they induce, one needs to be able to find the solution to an inverse problem. Although the magnetic field around a magnetic object can be calculated relatively easily, doing the inverse operation (i.e. finding its structure, position and orientation based on the magnetic field measurements) is generally more difficult, as it requires the use of an efficient fitting algorithm and often also a list of assumptions to limit the search space. Similarly to what was done for instance in [1] and [2], in this section we first formulate the direct expression of the external magnetic field induced by a single magnetic dipole moment, and then we define its inverse problem as an optimization problem.The external magnetic field H(r) induced by a single magnetic moment m is given by [14]:(1)H(r)=14πr33r(m·r)r2−mwhere r denotes the vector from the magnetic moment to the point in space where the field is calculated. Because the magnitude of the magnetic moment is usually fixed and for symmetry reasons, we choose for a representation of the moment orientation in spherical coordinates.Fig. 1shows the general convention we use for the coordinate system of m. The angle θ represents the angle between the Z-axis and the XY-plane, whereas ϕ denotes the angle within the XY-plane. Hence, the orientation of m in Cartesian coordinates can be rewritten as:(2)m(x,y,z)=Msin(θ)cos(ϕ)Msin(θ)sin(ϕ)Mcos(θ)where M=||m|| is constant for a single dipole moment. The position of the magnetic moment is denoted by the vector rm(x, y, z). The magnetic field present at the position of the sensors is then given by Eq. (1) for r=rs−rmwhere rs(x, y, z) is the position of the magnetic field sensor.When the sensor positions rs(x, y, z) are known precisely, and combining this information with the magnetic fields measured at the sensor positions, the inverse problem associated to the direct problem in Eq. (1) can be solved by using a fitting method. Indicating with p the parameter vector [rm(x, y, z), M, θ, ϕ] describing the unknown magnetic dipole, the magnetic data fitting process (i.e. the magnetic moment detection problem) can be formulated as follows:(3)findp*s.t.f(p*)=minp∈Df(p)where D is the search space and * indicates the optimal solution in D. With reference to Eq. (1), the objective function f(·) (in the following, simply referred to as “fitness”11We should remark that this terminology is inherited from classic evolutionary and swarm intelligence algorithms, where each solution of a problem is seen as an “individual” and its performance with respect to the optimization problem is seen as its “fitness”.) is a measure of the fitting error, that can be expressed for instance in the form of sum of squared errors:(4)f(p)=∑i=1Nsensors∑j=13[Hi,j−H˜j(p,rs(xi,yi,zi))]2where i indicates the sensor index and j the Cartesian component index (j=1, 2, 3 for X, Y and Z respectively); Hi,jrepresents the jth Cartesian component of the magnetic field measured at the ith sensor;H˜j(p,rs(xi,yi,zi))is the jth Cartesian component of the (estimated) magnetic field generated by a magnetic moment characterized by the parameters p=[rm(x, y, z), M, θ, ϕ] which would be detected at the sensor position rs(xi, yi, zi). As said these positions rs(xi, yi, zi), i=1… Nsensors, must be known a priori before starting the optimization process and are considered constant.It can be easily seen that lower values of f(·) indicate that the magnetic moment is detected correctly. Theoretically, a perfect detection would produce a fitting error equal to zero; in practice, considering the noise on the sensor data and some numerical errors due to the sensor calibration process (see below), it is impossible to obtain such a value but rather one should minimize the error to achieve a satisfactory fitting. As a final remark, we should note that with three magnetic sensors the inverse problem defined in Eq. (3) has a unique solution, since with 9 measurements (X–Y–Z per each 3-axis sensor) and 6 unknown parameters [rm(x, y, z), M, θ, ϕ], this problem is equivalent to solving an over-determined non-linear system of 9 equations in 6 variables. This is also true for any number of sensors larger than three. On the other hand, with only one sensor we would have an infinite number of solutions (6 unknowns, 3 measurements). With two sensors, we would have a limit situation of a non-linear system with 6 unknowns and 6 measurements, which might not be univocally solvable due to the spacial symmetry of some magnetic field configurations. We should point out that this analysis is valid only if we are interested in determining position, orientation and magnetic moment M. With a lower number of unknowns, the above analysis differs.In order to test and verify the idea of the single dipole localization, an experimental demonstrator setup has been realized. The setup consists of three 3-axis magnetic RM3000 field sensors [15]. These sensors provide a continuous flow of measures of the magnetic field strength in the X, Y and Z direction. The sensor count-rate was set to 500 counts in standard mode, providing a gain of about 100 counts per μT, a sample frequency (per axis) of about 200Hz, and a minimum noise level of 10nT. Each sensor is mounted on a cased custom PCB developed in-house, and connected via an FTDI cable to an ATmega8U2 Breakout board which acts as FTDI/USB bridge. The three breakout boards are connected to a USB mini-hub which sends the sensor data to the PC running the real-time demonstrator described in Section ‘Real-time demonstrator’.The top-view of the experimental setup is shown in Fig. 2. The three sensors are mounted on an aluminum plate and the sensor positions are measured with an accuracy of about 5mm. We should remark that each sensor actually contains 3 independent sensing elements, one for each axis, which are mounted at different positions on the sensor PCB. For the optimization procedure, however, we assume only a single position rs(xi, yi, zi), see Eq. (4), located on the center of symmetry of the PCB case. This introduces a small error in the localization of the magnetic moment. Another source of error is the custom PCB board/FTDI interface, which due to the absence of a power ripple filter introduces an additional background noise in the order of few tens of nT. Commercial high-quality boards should be used in industrial contexts to reduce this noise component.In order to use the sensor data for fitting, it is important to ensure that those data are calibrated, i.e. their order of magnitude and orientation are consistent with the real magnetic field induced by the dipole. In our experiments, a careful calibration procedure has been carried out, before installing the sensors on the aluminum plate, using the approach described by Camps et al. [16]. The calibration procedure for a 3-axis sensor is based on the assumption that its output can be written as:(5)Vx(t)Vy(t)Vz(t)=αxsxysxzsxyαysyzsxzsyzαzhx(t)hy(t)hz(t)+βxβyβzwhere V(t) are the raw sensor measures, α are the sensor gains, s are the non-orthogonality factors (which take into account the misalignment between the coordinate reference system of the sensors and the absolute reference system of the real magnetic field), h(t) are the real magnetic field and β are the sensor offsets. To calibrate each sensor, we collected the sensor readings while slowly rotating the sensor (in every possible direction) in the Earth magnetic field, i.e. in absence of any other magnetic moment dipole. In total, we collected 950 different sensor values for each sensor. By assuming:(6)||H||=hx(t)2+hy(t)2+hz(t)2=Kwhere K is the constant, known, Earth magnetic field (to compute its value at our location, 53°0′ N 6°33′ E, we used the International Geomagnetic Reference Field 2010 model, see [17]) one can fit the recorded data with Eq. (5) to find the unknown parameters α, s and β. As in [16], we used the Levenberg–Marquardt algorithm to minimize a quadratic fitting error function. For each sensor, we performed this procedure one-time-only and then saved the calibration parameters into a configuration file. Such file is read before starting the online optimization process (see below), so that the raw measures V(t) coming from the sensors are converted into the corresponding calibrated measures h(t) by applying Eq. (5).Algorithm 1Online optimization process// initializationinitialize cyclescalread the calibration parameters α, s and β from the configuration fileopen and configure sensor USB communication// measure static fieldfori=1→cyclescaldoHSraw← readFromSensors()end forcompute average static fieldH¯SrawH¯Scal← calibrateH¯Srawaccording to Eq. (5)// online optimizationinitialize ɛ, threshold, Dlarge, Dsmall, Tlarge, Tsmallwhile user does not stop doHraw← readFromSensors()Hcal← calibrate Hrawaccording to Eq. (5)H ←Hcal−H¯Scalif p*≠NULLthenalgorithm.initialize(Dsmall, Tsmall, p*)elsealgorithm.initialize(Dlarge, Tlarge)end if〈p*, f(p*〉 = algorithm.run(H, rs(xi, yi, zi), i=1→Nsensors)iff(p*)<ɛthenifM>thresholdthenupdate GUI (update dipole position/orientation) and log resultselseupdate GUI (remove dipole)p*=NULLend ifend ifend whileAn overview of the online optimization process is given in Algorithm 1. At the beginning of the procedure, the calibration parameters α, s and β are read from the configuration file (as described in the previous section) and the USB channel is established and configured to obtain the data from the sensors. Then, the static Earth magnetic field (i.e. the field measured in absence of any magnetic moment)HSrawis measured and averaged over a fixed number of cycles cyclescal. Here we indicate with readFromSensors() the routine that reads the raw data coming from the sensors. The average static fieldH¯Srawis then calibrated according to Eq. (5) to obtainH¯Scal, compensated for sensor gains/offsets and non-orthogonality of the reference systems. In particular, to obtain the calibrated data, the linear system Eq. (5) must be solved, with h(t) unknown and V(t) equal to the raw sensor data.At the end of the initialization stage, the online process is started. This process is continued until the user stops it from the graphical interface (see next subsection). At each step of the loop, the raw sensor dataHSraware collected and calibrated as described previously, to obtainHScal. In addition to that, the average static (calibrated) Earth fieldH¯Scalis subtracted from the calibrated dataHScalto obtain the magnetic field H that has to be fitted. For the sake of clarity, we should note that all the H variables introduced so far are implemented as matrices inℝNsensors×3, where Nsensorsis the number of sensors (in our case, 3).Once H is computed, an optimization algorithm (either the proposed SPORE or one of the comparison methods, see Sections ‘Single particle optimization with restarted exploration’ and ‘Experimental results’) is executed in the attempt of solving the optimization problem in Eq. (3), i.e. fitting H and detect Cartesian position, magnitude and orientation of the unknown magnetic moment (p*). With reference to Algorithm 1, the functions algorithm.initialize() and algorithm.run()22We use here an object-oriented notation to highlight the fact that these methods refer to each single optimization algorithm.correspond, respectively, to the parameter initialization and the execution of the optimization algorithm.If the fitting error f(p*) is smaller than a given threshold ɛ and the detected moment is sufficiently large (i.e., bigger than a given threshold), the fitting process is considered successful and its output is provided (either graphically or on a log file) to the user. It should be noted that, in order to provide a plausible initial guess for each step of the algorithm, at the beginning of each iteration the algorithm is initialized with the best solution p* found in the previous step. In case of population-based optimization algorithms, this is equivalent to the injection of p* in the initial randomly sampled population; in case of single solution algorithms, this means that the initial solution is just p*. If the detected moment is smaller than the threshold, however, the previous p* is nullified, since this means that no magnetic moment is present in the detectable area and that the previous solution shouldn’t be retained anymore. When p* is null, the algorithm explores the whole search space Dlarge(spanning over a large detectable area above the aluminum plate) using a larger computational budget, Tlarge; otherwise, the search space is shrunk over a smaller portion of the search space, Dsmall, centered around the previous best solution p*. In this case the algorithm is also allotted a shorter budget, Tsmall, under the assumption that a shorter number of fitness evaluations is needed to converge towards the optimum when a “good” initial guess is provided. This mechanism is especially useful if the magnetic moment moves relatively smoothly into the search space, so that only incremental variations of its position and orientation must be detected. On the other hand, when no previous initial solution p* is available, the algorithm must be allowed to search the whole detectable area, so to estimate any new dipole position/orientation within it.In order to display the estimated position and orientation of the dipole moment, we developed a multi-platform Java SWT application based on the OpenGL library JOGL [18,19]. The USB connection is handled using the JSSC library [20], while JAMA [21] is used for solving the calibration linear system in Eq. (5). The software runs, in background, the online optimization process shown in Algorithm 1 and updates, in real-time, a 3-D graphical environment showing the estimated dipole moment. Two update modes are available, namely track, which tracks the estimated position/orientation trajectory, and on-the-fly, which only plots the estimated position and orientation obtained from the last sensor samples. Through the interface, the user can control the optimization process (pausing or stopping it), set the update mode, and enable the visualization of the estimated position/orientation of the dipole and the sensor positions. Fig. 3shows a freehand trajectory of a magnetic dipole moment where both the position and orientation of the moment are determined using the procedure illustrated in Algorithm 1 with the single particle optimization algorithm described in the following section.In the last two decades, many researchers have put a great effort in designing robust and reliable optimization algorithms capable of guaranteeing good results on broad sets of benchmark functions and real-world problems. Nowadays, several state-of-the-art optimization methods can be rightfully considered general-purpose optimizers. Examples in the area of Evolutionary Computation and Swarm Intelligence are represented by CMA-ES [22] and various modifications of it [23–26], as well as numerous variants of Differential Evolution [27–35], Particle Swarm Optimization [36–44], and Memetic Computing approaches [45–52].However, despite the availability of these powerful optimization methods, there are still some very specific real-world optimization problems (see e.g. the robotic and sensor applications presented in [53–60]) which are difficult to tackle by means of general-purpose optimizers. For these cases, it is still reasonable to devise ad hoc optimization methods, or adapt existent algorithms to the problem, for instance embedding domain-specific knowledge into the algorithmic operators.In our case study, the real-time constraints and the presence of noise on the sensor measurements pose some technical challenges which make the optimization process particularly hard. In order to perform real-time detection of a magnetic dipole, the optimization algorithm should have the following features: (a) low computational overhead, i.e. it should perform a minimal number of mathematical operations; (b) strong exploitation, i.e. it should be able to obtain good results in a very limited number of fitness evaluations; (c) ability to escape local optima, since the fitness landscape corresponding to Eq. (4) is characterized by multiple “peaks”, mainly due to the noise and to the non-linear sensitivity of sensors.Having in mind these goals, we propose here a novel, fast single particle optimization named SPORE (Single Particle Optimization with Restarted Exploration). In a nutshell, SPORE consists of a single particle that is repeatedly perturbed, variable-wise, as long as the perturbations produce a fitness improvement. This mechanism endows the algorithm with a strong exploitation pressure. If the perturbations are unsuccessful, a simple restart scheme is used to partially re-sample the particle, inheriting a variable-size portion of the current best solution. The latter component gives the algorithm the ability of escaping local optima, still preserving part of the best solution found so far. This process goes on until a stop condition is met.Let us analyze more in detail the working principles of SPORE. The pseudo-code of the algorithm is shown in Algorithm 2, where it can be seen that the method consists of an initialization phase, followed by an optimization loop. Each cycle of the loop consists in turn of two steps, namely: (1) a variable-wise perturbations loop and (2) a restart with partial inheritance.During the initialization, a parameter δiis initialized for each variable to the width of the search space along that dimension (ubi−lbi, where ubiand lbiare, respectively, the upper and lower bound of the search space along the ith direction). Together with that, for each variable a maximum number of perturbation iterations is initialized,kmaxi=log2δi/ξ, where ξ is an algorithm parameter which controls the minimum perturbation range.After the initialization, the optimization loop starts. At the beginning of the first step of the loop, the current best fitness function is saved. Then, each ith variable is perturbed repeatedly, starting with a perturbation step δ=δi/2. More specifically, for each ith variable, and for a maximum number of perturbation cycles (kmaxi), the following operations are performed: first, a perturbation of radius δ is attempted in one direction; if this move leads to an improvement, the radius δ is halved and another perturbation in the same direction is attempted, otherwise the ith variable is reset to its previous value and the opposite direction −δ is used in the next perturbation cycle. When for the current δ both directions have been tried and no further improvements are possible, δ is halved and a new perturbation cycle begins. This way incrementally smaller perturbations are attempted, until the maximum number of perturbation cycleskmaxiis reached. In order to introduce the possibility of interrupting this exploitative search when the best solution is not improved, at the end of each cycle the perturbation loop is stopped with probability(k/kmaxi)2, where k is the index of the cycle. In this way, the perturbation loop has a very low chance of being interrupted during the first cycles, while this chance increases with the number of unsuccessful perturbation cycles.Whenever the first step does not produce any fitness improvement, the second step, i.e. restart with partial inheritance, is activated. This mechanism is introduced in the algorithmic structure in order to prevent the algorithm from being trapped into local optima, and balance the exploitation pressure of the first step. As shown in Algorithm 3, a logics similar to the binomial crossover used in differential evolution [61] is adopted. At restart activation, a dynamically adapting crossover rate CR is computed based on the current and maximum number of fitness evaluations, respectively nevaland Neval. The crossover rate is updated in such a way that it takes its maximum value at the beginning of the optimization, and decreases during the next stages. Once CR has been computed, for each ith variable of the current best particle a uniform random number r in [0, 1] is generated and compared with it. If r<CR, the ith variable is re-sampled within its bounds [lbi, ubi]; otherwise it will take the value of the corresponding variable in the current best solution. The modified particle x is then evaluated, and, in case of fitness improvement, it is copied into the current best particle.The main idea behind SPORE is essentially that, in order to address the optimization problem at hand, an extremely exploitative component is needed to refine the search within the current basin of attraction. Similar to the Hooke–Jeeves pattern search [62], the variable-wise perturbations loop tries to improve upon the current solution applying incrementally smaller perturbations, in both directions, on each variable. A randomized stop criterion is introduced within this component so to allow a higher chance of escaping local optima. The rationale for the randomized stop is that the algorithm should perform a larger number of perturbation cycles when exploiting a very promising region of the search space (thus obtaining, with a high probability, incremental improvements), and a small number of perturbations when it is stuck into a local optimum, where it fails at finding further improvements. Therefore, introducing a randomized number of perturbations (and a stop probability which quadratically increases with it), we endow the algorithm with a very simple form of adaptation, and, therefore, with a greater flexibility. It should be noted that the quadratic function guarantees a smoother probability increase than a linear function (because(k/kmaxi)2≤(k/kmaxi)∀k∈[1,kmaxi]).On top of that, a simple restart mechanism is used to re-sample the current particle whenever the exploitative component fails at improving upon it. This re-sampling mechanism guarantees a better trade-off between exploration and exploitation in two ways: on one hand, it retains parts of the current particle (rather than sampling a solution ex novo), thus preserving part of the previous achievements; on the other, the adaptive crossover rate adjusts the amount of variables which are inherited from the best solution, so that at the beginning of the optimization only a small number of variables are inherited (stronger exploration pressure), while subsequently larger parts of the best solution are retained (thus gradually favoring the exploitation pressure).Algorithm 2SPORE pseudo-code// initializationinitialize initial particle xinitialize best best=xfx=fbest=f(x)initialize ξfori=1→ndoinitialize δi=(ubi−lbi)kmaxi=log2δi/ξend forinitialize direction flag dir=0// optimization loopwhile stop criterion is not met do// step 1: variable-wise perturbations loopsave current best fitness finit=fbestfori=1→ndoupdate perturbation δ=δi/2stop=FALSEfork=1→kmaxiand notstopdosave old position xbak=xisave old fitness fbak=fxupdate position xi=xi+δupdate direction flag dir=dir+1calculate fitness fx=f(x)iffbak<fxthenchange perturbation direction δ=−δreset old position xi=xbakreset old fitness fx=fbakelsehalve perturbation δ=δ/2reset direction flag dir=0k=k+1end if// if both directions have been triedifdir==2 thenhalve perturbation δ=δ/2reset direction flag dir=0k=k+1end ififfx<fbestthenbest=xfbest=fxelseifrand(0,1)<k/kmaxi2thenstop=TRUEend ifend ifend forend for// step 2: restart with partial inheritanceif (finit−fbest)==0 thenperform restart as in Algorithm 3end ifend whileAlgorithm 3Restart with partial inheritance pseudo-codeadaptive crossover rate CR=[(Neval−neval)/Neval]2fori=1→ndoifrand(0, 1)<CRthenxi=rand(lbi, ubi)elsexi=bestiend ifend forcalculate fitness fx=f(x)iffx<fbestthenbest=xfbest=fxend if

@&#CONCLUSIONS@&#
