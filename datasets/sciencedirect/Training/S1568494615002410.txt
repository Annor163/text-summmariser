@&#MAIN-TITLE@&#
A biased random-key genetic algorithm for wireless backhaul network design

@&#HIGHLIGHTS@&#
We propose a novel network design problem for wireless backhaul networks.Its objective function is computed using the value of the maximum flow and network costs.We propose a BRKGA and a mixed integer linear programming model (MIP) to solve it.We assess the great performance of BRKGA over 30 large real-world instances.

@&#KEYPHRASES@&#
Wireless backhaul network design,Small cells,Genetic algorithm,Mixed integer programming model,

@&#ABSTRACT@&#
This paper describes a biased random-key genetic algorithm for a real-world wireless backhaul network design problem. This is a novel problem, closely related to variants of the Steiner tree problem and the facility location problem. Given a parameter h, we want to build a forest where each tree has at most h hops from the demand nodes, where traffic originates, to the root nodes where each tree is rooted. Candidate Steiner nodes do not have any demand but represent locations where we can install cellsites to cover the traffic and equipment to backhaul the traffic to the cellular core network. Each Steiner node can cover demand nodes within a given distance, subject to a capacity constraint. The aggregate set of constraints may make it impossible to cover or backhaul all demands. A revenue function computes the revenue associated with the total amount of traffic covered and backhauled to the root nodes. The objective of the problem is to build a forest that maximizes the difference between the total revenue and the cost associated with the installed equipment. Although we will have a forest when we consider only the backhaul links and root nodes, the addition of demand vertices can induce undirected cycles, resulting in a directed acyclic graph. We consider instances of this problem with several additional constraints that are motivated by the requirements of real-world telecommunication networks.

@&#INTRODUCTION@&#
There has been a surge in the popularity of mobile devices (smart-phones and tablets). For example, in the United States, mobile devices now account for more than 50% of Internet usage [1]. This, coupled with the popularity of high bandwidth services such as video, has pushed mobile data usage. Cisco VNI Global IP Traffic Forecast [2] predicts 57% annual growth rate for mobile data, resulting in an 10-fold increase from 2014 to 2019. Service providers need to keep up with this growth in mobile data usage by providing better coverage and higher rates to their customers.The associated network design problem needs to decide on the optimal concentration of cellular and Wi-Fi equipment to provide good service to users. Note that one can use Wi-Fi and LTE seamlessly for majority of the traffic without having to break and restart the session [3]. We also need to find the right backhaul strategy to route this traffic to the core network. A naive solution may be to run fiber to all sites, but it may be prohibitively expensive. Instead, we judiciously use the existing fiber infra-structure to pick the right backhaul. First of all, for installing Wi-Fi or cellular equipment, we may prefer a site that already has fiber. For other sites, we may be able to use a wireless backhaul to aggregate their traffic to a fibered site. Finally there are sites where running new fiber may be the best option.In this paper, we propose the wireless backhaul network design problem (WBNDP) with practical constraints, and present a model to deal with real networks. The motivation of the proposed problem is to model wireless backhaul networks that operate over technologies such as Wi-Fi, LTE (4G technology), and HSPA+ (3G technology). In such networks, we must collect data traffic in a given geographic region and route it to the core network. Their structure is determined by equipment and service quality constraints. Usually, one wants to build a tree spanning high-capacity nodes over a sparse graph with capacity constraints. Although the WBNDP resembles variants of the Steiner tree and facility location problems, its revenue and cost structures distinguish it from these two problems.To solve the WBNDP, we propose a biased random-key genetic algorithm (BRKGA) with a sophisticated decoding procedure. The algorithm has several phases, such as equipment deployment, construction of routing trees, flow computation, and pruning of unused equipment. The choice of BRKGA is grounded on its recent success in solving large combinatorial optimization problems [4]. In order to evaluate the quality of results obtained by the BRKGA, we also formulate and solve a mixed integer linear programming model for computing the optimal solution.The structure of the paper is as follows. Section 2 reviews the related literature. Section 3 presents the WBNDP in detail and Section 4, a formal definition as well as a mixed integer linear programming model are presented. Section 5 describes a biased random-key genetic algorithm to solve the WBNDP and Section 6 discusses the maximum flow problem that arises in WBNDP. Section 7 describes some instances derived from real-world problems and pre- and post-processing phases. Section 8 presents experimental results. Concluding remarks are made in Section 9.The wireless backhaul network design problem (WBNDP) is closely related to variants of the Steiner tree and the facility location problems. Steiner tree problems have been widely studied and among their many applications, network design may be the most expressive. Given a graph with a set of terminal nodes, a set of intermediate nodes called Steiner nodes, and edge costs, the Steiner Tree Problem (STP) consists in creating a minimum cost tree connecting all terminal nodes. The general version isNP-hard (Garey and Johnson [5]) and a survey of the STP is presented in Voß [6].A variant with many applications in industry is the Prize-Collecting Steiner Tree Problem (PCSP). In this problem, each vertex has a penalty value and each edge has a cost. The objective is to build a tree minimizing the sum of the costs of used edges plus the sum of the penalties of the vertices not spanned by the tree. This is a well-studied problem originated in Goemans and Williamson [7,8]. Goemans and Williamson [8] presented a 2-approximation algorithm for the PCSP for which practical results were discussed in Johnson et al. [9] and Canuto et al. [10]. Lucena and Resende [11] presented lower bounds using linear programming and cutting planes and their results were improved by Ljubić et al. [12]. Klau et al. [13] proposed a hybrid heuristic where the final population from a memetic algorithm is used to build reduced instances to be solved by an exact algorithm. In da Cunha et al. [14] a Lagrangian non-delayed relax-and-cut algorithm is proposed to generate primal and dual bounds for the problem.The first problem to deal with limited number of hops was proposed by Gouveia [15] and is called Hop-Constrained Minimum Spanning Tree Problem (HMSTP). In this problem, we want to obtain a minimum spanning tree such that the path between the root node and a leaf node has no more than H hops (edges). In Gouveia [15], a formulation based on subcycle elimination inequalities was presented as well as several lifting procedures and bounds based on Lagrangian relaxation. This approach was refined in several papers described in Dahl et al. [16]. Recently, Gouveia et al. [17] presented several local search neighborhoods resulting in good solutions. In Gouveia et al. [18], HMSTP was presented as a directed Steiner tree model over layered graphs. Several cutting planes from other Steiner problems were applied. A branch-and-cut algorithm was also proposed and it was able to obtain the best results so far described in the literature. Furthermore, Gouveia et al. [18] reduced the Diameter-Constrained Minimum Spanning Tree Problem (DMSTP) to a Steiner tree problem using the same technique. In the DMSTP, the hop constraint is applied to a path between any pair of vertices in the tree.Another related problem is the Steiner Tree Problem with Revenues, Budget and Hop Constraints (STPRBH). In this problem, the objective is to build a tree that maximizes the collected profit respecting an upper bound on network costs and maximum number of hops from the root node to other any node in the network. Differing from the HMSTP, in the STPRBH it is not mandatory to include all vertices and one has a limited budget to spend building the network. This problem was proposed by Costa et al. [19] in which a two-phase greedy algorithm was developed: one phase consists in a simple local search that destroys part of a solution and rebuilds it greedily, and a tabu search using two simple search neighborhoods. Later, Costa et al. [20] presented several integer linear programming models for the STPRBH and branch-and-cut algorithms were developed for each formulation. Layeb et al. [21] presented a compact formulation based on Miller–Tucker–Zemlin constraints which resulted in similar solutions to those found previously in the literature. Recently, Fu and Hao [22] proposed a new heuristic for the STPRBH which was able to find optimum solutions for instance with known optima and improved solutions for instances with unknown optima.A similar problem is the Connected Facility Location Problem (ConFL) introduced in Karger and Minko [23]. This problem consists in assigning each client to exactly one opened facility and connecting the opened facilities using a Steiner tree. Ljubić and Gollowitzer [24] introduced a modification in the ConFL by limiting the number of hops between the facilities and a root node. This problem is known as the Hop Constrained Connected Facility Location Problem (HCConFL). Ljubić and Gollowitzer [24] used the same technique presented in Gouveia et al. [18] where the problem is modeled on a layered graph. Branch-and-cut algorithms were developed.One can note that the problem addressed in this paper (WBNDP) has characteristics that are similar to those of the problems reviewed above. This is especially true with respect to the maximum number of hops. However, there are two main characteristics that distinguish the WBNDP from other problems. The first is the possibility that each demand node be served by more than one Steiner node or root node. In this sense, we do not have a tree like in the other problems. The second and most important characteristic is how the revenue is computed. In previous papers, the revenue considers the “full value” of a vertex if it is in the solution, i.e., the backhaul network is capable of routing all the traffic. In the WBNDP, due to natural constraints, this is not always true. In fact, we consider that the network has a limited routing capacity and the revenue is a function of the maximum flow in this network. This way, there is a strict relation between the network structure and the revenue, once both topology and link capacity directly influence the flow. Another small difference is that the degree constraints are applied only to Steiner nodes and macrocells (only to wireless links and not to fiber links).Consider a geographical region with each point in the region identified by its coordinates (latitude and longitude). Consider the graph G=(V, A), where V and A are, respectively, the sets of vertices and arcs of G. The set Vd⊂V is the subset of vertices that correspond to demand points or city blocks in this region. These demand points consist of mobile devices, such as mobile phones, tablets, laptops, and other devices that make use of wireless communication. The set Vs⊂V is the set of vertices that correspond to equipment used to collect and route traffic from the demand points. This equipment is installed on utility poles distributed across the streets and highways of the region. We consider small cells network design, meaning that cellsites have relatively small coverage radii. Small cells have the advantage of using spectrum more efficiently. We consider three types of equipment: Wi-Fi and LTE for access traffic (demand collection), and retransmitter for routing/backhauling. The set Vr⊂V represents the Fibered Access Points (FAPs) where we have existing fiber connected to the core network. VRADs (Video-Ready Access Devices) are one example of FAPs. Installing equipment close to a VRAD will enable us to route the traffic on this fiber with no or little additional cost. We also have many existing macro cellsites where we can add additional radio equipment (eNB) to carry traffic. If this macro has a fiber backhaul, we can technically consider it a FAP but because macros also cover access traffic directly, we make a distinction between macro cells and other FAPs for notational convenience. Finally certain macro cellsites are connected to the core with very high speed wireless links. In our formulation, they serve the same purpose as macros with a fiber backhaul and we treat them identically.The objective is to create routing trees such that the tradeoff between the revenue derived from the routed traffic and the network cost be the best possible. In these networks, there are a large number of peculiarities that differ them from Steiner trees. We call this problem the wireless backhaul network design problem (WBNDP) and in the following we describe each one of these particularities so that later on we can present a formal definition.In general, it is difficult to estimate the demand of each user due to the user's mobility in the region where the network will be built. One way to approximately model this scenario is to concentrate, for each city block, its total demand at the center of the block. Although this appears to be oversimplified, the errors are diluted by the mobility of the users. Therefore, it is reasonable to assume that a certain block may be served by several cellsites and its demand split among them. Although the demand may be split among several pieces of access equipment, this equipment and the routing equipment must be connected through trees rooted at the FAPs or the macrocells. Thus, one can note that a solution S for a backhaul network may contain an undirected cycle originated at a demand. Therefore, although we have a forest when we consider only the Steiner vertices and root nodes of S, the addition of demand vertices can induce these undirected cycles, resulting in a directed acyclic graph (DAG).Each access equipment is limited in its handling of traffic. These constraints are access radius and access capacity. Values of these parameters vary across vendors and also depend on geographic terrain. We have used the following representative values in our simulations. For access radius, we have Wi-Fi: 100m; LTE small cell: 400m; LTE macro cell and HSPA: 3000m. For access capacity, we have Wi-Fi: 100Mbps; LTE small cell: 20Mbps single band, 40Mbps dual band; LTE macro cell and HSPA: 25Mbps. Although, for the sake of simplification, we considered LTE macro cell and HSPA to have the same access radius and capacity, even though these two technologies can present different values. For more details about these limitations, see [25].The capacity of retransmitter equipment is one of the most complex aspects of this type of network. In addition to having a maximum access radius (representative value of 1000m), retransmitter equipment also have a physical restriction that limits the sum of the flow that it receives and sends to the other retransmitters. This quantity is limited to a value Ubh(e.g., 100Mbps). Though this equipment also deals with access traffic from other equipment (Wi-Fi/LTE) that share the same utility pole, this limit is not applied to that traffic. Therefore, the limit Ubhdoes not account for all incoming traffic but shapes the outgoing traffic.More precisely, letv∈Vsbe a retransmitter. TakeAv+s={(w,v)∈A:w∈Vs}as the set of arcs outgoing from neighbors ofvthat send to it backhaul traffic. Letav−be the outgoing arc ofvin the solution (recall that we are looking for a backhaul forest). LetAv+d={(w,v)∈A:w∈Vd}be the set of arcs from demand vertices tov. Letf:A→ℝ+be a function that defines the flow on the arcs. Therefore, we have(1)∑e∈Av+sfe+fav−≤Ubh,∀v∈Vssuch that(2)∑e∈Av+sfe+∑e∈Av+dfe=fav−,∀v∈Vs.While Inequality (1) only restricts the backhaul flow to at most the capacity Ubh, Equality (2) is the classical flow conservation equation which ensures thatvhas no excess flow. Although these restrictions do not influence the structure of the backhaul forest, they have a direct impact on the maximum flow in the forest, used to compute the revenue. In this case, we cannot use a classical algorithm for maximum flow such as Edmonds–Karp or Goldberg–Tarjan directly (see [26] for a comprehensive list).Another physical restriction on the retransmitters is that they support only a limited number of neighbors sending backhaul traffic to it (known as fan-in, equal to 5 in our simulation results). Thus, this restriction limits the incoming degree of each retransmitter vertex.One can note that the subgraph induced by Vsmay be sparse. The main reason for this is the existence of physical barriers, such as buildings and hills between pairs of utility poles. Moreover, the distance between them can be so large that the signal loses strength and impairs communication. Therefore, one must consider that the links(u,v)and(v,u)only exists when poles u andvare close enough (1000m in our simulations) and they are in each other's line of sight, i.e. we can trace a straight line between them without obstruction.Another important aspect is the interference among cellsites. Both LTE and HSPA use licensed spectrum and can interfere with each other. Therefore, a pair of LTE equipment cannot be installed too close together. In our simulations, we restrict a minimum distance of 300m between two LTE small cellsites and a minimum distance of 500m between LTE small cell and macro cellsites. Note that this concern does not exist with Wi-Fi equipment which, although can exhibit interference, occupies a non-licensed spectrum. Such spectrum is very hard to control due to external interferences.The first hops are defined to be arcs that link root nodes to poles. In practice, these hops may be built using either wireless links or fiber links. The links between utility poles and FAPs must use fiber. Links between poles and macrocells may use fiber or be wireless. The other hops are built over wireless links. The restriction is that the number of wireless hops must be limited to an upper bound (in practice, two or three hops). This restriction aims to reduce the latency of the wireless network and is commonly considered in network planning [16]. Note that only backhaul links are considered.ExampleFig. 1a depicts an example of a base graph where the dashed arcs represent possible wireless links and the solid blue arc represents an optical fiber link. The dotted sinuous arcs represent the possible links between a demand block and an access equipment. This graph is based on geographic information of the backhaul region and takes into consideration maximum coverage radii as well as the lines of sight of pairs of equipment. Note that the macrocell (represented by a large yellow rhombus/diamond) contains two attached vertices. These are the backhaul traffic aggregator (BTA) and the macro cell traffic aggregator (MTA) (represented by small yellow diamonds). Note that these vertices are virtual and the links between them are internal to the devices. They are used to better model the traffic (more detail is given in Section 4). As with the macrocells, each utility pole is represented by a red square and has attached to it two virtual vertices representing Wi-Fi and LTE equipment and their respective aggregators (small orange diamonds for WTAs and purple diamonds for LTAs). The demands are represented by light blue circles. Note that each demand may be satisfied in three distinct ways: Wi-Fi, LTE, and HSPA. In this example, only demands 0 and 2 can be served by the macro cell because of their proximity to the macrocell. Demand 2 can split its traffic between the macrocell and utility poles UP0 and UP1 using LTE. The same situation occurs with demand 3. Demand 1 can use Wi-Fi or LTE on pole UP2, and LTE on pole UP0. Demand 4 is only close to pole UP4 and can use both Wi-fi and LTE. Note that utility poles UP0, UP1, and UP2 are close enough to each other and in each other's lines of sight, enabling the installation of retransmitters on them. Utility poles UP3 and UP4 are in another region and do not have communication links with UP0, UP1, or UP2.Fig. 1b shows a valid solution. The solid arcs represent the links among the pieces of equipment. In this example we ignore capacities. Note that several pieces of equipment are not installed since they do not serve any demand. For example, in utility pole UP2 it suffices to install Wi-Fi. Note that if we consider only the black and blue arcs (straight lines), we have a forest. Note also that demand 2 splits its traffic between utility pole UP0 using LTE and the macrocell. Demand 3 is more interesting: it is split between two distinct subtrees. In this case, demand 3 uses LTE on UP3 and UP1 but nothing prevents it from using the Wi-Fi on UP1 and LTE on UP3.Let Vdbe the set of demand points or demand nodes. Let Vsbe the set of utility poles where the access and retransmission equipment can be installed. We refer to Vsas Steiner nodes. Let Vrbe the set of points which have fiber or a high capacity link which we call root nodes. Consider Vm⊆Vras the set of macrocells andVv⊆Vras the set of FAPs. Let V=Vd∪Vs∪Vrand note thatVm∪Vv=Vr, and the sets Vd, Vs, Vm, andVvare pairwise disjoint. Consider Vld⊆Vrto be the set of FAPs whose through traffic is leased.To model the traffic in the different technologies, consider the following sets:•WTA: set of vertices that represents units of Wi-Fi equipment to be installed on the poles. We call eachw∈WTAa Wi-Fi Traffic Aggregator. There is a one-to-one correspondence between Wi-Fi traffic aggregators and utility poles;LTA: set of LTE Traffic Aggregators whose description is similar to WTA, except that they are for LTE equipment;MTA: set of Macrocell Traffic Aggregators which have a one-to-one correspondence with each macrocell;BTA: set of Backhaul Traffic Aggregators which also have a one-to-one correspondence with each macrocell. The BTAs are restricted to wireless backhaul traffic.Letv∈Vs, u∈WTA. If u is assigned to polev, thenwta(v)=uandwta(u)=v. Consider the same for LTA, MTA, and BTA. As in previous sections, consider a directed graph G=(W, A) such that W=V∪WTA∪LTA∪MTA∪BTA. We will define the set of arcs A later. Letd:Vd→ℝ+be the function that maps the maximum traffic (in Mbps) that originates at each demand point.Consider the following constants:•Maximum number of wireless hops: H;Access Radii (in m):–Wi-Fi access radius: Rwifi;LTE access radius: Rlte;Macrocell access radius: Rmc;Retransmitter radius: Rbh;Minimum distance (in m):–LTE to LTE (pole to pole): δlte;LTE (pole) to macrocell: δmacro;Capacities (in Mbps):–Wi-Fi: Uwifi;LTE: Ulte;Macrocell (HSPA and LTE access): Umc;Retransmitter: Ubh;Revenue factor (in some monetary unit): ϱ;Cost (in some monetary unit):–Equipment deployment on a pole: Cp;Wi-Fi equipment: Cwifi;LTE equipment: Clte;Retransmitter with one-element antenna (fan-in=1): Cfan1;Retransmitter with two-or-more-element antenna (fan-in≥2): Cfan2;Maintenance of equipment on a pole (per year): Cman. The maintenance cost is the sum of the pole leasing costs and small cell maintenance costs, per year. Note that, if the pole has no access equipment but has a retransmitter, the maintenance cost shall be paid;Macrocell annual cost: Cmc. This costs is compounded by the annual site leasing cost and the annual maintenance cost;Meter of deployed fiber: Cfiber;Leased traffic (in $/Mbps): Cld;Maximum number of incoming backhaul neighbors:δbh+;Length of fibered link: ℓuvfor arc(u,v);Maximum length of fibered links: Rfiber. Theoretically, this limit does not exist since we may spread fiber over the entire network. In practice, the cost to do this is very high and therefore we impose this limit. However, this is a weak restriction which may be violated if necessary.Letdist:V×V→ℝ+be the (geodesic) distance between two points. Forv∈Vs∪Vm, considerLOSv={w∈Vs∪Vm:dist(v,w)≤Rbhand there is direct line of sight betweenvandw}. The set of arcs A is defined as the union of the following sets:•Adm={(u,v):u∈Vd,v∈MTAanddist(u,mta(v))≤Rmc}: Set of arcs from demand blocks to macrocells (MTAs) whose blocks are inside the radius of action of a macrocell;Adw={(u,v):u∈Vd,v∈WTAanddist(u,wta(v))≤Rwifi}: Set of arcs from demand blocks to utility poles (WTAs) inside the radius of action of Wi-Fi equipment;Adl={(u,v):u∈Vd,v∈LTAanddist(u,lta(v))≤Rlte}: Set of arcs from demand blocks to utility poles (LTAs) inside the radius of action of LTE equipment;Ass={(u,v):u,v∈Vsandv∈LOSu}: Set of arcs between utility poles. Note that both(u,v)and(v,u)belongs to Ass;Asmw={(u,v):u∈Vs,v∈BTAandu∈LOSbta(v)}: Set of arcs from utility poles to macrocells (BTAs). This set is restricted to wireless links;Asmf={(u,v):u∈Vs,v∈Vmanddist(u,v)≤Rfiber+ϵ}: Set of arcs from utility poles to macrocells using fibered links (recall that this is a weak restriction which can be relaxed by adjusting the value of ϵ);Asv={(u,v):u∈Vs,v∈Vvanddist(u,v)≤Rfiber+ϵ}: Set of arcs from utility poles to FAPs (same as before);Awta={(wta(v),v):v∈Vs}: Set of arcs from WTAs to utility poles;Alta={(lta(v),v):v∈Vs}: Set of arcs from LTAs to utility poles;Amta={(mta(v),v):v∈Vm}: Set of arcs from MTAs to macrocells;Abta={(bta(v),v):v∈Vm}: Set of arcs from BTAs to macrocells.Note that arc sets Adm, Adw, Adl, Ass, and Asmwcorrespond to wireless links. Arc sets Asvand Asmfcorrespond to fibered links. Arc sets Awta, Alta, Amta, and Abtarepresent connections between several pieces of equipment in the same small cell or macrocell. We use these arcs to model equipment capacities.To better describe the objective function and constraints of the WBNDP, we next model it as a mixed integer linear program (MIP). The constraints are based on the observations of Section 3 and on topological restrictions of a DAG, as well as maximum capacity and flow conservation limitations. One important definition to model the WBNDP, it is the notion of level. We define level as the number of wireless hops between a utility pole and a root node. Consider the following decision variables:•xuvp∈{0,1}for(u,v)∈A, u∈Vs,v∈Vs∪Vr∪MTA:xuvp=1indicates that arc(u,v)is in level p of some tree, for p=0, …, H;xuvp=0, otherwise. Forv∈Vr, only variablesxuv0are defined. Forv∈BTA, only variablesxuv1are defined;yv∈{0,1}forv∈Vs:yv=1indicates that a vertex/polevis in the solution;yv=0, otherwise;fuv∈ℝ+for(u,v)∈A: is the flow through arc(u,v);tv∈{0,1}for u∈Vs:tv=1indicates that polevhas installed Wi-Fi equipment;tv=0, otherwise;zv∈{0,1}for u∈Vs:zv=1indicates that polevhas installed LTE equipment;zv=0, otherwise;av1∈{0,1}forv∈Vs∪BTA:av1=1indicates that the pole or the macrocell has a retransmitter with a one-element antenna (fan-in=1);av1=0, otherwise;av2∈{0,1}forv∈Vs∪BTA:av2=1indicates that the pole or the macrocell has a retransmitter with a two-or-more-element antenna (fan-in≥2);av2=0, otherwise.Variables x are used to model the backhaul trees in levels. If an arc(u,v)is in level 0 (i.e.,xuv0=1), then the arc is a fibered link of high capacity. If the same arc is in level 1 (i.e.,xuv1=1), then it is a wireless link. Note that the variables x may be not defined for all arcs(u,v)and all levels p while some arcs only appear in deep levels of some tree. For instance, arc (UP1, UP2) from the example of Fig. 1a can only appear in level 3. Such cases can be identified in a preprocessing phase, as we will describe in Section 7.2.The following MIP models the WBNDP:(3a)maxϱ∑(u,v):v∈Vrfuv(3b)−∑v∈Vs(Cp+YCman)yv(3c)−∑v∈VsCwifitv−∑v∈VsCltezv(3d)∑v∈Vs∪Vm(Cfan1av1+(Cfan2−Cfan1)av2)(3e)−∑(u,v)∈Asv∪AsmfCfiberℓuvxuv0(3f)−∑(u,v)∈A:v∈VldCldfuv+Cmc(3g)s.t.∑p=0Hxuvp≤1∀(u,v)∈A:u∈Vs(3h)xuvp+1≤∑(v,w)∈A:w≠uxvwp∀(u,v)∈A:u∈Vs,p=0,…,H−1(3i)∑(u,v)∈A∑p=1Hxuvp≤δbh+yv∀v∈Vs∪BTA(3j)∑(v,w)∈A∑p=0Hxvwp≤yv∀v∈Vs(3k)av1≥1δbh+∑(u,v)∈A∑p=1Hxuvp∀v∈Vs∪BTA(3l)av2≥1δbh+∑(u,v)∈A∑p=1Hxuvp−1∀v∈Vs∪BTA(3m)av1≥∑(v,w)∈A∑p=1Hxvwp∀v∈Vs(3n)tv≤yv∀v∈Vs(3o)zv≤yv∀v∈Vs(3p)zu+zv≤1∀u,v∈Vs:dist(u,v)≤δlte(3q)zu=0∀u∈Vs,v∈Vm:dist(u,v)≤δmacro(3r)∑(v,w)∈Afvw≤dv∀v∈Vd(3s)fuv≤Uwifitv∀(u,v)∈A:u∈WTA(3t)fuv≤Ultezv∀(u,v)∈A:u∈LTA(3u)fuv≤∑p=1HUbhxuvp∀(u,v)∈A:u,v∈Vs∪BTA(3v)fuv≤Mxuv0∀(u,v)∈A:u∈Vs,v∈Vr(3w)∑(u,v)∈A:u∈Vsfuv+∑(v,w)∈Afvw≤Ubh∀v∈Vs(3x)∑(u,v)∈Afuv−∑(v,w)∈Afvw=0∀v∈V\(Vr∪Vd)(3y)fvw≤Ubh∀v∈BTA(3z)fvw≤Umc∀v∈MTA.Terms (3a)–(3f) constitute the objective function and computes the net profit that the network generates in a time windows ofY∈ℝ+years. In practice, the revenue is computed by a complex function based on service packages offered to customers and, in general, is an estimate based on the experience of operators and on market fluctuations. For the particular scenario considered in this paper, the revenue is a function of the total traffic routed through the FAPs. We consider a linear function using the revenue factor ϱ as shown by Term (3a). The remaining terms add up to the total cost: Term (3b) is the cost of deployment and maintenance of poles over Y years; Term (3c) is the cost of Wi-Fi and LTE equipment; Term (3d) is the cost of retransmitters; Term (3e) is the cost of trenching for fiber; and Term (3f) is the cost of leased traffic. The constant Cmcrepresents the macrocell cost as described in the beginning of this section.The constraints can be partitioned into three blocks.The first block ((3g)–(3j)) models the backhaul trees: Constraint (3g) forbids an arc to be in more than one level; Constraint (3h) requires that if an incoming arc into nodevis in level p+1,vshould have an outgoing arc in level p; Constraint (3i) limits the incoming degree for poles and BTAs according to Section 3.3 (note that the constraint only consider levels greater than or equal to one, since fibered arcs of level 0 are only allowed to be incoming arcs at FAPs and macrocells); and Constraint (3j) guarantees that each pole has at most one outgoing arc.The second block of constraints ((3k)–(3p)) is tied to equipment deployment. Constraints (3k) and (3l) indicate, respectively, the presence of a retransmitter with a one-element antenna or a multiple-element antenna. Note that if, for some nodev,av2=1, then necessarilyav1=1. In this case, we do not consider a one-element antenna subtracting its cost from the objective function as shown in Term (3d). Constraint (3m) guarantees placement of a retransmitter in nodevif there exists an arc outgoing fromv. Constraints (3n) and (3o) permit the deployment of Wi-Fi and LTE equipment on polev, respectively, only if polevis used. Constraints (3p) and (3q) prohibit the deployment of two pieces of LTE equipment near each other or close to a macrocell, respectively. Note that Constraint (3q) may be redundant since closeby pole/macrocell pairs are discarded in a preprocessing phase.The last block of constraints ((3r)–(3z)) is related to flow. Constraint (3r) limits the flow outgoing from demand blocks. Constraints (3s) and (3t) ensure that Wi-Fi and LTE capacities are respected. Constraint (3u) limits the capacity of wireless arcs to the retransmitter capacity. Constraint (3v) enables unlimited flow on fibered links whenM≥∑v∈Vddv. Constraint (3w) limits the retransmitter capacity as discussed in Section 3.3 (note that only backhaul flow is considered in this constraint). Constraint (3x) is the classical flow conservation constraint. Finally, Constraint (3y) applies the retransmitter capacity to BTAs, while Constraint (3z) limits macro cellsite traffic. All integrality requirements are omitted since they are described in the beginning of this section.Because of the large-scale nature of practical instances of MIP (3), it can be difficult to solve the WBNDP using an exact approach, such as a branch-and-cut algorithm. Typically, these instances are situated in regions of approximately 80km2 with about 15 macrocells, 130 VRADs, 3200 utility poles, and 16,000 demand blocks. Although the underlying graph is relatively sparse, the number of valid solutions can be huge. To deal with this situation, we propose a Biased Random-Key Genetic Algorithm (BRKGA) to solve the WBNDP. See Gonçalves and Resende [3] for an introduction to BRKGA. The main reason for opting for a BRKGA is that this metaheuristic has been shown to be adaptable to a wide variety of combinatorial optimization problems, such as packing [27], routing [28], clustering [29], and winner determination [30].From an implementation point of view, most of the effort in building a BRKGA focuses on devising a decoder, which takes as input a vector of random keys and outputs a valid solution for the problem. The decoding phase for the WBNDP consists in iteratively building acyclic directed graphs and the computation of maximum flows, costs, and revenues. This procedure builds the solution in a bottom-up fashion, starting at the root nodes and ending at the demand nodes. Since the WBNDP has a large number of peculiarities, the design of a decoder is not trivial and consists of a number of intermediate steps. In the next subsections, we describe each of these steps.Given an instance of the problem, without loss of generality we assume that the utility poles are listed in an arbitrary but fixed orderVs=(p¯1,…,p¯n)where n is the number of poles, i.e., n=|Vs|. We also assume that the root nodes are listed in an arbitrary but fixed order beginning with macrocells and ending with the FAPs, i.e,Vr=(m¯1,…,m¯α,f¯1,…,f¯β)where α is the number of macrocells and β is the number of FAPs.A chromosome is a vector of real numbers v∈[0, 1]5n. This vector is partitioned into five sections whose values are used to build the backhaul network. Each value is associated with a utility pole through an index given by Vs. As we explain below, each pole is associated with five values, or keys, of the chromosome, one in each partition.The first section consists of values v1, …, vnthat define which poles are present in the solution and their deployment order. The deployment order defines the sequence of LTE equipment installation. We refer to this first group as κA=(v1, …, vn).The second section consists of the values vn+1, …, v2nwhich are used as activation parameters. They determine whether:•an LTE equipment is deployed on the utility pole (L or NL);the utility pole is connected via fiber (F or NF);the utility pole connects directly to a FAP or a macrocell (D or ND).Using this notation we have:-vi∈[0.000,0.125), then: NL, NF, ND;vi∈[0.125,0.250), then: NL, NF, D;vi∈[0.250,0.375), then: NL, F, ND;vi∈[0.375,0.500), then: NL, F, D;vi∈[0.500,0.625), then: L, NF, ND;vi∈[0.625,0.750), then: L, NF, D;vi∈[0.750,0.875), then: L, F, ND;vi∈[0.875,1.000), then: L, F, D.The first parameter controls how to distribute LTE equipment and, as a consequence, how the demands are distributed amongst them. Furthermore, it may be valuable not to install LTE on a given utility pole even if there is nearby demand, since the cost/benefit ratio may be too low or negative. The second parameter dictates if a pole can be connected by fiber. It is used in cases where the utility pole is connected to a macrocell by fiber or by a wireless link. Again, this parameter controls the cost/benefit ratio. Lastly, the third parameter dictates the minimum tree level in which a pole appears in the backhaul network. We refer to these keys as κP=(vn+1, …, v2n).The third section κO=(v2n+1, …, v3n) defines the evaluation order of the utility poles as the network is grown. This order is used to build the next level of nodes in the forest. Suppose, for example, that a utility pole is already connected to the network and that it can only support one additional backhaul connection (i.e., Constraint (3i) is nearly saturated). If there are two other poles to be connected to this one, the order induced by κOwill define which pole will be connected. Another order induced byκO′can potentially generate a different network.The fourth section κN=(v3n+1, …, v4n) defines the evaluation order of a pole neighborhood. Suppose that a pole is about to be included in the network and that it has two or more previously deployed neighbor nodes with utility poles to which it can connect. The order induced by κNwill determine to which neighbor the connection will be made.Lastly, the fifth section κL=(v4n+1, …, v5n) defines the minimum tree level on which a utility pole can be placed. The root nodes and fibered utility poles are considered to be at level zero. Thus, the remaining poles are distributed among levels 1 through H. The minimum level of utility pole i is given by⌊(H+1)κiL⌋. If the minimum level of pole i is zero, it can be placed in any tree level. If it is one, pole i can only be placed in level 1 or above. In this case, the pole cannot be connected by fiber.Although at first glance, there is a superposition of functionalities among the several keys, we see below that each key plays a very particular role in the process of network construction.Algorithm 1 shows the basic steps to decode a chromosome into a valid solution. It consists of several procedures described in Algorithms 2–5. In addition to the above discussion, the algorithms also make use of the following definitions:•parent(p): indicates which utility pole, macrocell, or FAP that pole p is linked to, i.e., arc (p, parent(p)) exists in the backhaul network;children(p): set of poles linked to p, i.e., there exist links(w,p)forw∈children(p);level(p): indicates the level in which pole p is placed in the tree;fibered(p): indicates if pole p is linked by fiber to a root node;deg+(p): number of arcs leaving p (i.e., outgoing degree of p);CP: set of the most external poles in the current stage of network construction, i.e., the leaves of current forest;TK: set of all utility poles in current forest. Note that CP⊆TK;NL: set of utility poles to be considered for connection in the next forest levels.Algorithm 1Decoder.The first step is to choose which poles can be added to the solution. Line 1 of Algorithm 2 chooses the poles whose keys have a value greater than or equal to 0.5, and activates these poles in an order defined by their key values. Therefore, for each activated pole, we install Wi-Fi and LTE equipment in the given order when there is demand in the access radii of the pole. In the case of LTE, we need to check whether the pole is sufficiently far from any macrocell or other poles with previously installed LTE equipment.Algorithm 2Equipment activation and installation.The construction of the backhaul forest is an iterative bottom-up process. First, we create the first level connecting poles to the root nodes using Algorithm 3. Sets CP, TK, and NL are initially empty. We initialize pole levels to indicate that level assignment has not yet been made. Likewise, we initialize no connectivity by fiber to all poles (lines 1 and 2). We add to CP, the set of current poles, all active neighbors of each root node (lines 3 and 5) sorted in non-increasing order of their corresponding keys in the chromosome (line 6). Using this permutation, we try to connect each pole to a FAP or a macrocell obeying the minimum level and activation parameters (note that the function extractparameters() returns a triple according to the description of Section 5.1). If a connection by fiber is allowed, we choose the closest FAP or macrocell under the maximum distance constraint (line 12) and connect the pole to the chosen root node, setting it as “parent” of this pole, and placing the pole in the set of children of the root node. As it is a fibered connection, we consider that the pole is in level zero. If it is not possible to connect by fiber, we try to create a wireless link. To do this, we create a list of neighbor root nodes of the pole which will be visited circularly from the point i determined by the corresponding key in the chromosome. This is done until we obtain a connection (lines 20–33). Note that, in this case, the pole will be in level 1 and its parent will have its incoming degree incremented by one (lines 27 and 28). In the last case, when it is impossible to make a connection, we remove the pole from the set CP of current poles and place it in the set NL of poles for consideration in the next level.Algorithm 3Building of backhaul forest (level 0).After the first level of the backhaul forest is created, set CP consists in the poles that are forest leaves. From them, Algorithm 4 tries to augment the reach of the network. First, we add to list NL the neighbor poles of CP that are active, in the line of sight with some pole in CP, and are not yet part of the forest. We only consider neighbors from poles whose incoming degree is not saturated (line 3). These operations are described in lines 2–8. After constructing these lists, we consider the poles in NL as current poles and take a permutation according to the order induced by the chromosome keys. The remainder of the algorithm (lines 12–28) is similar to Algorithm 3 with respect to wireless connections. Note that at the end of this procedure, set NL may have poles that are not connected to any tree. These poles will be eliminated from the solution in a pruning phase.Algorithm 4Building of backhaul forest (level ≥ 1).After the complete construction of the backhaul forest, it is possible that there exist active poles not used in the forest, or yet poles present in the forest but not serving any demand. Algorithm 5 removes these poles. We have two pruning phases. The first occurs after the construction of the backhaul forest and the second after the maximum flow computation. In the first phase, we generate a “virtual” flow in each arc only present for the convenience of the algorithm. Thus, a recursive pruning procedure is applied in each root node (pruneSubtree()). This procedure traverses each tree using the depth-first strategy until it reaches a leaf node. This way it verifies if demand is served by this leaf node using either Wi-Fi or LTE (lines 5–8). In case demand is present, the pole is kept. If there is no demand but the pole has chidren nodes, then we can deduce that the pole is being used only as a retransmitter and we keep the pole in the forest. Otherwise, the pole is marked for later removal from set TK. Note that when the recursion returns, line 3 removes all marked children.Algorithm 5Equipment and poles pruning.After the forest construction and first pruning phases, it is necessary to create a graph induced by this forest to compute the maximum flow from the demand nodes to the root nodes. As pointed out in Section 3.3, the maximum flow problem to be solved is neither classical nor straightforward. To solve this problem, we proposed two solutions which are described in Section 6.Computed the maximum flow, a second pruning phase is applied to the forest and all non-used pieces of equipment are removed as described earlier (Algorithm 5). Lastly, the revenue and the costs are computed. As aforementioned, these calculations may use different approaches depending on the objective of the study. In this paper, the revenue is derived from the maximum flow directly as shown in Term (3a) of the objective function of MIP (3). The cost is computed using the remaining Terms ((3b)–(3f)). The total cost depends on the deployed equipment, deployed fiber, deployment and maintenance costs, and leased traffic. Computed the revenue and costs, the profit is returned as the solution value and fitness of the current decoded chromosome.As pointed out in Section 3.3, wireless backhaul equipment has very specific constraints with respect to the reception and retransmission of backhaul traffic. These constraints are mainly related to the physical proprieties of the wave spectrum used. This way, the total capacity of reception and retransmission is limited to a certain constant Ubh. At the same time, this equipment also collects local traffic sent by other equipment, such as Wi-Fi and LTE receptors.For a given retransmitterv, we can assume three distinct components. The first component is the incoming backhaul traffic, denoted byFbi, such thatFbi=∑u∈Vs:(u,v)∈Assfuv, i.e., the sum of backhaul traffic sent tovfrom neighbors. The second component is the access traffic, denoted by Fa, which is the sum of the Wi-Fi and LTE traffic inv, i.e.,Fa=fwta(v),v+flta(v),v.11Notation detail:fu,v=fuvThe third component is the outgoing backhaul traffic, denoted byFbo, such thatFbo=fv,parent(v)=Fbi+Fa. The relationship among these components is given by Inequality (1), that restricts the backhaul flow capacity, and by Eq. (2) that ensures flow conservation. The difficulty is that classical maximum flow algorithms do not deal with these restrictions at the same time and, as far as we know, there is no reduction from the maximum backhaul flow problem to any classical flow problem.One way to bypass this problem is to consider the access traffic as incoming backhaul traffic. Thus, note that(4)Fbi+Fa+Fbo≤Ubh.HoweverFbi+Fa=Fbo, which leads us to(5)Fbo≤Ubh2∀v∈Vs.In this case, as both incoming flows are of the same kind, it suffices to bound either the incoming or outgoing flow to half of the original capacity. The major drawback of this approach is the large flow loss that may result. Suppose, for example, a backhaul capacity of Ubh=100, backhaul incoming flow ofFbi=30, and an access flow of Fa=40. Using the previous technique, we will have the nominal capacity ofUbh′=50in the outgoing arc, which limits the maximum flow to the same value. In this case, 20 units of traffic, either demand or backhaul traffic, cannot be backhauled. But note that using the original constraints, all traffic can be routed since the outgoing traffic wouldFbo=Fa+Fbi=70that respects the capacity constraint (Fbi+Fbo=30+70=100=Ubh). In fact, we can provide a bound on this loss using simple algebra. Note that the most constraining factor is the incoming backhaul traffic. As it tends to zero, it enables the increase of the capacity of the outgoing traffic, thus allowing more access traffic be routed (see Lemma 1 below). Consider Inequality (1) in terms of access traffic:(6)Fbi+Fbo≤UbhFbi+Fbi+Fa≤UbhFa≤Ubh−2Fbi.Now consider Inequality (4) in terms of access traffic:(7)Fbi+Fa+Fbo≤Ubh2Fbi+2Fa≤UbhFa≤Ubh−2Fbi2.Taking the limit of the proportion between Inequalities (6) and (7) when the incoming backhaul traffic tends to zero, we have:(8)limFbi→0Ubh−2Fbi2Ubh−2Fbi=12.Therefore, the proposed simplification may cause a loss of up to 50% in access traffic (and, consequently, total traffic) that the network can transport. Although the theoretical bound is not very good, this approach leads to reasonable results in practice, as shown in Section 8.2. The following lemmata also give us bounds on the flows in the forest.Lemma 1Consider a vertexv∈Vswith backhaul capacity Ubh,Fbobe the outgoing backhaul traffic fromv, and Fabe the value of the access traffic incoming inv. Then,Fbois maximum only if Fais maximum.Proof 1The proof is simple by inspection of the maximality. First, note that we want to maximizeFbo=Fa+Fbi. But, by constraint capacity (1), we have thatFbi+Fbo≤Ubhwhich means thatFa+2Fbi≤Ubh. Let0≤Fˆa<Faand0≤Fbi<Fˆbiand suppose thatFˆaandFˆbiyield the maximum flowFˆbo. Suppose thatFˆbiis maximum which means thatFˆbi=Ubh/2enforcingFˆa=0. ThereforeFˆbo=Ubh/2. But choosingFbi=Fˆbi−ɛ, we have that Fa+2(Ubh/2−ɛ)≤Ubhwhich is Fa≤2ɛ. ThereforemaxFbo=2ɛ+Ubh/2−ɛ=ɛ+Ubh/2>Fˆbocontradicting the maximality ofFˆbo.Lemma 2Letv∈Vssuch thatvis in level 1 or greater in the backhaul forest. LetT(v)be a subtree of Steiner vertices rooted atv. For all verticesx,y∈T(v)such that arc (x, y)∈A, fxy≤Ubh/2.Proof 2LetNb(v)be the neighbor vertices ofvthat send to it backhaul traffic. Also consider FaandFboas defined before.Letx∈T(v)such that(x,v)∈A. Therefore:∑u∈Nb(v)fuv+Fbo≤Ubhfxv+∑u≠x∈Nb(v)fuv+Fbo≤Ubhfxv≤Ubh−Fbo−∑u≠x∈Nb(v)fuvwhich leads us tofxv≤Ubh−Fbo−∑u≠x∈Nb(v)fuv=Ubh−∑u∈Nb(v)fuv+Fa−∑u≠x∈Nb(v)fuv=Ubh−fxv−2∑u≠x∈Nb(v)fuv−Fa=Ubh−2∑u≠x∈Nb(v)fuv−Fa2≤Ubh/2.AsT(v)is a tree, all descendent arcs ofvhave their capacities bounded by Ubh/2 sincevis the unique output vertex inT(v).Lemma 1 shows that it is worthwhile to route the maximum access traffic available at a pole. Although this lemma is valid for all poles, it may be enforced in nodes at level 1 of the forest, since nodes at level 0 have a fiber connection allowing us to route all access traffic and backhaul traffic subject to the processing constraint. For poles at level 2 or above, we may drop Lemma 1 due to Lemma 2. Note that by Lemma 2, the capacity Constraint (1) does not play a role at poles at levels 2 or above since all traffic in those poles will respect this constraint.The maximum backhaul flow problem can be solved to optimality using a linear programming formulation derived from Constraints (1) and (2). The major problem with this approach is that, computationally, it is too slow to be used within the decoder. In Section 8.2, experimental results illustrate this problem. Another approach is to map this flow problem into a classical maximum flow problem [26]. One way to implement backhaul capacity constraint (1) in a classical maximum flow problem, is to set capacities on arcs instead of node equipment. To guarantee feasibility, one sets the capacities of all arcs connecting pairs of poles and arcs connecting pairs of poles/BTAs to half of the backhaul capacity, i.e, Ubh/2. Restricting capacity this way enables the utilization of classical flow algorithms at the expense, however, of potentially producing suboptimal flows.Consider a forest generated with Algorithms 2–5. In particular, consider the set TK of poles determined to be in the backhaul network. The maximum flow is computed over the graph induced by TK. For this, we take all vertices in TK and create subsets WTA′ and LTA′ restricted to poles in TK. This means that WTA′⊆WTA and LTA′⊆LTA since not all poles are in the forest and, for some poles, LTE equipment are forbidden. We also create the set BTA′ with vertices that aggregate wireless backhaul traffic in the macrocells. Note that a BTA exists in a macrocell only if it has children connected to it by wireless links. If all children are connected by fiber, then neither backhaul equipment nor a BTA is needed. Vertices in Vdand Vralso are considered when they are part of the backhaul forest. We add the vertex s to be the source node and vertex t to be the sink. We consider all arcs induced by the chosen vertices and create arcs from s to all demands and from all root nodes to t. In the following, definecap:E→ℝ+be the capacity of an arc:•For arc a incident tov∈Vd, letcap(a)=dv;For arc a, outgoing from vertex:–v∈WTA, let cap(a)=Uwifi;v∈LTA, let cap(a)=Ulte;v∈MTA, let cap(a)=Umc;v∈BTA, let cap(a)=Ubh;v∈Vr, let cap(a)=∞;For each arc a∈Ass∪Asmw, let cap(a)=Ubh/2;For each arc a∈Asv∪Asmf, let cap(a)=Ubh.Note that, although the fibered links in set Asv∪Asmfare considered to have unlimited capacity, we set their capacities to the capacity of retransmitter, modeling the incoming wireless backhaul traffic. In such case, we may lose access traffic if the pole with the fibered link has Wi-Fi and/or LTE traffic. To overcome this, we do the following. Letvbe a pole with a fibered link to some root nodew. We remove the arcs(wta(v),v)and(lta(v),v)and add the arcs(wta(v),w)and(lta(v),w)with the same respective capacities. Such change allows the maximum access traffic to by-pass polevand only limits the incoming backhaul traffic. Since we remove capacity Constraint (1), we may use any classical maximum flow algorithm to solve the maximum backhaul flow problem.As noted above, our approach may generate a suboptimal flow. To improve this, we propose a pumping algorithm to augment the generated flow. This algorithm is inspired on the push-relabel algorithm of [26] using Lemmata 1 and 2. The general idea is to push residual flow from the root vertices to the demand vertices observing Lemmata 1 and 2 and the capacity constraints. For each vertexv, letexcess(v)be the excess flow invthat must be pushed away. Algorithm 6 considers each root vertex and pumps flow through its subtrees. Lines 3–7 treat the fibered connections. For each child pole, the maximum flow increment is computed and passed to it as excess traffic. Then a procedure applied only to poles in level zero is called, and upon return, the flow is accumulated. In lines 10–19, the wireless connections are considered. In this case, the maximum flow of Ubhmust be shared with all wirelessly connected children. This is done by computing the maximum flow from the remaining capacity and excess. Since wireless children are considered be in level two or greater, a special procedure is called to treat this case. Again, the totals are accumulated.Algorithm 6Pumping root.Algorithm 7pumpPoleLevelZero(p).Algorithm 7 deals with poles at level zero. Since the above described by-pass guarantees that access traffic is maximum, one can limit their attention to only the incoming backhaul traffic. The algorithm just accumulated the access traffic (line 1) and pumped the maximum allowed flow to the children poles. In the end, if the pole has excess flow, it is pumped back to the parent vertex (line 9).Algorithm 8 deals with poles at level 1 or greater. The basic idea is the same of previous algorithms except that one must pay attention to the backhaul capacity and Lemmata 1 and 2. Considering Lemma 1, lines 2–16 aim to first maximize the access traffic. This block is considered twice: once for Wi-Fi and once for LTE. Because of this, we rename some terms to reduce the algorithm (lines 2 and 15). After the maximization of the access traffic, lines 22–35 try to push the remaining flow to the children nodes using a recursive call. As in other pumping algorithms, in the last two lines the excess is pumped back to the parent vertex. The key of this algorithm are lines 4–7 and 18–21. If the pole is in level 1, the access flow is given by Eq. (7) using simple substitution (the same occurs for the backhaul traffic in line 18). If the pole is in level two or greater, Lemma 2 comes into scene limiting the traffic to at most Cbh/2. In this case, we can consider that all traffic flows are of the same type and calculate the maximum local flow from the residue flow of all types. This ensures that the flow through that pole will respect the capacity constraint.Note that the proposed pumping heuristic has no relabel phase as in the push-relabel algorithm. The pumping algorithm ends after no more pushing is possible in the recursive calls and, therefore, its run-time complexity is O(|V|). Furthermore, the resulting flow is sensitive to the order that the poles are visited. Although the optimum flow is not guaranteed to be found, the pumping heuristic can improve the flow considerably (see Section 8.2 for more details).Algorithm 8pumpPoleLevelOneorMore(p).In this section, we describe the setup of the computational experiments performed to analyze the algorithms presented in this paper. The experiments were conducted using 30 instances derived from real-world scenarios.22These instances are available at http://www.loco.ic.unicamp.br/instances/wbndp.html.These instances are taken from neighborhoods of a large city in the United States. Each instance consists of a set of macrocells, VRADs, utility poles, and demand blocks. For each location, longitude and latitude coordinates are given. For each macrocell and utility pole, a list of street segments is given. We assume that if two locations share a segment, they are in the line of sight of each other. For each block, a traffic demand is given. For each macrocell and VRAD, there is an indication of whether traffic through them is leased or not. We classify the instances as small, medium, and large according the number of poles. Each class has ten instances. Table 1shows a summary and Table A.1 (in Appendix A) brings a complete description. The areas of the regions were computed for illustrative purposes only. The calculation of each area was based on the convex hull considering all locations in the region and their geodesic characteristics. Instance re01 is the smallest in terms of number of poles with 454 poles while instance re30 is the largest with 8740 poles. In terms of area, the smallest instance is re19 with 4.82km2 and the largest is re30 with 411.71km2.While all locations are real, the demand values are based on estimates of the actual demand and are scaled in an arbitrary range. The access radii, minimum distances, capacities, and backhaul constraints are real-life constraints and are displayed in Table 2. We also consider a scenario where the backhaul trees have restrictions neither in depth nor in breadth, and therefore the maximum number of hops H and the maximum number of incoming backhaul linksδbh+are unlimited (in practice, they are the number of poles in the instance). We call this scenario unrestricted in opposition to the restricted real-life scenario. The revenue factor and the costs are based on actual values but are also scaled in an arbitrary range. It is worthwhile to mention that the revenue factor, costs, and demands were scaled similarly so as to mimic real world values.33Disclaimer: these are generalized costs and revenues to assess performance of the algorithms and do not imply an actual business case for any carrier.The size of the fibered hop, ℓuv, is defined by the geodesic distance, in meters, between locations u andv. We consider a 3-year planning horizon, i.e. Y=3.The instance preprocessing aims to reduce the size of the instance and build the base graph that represents the potential wireless and fibered links, and the arcs representing the links between the demands points and access equipment. This graph is built using the definitions of Section 4. Note that, due to the minimum distance constraint between a macrocell and an LTE equipment, a pole u has an LTA associated with it if and only if for each macrocellv,dist(u,v)≥δmacro.The first step is to prune poles that will never be used in feasible solutions. To do this, we calculate the shortest path from each root node to each utility pole annotating the size of the shortest path from any root node to that utility pole. We consider that wireless arcs have weight one and fibered arcs have weight zero. Such paths represent the minimum level that a pole can have in the forest. Let q be the length of the shortest path from pole u to its closest root node. All poles for which q is greater than the maximum number of hops allowed (i.e., q>H) are eliminated since they cannot be used in any valid solution. Note that the corresponding WTA and LTA vertices are also deleted.The distances are also used to create the x variables of MIP (3). We only define the variablesxuvp, for p=q, …, H, and(u,v)∈A. Note that as u can be in level q or greater, the outgoing backhaul link(u,v)can only be in level q or greater. This preprocessing significantly reduces the size of the MIP and, consequently, the computational time needed to solve it.Another important observation is that several demand blocks may be served by the same group of poles and macrocells. This is particularly true for residential buildings and commercial areas. In such cases, we group these blocks making a super block whose demand is the sum of the demands of the original blocks. However, at the conclusion of the optimization, it will be necessary to “ungroup” these super blocks and redistribute the access flow to the original blocks.At the conclusion of the BRKGA iterations, we obtain an optimal or near-optimal solution using the strategy described in Section 6.2. One may note that if we compute the exact flow using the forest structure of the best solution found so far, we may be able to improve its objective function value. Note that this is true since this best solution was obtained using the heuristic maximum flow algorithm, a lower bound of the actual maximum flow. In view of this fact, at the end of the BRKGA iterations, we recompute the maximum flow for the best solution found using the linear programming model with Constraints (1) and (2). As we compute the exact flow just once, the execution time of entire algorithm is not compromised.The new linear programming based flow may traverse new paths. In some cases, some devices will no longer serve demands and can be disregarded. We can apply Algorithm 5 again to prune such unused equipment. Note that this post-processing can potentially further reduce the costs and improve the overall solution.The experiments were conducted on identical machines with four-core Intel Xeon 2.4GHz CPUs (two threads per core) and 50GB of RAM running GNU/Linux. Running times reported are UNIX real wall-clock times in seconds, excluding the effort to read the instance. The algorithms are implemented in C++ and we use the GNU g++ compiler version 4.8. Random numbers were generated by an implementation of the Mersenne Twister [31]. We used the Lemon library [32] to implement the graph structures and compute the maximum flow using its push-relabel algorithm implementation.To tune the BRKGA parameters, we use the iterated racing procedure [33]. This method consists in sampling configurations from a particular distribution, evaluating them using either the Friedman test or the t-test, and refining the sampling distribution with repeated applications of F-Race. We use the irace package [34], implemented in R, for parameter tuning. For each heuristic, we use a budget of 1000 experiments in the tuning procedure, where each experiment was limited to 1h. To tune the BRKGA parameters, we used the following ranges: population size ∈[300, 2000], elite percentage ∈[0.15, 0.30]; percentage of mutants introduced at each generation ∈[0.10, 0.20]; probability of inheriting each allele from elite parent ∈[0.5, 0.8]; number of independent populations ∈{1, 2}; exchange interval ∈[50, 200]; number of elite individuals in an exchange ∈[1, 2]; and reset population ∈[300, 700].The following values were recommended by irace. The population size was set to p=500, the elite size to pe=⌈0.30p⌉, and the number of mutants to pm=⌊0.15p⌋. The probability of inheriting each allele from the elite parent was ρe=0.70. We used the island model [35] with two independent and concurrent populations where every 100 generations each population exports its best solution to the other populations. After 300 generations without improvement, all populations are reset to vectors of random keys. We use four simultaneous cores for decoding.To solve the MIP, we used IBM ILOG CPLEX Optimizer version 12.6.0.0. We set CPLEX to use a maximum of 40GB of memory, using at most 40GB of disk memory when necessary. We allowed CPLEX use four threads in parallel. All other parameters were kept at their default values. We use a short run of the BRKGA to generate an incumbent solution for CPLEX. For this, we use BRKGA with the same parameters as above but limit its run to 100 iterations or 10% of maximum time, whichever comes first.We also tested a multi-start algorithm that uses the decoder of Section 5.2. In each iteration, the multi-start algorithm generates a random vector and uses the decoding function to obtain a solution. It also keeps the best solution over all iterations. In the end, the post-processing is applied to the best solution.Thirty independent runs were performed for the BRKGA and the multi-start algorithm. Since CPLEX is an implementation of an exact algorithm,44According to its documentation, the IBM ILOG CPLEX Optimizer, version 12.6.0.0 is fully deterministic when used with its default parameters (as done in our experiments).a single run for each instance was performed. We carried out two types of experiments, one limiting the running time of each algorithm to 1h and another to 5h. The limit of 1h enables network designers to work with several models in a manageable time while the limit of 5h enables a more thorough search. For both the BRKGA and the multi-start algorithm, we use an additional stopping criterion: 1000 generations (or iterations) without improvement of the best solution.As discussed in Section 7.2, it is important to preprocess the instance in order to reduce its size before optimization. With respect to the number of poles, the preprocessing phase in the restricted scenario achieved an average reduction of 13.00±16.39% (min=0.59, 1st Qu.=2.31, median=6.06, 3rd Qu.=17.97, max=67.61). For the unrestricted scenarios, the reduction was 4.04±7.68% (min=0.15, 1st Qu.=0.58, median=1.30, 3rd Qu.=3.82, max=39.40), since there is no restriction imposed on depth and breadth of the forest. As expected, this reduction has more impact on the MIP than it does on the BRKGA.The reduction in the number of demand blocks was huge in both scenarios: 95.96±1.88% of the original number of blocks for the restricted scenarios (min=88.26, 1st Qu.=95.49, median=96.25, 3rd Qu.=97.04, max=98.05), and 95.65±2.69% of the original number of blocks for the unrestricted scenarios (min=85.67, 1st Qu.=95.45, median=96.17, 3rd Qu.=96.98, max=98.05). This fact is mainly due to the concentration of demand blocks in residential buildings and commercial areas. On average, each super block corresponds to 30.97±11.43 original blocks.The instance graphs that result from preprocessing are sparse. In the restricted instances, the number of vertices varies from 717 to 25,690 and the number of arcs from 6917 to 314,229. The graph density, given by 2|A|/(|V|(|V|−1)), has an average of 0.0056±0.0063. For unrestricted instances, the number of vertices varies from 1290 to 27,322 and the number of arcs from 10,224 to 315,330. The graph density has an average of 0.0043±0.0035. Detailed results can be found in Tables B.1 and B.2 in the supplementary material.In Section 6, one can see that the maximum flow problem embedded in the WBNDP is not trivial and, as far as we know, a fast combinatorial algorithm to solve it does not exist in the literature. As commented in Section 6.2, one can solve this flow problem with a linear programming formulation using Constraints (1) and (2), but this approach can be too slow to be used in the decoding procedure. Therefore, in the same section, we presented a fast heuristic, coupled with pumping, to compute the maximum flow. Given a forest, this section studies the effects of choosing one or the other strategy to compute the maximum flow.The first experiment consists of 1200 independent runs of the decoder. For each run a random chromosome was generated and decoding was done twice: once using the heuristic flow algorithm and once using the exact flow algorithm. Then, the proportional difference in the flow values and solution times were computed. The heuristic flow algorithm was able to compute an average of 95.19±2.68% of the maximum flow computed by the exact flow algorithm (min=79.66, 1st Qu.=93.58, 3rd Qu.=96.47, max=100.00). We consider this performance very good even in light of Lemma 1. However, the computing times were extremely different. Since the decoding process is very fast, we chose to compare the number of CPU ticks used by each algorithm. The exact flow algorithm used an average of 2027±2080.42% more CPU ticks than did the heuristic flow algorithm (min=200, 1st Qu.=800, 3rd Qu.=2450, max=15, 100). This means that the exact flow algorithm is three orders of magnitude slower than the heuristic flow algorithm.Fig. 2shows the evolution of the profit as a function of number of iterations and CPU wall-clock time. For this, we used instance re30 and let BRKGA evolve for 100 iterations. In Fig. 2a the X axis represents the number of iterations and, in Fig. 2b, the wall-clock time in s in log scale. The Y-axis represents the scaled profit in both figures (see the definition of scaled profit in the beginning of Section 8.3). The shaded area represents the standard deviation. The red line and dots represent the algorithm using exact flow computation, while the blue squares and line represent the algorithm using the heuristic flow. The green triangles and line represent the utilization of heuristic flow and post-processing. In the experiment with the heuristic flow computation and post-processing, the exact flow was recomputed (followed by pruning) in each iteration. One may note in Fig. 2a that both heuristic and exact flow are able to generate almost the same profit in a given iteration. The post-processing approach performs better than the others since it has a second phase pruning as described in Section 7.3. In terms of running time, one can note in Fig. 2b that the exact flow algorithm obtains about the same profit as the heuristic but using much more time.To compare the algorithms with respect to profit, it is necessary to scale the results since instances can have very different profit values. For each instanceI, letχIbe the set of values of the solutions found forI, andDI=max(χI)−min(χI). The scaling is done by the simple transformationχI′=(x−min(χI))/DI∀x∈χIandDI>0,1otherwise,whereχI′is the set of scaled values. Note that all values are scaled to the range [0, 1].Using this scaling process, Fig. 3shows the distribution of profits for each algorithm. The box plots show the location of the first quartile, the profit median, and the third quartile. The whiskers extend to the most extreme revenue no more than 1.5 times the length of the box. The dots are the outliers. In the bar labels, MS stands for the multi-start algorithm, MIP stands for the exact algorithm using CPLEX and Formulation (3), and BRKGA is the biased random-key genetic algorithm. In the restricted scenario, MIP was able to overcome BRKGA for most small instances on the 1-h experiments and on most small and medium instances on the 5-h experiments. BRKGA presented a small variation in its results, although close to those of the MIP in both cases. MS presented a large variation and its results were the worst. This is due to, mainly, the decoder has no local search procedures (unless the pumping algorithm). This fact just reinforces the importance of the learning mechanism of BRKGA. For medium size instances, BRKGA presented more solid results while MIP showed more variation for 1-h experiments. In the 5-h runs, the results were similar to those for the small instances. For large instances, BRKGA was able to produce very good results when compared to MS and MIP in both cases. In fact, MIP does not produce any results besides the incumbent value generated by the BRKGA short run in large instances considering the limit of 1h. For 5h, only in two instances did MIP improve the incumbent. In the unrestricted scenario, BRKGA presented the best results. In fact, for all medium and large instances, MIP was not able to produce any solution (because of memory issues in building the model).To confirm the results presented in Fig. 3, we tested the normality of these distributions using the Shapiro–Wilk test and applied the Mann–Whitney–Wilcoxon U test, considered more effective than the t-test for distributions sufficiently far from normal and for sufficiently large sample sizes [36,37]. For all tests, we assume a confidence interval of 99%. For small, medium, and large instances, the Shapiro–Wilk tests revealed that no profit distribution fits a normal distribution since the p-values for all tests are less than 0.01. Therefore, we applied the U test which assumes as null hypothesis that the location statistics are equal in both distributions. As several statistical tests were performed, we used a p-value correction procedure based on false discovery rate (FDR) to minimize the number of false positives (Type I error) as indicated by [38].Table 3shows U test results for each pair of algorithms and different instance sizes of the restricted scenario, at a 99% confidence level. The structure of this table is as follows: Each row and column is indexed by one algorithm. Each element in the diagonal (bold) is the median of the scaled profit of the corresponding algorithm. The upper-right diagonal elements are the differences in location statistics for each pair of algorithms. A positive difference indicates that the “row algorithm” has its location statistics higher (better) than the “column algorithm,” and the negative difference is the opposite. The bottom-left diagonal elements are the p-values of each test. We omitted all p<0.01 values, that indicate that the difference is statistically significant for those pairs. We also omitted confidence intervals since for all tests the values lie in these intervals and are very narrow. One can notice that almost all comparisons are statistically significant, confirming the box plot results. The exception is BRKGA and MIP for medium instances using 1-h runs for which the test was inconclusive since p>0.01. MS is significantly worse than the other algorithms except for the 1-h MIP experiments on large instances. Summarizing, BRKGA was better than MIP on large instances and the opposite was true for the small instances. For medium-size instances, both apparently performed in a similar way although we cannot affirm this since p>0.01. For the unrestricted scenario, the statistical test only makes sense for the small instances since for the medium and large instances, MIP did not produce any feasible solution. In this case, BRKGA presented the median of 0.89, MS presented 0.01, and MIP presented 0.40. The tests indicate that all differences are significant, confirming the box plot.Table 4reports the performance of the algorithms. The first column indicates the instance class and the second column is the name of the algorithm. The two large blocks consider experiments limited to 1h and 5h, respectively. Each block has four columns. Column “% Best” represents the percentage of the number of instances for which the algorithm found a best solution; column “% Run” shows a percentage of the number of runs on which the algorithm found a best solution. The two columns under label “Prod. diff.” show, respectively, the average of the proportional difference between the value of the best solution found and the achieved value (%), and its corresponding standard deviation (σ). First, note that MIP presents the same values for % Best and % Run since only one experiment is done per instance. Considering the restricted scenario, MIP found 9 of 10 best solutions, although only one was proved be optimal in the 5-h run. BRKGA found 20% of best solutions in about 10% of the runs. However, the BRKGA results are stable and its solutions are within about 5% of the best. MS did not find any good solution on any instance. For the medium and large instances, the roles of BRKGA and MIP were exchanged on the 1-h runs. However, MIP obtained all best solutions on the medium-size instances when it was given 5h to run. In general, BRKGA did not find best solutions in several runs but presented very good alternative solutions. MIP found many best solutions but its results varied considerably. In the unrestricted scenario, BRKGA dominates MS and MIP since the latter could not solve any instance. BRKGA found the best solutions in 4.16% of the runs. The average proportional difference between the BRKGA results and the best solutions found was 13.94±9.67. For detailed results, please refer to Tables B.3 and B.4 in the supplementary material.One can note that the WBNDP is a problem rich in structure from the point of view of network engineering. Similar to the number of input parameters, a typical output has more than 50 parameters, such as number of pieces of equipment of each type, flows, coverage, costs, revenue, and other metrics besides the network structure itself. In this section, we briefly analyze some of these output parameters considering solutions for the restricted scenario since it is based on real constraints.Fig. 4shows the evolution of revenue (dark blue line with dots), cost (red line with squares), profit (light blue with rhombus), and coverage (magenta dashed line with triangles) for instance re17 for a given run. Revenue, cost, and profit are scaled to the range [0, 100]. Coverage is already represented in this range. One can note as the coverage increases, so does the revenue. This is expected since revenue is a function of traffic volume. Note that while the profit is monotone increasing, the revenue and cost display some bumps. In the close-up figure showed on the top right, one can see that both revenue and cost vary up and down while profit always non-decreasing. Such cases show a phase transition. When both revenue and cost curves are sloped downwards, the algorithm has found a solution that is less expensive using less equipment. In bottom right close-up, note that the profit is constant between iterations 77 and 87, but both revenue and cost have slightly negative slopes.Each tree in the backhaul forest has an average depth of 2.49±0.50. Each node has an average of 1.381±0.76 incoming neighbors which shows that the fan-in limit is rarely reached. Indeed, the average of the maximum fan-in is 3.73±0.64, and for some instances, no pole has more than two incoming neighbors. On average, 48.88±14.32% of the used poles have only Wi-Fi, 19.51±15.42% have only LTE, and 9.22±5.98% have both technologies. In 22.38±6.93% of the used poles, only retransmitters are installed. In only 0.34±0.51% of used poles, can one find a small cell without a retransmitter. Such poles have no neighbors and are linked directly to a FAP or macrocell using fiber.With respect to traffic, Wi-Fi was responsible for an average of 77.28±16.50% of the total covered access traffic while LTE served only 17.14±12.59% of the traffic. The macrocells served only 4.02±6.70% of the traffic. Wi-Fi has shown itself as an important resource to serve the demand due to it large capacity and low cost when compared to LTE and HSPA equipment. The backhaul networks were able to serve, on average, 55.78±16.82% of total demand.In Fig. 5, we show an example which is a small portion of a given region where a backhaul network is to be built. This region has three macrocells represented by small antenna figures. Each light green square represents a set of demand points in a specific block. The average number of demand points is 30 per block, but can reach hundreds of residential and commercial buildings. The dark red squares represent the VRAD/FAPs. The very small dark blue squares represent the utility poles. Fig. 6shows the equipment deployment and the coverage radii. The symbols with small equipment and two antennas represent Wi-Fi equipment while the blue stars represent LTE equipment. The poles with only retransmitters (backhaul equipment) are represented by a parabolic antenna. The brown and blue circles are, respectively, the Wi-Fi and LTE access radii. One can note that some blocks are not served. In particular, some blocks in the upper right-hand side of the figure are not covered. Fig. 7shows the backhaul network. The dashed purple arrows are wireless links, the black solid arrows are fibered links, and the arrows indicate the direction of hte root nodes.In this paper, we proposed a new problem called the wireless backhaul network design problem (WBNDP) which resembles variants of the Steiner tree and the facility location problems. The objective is to build a forest to collect and route wireless traffic. Differing from other problems in the literature, WBNDP uses routed traffic to compute the profit. This traffic is constrained to the network infrastructure with several real-world constraints. We proposed a biased random-key genetic algorithm (BRKGA) to solve the WBNDP. Its decoder relies on building the forest in a bottom-up fashion. We also proposed a mixed integer linear programming model to solve the WBNDP.BRKGA presented solid results with little variation. It was able to overcome the IBM ILOG CPLEX 12.6 using MIP (3), in several medium and large instances of 1-h runs. For longer experiments, BRKGA excelled on large instances. Such results enable BRKGA to be used as an important tool in the planning phase of a wireless backhaul network where, usually fast iterations are required. However, BRKGA also showed itself valuable for longer optimizations, mainly on large instances. The stable results produced by the BRKGA give network engineers a better understanding of the characteristics of an optimal network and makes it easier to modify some assumptions if needed.

@&#CONCLUSIONS@&#
