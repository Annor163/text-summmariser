@&#MAIN-TITLE@&#
Collision free region determination by modified polygonal Boolean operations

@&#HIGHLIGHTS@&#
An algorithm to determine the collision free region is proposed.The collision free region is a useful tool for cutting and packing problems with irregular items.Degenerated elements (edges and vertexes) represent local compaction situations.The collision free regions determines the presence of local compaction for the current item.

@&#KEYPHRASES@&#
Cutting and packing problems,Boolean operations,

@&#ABSTRACT@&#
Cutting and packing problems are found in numerous industries such as garment, wood and shipbuilding. The collision free region concept is presented, as it represents all the translations possible for an item to be inserted into a container with already placed items. The often adopted nofit polygon concept and its analogous concept inner fit polygon are used to determine the collision free region. Boolean operations involving nofit polygons and inner fit polygons are used to determine the collision free region. New robust non-regularized Boolean operations algorithm is proposed to determine the collision free region. The algorithm is capable of dealing with degenerated boundaries. This capability is important because degenerated boundaries often represent local optimal placements. A parallelized version of the algorithm is also proposed and tests are performed in order to determine the execution times of both the serial and parallel versions of the algorithm.

@&#INTRODUCTION@&#
Cutting and packing problems involving irregular shapes arise in a wide variety of industries, including shipbuilding, garments, sheet metal cutting, plastics and shoe manufacturing. These problems usually consist in placing a number of irregular items into one or more containers in such way that the layout is the most efficient possible; all items are assigned and do not overlap. The two-dimensional stock cutting problem was shown to be NP-hard and is therefore intrinsically difficult to solve.Bennell and Oliveira  [1] showed that the manipulation of items and containers’ geometry is a key point to determine whether a layout is feasible or not. Several approaches to ensure that, in the resulting layout, items do not overlap and fully fit inside the container have been proposed in the literature. Adamowicz and Albano  [2] chose to nest items into simpler shapes in which the interference can be more easily calculated. Babu and Babu  [3] approximated the container and the items by grid squares represented by a matrix. Lee et al.  [4] used direct trigonometry to determine the interference among items and the container. Recently, the nofit polygon (NFP) has been used by several researchers  [5–9] to ensure feasible layouts.The NFP is the set of feasible locations for one polygon with respect to another polygon, such that the polygons do not overlap. Feasible locations are required for most of the solutions to two-dimensional packing problems, and also for other problems such as robot motion planning. Different approaches to generate the NFP have been proposed in the literature. Minkowski sums were proposed by Ghosh  [10], and were later applied to cutting and packing problems by Dean et al.  [11] and Bennell and Song  [12]. Agarwal et al.  [13] compared different algorithms of convex subpolygon decomposition, such that the Minkowski sum can be directly determined for each convex subpolygon pair. Li and Milenkovic  [14] decomposed the items into star-shaped polygons. Burke et al.  [15] proposed an orbiting algorithm in which the movable item slides along the fixed item.When sequential placement of items is adopted, the placement heuristic must take into account previously placed items, as well as the container in order to obtain a feasible layout. The concept of collision free region emerges from this heuristic, and it represents the set of translations that, when applied to the movable item, places it in the interior of the container without colliding with the already placed items. The collision free region is determined by unifying the NFPs determined by the movable item in respect to the already placed items.The NFPs union must be made through non regularized Boolean operations, in which degenerated edges and vertexes are considered. A degenerated edge represents a sliding fit (in which the item position is constrained in all but one direction) and a degenerated vertex represents an exact fit (in which the item position is fully constrained by its surroundings).Gomes and Oliveira  [16] evaluated the point intersections between NFPs and selected the intersection points that are not internal to any NFP and, simultaneously, internal to the inner fit polygon. Such an approach cannot classify the vertexes in conventional boundary, sliding fit and exact fit. The vertex classification can be made by analyzing the vertex neighborhood with appropriate rules. Martins and Tsuzuki  [9] used regularized Boolean operations to determine the collision free region, thus ignoring exact and sliding fit configurations.Here, an algorithm to determine the collision free region is proposed. The paper is structured as follows. The concepts of NFP and collision free region are defined in Section  2. Section  3 explains the importance of determining the collision free region degenerated elements, using specific non-regularized Boolean operations. Section  4 shows the proposed algorithm. The proposed algorithm was implemented in two versions: serial and parallel. Finally, computational results are presented and conclusions are drawn.In this section, the collision free region and its primitive components, the nofit and inner fit polygons, are defined.The NFP represents a set of translations of an item and is mathematically represented by a set of vectors. For a better understanding of the NFPs properties, the set of translations of an item are represented by polygons in the plane. Every item has a reference point that can be internal or external to it. The NFP represents the set of forbidden translations that, when applied to the item, moves the reference point to the interior of the NFP, as shown in Fig. 1. For an itemP, which is a closed data set, leti(P)be its interior,∂Pbe its boundary andc(P)be its complement.Definition 2.1The NFP induced by itemPito itemPj, noted asΥ(Pi,Pj), is the set of translation vectors that, when applied toPj, makes it collide withPi. Thus,(1)Υ(Pi,Pj)=i(Pi)⊖i(Pj)={v→|∃a∈i(Pj),a+v→∈i(Pi)}.Another way to define the NFP is  [8](2)Υ(Pi,Pj)=i(Pi)⊕(−i(Pj))={(v−w)|v∈i(Pj),w∈i(Pi)}.The NFP can be obtained by the Minkowski sum algorithm  [13], which can be calculated very efficiently for convex polygons. The Minkowski sum result of two convex polygons is a convex polygon built from the original polygon edges sorted in counterclockwise order. Non-convex polygons can be decomposed into convex polygons in a preprocessing step, as the transformations applied (rotations and translations) do not affect such decomposition.Definition 2.2The Minkowski sum of two polygonsPiandPj, notedPi⊕Pj, is defined as the set of points{O+v→+w→|O+v→∈Pi,O+w→∈Pj}.Definition 2.3The opposed polygon for a given polygonPj, noted as−Pj, is defined as the set of points−Pj={O−w→|O+w→∈Pj}.The opposed polygon is obtained by inverting the signal of all the coordinates of the original polygon. From the above definitions, one can see that(3)i(Pi)⊖i(Pj)=i(Pi)⊕(−i(Pj))meaning that the NFP is produced by the Minkowski sum of the fixed item with the opposed item to be placed.An important property is thati(Υ(Pi,Pj))represents colliding placements.∂(Υ(Pi,Pj))andc(Υ(Pi,Pj))represent feasible placements.The inner fit polygon is another important frequently used concept, which is derived from the NFP and represents a set of translations for the placement of items inside a containerC. The inner fit polygon can be computed by sliding an item along the internal contour of the container  [5] (see Fig. 2).Definition 2.4The inner fit polygon induced by containerCto itemPj, noted asΛ(C,Pj), is the set of translation vectors applied toPjthat leaves it inside the container. Thus,(4)Λ(C,Pi)=c(c(C)⊕(−i(Pi)))={v→|∀a∈i(Pi),a+v→∈C}.An important property is thatc(Λ(C,Pi))represents invalid placements.∂(Λ(C,Pi))andi(Λ(C,Pi))represent feasible placements.Consider a containerCand a set of already placed itemsP={P1,…,Pn}, as shown in Fig. 3. A new itemPn+1, will be placed inside the container without colliding with the already placed items. The feasible set of translations for itemPn+1is given by the collision free region. A similar concept was previously used in robot motion planning  [17, sec. 13.4], and it was originally applied to irregular packing by Martins and Tsuzuki  [18].Definition 2.5Collision free region is the set of all translations that, when applied to a specific item, places the specific item inside a container without colliding with the already placed items.When the container is empty, the collision free region represents all the translations that place the item completely inside the container. In this particular case, the collision free region is the already defined inner fit polygon  [5]. For any given item, the calculation of the inner fit polygon is the first step in the determination of the collision free region.The collision free region for a specific item is determined by removing the NFPs generated by the already placed items, from the inner fit polygon.(5)Π(C,P,Pm)=Λ(C,Pm)⊟⨄Pi∈Pi(Pi)⊖i(Pm)where⊟and⨄are specific Boolean operations to manipulate NFPs and inner fit polygons. It is worth noting that only the NFP interior must be removed from the inner fit polygon (interior and boundary). This is why specific non-regularized Boolean operations are necessary.By analyzing expression (5), it is possible to define at least two possible algorithms to compute the collision free region. In the first algorithm, all the NFPs are removed from the inner fit polygon and, therefore, only difference operators are used. The difference operations considered result in collision free regions. In the second algorithm, the unions of all NFPs are calculated and then removed from the inner fit polygon. The unions of NFPs result in NFPs and, after the final difference operator is applied, the collision free region is obtained. The implementation of the specific non-regularized Boolean operations is not an easy task.In Section  3.1, it is explained that, in this work, to implement robust Boolean operations, the intersections between segments are calculated with finite precision. The difference between regularized and non-regularized Boolean operations is explained in Section  3.2. Section  3.3 shows an example in which the regularized union misses some degenerated edges. Section  3.4 shows some necessary characteristics of the non-regularized union and difference Boolean operators. Section  3.5 explains the data structure used.Boolean operations over polygons have the problem of lacking robustness. They face numerical instability and theoretical difficulties during geometric computations. These difficulties occur in boundary evaluations involving ill-conditioned geometric intersections  [19]. There is a great amount of research on robust geometrical representations and computations. In the context of floating point arithmetic, a thresholdϵ>0is used to compare two numbers. Hoffmann  [19] presented the incidence asymmetry problem in which a vertex can be incident to another vertex but not vice versa, and the incidence intransitivity problem, which considers three vertexes,a,bandc, wherea=bsince|a−b|<ϵ,b=csince|b−c|<ϵ, buta≠c, since|a−c|>ϵ.Bentley and Ottmann  [20] used finite precision to achieve robust algorithms for intersecting line segments. Agarwal et al.  [13] used CGAL to implement the Minkowski sum algorithm with exact rational numbers, and they reported execution times that range from a few seconds for shapes involving a small amount of concavities, and up to twenty minutes for highly irregular shapes. Hu et al.  [21] used interval arithmetics to ensure robustness. Wallner et al.  [22] showed that interval arithmetic is not geometric in the sense that it does not give exact error bounds. Several researchers used finite precision to implement Boolean operations over polygons  [23,24], which was adopted in this work, too.Conventional polygons are expected not to contain isolated points or lines. The regularization of a point setA,r(A), is defined byr(A)=∂(i(A)). Sets that satisfyr(A)=Aare said to be regular  [25]. Some combinations of polygons do not quite satisfy the regularity concept. Consider, for instance, the case shown in Fig. 4. According to the ordinary definition of intersection, the intersection between the two polygons consists of a rectangular polygon plus a degenerated edge. The Boolean operation over conventional polygons needs to preserve the regularity property. The regularized intersection is defined asA⋂∗B=∂(i(A⋂B)), where⋂denotes the ordinary set operation. In the literature, several proposals to implement regularized Boolean operations were proposed [23,24,26–28].The collision free region cannot be determined using regularized Boolean operations because it will miss eventual degenerated elements that represent local minima for the packing problem. Fig. 5(a) shows a critical example in which four rectangular items are already placed and a fifth rectangular item is to be placed. The reference is the central point of the movable rectangular item. This example shows the difference between regularized and non regularized unions. Fig. 5(b) shows the union of the four NFPs, represented by a rectangle with two internal degenerated edges. In this case, the degenerated situation refers to a situation in which the item can slide within a segment. If regularized union is applied to the four NFPs, the two degenerated edges are lost (see Fig. 5(c)).This section explains how to modify regularized Boolean operations to correctly implement the specific non-regularized Boolean operations which can manipulate NFPs and collision free regions. Implementations of regularized Boolean operations over conventional polygons have the following steps  [23,24,26–28]: intersection determination, classification of boundaries and collection of appropriate boundaries to compose the result.Fig. 6shows two conventional polygonsAandBwith their boundary orientations. The intersections between the conventional polygons are determined and the edges are divided. The intersection determination is a common module in all types of Boolean operation implementations  [23,24,26–28]. New vertexes are created at the intersecting positions and the intersecting edges are divided in both conventional polygons. Subsequently, vertexes and edges must be classified.The vertexes of a conventional polygon are classified as internal, external and on boundary. The classification of edges must consider the case in which two polygons share an edge. The shared edge may be in opposed orientations on the original polygons or coincident orientations. Consequently, the edges of a conventional polygon can be classified according to four attributes: internal, external, coincident shared and opposite shared. Fig. 7shows the classifications of the all edges for the example described in Fig. 6.The collection of the appropriate edges occurs differently depending on the Boolean operation type: subtraction or union. This module is responsible for determining which edges from the original conventional polygons will be used and which will be discarded. The edges can be used to define a conventional boundary or to define a degenerated element. The rules to define a conventional boundary are the same as for regularized Boolean operations. New rules are defined to create degenerated elements from conventional polygons.The union is exclusively used to combine NFPs, and the subtraction is exclusively used to combine a collision free region with NFP. Fig. 8shows both cases; on the left, the result of the union of two NFPs and, on the right, the difference between a collision free region and an NFP. The edges classified as shared play a very important role, creating degenerated placements in both results. In the union case, opposed shared edges generate internal degenerated edges. In the subtraction case, coincident shared edges generate external degenerated edges.The NFP (represented in Fig. 8 byA⨄B) and the collision free region (represented in Fig. 8 byA⊟B) have two types of boundaries: conventional polygons, and degenerated edges and/or vertexes. Conventional polygons are represented by an oriented sequence of vertexes. In this work, the convention that the left side of the oriented edge is inside and the right is outside is adopted. Degenerated edges that are associated with sliding fits are represented by two vertexes without orientation. Degenerated vertexes that are associated with exact fits are represented by single vertexes. Degenerated boundaries are of special interest as they represent desirable placements that can produce local optima layouts. Degenerated elements are stored in a separated data structure. Thus, the placement solver is capable of accessing these elements whenever necessary.As previously explained, NFPs and collision free region are generically represented by conventional polygons and degenerated elements. The implementation of the specific non-regularized Boolean operations over NFPs and collision free regions is executed in two steps (see Fig. 9). The first step is based on regularized Boolean operations  [23,24,26–28]. Initially, the intersection between conventional and degenerated boundaries are determined. Afterwards, conventional and degenerated boundaries are classified. Selected elements from the classified conventional boundary are selected to compose the result conventional boundary; and, selected elements from the classified degenerated boundary are selected to compose the result degenerated boundary. In the second step, new degenerated elements are created. New degenerated edges can be originated from the conventional boundary classification (see Fig. 8), and new degenerated vertexes can be originated from special configurations. The main modules of the proposed algorithm are explained as follows.As conventional polygons and degenerated elements might intersect each other, all boundaries are simultaneously processed and their intersections are determined. The intersection determination is based on the Bentley and Ottmann sweep line algorithm  [20]. In this work, the sweep line algorithm is modified to simultaneously classify degenerated vertexes and isolated degenerated edges; i.e., determine if degenerated vertexes and edges are internal, external or boundary.In the sweep line algorithm, an imaginary vertical sweep line moves from left to right across edges and vertexes, halting at event points. As the sweep line proceeds, the intersections restricted to the left of the sweep line are determined. There are four kinds of event points: left end points, right end points, crossings and isolated vertexes. The edges and vertexes that intersect the sweep lines1are stored in a listS, which is ordered from bottom to top (see Fig. 10). When a left end point event happens, the edge is inserted inS. In the example of Fig. 10, edgesL2,L5andL6were inserted inS. When a right end point is reached, the edge is removed fromS. In the example of Fig. 10, edgesL1,L3andL4were removed fromS. Adjacent edges are processed to verify if they intersect. If they intersect, the intersection point is determined and the intersecting edges are divided. In the example of Fig. 10, edgesLBandL7intersect and they will be divided. Fig. 11shows the types of intersections that causes edge division. The edges inShave the information to which polygon (AorB) and to which type of boundary (regular or degenerated) they belong. In the example,{L1,L2,L3,L4,L5,L6,L7}are edges from polygonAwith conventional boundaries, and{V1,LA,LB}are elements from polygonBwith conventional and degenerated boundaries.One simple way of finding whether the degenerated vertex is inside or outside a conventional polygon is to test how many times a ray, starting from the degenerated vertex and going any fixed direction, intersects the edges of the conventional polygon. The vertical sweep lines2plays the ray role, initially the degenerated vertexV1fromBis checked to lie onA’s conventional boundary. If the degenerated vertex in question is not on the boundary, the number of intersections is even if the degenerated vertex is outside, and it is odd if inside (see Fig. 10).In the case of a right end point event occurring on a degenerated edge whose left and right end points are isolated, without any contacting edge, such right edge point is classified in similar way as a degenerated vertex. Thus, the intersection module also includes degenerate vertexes and isolated edges classification. Fig. 12shows an example in which all intersecting vertexes are determined.Conventional and degenerated boundaries from polygonAare classified against polygonBconventional boundary, and vice versa. The edges from a conventional boundary can be classified as: internal, external, coincident shared and opposed shared. As degenerated boundaries do not have a direction, they can be classified as: external, internal and boundary.The classification starts by analyzing intersecting vertexes with coincident coordinates, they are collected in a circular listDsimilar to the one proposed by Leonov and Nikitin  [24]. Fig. 13shows an example in which vertexesA4,B9andB12have the same coordinates. The circular listDcontains all the edges emanating from the coincident vertexes, and they are ordered according to their horizontal angle. If a vertex belongs to the regular boundary, then it has two edges inD; otherwise, it has just one edge. The circular listDis used to determine counter clockwise and clockwise adjacency and to identify coincident edges.Coincident edges have the same vertexes coordinates. For conventional polygon edges, based on both edges orientation, the edges are classified as coincident or opposed shared. For degenerated edges they are classified as boundary. Conventional boundaries have sectors in the circular listD. Edges that are internal to the sector are classified as internal. Special care needs to be taken, because one conventional boundary can have more than one sector inD. The edges that were not classified as internal are classified as external. Fig. 12 shows an example in which all the possible intersections were determined and all the edges were classified as internal, external, coincident shared or opposite shared.The boundary collection step is the one in which the result is finally obtained. It has to deal with two important problems: which edges should be collected and in which order. The first problem is solved by adopting a set of boundary collection rules, which determine the inclusion of edges in the final result. For conventional polygons, the rules were defined by Leonov and Nikitin  [24] and are operation-specific. Consider an operationAopB, in whichopcan be the union or difference operator. A boundary collection rule specifies which label is applied to the edge and to which polygon it belongs (AorB). Also, boundary collection rules determine if the edge will be included with its original orientation or with inverted orientation. Collection rules are also defined for degenerated edges and are naturally equal to the rules of regular boundaries. The only difference is that, as degenerated edges have no orientation, inclusion orientation is not specified. Table 1shows the boundary collection rules for union and difference operators. It can be observed that orientation is not applicable to degenerated edges, so shared degenerated edges are classified as both coincident shared and opposite shared.Fig. 14shows four degenerated edge collection cases for difference Boolean operation. In this case,Ais a collision free region andBis a NFP. As previously explained, a degenerated edge can be classified as internal, external and boundary. The boundary classification can happen with conventional and degenerated boundaries (see Fig. 14(c) and (d)). Situations in which a degenerated edge fromAis internal toB, and where a degenerated edge fromBis external toAdo not create a degenerated edge in the result (see Fig. 14(a) and (b)).Fig. 15shows three degenerated edge collection cases for union Boolean operation. AsAandBare NFPs, the vice-versa situation must be considered. The situation in which a degenerated edge fromAis internal toBdoes not create a degenerated edge in the result. Fig. 16shows five degenerated vertex collection cases for the difference Boolean operation, whereAis a collision free region andBis a NFP. Situations in which a degenerated vertex fromAis internal toB, and in which a degenerated vertex fromBis external toAdo not create a degenerated vertex in the result (see Fig. 16(a) and (b)). Fig. 17shows four degenerated vertex collection cases for union Boolean operation, whereAandBare NFPs. The vice-versa situation must be considered. The situation where a degenerated vertex fromAis internal toBdoes not create a degenerated vertex in the result.The need to adopt a specific collection order in the conventional boundary is justified by the need of obtaining valid oriented contours in the result. If edges have been collected randomly, a new step should be added, in which edges are sorted for obtaining a valid oriented contour. By appropriately choosing connected edges, the final result is a valid connected oriented contour. This suggests that the collection should follow the oriented contour of one of the inputs, in which all the edges are connected and correctly oriented. When an intersection point is encountered, a decision has to be made in order to proceed to the correct contour. A new set of boundary collection rules is then defined, called jump rules  [24]. According to these rules, when an intersection point is found, the next edge to be collected is the first in counter-clockwise order that follows the boundary collection rules. As mentioned, counter-clockwise adjacency can be determined by using circular listD(see Fig. 13). Degenerated edges are also contained in this list, but they should be ignored in the jump rules, as a conventional boundary is being collected. The collection of the degenerated boundary is very straightforward. As there is no connection between degenerated edges or vertexes, they can be directly included in the result if they obey the boundary collection rules (see Figs. 14–17).Possibly the most significant difference between regularized and non-regularized Boolean operations algorithms is that, in the latter, additional checking must be performed to determine if new elements should be included in the result boundary. Such elements are always degenerated edges or vertexes. In regularized Boolean operations algorithms, boundary edges from the result are always found in the input boundaries. If degenerated boundaries are to be processed separately, the result of a non-regularized Boolean operations algorithm can have degenerated edges which were not contained in the input degenerated boundaries. Furthermore, degenerated vertexes can also only exist in the final result. To determine whether a new degenerated edge will be created, a rule similar to a boundary collection rule is checked. The edge is then included in the degenerated boundary (see Fig. 18).While the creation of degenerated edges follows the same procedure as the collection of the regular boundary, checking for new degenerated vertexes is a more complex task. Degenerated vertexes arise from the crossing of edges, more specifically, crossing where no edges follow boundary collection rules, including the one regarding the creation of degenerated edges. This is justified by the fact that all the intersecting vertexes are part of the final result. They are usually an endpoint of a collected edge or a degenerated edge and the only exception is when none of the edges that have the intersecting vertex as its endpoint are collected. Fig. 19(a) and (b) show two cases of vertex creation for the union Boolean operation and Fig. 19(c) and (d) show two cases for the difference Boolean operation. Other possible cases can involve more or less crossing edges; however, the generation rule is the same, i.e. no edges must follow the boundary collection rules. It is important to note that degenerated vertex creation should not be checked alongside jump rules, as the latter occurs on intersections in which one edge is already included. Table 2shows the creation rules for the union and difference operations.Degenerated boundaries classification and collection are processed in a different module. Degenerated edge creation is only possible for conventional boundary coincident edges, and it is thus processed in the conventional boundary module. On the other hand, degenerated vertexes can be originated from any crossing vertex; hence, all the intersections must be checked and thus it does not fit in a single module. The resulting degenerated boundary is composed of degenerated edges collected from conventional boundary edges and degenerated vertexes and edges collected from input degenerated boundaries.Collision free region determination is performed using a sequence of NFPs as input. Eq. (5) shows the necessary operations to be performed. In this work; the collision free region is calculated according to three different implementations. Considering thatPis a queue andnis the number of items in the queue. The first implementation is shown in Algorithm 1; it only consists of difference operators, as the collision free region is determined by serially subtracting every NFP from the inner fit polygon (see Fig. 20). The first implementation has no parallelization.The second implementation is an algorithm in which all NFPs are serially united and then subtracted from the inner fit polygon, shown in Algorithm 2. Union and difference operators are used in this implementation, and there is no parallelization (see Fig. 21). The union of all NFPs is defined as the obstructed region, as it represents all the forbidden translation for a given item, given a set of already placed items.The third implementation is a parallel algorithm to calculate the obstructed region described in Algorithm 3. In this algorithm, union operations are processed in parallel. Initially, all NFPs are determined and pushed in queueR. Each thread pops two NFPs, the NFPs are united to define an obstructed region, and the obstructed region is pushed back at the end of the queue. Just one thread accesses the queue at a time. If the queue does not have two obstructed regions, the threads that finished the union operation are kept in an idle state until the queue has enough obstructed regions. The procedure is repeatedn−1times, wherenrepresents the total number of NFPs, until the queue has just one obstructed region. At this moment, the threads are killed and the collision free region is determined by subtracting the obstructed region from the inner fit polygon. Fig. 22shows a example of parallel collision free region determination using the proposed algorithm. All horizontally aligned operations are performed in parallel. Finally, to obtain the collision free region, the obstructed region is subtracted from the inner fit polygon.

@&#CONCLUSIONS@&#
The collision free region concept is defined and non regularized Boolean operations are shown to be necessary to correctly determine it. Three different algorithms can be defined to determine the collision free region: one based exclusively on difference operations, and the other based on union and difference operations. One algorithm that uses union and difference operations can be parallelized (UD).The collision free region has two types of boundaries: conventional boundary and degenerated vertexes and edges. A robust non regularized Boolean operation algorithm using finite precision is proposed in order to compute the union between NPFs and the difference between a collision free region and a NFP. The proposed algorithm robustly determines conventional boundaries, degenerated vertexes and degenerated edges.The parallelized algorithm was implemented and tested. Execution times for serial and parallelized algorithms were measured and the advantage of the parallelized algorithm was only observed in problems with a larger number of items.