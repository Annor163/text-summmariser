@&#MAIN-TITLE@&#
Single chains to represent groups of objects

@&#HIGHLIGHTS@&#
Chain codes representations are applied to binary objects.Concatenation of the chain codes is achieved.Each object can be recovered without loss of information.Context-mixing algorithm is applied to the single chain.Greater compression levels are obtained.

@&#KEYPHRASES@&#
Single chains,Chain codes,Contour shapes,Compression,Context-mixing,

@&#ABSTRACT@&#
A chain code is a common, compact and size-efficient way to represent the contour shape of an object. When a group of objects is studied using chain codes, previous works require to obtain one chain code for each object. In this paper we assign a single chain to a group of objects, in such a way that all the properties of each object of the group can be recovered from the single chain. In order to achieve higher levels of compression, we propose a lossless method, that consists of representing a group of objects by means of a single chain, and then to apply a context-mixing algorithm. Regarding other methods of compression of the state-of-the-art, our experiments demonstrate that the best compression performance is achieved when our lossless method is applied. In this case more than 15% of a better compression level is reached.

@&#INTRODUCTION@&#
A chain code is a common and compact way to represent a contour shape.The “Freeman chain code”, proposed by Freeman in 1961 [1], is known as F8 chain code (F8 for short). It is composed of eight directions and travels through the center of the pixels of a contour shape on the basis of eight connectivity. Each movement direction is codified using a symbolα∈{0,1,2,…,7}in counter clockwise direction (see Fig. 1).On the other hand, F4 chain code (F4 for short) travels through the edges of the pixels of a contour shape using four connectivity. A movement direction is codified using a symbolα∈{0,1,2,3}(see Fig. 2). It is also known as a crack code because it covers the contour shape along edges of border pixels [2–6].In 1999, Bribiesca [7] proposed the vertex chain code, denoted by VCC. Among its most important features, VCC is composed by the symbols0,1and 2. It has some information between the contour shape and the inner part of the object. This code represents the changes made of a contour shape by computing the number of affected pixels (see Fig. 3).Sánchez-Cruz and Rodríguez-Dagnino [8] proposed, in 2005, the 3OT chain code (3OT for short). They compared 3OT with F4 and obtained a better result thanks to the use of the symbols0,1and 2 to label the changes generated in relation to orthogonal directions. 3OT has the same number of symbols than VCC, however it is composed of 3 vectors to codify the contour: reference, support and change. The symbol 0 represents no changes between reference and support, 1 represents a change equal to reference and 2 represents a change in contrary sense of the reference (see Fig. 4).Relied on F8, also in 2005, Kui and Žalik [9] proposed a new chain code, that we called here AF8 chain code (AF8 for short). This code is based on changes obtained with every pair of F8 code vectors when following the contour, i.e. every vector of change in the contour is compared with the previous one, and depending on the angle, a symbol is assigned (see Fig. 5). AF8 was compared with F4, F8, VCC and 3OT[10], and the results showed that AF8 reported more advantages when using the Huffman algorithm. However, in 2009 the combination 3OT-Arithmetic coding [11] performed better compression levels than AF8-Arithmetic.FromF4,VCC,3OT,F8and AF8 other chain codes have been derived. The derived codes are obtained when combining the symbols that appear in the contours, making a probabilistic model to modify the number of bits required to store the coded contour shape. For example,E−VCC,V−VCCandC−VCCchain codes were proposed in [12]. TheE−VCCchain code was obtained by considering that VCC uses two bits to represent three symbols. TheV−VCCchain code arises by considering a variable-length of VCC. TheC−VCCchain code is based on applying the Huffman algorithm on the VCC code-symbols. On the other hand, theM−3OTchain code was proposed when considering groups of symbols of 3OT[13], whereas MDF9 chain code was proposed by considering the AF8 patterns in pieces of discrete straight lines of the contour shapes [14]. Recently, NAD chain code was introduced in [15] and obtained more compression levels in [16]. It is a variation of AF8, where instead of using the symbols0,…,7, the authors use four symbols grouped as follows:0,2,310,311,312,301,300and 1 (and labeling the angles according to Fig. 6).The AAF8 chain code is the newest basic code (it is not derived from another known code), introduced in [17]. AAF8 chain code is composed of three vectors (two angles), in which, regarding the reference vector, a symbol of change direction is given, independently of the support vector direction. It is considered in a basis of eight connectivity. Table 1shows the basic and the derived codes.NAD is the latest chain code that surpasses the compression levels of the previous codes. We have compared our method with it. However, 3OT and AF8 are also worthy to be compared because they are very close to the NAD compression ratios, according to recent obtained results by Žalik et al. [16]. From these works, it can be observed that looking for better modifications of basic chain codes, together with the help of information theory, we can obtain a better compression performance. Of course, we must take into account that compression is also related to recognition, in the sense of being able to recognize redundancy in the information given by the geometry of the objects.In order to complete the comparisons, we also made our implementations using F8 and F4, because they are the classical chain codes used in literature.All the chain codes above mentioned have the common particularity that they were designed to represent a contour shape of an isolated object. However, to achieve even higher compression levels, we propose to change the paradigm, instead of handling objects with isolated chains we now represent groups of objects using a single chain. The idea is simple: we concatenate the chain codes of each contour shape of the group. In general the concatenation of chains is always possible, and in order to recover the single chains that form the concatenated chain, it is not necessary to have more information, like the length of each single chain and the position of each object.The purpose of the paper is to be able to transmit and maintain the shapes without loss of information from an original repository. Often the object repositories are given in different files, which can be numerated to sort the different objects. However, to save memory storage space, the set of objects can be placed in a single file, making sure the information on the form is unchanged, keeping it in a minimum bounding rectangular frame. As we demonstrate in this work, we avoid all extra storage thanks to the characteristics of the chain codes of objects. However, there are other interesting applications that do not need such an extra storage information, as we explain in Section 4.4.Of course, if a real scene want to be recovered, the positions of objects should be taken into account, then an extra storage information has to be spent, like the distance between objects. This distance can be stored between chain as the number of pixels among starting pixel between each pair of objects.Since Freeman proposed the first chain code [1], a considerable amount of papers using chain codes for a wide variety of issues in different fields have appeared. On the one hand, they have been studied theoretically to propose unique descriptors and to reach high compression levels for binary objects [1,7–18]. When a group of objects is studied, authors of these previous published articles usually encode object by object.On the other hand, chain codes have been used to real applications, like map representations and compression [2,19,20], to look for dominant points [21–24], to extract and to encode edges from 3D scenes [25–27], for analysis and shape recognition [28–30], for recognition of skeletal structures [31], and more recently for analysis and document compression [32–34].For recognition tasks, obtaining a unique descriptor for each object that permits us object classification is a challenge. Perhaps this conviction has made the researchers do not propose until now concatenating the descriptors for groups of objects.The novelty of our proposed method is to no longer consider isolated objects. As we have demonstrated our method facilitates keep such descriptors into a single chain, to recover subsequently object by object (for further analysis and recognition tasks if it is desired).Some clues that strings can be better compressed with longer strings come from the following previous works: for example, Sahami and Shayesteh [35] used a technique based on neural networks to find high compressions, they noted that the compression ratio increases linearly with the image size. Also, in [11] was noticed that compression rates increase while contour perimeter also increases.The contents of this work are as follows. In Section 2, some preliminaries are given. In Section 3 the concept of a chain code for a contour shape is extended to a group of objects by using only a single chain. Experiments and results exploiting the idea of using a single chain code for a group of objects are given in Section 4. Finally, in Section 5 some conclusions of this paper are given.In this section we introduce some concepts, algorithms and notations used throughout this work.An alphabetAis a set of symbols. A chain C of length n over an alphabetAis a sequence of n elements ofA, given by next expression:C:=c1c2⋯cn,ci∈Afor alli=1,…,n.If there is not ambiguity hazard about the alphabetA, we just say that C is a chain.LetC:=c1⋯cnandT:=t1⋯tmbe chains of length n and m, respectively. We define the concatenation of C and T, denoted byC⋅Tor CT, as the chain:CT:=c1⋯cnt1⋯tm.Let Γ be a contour shape of an object. A chain code of Γ is a chainC(Γ)that represents (encode) the contour shape Γ, this means that it is possible to recover (decode) the contour shape Γ using only the information of the chain codeC(Γ).The contour shape of an object can be seen as a set of vectors [17], so, a chain code is a representation of a set of vectors. As a consequence, all the basic codes can be handled as vector components, VCC inclusive, as it is explained also in [17].For data compression, several coding schemes have been used. One of the most popular is the Huffman algorithm [36], which is simple and easily described in terms of a prefix-code tree, generated from the probability that a symbol has in a message, giving a short code to the most frequent symbol and a larger to that which appear with lower probability. For a code of size n the algorithm runs inO(nlog⁡n)time, however the algorithm has the disadvantage that the code lengths must be rounded to a whole number of bits.Another of the most known code-schemes is the Arithmetic algorithm [37]. It can be computed by updating the probabilitiespiof each symbol of a message in an interval between 0 and 1, dividing the interval in proportion to the probability distribution for each input symbol, narrowing the interval by a factor ofpion each symbol i. This procedure is carried out iteratively until reading the last symbol.Another algorithm that obtains high compression rates is PPM (Prediction by Partial Matching) [38]. Although is slower to run, it has better compression performance than Huffman and Arithmetic. The main idea of PPM is to consider previous symbols (context) of a message to generate a conditional probability of the current symbol. Because the probability distribution tends to be high it can be used by Arithmetic algorithm to obtain a bit sequence, working much better than Huffman algorithm for this approach.On the other hand, context-mixing algorithm is related to PPM in the sense that the compressor is divided into a predictor and an Arithmetic coder, except that it uses a binary alphabet to simplify encoding and model merging [39].Particularly, PAQ archivers are a family of lossless data compressors based on context-mixing, and they are distributed as free software under the GNU general public license.Among the PAQ archivers, one of them is calledPAQ8L, which is used for lossless compression of files with alphabets of few symbols. Throughout the work we usePAQ8Lbecause we want to apply it to chain codes, which come from alphabets of size2,3,4or 8.The Huffman and Arithmetic algorithms have been widely used to prove the binary object compression methods [12,9,19,14,10,13,11,8]. Relied on RLE and MTFT transform to decrease the chain code entropy, Žalik and Lucak [15], and Žalik et al. [16] reached the best rate compression to isolated binary objects. On the other hand, methods for document image compression have been carried out in [33] and [34], achieving better compression performance than JBIG2 and DjVu by a wide range, wherePAQ8Lwas utilized to compress the resulting file text of such proposed methods.In this section we explain the coding and decoding of contour objects. To encode a group of N objects, the idea is simple but powerful: create a single chain formed by the concatenation of the chain codes of each object, i.e., to obtain the single chain S that represents the N objectsΓ1,…,ΓN, encode eachΓiand obtain the chain codesS1,…,SN. Finally, define the single chain that represents all the objects asS:=S1⋯SN.Example 3.1The F4-single chain of Fig. 7isSF4:=F4(a)⋅F4(b),whereF4(a)=000101111212122232330100033222323003andF4(b)=0010103001212121123322112332330303.Observe that given N arbitrary chains, it is always possible to create the concatenation S from these N chains, but in order to recover the original objects, it is necessary to have more information, as the length of each individual chain and the position of each of them in S. However, we avoid this extra storage exploiting the characteristics of the chain codes.As we mentioned in Introduction, all the basic codes can be handled as vector components. This means that as a consequence, when a chain code is decoded, we obtain the sequence of vectors that represents the contour shape.Lemma 3.2Let C be a crack code of a contour shape Γ and letv1,…,vnbe the vectors obtained when C is decoded. There exists a unique vectorvisuch that the end ofviis the beginning ofv1.ProofThe existence is easy, it isvn. Assumev1is the vector from the point(0,0)to the point(1,0). Letvibe a vector such that the end ofviis the point(0,0), the beginning ofv1. The beginning ofvi+1is the point(0,0).vi+1is not the vector to(−1,0)neither(0,1)becausev1is the leftmost top vector of the contour shape.vi+1is not the vector to(1,0)or(0,−1)because in this casevi+1=v1orvi+1=−vi, but vectors of a contour shape don not overlap. This means there is not avi+1vector and thusvi=vn.  □Remark 3.3The contour shapes that we are considering in this work are always closed curves because they come from a real object, so, for this work, the previous Lemma is also valid for chain codes that are not crack codes, i.e., for codes that cover the contour shape traveling through the center of the pixels. The proof of this fact is similar.The pair of previous results say that if we have a single chain S as the result of coding N objects, then, in order to recover the N objects, we need to decode the chain S as a simple chain code, until the end of one vector is the beginning of the first vector, in this moment we have completed an object.The next algorithm is used to decode the single chain that represents the group on N objects.Algorithm 3.4Decode N objectsInput A single chain S that represents N objects.OutputN objectsΓ1,…,ΓNrepresented by S.1.-Letv1be the first vector found when S is decoded as a chain code.Definej:=1,i:=1and the set of vectorsV:={v1}.i:=i+1. Letvithe following found vector when S is decoded as a chain code.V=V∪{vi}.DefineΓj:=Vandj=j+1.Eliminate the symbols of S used to find the object V.Else The setsΓjrepresent the objects encoded by S.Observe that condition Until guarantees that an object was found, because by Lemma 3.2, the first found vector with this property should be the end of an object.

@&#CONCLUSIONS@&#
As we know, in literature, a number of interesting articles about methods to represent, separately, contours of binary objects have appeared. Authors have carried out an analysis of length and compression performance. In this paper we have used the following strategy: a single chain that represents all the objects of a image has been found and then it has been applied the context-mixing algorithm.We have proved that it is possible to save and recover the information of all the objects in a single chain.Our experiments demonstrate that the combination of a single chain with 3OT andPAQ8Lachieve up to25%of efficiency, in compression, in comparison with managing chain codes representing each object of the image, and 15.7% better compression regarding the state-of-the-art.As a consequence of single chains, giving one more step to what has been done so far in the literature to encode individual objects, we have proposed an new method to improve compression efficiency when considering groups of objects that appear in an image.