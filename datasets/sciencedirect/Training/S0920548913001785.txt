@&#MAIN-TITLE@&#
End-to-end policy based encryption techniques for multi-party data management

@&#HIGHLIGHTS@&#
We describe novel approaches for controlling data in distributed, multi-party contexts.Sticky policies cryptographically bind data to policies constraining how it may be used.Secret sharing techniques can be used to improve scalability.Such approaches are useful in a variety of business contexts, especially involving sensitive data.

@&#KEYPHRASES@&#
Cloud,Sticky policy,Policy enforcement,Privacy,Secret sharing,

@&#ABSTRACT@&#
We describe a data management solution and associated key management approaches to provide accountability within service provision networks, in particular addressing privacy issues in cloud computing applications. Our solution involves machine readable policies that stick to data to define allowed usage and obligations as data travels across multiple parties. Service providers have fine-grained access to specific data based on agreed policies, enforced by interactions with independent third parties that check for policy compliance before releasing decryption keys required for data access. We describe alternative solutions based upon Public Key Infrastructure (PKI), Identity Based Encryption (IBE) and advanced secret sharing schemes.

@&#INTRODUCTION@&#
Lack of trust about privacy and security practice is at present a key inhibitor in moving to cloud models [1]. When sharing and storing information in the cloud, additional assurance is needed that appropriate security and privacy measures have been taken by Cloud Service Providers (CSPs). This problem is also present more generally as service provision chains become more global, complex and dynamic. Both business consumers and citizens are requiring more control over the usage and sharing of their personal and confidential information, as this is handled within potentially complex service provision chains.Current commercial solutions primarily focus on traditional, back-end security controls (e.g. access control) on the data, once this data is stored on the service provider side. Privacy and data control aspects, such as fine-grained definition and enforcement of user's preferences and policies (on how to process data, to whom to disclose data, various obligations on data transformation, deletion, etc.), are rarely implemented unless in a coarse-grained way (e.g. via macro opt-in, opt-out options). These solutions usually do not scale across multiple control domains: users' preferences and policies on how to handle data are not necessarily propagated and enforced across a chain of data disclosures within multiple Cloud Service providers. This means that users have little end-to-end control about the destiny, usage and management of their data, once disclosed to a Cloud Service Provider.To address this issue, we suggest a variety of solutions based on sticky policies, where policies and constraints are attached to data as it is transmitted and stored within the cloud. Sticky policies are strictly associated with users' data and drive access control decisions and enforcement of privacy and confidentiality.Our solutions ensure that data disclosed within cloud services is used, accessed, processed, stored and shared, etc. based upon agreed (potentially fine-grained) policies and constraints and degrees of assurance are provided by independent (trusted) third parties about compliance to these policies. Mechanisms using data encryption, driven by policies, can be used to ensure degrees of (fine-grained) data protection; Trusted third parties (called Trust Authorities (TAs)) can be used to provide compliance checking, enforcement and audit capabilities. Our solutions provide a practical solution to enhancing user control and providing accountability within the cloud, removing business barriers in the sense that organizations might be willing to move more of their sensitive operations to the cloud model.We believe that approaches based on cryptography are suitable to make significant progress towards providing the required level of control and accountability on personal and confidential data. This paper illustrates how this can be achieved by focusing on three solutions, one is general using ordinary Public Key Infrastructure (PKI), a second uses Identity Based Encryption (IBE) [2] and a third is based upon secret sharing [3]. In the PKI-based approach, it is assumed that all the stakeholders have certified public/private key pairs from trusted Certificate Authorities (CAs). In this context, these CAs can play the role of Trust Authorities. Policies are bound to data by encrypting the data under a symmetric key that a sender and receiver conditionally share based on fulfilment of policies, and sticking the data to the policing using public-key enveloping techniques. If IBE techniques are used instead for this binding then it means that a third party needs to check certain properties (as specified within the sticky policy associated with data) at the time of decryption, before an IBE decryption key for that data is released. These IBE techniques are conceptually equivalent to the PKI once, however they leverage a different cryptographic schema. An alternative approach consists in leveraging secret sharing techniques: in this case, the parties involved in the data management solution are enrolled in several, cascaded secret sharing schemes. By recreating the shared secrets, the parties can compute encryption keys required to access managed data. Instead of needing to a priori define all trusted authorities that will supervise access to the managed data and to manually enable each such Trusted Authority for each asset, the customer only has to provide a share of the secret sharing scheme. The resulting approach has more manageable computation, storage, and transmission bandwidth requirements as compared to prior solutions, and yet can still provide fine-grained control over access and usage of customer data. In general, the most appropriate solution will vary according to the context and trust models involved.This paper focuses on a Cloud Scenario consisting of multiple Service Providers, end users and enterprises. In this scenario, both end-users and employees within enterprises make active use of services in the Cloud, as shown in Fig. 1.Cloud service providers can use services provided by other providers in the cloud, in order to supply the required capabilities. For example, a storage service provider might use third-party data back-up services and information lifecycle management capabilities and part of their offering.In this context, personal information, confidential data, etc. can flow from one service provider to another one, due to a chain of service interactions and dependencies. For example, a user might disclose personal data to a CSP, during a business interaction and/or the provision of a service. The CSP might then need to interact with other service providers in the cloud, in order to provide the desired service. This might require sharing some of the personal data.We consider situations, such as within health service provision, access to applications and services in the cloud (storage, computing, etc.), and so on, as shown in Fig. 1, where a customer (that might be a citizen, employee or an enterprise) indeed needs to reveal personal and even sensitive information in order to receive a service, but wishes to control the way in which that information is used.In this paper we describe our approach to provide this control capability as well as degrees of assurance. We want to:•enable users to express their (privacy and security) preferences and policies when disclosing their personal data;provide mechanisms to protect data whilst it is shared across parties;provide mechanisms to increase the level of accountability.We define a system and mechanisms to enable the protection of data to be shared by a user (or service) with service providers, based on agreed policies and privacy preferences. The user can be actively involved in the selection of multiple, interchangeable services called Trust Authorities (TAs), that will track and audit for the fulfilment of these policies.Our solutions use sticky policies associated with data to dictate how to handle data at the receiver side. Our schemas involve three types of parties: Cloud Service Providers (CSP), which store and process the user's data, Trusted Authorities (TA), which audit that the CSPs handle the user's data according to the sticky policies defined by the user, and the users themselves, who own the assets and define access restrictions in sticky policies.We aim to enable the users to define policies which are preferences or conditions about how that information should be treated. The policy governs the use of associated data, and may specify for example the following:---The purposes of using data (e.g. for research, transaction processing, etc.).That data may only be used within a given set of platforms (with certain security characteristics), a given network or a subset of the enterpriseOther obligations and prohibitions (allowed third parties, people or processes; blacklists; notification of disclosure; deletion of data after a certain time)A list of trusted TAs (potentially the result of a negotiation process).The policy may be represented in any convenient format.The basic mechanisms of the proposed sticky policy solutions, also shown in Fig. 2, are as follows:•In order to be able to more easily interpret and enforce end user policies, instead of offering free expression of policies from end users, their preferences and policies are defined within a framework imposed by organizations. There are different ways of achieving this: one mechanism is that SPs offer a ‘smart notice’ containing the list of supported (macro) policies and TAs, where these policies relate to access control and obligation behaviours supported by the organization, and the end user can choose from these [4].A user (customer) — interacting with a SP — can select the granularity of how policies apply to items or specific subsets of personal data to be disclosed (ranging from coarse grained to fine-grained) and customize related preferences (e.g. notification preferences, period of time after deletion, set of agreed purposes, list of parties not to interact with, etc.).The user may have the option to select TAs that are to be trustedBased on the above selections, a client-side component supports the creation of sticky policies and their association to data, i.e. the bundling of policies, preferences, data and TAs. In other words, the client-side component deals with the packaging of data along with selected parameterized policies and TAs.The user can select the option to refer to secured data (e.g. personally identifiable information (PII)) by another third party (this is a storage provider that stores the encrypted data) rather than passing the encrypted data directly to the SP.Encrypted data along with sticky policies is sent to the SP.In order to gain access to the data in clear, the SP needs to interact with one of the selected TAs (based on availability). During this interaction the SP has to assert its willingness to fulfil the customized, sticky policies. This creates an audit trail that can be afterward used by the user and TA — in case of policy violations and misbehaviour.The SP will allow a predefined period of time for connection with the TA. There may be swapping between TAs based on need.Only after satisfying the requirements expected in that context from its role, can the TA decide to release the information that would enable the decryption of data.The SP will then be able to decrypt and access the data — either in the case where the data was directly disclosed or in the case where just a reference to it was provided (in this latter case, the SP will need to fetch the data from a storage provider).The various interactions and policy-related statements exchanged by a Service Provider with a TA are logged and audited by the TA. This provides forensic evidence in case of violations e.g. data misuses or policy violations. We believe that by introducing this additional step (to the process of releasing data, potentially in a complex chain of interactions) we increase the level of accountability of the various Service Providers and provide more assurance to the end-users that their data will be managed and processed according to their preferences and policies.The next three sections describe in detail how the conceptual schema shown in Fig. 2 can be implemented by using PKI and IBE cryptographic techniques as well as extended by using a secret sharing approach. These approaches may be summarized as follows:•In Section 5, the ‘sticky policy’ is mapped to an IBE encryption key, in order to encrypt the data (payload) and bind it to the desired usage policy.For the mechanisms described in Section 4 and Section 6, the sticky policies are instead linked to the data (payload) by means of digital signatures: after the user defined the policy for a certain access, they calculate a hash value of both the payload and the sticky policy, and sign it with their private signature key. For this step, a Public Key Infrastructure (PKI) is required. The user then encrypts the payload with a randomly generated keyK, using a symmetric encryption algorithm such as AES. The user then transmits the encrypted payload together with the cryptographically linked policies to the SP. If the SP needs access to the data, they need access toK.oThe mechanism described in Section 4 solves this requirement by attaching a copy ofKto each artefact, where the copy was encrypted once with each public key of each TA, binding access to the artefact to a specific set of TAs being available, thus requiring an a priori definition of all TAs. This works well for a static TA set, but scales badly if the TA set changes. This is likely to be the case in dynamic, multi-party cloud and service provider contexts.The mechanism described in Section 6 takes an alternative approach where the parties involved in the data management solution are enrolled in several, cascaded secret sharing schemes, implementing complex access structures based on combiner driven secret sharing schemes. This has advantages in terms of easier, more scalable security and key management.In this approach the data is associated to the policy using public key enveloping techniques similar to Public Key Cryptography Standard 7 (PKCS 7). Fig. 2 shows the template interaction schema used in this solution. Three entities are involved: a user (U), a service provider (SP) and a trusted authority (TA). In the case of Fig. 2, the SP is a special type — a cloud service provider (CSP).The actual implementation of this schema when using PKI-based solution is shown in Fig. 3.The user has a unique identity written as IdU which is indicated in the certificate of the user's public key, denoted by PubU. The corresponding private key is PrivU.Similarly, the TA has a unique identity written as IdTA, which is indicated in the certificate of the TA's public key, denoted by PubTA. The corresponding private key is PrivTA.Likewise, the SP has a unique identity written as IdSP, which is indicated in the certificate of the SP's public key, denoted by PubSP. The corresponding private key is PrivSP.There are two options for the policyKeyMapping function that sticks the policy to the key that is used to encrypt the data, and thereby can be thought of as performing the sticky policy functionality. The first option is signcryption, and the second is encrypt-then-sign. These correspond to the following functions respectively:policyKeyMappingPrivU,PubTA,K||policy=SigencPrivU,PubTA,K||policyorpolicyKeyMappingPrivU,PubTA,K||policy=UVwhereU=A.EncPubTA,KpolicyIdUandV=SigPrivU,U||IdTA•“||” denotes concatenationS.Enc() denotes a symmetric encryption algorithm, e.g. specified in ISO/IEC 18033-3A.Enc() denotes an asymmetric encryption algorithm, e.g. specified in ISO/IEC 18033-2Sig() denotes a signature algorithm, e.g., specified in ISO/IEC 14888 or ISO/IEC 9796Sigenc() denotes a signcryption algorithm, e.g. specified in ISO/IEC 29150.The protocol has the following stages, as shown in Fig. 3:(1)Generation of the policy by the user, together with a symmetric keyKused to encrypt the data (for efficiency, a symmetric key is used rather than an asymmetric key).Generation of the message from the user to the SP. The message is arranged aspolicy,policyKeyMappingPrivU,PubTA,K||policy,S.EncKPIIwhere PII is the data string containing personally identifiable information, to which the user would like to stick the policy. If the SP wants to make sure that this message is freshly created, we can insert a standard challenge-response process in it. In that case, step (2) is replaced by two sub-steps:1.SP sends a nonce to U, say nSP,U replacesK||policy withK||policy||nSP in the policyKeyMapping function.The same change (fromK||policy toK||policy||nSP) should be taken in steps (3) and (5) of Fig. 2.Generation of the message from SP to TA, which involves passing on some of the information sent to it by the original sender.The TA carries out policy checking, potentially including challenges to the SP. The SP may have to provide signed statements about its policies.If all checks are fulfilled, the TA will release the shared key: it generates a message from the TA to SP, which involves encrypting the symmetric keyKwith the SP's public key. By these means SP can get access toKand then decrypt the PII.This approach works well with a single TA. However, once there is more than one TA involved, the policyKeyMapping() function must be computed and the result must be transmitted and stored for each TA and for each record stored in the SP as follows (with PubTAidenoting the public key of Trust Authority TAi):policyKeyMappingPrivU,PubTAi,K||policy=SigencPrivU,PubTAi,K||policyorpolicyKeyMappingPrivU,PubTAi,K||policy=UV.Fig. 4shows a variation of the above approach in which a cloud storage provider is used to store the encrypted PII. This entity stores encrypted data associated with a reference to that data. No PII is exposed to this SP as it will not know the encryption key. Instead of the obfuscated data being passed around the cloud, an encrypted reference to that data is used.Fig. 5illustrates a cryptographic mechanism by which this may be provided. We use two symmetric keys (although variations on this approach may be used):K2is used to encrypt the PII andK1is used to encrypt the reference to the PII (e.g. a URI). The client component sends S.Enc(K2, PII), i.e .the PII encrypted withK2, to one (or more) such cloud storage parties. The user sends S.Enc(K1, refPII) to the CSP, i.e. the reference to the PII encrypted withK1, together with a sticky policy bindingK1to the policy and A.Enc(PubTA,K2). The CSP then forwards on the sticky policy to the TA, together with the keyK2encrypted with the TA's public key. If the TA is satisfied that the SP meets the policy, it sendsK1andK2encrypted with the SP's public key, by which means the SP can deduceK1andK2and hence is able to decrypt the reference to the PII and then the PII itself.The PKI-based approach discussed in this section offers mechanisms to protect the data when in transit as well as degrees of accountability and assurance, thanks to the logging and auditing processes carried out by the involved Trusted Authorities.Some complexity is introduced by having to manage the various PKI cryptographic material, certifications and the overall lifecycle. If multiple TAs are used, this approach requires both users and CSPs to manage multiple sets of keys, encryption processes and information.In addition there is a clear separation between the “sticky policy” associated to the data — that is purely a textual description of constraints — and the cryptographic keys associated to protect the data. This requires additional effort to manage both keys and policies in a consistent way. The next section illustrates the Identifier-Based Encryption schema that is comparable to the PKI-based approach but addresses and simplifies this later point by using “sticky policies” directly as the “encryption key” for the associated data.As an alternative approach, identity-based encryption (IBE) mechanisms can be used as the basis for provision of sticky policies. Identity-based encryption (IBE), e.g. [2], is a cryptographic schema where any kind of string (including a name, role, terms and conditions, etc.) can be used as a public encryption key. The generation of the corresponding IBE decryption key can be postponed until later than the encryption process. A trusted authority (TA) can generate this decryption key on the fly, under specific circumstances. Although this approach is conceptually similar to the PKI approach described above, the key difference is that we map a ‘sticky policy’ to an IBE encryption key. The role of the TA is expanded to perform a policy checking role (as it checks for the integrity and trustworthiness of the requestor's credentials and their IT environment before releasing the decryption key) and an auditing role (as it logs and audits disclosures of confidential data). The original idea of using IBE for sticky policies in key management was proposed in [5]. We now show an extended solution about how IBE-based sticky policies can be used to protect content in cloud computing environment.A protocol of this approach involves three entities: a user (U), a service provider (SP) and a trusted authority (TA). As it is the same as the PKI solution in the previous section, the SP is a special type — a cloud service provider (CSP). These three entities have cryptographic keys as follows:1.The TA has a unique identity written as IdTA, which is indicated in the certificate of the TA's public key, denoted by PubTA. The corresponding private key is PrivTA, which is a master key for an identity-based key generation service and allows the TA to generate identity-based private keys for the user and SP.The user has a unique identity written as IdU, which is used to compute the user's public key denoted by PubU. The corresponding private key is PrivU, which is generated by the TA, i.e.:PubU=Id−pubkeyGenerationIdUPubTAPrivU=Id−privkeyGenerationPrivTAPubU.The SP has a unique identity written as IdSP, which, along with a policy, is used to compute the SP's public key, denoted by PubSP. The corresponding private key is PrivSP, which again is generated by the TA.The policyKeyMapping function that sticks the policy to the SP's key that is used to encrypt the data and thereby can be thought of as performing the sticky policy functionality is achieved via generation of the SP's public key PubSP and private key PrivSP by:PubSP=Id−pubkeyGenerationIdSPPubTApolicyPrivSP=Id−privkeyGenerationPrivTAPubSP.The protocol has the following stages:(1)Generation of the policy by the user, together with a symmetric keyKused to encrypt the data (for efficiency, a symmetric key is used rather than an asymmetric key).Generation of the message from the user to the SP. The message is arranged aspolicy,IdSP,IdTA,IdU,IBEPubSP,PubTA,K||policy,IBSPrivU,IdUIdTAIdSP||policy,S.EncKPII,where PII is the data string containing personally identifiable information, to which the user would like to stick the policy. If the SP wants to make sure that this message is freshly created, we can insert a standard challenge-response process in it; similar to the PKI solution in the previous section.Generation of the message from SP to TA, which involves passing on some of the information sent to it by the original sender.The TA carries out identity checking, policy checking and the user's signature verification, potentially including challenges to the SP.If all checks are fulfilled, the TA will release the decryption capability to the SP: it generates a message from the TA to SP, which involves PrivSP. By this means SP can decryptKand then decrypt the PII.We recommend a standardized identity-based encryption scheme and symmetric encryption scheme specified by ISO/IEC. The references are as follows:•Id-pubkeyGeneration() and Id-privkeyGeneration() denotes identity-based key generation algorithms, e.g. specified in ISO/IEC 18033-5.IBE() denotes an identity-based encryption algorithm, e.g. specified in ISO/IEC 18033-5.S.Enc() denotes a symmetric encryption algorithm, e.g. specified in ISO/IEC 18033-3.This approach works well with a single TA. However, depending on applications, more than one TA may be involved. For example, there may be two separated TAs: TAU and TASP, where the first creates the identity-based private key PrivU for the user and the second creates the identity-based private key PrivSP for the SP. Furthermore, the role of either TAU or TASP can be split into multiple TAs, in order to enhance trust and/or flexibility. An implementation example of multiple TAs for IBE can be found in [6]. The next sections discuss how we envisage addressing the issue of having to deal with multiple TAs.Instead of encrypting the key material for each TA with the public key of the respective TA, as an alternative solution we suggest the definition of a set of secret sharing schemes to augment the usage of public key cryptography as the cryptographic backbone of the scheme. In contrast with public key cryptography, secret sharing schemes are a designated multi-party cryptographic tool, which addresses the original problem more efficiently and also with a potentially significantly higher level of security.Secret-sharing schemes form a particular group of multi-party key establishment protocols [7] that enable distribution of control or trust in critical activities. The central idea of a secret sharing scheme is that a key (in our case, the key used to encrypt the data) would be divided into v pieces (the “shares”), such that any pre-defined combination of them can be used to reconstruct the whole original key but using any set of shares that is not on the pre-defined set of combinations will not help to reconstruct the key. In other words, secret sharing schemes are used to distribute a secret among a set of participants such that only authorized subsets of participants can recreate the shared secretK, while unauthorized subset does not learn anything (in an information theoretic sense) aboutK. The set of all authorized subsets is called the scheme's access structure. There are many different secret sharing schemes, implementing a variety of access structures. As an example, Shamir's Threshold Scheme [3] is a threshold-based secret sharing scheme, which allows any subset of at least r of the v participants in the scheme to recreate the secret.In Shamir's (r, v) threshold scheme, a key (in our case, the encryption keyKused to encrypt the data) is divided into v pieces (the shares), such that any r of them can be used to reconstruct the original keyK, but using any number of shares less than r will reveal no additional information (in an information theoretic sense) useful to reconstructK.When employing secret sharing schemes with threshold access structures, for the sticky policy scenario, the secret sharing scheme could be designed to require shares from the SP and at least one TA to recoverKand decrypt the PII, while at the same time providing some redundancy among TAs.Secret sharing schemes are most suitable in situations where multiple TAs are employed and key management should be simplified, or where individual TAs might not be fully trusted and hence the other TAs should be used to audit and check what they are doing.In this section, we will define a secret sharing scheme based approach that supports multiple verification and control instances and facilitates key management. Conventional secret sharing schemes have been developed for a number of years [3]. Our approach uses a combiner driven secret sharing scheme [8], where the combiner needs to contribute at least one share for each recreation operation. This behaviour significantly increases the security level, as it is sufficient to destroy the combiner to prevent any further access to the information. Further, as the combiner needs to be involved in any recreation operation, the combiner's audit log gives strong evidence at the point in time, including evidence on the participant set that has been used for each recreation of the keyK. This behaviour is enforced by making the combiner part of each (minimal) set of participants that is authorized to recreate the keyK. To achieve this, the combiner receives one or more sets of shares, which it needs to contribute during recreation. The shares that are assigned to the combiner are chosen such that the combiner's shares by themselves are not sufficient to recreate the secret. It is shown in [8] that, by altering the combiner's shares, it is possible to keep the keyKand existing participants' shares constant, even if the participant set changes, as well as to change the keyKwithout altering the participant's shares. These properties significantly distinguish combiner driven secret sharing schemes from conventional secret sharing schemes.In the approach described in Section 4, service providers are not involved in decryption, whereas in this scheme both TAs and service providers are shareholders.There can be benefits of having new roles for service providers, depending upon the model and context. In the cloud use case, the combiner can be (within) a tamper resistant device which can be physically located either on the TA side (this would conform to the use case described above), or on the service provider side. For multiple TAs, and to prevent the combiner becoming a bottleneck, the combiner can be cloned without lowering the scheme's security level. As indicated earlier, the combiner does not hold enough information to independently recreate the shared secret. It always requires the shares of an authorized subset of participants to perform the recreation. Nevertheless, protecting access to the cloned combiner instances prevent authorized set of participants to recreate the secret “in the wild”, without creating an audit trail.With combiner driven secret sharing, the user's key can be changed in case it was compromised without the need of re-encrypting the entire cloud data store. Moreover, the scheme described in Section 4 binds access control to the public key of TAs. Hence, enrolling or disenrolling TAs in the original scheme would require extending each record in the cloud data store with a dataset, or finding and removing a dataset from all records respectively. In the secret sharing scheme based approach we describe in this paper, such global changes are not necessary: enrolment and disenrollment operations can be conducted by a simple combiner operation that does not affect the data store.We consider a multi-party cloud interaction scenario as a significant example, as shown in Fig. 1 and as described in Section 4, with one trusted user, one or more service providers, and one fully trusted Trust Authority as participating entities.For now, we assume that there is only one user, the user is fully trusted, and hence knows the keyKto encrypt and decrypt content. We will also discuss scenarios with multiple Trust Authorities or only partially trusted Trust Authorities in a later section.Besides the simple threshold access structure described by Shamir, secret sharing schemes can be used to implement more complex access structures, allowing implementation variants with different security levels. We define an authorized subset in an access structure to be a set of participant that is allowed to recreate the secret. We call an access structure where each superset of an authorized subset is authorized to recreate the secret a monotone access structure.We will use two types of monotone access structures and implementation thereof:–The threshold access structure, implemented in a modified variant of Shamir's polynomial based (r, v) threshold secret sharing scheme driven by a combiner, as described in [8].A simplified construction for (r, v) threshold schemes in the special case r=v. While originally described by Karnin et al. [9], we will use a slightly modified variant as described by Stinson [10].The basic access structure is defined on the participant set T=TU∪TTA∪TCSPwith:–The user, defined as tuin the set TU={tu}The TA, defined as tTAin the set TTA={tTA}The CSPs, defined in TCSP={tCSP,1,…,tCSP,c} where c is the number of participating CPSs.The basic access structure Z1, shown in Fig. 6, is defined such that either the user alone, or both the TA and at least one CSP must participate during the recreation. We define the access structure Z1 through a combined set of sub-access structures Z1,1, Z1,2, and Z1,3. Each sub-access structure represents a secret sharing scheme, which protects an intermediate secret. The intermediate secrets are eventually used to compute the shared secretK. For the sub-access structures Z1,1, Z1,2, and Z1,3, the functions representing a secret sharing scheme that implements these access structures would be f1, f2, and f3 respectively. The elements of the resulting secret sharing scheme can be represented by a graph. Fig. 5 shows a representation of the access structure using the graph based access structure definition schema introduced in [11]. The function f3 represents a secret sharing scheme where one or more of the participants tCSP,ccan recreate the secret. The resulting intermediate secret is used as a share in f2, where it can be used in combination with a share tTAto recreate another intermediate secret. Function f2 requires that both the intermediate secret computed by f3 and the share tTAare present. To recreateK, the share is used as an input parameter in f1. The function f1 is designed so that the secretKcan be computed if either the intermediate secret resulting from f2, or the share tuare present. We refer to [11] for a detailed discussion of graph-based access structure definitions and an overview of common functions.Note that this schema also works for non-monotone access structures, if, for instance, the user and one CSP alone cannot recreate the secret key.The secret sharing scheme functions are defined on the set of possible shares S as the functions' input, and the set of possible secret keys G as the functions' output. For simplicity, we assume S=G.The participants' shares are defined as:–suas the share of the user tu∈TUsTAas the share of the TA tTA∈TTA{sCSP,1,…,sCSP,c} as the share of the CSPs in TCSP, where sCSP,idenotes the share of CSP tCSP,ifor 1≤i≤c.Function f1 is trivially defined as:f1s=s∀s∈S.As we do not employ a combiner with f1, the user's share is equal to the keyK.Function f2 is an implementation of Stinson's (v, v) scheme [10]. We convert the input share tTAand the result of f3 computed on a CSP share tCSP,iinto a binary representation of equal length, and define ⊕ as the binary XOR operation. The function f2 is then defined as:f2s1s2=s1⊕s2∀s1,s2∈S.Function f3 is a combiner driven threshold secret sharing scheme as described in [8]. The combiner is collocated with the TA, which implies that a CSP is not able to recreate the shared secret of f3. Instead, the CSP i sends the share tCSP,ito the TA for the recreation operation. The CSP can take advantage of the existing public key infrastructure, and encrypt the share tCSP,iwith the TA's public key PubTA.The combiner allows the disenrollment of CPSs from the access structure Z1,3 as well as the enrolment of new CPPs to Z1,3 without changing the result of the recreation operation computed on f3. To achieve this, the combiner holds a set of shares which enables it to control the recreation process. Depending on the shares the combiner contributes, it can even influence the recreation result, that is, the combiner can be designed such that with different participant sets, different keys Kjare recreated.After the TA received the keyKfrom the user, it creates shares sCSP,j for each CSP, 1≤j≤c. A share is a pair sCSP,j=(xj,yj)∈Fp×Fp,1≤j≤c, where Fpis a finite field of prime order p, with |b(p)|=|b(K)|, and b(p) and b(K) denoting the binary representation of p andKrespectively.The TA chooses the yjfor the participant shares randomly and the xj≠0 pairwise distinct. Then, the TA interpolates a polynomial g3 through the points described by the CSPs' shares (xj,yj), and the random intermediate secret keyK3=(0,y0). This is similar to Shamir's threshold scheme [3], with the difference of the desired degree of g3 being deg(g3)=c, where c is the number of CSPs. To create a (1,c) threshold scheme, the TA computes a set of c combiner shares sc,3,i=(xi,g3(xi)),1≤i≤c and stores these combiner shares in the combiner. Afterwards, for all tCSP,j∈TCSP, the TA encrypts the share sCSP,jof CSPjwith the CSP's public key PubCSPj, and distributes the result to CSPj.As all shares and (recreated) secrets are in S, the TA can transform the function to:s2=s1⊕f2s1s2.The TA then computes the TA share sTAas:sTA=0,g30⊕K.Finally, the TA destroys its copy ofK.Note that, although random shares provide the highest level of security, all shares that have been chosen randomly can also be set to a non-random value in case the CSP wants to use a custom, pre-defined share. Shares can also be changed during runtime by re-computing the combiner sharessc,3,i=xi,g3xi,1≤i≤caccordingly.The function f3(s),s∈S is defined as the interpolation function for g3, recreating the polynomial g3 from the provided share s and the combiner shares sc,3,i,1≤i≤c.Updates of a CSP's share require the TA to have either access toK, or to recreateK=tTA⊕f3(sCSP,i) with the help of the CSP tCSP,ithat requested the share update. In other words, CPSs can request a share update from TA without the user's interaction, and the TA can enforce a share update on the user's request.If the user requests a share update for a CSP, and the new share is not communicated to the CSP, the CSP has effectively been disenrolled and can no longer participate in key recreation operations.Adding new CSPs requires the user to provide the keyK, which allows the TA to interpolate the polynomial using the combiner shares. With knowledge of the polynomial, the TA can compute a new share for the newly enrolled CSP, and distribute it as indicated above.After the TA destroyed the local copy ofK, there are not enough shares available in the TA or the combiner to recreate the polynomial f3, and so the keyK. A CSP tCSP,icannot recreate f3(sCSP,i), because the CSP does not have access to the combiner shares, which are crucial to do the required polynomial interpolation.See [8] for a detailed discussion on the scheme's security, as well as enrolment, disenrollment, and update operations.The possible storage protocol for one TA has the following stages, as shown in Fig. 7. Note that the protocol can vary, for instance, if the shares are computed by the user instead of the TA:(1)Generation of the policy by the user, together with a symmetric keyKused to encrypt the data (for efficiency, a symmetric key is used rather than an asymmetric key).Generation of the message from the user to the SP. The message is arranged aspolicy,SigPrivU,K||policy,S.EncKPIIwhere PII is the data string containing personally identifiable information, to which the user would like to stick the policy. If the SP wants to make sure that this message is freshly created, we can insert a standard challenge-response process in it. In that case, step (2) is replaced by two sub-steps:3.SP sends a nonce to U, say nSP,U replacesK||policy withK||policy||nSP.Sending the KeyKto the Trust AuthorityGeneration of the combiner share(s) SCand the share STAthrough the TA, transferring the combiner share(s) SCto the combiner, and retaining the TA share STAin the TA's secure data storeGeneration of the share SCSPand transferring it to the CSPDestruction of the original and intermediate key materialK, SC, STAand SCSPused during computation in the TA's volatile memory, but retaining the TA share STAin the TA's secure data store.The basic retrieval protocol for one TA has the following stages, as shown in Fig. 8:(1)Generation of the message from SP to TA, which involves passing on some of the information sent to it by the original sender, and the CSP's share SCSP.The TA carries out policy checking, potentially including challenges to the SP. The SP may have to provide signed statements about its policies.If all checks are fulfilled, the TA will release the keyK: the TA sends the shares STAand SCSPto the combinerThe combiner recreatesK.The TA generates a message from the TA to SP, which involves encrypting the symmetric key K with the SP's public key. By these means SP can get access to K and then decrypt the PII.Unacceptable business disruptions and delays may be caused if some of these entities (specifically the TAs) might not be available online all the time or have limited connectivity. The solution described in Section 4 can be extended to support degrees of resilience to failure due to communications issues (e.g. delays) between CSPs and TAs. Again, the “client component” at the user side generates a session key K and encrypts the user's PII with it. When the user wants to authorize a CSP to access their PII, they send to the CSP:•policy: the selected policies and ordered list of authorized TAsthe encrypted PII (using the symmetric keyK)for each of the authorized TAs, a sticky policy that includes a digital signature generated by the user on the policies and TAs with his/her private key PrivUand the symmetric keyKencrypted with the TA's public key.As shown in Fig. 9, when the CSP needs to access the user's PII, it sends the relevant sticky policy to one of the authorized TAs listed in policy — received from the user.The TA then checks the signature on the policy to verify that policy is authentic: if it is authentic, the TA further verifies that the CSP fulfils the conditions specified in the policy. If they are verified, the TA provides the CSP with the symmetric keyK. The CSP can then use its public key to decrypt the symmetric key and decrypt the PII.In the above case, the user needs to select: (1) the policies specifying the conditions under which his PII can be accessed and (2) the Trusted Authorities (TAs) authorized to verify whether an entity fulfils the policies. Next in this section we describe an alternative model where the user implicitly specifies the authorized TAs by including them in a secret sharing scheme access structure.Fig. 10illustrates a possible protocol where the user computes the shares. The “client component” at the user side generates a session keyKand encrypts the user's PII with it. When the user wants to authorize a CSP to access their PII, they send to the CSP:•policy: the selected policies and ordered list of authorized TAsthe encrypted PII (using the symmetric key K).Compared with the mechanism described above based on the PKI case, it is no longer necessary for the user to also send a sticky policy that includes a digital signature generated by the user on the policies and TAs with his/her private key PrivUand the symmetric keyKencrypted with the TA's public key PubTAi for each of the authorized TAs. Instead, the user sends a signed copy of the sticky policy, and shares the keyKusing a secret sharing scheme where the authorized TAs are members of authorized subsets.When the CSP needs to access the user's PII, it sends the relevant sticky policy to one of the authorized TAs listed in policy — received from the user, and includes the CSP's share.The TA (e.g. tTA,1) then checks the signature on the policy to verify that Policy is authentic: if it is authentic, tTA,1 further verifies that the CSP fulfils the conditions specified in the Policy. If they are verified, tTA,1 recreates the symmetric keyKand provides the CSP withK, encrypted with the CSP's public keyPubCSP. The CSP can then use its private key to decrypt the symmetric keyKand decrypt the PII.With multiple Trust Authorities being present, and either the user alone, or both at least one TA and at least one CSP must participate during the recreation, the access structure changes as illustrated in Fig. 11for Z2. The access structure Z2 defines sub-access structures Z2,1, Z2,2, Z2,3 and Z2,4 as the access structures of f1, f2, f3, and f4 respectively.We redefine TTAas:TTA=tTA,1…tTA,dwhere d is the number of Trust Authorities.Implementing Z2 requires a secret sharing scheme function that allows recreation of the shared secret if any of the TAs participates in the reconstruction. Implementation of such a scheme is possible with a combiner driven secret sharing scheme, using the function f4 on the binary representation of a TA share (sTA,i, 1≤i≤d) and a combiner share of the TA (sC,TAi, 1≤i≤d) as:f4s1s2=s1⊕s2∀s1,s2∈S.The function f4 requires a TA's share and a matching combiner share:f4sTA,isc,4,TAi=sTA,i⊕sc,4,TAi∀1≤i≤dThe combiner sharesC,TAiof a TA tTA,iis computed such thatf2f4sTA,isc,4,TAi,f3sCSP,i=f4sTA,isc,4,TAi⊕f3sCSP,i=sTA,i⊕sc,4,TAi⊕f3sCSP,i=K.With randomly chosen sTA,i, thesc,4,TAican hence be computed as:sc,4,TAi=K⊕sTA,i⊕f3sCSP,i.As f3(sCSP,i)=f3(K) holds, thesc,4,TAican also be computed as:sc,4,TAi=K⊕sTA,i⊕f3K.Hence, there are two options to enrol a new TA or update the share of an existing TA:1.The user actively contributesK.AsKcan also be computed by a CSP and an already enrolled TA, a CSP and a TA can collaborate to enrol additional TAs. Depending on the business case, this can be an advantage, but it also imposes a security risk. In any case, such an action leaves an audit trail with the combiner of the TA.Note that the TA holds two sets of combiner shares: one for the function f3, which is accessible to the TA for modification, and one for the function f4, which is not accessible to the TA (as an example, the combiner can be designed as a tamper resistant device). However, while each TA must hold the complete set of combiner shares for f3, the TAs should be restricted such that a TA tTA,ionly holds the combiner sharesc,4,TAifor the function f4. While additional shares are not required for the operation of the TA, they could be used by a TA to impersonate other TAs in case the attacking TA ever got access to the share set stored in the f4 combiner.To recreateK, a CSP tCSP,icontacts any TA tTA,jand provides the share CSP sCSP,i, encrypted withPubTAj. The TA then uses the c combiner shares sc,3,k,1≤k≤c for the computation of f3(sCSP,i) as discussed above, and computesKasK=sTA,j⊕sc,4,TAj⊕f3sCSP,i.Enrolment and disenrollment of CSPs, and updates of CSP shares requires access toK, which implies that those operations are only possible with the consent of the user, or of a CSP.The approaches described in Sections 4 and 5, where policies and constraints are attached to data as it is transmitted and stored within the cloud, can suffer from key management issues. Specifically, the approach suggested in Section 4 relies on a PKI infrastructure, delegating a significant amount of trust to trusted third parties (called Trust Authorities (TAs)) that need to provide compliance checking capabilities. Temporarily unavailability of such a TA might create unacceptable business disruptions and delays. The PKI-based scheme solves this problem by adding redundancy through several TAs. With redundant TAs, the PKI becomes hard to manage in practice, as the number of asymmetric PKI operations required in their process scales with the number of involved TAs. In the use case of a detached Cloud Storage Provider (CSP), the schema becomes even more complex. While that approach theoretically addresses the needs of user control and accountability of data access in the cloud, there is still no practical solution for this problem available. The secret sharing scheme based solution addresses this problem by considering an alternative approach using shares, as described in this section. Compared with the PKI-based scheme, storage and key management is easier, for example providing the following gains:–Auditing can be enhanced as neither a TA alone, nor a CSP, can recreate the secret without the TA combiner, leaving an audit log trace — as long as the key K is destroyed properly after usage.The number of policyKeyMapping for each artefact is much lower as it is not necessary to store that for each TA, and so the effort is constant, as compared with the alternative scheme of scaling with the number of TAs.There is still the possibility to only enable a subset of all TAs, because there can be different access structures for each artefact if necessary.The approach of supporting multiple TAs can be adapted to support multiple verification and control: instead of any TA authorizing access (i.e. the OR condition described in the previous section), it could be multiple TAs (i.e. an AND condition). Modifying the access structures so that at least 2 TAs have to participate in the recreation process allows for the CSP to recover K and decrypt the PII, while still providing for some redundancy among TAs and at the same time allow the TAs to audit each other's recreation attempts.Such a setup is most suitable in situations where individual TAs might not be fully trusted and hence the other TAs can audit and check what they are doing. However, we note that the TAs are still trusted to destroy shares (such as, shares from the CSP) as well as the keyKafter a successful recreation. Hence, the TAs are still in a strong trust position, which might require in-depth auditing in case the trust level should be lowered.We suggest using an access structure that either allows the user to access the secret keyK, or requires 2 or more TA shares, and one or more CSP shares to recreate the secret. This access structure is illustrated in Fig. 12for Z3. The access structure Z3 defines sub-access structures Z3,1, Z3,2, Z3,3 and Z3,4 as the access structures of f1, f3, f5, and f6 respectively.The secret sharing scheme used to implement Z3,2 for the CSPs is identical to the function f3 discussed earlier: the CSP sends its share to TA tTA,i,1≤i≤d, and tTA,i, recreates an intermediate result using the combiner driven threshold scheme f3 discussed above.At the same time, the CSP also indicates to TA tTA,j,1≤i≤d and i≠j that a recreation operation is pending with tTA,i. The TA tTA,jwill then send a share of a combiner driven (2, d) threshold scheme to tTA,i, which allows tTA,ito recreate another intermediate result using the secret sharing scheme implemented by the function f5, and then combine the two intermediate results to the keyKusing the function f6.The function f6 is an XOR function that recreates the secret keyKfrom the binary representation of the result of f3 and f5 for any two TAs tTA,i,tTA,jand any CSP tCSP,j:K=f5sTA,isTA,j⊕f3sCSP,k.This implies that the result of the functions f3 and f5 must be constant for all input shares, which is guaranteed by employing a combiner in both schemes.The function f5 is a combiner driven threshold scheme similar to f3 discussed earlier: the user creates shares sTA,jfor each TA, 1≤j≤d. Again, the shares are created as pairs sTA,j=(xj,yj)∈Fp×Fp,1≤j≤d, where Fp is a finite field of prime order p, with |b(p)|=|b(K)|, and b(p) and b(K) denoting the binary representation of p andKrespectively.The user chooses the yjfor the TA shares randomly and the xj≠0 pairwise distinct. Then, the user interpolates a polynomial g5 through the points described by the TAs' shares (xj,yj), and the intermediate secret key K5=(0,K⊕f3(sCSP,k)). The degree of g5 is deg(g5)=d, where d is the number of TAs.To create a (2,d) threshold scheme, the user computes a set of d−1 combiner shares sc,5,i=(xi,g5(xi)),1≤i≤d−1 and stores these combiner shares in the combiner. Afterwards, for all tTA,j∈TTA, the user encrypts the share sTA,jof TAjwith the TA's public keyPubTAj, and distributes the result to TAj.The function f3 is created as described in the previous section. We mention that the enrolment, disenrollment and update operations are carried out in the same way as discussed for f3 earlier.The protocol described above generates a second audit trail with the second TA. By increasing the threshold of f5, this security level can be increased further.As with the scheme described in Section 4, the TA is trusted to reliably destroy the keyKevery time after using it.In the schemes supporting multiple TAs based upon the approach described in Section 4, the core innovation comes from the fact that no TA is irreplaceable, e.g. the customer can select one or more of them (from a trusted list, agreed with the service provider): the service provider will automatically interact with one or more of them based on their online availability, response time, trust relationship and whether multiple verification is required. The principle underpinning the encryption of data with fine-grained policies can be used both to transfer data between parties and for the storage of the data themselves.Our solution is potentially very flexible as it enables a great variety of ways in which interactions could happen. This is very important as we target a cloud environment where multiple interaction models might happen. These include:1.the user disclosing data directly to the CSP (in encrypted form) or the data being accessed via a cloud storage providerthe user deciding which TAs to use, and backup options being in placea potential configuration on the operational mode of the TA, in case encrypted PII data is sent to a cloud storage provider as discussed above. In this case the TA could fetch the encrypted data and send it (encrypted) to the CSP along with the symmetric key, or else just send the encrypted key to the CSP and let the CSP fetch the data from the cloud storage provider.Choosing between these options might be part of an early negotiation phase with the user, or else some or all might be decided in advance by the infrastructure provider.The protocols described above can be combined, for example to allow transmission of data governed by sticky policies along chains of CSPs, and to allow usage of cloud storage providers in combination with allowing choice between multiple CSPs providing a Trust Authority role.The interactions described should not be interpreted as applying only to users representing people, as many interactions occur from machine to machine or from service to “service provider” and the protocols we describe can also apply more broadly to these cases.This solution allows tracing and auditing within the cloud via TAs and enforcement of user preferences by cloud service providers. It is flexible in that different approaches can be used by which the TAs control decryption of the data; this suits a cloud model in that alternative options are allowed in case of unavailability of the TAs, backup TAs, specialized cloud services for storage and avoiding forcing any specific interaction pattern. In addition, the TAs can audit each other.The keyKcan only be recreated with the cooperation of the combiner, that is, the combiner needs to contribute at least one share. For this reason, it is sufficient to destroy the combiner to prevent any further access to the information, which significantly increases the security level. With the combiner involved in any recreation operation, the combiner's audit log gives strong evidence on time and participant set for each recreation of the keyK. This allows keeping the keyKand existing participants' shares constant, even if the participant set changes, and distinguishes combiner driven secret sharing schemes from conventional approaches. Using a combiner driven scheme allows creation of a perfectly secure implementation (see [8] for proof), where none of the participants by themselves has a better chance of finding the secret key than guessing it.In the approaches described in Sections 4 and 5, service providers are not involved in decryption, whereas in the approach described in Section 6 both TAs and service providers are share holders. There can be benefits of having new roles for service providers, depending upon the model and context. In the cloud use case, the combiner can be (within) a tamper resistant device which can be physically located either on the TA side (this would conform to the use case described in Section 4 above), or on the CSP side. For multiple TAs, and to prevent the combiner becoming a bottleneck, the combiner can be cloned without lowering the scheme's security level. With certain extensions to our model, the user's key can be changed in case it was compromised without the need of re-encrypting the entire cloud data store. Moreover, the scheme described in Section 4 binds access control to the public key of TAs. Hence, enrolling or disenrolling TAs would require extending each record in the cloud data store with a Enc(PubTAnew,K) dataset, or finding and removing a Enc(PubTAtoDelete,K) dataset from all records respectively. In our secret sharing scheme based approach, such global changes would not be necessary. Enrollment and disenrollment operations can be conducted by a simple combiner operation that does not affect the cloud data store.The PKI approach described in Section 4 above can suffer from key management issues, which in particular manifest themselves when adding new participants such as trusted authorities, and might unnecessarily disclose and leak keys: Enrolling of new TAs with the original scheme requires a significant amount of computation effort to recompute a key component for each asset that is already stored in the storage provider. Computing this key component requires access to the private, symmetric master encryption key, which makes it necessary to transfer the master encryption key over the network, and give another party access to the symmetric key. Enrolling new TAs within the approach described in Section 4 requires a significant amount of computation effort specifically because each additional TA requires computation of the policyKeyMapping() function for each asset that is already stored in the SP. Computing the policyKeyMapping() function requires access to the private, symmetric keyK, the policy and the PII. Hence, creating this information requires transferring the already protected information from SP to a trusted entity such as the TA, original user, or another trusted third party, and giving that party access to the required confidential key material. Transferring this data can be a security issue, as a single entity will have access to the entire data during the decryption and re-encryption process, as well as all required key material. This operation is highly vulnerable against leaks of data or key material, both during transport, but also during the actual crypto operation which (depending on the amount of data) can take weeks. The required data transfer and re-encryption is also a significant performance and cost factor when enrolling new TAs, making enrollment or disenrollment of TAs de facto economically impossible. The set of cascaded secret sharing schemes described in Section 6 takes advantage of combiner driven secret sharing as described in [8], and so prevents the performance and key management issues of the scheme proposed in Section 4.

@&#CONCLUSIONS@&#
In this paper a novel user-centric data control mechanism has been proposed and explained. This method involves machine-readable policies (defining allowed usage and associated obligations) that are attached to data (or references to data) and travel with it as it passes among multiple parties. We have described various different approaches that can support multiple verification and control. We have also considered how key management can be simplified by means of using secret sharing instead of a public key infrastructure as the cryptographic backbone of the scheme. In contrast to PKIs, secret sharing schemes are a designated multi-party cryptographic tool which addresses the original problem more efficiently and also with a potentially significantly higher level of security.These ‘sticky policy’ techniques are likely to be most suitable in environments where increased trust and protection justify the additional expense, or alternatively to business partners of ‘good willing’ enterprises who might encourage its use. The solutions could be used in a number of business areas but are particularly suitable to enhance privacy protection in sectors like healthcare, where sensitive information is involved, and in the cloud. The mechanisms that are most suitable for a given context will depend upon the trust model involved; in particular, the PKI mechanism is suitable where individual audit authorities are trusted by consumers and service providers to play a key role, whereas the secret sharing mechanism described in this paper is especially suitable for trust models where the parties involved in provision of decryption keys cannot be wholly trusted individually, and so the trust is spread across multiple entities.