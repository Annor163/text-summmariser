@&#MAIN-TITLE@&#
Serial batching scheduling of deteriorating jobs in a two-stage supply chain to minimize the makespan

@&#HIGHLIGHTS@&#
For the scheduling problem with a buffer, an optimal algorithm is developed for solving it.For the scheduling problem without buffer, some useful properties are derived.A heuristic is designed for solving it, and a novel lower bound is also derived.Two special cases are well analyzed, and two optimal algorithms are developed for solving them, respectively.

@&#KEYPHRASES@&#
Batch scheduling,Supply chain,Deterioration,Transportation,Heuristic,

@&#ABSTRACT@&#
This paper investigates the coordinated scheduling problem of production and transportation in a two-stage supply chain, where the actual job processing time is a linear function of its starting time. During the production stage the jobs are first processed in serial batches on a bounded serial batching machine at the manufacturer's site. Then, the batches are delivered to a customer by a single vehicle with limited capacity during the transportation stage, and the vehicle can only deliver one batch at one time. The objective of this proposed scheduling problem is to make decisions on job batching and batch sequencing so as to minimize the makespan. Moreover, we consider two different models. With regards to the scheduling model with a buffer for storing the processed batches before transportation, we develop an optimal algorithm to solve it. For the scheduling model without buffer, we present some useful properties and develop a heuristic H for solving it. Then a novel lower bound is derived and two optimal algorithms are designed for solving two special cases. Furthermore, computational experiments with random instances of different sizes are conducted to evaluate the proposed heuristic H, and the results show that our proposed algorithm is superior to other four approaches in the literature. Besides, heuristic H in our experiments can effectively and efficiently solve both small-size and large-size problems in a reasonable time.

@&#INTRODUCTION@&#
In the current competitive global market, cooperation with the partners in supply chains becomes of increasing importance for decreasing product costs and enhancing competitiveness. The coordination of production and transportation is one of the most significant issues for the supply chain participants. However, how to realize effective and efficient coordination is complicated due to its combinatorial nature, and it has attracted much attention from researchers. Hall and Potts (2003) studied such a complex problem and put forward the concept of supply chain scheduling for the first time. In their work, a variety of scheduling, batching, and delivery problems arising in an arborescent supply chain were considered, where a supplier makes deliveries to several manufacturers and a manufacturer also makes deliveries to customers. Afterwards, increasing studies focused on different scheduling problems in a supply chain. Despite all these studies, some particular features were still ignored in previous related work, such as deteriorating jobs, particular production modes, etc. These features are often inevitable and should be taken into account in a supply chain.The supply chain considered in this paper concerns a typical industrial aluminum profile, where a customer first places orders with an extrusion factory, and then the cylindrical aluminum ingots are processed in this factory, followed by the delivery to the customer. Based on the technology of Internet of Things (IoT), the real-time information of production and transportation can be shared by the members of the supply chain. Therefore, the main operation processes can be considered as a two-stage scheduling model in a supply chain that integrates production and transportation, which are described as follows:(a) In the upstream of the supply chain, a manufacturer (i.e., extrusion factory) processes cylindrical aluminum ingots of the orders sent from a customer on an extrusion machine, which is a batching processing machine that processes cylindrical aluminum ingots for the extrusion process in the pattern of serial batches. Cylindrical aluminum ingots are first preheated in a heating furnace, and then they wait for the extrusion process. During the extrusion process, a mold is required to assemble with the extrusion machine. The extrusion processing times of aluminum ingots depend on their types and the mold's performance at the beginning of the process. The longer the mold processes the aluminum ingots, the worse the performance of the mold is. Therefore, if an aluminum ingot waits for a longer time before the extrusion process starting, then it will take more time to complete the extrusion process. Based on the real production situation, the extrusion processing times of aluminum ingots could be modeled as an increasing linear function of their starting times. The deteriorating rates of all jobs may vary based on their types according to different customers’ requirements. (b) In the downstream, these batches are delivered by a single vehicle from the manufacturer to the customer. In this situation, there are two different scenarios in the manufacturer. We consider the first scenario when there is a buffer for storing the processed batches to be delivered, while there is no buffer in the second scenario. The objective is to minimize the arrival time of the last batch at the customer. The details of the problem are further described in Section 2.In general, the considered problems are related to three scheduling problems, namely the scheduling with transportation in a supply chain, the scheduling with deteriorating jobs, and the batch scheduling with deteriorating jobs. In the following, a brief review is presented on the above three scheduling problems.Much research focuses on the scheduling problems with transportation consideration in a supply chain (Hall & Potts, 2003; Geunes & Pardalos, 2003). Wang and Cheng (2007b) considered the scheduling problem of coordinated production and transportation with machine availability, and the objective was to minimize the arrival time of the last delivery batch. They studied three scenarios of this problem, and a polynomial algorithm and two heuristic algorithms were proposed to solve them, respectively. Zegordi and Nia (2009) studied an integrated scheduling problem of production and transportation in a two-stage supply chain, where the suppliers are distributed in various geographic zones and the vehicles are assumed to have different speeds and transportation capacities. The objective was to minimize the makespan, and a dynamic genetic algorithm was developed to solve it. Steinrücke (2011) studied an integrated scheduling problem of production and transportation in a global aluminum supply chain network. Their objective was to minimize the sum of production and transportation costs, and some relax-and-fix heuristics were developed to solve it. Wang, Grunder, and Moudni (2013) considered a production-delivery scheduling problem for a make-to-order supply chain, which consists of the supplier, the transporter, and the customer. The objective was to minimize the total cost induced by set-up, delivery, and inventory. A precise instance was derived from the general model, and then a heuristic algorithm was presented to deal with it. Ma, Felix, Chan, and Chung (2013) investigated an integrated scheduling problem with shipping information, where the vehicle transport is limited and not available all the time. Their objective was to minimize the earliness and tardiness, which is represented by the sum of storage, shipment and tardiness costs. A two-level genetic algorithm was designed for solving the problem.For the second related scheduling problem considering the deteriorating jobs, there has been much research from a variety of perspectives (Wang, 2007; Wang & Cheng, 2007a). Lai, Wu, and Lee (2012) addressed the scheduling problem under the deterioration function of the logarithm of the job processing times already processed, and the optimal solutions were provided for some single machine problems. Wang, Wang, and Ji (2012) studied a single machine scheduling problem with the effects of deterioration and learning at the same time, and the objective was to minimize the total completion time. An optimal schedule was proved to be V-shaped with respect to the job normal processing times, and three heuristic algorithms were proposed based on the V-shaped property. Wang and Wang (2012) investigated the single scheduling problems with the effect of nonlinear deterioration. They showed that the makespan minimization problem is polynomially solvable under nonlinear deterioration, and the total completion time minimization problem is V-shaped regarding job normal processing times.A few similar scheduling problems with deteriorating jobs and batch scheduling considerations have been studied. Li, Ng, Cheng, and Yuan (2011) investigated a single parallel batching machine scheduling problem with simple linear deterioration of processing times. The objective was to minimize the makespan, and several algorithms were proposed for both unbounded and bounded models. Qi, Zhou, and Yuan (2009) considered several single parallel batching machine scheduling problems. Three different algorithms were designed for minimizing the maximum cost, the number of tardy jobs, and the total weighted completion time, respectively. Miao, Zhang, and Cao (2011) studied the parallel batching scheduling problems with deteriorating jobs. For the case that the jobs have identical release dates, an optimal algorithm and a fully polynomial-time approximation scheme were given for single machine and multiple machines problems, respectively. The serial batching scheduling problem is similar to the group scheduling problem, in which the jobs are previously classified into groups based on the similar production requirements. Recently, many papers are published on group scheduling with deteriorating jobs, including Wu, Shiau, and Lee (2008), Wu and Lee (2008), Wang, Lin, and Shan (2008), Wang, Gao, Wang, and Wang (2009), Zhang and Yan (2010), Yang and Yang (2010), Wang and Sun (2010), Wei and Wang (2010), Huang, Wang, and Wang (2011), Yang (2011), and Lee and Lu (2012), which are compared in Table 1. The major similarity of these two scheduling problems is that the jobs in the same batch or group are processed one after another. However, there are two key differences of them: (1) the machine capacity, i.e., the maximum number of jobs in a batch, should be considered in serial batching scheduling problems, while it does not exist in group scheduling problems; (2) the group scheduling problems have an important assumption that all jobs are pre-classified into certain groups according to the similar production requirements. However, in serial batching scheduling problems, both job batching and batch sequencing should be considered simultaneously.In summary, scheduling problems with serial batching, transportation, or deterioration have been extensively studied separately in recent literature. However, to the best of our knowledge, there is no research result on scheduling models considering these significant features together, which exist in some real production situations. Moreover, most studied scheduling models in a supply chain just assumed a single case when either there is a buffer for storing jobs or there exists no buffer. In addition, a majority of the existing approaches cannot be directly applied for solving large-size scheduling problems in a supply chain, while it is a common phenomenon in practice. Thus, it is worthwhile for us to develop more effective and efficient approaches for all such problems above. The main contributions of this paper can be summarized as follows:(1)New research is pursued by taking into account the features of serial batching, different job deteriorating rates, and transportation simultaneously on a two-stage scheduling problem in a supply chain.For the scheduling problem with a buffer, an optimal algorithm is developed for solving it.For the scheduling problem without buffer, some useful properties are derived, based on which a heuristic is designed for solving it. The proposed heuristic is capable of solving large-size problems in a reasonable time. A novel lower bound is also derived. Two special cases are well analyzed, and two optimal algorithms are developed for solving them, respectively.The reminder of this paper is organized as follows. In Section 2, the proposed problems are described in detail and formalized. In Sections 3 and 4, the first and second problems are studied, respectively. We conclude the paper and suggest some topics for future research in Section 5.The concerned scheduling problems in a supply chain consist of two stages, i.e., the production and transportation stages. During the production stage, a set { J1, J2, …, Jn} of n jobs is to be first partitioned into batches and then processed on a manufacturer's serial batching machine in the pattern of serial batches, where serial batches require that a number of jobs within the same batch are processed one after another in a serial fashion (Xuan & Tang, 2007). The batch completion time is defined as the completion time of the last job in the batch. The capacity of the batching machine is denoted as c, and the number of jobs of each batch cannot exceed c. All jobs and the machine are available at time t0 in the manufacturer, t0 > 0. The actual job processing time of job Jiis modeled as a linear function of its starting time t, and it is defined as(1)pi=ait,i=1,2,…,nwhere aiis the deteriorating rate of Ji.Moreover, the actual batch processing time Pkof batch bkcan be also derived as a function of its starting time t as follows:(2)Pk=t∏Ji∈bk(1+ai)−tDuring the transportation stage, there is a single vehicle carrying the processed batches back and forth between the manufacturer and the customer. The vehicle's capacity is assumed to be equal to the machine's capacity, and it can transport one batch in each shipment. The round trip time between the manufacturer and the customer is defined as a constant T, and each one-way time isT2.Two different types of the two-stage scheduling problems in this supply chain are studied. The first one refers to the situation when there exists a buffer in the manufacturer, i.e., the manufacturer can place the finished batch from the machine into the buffer and continue to process the next batch on the machine immediately no matter whether the vehicle returns to the manufacturer or not. The second one is the situation when there is no buffer in the manufacturer, and then the machine must wait to process the next batch until the vehicle returns to the manufacturer to take the finished batch from the machine.Fig. 1 shows the structure of the studied scheduling problems. We need to make decisions on the job batching and batch sequencing simultaneously to minimize the makespan. Using the conventional notation of Graham, Lawler, Lenstra, and Rinnooy Kan (1979), these two types of scheduling problems are denoted as M → C|pi= ait, s − batch, T, buffer|Cmaxand M → C|pi= ait, s − batch, T|Cmax, respectively.The assumptions for the problems are as follows:•All preheated aluminum ingots, the batching machine, and the vehicle are available at the manufacturer at time t0.In the first scenario with a buffer, the space of the buffer is unlimited.Pre-emption is prohibited, i.e., once a batch is initiated, no job can be released from the batch until the whole batch is completely processed.The notations and definitions used for both scheduling problems are as follows:NotationDefinitionnthe number of jobsmthe number of batchesJithe ith job, i = 1, 2,…,naithe deteriorating rate ofJi, i = 1, 2,…,npithe actual processing time ofJi, i = 1, 2,…,nbkthe kth batch, k = 1, 2,…,mnkthe number of jobs inbk, k = 1, 2,…,mPkthe actual processing time ofbk, k = 1, 2,…,mcthe capacity of the batching machine and the vehicleTthe round trip time between the manufacturer and the customert0the starting time of processing jobs during the production stageS1k(S2k)the starting time ofbkduring the production stage (transportation stage), k = 1, 2,…,mC1k(C2k)the completion time ofbkduring the production stage (transportation stage), k = 1, 2, …, mCmaxthe makespan or maximum completion time of all jobsxik1, ifJiis assigned tobk; otherwise,xik= 0ykw1, ifbkprecedesbwduring the production stage; otherwise,ykw= 0, k, w = 1, 2,…,mzkw1, ifbkprecedesbwduring the transportation stage; otherwise,ykw=0, k, w = 1, 2,…,mMa large enough positive constant(3)MinimizeCmaxSubject to:(4)∑k=1mxik=1,i=1,2,…,n(5)∑i=1nxik≤c,k=1,2,…,m(6)C1k=S1k∏i=1+∑j=1k−1nj∑j=1knj(1+ai),k=1,2,…,m(7)S1(k+1)=C1k,k=1,2,…,m−1(8)S2(k+1)≥C1k+T,k=1,2,…,m−1(9)C2k=S2k+T2,k=1,2,…,m(10)C1k−C1w+Mykw−Pk≥0,k,w=1,2,…,m(11)C2k−C2w+Mykw−T≥0,k,w=1,2,…,m(12)Cmax≥C2k,k=1,2,…,m(13)xik,ykw,zkw=0or1,i=1,2,…,n,k,w=1,2,…,mThe objective function (3) minimizes the makespan. Constraint set (4) assures that each job should be only assigned to one batch. Constraint set (5) guarantees that the number of the jobs in a batch cannot exceed the machine capacity. Batch completion time at the manufacturer's side is defined by constraint set (6). Constraint set (7) makes sure that a new batch can be immediately processed on the manufacture's machine after the previous batch is completed. Constraint set (8) indicates that the starting time to process a batch in the manufacturer should be no less than the previous batch's completion time on the machine plus the round trip time. Based on constraint set (9), the batch completion time can be calculated. Constraint sets (10) and (11) ensure that there is no overlapping situation between any two different batches during the production or transportation stage. The property of the makespan is specified by constraint set (12). Constraint set (13) defines the ranges of the variables.(14)Minimize(2)Subjectto(2)--(6),((8)--(13)),andS1(k+1)=max{C1k,S1k+T},k=1,2,…,m−1Constraint set (14) restricts that a new batch cannot start to be processed in the manufacturer before the previous batch has been completed on the manufacturer's machine and the vehicle has returned to the manufacturer. Based on constraint set (14), since there is no buffer in the manufacturer, a new batch cannot be immediately processed on the manufacture's machine after the previous batch is completed. Thus, constraint set (7) is not considered in this model.In this section, the problem M → C|pi= ait, s − batch, T, buffer|Cmaxis studied. Some properties are proved and then an algorithm is proposed to solve this problem.Lemma 1For the problem M → C|pi= ait, s − batch, T|Cmax, the optimal schedule satisfies the property thatCmax*≥{max{∏i=1ns0+P1+(⌈nc⌉−12)T,s0∏i=1n(1+ai)+T2},ifn>cs0∏i=1n(1+ai)+T2,otherwise.(1) if n > c, then one lower bound of makespan can be obtained by assuming that there is no idle time during the transportation stage after the first batch is completed on the manufacturer's machine, thus we haveCmax*≥s0+P1+(⌈nc⌉−12)T. Meanwhile, the other lower bound can be obtained by assuming that there is no idle time during the production stage, thenCmax*≥s0∏i=1n(1+ai)+T2. Thus,Cmax*≥max{s0+P1+(⌈nc⌉−12)T,s0∏i=1n(1+ai)+T2}. It is easy to infer thatCmax*≥s0∏i=1n(1+ai)+T2when n ≤ c. The proof is completed. □For the problem M → C|pi= ait, s − batch, T, buffer|Cmax, if n ≤ c, then the optimal schedule can be obtained after placing all jobs into a single batch in an arbitrary order.The result can be easily obtained from Lemma 1, so here it is omitted. □Then, an algorithm is proposed to solve this problem.Algorithm 1Algorithm 1Step 1. Index the jobs in the non-decreasing order ofaisuch thata1≤a2≤⋯≤anand obtain a job list.Step 2. Ifn≤c, then place all jobs in a batch and go to step 4. Otherwise, place the first[n−c(⌈nc⌉−1)]jobs in a batch.Step 3. If there are still unscheduled jobs in the job list, then place the firstcjobs in a batch and iterate. Otherwise, go to step 4.Step 4. Schedule the batch(es) in their generation order at timet0.Lemma 3If n > c, then the batches generated byAlgorithm 1satisfy the property that Pk + 1 ≥ Pk(k = 1, 2, …, m − 1).When k ≥ 2, the completion time of bkon the manufacturer's machine isC1k=S1k∏i=1+∑j=1k−1nj∑j=1knj(1+ai)=t0∏i=1∑j=1k−1nj(1+ai)∏i=1+∑j=1k−1nj∑j=1knj(1+ai).Then,Pk=C1k−S1k=t0∏i=1∑j=1k−1nj(1+ai)[∏i=1+∑j=1k−1nj∑j=1knj(1+ai)−1].Also,Pk+1=t0∏i=1∑j=1knj(1+ai)[∏i=1+∑j=1knj∑j=1k+1nj(1+ai)−1].According to Algorithm 1, we have∏i=1∑j=1knj(1+ai)≥∏i=1∑j=1k−1nj(1+ai)and∏i=1+∑j=1knj∑j=1k+1nj(1+ai)≥∏i=1+∑j=1k−1nj∑j=1knj(1+ai).Thus, Pk + 1 ≥ Pk.When k = 1, it can be also inferred that P2 ≥ P1. The proof is similar to that of the situation when k ≥ 2, so here it is omitted.The proof is completed. □ForAlgorithm 1, if T ≤ P2, then the makespan generated byAlgorithm 1is equal toCmax=t0∏i=1n(1+ai)+T2.If T ≤ P2, then we have T ≤ P2 ≤ P3 ≤ ⋅⋅⋅ ≤ Pmbased on Lemma 3. The completion time of bkduring the transportation stage can be obtained asC2k=t0∏i=1∑j=1knj(1+ai)+T2.Thus, we haveCmax=C2m=t0∏i=1∑j=1mnj(1+ai)+T2=t0∏i=1n(1+ai)+T2.□Sincet0∏i=1n(1+ai)+T2≤Cmax*, we have the following corollary.Corollary 1For the M → C|pi= ait, s − batch, T, buffer|Cmax problem, if n > c and T ≤ P2, thenAlgorithm 1generates an optimal schedule.ForAlgorithm 1, if T ≥ P2andT(⌈nc⌉−1)≤t0∏i=1n(1+ai)−t0∏i=1n−c(⌈nc⌉−1)(1+ai), then the makespan generated byAlgorithm 1isCmax=t0∏i=1n(1+ai)+T2.If T ≥ P2 andT(⌈nc⌉−1)≤t0∏i=1n(1+ai)−t0∏i=1n−c(⌈nc⌉−1)(1+ai), there should be two batches bpand bqsatisfying that S2p+ T ≥ C1(p + 1), S2q+ T ≤ C1(q + 1), and1≤p<q≤⌈nc⌉−1.The completion time of bq + 1 during the transportation stage isC2(q+1)=S2(q+1)+T2=max{C1(q+1),S2q+T}+T2=C1(q+1)+T2=t0∏i=1∑j=1q+1nj(1+ai)+T2.Thus,Cmax=C2m=t0∏i=1∑j=1mnj(1+ai)+T2=t0∏i=1n(1+ai)+T2.□Similar to Corollary 1, we can also have the following corollary.Corollary 2For the M → C|pi= ait, s − batch, T, buffer|Cmax problem, if n > c, T ≥ P2, andT(⌈nc⌉−1)≤t0∏i=1n(1+ai)−t0∏i=1n−c(⌈nc⌉−1)(1+ai), thenAlgorithm 1generates an optimal schedule.ForAlgorithm 1, if T ≥ P2andT(⌈nc⌉−1)≥t0∏i=1n(1+ai)−t0∏i=1n−c(⌈nc⌉−1)(1+ai), then the makespan generated byAlgorithm 1isCmax=t0∏i=1n−c(⌈nc⌉−1)(1+ai)+(⌈nc⌉−12)T.If T ≥ P2 andT(⌈nc⌉−1)≥t0∏i=1n(1+ai)−t0∏i=1n−c(⌈nc⌉−1)(1+ai), then the makespan generated by Algorithm 1 should beCmax=C2m=C2⌈nc⌉=S2⌈nc⌉+T2=max{S2(⌈nc⌉−1)+T,C1⌈nc⌉}+T2=C11+T(⌈nc⌉−1)+T2=t0∏i=1n−c(⌈nc⌉−1)(1+ai)+(⌈nc⌉−12)T.□For the problem M → C|pi= ait, s − batch, T, buffer|Cmax, if n > c, T ≥ P2, andT(⌈nc⌉−1)≥t0∏i=1n(1+ai)−t0∏i=1n−c(⌈nc⌉−1)(1+ai), then the optimal schedule satisfies the properties that(1)m=⌈nc⌉;n1=n−c(⌈nc⌉−1);ax≤ ayfor two arbitrary jobs ax∈ b1 and ay∈ bk(k ≥ 2).(1). Since the possible smallest number of batches is⌈nc⌉, we havem≥⌈nc⌉. Assuming there exists an optimal schedule satisfying thatm>⌈nc⌉, it can be obtained thatCmax*=t0∏i=1n1(1+ai)+(m−12)T.Based on Lemma 5,Cmax*−Cmax=t0∏i=1n1(1+ai)+(m−12)T−t0∏i=1n−c(⌈nc⌉−1)(1+ai)+(⌈nc⌉−12)T>t0−t0∏i=1n−c(⌈nc⌉−1)(1+ai)+(m−⌈nc⌉)T≥T−P1.Since T ≥ P2 ≥ P1, we haveCmax*>Cmax, which contradicts with the optimal schedule. Thus, it should be thatm=⌈nc⌉.(2). Based on (1), it can be obtained thatn1≥n−c(⌈nc⌉−1). Assuming there exists an optimal schedule satisfying thatm=⌈nc⌉andn1>n−c(⌈nc⌉−1), then after an arbitrary job Jxin b1 is transferred into another arbitrary batch bkwith nk< c, the completion time of all jobs is updated toCmax′=t0·11+ax·∏i=1n1(1+ai)+(⌈nc⌉−12)T.Then,Cmax′−Cmax*=−axt0·11+ax·∏i=1n1(1+ai)<0,which contradicts with the optimal schedule. Therefore, we haven1=n−c(⌈nc⌉−1).(3). Assuming there exists an optimal schedule satisfying that ax> ayfor two arbitrary jobs ax∈ b1 and ay∈ bk(k ≥ 2), based on (1) and (2), the makespan after swapping Jxand Jyis updated toCmax′=t0·1+ay1+ax·∏i=1n1(1+ai)+(⌈nc⌉−12)T.Then,Cmax*−Cmax′=t0·ax−ay1+ax·∏i=1n1(1+ai)>0,which contradicts with the optimal schedule, thus it should be ax≤ ay. □For the problem M → C|pi= ait, s − batch, T, buffer|Cmax, if n > c, T ≥ P2, andT(⌈nc⌉−1)≥t0∏i=1n(1+ai)−t0∏i=1n−c(⌈nc⌉−1)(1+ai), thenAlgorithm 1generates an optimal schedule.Algorithm 1generates an optimal solution for the problem M → C|pi= ait, s − batch, T, buffer|Cmax, and the optimal makespan isCmax*={t0∏i=1n(1+ai)+T2,n≤cmax{t0∏i=1n−c(⌈nc⌉−1)(1+ai)+(⌈nc⌉−12)T,t0∏i=1n(1+ai)+T2∏i=1n−c(⌈nc⌉−1)},n>cCombining Lemma 2, Corollary 1, Corollary 2, and Corollary 3, it can be obtained that Algorithm 1 generates an optimal schedule for the problem M → T|pi= ait, s − batch, T, buffer|Cmax. When n > c, T ≥ P2, andT(⌈nc⌉−1)≤t0∏i=1n(1+ai)−t0∏i=1n−c(⌈nc⌉−1)(1+ai), the makespan generated by Algorithm 1 isCmax*=t0∏i=1n−c(⌈nc⌉−1)(1+ai)+(⌈nc⌉−12)T.Under all the other conditions, the makespan generated by Algorithm 1 isCmax*=t0∏i=1n(1+ai)+T2.Therefore,Cmax*={t0∏i=1n(1+ai)+T2,n≤cmax{t0∏i=1n−c(⌈nc⌉−1)(1+ai)+(⌈nc⌉−12)T,t0∏i=1n(1+ai)+T2∏i=1n−c(⌈nc⌉−1)},n>cThe proof is completed. □In this section, the problem M → C|pi= ait, s − batch, T|Cmaxis studied. We provide some properties in Section 4.1. Then a heuristic and a lower bound are presented in Section 4.2, followed by two special cases in Section 4.3. Finally, we conduct computational experiments in Section 4.4.Some structural properties are demonstrated for the general case in this subsection.Lemma 8For the problem M → C|pi= ait, s − batch, T|Cmax, the optimal schedule satisfies the property that the jobs in each batch can be sequenced in any order.The result can be obtained by interchanging two adjacent jobs in an arbitrary batch. □For the problem M → C|pi= ait, s − batch, T|Cmax, the optimal schedule satisfies the property that ykw+ zkw= 0 or 2, wherek, w = 1, 2, …, m.It is easy to infer that S2k≥ S2wwhen S1k≥ S1w, or S2k< S2wwhen S1k< S1w. It should be ykw= zkw= 0 or ykw= zkw= 1. Thus, we can obtain that ykw+ zkw= 0 or 2, where k, w = 1, 2, …, m. □For the problem M → C|pi= ait, s − batch, T|Cmax, there exists Jx∈ bk + 1in a schedule. IfS1(k+1)∏i=1+∑j=1knj∑j=1k+1nj(1+ai)≥S1(k+1)+T,S1k∏i=1+∑j=1k−1nj∑j=1knj(1+ai)<S1k+T,andnk<c,then the solution can be improved.If Jxis transferred from bk + 1 into bk, then the updated completion time of bkon the manufacturer's machine isC1k′=S1k(1+ax)∏i=1+∑j=1k−1nj∑j=1knj(1+ai).There are two cases as follows:(1)C1k′≤S1k+T.The updated completion time of bk + 1 on the manufacturer's machine isC1(k+1)′=S1(k+1)′·11+ax·∏i=1+∑j=1knj∑j=1k+1nj(1+ai)=S1(k+1)·11+ax·∏i=1+∑j=1knj∑j=1k+1nj(1+ai).Then,C1(k+1)′−C1(k+1)=S1(k+1)·11+ax·∏i=1+∑j=1knj∑j=1k+1nj(1+ai)−S1(k+1)∏i=1+∑j=1knj∑j=1k+1nj(1+ai)=S1(k+1)·−ax1+ax·∏i=1+∑j=1knj∑j=1k+1nj(1+ai)<0.Thus,C1(k+1)′<C1(k+1).C1k′>S1k+T.The updated completion time of bk + 1 on the manufacturer's machine isC1(k+1)′=S1k(1+ax)∏i=1+∑j=1k−1nj∑j=1knj(1+ai)·11+ax·∏i=1+∑j=1knj∑j=1k+1nj(1+ai).=S1k∏i=1+∑j=1k−1nj∑j=1knj(1+ai)·∏i=1+∑j=1knj∑j=1k+1nj(1+ai).Since we haveS1k∏i=1+∑j=1k−1nj∑j=1knj(1+ai)<S1k+TandS1(k+1)=S1k+T,it can be deduced thatC1(k+1)′−C1(k+1)=∏i=1+∑j=1knj∑j=1k+1nj(1+ai).[S1k∏i=1+∑j=1k−1nj∑j=1knj(1+ai)−(S1k+T)]<0.Combining two cases, we can conclude that the solutions are improved. □For the problem M → C|pi= ait, s −  batch, T|Cmax, if there exist two arbitrary jobs Jx∈ bk and Jy∈ bk + 1in an optimal schedule, then the optimal schedule satisfies the property thatax≥aywhenS1k∏i=1+∑j=1k−1nj∑j=1knj(1+ai)<S1k+Tandk=2,…,m−1.Assuming that ax< aywhenS1k∏i=1+∑j=1k−1nj∑j=1knj(1+ai)<S1k+Tand k = 2, …, m − 1. If Jxand Jyare exchanged, then there are two situations to be considered.(1)S1k·1+ay1+ax·∏i=1+∑j=1k−1nj∑j=1knj(1+ai)≤S1k+T.In this case, the updated completion time of bk + 1 on the manufacturer's machine isC1(k+1)′=(S1k+T)·1+ax1+ay·∏i=1+∑j=1knj∑j=1k+1nj(1+ai).Then,C1(k+1)′−C1(k+1)=(S1k+T)·ax−ay1+ay·∏i=1+∑j=1knj∑j=1k+1nj(1+ai)<0,which contradicts with the optimal solution, so we should have ax≥ ay.(2)S1k·1+ay1+ax·∏i=1+∑j=1k−1nj∑j=1knj(1+ai)>S1k+T.The updated completion time of bk + 1 on the manufacturer's machine isC1(k+1)′=S1k·1+ax1+ay·∏i=1+∑j=1k−1nj∑j=1knj(1+ai)·1+ay1+ax·∏i=1+∑j=1knj∑j=1k+1nj(1+ai)=S1k∏i=1+∑j=1k−1nj∑j=1knj(1+ai)·∏i=1+∑j=1knj∑j=1k+1nj(1+ai).Since we haveS1k+T>S1k∏i=1+∑j=1k−1nj∑j=1knj(1+ai),it can be deduced thatC1(k+1)−C1(k+1)′=∏i=1+∑j=1knj∑j=1k+1nj(1+ai)×[S1k+T−S1k∏i=1+∑j=1k−1nj∑j=1knj(1+ai)]>0,which also contradicts with the optimal solution, so it can be obtained that ax≥ ay. Combining these two situations, the proof is completed. □For the problem M → C|pi= ait, s − batch, T|Cmax, there exist two arbitrary jobs Jx∈ bk and Jy∈ bk + 1in a schedule, ifax≤ay,S1k∏i=1+∑j=1k−1nj∑j=1knj(1+ai)≥S1k+T,andS1(k+1)∏i=1+∑j=1knj∑j=1k+1nj(1+ai)≤S1(k+1)+T(k=2,…,m−1),then the solution remains unchanged after Jx and Jy are swapped.. After Jxand Jyare swapped, the updated completion time of bkduring the production stage isC1k′=S1k·1+ay1+ax·∏i=1+∑j=1k−1nj∑j=1knj(1+ai)SinceS1k·1+ay1+ax·∏i=1+∑j=1k−1nj∑j=1knj(1+ai)≥S1k∏i=1+∑j=1k−1nj∑j=1knj(1+ai)≥S1k+T,the updated completion time of bk + 1 during the production stage isC1(k+1)′=S1k·1+ay1+ax·∏i=1+∑j=1k−1nj∑j=1knj(1+ai)·1+ax1+ay·∏i=1+∑j=1knj∑j=1k+1nj(1+ai)=S1k·∏i=1+∑j=1k−1nj∑j=1knj(1+ai)·∏i=1+∑j=1knj∑j=1k+1nj(1+ai)=C1(k+1).SinceS1(k+1)∏i=1+∑j=1knj∑j=1k+1nj(1+ai)≤S1(k+1)+T,it is obtained thatC1(k+1)′−S1(k+1)′=C1(k+1)−C1k′=C1(k+1)−S1(k+1)·1+ay1+ax<S1(k+1)∏i=1+∑j=1knj∑j=1k+1nj(1+ai)−S1(k+1)≤T.Thus,C2(k+1)′=C2(k+1)and the proof is completed. □For the problem M → C|pi= ait, s − batch, T|Cmax, if n ≤ c, then there exists an optimal schedule satisfying that m = 1 and the jobs in the batch can be sequenced in any order.When n ≤ c, we assume that there exists an optimal schedule satisfying m > 1. Since n ≤ c, all jobs can be transferred from other batches into b1. The updated completion time of all jobs isCmax′=C21′=t0∏i=1n(1+ai)+T2≤Cmax*.The updated schedule remains optimal, and based on Lemma 8, the jobs can be sequenced in any order in b1.The proof is completed. □For the problem M → C|pi= ait, s − batch, T|Cmax, if c < n ≤ 2c, then there exists an optimal schedule satisfying m = 2, n1 = n − c, n2 = c, and ax≤ ay for two arbitrary jobs Jx∈ b1and Jy∈ b2.The proof can be completed by combining two cases.(1)Case 1: assuming there exists an optimal schedule for m ≥ 3.Since c < n ≤ 2c, all jobs can be transferred from the other batches into b1 and b2. The schedule can be updated as ({J1, J2, …, Jn − c}, { Jn − c + 1, Jn − c + 2, …, Jn}) satisfying n1 = n − c, n2 = c, and a1 ≤ a2 ≤ ⋅⋅⋅ ≤ an − c≤ an − c + 1 ≤ ⋅⋅⋅ ≤ an. The updated completion time of all jobs isCmax′=max{C12′,C11′+T}+T2.We haveC12′=t0∏i=1n(1+ai)andC11′=t0∏i=1n−c(1+ai)The original completion time of all jobs isCmax=max{C1m,C1(m−1)+T}+T2.It is easy to see thatC1m≥C12′andC1(m−1)≥C11′. Thenmax{C1m,C1(m−1)+T}+T2≥max{C12′,C11′+T}+T2.Thus,Cmax≥Cmax′and the updated schedule remains optimal.Case 2: assuming there exists an optimal schedule for m = 2.There exist two subcases for this case.(2.1) Case 2.1: n1 ≠ n − c (or n2 ≠ c).If n1 ≠ n − c, then n1 > n − c and n2 < c. After transferring an arbitrary job Jxfrom b1 into b2, the updated completion time of all jobs isCmax′=max{C12′,C11′+T}+T2=max{C12,C11·11+ax+T}+T2,andCmax−Cmax′=max{C12,C11+T}−max{C12,C11·11+ax+T}≥0.It can be obtained thatCmax≥Cmax′and the updated schedule remains optimal. Similarly, we can remove jobs from b1 into b2 until n1 = n − c and n2 = c.(2.2) Case 2.2: ax> ayfor two arbitrary jobs Jx∈ b1 and Jy∈ b2.Assuming there exits an optimal schedule satisfying that ax> ayfor two arbitrary jobs Jx∈ b1 and Jy∈ b2. After swapping Jxand Jy, the updated completion time of all jobs isCmax′=max{C12′,C11′+T}+T2=max{t0[1+ay1+ax·∏i=1n−c(1+ai)]·[1+ax1+ay·∏i=n−c+1n(1+ai)],t0[1+ay1+ax·∏i=1n−c(1+ai)]+T}+T2=max{C12,C11·1+ay1+ax+T}.Then,Cmax−Cmax′=max{C12,C11+T}−max{C12,C11·1+ay1+ax+T}≥0.Therefore, we can have ax≤ ay.Combining two cases for m ≥ 3 and m = 2, the proof is completed. □For the problem M → C|pi= ait, s − batch, T|Cmax, if n > 2c, then there exists an optimal schedule satisfying ax≤ ay for two arbitrary jobs Jx∈ b1and Jy∈ b2.Since the proof of Lemma 15 is similar to that of Lemma 14, here it is omitted. □In Section 4.2.1, a heuristic is introduced for the studied problem based on the properties which are previously proved in Section 4.1, and then a lower bound is derived in Section 4.2.2.A heuristic H is developed to solve the problem M → C|pi= ait, s − batch, T|Cmax. The process of the proposed heuristic is implemented through two phases: (1) job batching, and (2) batch sequencing. The details of heuristic H are as follows.Heuristic HStep 1. Ifn≤c, then place all jobs in a batch in any order and output the scheduleσ. Otherwise, go to step 2.Step 2. Ifc<n≤2c, then index the jobs in the non-decreasing order ofaisuch thata1≤a2≤⋯≤an, place the first(n−c)jobs in the first batch and the remainingcjobs in the second batch, and output the scheduleσ. Otherwise, go to step 3.Step 3. Index the jobs in the non-increasing order ofaisuch thata1≥a2≥⋯≥anand obtain a job list. Place the jobsJc+1,Jc+2,…,andJ2cin the first batchb1.Step 4. Setσ=b1,k=2, andS=S1k=t0∏i=c+12c(1+ai).Step 5. Re-index the remaining(n−c)jobs in the non-increasing order ofaisuch thatac+1≥ac+2≥⋯≥an, and obtain a job list.Step 6. Seti=c+1,bk={Ji},nk=1, andS=S(1+ai).Step 7. Ifi<n, then updatei=i+1and go to step 8. Otherwise, output the scheduleσ.Step 8. Ifnk<candS−S1k<θT(θ≥1), then updatebk=bk⋃{Ji},nk=nk+1, andS=S(1+ai), and go to step 7. Otherwise, go to step 9.Step 9. UpdateS=max{S,S1k+T},σ=σ⋃bk,k=k+1,S1k=S,bk={Ji},nk=1, andS=S(1+ai). Go to step 7.In order to analyze the performance of the proposed heuristic, two lower bounds of the makespan are presented as follows.Similar to the problem M → C|pi= ait, s − batch, T, buffer|Cmax, the first lower bound is obtained by assuming that there is no additional idle time on the manufacturer's serial batching machine. Then, the first lower bound is equal to the completion time of the last job at the customer's side, which is calculated asLB1=C1m=t0∏i=1n(1+ai)+T2.Similarly, with regards to the second lower bound, we assume that there is no idle time during the transportation stage since the vehicle starts to transport the first batch from the manufacturer to the customer. Thus, the second lower bound is equal to the completion time of the first batch on the manufacturer's machine plus the vehicle's total trip time, i.e.,C11+⌈nc⌉·T−T2.SinceC11≥t0(1+mini=1,2,…,n{ai}), it can be obtained thatLB2=t0(1+mini=1,2,…,n{ai})+⌈nc⌉·T−T2.In this way, two special situations according to above two lower bounds are considered as follows.(1) Situation 1In this situation, if n > 2c, then the case when the processing time of the second batch on the manufacturer's machine is smaller than the round trip time T is considered. Under the condition that the second batch has the possible longest processing time, we have the following lemmas.Lemma 16If n > 2c and the second batch has the possible longest processing time during the production stage, then n1 = n2 = c.The processing time for b2 isP2=t0∏i=1n1(1+ai)·[∏i=n1+1n2(1+ai)−1].If c > n1, then after transferring an arbitrary job Jjfrom bk( k > 2) into b1, the updated processing time of b2 isP2′=t0(1+aj)·∏i=1n1(1+ai)·[∏i=n1+1n2(1+ai)−1].Then,P2′−P2=t0aj∏i=1n1(1+ai)·[∏i=n1+1n2(1+ai)−1]>0.Similar to the above situation, if c > n2, then it can be proved that after transferring an arbitrary job Jjfrom bk( k > 2) into b2, the updated processing time of b2 is longer than the original one. Thus, n1 = n2 = c. □If n > 2c and the second batch has the possible longest processing time, then we have ay≥ ax and ax≥ az for three arbitrary jobs ax∈ b1, ay∈ b2, and az∈ bk(k > 2).If ax> ay, then the processing time of b2 after swapping Jxand Jyis updated toP2′=t0·1+ay1+ax·∏i=1c(1+ai)·[1+ax1+ay·∏i=c+12c(1+ai)−1]=t0∏i=1c(1+ai)·[∏i=c+12c(1+ai)−1+ay1+ax].Then,P2′−P2=t0∏i=1c(1+ai)·[∏i=c+12c(1+ai)−1+ay1+ax]−t0∏i=1c(1+ai)·[∏i=c+12c(1+ai)−1]=t0·ax−ay1+ay·∏i=1c(1+ai)>0.Similar to the above situation, if az> ax, then it can be proved that after swapping Jxand Jz, the updated processing time of b2 is longer than the original one.Thus, the proof is completed. □Combining the above Lemmas 16 and 17, it is easy to obtain the following lemma.Lemma 18If n > 2c and the jobs are indexed in the non-increasing order of ai such that a1 ≥ a2 ≥ ⋅⋅⋅ ≥ an, then the possible longest processing time of the second batch isP2max=t0∏i=c+12c(1+ai)[∏i=1c(1+ai)−1].If n > 2c andP2max<T, then there should be idle time for b2 to wait for the vehicle. Another lower bound can be updated from LB1 asLB3=∏i=2c+1n(1+ai)[t0∏i=c+12c(1+ai)+T]+T2.(2) Situation 2All jobs are indexed in the non-decreasing order of aisuch that a1 ≤ a2 ≤ ⋅⋅⋅ ≤ an. For the second lower bound, we consider the situation when the processing time of an arbitrary job is longer than the round trip time T from time t, i.e., t(1 + af) − t ≥ T. In this situation there are still (n − f + 1) unscheduled jobs at time t, and 1 ≤ f ≤ n. Then, there should be no idle time for the remaining jobs on the manufacturer's machine. Another lower bound is updated from LB2 asLB4=[t0(1+a1)+T·max{⌊fc⌋−1,0}]·∏i=max{f,2}n(1+ai)+T2.Consequently, the overall lower bound can be shown as follows:LB={max{LB1,LB2},unsatisfyingsituations1and2max{LB2,LB3},satisfyingsituation1andunsatisfyingsituation2max{LB1,LB4},satisfyingsituation2andunsatisfyingsituation1max{LB3,LB4},satisfyingsituations1and2Two special cases are discussed in this section. All jobs are first indexed in the non-decreasing order of ai. Then, two special cases are under the assumptions thatt0∏i=1n(1+ai)−t0(1+ai)≤T(denoted as special case 1) and t0a1 ≥ T (denoted as special case 2), respectively.In this special case, we have the following lemmas.Lemma 19For special case 1, if n > c, then the optimal schedule satisfies the property that the deteriorating rates of the jobs in the first batch are no larger than those in other batches.Assuming there exist two arbitrary jobs Jx∈ b1 and Jy∈ bk(2 ≤ k ≤ m) in an optimal schedule satisfying ax> ay, then after swapping Jxand Jy, the makespan is updated toCmax′=t0·1+ay1+ax·∏i=1n1(1+ai)+(m−12)T.Then,Cmax*−Cmax′=t0·ax−ay1+ax·∏i=1n1(1+ai)>0,which contradicts with the property of the optimal schedule. Thus, the optimal schedule should satisfy ax≤ ay. □Similar to Lemma 7, the following lemma can be obtained.Lemma 20For special case 1, if n > c, then the optimal schedule satisfies the property that the first batch contains[n−(⌈nc⌉−1)c]jobs and the next(⌈nc⌉−1)batches are full of jobs.Based on Lemmas 19 and 20, it is easy to obtain the following theorem.Theorem 2Algorithm 1 generates an optimal solution for special case 1, and the optimal makespan isLemma 21For special case 2, the optimal schedule satisfies the property that the jobs can be sequenced in any order.The result can be obtained by interchanging two adjacent jobs in an arbitrary batch or two random jobs in two different batches. □For special case 2, the optimal schedule is independent of the patterns of job batching.We consider the following two situations in an optimal schedule:(1) Assuming there exists a batch bk, satisfying nk≥ 2 and Jx∈ bk:We remove Jxfrom bkas a new single batch, and this new batch is processed after bkon the machine. The updated completion time of bkin the production stage isC1k′=S1k·11+ax∏i=1+∑j=1k−1nj∑j=1knj(1+ai).SinceC1k′≥S1k+T, the completion time of bkin the transportation stage isC2k′=S1k·11+ax∏i=1+∑j=1k−1nj∑j=1knj(1+ai)+T2.The completion time of the new batch {Jx} in the production stage isC1k′·(1+ax), and we haveC1k′·(1+ax)≥C2k′+T2. The completion time of the new batch {Jx} in the transportation stage isC1k′·(1+ax)+T2=C2k. Then the completion times of bk + 1 in the production stage and the transportation stage remain unchanged. Thus, the new schedule remains optimal.(2) Assuming there exist two adjacent batches bkand bk + 1, satisfying nk< c or nk + 1 < c:Similar to the above situation 1, the updated schedules remain optimal after transferring no more than (c − nk + 1) arbitrary jobs from bkinto bk + 1 or (c − nk) arbitrary jobs from bk + 1 into bk.Combining two situations, the proof is completed. □Based on the above lemmas in this subsection, the following algorithm is proposed to solve special case 2.Algorithm 2Algorithm 2Step 1. Index the jobs in the adjacent order ofaiand obtain a job list.Step 2. Place the first randomx(x≤c)jobs in a batch and iterate until there are no unscheduled jobs left in the job list.Step 3. Schedule the batch(es) in their generation order at timet0.From Lemmas 21 and 22, we can easily obtain the following theorem.Theorem 3Algorithm 2generates an optimal solution for special case 2, and the optimal makespan ist0∏i=1n(1+ai)+T2.In this section, computational experiments were carried out to evaluate the performance of the proposed heuristic. All the algorithms were coded in PowerBuilder 9.0 language and their code was run on a Pentium(R)-4, 300 MHz PC with 2GB of RAM.Five experimental parameters were considered: the number of jobs (n), the capacity of the batching machine and the vehicle (c), the deteriorating rate of the job processing time on the manufacturer's serial batching machine (ai), starting time of processing jobs during the production stage (t0), and round trip time between the manufacturer and customer (T). Specifically, different levels of job numbers and the capacity of the machine and the vehicle are considered. Both small-size and large-size random instances were generated, and two levels of the capacity with c ∈ U[10, 15] and c ∈ U[15, 20] were tested. Based on theactual production data and the production staffs’ experiences, the deteriorating rates of the job processing times follow a uniform distribution between 0 and 10 percent, which is similar to the situation to that of the problem investigated by Ruiz-Torres, Paletta, and Pérez (2013). Thus, the deteriorating rates of the job processing times on the manufacturer's serial batching machine were generated from U(0, 0.1]. Other parameters were generated based on the real production data of an aluminum company in China. The parameter values are described in Table 2.For effectiveness evaluation, the solutions reported by the proposed heuristic H are compared with those of two previous approaches from the literature, namely algorithms FBLDR and SBPT-FOE (n, c) proposed by Li et al. (2011) and Tang and Liu (2009), respectively. Two new algorithms were developed by revising step 1 of algorithm FBLDR to index the jobs in non-decreasing order of deteriorating rate such that a1 ≤ a2 ≤ ⋅⋅⋅ ≤ an, and revising algorithm SBPT-FOE(n, c) to sequence the jobs in the non-increasing order of deteriorating rate such that a1 ≥ a2 ≥ ⋅⋅⋅ ≥ an. These two algorithms are denoted as algorithms FBSDR and LBPT-FOE(n, c), which are also compared with the proposed heuristic H.We next analyze the performance of five approaches in terms of the relative gap between the makespan reported by each approach and the lower bound derived in Section 4.2.2. The relative gap percentage (GapA) between the approach A and the lower bound (LB) is computed as Eq. (15).(15)GapA=CmaxA−LBLBThe performance of our proposed heuristic is sensitive to the value of the parameter θ (θ ≥ 1) for small-size instances, which was initially set to 1, 2, 3, 4, 5, 6, 7, 8, 9, and 10, respectively. It is worthwhile to note that heuristic H can obtain a solution within 2 seconds for each instance, even for the large-size instance with up to 400 jobs, which indicates that the procedure is subject to low computational burden to run the heuristic approach with different parameter values. The best solution, obtained by using one of these parameter values, was selected as the final solution to the problem.In order to analyze the impact of the factors on the performance of the obtained solution, a factorial experiment including two factors was designed. These two factors characterize the number of jobs (i.e., n) and the capacity of the machine and vehicle (i.e., c). Each treatment for the combination (n, c) was replicated ten times, and both average and maximum relative gaps were reported.(1)Analysis of results for c ∈ U[10, 15]Table 3 compares the effect of problem size on the average and maximum relative gap percentages for the small-size problems when c ∈ U[10, 15]. The average relative gap percentage of heuristic H ranges from 0.0006 to 0.1337, and its maximum relative gap percentage ranges from approximately 0.0007 to 0.2015. In this case, heuristic H performed better than FBLDR, FBSDR, SBPT-FOE(n, c), and LBPT-FOE(n, c). LBPT-FOE(n, c) obtained better solutions than FBLDR, FBSDR, and SBPT-FOE(n, c) when n = 30and 35, while FBLDR performed better than FBSDR, SBPT-FOE(n, c), and LBPT-FOE(n, c) when n ≥ 40. For the 45-job problem instance, FBLDR, FBSDR, SBPT-FOE(n, c), and LBPT-FOE(n, c) reported average relative gap percentages of 0.0011, 0.3762, 0.8320, and 0.0014, respectively. However, heuristic H reported an average relative gap percentage of only 0.0006.Table 4 displays the similar effect for the large-size problems when c ∈ U[10, 15]. It is clear that the average and maximum relative gap percentages of heuristic H decrease with the number of jobs increasing when n ≤ 220. Both gaps range from 0.0001 to 0.0224, and 0.0002 to 0.0407. Both of them are smaller than 0.0001 when n > 220, which means that the solutions generated by heuristic H are very close to the optimal schedules. The performance of heuristic H is also more effective than that of the other four approaches. Moreover, the performance of FBLDR is better than those of FBSDR, SBPT-FOE(n, c), and LBPT-FOE(n, c) for each problem instance. For the 400-job problem instance, FBLDR, FBSDR, SBPT-FOE(n, c), and LBPT-FOE(n, c) reported average relative gap percentages of 0.0002, 20.3924, 22.4252, and 0.5890, respectively. However, the average relative gap percentage of heuristic H is smaller than 0.0001.(2)Analysis of results for c ∈ U[15, 20]Table 5shows the performance comparison among five different approaches in terms of average and maximum relative gap percentages for the small-size problems when c ∈ U[15, 20]. The average relative gap percentage of heuristic H ranges from 0.0006 to 0.1451, and its maximum relative gap percentage ranges from 0.0014 to 0.2736, respectively. Heuristic H performed better than FBLDR, FBSDR, SBPT-FOE(n, c), and LBPT-FOE(n, c). LBPT-FOE(n, c) performed better than FBLDR, FBSDR, and SBPT-FOE(n, c) when n = 30, 40, and 45, while FBLDR outperformed FBSDR, SBPT-FOE(n, c), and LBPT-FOE(n, c) when n = 35 and n ≥ 50. For the 40-job problem instance, FBLDR, FBSDR, SBPT-FOE(n, c), and LBPT-FOE(n, c) reported average relative gap percentages of 0.0030, 0.0011, 0.4077, and 0.0014, respectively. However, heuristic H reported an average gap percentage of only 0.0008.In Table 6, we compare five different approaches on the average and maximum gap percentages for the large-size problems when c ∈ U[15, 20]. The results indicate that the average and maximum relative gap percentages of heuristic H decrease with the number of jobs increasing when n ≤ 220. The average relative gap percentage ranges from 0.0004 to 0.0350, and the maximum relative gap percentage ranges from 0.0015 to 0.0720 when n ≤ $240. Moreover, both of them are smaller than 0.0001 when n ≥ 260. Compared with heuristic H, the other four approaches performed poorly. FBLDR obtained better solutions than FBSDR, SBPT-FOE(n, c), and LBPT-FOE(n, c) for each problem instance. For the 400-job problem instance, FBLDR, FBSDR, SBPT-FOE(n, c), and LBPT-FOE(n, c) reported average relative gap percentages of 0.0008, 34.0734, 37.2489, and 0.6739, respectively. However, the average gap percentage of heuristic H is only smaller than 0.0001.In conclusion, the proposed heuristic H outperformed the other four approaches both on the small-size and large-size problem instances. With respect to large-size problem instances, for c ∈ U[10, 15], the average and maximum relative gap percentages are less than 0.01 when n ≥ 160, and both of them are less than 0.0001 when n ≥ 240. For c ∈ U[15, 20], the average and maximum relative gap percentages are below 0.01 when n ≥ 180, and they are less than 0.0001 when n ≥ 260, which is also nearly 0. It implies that the performance of heuristic H has great effectiveness for large-size problems.

@&#CONCLUSIONS@&#
