@&#MAIN-TITLE@&#
Noninterference in a predicative polymorphic calculus for access control

@&#HIGHLIGHTS@&#
A denotational semantics based on Henkin models is given for a predicative polymorphic calculus of access control.Noninterference as a basic semantic notion of security is semantically defined.It is proven that the language is type-sound in the sense that every welltyped program of the language satisfies noninterference.

@&#KEYPHRASES@&#
Access control,Denotational semantics,Noninterference,Predicative polymorphism,

@&#ABSTRACT@&#
Polymorphic programming languages have been adapted for constructing distributed access control systems, where a program represents a proof of eligibility according to a given policy. As a security requirement, it is typically stated that the programs of such languages should satisfy noninterference. However, this property has not been defined and proven semantically. In this paper, we first propose a semantics based on Henkin models for a predicative polymorphic access control language based on lambda-calculus. A formal semantic definition of noninterference is then proposed through logical relations. We prove a type soundness theorem which states that any well-typed program of our language meets the noninterference property defined in this paper. In this way, it is guaranteed that access requests from an entity do not interfere with those from unrelated or more trusted entities.

@&#INTRODUCTION@&#
The use of programming languages theory in providing information security has long been recognized [33,34]. The basic idea is to design a programming language such that every system constructed using that language provably satisfies given security requirements. Although the research in this area has mainly focused on information confidentiality and integrity, the underlying notion can also be utilized in providing authenticity, e.g., [20,13], service availability, e.g., [25,42,14], and even constructing secure access control systems, e.g., [16,2,15,38,35,23]. When extended into access control, it may take the form of presenting an appropriate static semantics for the language so that its corresponding logic can reflect the intended policy. In this view, the programs of the language are regarded as proofs of eligibility and can be exploited in proof carrying authorization [8,11].A common approach to enforce confidentiality via programming languages theory is to build a variant ofλ-calculusso that noninterference [19], which is the basic semantic notion of secure information flow, is satisfied by the terms of the calculus—the words calculus and language are used interchangeably throughout this paper. To achieve this, it is required to have a lattice of security labels representing the sensitivity of the information related to variables, terms, and even computations. The language is then so designed that information flow from high (private) to low (public) is prohibited by the type or run-time system. Integrity can be achieved in the same way where the lattice of labels represents the integrity of information, and then, flow from low (untrusted) to high (trusted) is prevented by the language.A number of issues should be considered when noninterference is applied to access control. First, the language should be equipped with richer types handling specific relations between principals. For example, we need polymorphic types to formulate the assertions made about the relative power of principals such as those employed to encode the delegation of rights [2]. This necessitates a more complicated semantics, thereby complicating the study of noninterference. Second, the concept of noninterference, as it is defined in the realm of confidentiality, cannot be directly applied to the context of access control—we have seen similar results stating that if confidentiality and integrity are taken dual, some important facets will be ignored [27,12].If noninterference, as it is defined in confidentiality, is applied to a language that is employed as a logic for access control, different proofs of the same assertion made by an untrusted entity will have the same influence on what is derived from the policy. Such a property, however, vacuously holds in any logic, and thus, does reflect no specific feature of an access control system. This is while noninterference in the context of access control should guarantee that the policy will derive the same access rights in the presence of different assertions by an untrusted entity. By such an interpretation, a proof of an access right should not depend on any proof of any statement by an untrusted entity. This is analogous to the interpretation of noninterference in some constructive logics of access control [17] where the proof theory of the logic is required to handle the assertions made by different principals independently of each other. An attempt has been made in [2] to bring this property into a calculus for access control based on Dependency Core Calculus (DCC) [4]—DCC is aλ-calculusdevised to enforce restrictions on dependencies among computations through a lattice of monads [30,40]. However, due to the lack of semantic treatment of the property, the soundness of the language was not provable. In [6], noninterference for a logic of access controls is studied in terms of the game semantics. This approach, however, is limited to the monomorphic calculi of access control. As indicated earlier, a more expressive language with richer types is required for access control.This paper is an attempt to solve the problem stated above. In doing so, we first introduceD∀Pwhich is a predicative polymorphic calculus based on [2]. Then, we propose a denotational semantics for the language using Henkin models [28] and employ it to introduce a noninterference property reflecting the features required for a secure access control system. As a type soundness theorem, we prove that every well-typed program ofD∀Psatisfies noninterference. Unlike impredicative polymorphic languages, a predicative one does not allow the application of terms to polymorphic types. Our language does not allow terms to be applied to terms of polymorphic types either. In this way, we are able to propose a straightforward semantics for the language, and consequently, to make the soundness of the language provable, but possibly at the cost of expressiveness. It is also discussed how such a language may make restrictions on what can be expressed as an access control policy.It is worth noting that there are interesting works on languages with access control constructs, e.g., [10,35,24,37], where a noninterference property can be defined and proven. In that line of research, access control policies are embedded in the code of programs and it is guaranteed that, for example, information flow from high to low does not occur when typable programs execute. In the line of research we follow, however, the language itself—and not a program—conveys what is required for access control. Put alternatively, the language acts as an authorization logic. In such a case, every well-typed program of the language can be thought of as a proof of eligibility. The noninterference property, then, states that derivable access rights do not depend on the statements made by untrusted entities.The rest of this paper is organized as follows. Section 2 is on the significance of noninterference in access control systems. In Section 3, we develop a predicative polymorphic calculus for access control namedD∀P. Section 4 gives a denotational semantics for the calculus based on Henkin models. Section 5 defines noninterference formally on the basis of the semantics ofD∀P. Then, it is shown that any well-typed term of the calculus satisfies noninterference. Section 6 is on the expressiveness ofD∀Pand Section 7 concludes the paper.Access control is, in general, the process of deciding whether or not a request for a resource should be granted. The decisions made by an access control system are based on the policy of the enterprise who intends to control access to its resources. Access control seems straightforward, though it is error prone, especially in distributed and open environments where there are diverse kinds of principals that perform a wide variety of operations. A principal may be a client, a node on the network, a communication link, or even a cryptographic key. Every principal may make requests for resources, delegate its own rights to the other principals, confirm the credentials provided by the others, and so on.To manage complexities, modal logics have been proposed as a means for the specification and enforcement of access control policies, e.g., [5,8,26,1,15–18,2,23,21]. The use of modal operators such as says helps us abstract away the assertions made by principals from technical details concerning the manner of processing a request, authenticating the requester, and so on. In fact, a statement likeAsaysσindicates that the principal A has made the assertionσ. The machinery of the logic can then be utilized to reason about access requests efficiently in such a way that the resources used for authorization can be minimized. In addition, the use of logic makes it possible to verify an access control system formally.In a logical view, access control lists can be represented by formulas likeAcontrolsσwhich is a syntactic sugar for(Asaysσ)→σ. A partial order relation, e.g., speaks for, is also defined on the set of principals which specifies if a principal is at least as powerful as the other. By such an interpretation,AspeaksforBimplies that we can employ every assertion made by A to validate B's assertions. It is typical to express speaks for in terms of says as follows:AspeaksforB=∀σ.Asaysσ→Bsaysσ.One interesting way of implementing an access control system using logic is to build a programming language whose static semantics conveys the logical requirements for access control. In fact, inspired from the Curry–Howard isomorphism, authorization rules are represented by the typing rules of the language. In this view, an access request is granted if it can be derived in the logic. Equivalently, it is granted if, in the side of the corresponding programming language, there is a program of the type of what is requested. Thus, the principal having a request for a resource should provide the proof of its eligibility in the form of a program. The enterprise who authorizes principals then verifies the proof by type-checking that program. This approach has many advantages. First, the semantics of the logic can be studied through the massive work already done on the semantics of programming languages. Second, to implement an access control system, we should only check the proofs and it is not required to run a costly proof search.The correctness of an access control system constructed in this way can be formulated as satisfying a noninterference property by all programs of the language. Noninterference, in general, states that high-level information should not be revealed in lower levels. This notion of security has been incorporated into a number of languages, e.g., [39,22,9,31,41,43]. When used in the context of access control, an intuitive interpretation of noninterference is that granting an access to a principal must not be influenced by the assertions made by less trustworthy or unrelated principals. More formally, if A is more trustworthy than B, any proof M of an A's assertion, which relies on a proof N of an assertion made by B, can be converted to a proof being independent of N[2,17].The following example shows how the absence of this property may lead to an undesirable behavior of an access control system. Assume that principal A is more trusted than B and that(1)Acontrolsσ,whereσ=(Bsaysread[fileX])→read[fileX].Now, let M be a proof term of the statementAsaysσ. Furthermore, consider the case in which M can be obtained from the proof term N of(2)Bsaysread[fileX].In such a case, the statementread[fileX]can be derived when B issues the request represented by (2), i.e., there is a proof term N for (2). In fact, (2) impliesAsaysσ, due to the assumption that M is obtained from N. Then, from (1) andAsaysσ, we have(Bsaysread[fileX])→read[fileX]. This impliesread[fileX]. In this way, a less trustworthy principal B interferes with the decisions made by the access control system through the rights of a more trusted principal A. Such malfunctions will be avoided if an access control system enforces noninterference. In fact, noninterference is not satisfied in this example because M is obtained from N. That is, a less trusted principal interferes with the proofs of the assertions made by a more trusted one.We presentD∀P, a calculus that can be employed as a means for the specification and enforcement of access control policies. Indeed, it is a monadic predicative polymorphic language whose semantics enables us to define a noninterference property reflecting what is required for access control. In general, a type in a polymorphic language may have quantified type variables. The language is predicative because type application on quantified types is not allowed. Moreover, terms cannot be applied to terms of universal types. To study such languages, it is conventional to define small and large universes of types. The small universe, denoted by U1, comprises the types with no quantified type variables, while the large universe, written U2, consists of all types. The syntax ofD∀P, as given in Fig. 1, defines the types and terms of the language in which t is a type variable, b is a base type, and A is a principal.Fig. 2defines the judgmentΓ⊢τ:uwhich states that the type expressionτis in the universe u of types. In this figure,Bis the set of base types andLis a lattice of principals in whichA⪯Bmeans that A is more trusted than B. The ruleunivdoes not introduce a new type expression but indicates that the large universe subsumes the small one. It is also worth mentioning that a contextΓcomprises a number of type variables associated with their universes as well as term variables paired off with their types. Moreover, in the rules definingΓ⊢τ:uit is assumed that the context is well-formed—for the sake of conciseness, we do not add this assumption to the premises of the rules. The well-formedness ofΓis shown by⋄⊢Γand is defined in Fig. 3. The rule wfc2 states that well-formedness is closed under adding a fresh type variable of the small universe—the freshness of t is shown byt#Γ. The same holds for a fresh term variable x, as seen in the rule wfc3.We also need to define protection at a given trust level. We may use the judgmentπ(τ,A), defined in Fig. 4, to state that the typeτis protected at level A. When used in access control, each type is matched with a statement of the corresponding logic—the Curry–Howard isomorphism. Thus, protection can be interpreted in terms of the influence of a statement on a particular level. More precisely,π(τ,A)ensures that the statementτwill not influence the proof of the statements representing privileges of A. This is akin to what is required for information integrity.InD∀P, we have two distinguished base types unit and null. The base type unit is equivalent to⊤in the side of logic, whereas null represents falsehood⊥. Thus, unit does not influence other proofs; it holds anywhere vacuously. The same holds for the typenull→τ. Other base types correspond to the statements representing the final decisions made by an access control system, e.g., “fileXis deleted.” Such base types may act as hypotheses for the proof of other statements. Therefore, they are considered to be protected at no level. The operator says is a type constructor that takes an element A of latticeLand a type and returns a specific type that is protected at levels less than A. If principal B is less trusted than A, then what B says should not influence the proof of statements representing access to the objects controlled by A. In the case where principal B is not less trusted than A,Bsaysτis protected at level A ifτis protected at the same. A product type is protected at a level if both components are protected at that level. A function type is protected as long as the return type is. Finally, a polymorphic type is protected at a particular level if every type obtained from replacing the type variable with a specific type is protected. Note that sum types are not protected at any level, as they can influence what is more trusted through injection tags [36].The typing rules ofD∀Pare given in Fig. 5. All rules other thanunitMandbindMare standard typing rules for a predicative polymorphicλ-calculus. The ruleunitMintroduces the terms representing computations. It is the same as the standard typing rule for a monadic calculus except that the level of computation should be known in advance—A∈L. The rulebindMis the binding rule for computations in which the protection judgment appears as a premise.In this section, we propose a denotational semantics forD∀Pusing Henkin models. It is based on classical set theory where a function type is interpreted as the set of all mathematical functions from a specific domain to the co-domain that is denoted by its return type.The applicative structure forD∀Pis defined to be the tripleA=〈U,dom,{Appa,b,Appf,Proj1a,b,Proj2a,b,Inlefta,b,Inrighta,b,TA,a}〉,where1.U={U1A,U2A,→A,∀A,⁎A,+A,{TAA|A∈L},Itype}in which•U1AandU2Aare two sets such thatU1A⊆U2Aand0,1∈U1A,→A:U1A×U1A→U1A,∀A:[U1A→U2A]→U2A, where[U1A→U2A]={f|f:U1A→U2A},⁎A:U2A×U2A→U2A,+A:U2A×U2A→U2A,TAA:U2A→U2A, andItype:B→U1AwithItype(null)=0andItype(unit)=1;Itypeis an injective function as well.dom={Doma|a∈U2A}, where Domais a set of values for the type valuea∈U2A;Dom0={}andDom1={⊤}, andfor{Appa,b,Appf,Proj1a,b,Proj2a,b,Inlefta,b,Inrighta,b,TA,a}, we have•Appa,b:Doma→Ab→Doma→Dombfora,b∈U1A,Appf:Dom∀A(f)→U1A→⋃a∈U2ADoma, where for every valuev∈Dom∀A(f)and every type valuea∈U1A, we haveAppfva∈Domf(a),Proj1a,b:Doma⁎Ab→Domafora,b∈U2A,Proj2a,b:Doma⁎Ab→Dombfora,b∈U2A,Inlefta,b:Doma→Doma+Abfora,b∈U2A,Inrighta,b:Domb→Doma+Abfora,b∈U2A, andTA,a:Doma→DomTAA(a)fora∈U2AandA∈L.The applicative structureAshould be extensional. In addition to the conditions stated in [28], this requires the following extra condition:∀f,f′∈DomTAA(a)→b.∀d∈Doma.AppTAA(a),bf(TA,ad)=AppTAA(a),bf′(TA,ad)⇒f=f′.Moreover, for the applicative structureA, theA-environmentνis defined byν:Var→U1A∪⋃a∈U2ADoma,where Var is the set of variables. Then, for every type variable t,ν(t)∈U1A. We useν[a/t]andν[x↦a]to denote environments in which a particular variable is mapped to a specific value. The environmentν[a/t]represents the state in which t is mapped to the type value a. More formally,ν[a/t](s)={a,s=tν(s),s≠t.Similarly, the environmentν[x↦a]represents the state in which x is mapped to the term value a.Given an applicative structureAand anA-environmentν, the meaning of a type expressionτ, written〚τ〛ν, is defined by•〚t〛ν=ν(t)(t∈Var),〚b〛ν=Itype(b)(b∈B),〚τ→τ′〛ν=〚τ〛ν→A〚τ′〛ν,〚τ⁎τ′〛ν=〚τ〛ν⁎A〚τ′〛ν,〚τ+τ′〛ν=〚τ〛ν+A〚τ′〛ν,〚Asaysτ〛ν=TAA(〚τ〛ν), and〚∀t:U1.τ〛ν=∀A(f)wheref:U1A→U2Aandf(a)=〚τ〛ν[a/t].An environmentνsatisfies a contextΓ, writtenν⊨Γ, iffx:τ∈Γ⇒ν(x)∈Dom〚τ〛ν.We follow the meaning of term M of typeτin contextΓand context-satisfying environmentνas defined in [28] and give meaning to the new terms ofD∀Pby(3)〚Γ⊢ηAM:Asaysτ〛ν=TA,a〚Γ⊢M:τ〛ν,and(4)〚Γ⊢(letx⇐MinN):τ′〛ν=〚Γ,x:τ⊢N:τ′〛ν[x↦d]in whicha=〚τ〛ν,d∈Doma, and〚Γ⊢M:Asaysτ〛ν=TA,ad.An extensional applicative structureAis a Henkin model if the meaning function “〚·〛·” defined above is a total function.Lemma 1For any two type expressionsτandτ′, any type variable t, and any environmentν,〚[τ′/t]τ〛ν=〚τ〛ν[〚τ′〛ν/t].By induction on the structure ofτ.□The meaning function “〚·〛·” is total.By induction on the rules definingΓ⊢M:τ.□Noninterference is of great concern in distributed access control systems, where there exist diverse kinds of requesting entities, access rights, and requests. In such environments, it is significant to have trust in what is asserted by a principal and the way an access permission is derived. A principal can influence the derivation of an access permission through asserting those statement formulated by says constructor inD∀P. Noninterference can then be defined as a property requiring that untrusted principals may not influence the derivation of access permissions for trusted principals.To formalize this notion, we first consider the family of semantic relationsR={RAa,a′⊆Doma×Doma′|a,a′∈U2A,A∈L}which primarily represent the extent to which a principal trusts a computation or equivalently a proof. Rather than being indexed by a single type value, which is usual in logical relations as well as in defining and analyzing information flow properties, e.g., [22,4], the relations here are defined over two type values. This will facilitate the semantic interpretation of noninterference in access control. In access control, we need to say that replacing some statementτfrom a principal with any other statementσfrom the same does not influence the proof of the statement originated from a more trustworthy principal. Such a property cannot be expressed using semantic relations on single type denotations where the proof of a statement can only be substituted for another proof of the same statement. In fact, making restrictions on replacing a proof of a statement with another proof of the same statement does not reflect what is expected from noninterference in the context of access control.Our semantic relations are inductively defined in Table 1. If(v,v′)∈RAa,a′, then, in principal A's view,v∈Domais denoted by a proof term that can be replaced with another proof term denotingv′∈Doma′. We explain the relationRAa,a′through an example. Consider the type valuea∈U2A. If principal A trusts a,RAa,a′=∅holds for any type valuea′∈U2Aother than a. Put alternatively, in the side of the corresponding logic, A does discriminate between a proof of a statement (type) with denotation a and a proof of a statement with another denotation. However, if A does not trust a, thenRAa,a′=Doma×Doma′holds for any type valuea′that is not trustworthy to A. That is, A is indifferent between the proofs of the statement denoting a and the ones of any untrusted statement denotinga′. From now on, we say that the relationRAa,a′is complete ifRAa,a′=Doma×Doma′. Another case of indifference for A would be when there exist two proofs for a single statement, i.e., whena=a′. Indeed, what matters for the principal A is the provability of the statement rather than what proof is associated with the statement. Therefore,RAa,awould be complete as well.The denotations of base types are assumed to be trustworthy to any principal. Thus, for base typesb,b′∈Bwith〚b〛ν≠〚b′〛ν′the relationRA〚b〛ν,〚b′〛ν′is empty. The relation for the base types of the same denotation is complete. It should be noted that since the functionItypeis injective, the base types of the same denotation are the same. The relation concerning the denotations of two function types comprises all pairs(f,f′)that, in a principal A's vision, preserve closure with respect toR. That is, their return values are related for any pair of related input elements. In fact, in A's viewpoint, theλ-termdenoting f can be replaced with the term denotingf′. For the denotations of product types, p is in relation withp′if the terms denoting the components of p can be replaced with the terms denoting the components ofp′. The denotations of two sum types are related if they are the left or right injection of related denotations of respective types.Principal A trusts the computations of typeBsaysτdepending on B's trustworthiness in comparison with A's. If A is less trustworthy than B, from A's viewpoint, the denotations of two computations at level B are related provided the denotations of the terms on which computations are performed are related. If A is not less trustworthy than B, any pair of values denoted by computations at level B are related. Finally, the denotations of two polymorphic types are in relation with each other in a principal's vision if the results of their application to the denotation of every type are related.Theorem 2Assume thatΓ⊢M:σandν,ν′⊨Γfor two environmentsνandν′. If(ν(x),ν′(x))∈RA〚τ〛ν,〚τ〛ν′for allx:τ∈Γ, then(〚Γ⊢M:σ〛ν,〚Γ⊢M:σ〛ν′)∈RA〚σ〛ν,〚σ〛ν′.By induction on the typing rules given in Fig. 5. Here, we sketch the proof under the derivation by the rule t-app. In doing so, we assume that the theorem holds forΓ⊢M:∀t:U1.τ1and then we prove it forΓ⊢Mτ2:[τ2/t]τ1. IfΓ⊢Mτ2:[τ2/t]τ1,ν,ν′⊨Γ, and for allx:τ∈Γ,(ν(x),ν′(x))∈RA〚τ〛ν,〚τ〛ν′, then according to the induction hypothesis we have(〚Γ⊢M:∀t:U1.τ1〛ν,〚Γ⊢M:∀t:U1.τ1〛ν′)∈RA〚∀t:U1.τ1〛ν,〚∀t:U1.τ1〛ν′.Then, according to the definition of our logical relation over polymorphic types in Table 1,(AppF〚Γ⊢M:∀t:U1.τ1〛νa,AppF′〚Γ⊢M:∀t:U1.τ1〛ν′a)∈RA〚τ1〛ν[a/t],〚τ1〛ν′[a/t]holds for alla∈U1A, where F andF′denote the functions that are used to model the type∀t:U1.τ1inνandν′, respectively. Therefore, the above pair could be formulated as the pair of denotations forΓ⊢Mτ2:[τ2/t]τ1inνandν′.□Now, we define noninterference in the context of access control as a property to which principals cannot interfere with those requests made by more trustworthy or unrelated principals. In doing so, first we define evalAas follows:evalA=defΛt:U1.λz:Asayst.lety⇐ziny.The term evalAtakes a type and a computation of that type in level A and returns the result of the computation. It is worth noting that evalAcan only be applied to those types that are protected at level A.Definition 1A term N of typeσin contextΓ,t:U1,x:tsatisfies noninterference iff for every two type expressionsτandτ′and every principal A for which[τ/t]σand[τ′/t]σare not protected at A and every two terms M andM′of typesAsaysτandAsaysτ′,(〚Γ⊢N′τ(evalAτM):[τ/t]σ〛ν,〚Γ⊢N′τ′(evalAτ′M′):[τ′/t]σ〛ν′)∈RC〚[τ/t]σ〛ν,〚[τ′/t]σ〛ν′holds for every two context-satisfying environmentsνandν′and every principal C, where[τ/t]σand[τ′/t]σare protected at C andN′=(Λt:U1.λx:t.N):(∀t:U1.t→σ).The definition also implicitly assumes thatevalAτMandevalAτ′M′are well-typed.In a colloquial sense, a term N of typeσwith free variable x satisfies noninterference if, in every principal C's view, it does not matter which untrusted computation is substituted for x. Its logical interpretation is as follows: if A is less trustworthy than C, the proof ofσdoes not depend on a proof M ofAsaysτ, and thus, M can be replaced with any proofM′of any other statementAsaysτ′.In should be noted that our definition of a term satisfying noninterference is reminiscent of Reynolds' relational parametricity [32]. It states that the clients of an abstract data type behave uniformly for all available interpretations of that type and cannot depend on the way it is represented. A useful application of relational parametricity is the notion of representation independence [29,7] which states that two different implementations of an abstract type are equivalent if there is a relation between their type representations that is preserved by their operations. The semantics handling such a relation between types may be represented by logical relations over pair of type expressions.Definition 2We say that a language enforces noninterference, or is type-sound, iff every well-typed term of that language satisfies noninterference.D∀Pis type-sound.There are two kinds of typable terms, those protected at some level and those that are not protected at any level. For the terms of the second kind, the proof is immediate, as the premise of the theorem does not hold. For the terms that are protected at some level, we can use induction on the protection rules given in Fig. 4. More precisely, it is proven that the property P, defined below, holds ofπ([τ/t]σ,C).P(π([τ/t]σ,C))=(Γ,t:U1,x:t⊢N:σ∧¬π([τ/t]σ,A)∧¬π([τ′/t]σ,A)∧Γ⊢M:Asaysτ∧Γ⊢M′:Asaysτ′∧π([τ/t]σ,C)∧π([τ′/t]σ,C)∧Γ⊢evalAτM:τ∧Γ⊢evalAτ′M′:τ′)⇒(〚Γ⊢(Λt:U1.λx:t.N)τ(evalAτM):[τ/t]σ〛ν,〚Γ⊢(Λt:U1.λx:t.N)τ′(evalAτ′M′):[τ′/t]σ〛ν′)∈RC〚[τ/t]σ〛ν,〚[τ′/t]σ〛ν′.By¬π(σ,A), we meanσis not protected at level A. We prove the property overπ(Bsays[τ/t]σ,C)here—other cases can be treated similarly. In doing so, we use induction on the rules pr3 and pr4.•Proofunderderivationbytherulepr3: We show that ifC⪯BthenP(π(Bsays[τ/t]σ,C)). The typeBsays[τ/t]σis not protected at level A. Therefore, according to pr3 and pr4,A⪯Band[τ/t]σis not protected at level A. Similarly, from¬π(Bsays[τ′/t]σ,A), it is concluded that[τ′/t]σis not protected at level A. FromC⪯BandA⪯B, we haveA⪯C. Now, we define d andd′asd=〚Γ⊢M:Asaysτ〛νandd′=〚Γ⊢M′:Asaysτ′〛ν′. FromA⪯C, we haveRC〚Asaysτ〛ν,〚Asaysτ′〛ν′=Dom〚Asaysτ〛ν×Dom〚Asaysτ′〛ν′.Hence,(5)(d,d′)∈RC〚Asaysτ〛ν,〚Asaysτ′〛ν′.We also define f andf′asf=〚Γ,t:U1,y:Asayst⊢(Λs:U1.λx:s.N)t(evalAty):Bsaysσ〛ν[〚τ〛ν/t][y↦d],f′=〚Γ,t:U1,y:Asayst⊢(Λs:U1.λx:s.N)t(evalAty):Bsaysσ〛ν′[〚τ′〛ν′/t][y↦d′].Fromν[〚τ〛ν/t][y↦d](y)=d,ν′[〚τ′〛ν′/t][y↦d′](y)=d′, and (5),(6)(ν[〚τ〛ν/t][y↦d](y),ν′[〚τ′〛ν′/t][y↦d′](y))∈RC〚Asaysτ〛ν,〚Asaysτ′〛ν′.Moreover, according to Lemma 1, we know that〚Asaysτ〛ν=〚Asayst〛ν[〚τ〛ν/t][y↦d].Thus, we can rewrite (6) as(7)(ν[〚τ〛ν/t][y↦d](y),ν′[〚τ′〛ν′/t][y↦d′](y))∈RC〚Asayst〛ν[〚τ〛ν/t][y↦d],〚Asayst〛ν′[〚τ′〛ν′/t][y↦d′].From Theorem 2 and (7), it is concluded that(f,f′)∈RC〚Bsaysσ〛ν[〚τ〛ν/t][y↦d],〚Bsaysσ〛ν′[〚τ′〛ν′/t][y↦d],which is equivalent to(f,f′)∈RC〚Bsays[τ/t]σ〛ν,〚Bsays[τ′/t]σ〛ν′using Lemma 1. Finally, it can be easily shown thatf=〚Γ⊢(Λt:U1.λx:t.N)τ(evalAτM):Bsays[τ/t]σ〛ν,andf′=〚Γ⊢(Λt:U1.λx:t.N)τ′(evalAτ′M′):Bsays[τ′/t]σ〛ν′.Proofunderderivationbytherulepr4: IfP(π([τ/t]σ,C)), we haveP(π(Bsays[τ/t]σ,C)). As with the proof for pr3, it is derived thatA⪯Band the type expressions[τ/t]σand[τ′/t]σare not protected at level A. Moreover, fromπ(Bsays[τ/t]σ,C), we haveπ([τ/t]σ,C). Asπ(Bsays[τ′/t]σ,C), at least one of the cases below holds.1.C⪯B: The theorem has been proven for this case in the proof for pr3.π([τ′/t]σ,C): The typing judgmentΓ,t:U1,x:t⊢N:Bsaysσ, throughunitMin Fig. 5, implies that there exists a termN′of typeσwith free variable x of type t such thatN=ηBN′. Thus, from the induction hypothesisP(π([τ/t]σ,C)),we have(8)(〚Γ⊢(Λt:U1.λx:t.N′)τ(evalAτM):[τ/t]σ〛ν,〚Γ⊢(Λt:U1.λx:t.N′)τ′(evalAτ′M′):[τ′/t]σ〛ν′)∈RC〚[τ/t]σ〛ν,〚[τ′/t]σ〛ν′.Now, we consider the two casesB⪯CandB⪯C. For the former,RC〚Bsays[τ/t]σ〛ν,〚Bsays[τ′/t]σ〛ν′=Dom〚Bsays[τ/t]σ〛ν×Dom〚Bsays[τ′/t]σ〛ν′,and thus,P(π(Bsaysσ,C))holds. For the latter, according to (8), we have(TB,〚[τ/t]σ〛ν〚Γ⊢(Λt:U1.λx:Asayst.N′)τ(evalAτM):[τ/t]σ〛ν,TB,〚[τ′/t]σ〛ν〚Γ⊢(Λt:U1.λx:Asayst.N′)τ′(evalAτ′M′):[τ′/t]σ〛ν′)∈RC〚Bsays[τ/t]σ〛ν,〚Bsays[τ′/t]σ〛ν′.Therefore, from (3),(〚Γ⊢(Λt:U1.λx:Asayst.N)τ(evalAτM):Bsays[τ/t]σ〛ν,〚Γ⊢(Λt:U1.λx:Asayst.N)τ′(evalAτ′M′):Bsays[τ′/t]σ〛ν′)∈RC〚Bsays[τ/t]σ〛ν,〚Bsays[τ′/t]σ〛ν′.□Now, reconsider the example given in Section 2. In that example, it is assumed that there exists a proof M ofAsaysσif there is a proof N ofBsaysread[fileX]. It is also assumed that B is less trustworthy than A. In what follows, it is shown that deriving M from N is not possible, or equivalently, the term M is ill-typed. According to the typing rules given in Fig. 5, the only way to substitute a computation for a variable in a term is the application of the rule bindM. In other words, to derive M of typeAsaysσfrom N, N should be evaluated and substituted for some placeholder in an another term such that the result of substitution is M. This is not possible becauseAsaysσis not protected at level B.

@&#CONCLUSIONS@&#
