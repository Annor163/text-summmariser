@&#MAIN-TITLE@&#
Approximating closed fork-join queueing networks using product-form stochastic Petri-nets

@&#HIGHLIGHTS@&#
Product-form SPN approximation for fork-join networks with interfering requests.Conditions for accurate approximation.Validation against simulation.Evaluation of the performance of replication in NoSQL cloud datastores.

@&#KEYPHRASES@&#
Product-form stochastic Petri nets,Reversed Compound Agent Theorem (RCAT),NoSQL datastores,

@&#ABSTRACT@&#
Computing paradigms have shifted towards highly parallel processing and massive replication of data. This entails the efficient distribution of requests and the synchronization of results provided to users. Guaranteeing SLAs requires the ability to evaluate the performance of such systems while taking the effect of non-parallel workloads into consideration. This can be achieved with performance models that are able to represent both parallel and sequential workloads. This paper presents a product-form stochastic Petri-net approximation of fork-join queueing networks with interfering requests. We derive the necessary conditions that guarantee the accuracy of the approximations and verify this through examples in comparison to simulation. We apply these approximate models to the performance evaluation of replication in NoSQL cloud datastores and illustrate the composition of large models from smaller models, thus facilitating the ability to model a range of deployment scenarios. We show the efficiency of our solution method, which finds the product-form solution of the models without the representation of the state-space of the underlying CTMC.

@&#INTRODUCTION@&#
The advent of heterogeneous cloud services and their complex underlying interdependencies necessitate the need for predictive, quantitative modelling of their performance as a prerequisite for their efficient design. As the size and interoperability of these systems increases, simulation rapidly becomes prohibitive necessitating the need for lightweight analytical models or their approximations to analyze and predict the performance and related costs of such emerging architectures. Cloud pay-for-use services, virtualization and high speed data generation and processing require dynamic, self-managing and autonomous systems that can effectively respond to changes in workloads by amending their configurations to meet SLAs at runtime. Analytical performance models and approximations are candidates for such implementations (Huebscher and McCann, 2008) within lightweight dynamic configuration monitors and tools.The parallel processing paradigm has become the backbone of cloud and web services, in which requests are distributed to multiple processing nodes in parallel in order to decrease latency, in the case of high performance computing, and to increase availability in the context of web and cloud databases. This processing behavior is analogous to the fork-join structure in which arriving jobs are split to be processed at parallel nodes and then resynchronized after processing. Further, this fork-join split and synchronization behavior exhibits itself in(1)the parallel processing of Big Data within the MapReduce framework in which intermediate results are combined to form the final result (Dean and Ghemawat, 2008);RAID disk storage (Patterson et al., 1988) that delivers high reliability coupled with high performance through the access of replicated data on multiple disks;the parallel invocation of composite web services within a service application (Menasce, 2004); andeventual consistency in NoSQL datastores in which copies of replicated data items are compared for consistency (Cattell, 2011; Stonebraker and Cattell, 2011).Efficient utilization and energy efficiency require that infrastructure nodes are not dedicated to one application or service. Thus it is expected that in the above examples the infrastructure would process independent workloads that do not participate in the fork-join synchronizing process. These non-forking workloads will affect the performance, and thus the SLAs, of the forking requests. Such scenarios can be represented by fork-join systems with interfering requests; this allows for the performance analysis of realistic architectures and applications and does not isolate the forking requests from the effects of the environment.In this paper, we present the approximate analytical solution of fork-join queueing systems with interfering requests utilizing the product-form solution of stochastic Petri-nets (SPN) which we refer to as RB-n-m replication blocks. These models are applied to the performance analysis of NoSQL cloud datastores. Modelling replication in NoSQL datastores requires the representation of(1)the processing of requests arriving at a node;the synchronization of requests for multiple copies of a data item and;the routing of requests based on the number of copies stored across the cluster.NoSQL datastores cater mainly to distributed Web 2.0 applications (Stonebraker and Cattell, 2011) which require low latency with a weaker guarantee of data consistency (Cattell, 2011). Thus datastore performance depends on the ability of the nodes to cooperate in satisfying user requests in a timely fashion.The primary technique used to solve the approximate fork-join queueing models is the Reversed Compound Agent Theorem (RCAT) (Harrison, 2003), which provides a unified framework for the derivation of product-form solutions for cooperating Markovian processes by representing the cooperation as RCAT rate equations. We approximate the fork-join queueing system as a certain type of synchronizing product-form stochastic Petri nets called building blocks (Balsamo et al., 2012) and derive the assumptions needed to accurately represent the performance measures of the fork-join queueing system. Automated direct solutions of the RCAT rate equations have not been attempted, as it has been deemed difficult due to the non-linearity of the equations (Balsamo et al., 2010a). In this paper, we formulate the solution of the RCAT rate equations into a non-linear optimization problem and illustrate the scalability and flexibility of the technique in comparison to current methods in the literature.The contributions of this paper are the following:•We present an approximation of fork-join queueing networks with interfering requests based on product-form SPNs, which we have called RB-n-m replication blocks. We give the conditions which guarantee the accuracy of these approximations and give counter examples when they exist. We validate the solution of the RB-n-m replication blocks in comparison to simulation for any n places and any m partial or full forking requests.We apply the product-form RB-n-m replication blocks to replication in NoSQL datastores and analyze the performance of these systems. In addition, we show how to compose larger models from smaller RB-n-m models to evaluate non-centralized scenarios. At present, performance modelling has concentrated on traditional relational databases (Osman and Knottenbelt, 2012), using mainly queueing networks, (e.g. Nicola and Jarke (2000); Elnikety et al. (2009); Di Sanzo et al. (2010); Osman et al. (2011)) and queueing Petri nets, e.g. (Osman et al., 2013; Coulden et al., 2013). Recent work (Osman and Piazzolla, 2014; Gandini et al., 2014) in modelling NoSQL replication uses simulation based techniques to solve the models.We have formulated the RCAT rate equations of our models as a non-linear optimization problem, which finds the product-form solution of the models without the representation of the state-space of the underlying CTMC. We show that our method is more flexible and scalable in comparison to existing RCAT automated solution methods in the literature.The rest of this paper is organized as follows. Section 2 presents the background and related work for fork-join systems. In Section 3, we present the details of the product-form approximation and conditions for accuracy. We illustrate the generatation of the RCAT rate equations in Section 4. Validation of the models is presented in Section 5. We model and evaluate the performance of NoSQL datastores in Section 6. Finally, we conclude the paper and provide directions for future work in Section 7.Fig. 1details an n-branch fork-join queueing system where each branch is represented by an M/M/1 queue. The system has two types of arrivals: forking and interfering. Forking requests arrive at the forking point and are split into m (m > 1) independent tasks to be served in parallel at all of the m queues. Tasks that have completed their service wait at the join point until all m jobs have competed their service and then re-join and leave the system. Interfering jobs are independent arrivals to any of the n queues that do not fork and thus affect the processing of forked tasks as shown in Fig. 1. In this paper we refer to forked arrivals as replicated requests and interfering arrivals as non-replicating requests.Arriving jobs can be forked to m < n queues, known as partial fork, orm=nqueues known as full-fork. Fig. 1 shows an example of full-forked tasks. Partial forked jobs will randomly choose m of the n queues for service. Dynamic forking is when a forked request will arrive with a different probability to each of the m queues. Fork-join systems can be homogenous, i.e., all service times for forked and interfering requests are the same or heterogeneous in which their service times differ at each queue. In this paper, we examine homogeneous systems and partially heterogeneous systems in which the service times for the forking (interfering) requests are the same at each queueing center. We present cases for full fork and partial fork, both with interfering requests.

@&#CONCLUSIONS@&#
This paper presented a product-form approximation of closed fork-join queueing systems with interfering requests using SPNs in the form of RB-n-m replication blocks under conditions for the SPN transitions. This has been illustrated through the modelling of single-master replication in NoSQL datastores in which the RB-n-m gave excellent accuracy. In addition, we have demonstrated the ability to compose smaller RB-n-m replication blocks to form larger clusters with more realistic properties. The scalability and resource efficiency of the solution of the RB-n-m models makes them amenable to lightweight incorporation within autonomous monitoring and feedback systems for cloud datastores.We have shown that it is possible to accurately incorporate replication and synchronization within larger Markovian models without undue costs of analysis. Our method of directly solving the RCAT rate equations as a nonlinear optimization problem eliminates the need for representing the underlying CTMC of the cooperating Markovian processes and thus allowing for the modelling and analysis of large and complex systems. In addition, the ability to integrate user-defined constraints on the variables and parameters in the optimization problem provides the modeller with the flexibility to experiment with different configurations and parameterizations, thus imposing pre-defined conditions on the feasible solution, and producing different product-form solutions when they exist. Further, as the solution method described in this paper is not specific to product-form RB-n-m replication blocks it can be efficiently applied to solve large models with heterogeneous cooperating agents that satisfy the RCAT conditions.Our models have focused on the RB-n-m class of replication blocks, in which non-replicated requests are sent to each of the n nodes in a cluster and all combinations of m nodes –(nm)of them – also receive replicated requests, i.e. full and partial fork-join systems. It is straightforward to model replication in which not every combination of the m nodes is available for replication and also more or less than m nodes may be used; giving an RB-n-{m1,…,mk}building block, where1≤mj≤n,j=1,…,k,in the event that all combinations of{m1,…,mk}nodes are available, for example. The method applied in this paper is applicable to open systems, and as the product-form constraints are less restrictive, more representative scenarios can be explored. We would need to investigate the accuracy conditions of such product-form models when approximating fork-join queueing systems with interfering requests and configurable forks.Assume we have a set of cooperating Markovian processes:M={P1,…,PN}. A state transition in the CTMC of the network is denoted by an action. A cooperation between two components or processes involves a set of actions A, with labels a. Each action a represents a synchronizing transition in a pairwise cooperation between processes Piand Pj(i ≠ j), which takes place in both processes simultaneously. If an action a causes a state transition (si→si′) in Piand a corresponding transition from (sj→sj′) in Pj(i ≠ j), both with rate μa, then a is considered an active action in Piand a passive action in Pj. For simplicity we will use a simple example to illustrate the application of RCAT.To derive a product-form using RCAT the reversed rates of the synchronizing active actions must be calculated. The reversed rate for a transition from state i to state j with rate λ is (Kelly, 1979):(16)rλ¯=π(i)λπ(j)where π(·) denotes the equilibrium probability function of the CTMC.Assume we have an open queueing network with three M/M/1 nodes in tandem: P1, P2, P3, each with service rates μ1, μ2, μ3, respectively. External Poisson arrivals arrive at P1 with rate λ1, are serviced and immediately proceed to P2, then to P3 and leave the network after processing. Therefore,M={P1,P2,P3}andA={λ1,μ1,μ2,μ3}. Let Ridenote the isolated component for the process Pi. The goal of RCAT is to find the rates of these isolated components in order to calculate the product-form. The steps to apply RCAT are as follows (Harrison, 2010):1.For each Pi, construct Riby setting the rate of every instance a ∈ A that is passive in Pito xa. Hence:R1∼{λ1,μ1}(nopassiveactions),R2∼{xμ1,μ2}(μ1isapassiveactioninP2),R3∼{xμ2,μ3}(μ2isapassiveactioninP3).where we have used the symbol ∼ to indicate that a process is given by its defining instantaneous transition rates.For each active action a ∈ Ri, check that the reversed rate,ra¯is the same for all its instances. Applying (16) we have:rμ1¯=λ1,rμ2¯=xμ1,rμ3¯=xμ2.We note that the reversed ratera¯will in general be a function of xb, where b ∈ A.Solve the rate equations:xa=ra¯for each a ∈ A. This step gives:xμ1=rμ1¯=λ1,xμ2=rμ2¯=xμ1.which simplifies to:xμ1=xμ2=λ1.Substituting the solution of the rate equations in Rigives:R1∼{λ1,μ1},R2∼{λ1,μ2},R3∼{λ1,μ3}.Check that the RCAT enabling conditions (Harrison, 2003) stated below are satisfied.The required product-form for states=(s1,s2,s3)is π(s)∝π1(s1)π2(s2)π3(s3) where πk(sk) is the equilibrium probability of state skin Rk. In this case:π(s1,s2,s3)=∏i=1,2,3(1−ρi)ρisi,ρi=λ1/μi.Informally, the RCAT conditions require (Harrison, 2003; Harrison and Marin, 2013):1.If a synchronizing type t is passive in a component, then all states of that component must have one outgoing transition with type t;If a synchronizing type t is active in a component, then all states of that component must have one incoming transition with type t;In the isolated components, all transitions sharing the same active synchronizing type must have the same reversed rate.For queueing networks, all passive actions are enabled in all states and all states have an incoming instance of every active action. This is straight forward for an M/M/1. For the formal definition and proof of RCAT and its extension to two way and multi-way synchronizations the reader is referred to (Harrison, 2003, 2004; Harrison and Lee, 2005).The elegance of RCAT and its extensions (Harrison, 2004; Harrison and Lee, 2005), has been in providing a unified automated approach to deriving product-form solutions to a variety of known cooperating Markovian processes: i.e., Jackson queueing networks (Harrison, 2003), BCMP networks (Harrison, 2004), G-networks with triggers (Harrison and Marin, 2013) and stochastic Petri nets (Balsamo et al., 2012). Moreover, Extended RCAT has produced new product-form solutions for G-networks with generalized resets (Harrison, 2004), finite capacity queues with blocking or skipping (Balsamo et al., 2010b) and stochastic Petri nets with signals (Marin et al., 2012).Current work in automating the application of RCAT and the identification and/or solution of the rate equations falls into two categories:•Algorithms to derive the rate equations for specific Markovian processes, e.g., in Harrison and Marin (2013) the authors describe a general algorithm to derive the rate equations for any set of cooperating Markovian processes specified in PEPA (Hillston, 1994). In Balsamo et al. (2012), an algorithm to identify the basic building blocks of a stochastic Petri net is described. Even though these algorithms have not been automated, the implementation is straightforward and can be generalized to identifying reversed rates and the RCAT rate equations from XML representations of Markovian models.Automated algorithms to compute the values of the reversed rates by applying RCAT conditions to the CTMCs of the cooperating agents (Casale and Harrison, 2013; Balsamo et al., 2010a; Marin and Bulo, 2009). This is conducted without direct use or solution of the rate equations. These methods solve subsets of RCAT models and are computationally expensive in comparison to the method described in this paper. Moreover, the description of the input is not straightforward, as in some cases the CTMC must be truncated in order for a feasible solution to be calculated.