@&#MAIN-TITLE@&#
The generalized covering traveling salesman problem

@&#HIGHLIGHTS@&#
We develop a problem with potential applications in humanitarian relief transportation and telecommunication networks.Two mathematical methods and two metaheuristic algorithms are proposed to solve the problem.The introduced problem is a generalization of the covering salesman problem and the proposed method has been adapted to be used for this problem as well.The results have been compared with the state of the art algorithms available in the literature.

@&#KEYPHRASES@&#
Traveling salesman problem,Humanitarian relief transportation,Memetic algorithm,Variable neighborhood search,

@&#ABSTRACT@&#
In this paper we develop a problem with potential applications in humanitarian relief transportation and telecommunication networks. Given a set of vertices including the depot, facility and customer vertices, the goal is to construct a minimum length cycle over a subset of facilities while covering a given number of customers. Essentially, a customer is covered when it is located within a pre-specified distance of a visited facility on the tour. We propose two node-based and flow-based mathematical models and two metaheuristic algorithms including memetic algorithm and a variable neighborhood search for the problem. Computational tests on a set of randomly generated instances and on set of benchmark data indicate the effectiveness of the proposed algorithms.

@&#INTRODUCTION@&#
The traveling salesman problem (TSP) is one of the most studied problems in the field of combinatorial optimization. Given a graph G=(N, E), the TSP is to find a minimum length Hamiltonian cycle of the vertices in N in which each vertex has to be visited exactly once [13].The quota traveling salesman problem (QTSP) is a generalization of the TSP in which the salesman has to visit a given quota of vertices while minimizing the total travel cost [4,10]. In this problem, each vertex has a pre-determined amount of prize that could be collected by the salesperson by being visited on the tour. The k-TSP is a special case of the QTSP in which each vertex has one unit of prize and the goal is to visit k vertices, in order to collect k units of prize [15,30].Introduced by Balas in 1989 [5], in the prize collecting traveling salesman problem (PCTSP) it is given a set of vertices in which each vertex has a pre-determined amount of prize. The goal of the PCTSP is to collect a certain amount of prize, while minimizing the routing and penalty costs. Essentially, the routing cost is the total distance traveled by the salesman and the penalty cost is the cost occurred by not visiting a vertex on the tour [5,9].Many variations of the standard TSP are introduced in the literature including the online TSP [38], the TSP with pickup-and-delivery [42], clustered TSP [6], generalized TSP [27,29], multi-depot multiple TSP [17] and etc. To the complete survey on the TSP and its variants, we refer the interested readers to the book by Gutin and Punnen [19].There is a vast body of literature dedicated to covering problems. The purpose of such problems is to satisfy the customers’ demand in two different ways. Essentially, different customers’ demand can be provided at the same location at which they are located or it can be delivered at a destination within a pre-specified distance of the customer locations [41].Several variations of the TSP with potential applications in route designing of the healthcare teams in developing countries [16], and applications from design of the distributed networks [21] have been introduced. In these two problems and some others which are proposed in the literature, there is no need to visit all the customers on the tour structure and the objectives can be satisfied by visiting a limited number of customers. As an example we can refer to the case of emergency management in which it is not possible for the medical team to visit all the customers on the tour. In such situation, a subset of customers can be visited on the tour and the rest of them are covered, i.e., located within a pre-specified distance of at least on visited customer.The covering salesman problem (CSP) is a generalization of the TSP in which we have to satisfy all the customers’ demand by visiting or covering them [11]. Essentially, for each customer, say i, it is given a covering radius di, within that all the located customers will be covered. The goal of the CSP is to construct a minimum length tour over a subset of the given customers such that each customer, not visited on the tour, is within the covering distance of at least one visited customer [11]. Many papers have discussed on the application of this problem and some of its generalization in the fields of emergency management and disaster planning [1,34,35,37].What happens in reality when satisfying a given set of customers’ demand, is somehow different from the assumptions made in many problems, introduced in the literature. As an example, usually the distribution centers cannot be constructed at the same location at which the customer zones are located. Essentially, there can be a situation in which it is not possible for the health care team to assess the customer zone by vehicles. So, they need to locate the facilities in a location different from the customer zone. Moreover, in the QTSP case the customers can travel to a facility location to receive their demands.Taking into account the above assumptions, in this paper we propose a generalization of the TSP with applications in humanitarian relief transportation. Suppose we are given a set of vertices including a central depot, facility and customer vertices. Each customer i has one unit of demand (prize) that will be satisfied when it is located within a certain coverage radius of at least one facility j visited by the tour. Essentially, each facility j has a coverage radius djwithin that all the available customers are covered. The goal of the problem is to construct a minimum length Hamiltonian cycle over a subset of facilities, while collecting the specified amount of prize P.The introduced problem is a generalization of the CSP, TSP, k-TSP and the QTSP and all applications already introduced for these problems could be easily extended to the new developed problem. Letting P=21, Fig. 1represents an example in which 4 facilities have been visited by the tour and 21 customer vertices are covered by the visited facilities.The paper is organized as follows. Section 2 develops a formal description of the problem. The details of the proposed solution methods are provided in Section 3. Extensive computational tests for the studied problem and one of its variants (CSP) are reported in Section 4, followed by conclusion and future directions given in Section 5.The problem is defined on a directed graph G=(V, A), where V={0}∪W∪T contains three sets of vertices including the depot, {0}, the set of customers, W, and the set of facilities, T. Moreover, the set of arcs is given by A={(i, j)|i, j∈T∪{0}}. To each (i, j)∈A is associated a travel cost represented by tijand each customer i has a prize, pi, that will be covered by the tour when it is located within the predefined coverage distance of at least one routed facility. We denote by Tithose facilities that are able to cover customer i. The goal of the problem is to collect a pre-determined amount of prize, P, while minimizing the total traveled length.The decision variables to model the problem are defined as follows:(1)xij=1ifarc(i,j)isvisitedbythetour,0otherwise.∀(i,j)∈A(2)zij=1ifthedemandofcustomeriisallocatedtothefacilityj,0otherwise.∀i∈W,j∈TFinally, for each i∈T, uiis a continuous variable representing the tour load before visiting vertex i.In what follows, we extend two mathematical models for the studied problem. Based on the formulations developed for the TSP and its variants, we divide the models into two groups namely, node-based and flow-based formulations.In this section, we develop a node-based formulation for the studied problem. This kind of formulation, applies the well known Miller–Tucker–Zemlin subtour elimination constraints proposed for the TSP [14,25,31].(3)min∑(i,j)∈Atijxijsubject to:(4)∑i∈W∑j∈Tipizij≥P(5)∑j∈Tizij≤1∀i∈W,(6)∑j∈T∪{0}x0j=1(7)∑j∈T∪{0}xij=∑j∈T∪{0}xji∀i∈T∪{0},(8)zij≤∑k∈T∪{0}xkj+∑k∈T∪{0}xjk∀i∈W,j∈Ti,(9)ui−uj+(|T|+1)Xij≤|T|∀i,j∈T,(10)xij∈{0,1}∀i,j∈T∪{0},(11)zij∈{0,1}∀i∈W,j∈Ti,(12)uj≥0∀j∈T∪{0}.The objective function (3) is to minimize the total traveling cost. Constraint (4) assures the total collected prize, by the eligible facilities, to be greater than or equal to the pre-specified value P. For each i∈W, constraint (5) assures customer i to be allocated to at most one facility j∈Ti. Constraint (6) makes sure that the tour to be started from the depot, followed by the in-degree and out-degree constraints (for each i∈T∪{0}) represented by constraints set (7). For each customer i and facility j∈Ti, constraint (8) shows that, i could be allocated to j only if j is visited by the tour. Constraint set (9) models the sub-tour elimination constraints. Finally, constraints (10)–(12) define the model variables.Several papers have reported successful results of applying flow-based formulations for different routing problems [26,39]. In this section we adapt this kind of formulation to be used for our developed problem. To do so, for each i, j∈T∪{0} a set of continuous variables are introduced as follows.uijis a continuous variable, representing the tour load after leaving vertex i and just before visiting vertex j. Based on the description of the new introduced variables (uij), the model reads as follows.(13)min∑(i,j)∈Atijxijsubject to:(14)∑i∈W∑j∈Tipizij≥P(15)∑j∈Tizij≤1∀i∈W,(16)∑j∈T∪{0}x0j=1(17)∑j∈T∪{0}xij=∑j∈T∪{0}xji∀i∈T∪{0},(18)zij≤∑k∈T∪{0}xkj+∑k∈T∪{0}xjk∀i∈W,j∈Ti,(19)∑j∈Tu0j=∑i∈W∑j∈Tizij(20)∑j∈T∪{0}uji−∑j∈T∪{0}uij=∑j∈Wzji∀i∈T,(21)∑j∈Tuj0=0(22)uij≤|W|xij∀i,j∈T∪{0},(23)xij∈{0,1}∀i,j∈T∪{0},(24)zij∈{0,1}∀i∈W,j∈Ti,(25)uij≥0∀i,j∈T∪{0}.The objective function (13) and the constraints (14)–(18) are the same as those already explained for the node-based formulation (i.e., (3)–(8), respectively). Constraints (19)–(21) are the subtour elimination constraints. Essentially, constraint (19) assures that the initial tour load, before leaving the depot, to be equal to the total prize that will be collected by the tour. Constraint (20) makes sure that the load difference of the tour before and after visiting a facility, say i, is exactly equal to the prize allocated to the facility i. Constraint (21) sets the total load of the vehicle, when returning to the depot, to 0. For each (i, j)∈A, constraint (22) models the relation between the routing (xij) and the flow (uij) variables. Essentially, we are not allowed to send flow along arc (i, j)∈A when its corresponding variable xijis not visited by the tour. Finally, decision variables are given in (23)–(25).Two metaheuristic algorithms, namely memetic algorithm (MA) and variable neighborhood search (VNS) are developed for the introduced problem. In the following, the details of these algorithms are provided.The genetic algorithm (GA) is a global search optimization technique, developed by Holland [22], with effective results in different areas including business, science, and engineering [12,24,28,40]. MA is the GA hybridized with the local search ideas [33]. Several variants of the TSP have been solved by MA with very good results. For example we can refer to the works by Bontouxa et al. [7], Buriol et al. [8] and Gutin and Karapetyan [20].In this section we develop a MA for the studied problem which its flow chart is depicted in Fig. 2. It starts by constructing the initial population set containing a set of Npchromosomes (Section 3.1.2). At each iteration, the crossover (Section 3.1.5) is applied over a set of individuals selected during the selection phase as described in Section 3.1.4. Since the generated offspring could be infeasible, the feasibility recovery procedure is developed to make the solutions feasible for which the details are provided in Section 3.1.6. Upon this step, the mutation and local search phases are applied to the offspring (see Sections 3.1.7–3.1.8, respectively) and the repeated solutions are eliminated from the set of new generated offspring. Finally, the survivors are selected (Section 3.1.9) and the algorithms iterates as long as the best solution has not been improved for γ successive iterations. In what follows, the details of the MA's different procedures are provided in details.Permutation representation is used to the genetic representation of the solutions. Using this kind of representation, each chromosome contains an ordered set of facilities and the depot which are visited by the tour. Fig. 3provides the representation of the solution shown in Fig. 1, where totally four facilities are visited by the tour.A set of Npindividuals is generated by following four different procedures developed to this purpose.•Construction rule 1: the algorithm applies a randomized variation of the nearest neighbor algorithm, proposed for the traveling salesman problem [3]. Starting from the depot, at each step of this procedure the next facility to be visited by the tour is randomly selected from those that are among the three nearest facilities of the last visited vertex covering at least one unit of unsatisfied demand. The algorithm keeps adding the facilities to the tour, as long as the total collected prize is less than P. Finally, the tour will be terminated by visiting the depot as the last vertex of the tour.Construction rule 2: within this procedure, the facilities are selected from those that are able to cover the largest number of uncovered customers. Starting from the depot, the next vertex to be visited by the tour is randomly selected, from the three facilities that are able to cover the largest number of uncovered customers. Upon adding the selected facility to the tour, the coverage of customers will be updated and the process continues until at least P units of prize is collected by the tour. The Hamiltonian tour will be terminated by visiting the depot as the last vertex of the tour.Construction rule 3: in this procedure an initial solution is generated by combining the first two methods. Essentially, at each step the new added facility is selected from those with the minimum distance from the last visited facility or those which are able to cover the largest number of uncovered customers. To do so, as long as the solution is infeasible the new facilities are added to the tour by following rules 1 and 2 in turn.Construction rule 4: the Hamiltonian cycle is constructed by selecting the facilities, randomly. Particularly, as long as the solution is infeasible, a facility is randomly selected, from those unvisited facilities that are able to cover at least one unit of unsatisfied demand. At each iteration, the new facility is visited in the last position of the tour.Finally, 50, 30, 15 and 5 percent of the Np individuals, are generated by following rules 1 to 4, respectively.According to the objective function definition, the fitness of each individual is calculated by using the objective function (3) which is the summation of the total length (time) traveled by the tour.By applying the selection phase, we aim at selecting a set of K individuals to perform the crossover and mutation. To do so, we propose three rules in order to select the individuals.•Roulette wheel selection: the roulette wheel selection is applied to select the individuals. Essentially, the probability of selecting the individuals is directly proportional to their fitness values. Letting fito be the fitness value of each indivisual i, the probability of selecting i is as follows:(26)pi=fi(∑i=1Npfi)Random selection: by following this rule, all individuals have the same probability to be selected. Particularly, the probability for selecting each individual is 1/Np.Best selection: the chromosomes are listed based on their fitness value and the first K individuals, i.e., those having the best fitness function, are selected.To do the crossover, two chromosomes have to be chosen from the set of K individuals selected within the selection phase. To select such two chromosomes, we propose to use the following rules:•Crossover rule 1: to do the crossover we always select the chromosome with the best fitness value as one of the parents and the next is selected from the remaining K−1 individuals. As a result, totally K−1 pairs of chromosomes are evaluated using this rule.Crossover rule 2: two parent chromosomes are selected uniformly randomly. So, a set of K/2 pairs will be available by following this rule.Upon selecting the parents, we apply one point move crossover to obtain the offspring. To do so, a position along each chromosome string is selected, randomly, and the substrings of the parents will be exchanged to generate the children. An example is represented in Fig. 4.The offspring, resulted from the crossover may be infeasible. In order to work with the feasible chromosomes, a simple procedure is developed (see Algorithm 1, that makes the offspring feasible. Essentially, the infeasibility may occur because of two problems: there could be some facilities visited more than once or there could be a situation in which the total number of covered customers, by the available facilities in the tour structure, is less than P. To generate a feasible solution from an infeasible one, the extra facilities are removed from the tour and while the solution is infeasible, by not being able to cover at least P units of customers’ demand, a set of promising facilities are added to the tour to recover the feasibility. Essentially, the promising facilities are those that are able to cover the maximum number of uncovered customers.Algorithm 1Feasibility recovery.Starting from the first facility visited by the tour, extract all illegal facilities, i.e., those that are visited more than once;While(The solution is not feasible)doj:= Select an unvisited facility that by adding to the tour, covers the maximum number of uncovered customers;Add the facility j to its best position, i.e., the position that leads to the minimum extra insertion cost;endEach visited facility in a given chromosome has a probability β to be extracted from the solution and being substituted with a set of other potential facilities. Essentially, upon extracting a facility, say j, from the tour, a facility will be randomly selected from the θ unvisited nearest ones to the j and is added to its best position in the tour, i.e the position leading to the minimum extra insertion cost. As long as the solution is not feasible, this procedure continues adding the facilities to the tour by randomly selecting the facilities. If the procedure is not able to recover the feasibility by adding all θ facilities, the original extracted facility j is put back into its original place and the procedure continues by applying this process to the next routed facility. The general framework of the mutation procedure is provided in Algorithm 2.In order to intensify the search, two kinds of move, namely 2-opt and drop-and-add procedures, are developed. By applying the 2-opt procedure, the goal is to improve the tour length by changing the order of the facilities visited by the tour. Within the drop-and-add procedure, a facility is extracted from its location in the tour. In case of feasibility and improving the objective function, the extracted facility will not be reinserted in the tour, otherwise, the algorithm searches for the best feasible substitution from the N facilities nearest to the extracted one with the minimum extra insertion cost. Essentially, all sequences consisting of one or two facilities are generated and the best feasible substitution leading to an improvement in the objective function will be implemented, otherwise, in case of having a worse solution, the extracted facility is put back into its original place. In a random order, both 2-opt and drop-and-procedures, are applied until we have no improvement in the tour length.Algorithm 2Mutation procedure.J:= The set of randomly ordered facilities visited in the (CurrentSolution);j:= 0;While (j≤|J|)rand:= Randomly generate a number in [0, 1];if (rand≤β) thenExtract the jth facility of J;L:= The set of θ randomly ordered facilities nearest to j;l:= 1;NewSolution:= CurrentSolution;While (l≤θ or the solution is not feasible) doNewSolution:= Select facility l from the set L and add it to its best position in the NewSolution;l:= l + 1;endif (the new solution is feasible) thenCurrentSolution:= NewSolution;endendj:= j + 1;endThe set of Npinitial chromosomes and the new generated children are sorted in a non-decreasing order of the fitness value. To obtain the next generation, the set of both Npinitial and children chromosomes are divided into three groups. Essentially, the first group (A) contains 50% of those chromosomes having the best fitness value in the ordered lists. The second (B) and third (C) groups contain the next 30% and 20% of the chromosomes from the ordered lists, respectively. Upon this procedure, the group A of children chromosomes are substituted with those having the worst fitness value in group A of initial chromosomes. This process is repeated for the next two groups as well. Within this procedure, the substitutions are done in a way that the population size (Np), will remain fixed.Proposed by Mladenović and Hansen [32], VNS is a metaheuristic algorithm that explicitly applies a strategy based on dynamically changing neighborhood structures. The general framework of the VNS algorithm for the introduced problem is given in Algorithm 3. The algorithm starts to construct an initial solution (CurrentSolution) by applying the construction rule 1 (see Section 3.1.2). It then improves upon this initial solution by applying the 2-Opt and drop-and-add procedures (see Section 3.1.8). The improvement of the solution continues in a loop until the termination criteria is met which is a given number of iterations (ρ) without having an improvement in the cost of the best known solution. The loop contains a shaking procedure and the local search procedures. If a solution is improved by applying the shaking and local search procedures it will be accepted as the incumbent solution. We also utilize the threshold accepting criterion in updating the current solution at the end of each iteration of the VNS algorithm. Essentially, a worse solution is accepted as the current solution if it is not worse than a given percentage (λ) of the cost of the best known solution. At each iteration of the VNS algorithm we apply the shaking procedure in order to dynamically expand the neighborhood structure. In particular, the algorithm generates a solution which is in the neighborhood size k of the CurrentSolution, i.e., Shaking(CurrentSolution, k). Specifically, Shaking(CurrentSolution, k) is defined as the set of solutions that can be obtained from the CurrentSolution by calling the addition or removal procedures for k times. The details of these procedures are given in the following:•Removal procedure: routed facilities on the tour of the solution are sorted in a non-increasing order of a score which is defined in (27). In this relation RemovalCost(i) is the cost saving occurred by removing facility i form the solution while RemovalCover(i) is the number of customers that are explicitly covered by facility i.(27)Rremove(i)=RemovalCost(i)(RemovalCover(i)+1)foreachroutedfacilityiFollowing this step, the first α facilities of the ordered set are considered as the candidate list. Finally, a facility is selected from the candidate list randomly and is removed from the solution.Addition procedure: unrouted facilities are sorted in a non-increasing order of their score values which is defined in (28). In this relation AdditionCost(i) is the cost imposed to the tour length by adding facility i into its best position in the tour, i.e., the location with the cheapest extra insertion cost. Moreover, AdditionCover(i) is the total number of uncovered facilities that will be covered by visiting facility i in the solution.(28)Radd(i)=AdditionCover(i)(AdditionCost(i)+1)foreachunroutedfacilityiFollowing this step, the first δ facilities yielding the maximum score are considered in the candidate list from which one facility is selected randomly and added into its best position in the current tour.Algorithm 3The general framework of the VNS algorithm.CurrentSolution:= Initialization();CurrentSolution:= 2-Opt(CurrentSolution);CurrentSolution:= drop-and-add (CurrentSolution);BestSolution:= CurrentSolution;Iter:=1;While (Iter ≤ρ) dok = 1;While (k≤ϕ) doCurrentSolution:=Shacking(CurrentSolution, k);CurrentSolution:= 2-Opt(CurrentSolution);CurrentSolution:= drop-and-add (CurrentSolution);if (Cost(CurrentSolution)<Cost(BestSolution)) thenBestSolution = CurrentSolution;k:=1;Iter:=1;if (Iter>ρ) thenbreak;endendelse if (Cost(CurrentSolution)<(1+λ)Cost(BestSolution))thenIter:= Iter + 1;k:=k+1;endelseCurrentSolution:= BestSolution;Iter:= Iter + 1;k:=k+1;if (Iter>ρ) thenbreak;endendendendTo test the performance of the developed algorithms a set of 115 instances are designed, derived from TSP library [36]. The generated data ranging in size from 51 to 1000 vertices which are divided into small (|V|≤76), medium (100≤|V|≤200) and large size (535≤|V|≤1000) instances. According to the developed problem characteristics, the set of vertices is divided into three groups. The first vertex in each datum is considered to be the depot and the rest of the vertices are divided into facility and customer vertices. From each instance, we have generated three new data in which 30, 40 or 50 percent of the vertices (V) are considered to be the facility vertices, respectively. Moreover, we assume that each facility j∈T to be able to cover its NC nearest customers. In our designed instances, NC is a random value taken from [1,10]. Finally, from each instances three new data are designed for which 50, 75 and 100 percent of the customers have to be covered, respectively. Moreover, a set of 27 test instances are generated having 100, 150 or 200 vertices. To generate this set of test instances, we follow the same rules already explained for the original data.The metaheuristic algorithms have been implemented in C++ and tested on PC with an Intel Core i5 processor running at 2.27GHz with 4GB RAM. A simple test has been conducted to reach a good combination of the parameters involved in the designed algorithms. For each test instance and each parameter combination, 5 independent runs of the algorithm have been done and by taking into account the average performance of the results, the best combination of the parameters has been driven. For both algorithms, Table 1provides the range of the parameters and the best combination used to run the final experiments.Regarding the MA, three and two different rules were proposed for the selection (Section 3.1.4) and crossover (Section 3.1.5), respectively. Here, we perform a simple test to select the best way of combining them in order to be used within the general framework of the MA. Table 2reports the result of different combinations obtained by running the algorithm over the set of test instances. Preliminary tests show that the algorithm results are not so sensitive to different parameters’ configuration. So, to run the instances we use the following set of parameters: Np=100, Nc=20, β=0.05, θ=4, N=10 and γ=120. Based on these results, on average the combination of the “Roulette wheel” in selecting the parents and “rule 1” for doing the crossover, leads to the best performance. Moreover, there is only 0.41% of gap between the best and worst performance of the available six different combinations over the set of 27 test instances.We have used ILOG Cplex 12.1 [23] to run the node-based and flow-based models to optimality. Particularly, 3600s of CPU time is put on the maximum running time of Cplex and the results are reported in Tables 3–5for the small, medium and large instances, respectively.Table 3 represents the results obtained by the proposed exact and metaheuristic methods for the small size instances. In this table, the first column gives the name of the instance, while the next four columns show the number of vertices (|V|), facilities (|T|), customers (|W|) and the minimum amount of prize to be collected (|P|), respectively. Columns six to eight, represent the results obtained by running the flow-based model over each of the instances and the objective function, gap from the optimality and running times are provided in the columns labeled by “Obj.”, “Gap(%)” and “Time”, respectively. The next three columns reports the same results obtained by running the node-based model. Finally, in the remaining columns each successive three columns represent, respectively, the results obtained by MA and VNS algorithms. In this table, the column represented by “Average Obj.” gives the average objective function of the corresponding mataheuristic algorithm over five different runs, followed by its deviation (“Dev(%)”) from the best solutions obtained by exact methods. Finally, the column labeled by “Time” is the average running time of the corresponding mataheuristic algorithm over five different runs. The last two rows of the table provide the number of the best solutions obtained by each method (No. Best) and their average performance over all the available instances (Average), respectively.In almost all of the 32 small size instances, both exact formulations are able to reach the optimal solutions. On average, the running times are 519.01 and 335.90s for the flow-based and node-based formulations, respectively. The MA and VNS algorithms perform very well on these instances in which all the optimal solutions have been obtained. In this table the best solutions found by each method is represented in bold and for all the available instances, MA and VNS are able to reach the optimal solutions in all five different runs. Finally, the average run time of the MA and VNS are 0.15 and 0.08s over 32 available instances, respectively.The results of different algorithms over the medium size instances are reported in Table 4. According to this table, by running the exact models, there are several instances for which the time threshold of Cplex has reached without proving the optimality of the best found solutions. Totally, there are 69 instances in the medium size group where in 9 and 14 instances the optimal solutions have been achieved by applying the node-based and flow-based models, respectively. Computational results over this class of instances show that almost all of the optimal solutions have been obtained by the metaheuristic algorithms as well. Essentially, there are only 1 and 3 instances for which the MA and VNS algorithms are not able to obtain the best solutions achieved by the exact models, respectively. There are also 32 instances for which the MA strictly outperforms the best solutions obtained by the two exact models while this value is 30 for the case of VNS algorithm. The average running time of the MA algorithm over all of the instances is 0.42s while this time is only 0.28s for the VNS algorithm. Moreover, this time is 6262.62 and 6262.20s for the flow-based and node-based models, respectively. The overall average deviation of the best solution obtained by the exact models with respect to results by MA and VNS algorithms clearly indicates the superiority of the metaheuristic methods where the overall deviations are −1.90% and −1.83% for the MA and VNS algorithms, respectively.The results of the MA and VNS algorithms over the 14 large size instances are reported in Table 5. To have a fair comparison of the metaheuristic algorithms we have used CPU time as the termination criterion of the two algorithms. Essentially, both algorithms have been executed with three different time limits, namely 30, 60 and 120s. In this table, the columns labeled by “Best Obj.” and “Average Obj.” give the best and average performance of the different algorithms over five different independent runs of corresponding algorithms. Moreover, the number of the best solutions obtained in each column and the corresponding average of different columns are given in the last two rows, respectively. Taking into account the overall average of the “Best Obj.” column, the results show that on average the MA algorithm always outperform the VNS algorithm in different time limits. This is the same when considering the average performance of the algorithms over five independent runs. Taking into account the number of the best solutions obtained by each algorithm in different time limits, the results show that still MA outperform the VNS by obtaining larger number of the best known solutions.The results of the metaheuristic algorithms over the large size instances, clearly show that the MA outperforms the VNS algorithm. To validate the quality of the proposed MA, we adapt this method to be used for the CSP. The CSP was introduced by Current and Schilling [11] with potential applications in relief transportation. The authors developed a simple heuristic method, where, at first the set covering problem (SCP) is solved over a given CSP instances to find the minimum number of vertices that are able to cover all the available demands. Following this step, the TSP tour is constructed over the resulted vertices from the first step of the algorithm. Since there could be multiple solutions with the same SCP objective function, the authors proposed to find all SCP optimal solutions and take the one having the minimum TSP tour. Golden et al. [18] developed two heuristics (called LS1 and LS2) which applies swap, extraction-reinsertion and perturbation moves to try to find good quality solutions. Finally, an involved algorithm combining exact and heuristic ideas (called SN) was proposed in the literature [37] that outperforms the other available methods. Essentially, the SN method follows a destruct-and-repair paradigm, where, an initial feasible solution is destroyed by extracting some of the vertices visited on the tour and repaired by allocating the available vertices to the solution through solving an integer linear programming model to optimality [37].Our introduced problem can be converted to the CSP. To do so, suppose |W|=|T| and for each i∈W the coordinates of i to be the same as at least one j∈T. Moreover, the covering distance of j is supposed to be the same as customer i in the CSP case. Letting dis(i, j) to represent the distance between i and j∈T and assuming (0, i1, i2, …, ik, 0) to be a feasible tour, the depot could be easily eliminated from the calculation by letting dis(ik, 0)+dis(0, i1)=dis(ik, i1).The same set of parameters have been used to run the CSP instances. To compare the MA's performance over the CSP instances, we have used 16 benchmark instances available in the literature [18]. Moreover, to do the comparison we use the results obtained by LS2 and SN which are the best available methods for the CSP. Table 6provides the results of different algorithms for the CSP, in which the label of the columns have the same meaning as those explained for Table 5. Moreover, in these instances each customer could cover its NC = 7, 9, 11 nearest customers, resulting in 48 instances. Each algorithm has been executed five times and the best, worst and average performance are represented in the appropriate columns. Considering the best performance of the algorithms over 48 available instances, 47 of the best known solutions are obtained by the MA. The average run time of the MA is 1.59 while this is 2.55 and 6.98 for the LS2 and SN methods, respectively. Taking into account the overall average performance of the three methods, the MA has the best performance. Particularly, it outperforms the other two methods by obtaining the most number of the best found solutions and the minimum average cost over all the 48 instances.We proposed a variation of the traveling salesman problem with potential applications in humanitarian relief transportation problem. Given a set of vertices including the depot, facility and customer vertices, the goal of the introduced problem is to construct a minimum length cycle over a subset of facilities while covering a given number of customers. Two mathematical models and two metaheuristic algorithms including memetic algorithm and variable neighborhood search were proposed. Comparing the results obtained by the proposed metahuristic algorithms with those obtained by the exact models, clearly indicates the effectiveness of the developed heuristic methods. Moreover, the memetic algorithm was adapted to be used for the covering salesman problem and the results are comparable with the state of the art algorithms available in the literature.

@&#CONCLUSIONS@&#
