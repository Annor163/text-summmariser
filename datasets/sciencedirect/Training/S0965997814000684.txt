@&#MAIN-TITLE@&#


@&#HIGHLIGHTS@&#
Overview of the current state of the art of high-order fictitious domain methods.Review of the recently introduced Finite Cell Method.Introduces FCMLab as an entrypoint into high-order fictitious domain methods.Information provided allows researchers to quickly prototype new numerical ideas.

@&#KEYPHRASES@&#
Finite Cell Method,Fictitious domain methods,MATLAB,Object-oriented finite elements,High-order finite elements,p-FEM,

@&#ABSTRACT@&#
The recently introduced Finite Cell Method combines the fictitious domain idea with the benefits of high-order finite elements. Although previous publications demonstrated the method’s excellent applicability in various contexts, the implementation of a three-dimensional Finite Cell code is challenging. To lower the entry barrier, this work introduces the object-oriented MATLAB toolbox FCMLab allowing for an easy start into this research field and for rapid prototyping of new algorithmic ideas. The paper reviews the essentials of the methods applied and explains in detail the class structure of the framework. Furthermore, the usage of the toolbox is discussed by means of different two- and three-dimensional examples demonstrating all important features of FCMLab (http://fcmlab.cie.bgu.tum.de/).

@&#INTRODUCTION@&#
For decades, the Finite Element Method (FEM) has been among the most prominent approaches to solve partial differential equations (PDEs) numerically. Many theoretical and algorithmic enhancements of the method now allow to simulate very complex scenarios in science and technology. What remains unchanged, however, is the central idea to describe the PDE’s solution and the domain geometry using the same mesh. This dual-use of elements for the approximation of the geometric shape and solution characteristics implies e.g. that distorted elements have to be avoided, as they would degrade the numerical accuracy. For non-trivial geometries, this constraint complicates the mesh generation process considerably and renders the method’s intrinsic need for a geometry-conforming discretization as one often limiting factor in daily engineering practice.Alternative numerical approaches try to drop this limitation by separating the discretization of the solution from that of the geometry. Prominent examples are meshless and element-free methods [1,2]. Also the Generalized Finite Element, Immersed Boundary, Fictitious Domain, Fat Boundary, Cartesian Grid-FEM and certain variants of extended Finite Element Methods follow this approach [3–16]. For a comprehensive review see [17–19]. A common idea of these methods is to approximate the PDE’s solution using a non-geometry-conforming discretization (approximation mesh) and to capture the actual domain geometry on a separate geometry mesh. Many of these approaches use a rather fine approximation mesh on which linear shape functions are spanned. This h-FEM-like concept has been extended to higher orders by the Finite Cell Method (FCM), combining a fictitious domain approach with the benefits of high-order finite elements (p-FEM). The Finite Cell Method was first introduced in [20,21], where its potential was demonstrated for linear-elastic examples in two and three dimensions. Various extensions of the FCM confirm its versatility in the context of topology optimization [22], geometrically non-linear continuum mechanics [23], adaptive mesh-refinement [24–27], computational steering [28,29], biomedical engineering [30], numerical homogenization [31], elastoplasticity [32], wave propagation in heterogeneous materials [33,34], local enrichment for material interfaces [35], convection diffusion problems [36,37], thin-walled structures [38], design-through-analysis and iso-geometric-analysis [26,27,39,40], weak coupling of non-matching, multi-patch geometries [41], and multi-physical applications [42]. The potential of high-order-fictitious-domain methods is also demonstrated in the context of Kantorovich methods [43,44], immersed B-Spline methods (I-Splines) [45,6,46], and eXtended Finite Element Methods (XFEM) [13–16].Yet, research in this field essentially demands for the availability of a high-order Finite Element code, which is not trivial to implement. To lower this entry barrier, the goal of the present work is to introduce FCMLab, an object-oriented MATLAB toolbox tailored for quick prototyping of new algorithmic ideas. Similar open-source software projects have been launched recently in the communities of hp-FEM, XFEM, meshless methods, and isogeometric analysis (see e.g. [47–54]). The authors hope that this work will be helpful for researches interested in high-order fictitious domain methods. For this purpose, the second section of this paper briefly explains the essential concepts of high-order Finite Elements and of the Finite Cell Method. The most important parts of the code design are outlined in the third section. The fourth section explains how to use the toolbox by different examples in two and three dimensions.As indicated in the introduction, this section outlines the essential ideas of the Finite Cell Method. As a model problem, linear elasticity will be considered and some basics of the p-version of the Finite Element Method, being a prerequisite for the FCM will be sketched, briefly.Consider a two- or three dimensional domainΩwith its boundary∂Ωdivided into Neumann and Dirichlet partsΓNandΓD, respectively, such thatΓN∩ΓD=∅andΓN∪ΓD=∂Ω.Assuming linear-elastic behavior, the deformationucaused by a body forcebˆis described by the following set of partial differential equations:(1a)∇·σ+bˆ=0∀x∈Ω(1b)σ=C:ε∀x∈Ω(1c)ε=12∇u+∇u⊤∀x∈Ω(1d)σ·n=tˆ∀x∈ΓN(1e)u=uˆ∀x∈ΓD.Here,σandεdenote the stress and strain tensor, respectively, andCis the linear-elastic constitutive tensor.tˆanduˆare the traction and displacement vectors prescribed on the respective boundaries.nis the outward-pointing normal vector on the boundary.Following the principal of virtual work described e.g. in [55–58], the above equation is transferred into its corresponding weak form:Findu∈H1(Ω)such that(2a)a(u,v)=f(v)∀v∈H1(Ω)(2b)witha(u,v)=∫Ωε(v):C:ε(u)dΩ(2c)andf(v)=∫Ωv·bˆdΩ+∫ΓNv·tˆdΓ,withH1denoting the Sobolev space of order 1.On the basis of the weak formulation, the Finite Element Method is applied to approximate the analytical solution. To this end, the infinite-dimensional Sobolev space is restricted to an n-dimensional subspaceVh⊂H1being spanned by the basisB=N1,N2,…,Nn. This allows to express the numerical approximationuh∈Vhas a linear combination of basis functions:(3)uh=∑i=1nNiũi,withũidenoting the degrees of freedom related to shape functionsNi. Following a Bubnov-Galerkin approach, the space of test functionsvis reduced to the same spaceVh[55]. Thus, the same basis representation can be employed for the test functionsvh∈Vh. To determine the unknown degrees of freedom, the above representation is inserted into the weak form (2) yielding a system of linear equations(4)Kũ=b,which has to be solved for the unknownsũ. Typically,Kandbare denoted as stiffness matrix and external force vector.The type of basis functions N has a major influence on the characteristics of the numerical method. For the Finite Cell Method, any high-order basis can be utilized. So far p-FEM shape functions [57,59], NURBS, being used in isogeometric analysis [60], and Gauss–Lobatto-Legendre polynomials, used in the Spectral Cell Method [33], have been applied successfully. Currently, FCMLab only provides basis functions from the p-version.Its one dimensional shape functionsNi1D(see Fig. 1) are defined as integrated Legendre polynomials [57]. They yield a hierarchical basis, which is superior to the classical Lagrange basis from a numerical point of view as the condition number of the corresponding stiffness matrix remains constant for an increasing polynomial degree (in case of Laplace problems). Although this property does not carry over to higher dimensions, a comparatively low condition number is maintained.To obtain a two- or three-dimensional basis on a unit-square or -cube, the one-dimensional shape functions are combined in a tensor productNi,j2Dr,s=Ni1DrNj1DsandNi,j,k3Dr,s,t=Ni,j2Dr,sNk1Dt.As depicted in Fig. 2, the elements of the two-dimensional tensor-product space can be sorted into the following three groups:Nodal-mode.The combination of two one-dimensional nodal-modes gives rise to the well known bi-linear modes (see Fig. 3(a)). Just as in 1D, these can be associated directly to one node giving the group its name.Edge-mode.The combination of a one-dimensional internal-mode and a one-dimensional nodal-mode results in a function that is non-zero at only one edge (see Fig. 3(b)). Therefore, the mode can be directly associated to that edge and, thus, identified as a two-dimensional edge-mode.Internal-mode.The combination of two one-dimensional internal-modes yields a function that is zero on all four nodes and edges (see Fig. 3(c)). The mode can, therefore, be directly associated to the face and thus, identified as a bubble- or internal-mode.This mode concept naturally extends into three-dimensions, where also internal- or volume-modes have to be considered.Different alternatives to the tensor-product space, such as a trunk-space or anisotropic polynomial-degree-templates, are discussed in [61,57]. They are currently not implemented in FCMLab but might be added in the future.As discussed in the introduction, mesh-generation is often time consuming and sometimes even a limiting factor when using FEM for industrial applications. This problem becomes even more severe for the p-version of the Finite Element Method: although the solution can be represented by much less and thus coarser elements compared to the h-version, they have to assume possibly complex shapes of the domain’s surface, to deliver accurate results [57]. The Finite Cell Method (FCM) [20,21], combining the benefits of higher-order Finite Elements with the ideas of fictitious domain methods, overcomes these mesh generation problems. The basics of the method are briefly reviewed in the first part of this section, whereas the second part addresses the imposition of boundary conditions for non-boundary-conforming discretizations.The essential idea of the Finite Cell Method is to simplify the mesh-generation process by separating the approximation of the analytical solution from the geometry representation of the physical domain. For this purpose, two independent discretizations are introduced: the solution and the integration mesh. The first mesh is used to approximate the analytical solution and, thus, spans the shape functions. However, it does not resolve the geometry of the domain. This is done by the second mesh, which is completely independent of the first one and does not introduce any additional degrees of freedom.Solution mesh The first step to separate the two meshes is to embed the actual physical domainΩphyin a fictitious domainΩficsuch that their unionΩ∪yields a simple shape (see Fig. 4). To recover the original boundary value problem on the new domainΩ∪, an indicator functionαis defined as1Choosingαas zero outside of the physical domain negatively influences the condition number of the stiffness matrix. To control the conditioning, the value ofαis typically set to a small value that allows to solve the system of equations without numerical problems. Experience shows that the direct solvers implemented in MATLAB can handle values ofα≈10-10without major difficulties.1(5)α(x)=1∀x∈Ωphy0∀x∉Ωphy.The bi-linear forma(·,·)can then be rewritten asau,v=∫Ωphyε(v):C:ε(u)dΩ=∫Ωphy1·ε(v):C:ε(u)dΩ+∫Ωfic0·ε(v):C:ε(u)dΩ≈∫Ω∪α·ε(v):C:ε(u)dΩ.The right hand sidef(·)can be treated analogously. In this way, the meshing of the complex physical domain can be simplified drastically, as the simply-shaped domainΩ∪can be discretized instead using a Cartesian-shaped solution mesh, which renders the mesh-generation process trivial. To avoid a confusion of names, the resulting non-boundary-conforming, high-order elements are denoted as Finite Cells giving the method its name.Integration mesh The second step is to recover the domain geometry using a separate integration mesh. In principle, this second mesh can be generated following various strategies. One possibility is to use conforming integration simplices by triangulating the physical domain. XFEM- and Level Set-based methods commonly apply this strategy [14,15]. Typically, this approach is used with linear simplices. However, the method can also be extended to higher-orders as shown in [13,62–64,16,65,66].An alternative strategy, which is followed within this work, is to use a space-tree as integration mesh (see e.g. [67]). Starting from the non-conforming solution mesh, cut cells are recursively refined towards the domain boundary yielding a quad- or octree structure (see Fig. 5). This approach has the advantage that it requires only a simple inside-outside test. It can therefore also be applied in conjunction with simple geometry modeling techniques such as voxel-models, whereas the triangulation approach demands for a more advanced geometry representation.A challenging task being a consequence of the non-boundary-conforming discretization is the imposition of boundary conditions.Like in the classical FEM, homogeneous, ’natural’ Neumann boundary conditions need no special treatment in the FCM. Inhomogeneous Neumann boundary conditions demand to explicitly include the boundary integral term of the linear form 2c. As the boundary is not resolved by edges of the finite cells, a classical integration over the element edges is not possible. Instead, an explicit surface discretization is introduced on which the traction integral can be evaluated. Just as the previously described integration mesh, this surface integration mesh is independent of the actual solution mesh and does not introduce additional degrees of freedom. A convenient way to generate this mesh – supported by FCMLab – is to provide the surface of interest as an STL2Surface Tesselation Language.2file. The STL format is supported by most CAD systems and represents surfaces as a collection of linear triangles over which the integration can be performed.In contrast to the Neumann case, the incorporation of Dirichlet boundary conditions is more challenging. Classically, they are imposed by explicitly choosing the shape functions from kinematically admissible spaces, such that the prescribed values are met on the boundary by definition [57]. This imposes the boundary conditions in the strong sense and can also be followed in the case of non-boundary conforming discretizations by adapting the admissible function spaces for the particular geometry under consideration. Popular methods following this idea are for example web- and i-spline based methods (see e.g. [68,45]). An alternative approach followed in this work is to extend the weak formulation such that it directly incorporates the Dirichlet boundary conditions. Possible strategies for this purpose are for example the Lagrange Multiplier or Penalty Method [56,69,23,70]. An alternative is to use an approach originally introduced by Nitsche in [71] for the Laplace problem, which was later extended to other applications [72–75]. The idea of this method is to extend the original weak form (2) by additional constraining expressions as follows:ãu,v=au,v-∫ΓDσu·n·vdΓ-∫ΓDσv·n·udΓ+β∫ΓDv·udΓandf̃v=fv-∫ΓDσ(v)·n·uˆdΓ+β∫ΓDv·uˆdΓ.The first additional integral of the bi-linear form follows naturally from the divergence theorem when the test functions are not restricted to be homogeneous on the boundary. It, therefore, insures the method’s consistency. The second additional term ofãand the first additional term off̃are introduced to yield a symmetric stiffness matrix. The two remaining integrals are introduced for numerical stabilization, since coercivity might be lost when subtracting the consistency terms from the bilinear form. With this extension, the discrete problem can be reformulated incorporating the Dirichlet boundary conditions in the weak sense as follows:Finduh∈VΩsuchthatãuh,vh=f̃vh∀vh∈VΩ.In analogy to Neumann boundary conditions, the constraining expressions are evaluated using a separate surface integration mesh.The major advantage of Nitsche-like methods is their inherent consistency, which ensures that the solution of the original strong problem 1e also solves the modified weak problem [73,76,74]. However, the major challenge of this approach is to select the stability parameterβlarge enough to ensure the coercivity of the modified weak form. As shown in [74,72,73], the correct value ofβis dependent on the mesh-size h, the polynomial degree p, and the material parameters. [73–75] suggest to solve an auxiliary eigenvalue-problem to estimateβ. However, their investigations show that choosing a value higher than the threshold has no significant effect on the numerical result. Following the work of [23,40,42], who showed that also an empirical choice of the stability parameter yields good results, the eigenvalue-estimate is omitted in this work.FCMLab is an object-oriented MATLAB toolbox, which is intended to provide an easy entry point into the research field of higher-order fictitious domain methods. This section presents a compact outline of the code design. To this end, the two most frequently applied design patterns are introduced in the first part of the section. In the second part, the most important classes of the toolkit and their mutual dependencies are explained. The description of the code expects the reader to be familiar with general MATLAB programming and knowledge of object oriented concepts in MATLAB, as described e.g. in [78,79].In the context of object-oriented software engineering, certain types of design problems keep on re-appearing, independent of the actual application under consideration. For this reason, design patterns have been developed as reusable template solutions for the most prominent design problems. A classical reference in this context is the textbook by Gamma, Helm, Johnson, and Vlissides [77].The strategy pattern is a behavioral pattern aiming to decouple a family of algorithms from the actually calling code. For this purpose, different algorithms are implemented as separate classes. They all inherit from the same base class which defines the common interface. The client code then implements against this abstract interface and not against the actual implementations. Thus, the calling codes and the algorithms are decoupled, allowing to refactor and maintain the implementation of different algorithms without affecting the client code. Furthermore, the family of algorithms can be extended by simply adding new sub-classes. A numeric-oriented example is depicted in Fig. 6(a).The factory method pattern is a creational pattern aiming to simplify the creation of complex products. For this purpose, the creational process is decoupled from the client code by introducing an abstract creator class. This specifies the interface functions that create the respective object. These factory-methods are then implemented in different sub-classes deciding in which way the final product is constructed. This approach allows the client code to implement against the abstract interface without knowing about the details of the different creator classes. In this way, the implementation of the creational process can be exchanged easily as the calling code remains unaffected. A numeric-oriented example is depicted in Fig. 6(b).The factory idea can be extended to the abstract factory pattern, which allows to create complex product families easily. Within FCMLab, both versions of the pattern are applied and combined.Besides the aspects of extensibility and maintainability, a third important request when developing a software framework is to ensure and maintain code correctness and consistency. For this purpose, FCMLab is developed in a test-driven manner (see e.g. [80,81]). The framework is, thus, equipped with a test suite, which verifies the correctness of the individual modules following the idea of unit tests. Furthermore, the full simulation pipeline is tested using examples with analytical solutions which allow to verify the numerical results. To ensure code correctness during the on-going development process, a continuous integration system is employed, which automatically executes the entire test suite as soon as changes are committed to the version control system. To this end, we utilize the MATLAB xUnit Test Framework [82], the continuous integration server Jenkins (formally known as Hudson) [83], and Apache Subversion (SVN) [84].The aim of FCMLab is to provide a prototyping framework in which new algorithmic ideas can be tested easily. Therefore, the framework has to be structured such that different components can be exchanged easily without affecting other parts of the code. The design must thus aim for high cohesion of the individual modules – in the sense that all libraries, classes, and functions have one clearly defined responsibility–and low coupling between the modules. To address these issues, the program is decomposed hierarchically into the sub-systems depicted in Fig. 7. These are then arranged as layers such that each module only depends on lower layers. This architecture allows to regard each layer as a virtual machine with a clearly defined task, whose implementation can be exchanged without affecting up-stream elements. The details of the different packages are explained in the following sections.The geometry packages provide essential geometric objects such as vertices, lines, quadrilaterals, and hexahedra (see Fig. 8). These are realized as separate classes and grouped according to their dimensionality as abstract curves, areas, and volumes. These abstractions all implement the class AbsGeometry that specifies the interface functions listed in Table 1.As discussed in Section 2.2, the Legendre-based shape functions can be associated to the different topological components. Therefore, the topology package, depicted in Fig. 9, is responsible for handling the degrees of freedom. To this end, a Dof class is defined, which is then aggregated by the AbsTopology class. This interface is implemented by the classes Node, Edge, Face, and Solid that hold objects of their respective geometric counterparts. Furthermore, the classes store the associated polynomial degree of the shape functions.As discussed in Section 2.3, the essential idea of the Finite Cell Method is to decouple the solution mesh from the geometry and to recover the original domain on the integration level. This demands for a separate geometry representation, which is provided by the embedded domain package (see Fig. 10). It contains the abstract AbsEmbeddedDomain class, which specifies the interface function getDomainIndex(…) determining the domain in which a point under consideration lies. This interface is implemented by different concrete domains, such as simple geometric objects that can be specified explicitly (e.g. sphere, rectangle, ellipse). Furthermore, FCMLab provides an implementation that allows to create embedded domains on the basis of CT-scan-data. This VoxelDomain class reads in the CT-data from a simple ASCII file format, which linearizes the three-dimensional matrix. The origin and the bounding box are extracted automatically. Based on this information, the Finite Cell mesh can be created. The list of domain types can be extended easily to suit new needs.In addition to the domain description, the FCM demands for an explicit representation of the boundary for application of boundary conditions. For this purpose, the package provides a AbsBoundaryFactory class, which specifies the getBoundary(…) function returning a surface description as a list of geometric simplices. Presently, several explicit geometries such as circles and rectangles are provided as well as an implementation to read STL files,3For this purpose, the stlread function provided by Doron Harlev is used, which is available on the MATLAB Central File Exchange platform: http://www.mathworks.com/matlabcentral/fileexchange/6678-stlread.3which can be exported from a CAD model. Again, this list can be extended easily for new applications.As discussed in Section 2.3, the domain integration for the FCM is carried out over a separate integration mesh. For this purpose, the integration package defines the non-abstract class Integrator. This class provides the service function integrate(…), taking the integrand and the integration domain as arguments. To generate the integration mesh, the integrator aggregates the abstract classes AbsPartitioner and AbsIntegrationScheme. The AbsPartitioner serves as an interface for different partitioning strategies (see Fig. 11). Currently, FCMLab provides one-, two-, and three-dimensional space trees as concrete partitioning strategies. These could be extended by different schemes, such as triangulations. The class AbsIntegrationScheme provides interfaces to get one-dimensional integration coordinates and weights. At present, the quadrature rule for Gauss–Legendre integration is available, which is used mostly in Finite Element Analysis [55].The material package contains different constitutive relations. To encapsulate these from the other parts of the code, the AbsMaterial class is defined, which specifies the interface functionality listed in Table 2.In addition to providing the constitutive properties, the material package is also responsible for defining the Finite Cell indicator functionαintroduced in Section 2.3. For this purpose, the third method in the table is specified, which returns theα-value of the respective material. The idea is to associate one material for each domain: on the physical domains, the “real” materials are defined withα=1.0; on the fictitious domains, auxiliary “void” materials are defined withα→0.4To avoid numerical difficulties due to badly conditioned matrices, anα-value of10-10is chosen for the numerical examples of Section 4.4This concept allows to handle all domains and materials in the same way during the integration process.As depicted in Fig. 12, FCMLab provides material laws for linear-elastic simulations. Again, this list can be extended by new materials easily as the other parts of the code implement against the interface defined by AbsMaterial.The element package is the kernel of the toolbox. It is responsible for computing the stiffness matrix and the right-hand-side vector of an element. For this purpose, the abstract AbsElement class is defined aggregating its topological components, a material, and a domain and offers the interface functions listed in Table 3. To implement these services, the shape functions and their derivatives need to be evaluated and arranged in matrices. As this process depends on the dimensionality of the problem, the strategy pattern is applied by encapsulating the shape-function evaluation into respective sub-classes (see Fig. 13). In this way, the higher-level parts of the code can use the abstract element without having to know about the details of the setup and the dimensionality. As the creation of an element is rather complex, different factories are provided to generate the most commonly used types.The mesh package provides components to create and operate on one-, two-, and three-dimensional Cartesian meshes. For this purpose, a non-abstract Mesh class is defined aggregating the respective topological components as well as all elements (see Fig. 14). As services, it offers the functions listed in Table 4. Furthermore, the mesh package offers different schemes to number the degrees of freedom. To this end, the AbsNumberingScheme is defined, which assigns the degrees of freedoms to the topological components. The interface is implemented by concrete strategies sorting the unknowns either according to their associated polynomial degree or to their topological component.Following the abstract factory pattern, the mesh creation process is encapsulated into the abstract AbsMeshFactory class that handles the setup of the topology, the elements, and the numbering scheme.The boundary condition package offers the possibility to constrain the numerical system using Neumann and Dirichlet boundary conditions. As described in Section 2.3, the latter can be applied in the strong and in the weak sense. To break the complexity of the package, it is split into sub-systems, which are explained in the following paragraphs.5Within the figures of the different packages, the terms DBC and NBC are used as abbreviations for Dirichlet and Neumann boundary conditions. Within FCMLab, the full class names are spelled out.5Dirichlet boundary conditions. To apply Dirichlet boundary conditions, the abstract AbsDirichletBoundaryCondition class is introduced. It provides the interface function modifyLinearSystem(…), which takes the mesh and the system of linear equations as arguments and applies the boundary conditions. From this super class, the StrongDirichletBoundaryCondition and WeakDirichletBoundaryCondition are derived.Strong Dirichlet boundary conditions directly operate on degrees of freedom. Since the latter are associated to the topological components (see Section 3.3.2), three different classes are derived from AbsStrongDirichletBoundaryCondition. They handle the corresponding tasks for nodes, edges, and faces, respectively (see Fig. 15). In principle, strong Dirichlet boundary conditions can be applied in various ways. To allow for this flexibility, the strategy pattern is applied by introducing the interface class AbsStrongConstrainingAlgorithm. Presently, two implementations of this interface are provided: The first is the StrongPenaltyDirichletAlgorithm, which constrains the respective degrees of freedom by adding a specified penalty value on the main diagonal of the system matrix. The second strategy condenses the influence of the constrained degrees of freedom to the right hand side and thus results in a better conditioning of the stiffness matrix (see e.g. [85]).As described in Section 2.3, weak Dirichlet boundary conditions can be e.g. applied following the penalty or a Nitsche-like method. Both approaches introduce additional boundary integrals constraining the solution appropriately. To evaluate these integrals, the WeakDirichletBoundaryCondition class aggregates a list of geometric objects as boundary description and an integrator object (see Fig. 16). The actual constraining algorithm is encapsulated by introducing the AbsWeakConstrainingAlgorithm interface class, which is then implemented by the WeakNitscheAlgorithm and WeakPenaltyAlgorithm.Neumann boundary conditions. Also in the case of Neumann boundary conditions, two different cases have to be considered.In the general case, the traction integral in 2c has to be evaluated over the Neumann boundary. To this end, the WeakNeumannBoundaryCondition class is introduced, which, in analogy to the weak Dirichlet case, aggregates a boundary description and an integrator object. The actual integrand is specified as a handle to a load function (see Fig. 17).The second case is the application of a load vector, which lumps the applied tractions in the nodal degrees of freedom [58]. For this purpose, the NodalNeumannBoundaryCondition is defined.To compute the mechanical reactions of the system under consideration for different load settings, a LoadCase class is introduced to which different body and surface loads can be associated.

@&#CONCLUSIONS@&#
