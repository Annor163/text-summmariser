@&#MAIN-TITLE@&#
Algorithmic aspects of mean–variance optimization in Markov decision processes

@&#HIGHLIGHTS@&#
The mean and variance of the total reward in Markov decision processes are studied.Randomized or history-based policies can improve performance for these criteria.Computing an optimal policy under a variance constraint is shown to be NP-hard.Pseudopolynomial exact and approximation algorithms are proposed.

@&#KEYPHRASES@&#
Markov processes,Dynamic programming,Control,Complexity theory,

@&#ABSTRACT@&#
We consider finite horizon Markov decision processes under performance measures that involve both the mean and the variance of the cumulative reward. We show that either randomized or history-based policies can improve performance. We prove that the complexity of computing a policy that maximizes the mean reward under a variance constraint is NP-hard for some cases, and strongly NP-hard for others. We finally offer pseudopolynomial exact and approximation algorithms.

@&#INTRODUCTION@&#
The classical theory of Markov decision processes (MDPs) deals with the maximization of the cumulative (possibly discounted) expected reward, to be denoted by W. However, a risk-averse decision maker may be interested in additional distributional properties of W. In this paper, we focus on the case where the decision maker is interested in both the mean and the variance of the cumulative reward (e.g., trying to optimize the mean subject to a variance constraint or vice versa), and we explore the associated computational issues.Risk aversion in MDPs is of course an old subject. In one approach, the focus is on the maximization ofE[U(W)], where U is a concave utility function. Problems of this type can be handled by state augmentation (e.g., Bertsekas, 1995), namely, by introducing an auxiliary state variable that keeps track of the cumulative past reward. In a few special cases, e.g., with an exponential utility function, state augmentation is unnecessary, and optimal policies can be found by solving a modified Bellman equation (Chung & Sobel, 1987). (The exponential utility function is often viewed as a surrogate for trading off mean and variance, on the basis of a single tunable parameter. The difficulty of solving mean–variance optimization problems—which is the focus of this paper—does provide some support for using a surrogate criterion, more amenable to exact optimization.) Another interesting case where optimal policies can be found efficiently involves a “one-switch utility functions” (the sum of a linear and an exponential) Liu and Koenig (2005), or piecewise linear utility functions with a single break point (Liu & Koenig, 2006).In another approach, the objective is to optimize a so-called coherent risk measure (Artzner, Delbaen, Eber, & Heath, 1999), which turns out to be equivalent to a robust optimization problem: one assumes a family of probabilistic models and optimizes the worst-case performance over this family. In the multistage case (Riedel, 2004), problems of this type can be difficult (Le Tallec, 2007), except for some special cases (Iyengar, 2005; Nilim & El Ghaoui, 2005) that can be reduced to Markov games (Shapley, 1953).Mean–variance optimization lacks some of the desirable properties of approaches involving coherent risk measures or risk-sensitive utility functions (e.g., exponential utility functions) and sometimes leads to counterintuitive policies. Bellman’s principle of optimality does not hold, and as a consequence, a decision maker who has received unexpectedly large rewards in the first stages, may actively seek to incur losses in subsequent stages in order to keep the variance small. Counterintuitive and seemingly “irrational” behavior (i.e., incompatible with expected utility maximization) can even arise in static problems under a mean–variance formulation: for example, under a variance constraint, one may prefer to forgo a profit which is guaranteed to be positive but has a positive variance. Nevertheless, mean–variance optimization is a common approach in financial decision making e.g., (Luenberger, 1997), especially for static (one-stage) problems. Consider, for example, a fund manager who is interested in the 1-year performance of the fund whose investment strategies will be judged according to the mean and variance of the return. Assuming that the manager is allowed to undertake periodic re-balancing actions in the course of the year, one obtains a Markov decision process with mean–variance criteria, and it is important to know the least possible variance achievable under a set target for the mean return. While the applicability of the financial strategies arising from mean–variance optimization in multi-period fund management can be debated (due to the “irrational” aspects mentioned above), mean–variance optimization is definitely a meaningful objective in various engineering contexts. Consider, for example, an engineering process whereby a certain material is deposited on a surface. Suppose that the primary objective is to maximize the amount deposited, but that there is also an interest in having all manufactured components be similar to each other; this secondary objective can be addressed by keeping the variance of the amount deposited small. In general, the applicability of the formulations studied in this paper will depend on the specifics of a particular application.Mean–variance optimization problems resembling ours have been studied in the literature. For example, (Guo, Ye, & Yin, 2012) consider a mean–variance optimization problem, but subject to a constraint on the vector of expected rewards starting from each state, which results in a simpler problem, amenable to a policy iteration approach. Collins (1997) provides an apparently exponential-time algorithm for a variant of our problem, and Tamar, Di-Castro, and Mannor (2012) propose a policy gradient approach that aims at a locally optimal solution. Expressions for the variance of the discounted reward for stationary policies were developed in Sobel (1982). However, these expressions are quadratic in the underlying transition probabilities, and do not lead to convex optimization problems. Similarly, much of the earlier literature (see Kawai (1987), Huang & Kallenberg (1994) for a unified approach) on the problem provides various mathematical programming formulations. In general, these formulations either deal with problems that differ qualitatively focusing on the variation of reward from its average (Filar, Kallenberg, & Lee, 1989; White, 1992) from ours or are nonconvex, and therefore do not address the issue of polynomial-time solvability which is our focus. Indeed, we are not aware on any complexity results on mean–variance optimization problems. We finally note some interesting variance bounds obtained by Arlotto, Gans, and Steel (2013).Motivated by considerations such as the above, this paper deals with the computational complexity aspects of mean–variance optimization. The problem is not straightforward for various reasons. One is the absence of a principle of optimality that could lead to simple recursive algorithms. Another reason is that, as is evident from the formulavar(W)=E[W2]-(E[W])2, the variance is not a linear function of the probability measure of the underlying process. Nevertheless,E[W2]andE[W]are linear functions, and as such can be addressed simultaneously using methods from multicriteria or constrained Markov decision processes (Altman, 1999). Indeed, we will use such an approach in order to develop pseudopolynomial exact or approximation algorithms. On the other hand, we will also obtain various NP-hardness results, which show that there is little hope for significant improvement of our algorithms.The rest of the paper is organized as follows. In Section 2, we describe the model and our notation. **We also define various classes of policies and performance objectives of interest. In Section 3, we compare different policy classes and show that performance typically improves strictly as more general policies are allowed. In Section 4, we establish NP-hardness results for the policy classes we have introduced. Then, in Sections 5 and 6, we develop exact and approximate pseudopolynomial time algorithms. Unfortunately, such algorithms do not seem possible for some of the more restricted classes of policies, due to strong NP-completeness results established in Section 4. Finally, Section 7 contains some brief concluding remarks.In this section, we define the model, notation, and performance objectives that we will be studying. Throughout, we focus on finite horizon problems.1Negative complexity results are straightforward to extend to the more general case of infinite horizon problems. Also, some of the positive results, such as the approximation algorithms of Section 6, can be extended to the infinite horizon discounted case; this is beyond the scope of this paper.1We consider a Markov decision process (MDP) with finite state, action, and reward spaces. An MDP is formally defined by a sextupleM=(T,S,A,R,p,g)where:(a)T, a positive integer, is the time horizon;Sis a finite collection of states, one of which is designated as the initial state;Ais a collection of finite sets of possible actions, one set for each state;Ris a finite subset ofQ(the set of rational numbers), and is the set of possible values of the immediate rewards. We letK=maxr∈R|r|.p:{0,…,T-1}×S×S×A→Qdescribes the transition probabilities. In particular, pt(s′∣s,a) is the probability that the state at time t+1 is s′, given that the state at time t is s, and that action a is chosen at time t.g:{0,…,T-1}×R×S×A→Qis a set of reward distributions. In particular, gt(r∣s,a) is the probability that the immediate reward at time t is r, given that the state and action at time t is s and a, respectively.With few exceptions (e.g., for the time horizon T), we use capital letters to denote random variables, and lower case letters to denote ordinary variables. The process starts at the designated initial state. At every stage t=0,1,…, T−1, the decision maker observes the current state Stand chooses an action At. Then, an immediate reward Rtis obtained, distributed according to gt(·∣St,At), and the next state St+1 is chosen, according to pt(·∣St,At). Note that we have assumed that the possible values of the immediate reward and the various probabilities are all rational numbers. This is in order to address the computational complexity of various problems within the standard framework of digital computation. Finally, we will use the notation x0:tto indicate the tuple (x0,…, xt).We will use the symbol π to denote policies. Under a deterministic policy π=(μ0,…, μT−1), the action at each time t is determined according to a mapping μtwhose argument is the history Ht=(S0:t,A0:t−1,R0:t−1) of the process, by letting At=μt(Ht). We let Πhbe the set of all such history-based policies. (The subscripts are used as a mnemonic for the variables on which the action is allowed to depend.) We will also consider randomized policies. Intuitively, at each point in time, the policy can pick an action at random, with the probability of each action determined by the current information (which is Htas well as the outcomes of earlier randomizations). Randomness can always be simulated by using an independent uniform random variable as the seed, which leads to the following formal definition. We assume that there is available a sequence of i.i.d.uniform random variables U0, U1,…, UT−1, which are independent from everything else. In a randomized policy, the action at time t is determined by letting At=μt(Ht,U0:t). Let Πh,ube the set of all randomized policies.In classical MDPs, it is well known that restricting to Markovian policies (policies that take into account only the current state St) results in no loss of performance. In our setting, there are two different possible “states” of interest: the original state St, or the augmented state (St,Wt), whereWt=∑k=0t-1Rk,(with the convention that W0=0). Accordingly, we define the following classes of policies: Πt,s(under which At=μt(St)), and Πt,s,w(under which At=μt(St,Wt)), and their randomized counterparts Πt,s,u(under which At=μt(St,Ut)), and Πt,s,w,u(under which At=μt(St,Wt,Ut). Notice thatΠt,s⊂Πt,s,w⊂Πh,and similarly for their randomized counterparts.Once a policy π and an initial state s is fixed, the cumulative reward WTbecomes a well-defined random variable. The performance measures of interest are its mean and variance, defined byJπ=Eπ[WT]and Vπ=varπ(WT), respectively. Under our assumptions (finite horizon, and bounded rewards), it follows that there are finite upper bounds of KT and K2T2, for ∣Jπ∣ and Vπ, respectively, independent of the policy.Given our interest in complexity results, we will focus on “decision” problems that admit a yes/no answer, except for Section 6. We define the following problem.Problemmv-mdp(Π):Given an MDPMand rational numbers λ, v, does there exist a policy in the set Π such that Jπ⩾λ and Vπ⩽v?Clearly, an algorithm for the problem mv-mdp(Π) can be combined with binary search to solve (up to any desired precision) the problem of maximizing the expected value of WTsubject to an upper bound on its variance, or the problem of minimizing the variance of WTsubject to a lower bound on its mean.Our first step is to compare the performance obtained from different policy classes. We introduce some terminology. Let Π and Π′ be two policy classes. We say that Π is inferior to Π′ if, loosely speaking, the policy class Π′ can always match or exceed the “performance” of policy class Π, and for some instances it can exceed it strictly. Formally, Π is inferior to Π′ if the following hold: (i) if(M,c,d)is a “yes” instance of mv-mdp(Π), then it is also a “yes” instance of mv-mdp (Π′); (ii) there exists some(M,c,d)which is a “no” instance of mv-mdp(Π) but a “yes” instance of mv-mdp(Π′). Similarly, we say that two policy classes Π and Π′ are equivalent if every “yes” (respectively, “no”) instance of mv-mdp(Π) is a “yes” (respectively, “no”) instance of mv-mdp(Π′).We define one more convenient term. A state s is said to be terminal if it is absorbing (i.e., pt(s∣s,a)=1, for every t and a) and provides zero rewards (i.e., gt(0∣s,a)=1, for every t and a).Our first observation is that randomization can strictly improve performance. This is not surprising given that we are dealing simultaneously with two criteria, and that randomization is helpful in constrained MDPs e.g., (Altman, 1999). (Clearly, it is not the case that there will always be improvement—consider a case where rewards are identically zero, so that all policy classes offer the same performance. The content of our result is that certain policies are not “equivalent,” meaning that there exist instances for which the resulting performance is different).Theorem 1(a)Πt,sis inferior to Πt,s,u;Πt,s,wis inferior to Πt,s,w,u;Πhis inferior to Πh,u.It is clear that performance cannot deteriorate when randomization is allowed. It therefore suffices to display an instance in which randomization improves performance.Consider a one-stage MDP (T=1). At time 0, we are at the initial state and there are two available actions, a and b. The mean and variance of the resulting reward are both zero under action a, and both equal to 1 under action b. After the decision is made, the rewards are obtained and the process terminates. Thus WT=R0, the reward obtained at time 0.Consider the problem of maximizingE[R0]subject to the constraint that var(R0)⩽1/2. There is only one feasible deterministic policy (choose action a), and it has zero expected reward. On the other hand, a randomized policy that chooses action b with probability p has an expected reward of p and the corresponding variance satisfiesvar(R0)⩽E[R02]=pE[R02|A0=b]=2p.When 0<p⩽1/4, such a randomized policy is feasible and improves upon the deterministic one.Note that for the above instance we have Πt,s=Πt,s,w=Πh, and Πt,s,u=Πt,s,w,u=Πh,u. Hence the above example establishes all three of the claimed statements.□We now show that in most cases, performance can improve strictly when we allow a policy to have access to more information. The only exception arises for the pair of classes Πt,s,w,uand Πh,u, which we show in Section 5 to be equivalent (cf. Theorem 6).Theorem 2(a)Πt,sis inferior to Πt,s,w, and Πt,s,uis inferior to Πt,s,w,u.Πt,s,wis inferior to Πh.(a)Consider the following MDP, with time horizon T=2. The process starts at the initial state s0, at which there are two actions. Under action a1, the immediate reward is zero and the process moves to a terminal state. Under action a2, the immediate reward R0 is either 0 or 1, with equal probability, and the process moves to state s1. At state s1, there are two actions, a3 and a4: under action a3, the immediate reward R1 is equal to 0, and under action a4, it is equal to 1. We are interested in the optimal value of the expected rewardE[W2]=E[R0+R1], subject to the constraint that the variance is less than or equal to zero (and therefore equal to zero). Let p be the probability that action a2 is chosen at state s0. If p>0, and under any policy in Πt,s,u, the reward R0 at state s0 has positive variance, and the reward R1 at the next stage is uncorrelated with R0. Hence, the variance of R0+R1 is positive, and such a policy is not feasible; in particular, the constraint on the variance requires that p=0. We conclude that the largest possible expected reward under any policy in Πt,s,u(and, a fortiori, under any policy in Πt,s) is equal to zero. Consider now the following policy, which belongs to Πt,s,wand, a fortiori, to Πt,s,w,u: at state s0, choose action a2; then, at state s1, choose a3 if W1=R0=1, and choose a4 if W1=R0=0. In either case, the total reward is R0+R1=1, while the variance of R0+R1 is zero, thus ensuring feasibility. This establishes the first part of the theorem.Consider the following MDP, with time horizon T=3. At state s0 there is only one available action; the next state S1 is either s1 or s1′, with probability p and 1−p, respectively, and the immediate reward R0 is zero. At either state s1 ors1′, there is again only one available action; the next state, S2, is s2, and the reward R1 is zero. At state s2, there are two actions, a and b. Under action a, the mean and variance of the resulting reward R2 are both zero, and under action b, they are both equal to 1. Let us examine the largest possible value ofE[W3]=E[R2], subject to the constraint var(W2)⩽1/2. The class Πt,s,wcontains two policies, corresponding to the two deterministic choices of an action at state s2; only one of them is feasible (the one that chooses action a), resulting in zero expected reward. However, the following policy in Πhhas positive expected reward: choose action b at state s2 if and only if the state at time 1 was equal to s1 (which happens with probability p). As long as p is sufficiently small, the constraint var(W)⩽1/2 is met, and this policy is feasible. It follows that Πt,s,wis inferior to Πh.□In this section, we establish that mean–variance optimization in finite horizon MDPs is unlikely to admit polynomial time algorithms, in contrast to classical MDPs.Theorem 3The problemmv-mdp(Π) is NP-hard, when Π is Πt,s,w, Πt,s,w,u, Πh, or Πh,u.We will actually show NP-hardness for the special case of mv-mdp(Π), in which we wish to determine whether there exists a policy whose reward variance is equal to zero. (In terms of the problem definition, this corresponds to letting λ=−KT and v=0.) The proof uses a reduction from the Partition problem: Given n positive integers, does there exist a subset B of {1,…, n} such that∑i∈Bri=∑i∉Bri?Given an instance (r1,…, rn) of Partition, and for any of the policy classes of interest, we construct an instance of mv-mdp(Π), with time horizon T=n+1, as follows. At the initial state s0, there is only one available action, resulting in zero immediate reward (R0=0). With probability 1/2, the process moves to a terminal state; with probability 1/2, the process moves (deterministically) along a sequence of states s1,…, sn. At each state si(i=1,…, n), there are two actions: ai, which results in an immediate reward of ri, and bi, which results in an immediate reward of −ri.Suppose that there exists a set B⊂{1,…, n} such that∑i∈Bri=∑i∉Bri. Consider the policy that chooses action aiat state siif and only if i∈B. This policy achieves zero total reward, with probability 1, and therefore meets the zero variance constraint. Conversely, if a policy results in zero variance, then the total reward must be equal to zero, with probability 1, which implies that such a set B exists. This completes the reduction.Note that this argument applies no matter which particular class of policies is being considered.□The above proof also applies to the policy classes Πt,sand Πt,s,u. However, for these two classes, a stronger result is possible. Recall that a problem is strongly NP-hard, if it remains NP-hard when restricted to instances in which the numerical part of the instance description involves “small” numbers; see Garey & Johnson (1979) for a precise definition.Theorem 4If Π is either Πt,sor Πt,s,u, the problemmv-mdp(Π) is strongly NP-hard.As in the proof of Theorem 3, we will prove the result for the special case of mv-mdp, in which we wish to determine whether there exists a policy under which the variance of the reward is equal to zero. The proof involves a reduction from the 3-Satisfiability problem (3sat). An instance of 3sat consists of n Boolean variables x1,…, xn, and m clauses C1,…, Cm, with three literals per clause. Each clause is the disjunction of three literals, where a literal is either a variable or its negation. (For example,x2∨x¯4∨x5is such a clause, where a bar stands for negation.) The question is whether there exists an assignment of truth values (“true” or “false”) to the variables such that all clauses are satisfied.Suppose that we are given an instance of 3sat, with n variables and m clauses, C1,…, Cm. We construct an instance of mv-mdp(Π) as follows. There is an initial state s0, a state d0, a state cjassociated with each clause Cj, and a state yiassociated with each literal xi. The actions, dynamics, and rewards are as follows:(a)Out of state s0, there is equal probability, 1/(m+1), of reaching any one of the states d0,c1,…, cm, independent of the action; the immediate reward is zero.State d0 is a terminal state. At each state cj, there are three actions available: each action selects one of the three literals in the clause, and the process moves to the state yiassociated with that literal; the immediate reward is 1 if the literal appears in the clause unnegated, and −1 if the literal appears in the clause negated. For an example, suppose that the clause is of the formx2∨x¯4∨x5. Under the first action, the next state is y2, and the reward is 1; under the second action, the next state is y4 and the reward is −1; under the third action, the next state is y5, and the reward is 1.At each state yi, there are two possible actions aiand bi, resulting in immediate rewards of 1 and −1, respectively. The process then moves to the terminal state d0.For the converse direction, suppose that there exists a policy in Πt,s, or more generally, in Πt,s,uunder which the variance of the total reward is zero. Since the total reward is equal to 0 whenever the first transition leads to state d0 (which happens with probability 1/(m+1), it follows that the total reward must be always zero. Consider now the following truth assignment: xiis set to be true if and only if the policy chooses action biat state yi, with positive probability. Suppose that the state visited after the first transition is cj. Suppose that the action chosen at state cjleads next to state yiand that the literal xiappears unnegated in clause Cj. Then, the reward at state cjis 1, which implies that the reward at state yiis −1. It follows that the action chosen at yiis bi, and therefore xihas been set to be true. It follows that clause Cjis satisfied. A similar argument shows that clause Cjis satisfied when the literal xiassociated with the chosen action at cjappears negated. In either case, we conclude that clause Cjis satisfied. Since every state cjis possible at time 1, it follows that every clause is satisfied, and we have a “yes” instance of 3sat.□Because the immediate rewards are bounded, it is easily seen that an instance with general rewards is equivalent to one with all positive (or all negative) rewards. It follows that our negative complexity results remain valid even if we restrict to instances in which all rewards are positive (respectively, negative).The comparison and complexity results of the preceding two sections indicate that the policy classes Πt,s, Πt,s,w, Πt,s,u, and Πhare inferior to the class Πh,u, and furthermore some of them (Πt,s, Πt,s,w) appear to have higher complexity. Thus, there is no reason to consider them further. While the problem mv-mdp(Πh,u) is NP-hard, there is still a possibility for approximate or pseudopolynomial time algorithms. In this section, we focus on exact pseudopolynomial time algorithms.Our approach involves an augmented state, defined by Xt=(St,Wt). LetXbe the set of all possible values of the augmented state. Let|S|be the cardinality of the setS. Let|R|be the cardinality of the setR. Recall also thatK=maxr∈R|r|. If we assume that the immediate rewards are integers, then Wtis an integer between −KT and KT. In this case, the cardinality|X|of the augmented state spaceXis bounded by|S|·(2KT+1), which is polynomial. Without the integrality assumption, the cardinality of the setXremains finite, but it can increase exponentially with T. For this reason, we study the integer case separately in Section 5.2.In this section, we provide some results on the representation of MDPs in terms of a state-action frequency polytope, thus setting the stage for our subsequent algorithms.For any policy π∈Πh,u, and anyx∈X,a∈A, we define the state-action frequencies at time t byztπ(x,a)=Pπ(Xt=x,At=a),t=0,1,…,T-1,andztπ(x)=Pπ(Xt=x),t=0,1,…,T.Let zπbe a vector that lists all of the above defined state-action frequencies.For any family Π of policies, let Z(Π)={zπ∣ π∈Π}. The following result is well known e.g., (Altman, 1999). It asserts that any feasible state-action frequency vector can be attained by policies that depend only on time, the (augmented) state, and a randomization variable. Furthermore, the set of feasible state-action frequency vectors is a polyhedron, hence amenable to linear programming methods.Theorem 5(a)We have Z(Πh,u)=Z(Πt,s,w,u).The set Z(Πh,u) is a polyhedron, specified byO(T·|X|·|A|)linear constraints.Note that a certain mean–variance pair (λ,v) is attainable by a policy in Πh,uif and only if there exists some z∈Z(Πh,u) that satisfies(1)∑(s,w)∈XwzT(s,w)=λ,(2)∑(s,w)∈Xw2zT(s,w)=v+λ2.Furthermore, since Z(Πh,u)=Z(Πt,s,w,u), it follows that if a pair (λ,v) is attainable by a policy in Πh,u, it is also attainable by a policy in Πt,s,w,u. This establishes the following result.Theorem 6The policy classes Πh,uand Πt,s,w,uare equivalent.Note that checking the feasibility of the conditions z∈Z(Πh,u), (1), and (2) amounts to solving a linear programming problem, with a number of constraints proportional to the cardinality of the augmented state spaceXand, therefore, in general, exponential in T.In this section, we assume that the immediate rewards are integers, with absolute value bounded by K, and we show that pseudopolynomial time algorithms are possible. Recall that an algorithm is a pseudopolynomial time algorithm if its running time is polynomial in K and the instance size. (This is in contrast to polynomial time algorithms in which the running time can only grow as a polynomial of logK.)Theorem 7Suppose that the immediate rewards are integers, with absolute value bounded by K. Consider the following two problems:(i)determine whether there exists a policy in Πh,ufor which (Jπ,Vπ)=(λ,v), where λ and v are given rational numbers; and,determine whether there exists a policy in Πh,ufor which Jπ=λ and Vπ⩽v, where λ and v are given rational numbers.these two problems admit a pseudopolynomial time algorithm; and,unless P=NP, these problems cannot be solved in polynomial time.(a)As already discussed, these problems amount to solving a linear program. In the integer case, the number of variables and constraints is bounded by a polynomial in K and the instance size. The result follows because linear programming can be solved in polynomial time.This is proved by considering the special case where λ=v=0 and the exact same argument as in the proof of Theorem 3.□Similar to constrained MDPs, mean–variance optimization involves two different performance criteria. Unfortunately, however, the linear programming approach to constrained MDPs does not translate into an algorithm for the problem mv-mdp(Πh,u). The reason is that the setPMV={(Jπ,Vπ)|π∈Πh,u}of achievable mean–variance pairs need not be convex. To bring the constrained MDP methodology to bear on our problem, instead of focusing on the pair (Jπ,Vπ), we defineQπ=Eπ[WT2], and focus on the pair (Jπ,Qπ). This is now a pair of objectives that depend linearly on the state frequencies associated with the final augmented state XT. Accordingly, we definePMQ={(Jπ,Qπ)|π∈Πh,u}.Note that PMQis a polyhedron, because it is the image of the polyhedron Z(Πh,u) under the linear mapping specified by the left-hand sides of Eqs. (1) and (2). In contrast, PMVis the image of PMQunder a nonlinear mapping:PMV={(λ,q-λ2)|(λ,q)∈PMQ},and is not, in general, a polyhedron.As a corollary of the above discussion, and for the case of integer rewards, we can exploit convexity to devise pseudopolynomial algorithms for problems that can be formulated in terms of the convex set PMQ. On the other hand, because of the non-convexity of PMV, we have not been able to devise pseudopolynomial time algorithms for the problem mv-mdp(Πh,u), or even the simpler problem of deciding whether there exists a policy π∈Πh,uthat satisfies Vπ⩽v, for some given number v, except for the very special case where v=0, which is the subject of our next result. For a general v, an approximation algorithm will be presented in the next section.Theorem 8(a)If there exists some π∈Πh,ufor which Vπ=0, then there exists some π′∈Πt,s,wfor whichVπ′=0.Suppose that the immediate rewards are integers, with absolute value bounded by K. Then the problem of determining whether there exists a policy π∈Πh,ufor which Vπ=0 admits a pseudopolynomial time algorithm.(a)Suppose that there exists some π∈Πh,ufor which Vπ=0. ByTheorem 6, π can be assumed, without loss of generality, to lie in Πt,s,w,u. Let varπ(WT∣U0:T), be the conditional variance of WT, conditioned on the realization of the randomization variables U0:T. We havevarπ(WT)⩾Eπ[varπ(WT|U0:T)], which implies that there exists some u0:Tsuch that varπ(WT∣U0:T=u0:T)=0. By fixing the randomization variables to this particular u0:T, we obtain a deterministic policy, in Πt,s,wunder which the reward variance is zero.If there exists a policy under which Vπ=0, then there exists an integer k, with ∣k∣⩽KT such that, under this policy, WTis guaranteed to be equal to k. Thus, we only need to check, for each k in the relevant range, whether there exists a policy such that (Jπ,Vπ)=(k,0). ByTheorem 7, this can be done in pseudopolynomial time.□The approach in the proof of part (b) above leads to a short argument, but yields a rather inefficient (albeit pseudopolynomial) algorithm. A much more efficient and simple algorithm is obtained by realizing that the question of whether WTcan be forced to be k, with probability 1, is just a reachability game: the decision maker picks the actions and an adversary picks the ensuing transitions and rewards (among those that have positive probability of occurring). The decision maker wins the game if it can guarantee that WT=k. Such sequential games are easy to solve in time polynomial in the number of (augmented) states, decisions, and the time horizon, by a straightforward backward recursion. On the other hand a genuinely polynomial time algorithm does not appear to be possible; indeed, the proof of Theorem 3 shows that the problem is NP-complete.In this section, we deal with the optimization counterparts of the problem mv-mdp(Πh,u). We are interested in computing approximately the following two functions:(3)v∗(λ)=inf{π∈Πh,u:Jπ⩾λ}Vπ,and(4)λ∗(v)=sup{π∈Πh,u:Vπ⩽v}Jπ.If the constraint Jπ⩾λ (respectively, Vπ⩽v) is infeasible, we use the standard convention v∗(λ)=∞ (respectively, λ∗(v)=−∞). Note that the infimum and supremum in the above definitions are both attained, because the set PMVof achievable mean–variance pairs is the image of the polyhedron PMQunder a continuous map, and is therefore compact.We do not know how to efficiently compute or even generate a uniform approximation of either v∗(λ) or λ∗(v) (i.e., find a value v′ between v∗(λ)−∊ and v∗(λ)+∊, and similarly for λ∗(v)). In the following two results we consider a weaker notion of approximation that is computable in pseudopolynomial time. We discuss v∗(λ) as the issues for λ∗(v) are similar.For any positive ∊ and ν, we will say thatvˆ(·)is an (∊,ν)-approximation of v∗(·) if, for every λ,(5)v∗(λ-ν)-∊⩽vˆ(λ)⩽v∗(λ+ν)+∊.This is an approximation of the same kind as those considered in Papadimitriou & Yannakakis (2000): it returns a valuevˆsuch that(λ,vˆ)is an element of the “(∊+ν)-approximate Pareto boundary” of the set PMV. For a different view, the graph of the functionvˆ(·)is within Hausdorf distance ∊+ν from the graph of the function v∗(·).We will show how to compute an (∊,ν)-approximation in time which is pseudopolynomial, and polynomial in the parameters 1/∊, and 1/ν.We start in Section 6.1 with the case of integer rewards, and build on the pseudopolynomial time algorithms of the preceding section. We then consider the case of general rewards in Section 6.2. We finally sketch an alternative algorithm in Section 6.3 based on set-valued dynamic programming.In this section, we prove the following result.Theorem 9Suppose that the immediate rewards are integers. There exists an algorithm that, given ∊, ν, and λ, outputs a valuevˆ(λ)that satisfies(5), and which runs in time polynomial in|S|,|A|,T,K,1/∊, and 1/ν.Without loss of generality, and only for the purposes of this proof, we can and will assume that the immediate rewards are nonnegative. Indeed, if the immediate rewards range in [−K,K] we can redefine them, by adding K to the reward at each stage. Then,vˆ(λ)for the original problem will be equal tovˆ(λ+K)for the new problem. Since the rewards are bounded by K, we have v∗(λ)=∞ for λ>KT and v∗(λ)=v∗(0) for λ<0. For this reason, we only need to consider λ∈[0,KT]. To simplify the presentation, we assume that ∊=ν. We let δ be such that ∊=3δ KT.The algorithm is as follows. We consider grid points λidefined by λi=(i−1)δ, i=1,…, n, where n is chosen so that λn−1⩽KT, λn>KT. Note that n=O(KT/δ). For i=1,…, n−1, we calculateqˆ(λi), the smallest possible value ofE[WT2], whenE[WT]is restricted to lie in [λi,λi+1]. Formally,qˆ(λi)=minq|∃λ′∈[λi,λi+1]s.t.(λ′,q)∈PMQ.We letuˆ(λi)=qˆ(λi)-λi+12, which can be interpreted as an estimate of the least possible variance whenE[WT]is restricted to the interval [λi,λi+1]. Finally, we setvˆ(λ)=mini⩾kuˆ(λi),ifλ∈[λk,λk+1].The main computational effort is in computingqˆ(λi)for every i. Since PMQis a polyhedron, this amounts to solving O(KT/δ) linear programming problems. Thus, the running time of the algorithm has the claimed properties.We now prove correctness. Let q∗(λ)=min{q∣ (λ,q)∈PMQ}, and u∗(λ)=q∗(λ)−λ2, which is the least possible variance for a given value of λ. Note that v∗(λ)=min{u∗(λ′)∣ λ′⩾λ}.We haveqˆ(λi)⩽q∗(λ′), for all λ′∈[λi,λi+1]. Also,-λi+12⩽-(λ′)2, for all λ′∈[λi,λi+1]. By adding these two inequalities, we obtainuˆ(λi)⩽u∗(λ′), for all λ′∈[λi,λi+1]. Given some λ, let k be such that λ∈[λk,λk+1]. Then,vˆ(λ)=mini⩾kuˆ(λi)⩽minλ′⩾λku∗(λ′)⩽minλ′⩾λu∗(λ′)=v∗(λ′),so thatvˆ(λ)is always an underestimate of v∗(λ).We now prove a reverse inequality. Fix some λ and let k be such that λ∈[λk,λk+1]. Let i⩾k be such thatvˆ(λ)=uˆ(λi). Let alsoλ¯∈[λi,λi+1]be such thatq∗(λ¯)=qˆ(λi). Note that(6)λi+12-λ¯2⩽λi+12-λi2=δ(λi+λi+1)⩽2δ(KT+δ)⩽3δKT.Then,vˆ(λ)=(a)uˆ(λi)=(a)qˆ(λi)-λi+12=(c)q∗(λ¯)-λi+12⩾(d)q∗(λ¯)-λ¯2-3δKT=(e)u∗(λ¯)-3δKT⩾(f)v∗(λ¯)-3δKT⩾(g)v∗(λ-δ)-3δKT⩾(h)v∗(λ-∊)-∊.In the above, (a) holds by the definition of i; (b) by the definition ofuˆ(λi); (c) by the definition ofλ¯; and (d) follows from Eq. (6). Equality (e) follows from the definition of u∗(·). Inequality (f) follows from the definition of v∗(·); and (g) is obtained because v∗(·) is nondecreasing and becauseλ¯⩾λ-δ. (The latter fact is seen as follows: (i) if i>k, thenλ⩽λk+1⩽λi⩽λ¯; (ii) if i=k, then both λ andλ¯belong to [λk,λk+1], and their difference is at most δ.) Inequality (h) is obtained because of the definition ∊=3δKT, the observation δ<∊, and the monotonicity of v∗(·).□Theorem 9 allows us to construct an approximate Pareto boundary. In addition, one may be interested in obtaining corresponding policies. As is common in Markov decision theory, the construction of suitable policies is implicit in value function calculations, and is immediate from the proof Theorem 9, as we now describe. Suppose that are given some λ that happens to lie in some [λk,λk+1]. As in the proof of the theorem, we find some i such thatvˆ(λ)=uˆ(λi)=qˆ(λi)-λi+12. From the definition ofqˆ(λi), there exists some(λ¯,q)∈PMQwithλ¯∈[λi,λi+1]andq=q∗(λ¯)=qˆ(λi). The key observation is that we can easily find a policy for whichE[WT]andE[WT2]are equal toλ¯and q, respectively. This is done by finding a corresponding state-action frequency vector in the polyhedron Z(Πh,u) (which is a linear programming feasibility problem), and expressing that vector as a convex combination of extreme points of Z(Πh,u). As is well known, extreme points of Z(Πh,u) are associated with deterministic policies. The desired policy is a randomized policy obtained by combining these deterministic policies according to the coefficients involved in the convex combination. The policy constructed in this manner has a variance equal toq-(λ¯)2=qˆ(λi)-(λ¯)2⩽qˆ(λi)-λi+12+3δKT=vˆ(λ)+3δKT⩽vˆ(λ)+∊,where the first inequality is obtained as in Eq. (6). We have thus found a policy whose performance is within ∊ of the computed approximately optimal performancevˆ(λ).Similar policy constructions are possible in the other cases considered in this paper (as, for example, in the next section). Given that these constructions do not involve any new ideas, we will not repeat them.When rewards are arbitrary, we can discretize the rewards and obtain a new MDP. The new MDP is equivalent to one with integer rewards to which the algorithm of the preceding subsection can be applied. This is a legitimate approximation algorithm for the original problem because, as we will show shortly, the function v∗(·) changes very little when we discretize using a fine enough discretization.We are given an original MDPM=(T,S,A,R,p,g)in which the rewards are rational numbers in the interval [−K,K], and an approximation parameter ∊. We fix a positive number δ, a discretization parameter whose value will be specified later. We then construct a new MDPM′=(T,S,A,R′,p,g′), in which the rewards are rounded down to an integer multiple of δ. More precisely, all elements of the reward rangeR′are integer multiples of δ, and for everyt,s,a∈{0,1,…,T-1}×S×A, and any integer n, we havegt′(δn|s,a)=∑r:δn⩽r<δ(n+1)gt(r|s,a).We denote by J, Q and by J′, Q′ the first and second moments of the total reward in the original and new MDPs, respectively. Let Πh,uandΠh,u′be the sets of (randomized, history-based) policies inMandM′, respectively. Let PMQandPMQ′be the associated polyhedra.We want to to argue that the mean–variance tradeoff curves for the two MDPs are close to each other. This is not entirely straightforward because the augmented state spaces (which include the possible values of the cumulative rewards Wt) are different for the two problems and, therefore, the sets of policies are also different. A conceptually simple but somewhat tedious approach involves an argument along the lines of Whitt (1978), Whitt (1979), generalized to the case of constrained MDPs; we outline such an argument in Section 6.3. Here, we follow an alternative approach, based on a coupling argument.Proposition 1There exists a polynomial function c(K,T) such that the Hausdorf distance between PMQandPMQ′is bounded above by 2KT2δ. More precisely,(a)For every policy π∈Πh,u, there exists a policyπ′∈Πh,u′such thatmax|Jπ′′-Jπ|,|Qπ′′-Qπ|⩽2KT2δ.Conversely, for every policyΠh,u′, there exists a policy Πh,usuch that the above inequality again holds.We denote by d(r) the discretized value of a reward r, that is,d(r)=max{nδ:nδ⩽r,n∈Z}. Let us consider a third MDPM″which is identical toM′, except that its rewardsRt″are generated as follows. (We follow the convention of using a single or double prime to indicate variables associated withM′orM″, respectively.) A random variable Rtis generated according to the distribution prescribed by gt(r∣st,at), and its value is observed by the decision maker, who then incurs the rewardRt″=d(Rt). LetPMQ″be the polyhedron associated withM″. We claim thatPMQ″=PMQ′. The only difference betweenM′andM″is that the decision maker inM″has access to the additional information Rt−d(Rt). However, this information is incosequential: it does not affect the future transition probabilities or reward distributions. Thus, Rt−d(Rt) can only be useful as an additional randomization variable. SincePMQ′is the set of achievable pairs using general (history-based randomized) policies, having available an additional randomization variable does not change the polyhedron, andPMQ″=PMQ′. Thus, to complete the proof it suffices to show that the polyhedra PMQandPMQ″are close.Let us compare the MDPsMandM″. The information available to the decision maker is the same for these two MDPs (since all the history of reward truncations{Rτ-d(Rτ)}τ=1t-1is available inM″for the decision at time t). Therefore, for every policy in one MDP, there exists a policy for the other under which (if we define the two MDPs on a common probability space, involving common random generators) the exact same sequence of states(St=St″), actions(At=At″), and random variables Rtis realized. The only difference is that the rewards are Rtand d(Rt), inMandM″, respectively. Recall that 0⩽Rt−d(Rt)⩽δ. We obtain that for every policy π∈Π, there exists a policy π″∈Π″ for which0⩽WT-WT″=∑τ=0T-1(Rt-d(Rt))⩽δT, and therefore,WT2-WT″2⩽2KT2δ. Taking expectations, we obtain ∣Jπ−J′′π∣⩽Tδ,Qπ-Qπ″⩽2KT2δ. This completes the proof of part (a). The proof of part (b) is identical.□There exists an algorithm that, given ∊, ν, and λ, outputs a valuevˆ(λ)that satisfies(5), and which runs in time polynomial in|S|,|A|,T,K,1/∊, and 1/ν.Assume for simplicity that ν=∊. Given the value of ∊, let δ be such that ∊/2=2KT2δ, and construct the discretized MDPM′. Run the algorithm from Theorem 9 to find an (∊/2,∊/2)-approximationvˆforM′. Using Proposition 1, it is not hard to verify that this yields an (∊,∊)-approximation of v∗(λ).□There are two general approaches for constructing approximation algorithms. (i) One can discretize the problem, to obtain an easier one, and then apply an algorithm specially tailored to the discretized problem; this was the approach in the preceding subsection. (ii) One can design an exact (but inefficient) algorithm for the original problem and then implement the algorithm approximately. This approach will work provided the approximations do not build up excessively in the course of the algorithm. In this subsection, we elaborate on the latter approach.We defined earlier the polyhedron PMQas the set of achievable first and second moments of the cumulative reward starting at time zero at the initial state. We extend this definition by considering intermediate times and arbitrary (intermediate) augmented states. We let(7)Ct(s,w)={(λ,q):∃π∈Πh,us.t.Eπ[WT|St=s,Wt=w]=λandEπ[WT2|St=s,Wt=w)=q}.Clearly, C0(s,0)=PMQ. Using a straightforward backwards induction, it can be shown that Ct(·,·) satisfies the set-valued dynamic programming recursion2If X and Y are subsets of a vector space and α a scalar, we let α X={αx∣x∈X} and X+Y={x+y∣x∈X, y∈Y}. Furthermore, if for everya∈A, we have a set Xa, thenconva∈A{Xa}is the convex hull of the union of these sets.2(8)Ct(s,w)=conva∈A∑s′∈Spt(s′|s,a)∑r∈Rgt(r|s,a)Ct+1(s′,w+r),for everys∈S,w∈R, and for t=0,1, 2, …, T−1, initialized with the boundary conditions(9)CT(s,w)={(w,w2)}.A simple inductive proof shows that the sets Ct(s,w) are polyhedra; this is because CT(s,w) is either empty or a singleton and because the sum or convex hull of finitely many polyhedra is a polyhedron. Thus, the recursion involves a finite amount of computation, e.g., by representing each polyhedron in terms of its finitely many extreme points. In the worst case, this translates into an exponential time algorithm, because of the possibly large number of extreme points. However, such an algorithm can also be implemented approximately. If we allow for the introduction of an O(∊/T) error at each stage (where error is measured in terms of the Hausdorf distance), we can work with approximating polyhedra that involve only O(1/∊) extreme points, while ending up with a O(∊) total error; this is because we are approximating polyhedra in the plane, as opposed to higher dimensions where the dependence on ∊ would have been worse dependence. The details are straightforward but somewhat tedious and are omitted. On the other hand, in practice, this approach is likely to be faster than the algorithm of the preceding subsection.

@&#CONCLUSIONS@&#
We have shown that mean–variance optimization problems for MDPs are typically NP-hard, but sometimes admit pseudopolynomial approximation algorithms. We only considered finite horizon problems, but it is clear that the negative results carry over to their infinite horizon counterparts. Furthermore, given that the contribution of the tail of the time horizon in infinite horizon discounted problems (or in “proper” stochastic shortest path problems as in Bertsekas (1995)) can be made arbitrarily small, our approximation algorithms can also yield approximation algorithms for infinite horizon problems.Two more problems of some interest deal with finding a policy that has the smallest possible, or the largest possible variance. There is not much we can say here, except for the following:(a)The smallest possible variance is attained by a deterministic policy, that is,minπ∈Πh,uVπ=minπ∈ΠhVπ.This is proved using the inequalityvarπ(WT)⩾Eπ[varπ(WT|U0:T)].Variance will be maximized, in general, by a randomized policy. To see this, consider a single stage problem and two actions with deterministic rewards, equal to 0 and 1, respectively. Variance is maximized by assigning probability 1/2 to each of the actions. The variance maximization problem is equivalent to maximizing the concave function q−λ2 subject to (λ,q)∈PMQ. This is a quadratic programming problem over the polyhedron PMQand therefore admits a pseudopolynomial time algorithm, when the rewards are integer.Our results suggest several interesting directions for future research, which we briefly outline below.First, our negative results apply to general MDPs. It would be interesting to determine whether the hardness results remain valid for specially structured MDPs. One possibly interesting special case involves multi-armed bandit problems: there are n separate MDPs (“arms”); at each time step, the decision maker has to decide which MDP to activate, while the other MDPs remain inactive. Of particular interest here are index policies that compute a value (“index”) for each MDP and select an MDP with maximal index; such policies are often optimal for the classical formulations (see Gittins (1979) and Whittle (1988)). Obtaining a policy that uses some sort of an index for the mean–variance problem or alternatively proving that such a policy cannot exist would be interesting.Second, a number of complexity questions have been left open. We list a few of them:(a)Is there a pseudopolynomial time algorithm for computing v∗(λ) or λ∗(v) exactly?Is there a polynomial or pseudopolynomial time algorithm that computes v∗(λ) or λ∗(v) within a uniform error bound ∊?Is the problem of computingvˆ(λ)with the properties in Eq. (5) NP-hard?Is there a pseudopolynomial time algorithm the smallest possible variance in the absence of any constraints on the mean cumulative reward?Third, bias-variance tradeoffs may pay an important role in speeding up certain control and learning heuristics, such as those involving control variates (Meyn, 2008). Perhaps mean–variance optimization can be used to address the exploration/exploitation tradeoff in model-based reinforcement learning, with variance reduction serving as a means to reduce the exploration time (see Sutton & Barto (1998) for a general discussion of exploration–exploitation in reinforcement learning). Of course, in light of the computational complexity of bias-variance tradeoffs, incorporating bias-variance tradeoffs in learning makes sense only if experimentation is nearly prohibitive and computation time is cheap. Such an approach could be particularly useful if a coarse, low-complexity, approximate solution of a bias-variance tradeoff problem can result in significant exploration speedup.Fourth, we only considered mean–variance tradeoffs in this paper. However, there are other interesting and potentially useful criteria that can be used to incorporate risk into multi-stage decision making. For example, Liu and Koenig (2005) consider a utility function with a single switch. Many other risk aware criteria have been considered in the single stage case. It would be interesting to develop a comprehensive theory for the complexity of solving multi-stage decision problems under general (monotone convex or concave) utility function and under risk constraints. This is especially interesting for the approximation algorithms presented in Section 6.Finally, it is reasonable to expect that our positive results (on approximation algorithms) can be extended to problems involving continuous states and actions and/or unbounded rewards, by first discretizing the problem, truncating the rewards, and then applying our algorithms to a discrete problem. Of course, one would have to deal with the generic issues that arise in discretizing MDPs Whitt (1978), Whitt (1979); we expect this line of work to be tedious without offering any substantial new insights, and have refrained from pursuing it in this paper.