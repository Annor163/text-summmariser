@&#MAIN-TITLE@&#
Rank-based memetic algorithm for capacitated arc routing problems

@&#HIGHLIGHTS@&#
The concepts of Rank Number and Rank Count are proposed to shed light onto the edge selection rules.The Rank-based Neighborhood Search (RENS) operator is introduced.Two rules, mapping rule and move rule, are constructed to explain work of virtual backtracking.The experimental results show that RMA performs very well.

@&#KEYPHRASES@&#
Memetic algorithm,Rank,Schema transition,Rank-based Neighborhood Search,Capacitated arc routing problems,

@&#ABSTRACT@&#
The capacitated arc routing problem (CARP) has garnered much attention recently, owing to its wide range of applications in the real world. This study describes an efficient memetic algorithm for solving CARP. First, the concepts of Rank Number (RankNo), and Rank Count (RankCount) are proposed, to shed light onto the edge selection rules. Then, the essential backbone of the algorithm, the Rank-based Neighborhood Search (RENS) operator, is introduced. Based on these above-mentioned concepts, methods relating to selection and evaluation of edge(s) are designed to make local search more effective. Two rules, namely mapping rule (MAR) and move rule (MOR), are constructed explain the working of the RENS operator. Finally, this algorithm is tested on seven famous benchmark sets. The experimental results show that it has the better performance than two compared state-of-the-art algorithms.

@&#INTRODUCTION@&#
The arc routing problem is a classic problem, the applications of which include things such as street sweeping, mail deliveries, cargo deliveries, and waste collection. The capacitated arc routing problem (CARP) is the most typical form of this problem. A CARP involves a graph G=(V, E, A), where the aim is to find the minimum cost routing plan for vehicles to serve all the required edges (undirected) and arcs (directed) within a graph.CARP is a NP-hard problem, as proven by Golden and Wong [1]. Keeping this in mind, classical exact methods are only applicable for simply and small-scale instances of CARP. Heuristics and meta-heuristics are more efficient algorithms for solving medium to large-scale CARP. For example, Augment-Merge [1], Path-Scanning [2], and Ulusoy's heuristic [3] are some of the typical heuristic approaches to solve large-scale CARP. Other heuristics approaches include Tabu Search in [4] and variable neighborhood search in [5,6]. Beullens et al. [7] established a guided local search (GLS) algorithm, in which mechanisms of neighbor lists and edge marking are considered to make the search process more effective.Mei et al. [8] designed a global repair operator (GRO), and further embedded it in a Tabu search algorithm (TSA) to form a repair-based Tabu search (RTS) algorithm. The reported results suggest that RTS outperforms TSA in terms of the quality of solutions, and it also has faster convergence speed than TSA. Santos et al. [10] proposed an improved ant colony algorithm for CARP (Ant-CARP), which had the better performance than the existing algorithms and found some new best solutions.In addition to the above-mentioned algorithms, some others have been designed for solving CARP [11–13]; and lower and upper bounds are improved for large scale capacitated arc routing problems in [14]. Among these, one type is known as the stochastic algorithms with evolutionary features. Such algorithms with natural evolution can lead the process of search in multiple directions at the same time, which have great advantage in accuracy of the solution and diversity of the population. A key issue, aimed at the relationship between exploration and exploitation for evolutionary algorithms is addressed in [15]. However, the shortcoming for such an algorithm has poor local search performance, although the global search capability of the algorithm is good.Moscato [16] introduced Memetic Algorithm in 1989, which is inspired by Darwinian natural evolution and Dawkin's memes notion [17]. These algorithms combine population search methods with a local search process, which is heuristic by information unique to each problem. Lacomme et al. [18] proposed a memetic algorithm in 2001, which combines the genetic algorithm with local search (called LMA in short). With the use of evolutionary characteristics, LMA can outperform several other algorithms. Mei et al. [19] developed LMA to ILMA (Improved LMA) by using a new evaluation rule in LMA. There are two versions of ILMA, which use two different penalty coefficients for infeasible solutions, i.e., ILMA1 and ILMA2. It was shown that ILMA2 with a finite changeable penalty coefficient is better than ILMA1 with an infinite penalty coefficient. Tang et al. [20] proposed the MAENS algorithm with Merge-Split (MS) operator, which has ability to perform searching for extended neighborhood. In this way, it has the potentiality to find better solution than the existing algorithms. Feng et al. [21] developed a probabilistic memetic algorithm (PMA) which is based on PrMF structure [22] for solving CARP that could balance global search and local search adaptively, giving it great superiority in solving CARP.An essential component of memetic algorithms lies in its local search process, which is the differentiating factor between memetic algorithms and most of evolutionary algorithms. Local search is usually considered to be a local optimization and refining process. We can refine solution quality by using the local search operators, however, general local search process only perform searching for a neighborhood and aim to find local optimum. Some scholars try to increase ability of local search operators. They suggest that local search should have the ability to expand the neighborhood during the search process in order that some good schema structures could be found, and at last the high quality solution could be obtained [9,20].Improving the efficiency of the local search process is also investigated. For those problems (i.e., CARP, TSP, etc.), whose local search operators are performed with edges movement, a common approach is that edge selection for the operation of local search operator is performed in an ordered way. However, in this method, as the information about the distance between the vertices is not fully considered, some of the key indicators that are relevant to the solution quality cannot meet the evaluation rules, which might makes the search invalid. In this paper, we present a way to easily evaluate these edges, and by performing local search operations to these edges some competitive candidates will be prior generated.In this paper, we propose a new local search operator, the RENS operator that is an intermediate between local search and global search. We also design a strategy that incorporates new edge evaluation criteria, which can identify edges, which are affecting solution quality negatively in their current position. Furthermore, a quantitative analysis method has been employed to evaluate the state of the edges belonging to a solution, which enables move operators to handle the above mentioned edges with poorer states first; consequently, this will make the operations of move operators more efficient.The rest of this paper is organized as follows. Section 2 gives description of capacitated arc routing problem and information on the general framework of memetic algorithms. Section 3 describes the concepts of rank number and rank count, which can aid in evaluation of edge state; Section 4 describes the RENS operator and its implementation mechanism. Section 5 details the idea of a memetic algorithm with rank-inspired edge selection and Rank-based Neighborhood Search, while Section 6 gives the experimental studies. Lastly, Section 7 outlines the conclusion of the paper and discusses future works.The CARP involves a graph G=(V, E, A), where the aim is to find the minimum cost routing plan for vehicles to serve all the required edges (undirected) and arcs (directed) within a graph. The edges and arcs to be served form a subset of all the edges E and arcs A of the graph. Each edge is considered as a pair of arcs, one for each direction. All arcs that need to be serviced are called tasks, and each task has a unique task ID (ID for the depot is set to 0).For CARP, sometimes several other constraints also need to be considered, some of those being heterogeneous fleet of vehicles, service time restrictions, prohibited U-turns, etc.Each solution of the problem is represented as a sequence of tasks (list of task IDs, with depot having ID 0), omitting the vertices between these. While considering the direction, edges are considered as two tasks, hence they have two task IDs. All task IDs are encoded from 1 by increasing 1. For an edge t, a task ID is labeled as t, while another task ID is labled as t plus |E|. The shortest path between them, which can be obtained from the Dijkstras algorithm, is used to connect them.For each task (given task ID is t), there are certain parameters associated with it, besides its head node and tail node, those being:(1)Serving cost (servecost(t)): the cost associated with serving this arc.Deadheading cost (deadheadcost(t)): the cost associated with traveling on the arc.Demand for the arc (demand(t)).The solution S is represented as (R1, …, Ri, …, Rm), Ri=(0, ti1, ti2, …, tip, 0), where Riis a route, which means a vehicle i; all tasks in a route Ridescribes those tasks served by the vehicle i. Given such a solution, the routing plan is found by finding the shortest path between two consecutive tasks for all routes.The problem can be defined as follows:(1)minTC(S)=∑i=1length(S)servcost(ti)+∑i=1m∑j=0pshortestpath(tij+ti(j+1))This equation represents the minimization of the total cost of the solution obtained. The first item represents the serving cost of all the tasks, it is a definite value. Thus, our aim is to seek minimum value of the second item. It is note that two facts: (1) shortestpath(tij, ti(j+1)) represents the shortest path distance between two consecutive tasks. In Particular, the first item shortestpath(0, ti1) and the last item shortestpath(tip, 0) represent the shortest distances from the depot to the task ti1, and the task tipto the depot for the route Ri; (2) the shortest path in this context refers to the path with the minimum total deadheading cost. This minimization is done with respect to the following constraints:(2)app(t)+app(inv(t))=1(3)m≤nveh(4)load(Ri)≤Qwhere app(t) is the number of times the task appears in a particular sequence. For each edge, inv(t) represents the inversion of this task, for the other direction; m is the number of routes, nveh is the number of vehicles, load(Ri) is the total demand for the route Ri, and Q is the capacity of a vehicle.Eq. (2) translates to the constraint that a task or its inversion should be serviced at least once, and they cannot be serviced at the same time. app(t), app(inv(ti))∈{0, 1}, the task t is serviced while app(t) equals to 1, otherwise the task t is not be serviced while app(t) equals to 0. Eq. (3) translates to the constraint that the number of routes should be less than or equal to the number of vehicles available, and lastly, Eq. (4) represents the constraint that for each route in the solution, the total demand of the route should be less than or equal to the capacity of the vehicle.Memetic algorithms are a special type of evolutionary algorithms, with one major difference, which is the replacement of the mutation operators in the evolutionary algorithm by local search operators in memetic algorithms. These operators usually incorporate some domain-specific heuristics, and hence MAs have shown such promising results. The combination of the global search operators and the local search operators helps MAs maintain a balance between generality and specificity.Local search operators have different forms because they have capability in searching different schema structure. For CARP, local search operators are referred to as move operators [18], which mainly include some common forms, such as:(1)Single-insertion: this operator moves a task from its current location to a new location of the solution or in a new empty route.Double-insertion: this operator moves two consecutive tasks, as opposed to one in the single-insertion operator.Swap: this operator swaps the position of two candidate tasks.2-opt: this operator selects a sub-route within a route, and reverses the direction of the tasks in it. When applied to two routes, they are first split into four sub-routes that, after reversing their directions, are re-connected.For local search behavior, a move operator with multi-step size is more desirable. This viewpoint is first discussed and supported by the conclusion presented in [23]. A simple way to implement this idea is by making an operator or more operators perform multiple times; e.g., Liang et al. [24] tackled the cutting stock problem using such an idea. As CARP is a more complex combinatorial problem, it is not easy to obtain high quality solutions only if the move operators are simply applied multiple times in a given sequential combination way.Sudholt [25] found out that high local search depth possibly has a significant impact on algorithmic performance. On the other hand, it will yield a super-polynomial computing time, which is consistent with the no free lunch (NFL) theorem [26]. Intractability of local search problems is discussed in [27], and variable-depth search is considered an effective approach to overcome local optima [28].With regard to move operator capability for CARP, Tang et al. [20] proposed a new move operator, namely merge-split (MS) operator in MAENS. The MS operator, which combines the path scanning (PS) heuristics [2] and Ulusoy's splitting procedure [3], can perform search in the extended neighborhood. In the process of the MS operator operation, the routes are selected based on stochastic features; thus new generated solutions can be regarded as an effect of global search feature through a series of operations of sorting and reorganization.When considering those optimization problems with strong constraints conditions like CARP, there are many infeasible solutions generated, and the algorithm′s performance will be decreased if these infeasible solutions are discarded. Since these infeasible solutions are likely to be converted into high-quality feasible solutions by using several transformation. In particular, we need focus on those infeasible solutions with low weight. This viewpoint is also addressed in literature work [20,29]. An effective method that overcomes this limitation is to add a penalty item for an infeasible solution. In addition, for exploring infeasible solutions, the repair operator is also a commonly employed method. An infeasible solution, with the capacity constraint that is handled through a global repair operator, may ultimately produce a feasible solution with high quality [9].Based on the above-mentioned analysis, we propose the RENS operator, which is a new local search operator based on the RENS data.Here, we give some basic definitions and concepts so as to facilitate the following analysis.Definition 1Rank Number (RankNo) is the position number, which is decided by the shortest distance from one vertex Vi(1≤i≤n) to another vertex Vj(1≤j≤n).(6)md(vi,vj)=0wheni=jmin{distance(vi,vj)}wheni≠jwheredistance(vi,vj)is distance from vertexvito vertexvj, and the shortest distance from one vertex to another is computed via the Dijkstra algorithm.Subsequently, the matrix MinDis can be constructed, where each element is decided by (6):(7)MinDis=0md(v1,v2)…md(v1,vn)md(v2,v1)0…md(v2,vn)…………md(vn,v1)md(vn,v2)…0For each vertex Vi(1≤i≤n), first, all vertices are sorted in ascending order based on the shortest distance from the vertex to all the vertices(including itself); second, a number is assigned for each vertex based on the distance, and the number is expressed as 1, 2, …, k. Note that the RankNo is the same for vertices that are equidistant from this vertex.After the above-mentioned process, we obtained a matrix RankNo corresponding to matrix MinDis. Here,rak(vi,vj)is the assigned number ofdis(vi,vj).(8)RankNo=1rak(v1,v2)…rak(v1,vn)rak(v2,v1)1…rak(v2,vn)…………rak(vn,v1)rak(vn,v2)…1As the distance from each vertex to itself is 0, i.e.,md(vi,vi)=0, it is the shortest distance from each vertex to the others. Here,rak(vi,vi)=1is given.In particular, for undirected graph, its relation can be shown as:md(vi,vj)=md(vj,vi)However, usually, the following relation exists:rak(vi,vj)≠rak(vj,vi)From the above-mentioned description, it can be noted that selecting edges by the order decided by RankNo is of more significance than selecting edges by the distance between the vertices. Since edges are selected by RankNo sorting considering two kinds of information, sorting information and distance information.Definition 2Rank Count (RankCount) for one edge indicates the sum of RankNo of the head node of the edge and tail node of its previous edge and the tail node of the edge and head node of its next edge. Thus it can be described as:Fig. 1shows RankCount structure of an edge (says e1).From the RankCount structure of the edge e1, it can be seen that it includes two connection links with each link being composed of two adjacent nodes of two nearing edges belong to the same route of a candidate solution. Here connection link is introduced to describe the degree of association between edges which can be measured by RankNo between adjacent nodes of edges. One edge has two connection links (i.e., l11 and l12 in Algorithm 1) and they can be used to measure the edge state.We note that, for a candidate solution, the relative position relationship between some edges and the adjacent edges might be more stable for move operators’ operation, while the relative position relationship between others edges and the adjacent edges are more likely to change. In other words, some connection links are not to be broken easily during local search process; while other connection links are easily broken. The stability of the relative position relationship for an edge and the adjacent edges is called edge state. Further studies showed that, for a high quality solution, the relative position relationship among the edges and the adjacent edges are more stable; while for a poor solution, the relative position relationship among the edges and the adjacent edges are more unstable. How to measure the state of the edge is an issue to be addressed in this paper. Considering the state of an edge is related to two connection links, by the definition of the RankCount above, edge state can be measured by RankCount by Definition 2 which is computed by RankNo.Generally, the smaller the RankCount of an edge and its adjacent edges is, the better is the state of the edge, given that RankCount reflects the actual distance between the edges. On the contrary, the greater the RankCount of an edge and its adjacent edges is, the poorer is the state of the edge.Edge state is an important criterion while executing the local search during edge selection. When operating the move operator, a poorer state edge can be moved to a new position. After movement the edge might be in a better state with a smaller RankCount value, thereby this might improve the quality of the solution.In this section, we firstly describe the RENS operator, a novel move operator based on rank information, and then discuss its implementation methods.The RENS operation is searching for better schemas, in a larger neighborhood, given the multi-step size of the operator. Although it is possibly similar to what the global search operation seeks to achieve, the RENS search operation does not permit population degradation. It aims to pursuit population evolution from the schema viewpoint.The RENS search process can be regarded as a search for a graph that is created by a candidate solution. The rules of creating a graph are as follows: The depot is selected as the traversal start node (i.e., root) and the nodes of all the edges, which are connected with root, are selected as extended nodes. Each extended node is further expanded or extended in breadth and depth direction along all of its available direct connection paths. Step size and combination method of conducting move operators are flexibly changed by computing gain. A search is considered to be successful when gain or composite gain is greater than zero, or increment of objective function value is smaller than zero. Hence, when the search is successful, a new graph is reconstructed for performing the new search processes. The algorithm stops when the global optimal solution is found or the given stopping condition is met.Some factors need to be considered while the RENS search process.(1)Which search method is applied in designing issue?What is the step size in deep level direction?Are all branches needed for traversal? Or which branches are preferably selected to move during the RENS search processes?For the first problem, backtracking, which usually uses Depth-First-Searching (DFS), is an exhaustive traversal method for a graph search. In the searching process, once the search in a direction is completed and the optimal solution is not found, the process subsequently goes back to its parent vertex to search other branches of the parent node. This process is repeated until it finds a node in which the best solution is satisfied, or until all the directions have been searched completely. The optimal solution can always be found when all the directions have been searched. This method is only suitable for solving small-scale graph search problem. However, for a moderate-scale complex graph, the computing cost (time) cannot be acceptable.For the second problem, it deals with the balance between solution's accuracy and computing cost. In this paper, the step size of the move operators is set to 3 based on the following factors: For each selected moving edge, when considering the relation information of the head node and tail node, two independent move operators are needed to perform. While performing two steps of move operators whose edge(s) are moved to the target route, the capacity of the target route must be beyond the given vehicle capacity Q, so some edges that need to be removed from the target route. Considering the computing cost of move operators, we need to perform one step of move operator to meet the capacity constraints. Accordingly, the whole step size for the above three step move operators is set to 3.For the third problem, when taking into account computing efficiency, it is noted that not all the branches (edges) should be selected to exploration; some branches should be ignored because they do not meet the principle of optimality. It deals with edge selection rules. Two rules are applied to this process. These are: (1) Some edges with larger RankCount value are preferably selected to perform move operators’ operation. This makes edges’ selection efficient because it can avoid edges’ selection with order way by lots of computing. (2) For a checked edge to be moved, the edge with smaller RankCount value between it and the edge to be selected is examined firstly. The above two rules of edges selection are fully taken used of the RankCount information. Taking use of RankCount information, we could design the RENS operator for edges selection from both positive and negative aspects of information.The pseudo-code for the RENS operator is provided in the following figure, with an explanation of the pseudo-code following it.Algorithm 1(the RENS operator)Begin1 for each edge of those selected edges to be moved (a1) do2 for each edge with better state edges between it and the edge to be moved (a2) do3   Search for possible moves; //a combination of move operators is considered here4   Compute gain (gain) or max composite gain (max_cgain) from each possible move;5   if (gain>0 or max_cgain>0)6 Perform combination move;7   endif8 endfor9 endforEndSome details need to be analyzed, and selection of key parameters will be discussed in the following:(1)Given a candidate solution, the search starts at the depot node. Each extended node of the depot node is expanded, first in the depth-first direction and then in the breadth-first direction. We all know that backtracking method is a basic technique during the search processes.The RENS operator examines the edges that are in a poorer state. As explained previously, rank data provides an effective measure of the state of an edge, which is used to control the parameters a1 and a2. We will explain the selection of a1 and a2 in the following.The operator considers the effect of moving these edges. This effect is quantified in the form of the increment of objective function value (cost) achieved by making this move. By not executing the move, consistency can be maintained for the rest of the search, so as to calculate the increment of cost for each move that is considered later on in the search. Here a new backtracking method, which is called virtual backtracking, is applied to the search processes. We will discuss its implement in Section 4.2.If the increment of cost is smaller than zero, in other words, gain is larger than 0, this move is executed, and the solution is modified.In order to improve search efficiency, the following changes are made to the search processes:A pruning strategy is employed for pruning branches that cannot lead to an optimal solution. This is done on the basis of rank data.This further raises the problem of the selection of the values for the parameters a1 and a2 (refer to Table 1at the end for description). These parameters determine the number of edges examined for the search process. The parameter a1 determines the percentage of edges whose states are relatively poorer that are selected to perform the search using the RENS operator, and the parameter a2 determines the percentage of better state branches, of the selected poorer state edge, which are examined while conducting the search. By controlling the values of these parameters, one can determine the size of the extended neighborhood examined during the process of the RENS operator, and can obtain high quality solution in an acceptable time.Here we first discuss process of virtual backtracking using an example, and then its implementation is addressed.For a candidate solution, it is assumed as following: S0=(0, 2, 10, 3, 4, 9, 7, 8, 0, 1, 6, 5, 0). There are two routes for the solution S0. The first route includes seven edges to be serviced, labeled as: 2, 10, 3, 4, 9, 7, 8. The second route includes three edges to be serviced, labeled as: 1, 6, 5. If the edge 9 is selected to move from the first route to the front of the edge 1 in the second route, and if backtracking is applied to the above move operator, edge 9 will be deleted from the position in the first route, and it is inserted into the corresponding position in the second route. Then edge position relationship is adjusted and increment of cost is computed for the next move operation. For virtual backtracking, our intention is to calculate the increment of objective function valu(cost) without edge movement, meanwhile mark these edges for further processing. If only take into account a step of move operator, the RENS operator based on backtracking or based on virtual backtracking has not essential difference, thus virtual backtracking is not necessary in this case; however, for multiple move operators, the case is different. The RENS operator based on virtual backtracking with labeling relationship of changing edges can work well without actual edges movement. Furthermore, it is not return to the parent vertex of current point as doing it like backtracking method when search fails in a direction.Here a key point is how to mark these edges and express the relationships among them? We adopt the relative position of edge(s) relationship to recode the movement of the edges. When taking into account move effect of the edge 9, information of edges relationship for the original side and the target side need to be adjusted. Firstly, for the original side, the next edge of the previous edge of the edge 9, namely, the next edge of the edge 4 is adjusted from the edge 9 to the next edge of the edge 9, i.e., the edge 7. Similarly, the previous edge of the next edge of the edge 9 is the edge 4. Second, for the target position, we should adjust the prior the edge 1 with its value being changed from 0 into 9. Finally, if increment of objective function value meets the given condition, then actual edges movement are performed and it is necessary to adjust the source position and target position information for the selected edge 9.In the above processes, virtual backtracking might be divided into two stages, mapping stage and movement stage. In the mapping stage, the relative position of edge(s) relationship is constructed by the move operators and edge(s) selected. We might need to pay special attention to the mapping stage. For example, for each step of multi-step local search operators, we mark the position change of edges and adjust the relative position relationship among the edges to compute gain. Only if gain is larger than zero, the second stage, i.e., the movement of edges is executed. In this way, if gain is smaller than or equal to zero, that is local search is false in a given direction, we might perform search in a new direction while avoiding backtracking to the parent vertex and recovering scene parameters.To achieve the above processes, two kinds of rules, which are called as mapping rule (MAR) and move rule (MOR), are designed and applied to the RENS operator based on virtual backtracking. Fig. 2depicts the relationship among the above-mentioned concepts. Here S0 is an initial solution; S1 is generated by S0 through a step of move operator (LS1) using backtracking, S2 is generated by S1 through a step of move operator (LS2) using backtracking. Svb1 is formed by S0 through a step of move operator (LS1) using virtual backtracking, and Svb2 is formed by Svb1 through a step of move operator (LS2) using virtual backtracking. Note that Svb1 and Svb2 are not actually generated, and they are the only imaging solutions whose roles are used to compute gain and cost indexes. In addition, MAR rules: MAR1, MAR2 are the mapping rules corresponding to two kinds of move operators. MOR rules: MOR1, and MOR2 are used to describe the relationship between S1 and Svb1, S2 and Svb2.In the following we will analyze how to construct rules of MAR and MOR.They need to be constructed for all the move operators, respectively. For each move operator, when considering the effect of position change on the original and target sides for the selected moving edge(s), the adjustment rules need to be built for the edge(s) to be moved.In the above example, when the edge 9 is selected to move from the route 1 to the front of the edge 1 in the route 2, we need to build the mapping rules for the original side, the target side and the edge 9.For the original side (the route 1), we need update the relative positions_of previous edge and next edge for the edge 9. Next edge of previous edge (the edge 4) of the edge 9 is next edge (the edge 7) of the edge 9; and previous edge of next edge (the edge 7) of the edge 9 is previous edge (the edge 4) of the edge 9, which can be described as below.me−>pe−>ne=me−>neme−>ne−>pe=me−>pewhere me is the edge to be moved, pe is previous edge, ne is next edge, symbol−>is a kind of relation. For example, me−>pe denotes previous edge of me.For the target side (the route 2), since the edge 9 is inserted into the front of the edge 1 in route 2, we need update the relative position relationship for the edge 1. The corresponding mapping relationship is that previous edge of the base edge (the edge 1) is adjusted as the edge to be moved (the edge 9), it can be described as below.be−>pe=mewhere be is the base edge.In addition, for the edge (the edge 9) to be moved, the route and virtual position need to be adjusted as below.me−>rnum=Tnum and me−>posvir=Tposwhere rnum is route number, posvir is virtual position, Tnum is target route number, Tpos is target position.As discussed the above, MAR rules are described in relative position information. Therefore, MOR should contain adjustment rules of edge between the actual position and relative position. When taking into account the direction between the edge to be moved and reference edge, MOR rules can be generally expressed as follows:me−>pos=me−>posvir+d1where d1 is a position offset. For the above-mentioned move operator, d1 is 1. A complete set of MAR and MOR rules is needed to make virtual backtracking work. Some other cases are not covered in this paper.As we all known that the RENS operator using backtracking needs perform each step of move operator's operation with lots of edges’ move and adjustment, which will cost much of time and computation. However, the RENS operator based on virtual backtracking with MAR and MOR rules can efficiently avoid invalid movement.The rank-based memetic algorithm (RMA) includes the following processes: initialization, global search operation (such as crossover operator), partial replacing operation, local search operation, evaluation and selection.This process invokes the initialization of the population and path information.For population initialization, all individuals selected in the initial population are generated in a random manner to maintain the diversity of individuals. Furthermore, information initialization also has the two following aspects: (1) computing distance among vertices by Dijkstra's algorithm; and (2) computing RankNo information, which has been presented in Section 3. RankNo information is saved in a pointer variable, which is used to compute the RankCount value of the edges for a candidate solution.For the global search process, two methods are employed. First, an ordered crossover (OX) [8] is applied to the population, to obtain the offspring solution.Second, if the best solution has not been changed for a number of generations, new individuals (generated randomly) replace some of the poorer individuals in the current population. This helps the algorithm to enlarge search space and maintain individual diversity in the population. When considering mutation operator is replaced by move operator, it is possible that global search capability is becoming poorer. From this viewpoint, partial replacement may makes the algorithm has better robustness.In the local search, the basic LSP is performed first. The basic LSP includes five commonly used operators for CARP, namely inversion, single insertion, double insertion, swap, and 2-opt [8,9]. The above-mentioned operators are called basic local operators because they perform a specific operation. Furthermore, it is worthwhile to highlight two aspects: (1) we extended the swap operator so that it can handle one or two edges while some repeated search cases are not missing and (2) edge selection is based on RankNo information.After executing the basic local search operator, a local optimum is obtained. Then the RENS operator can be executed on this solution. Owing to its larger step size, it has probability to look for new schemas in a larger neighborhood. After RENS has been executed on a solution, the basic local search is operated again to obtain the local optimum within this new neighborhood. The whole local search process is repeated as long as a better solution is found at each iteration, and the number of iterations is limited to a certain number. By modifying the local search process through RENS, it now has more chance to focus on those good schema structures, besides maintain the refining capability of the basic local search. Algorithm 2 is the pseudo-code for LSP, and Fig. 3is flow chart of the RENS operator.It should be noted that after performing the basic local search operation, and only if an improved solution is obtained, the RENS operation is performed on this solution. However, if the solution obtained from applying the basic move operators is not an improvement, the RENS process is forgone, and the local search process ends. Since in the case where the basic local search operation is unable to provide a better solution, the following reasons may exist: (1) the region represented by the candidate solution and its neighborhoods are ordinary regions and (2) these regions have been searched. Thus operating RENS on it might lead to a solution that is still not better than the original solution, making the search invalid, and the local search process will end as a better solution is not obtained. The relationship between the basic local search operator and the RENS operator, on the one hand, is the role of schema refining and schema discovery; on the other hand, it also reflects landscape feature in searching.In this study, we used two different criteria to evaluate the different situations during algorithm operation.The first criterion is as follows: If the capacity sum of all the routes satisfies the corresponding constraints, and if increment of objective function value (cost) is smaller than zero. In other words, in this case, it is called positive gain (gain) exists, i.e., gain>0, the move operator is executed. This criterion can effectively avoid missing global optimum when moving the edges.Algorithm 2(LSP)Begin1 Set count variable cv=0 and given count maxvalue cm=const; //cv= counter variable2 Do3   cv=cv+1;4   Compute beginning cost (begCost) for and best cost (bestCost) for Sb:begCost=split(Sc), besCost=split(Sb);5  ifcv>1 then6 Perform the RENS operator operation to Slgenerate Sl;7  end if8   Perform basic move operators to Slgenerate Sl;9   Compute ending cost (Ecost):10endCost=split(Sl);11   ifendCost<bestCost then Sb=Sl12   Compute increment of cost (incCost)incCost=endCost−begCost;13 While (incCost<0 or cv≤cm)EndAn extension criterion is as follows: When constraints violation does not increase and the gain is positive, the move operator is performed.The second criterion is as follows: If the increase in total capacity violation is greater than 0, then composite gain (CGain) is proposed for this case, which is given by:(10)CGain=(TC(X1)−TC(X0))−λ*(TV(X1)−TV(X0))=gain−λ*icvwhere TC(.) is the total cost and TV(.)is the summation of all routes capacity violation.As a punishment mechanism, the setting of punishment coefficient will affect the performance of the search algorithm. Its size should be dynamically reflected in the move operator operation and is varied with the change of constraints violation. Here, λ is initialized as follows, and its variation caused by local process is presented in [20]:(11)λ=TC(Xk)Q*TC(Xk)TC(X)+TV(X)Q+1The second criterion helps avoiding getting trapped in a local optimum, as it allows the generation of infeasible solutions.When computing objective value for a solution, by taking into account a solution into an infeasible solution (i.e., the possible existence of constraint violation), the split procedure using Ulusoy's heuristic [3] is applied to the infeasible solution, and a feasible solution with a minimum cost, but satisfying capacity constraints, is obtained.To properly evaluate the algorithm's effectiveness in solving CARP, we selected all the known benchmark sets in our test. The test results were compared with the existing two competitive algorithms [10,20].Table 1 summarizes the parameter settings for the algorithm. All the experiments were conducted for 30 independent runs. The algorithm was terminated when a given generation was reached or when the lower bound of test instances was found. When the best solution obtained by the algorithm does not change within 40 consecutive generations, six different individuals generated by random method were used to replace poorer individuals of the current population.Benchmark test sets and experimental results between RMA and three compared algorithms are shown in Tables 2–9.The following is a brief description of the contents in the tables (for details not mentioned here, kindly refer to [20]):(1)The columns headed |V|, and |R| indicate the number of vertices, required serviced edges numbers.The columns headed LB give the lower bounds found so far for all the instances referred in [20].Average value (Ave) and standard deviations (Std) are computed for the test data after 30 runs. The column headed best is the cost of the best solution obtained among the 30 runs.For each table, two additional rows are added at the bottom. The first row (mean) shows the average values calculated over all the instances of the test set for each algorithm. The second row presents the average percentage deviation (APD) from the lower bounds for each algorithm.As pointed out in some studies, it may not be easy for us to compare the solution quality and computing cost using different algorithms. On the one hand, the best solutions provided by some studies were obtained under the conditions of different parameters setting, or from a number of independent runs. In fact, it is hard to evaluate all compared algorithms performance. Because there are many factors may affect test data, such as computing platform, parameters setting, and even more strategies applied in the algorithms. Here we compared the performance indices between our algorithm and the other algorithms based on the following aspects: the best solutions, average solutions, and standard deviation.In terms of the best solution, in the 30 independent runs by each algorithm on test data, there were eleven relatively simple test instances for all the 24 test instances for the egl set, namely, E1-A, E1-B, E1-C, E2-A, E2-B, E2-C, E3-A, E3-B, E3-C, S1-A, S1-B. Our algorithm and the compared algorithms detected the known solutions from 30 independent runs. While for S4-C, only MAENS and RMA found the best solution with its value being 20,538. For the other twelve test instances, RMA found all the best solutions and improved four best-known solutions. For the rest of the test sets, RMA still outperformed the compared algorithms except the set D. However, this algorithm was slightly inferior to Ant-CARP on set D. Similarly, in terms of APD, RMA outperformed the compared algorithms on the egl set, and set C, E, and F, and also found two new best solutions.In addition, in terms of the average performance index, our algorithm also showed good characteristics. Since we cannot determine whether the median cost using Ant-CARP was an average index or not. Hence, we compared the average index between the algorithm and MAENS. For 24 instances of the egl set, the algorithm outperformed MAENS on most instances, except two (i.e., E1-A, and E2-A). As the two above-mentioned instances were relatively easy, MAENS and our algorithm converged to the best solutions from 30 independent runs. With respect to the other four instances, namely, E1-C, E2-B, E2-C, S1-A, and the algorithm found the best-known solutions for each run of 30 independent runs. With regard to the other test sets, the algorithm still outperformed MAENS except for the gdb set. RMA was slightly inferior to MAENS on the gdb set. Since MAENS always obtained the best solution while RMA failed to find the best solution in two runs of 30 runs. Note that the std data can reflect the algorithms stability to a certain extent. However, as the best solutions obtained by the compared algorithms for some test instances are different, comparison of the std data does not have substantial sense.Table 9 shows the comparative statistical data on the algorithm with the RENS operator and without the RENS operator for solving different test sets. From the comparative test results, it should be noted that the RENS operator proposed in this study has the capability to find those better solutions that are difficult to find by using basic move operators for some test instances. However, for those simple test instances, the effectiveness of the RENS operator is not obvious.Table 10shows the computing times of the algorithm and the compared algorithms. The algorithm is coded in C language and implemented in Intel(R) Core(TM) 2 Duo CPU E7400 2.8GHz. We know that the CPU running time of the algorithm is mainly affected by the CPU parameter; in addition, it is also affected by other factors, such as RAM, operating system, programming language and environment, etc. For MAENS, when taking into account hardware with CPU being Intel(R) Xeon(R) E5335 2.00GHz, the computing times of RMA need to be multiplied by 2.8/2 times, that is 1.4 times. In this way, RMA costs more computing times than MAENS for the val set and egl set; while it costs less computing times for set C and set D. It should be noted that the RENS operator in this algorithm includes three different phases of operations; hence, it has higher computational cost. It can be seen that from the test data only on the egl test set, the algorithm has significantly better results. We also realize that the difference in the computing cost between RMA and the compared algorithms is not obvious for the other test sets. When compared with the improvement in the solution accuracy, the increase in computation time is probably a secondary factor, and this conclusion is also based on the following considerations in practical problem and application requirements.We carried out further analysis on algorithm performance based on search capability and search efficiency.First, in the process of the proposed local search, the search schema has been changed. This is mainly reflected in the fact that the local search is no longer a simple refining process-it has the ability to find new schema. Although global search, such as mutation operator, on one hand, has the ability to find new schema structure; on the other hand, it will also result in degradation of the population. From the viewpoint of schema search, RENS is dedicated to find a better schema structure, while the basic search can be regarded as refinement and optimization for the good schema that has been found. The proposed algorithm, which includes global search, schema discovery, and schema refining, is beneficial to find a better solution.Second, the RENS operator has high time complexity and computational cost. To reduce the computation time, some methods and strategies have been applied to this algorithm. As was discussed before, the parameter a1 and a2 are used to control the number of edges that are examined.In this paper, the parameter a1 is set to 0.3 (Table 1), i.e., 30% edges whose states are relatively poorer are selected to perform the local search. This value limits the number of edges that are examined, thereby reducing computational time. It must also be noted that position relation (here, known as connection link) of such an edge with its adjacent edges is prone to be broken. Moreover, although the connection link between the edges with better state would not be actively broken, the passive association of some poor-state edges can still break it to form better connection link, and thus find higher quality solutions.The parameter a2 (Table 1) is set to one-sixth, so that for all extended branches of a selected edge (that is in the 30% of poorer state edges which are controlled by parameter a1), only about 16.7% of the better state branches, along the depth-first direction, are selected to perform the search. This parameter ensures that the number of better state edges for which the connection link is broken is not high.Only 30% of the edges with poor state, and for these edges, only 16.7% of the branches in a better state, were selected to perform the depth level search, while other branches were pruned. According to the selection of the above-mentioned parameters, the proportion of the selected branches among all the branches was as follows: 0.3*1/6*1/6*1/6*100% =0.14%, i.e., only about 0.14% of the space was selected to perform the RENS operation.As the RENS operator is dedicated to find the better schema structure and to obtain high-quality solution, it still has to be combined with the operation of basic search operators. As a result, the RENS does not lose the chance in finding the optimal solution for the above-mentioned parameters settings.As we all know, local search is regarded as a refining process. LSP speeds up the algorithm's convergence rate and improves the best solution's accuracy. However, general LSP, to some extent, also limits the ability of local search. In this study, the RENS operator has been introduced to expand the capabilities of the local search process. The basic search process focuses on discovering the neighborhood local optimal solution, and can be considered as a schema refining process; while the RENS operator has capability in discovering some new better schemas. This helps us to understand the behavior of local search and characteristics better. To improve the local search efficiency and avoid an invalid or repeated search, this study has proposed a quantitative analysis method by which an edge state can be computed and evaluated. By this method, move operators could deal with those edges with poorer states. With regard to the design issue of the RENS operator, it is modeled as a graph search process. Although backtracking is a commonly used method for the RENS process of a graph, it has some defects, such as low search efficiency and poor robustness. In this study, we have presented virtual backtracking, which, relative to exhaustive backtracking, performs actual edges’ moves when gain or composite gain meets the evaluation rule; thus, it has the advantage of lower computational cost, and enhances the robustness of the algorithm. In summary, in our opinion the success of our approach has four major components: (1) the proposed local search model aims at finding some promising local optima; (2) the RENS operator is applied to find good schema structure; (3) the quantitative analysis method of edge preferably select those poor state edges in local search process; and (4) some strategies, such as pruning strategy, are applied to avoid unnecessary computing and search.In theory, the optimization process itself is a systematic project. The designs of some key factors in optimizing greatly influence the algorithm. In the future research, we will carry out further investigation on the collaboration and balance among different operators, and use landscape features to guide the search of the operators.

@&#CONCLUSIONS@&#
