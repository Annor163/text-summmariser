@&#MAIN-TITLE@&#
An efficient hybrid particle swarm optimization algorithm in a rolling horizon framework for the aircraft landing problem

@&#HIGHLIGHTS@&#
A hybrid particle swarm optimization algorithm in a rolling horizon framework is proposed to solve the aircraft landing problem.The performance of the proposed algorithm is evaluated using benchmark instances involving upto 500 aircrafts and 5 runways.The proposed algorithm outperforms the existing approaches in the literature.The proposed algorithm is effective in solving the problem in short computational time.

@&#KEYPHRASES@&#
Aircraft landing problem,Metaheuristics,Particle swarm optimization,Rolling horizon approach,

@&#ABSTRACT@&#
This paper proposes a hybrid particle swarm optimization algorithm in a rolling horizon framework to solve the aircraft landing problem (ALP). ALP is an important optimization problem in air traffic control and is well known as NP-hard. The problem consists of allocating the arriving aircrafts to runways at an airport and assigning a landing time to each aircraft. Each aircraft has an optimum target landing time determined based on its most fuel-efficient airspeed and a deviation from it incurs a penalty which is proportional to the amount of deviation. The landing time of each aircraft is constrained within a specified time window and must satisfy minimum separation time requirement with its preceding aircrafts. The objective is to minimize the total penalty cost due to deviation of landing times of aircrafts from the respective target landing times. The performance of the proposed algorithm is evaluated on a set of benchmark instances involving upto 500 aircrafts and 5 runways. Computational results reveal that the proposed algorithm is effective in solving the problem in short computational time.

@&#INTRODUCTION@&#
Aircraft sequencing and scheduling problems have gained considerable importance in recent years due to frequent air traffic congestions and flight delays at airports caused by the increasing air traffic volume amid scarce airport resources. Several optimization models of scheduling aircrafts at terminal areas have been discussed by researchers over the last two decades [1]. Aircraft landing problem (ALP) is one of the important optimization problems in air traffic control which is well known as NP-hard.The ALP consists of allocating the arriving aircrafts to runways at an airport and assigning a landing time to each aircraft, which is constrained within a specified time window, bounded by an earliest landing time and a latest landing time. The earliest landing time is the time at which an aircraft can land if it flies at its maximum airspeed and the latest landing time is the maximum allowable time of holding (circling) the aircraft before landing it. Each aircraft has an optimum target landing time determined based on its most fuel-efficient airspeed, referred to as the cruise speed. A deviation from the target landing time incurs a cost which is proportional to the amount of deviation. A landing aircraft creates wake turbulence and, therefore, the following aircrafts must maintain a minimum separation time for safe landing. Thus, each arriving aircraft is assigned a landing time such that it satisfies the minimum separation time requirement with its preceding aircrafts. A heavy aircraft usually generates more severe wake turbulence than a small aircraft and, therefore, the safe separation time between aircrafts is sequence-dependent.Basically two cases of ALP have been considered in the literature, namely, the static case and the dynamic case. In the static case [2], the complete information about target landing times and time windows for a given set of aircrafts in a planning horizon are known and the schedules are generated for all the aircrafts at once. In the dynamic case [3], the schedules are modified over time as new aircrafts arrive in the radar range of the airport. In this paper, the static case of ALP is considered with the objective to minimize the total cost due to the deviation of landing times of aircrafts from the respective target landing times.The static aircraft landing problem has been researched for over two decades. Abela et al. [4] considered the single runway ALP and proposed two approaches, a genetic algorithm (GA) based heuristic and a branch and bound algorithm to solve the problem. They tested the performance of their proposed approaches using problem instances involving upto 20 aircrafts. Ernst et al. [5] presented a simplex algorithm for the ALP and found optimal solutions for instances involving upto 44 aircrafts on both single and multiple runway cases. Beasely et al. [2] developed a mixed integer zero-one formulation for the ALP. They obtained optimal results for problem instances involving upto 50 aircrafts using a linear programming-tree search based exact approach. Pinol and Beasely [6] developed two population based heuristic approaches, a scatter search and a bionomic algorithm for the ALP. They tested the performance of their proposed algorithms with problem instances involving upto 500 aircrafts and 5 runways. Their proposed algorithms were capable of finding optimal solutions only for the instances with upto 50 aircrafts. Soomer and Franx [7] presented a single runway ALP that allows airlines to provide cost functions for their aircrafts which is then rescaled by air traffic control to ensure equity among different airlines. They presented a mixed integer programming formulation for the problem and proposed a local search based approach to solve problem instances obtained from a major European hub. Yu et al. [8] proposed a cellular automation based optimization approach to solve the single runway ALP and tested its performance on the instances earlier used by Pinol and Beasely [6]. Their proposed approach was capable of finding optimal solution for instances with upto 100 aircrafts. Salehipour et al. [9] presented two hybrid simulated annealing based metaheuristic approaches for the ALP. Their proposed approach was capable of finding optimal solution for benchmark instances with upto 50 aircrafts and was competitive with the results obtained using CPLEX software for large size instances. Bencheikh et al. [10] presented a hybrid genetic algorithm-tabu search approach and tested its performance with the results obtained by Pinol and Beasely [6]. Xie et al. [11] presented a hybrid metaheuristic based on bat algorithm to solve ALP and compared its performance with the results obtained by Pinol and Beasely [6] for multiple runways instances. Awasthi et al. [12] presented a schedule generation procedure for a given landing sequence and runway allocation and proposed a simulated annealing algorithm for the ALP. They compared the performance of their algorithm with the results obtained by Pinol and Beasely [6] and reported better solutions than the best known solutions for several instances. Vadlamani and Hosseini [13] proposed a decomposition based heuristic to solve the single runway ALP. They tested the performance of their approach on benchmark instances with upto 150 aircrafts.Recently, Faye [14] presented a time discretization approach for the ALP and proposed an exact approach and a heuristic approach to solve the problem. They compared the performance of their exact approach with other time discretization approaches from literature using the benchmark instances from Ref. [6]. The performance of their heuristic approach is analysed by comparing with the approaches presented in Ref. [6]. Sabar and Kendall [15] presented an iterated local search approach for the ALP that uses multiple perturbation operators with time varying perturbation strength to escape from local optimum. They compared the performance of their approach with the approaches from Refs. [6,9] using the benchmark instances.The above literature review reveals that both exact and heuristics approaches have been proposed to solve the ALP. Most of the recent papers have focussed more on developing heuristic approaches due to the computational complexity associated with solving large size problem instances. This paper presents a hybrid particle swarm optimization-local search algorithm in a rolling horizon framework to solve the problem under consideration. The performance of the proposed approach has been tested on benchmark instances involving upto 500 aircrafts and 5 runways.The notations used for describing the problem are as follows:n number of aircraftsi index for aircrafts (i=1,2…n)j index for aircrafts (j=1,2…n)m number of runwaysr index for runways (r=1,2…m)Eiearliest landing time of aircraft iLilatest landing time of aircraft iTitarget landing time of aircraft igipenalty associated with early landing of aircraft ihipenalty associated with late landing of aircraft iSSijminimum separation time requirement between aircrafts i and j, with i preceding j, when landing on the same runwaySDijminimum separation time requirement between aircrafts i and j, with i preceding j, when landing on different runwaysxiassigned landing time of aircraft iCipenalty cost associated with landing of aircraft i.There are n arriving aircrafts in the radar range of an airport and m number of runways available for landing. Each aircraft i has a most-economical target landing time Tiand a early or late landing incurs a penalty which is proportional to the amount of deviation from Ti. If an aircraft is scheduled to land earlier than its target landing time, then the landing is penalised by a cost giper unit time of deviation from the target landing time. On the other hand, if the aircraft is scheduled to land later than its target landing time, then its landing is penalised by a cost hiper unit time of deviation from the target landing time. If xiis the scheduled landing time of aircraft i, then the penalty cost is determined as Ci=gi×max(0, Ti − xi)+hi×max(0, xi − Ti). Obviously, Ciis zero if the aircraft is assigned a landing time equal to its target landing time.Each aircraft i has a time window (Ei, Li) within which the landing time xican be assigned, i.e. Ei≤xi≤Li, where Eiand Liare, respectively, the earliest landing time and the latest landing time.For each pair of aircrafts (i, j) scheduled to land on the same runway, a minimum separation time SSijis required to be maintained between their landing times. If an aircraft i is scheduled to land ahead of aircraft j on the same runway, then xj≥SSij+xi, where xiand xjare the landing time of aircrafts i and j, respectively. For each pair of aircrafts (i, j) allocated on different runways, a minimum separation time SDijis required to be maintained between their landing times.The objective of the problem is to determine the optimal allocation of aircrafts to airport’s runways and also to determine the optimum landing schedules that minimizes the total cost due to the deviation of landing times from the respective target landing times, given by∑i=1nCi. The mathematical formulation for the problem [9] is as follows.Decision variables:xi=landingtimeof aircraftiyij={1,iflandingtimeofaircraftiprecedesaircraftj0,otherwiseδij={1,ifaircraftiand aircraftjare assigned to the same runway0,otherwisezir={1,ifaircraftiisassignedtorunwayrforlanding0,otherwiseObjective:(1)Minimize∑i=1n(gi×max(0,Ti−xi)+hi×max(0,xi−Ti))Subject to:(2)Ei≤xi≤Li∀i(3)xj≥xi+SSij×δij+SDij×(1−δij)−H×yji∀(i,j):i≠j(4)yij+yji=1∀(i,j):i≠j(5)∑r=1mzir=1∀i(6)δij≥zir+zjr−1∀(i,j,r):i≠j(7)δij−δji=0∀(i,j):i≠j(8)δij,zir,yij∈0,1∀(i,j,r):i≠jEq. (1) is the objective function of the ALP. Eq. (2) represents a set of constraints that confines the landing times of each aircraft i within its earliest landing time and the latest landing time. Eq. (3) represents a set of constraints that allocates landing times to aircrafts such that the safe separation time between the landing times of each pair of aircrafts (i, j) assigned to the same runway or different runways are satisfied. The term H in the equation represents a large positive integer. The equation is active only when the binary variable yji=0, i.e. when aircraft i precedes aircraft j for landing. The equation becomes inactive when yji=1. Eq. (4) represents a set of constraints that creates the landing sequence between each pair of aircrafts (i, j). Eq. (5) represents a set of constraints that assigns each aircraft to exactly one runway for landing. Eqs. (6) and (7) represent a set of constraints that assigns the variable δijeither to 1 or 0 depending on whether the pair of aircrafts (i, j) are assigned to the same runway or different runways, respectively.This section first describes the proposed hybrid particle swarm optimization-local search (HPSO-LS) algorithm without the rolling horizon framework. A brief description on the general PSO algorithm is presented as a preliminary to the proposed HPSO-LS algorithm. The rolling horizon (RH) framework that embeds the HPSO-LS algorithm to solve the ALP is presented subsequently.Particle swarm optimization (PSO) is a population based metaheuristic approach based on the flocking behaviour of birds. The approach was introduced by Kennedy and Eberhart [16] in 1995. PSO optimizes a given problem by iteratively moving a set of candidate solutions in the search space in pursuit of finding an optimal solution with regard to a given objective function. The search process starts by initializing a swarm comprising of a set of particles wherein the position of each particle is a feasible solution to the problem in an encoded form. Particles cooperate to find the best position (best solution) in the search space by moving towards the particle best position and the global best position with each iteration. The particle best position is the best position found by each particle so far. The global best position is the best position found by the swarm so far. Each particle moves from its present position to its next position according to a velocity which is calculated based on its own previous position, its particle best position and the global best position. In the case of continuous optimization problems, the position updating by changing the velocity is represented as(9)Vkj⟵w×Vkj+c1×rand1×(pbestkj−Xkj)+c2×rand2×(gbestj−Xkj)(10)Xkj⟵Xkj+VkjIn Eqs. (9) and (10), Vkjis the velocity of particle k on dimension j, and Xkjis the position of particle k on dimension j. The pbestkjis the particle best position corresponding to particle k on dimension j, and gbestjis the global best position of the swarm on dimension j. The constants c1 and c2 are used to decide the extent to which the particles prefer to move towards the particle best position and the global best position, respectively. rand1 and rand2 are random numbers between 0 and 1.The particle position representation in the early implementation of PSO to the machine scheduling problems [17–19] used continuous values that indicated priorities for the tasks and Eqs. (9) and (10) were used for velocity and position updating to change the task priorities over the iterations. Zhang et al. [20] proposed a PSO for the resource-constrained project scheduling problem, and compared two types of particle position representation: (1) priority-based representation that uses continuous values to indicate priorities, and (2) permutation-based representation, in which the particle position is represented by sequential order of activities. Their computational experiments proved permutation-based representation to be better than priority-based representation. Sha and Hsu [21] also proposed PSO approaches with the two particle position representation schemes, the priority-based representation and the permutation-based representation, for the classical job shop scheduling problem. Their computational experiments also proved permutation-based representation to be better than priority-based representation. The HPSO-LS algorithm proposed in this paper uses a permutation-based particle position representation scheme and iteratively moves the particles in the solution space by applying certain operators.Population based metaheuristics (like Genetic algorithm, PSO, etc.) do very well in exploring the overall search space in pursuit of the global optimum solution, but they are not very good at locating the local optimum in the regions they explore due to their inability to make small moves in the neighborhood of current solutions. Therefore, metaheuristics are usually combined with a local search method to improve their local exploitation ability [17,21,22]. The PSO algorithm proposed in this paper is coupled with a local search (LS) algorithm to leverage the advantages mentioned above.The particle position representation used in the proposed HPSO-LS algorithm and its decoding is described as follows.The position of each particle in the proposed HPSO-LS algorithm consists of two parts. The elements in the first part of the position vector represent the landing sequence (SEQ) of all the aircrafts in the planning horizon. The second part of the position vector with as many number of elements equal to the total number of aircrafts in the planning horizon, represents the allocated runway (RA) corresponding to each aircraft in the landing sequence (SEQ). An example of a particle position vector is shown in Table 1. In the example, there are 10 arriving aircrafts (A1, A2, …A10) and two runways (R1 and R2) at the airport. The first element in the first part of the position vector is aircraft A4, which is sequenced to land ahead of aircraft A2, the second element of the position vector. Therefore, the elements in the first part of the position vector indicate the landing sequence of aircrafts in the order, A4, A2, A1, A5 and so on. The first element in the second part of the position vector indicates that aircraft A4 (the first element in SEQ) is assigned runway R2 for landing. In the same way, aircraft A2 is assigned runway R1, aircraft A1 is assigned runway R2 and so on for all the other aircrafts in SEQ.The procedure to generate optimal landing schedules for a given particle position vector is based on the optimal timing algorithm proposed in Refs. [23–25] for the single machine scheduling problem. Solving the ALP for a given landing sequence on a single runway can be thought of as a single machine scheduling problem with earliness and tardiness penalties for each job. However, there is a subtle but important difference between the ALP and the single machine scheduling problem [5]. In the ALP, the separation constraint must not only be satisfied between immediately successive aircrafts in the sequence, but between all pairs of aircrafts. In single machine scheduling, on the other hand, this type of separation requirement between completion times of non-successive jobs does not exist [5]. The schedule generation procedure proposed in this paper for the ALP adopts the optimal timing algorithm and extends it to include the separation constraints between non-successive aircrafts as well. The schedule generation procedure for the single runway and multiple runway cases is discussed in the following sections. The algorithm of the proposed schedule generation procedure is given in Appendix A along with an illustration for a multiple runways case.Given a landing sequence SEQ with n number of aircrafts, let Yirepresent the landing time of each aircraft i (i=1,2,…n). Letσkrepresent the partial sequence containing the first k aircrafts in SEQ. Let Sk={Y1, Y2,…Yk} represent the partial schedule corresponding to σk. Let Pkrepresent the total penalty cost corresponding to the partial schedule Sk. A set of aircrafts that are scheduled contiguously in Skis called a block. A pair of aircrafts (i, j), with i preceding j, are contiguous to each other and belong to the same block if Yj=Yi+SSij. Let Bkrepresent the block that contains the aircraft k in the partial sequence σk. The cost function of Bkcan be expressed in terms of the landing time Yk. Let the cost function of block Bkbe represented as Z(Yk).Z(Yk) is always a piece-wise convex cost function with only one minimum point [23–25]. Fig. 1shows an example of a block of aircrafts on a single runway and a typical plot of the cost function Z(Yk) when the landing time Ykis reduced.Reducing the landing times of all the aircrafts in a block by the same amount of time is termed as ‘left-shifting’ of the block or ‘block-shifting’. The slope of the cost function Z(Yk) for a specific value of Ykcan be expressed asSL=∑i∈LATEhi−∑i∈EARLYgi. In the equation, LATE represents the set of aircrafts belonging to Bkthat are late from their respective target landing times and EARLY represents the set of aircrafts belonging to Bkthat are early from their respective target landing times.The schedule generation procedure is described as follows. Initially, the partial schedule S1={Y1} is generated by assigning the first aircraft in the landing sequence SEQ to its target landing time (i.e. Y1=T1). Subsequently, the partial schedule Sk(2≤k≤n) is generated from Sk−1 by assigning the landing times of all the aircrafts in Sk−1 to Skfollowed by determining a feasible landing time for the aircraft k. The landing time of aircraft k is determined as follows.If Yi+SSik≤Tk(∀i:Yi∈Sk-1), then aircraft k is scheduled to land at its target landing time Tk(i.e. Yk=Tk). The partial schedule Skis optimal in this case.Conversely, if Yi+SSik>Tk(for any Yi∈Sk-1), then Yk=max1≤i≤k-1{Yi+SSik} (such that Yi∈Sk-1). In this case, the aircraft k has a penalty cost due to lateness. The block Bkcorresponding to the aircraft k is subsequently generated and a block-shifting procedure is applied to optimize the partial schedule Sk.In the block-shifting procedure, a set of aircrafts is selected from Bksuch that it contains the aircraft k and has the greatest slope for its cost function. Let the set of selected aircrafts be represented as B* and its cost function be represented as Z*(Yk). The set B* is formed in such a way that if an aircraft in Bkbelongs to B* then its preceding aircraft with which it is contiguously scheduled, also belongs to B*. The set B* must contain the aircraft k and should have the greatest slope for its cost function Z*(Yk) among all the feasible sets that can be formed from Bk. If Z*(Yk) has a positive value for its slope, then left-shifting aircrafts in B* yields the greatest improvement in total penalty cost Pkper unit time than any other feasible set formed from Bk. In the example given in Fig. 1, two feasible sets can be formed from the block B8; one set contains all the aircrafts in B8 and the other set contains all the aircrafts in B8 excluding the aircraft A7.The aircrafts in B* are retained in Bkand the other aircrafts are removed. The newly formed block Bk, which contains only the aircrafts in B* with cost function Z(Yk)=Z*(Yk), is then left-shifted to optimize the partial schedule Sk. Let the above procedure of obtaining the new block Bkfor left-shifting be represented as optimal_block procedure.The block Bkis left-shifted towards the minimum point of its cost function Z(Yk) until one of the following cases occurs.(i)The landing time of an aircraft i in the block Bkbecomes equal to its earliest landing time Ei.An aircraft that belongs to Bk, as a result of left-shifting becomes contiguous with a preceding aircraft that does not belong to Bk.When the slope of the cost function Z(Yk) changes or when the minimum point of the cost function Z(Yk) is reached.In case (i), the optimal_block procedure is again applied on the block Bksuch that the set B* does not contain the aircraft i with its landing time Yi=Ei. The new block Bkobtained with the optimal_block procedure is left-shifted towards the minimum point of its cost function. The cases, (i), (ii) and (iii) are checked during left-shifting.If the aircraft with its landing time equal to its earliest landing time cannot be excluded to form a feasible set B*, then no left-shifting is done further and the resulting partial schedule Skis optimal. However, if Ykis greater than Lkin the partial schedule Sk, then no feasible schedule exists for the given SEQ.In case (ii), the block Bkis re-generated. The optimal_block procedure is subsequently applied to the re-generated block Bk. The new block Bkobtained with the optimal_block procedure is left-shifted towards the minimum point of its cost function. The three cases, (i), (ii) and (iii), are checked during left-shifting.In case (iii), the optimal_block procedure is again applied to Bkso as to obtain the set B*. The new block Bkthus formed from B* using the optimal_block procedure is left-shifted towards the minimum point of its cost function. The three cases, (i), (ii) and (iii), are checked during left-shifting.In case (iii), if the block Bkreaches its minimum point and no further improvement in penalty cost is possible with the optimal_block procedure (i.e. the slope of the cost function corresponding to all the feasible sets in Bkare negative), then the resulting partial schedule Skis optimal and no left-shifting is further done. However, if Ykis greater than Lkin the partial schedule Sk, then the block-shifting procedure is continued until Ykbecomes equal to its latest landing time Lk. The cases, (i), (ii) and (iii) are checked during left-shifting.Awasthi et al. [12] presented a left shifting procedure based on net positive value of slope to optimize the landing times of a block of aircrafts for the single runway ALP. However, in their schedule generation procedure, initially all the aircrafts in an instance are assigned landing times considering the separation requirements and subsequently the blocks with positive slope are identified and left shifted. They extended their schedule generation approach to the multiple runways case assuming each runway to be independent of the other with no separation requirements between aircrafts landing on different runways, i.e SDij=0,∀(i,j). The schedule generation procedure for multiple runways case presented in the following section of this paper is a generalized one and can be applied for any positive value of SDij, i.e. SDij≥0,∀(i,j).In the multiple runways case, a pair of aircrafts (i, j), with i preceding j, are contiguous and belong to the same block if their landing times are separated either by SSijor SDij. In other words, aircrafts i and j, with i preceding j, are contiguous and belong to the same block if Yj=Yi+SSij, when i and j are on the same runway or if Yj=Yi+SDij, when i and j are on different runways. Therefore, a block in multiple runways case may consist of aircrafts from more than one runway as shown in an example in Fig. 2. The cost function Z(Yk) of the block Bkexpressed in terms of Ykis always a piece-wise convex function and has only one minimum point.The initial partial schedule S1={Y1} is generated by assigning the first aircraft in the sequence SEQ to its target landing time (i.e. Y1=T1). Subsequently, the partial schedule Sk(2≤k≤n) is generated from Sk-1 by scheduling the aircraft k as follows.If Yi+SSik≤Tk(∀i:Yi∈Sk-1, i and k are on same runway) and Yi+SDik≤Tk(∀i:Yi∈Sk-1, i and k are on different runways), then aircraft k is scheduled to land at Tk(i.e. Yk=Tk). The resulting partial schedule Skis optimal.Conversely, if Yi+SSik>Tk(for any Yi∈Sk-1, i and k are on the same runway) or if Yi+SDik>Tk(for any Yi∈Sk-1, i and k are on different runways), then the landing time assigned to aircraft k is Yk=max{YS,YD}, where YS=max1≤i≤k-1{Yi+SSik} (such that Yi∈Sk-1, i and k are on the same runway) and YD=max1≤i≤k-1{Yi+SDik} (such that Yi∈Sk-1, i and k are on different runways). The block Bkcorresponding to aircraft k is generated and the block shifting procedure is applied to optimize the partial schedule Sk. The optimal_block procedure and the three cases to be checked during left-shifting are performed in the same way as discussed in the single runway case. Fig. 2 shows the feasible sets that are formed during optimal_block procedure for the given example. Left-shifting the set of aircrafts with greatest slope for its cost function towards its minimum (feasible) point optimizes the partial schedule Skand results in optimal total penalty cost Pk.Fig. 3shows the different modules of the proposed HPSO-LS algorithm in the form of a flowchart.The following are a few important notations used in the description of the proposed HPSO-LS algorithmswarm_size number of particles in the swarmq index for particles (q=1,2,…swarm_size)par_pos(q) position vector of particle qpar_sol(q) total penalty cost corresponding to par_pos(q)pbest_pos(q) best position vector found by particle q so farpbest_sol(q) total penalty cost corresponding to pbest_pos(q)gbest_pos best position vector found from the beginning of the algorithmgbest_sol total penalty cost corresponding to gbest_posThe detailed description of the different modules of the proposed algorithm is as follows:The following data pertaining to the problem is given as input in this module: number of aircrafts (n), number of runways (m), earliest landing time (Ei), latest landing time (Li), target landing time (Ti) corresponding to each aircraft i (i=1,2,…n), minimum separation time requirements (SSij) between each pair of aircrafts (i, j) on same runway, minimum separation time requirements (SDij) between each pair of aircrafts (i, j) on different runways, cost of early landing of each aircraft (gi) per unit time and cost of delayed landing of each aircraft (hi) per unit time.A set of particles equal to swarm_size is generated in this module. Each particle q in the initial swarm consists of a position vector par_pos(q). As discussed in Section 3.2, each position vector consists of two parts; the landing sequence part (SEQ) and the runway allocation part (RA). The SEQ part of position vector, if randomly generated, may result in infeasible solutions due to the time window constraints and separation requirements between aircrafts (usually in the range 60–200s). Besides, as it can be seen in Fig. 4, the time windows between all pair of aircrafts do not overlap (or the amount of overlap between the time windows is less than the separation time between the aircrafts), literally forming a precedence relationship between them. Therefore, a position vector generation procedure is proposed (shown in Figs. 5 and 6) to generate the initial swarm. The position vector generation procedure first generates the SEQ part of the position vector in the neighbourhoods of the target landing time sequence and subsequently assigns the aircrafts to runways to generate the RA part of the position vector.In order to generate the SEQ part of the position vector, the first come first serve (FCFS) sequence using the target landing times is initially obtained. Let list represent the sequence of aircrafts as per the FCFS order and pirepresent the position of each aircraft (i=1,2…n) in the sequence. The first aircraft in list has p1=1, the second aircraft has p2=2, and so on till the last aircraft in list. The position vector generation algorithm uses the roulette wheel selection mechanism to choose an aircraft from list and place it in land_seq. The aircraft is chosen from list based on a probability which is an exponential function of its position piin list and a parameter α. A higher value of parameter α generates sequences very close to the FCFS sequence, whereas lower values result in random sequences. Fig. 5 shows the flowchart of the position vector generation procedure to generate the landing sequence part of position vector.The runway allocation (RA) part of the position vector is generated using the schedule generation procedure discussed in Section 3.3. In the schedule generation procedure, when an aircraft k is picked from land_seq to generate the partial schedule Sk, it is assigned to each of the available runways (r=1,2,..m) and the corresponding total penalty cost (cost(r)) is determined. The runway on which the partial schedule Skhas the least total penalty cost (i.e.min1≤r≤mcost(r)), is allocated to the aircraft k. The landing sequence and the allocated runways obtained corresponding to each particle q is assigned to par_pos(q). The total penalty cost obtained with the schedule generation procedure is assigned to par_sol(q). If the SEQ and RA generated, results in an infeasible schedule, then the SEQ and RA are re-generated using the position vector generation procedure until a feasible schedule is obtained. Fig. 6 shows the flowchart of the position vector generation procedure to generate the runway allocation part of position vector.Based on the par_pos(q) and par_sol(q) obtained for each particle q (q=1,2,…swarm_size) in the current iteration, the best position found so far by the particle and its corresponding penalty cost are updated in pbest_pos(q) and pbest_sol(q), respectively. The best position vector found from the beginning of the algorithm and its corresponding penalty cost are updated in gbest_pos and gbest_sol, respectively.In this module, a local search procedure is performed to improve the objective value of each particle in the swarm. The local search procedure generates a set of neighbourhood position vectors corresponding to each particle position vector q (q=1,2,…swarm_size). The best neighbourhood (with the least total penalty cost) replaces the particle position vector if it is an improved solution. The process of generating neighbourhoods and selecting the best neighbourhood to replace the particle position vector is repeated until there is no further improvement in the total penalty cost. The neighbourhood generation mechanisms used in this paper are pair-wise interchange and insertion.In the pair-wise interchange mechanism, the neighbourhood position vectors are generated by swapping the elements in the particle position vector. A set of neighbourhoods are generated by pair-wise interchange of aircrafts in the first part of position vector. Each neighbourhood position vector generated in this set has all its elements same as the particle position vector, except that two aircrafts in the first part of the position vector have swapped positions.In the multiple runways case, another set of neighbourhoods are generated by pair-wise interchange of elements in the second part of the position vector. Each neighbourhood position vector generated in this set has all its elements same as the particle position vector, except that two aircrafts in the second part of the position vector have swapped their runways.An element is paired with another element for swapping in such a way that the distance between their positions in the position vector is within a certain limit. Let this limit be represented as swap_limit. Then swap_limit is an integer that limits the positions for an element to choose its pair. If an element from the kth position is chosen and swap_limit is 5, then it can be paired with another element which is between positions (k−5) and (k+5) in the position vector.In the insertion mechanism, the neighbourhood position vectors are generated by moving an element in the particle position vector to another position. A set of neighbourhoods are generated by shifting the position of aircrafts along with its runway in the position vector. Each neighbourhood position vector generated in this set has all its elements same as the particle position vector, except that one aircraft along with its runway is removed from its original position and inserted in another position. The shifting of position of an aircraft and its runway is confined within a limit represented by shift_limit. If an aircraft at the kth position is to be shifted and shift_limit is 5, then it can be moved to positions only between (k−5) and (k+5) in the position vector.In the multiple runways case, another set of neighbourhoods are generated by changing the runway at each position in the second part of the position vector. Each neighbourhood position vector generated in this set has all its elements same as the particle position vector, except that the runway of an aircraft is changed in the second part of the position vector. The first part of the position vector remains unchanged.The values of swap_limit and shift_limit were set as 5 in order to reduce the computational burden of the algorithm.In this module, each particle q (q=1,2…swarm_size) updates its position based on its current position par_pos(q), its own previous best position pbest_pos(q) and the global best position gbest_pos. The procedure involves a step by step approach of creating a new position vector new_pos. In each step, an aircraft along with its runway is probabilistically selected from one of the position vectors; par_pos(q), pbest_pos(q) and gbest_pos. The aircraft, which is not yet allocated in new_pos, is selected along with its runway from the leftmost position of the probabilistically chosen position vector and placed at the last available position in new_pos.The probabilities to select the position vector are determined using the following equationsprob_cur(q)=fcur(fcur+c1×fpbest+c2×fgbest)prob_pbest(q)=c1×fpbest(fcur+c1×fpbest+c2×fgbest)prob_gbest(q)=c2×fgbest(fcur+c1×fpbest+c2×fgbest)where prob_cur(q), prob_pbest(q) and prob_gbest(q) are the probabilities of selecting an aircraft from current position, previous best position and global best position, respectively. c1 and c2 are two parameters that define the relative importance between the present position, particle best position and global best position. The values of c1 and c2 were set as 0.5 based on the values set for the two parameters in similar PSO algorithms proposed in the literature [26,27]. fcur, fpbestand fgbestare the functions of total penalty cost corresponding to the present position, previous best position and global best position, respectively, which are determined as follows.fcur=1.0par_sol(q)fpbest=1.0pbest_sol(q)fgbest=1.0gbest_solThe total penalty cost corresponding to the position vector new_pos is then determined using the schedule generation procedure, and if the generated schedule is feasible, the landing sequence and runway allocations in new_pos are assigned to par_pos(q). If the generated schedule corresponding to new_pos is infeasible, then the particle position updating procedure is repeated until a feasible new_pos is obtained. An illustration of the particle position updating procedure is shown in Fig. 7.The algorithm is terminated if atleast half of the number of particles in the swarm converge to the gbest_sol value or if a specified number of iterations num_iter is reached. The algorithm is also terminated if gbest_sol becomes zero.The schedule generated corresponding to the gbest_pos position vector along with gbest_sol is printed in the output module.Rolling horizon (RH) based approaches have already been applied to solve the dynamic cases of ALP [28–31]. In the dynamic ALP, RH approach is used as an online optimization strategy wherein, based on the current available information of aircrafts, the problem is optimized for a fixed time horizon. After a specific roll period, the RH approach repeats the optimizing procedure for another fixed time horizon based on the updated information of the arriving aircrafts. The RH framework proposed in this paper is based on the rolling horizon scheduling strategy presented in Ref. [32] in which the rolling domain (horizon) is defined in terms of number of jobs rather than a time interval. The proposed RH framework converts the original runway allocation and scheduling problem into several smaller problems so as to reduce the computational burden.The proposed RH approach consists of two parameters: (1) an optimization window of size W and (2) a rolling parameter R, both defined in terms of number of aircrafts. Fig. 8shows the consecutive optimization windows and the rolling parameter which advances the window.The rolling parameter creates overlapping optimization windows which are optimized in such a way that the output of an optimized window becomes the initial condition of the following one until all the aircrafts in the instance are optimized. The runway allocation and landing sequence of aircrafts within each window is optimized using the HPSO-LS algorithm. As the solution space of each optimization window is much smaller, the HPSO-LS algorithm can more efficiently perform the search to obtain high quality solution. Though, the landing sequence of aircrafts along with its allocated runways preceding the optimization window is frozen, their landing times are allowed to change when partial schedules corresponding to aircrafts within the window are determined using the schedule generation procedure.The RH-HPSO-LS framework for the ALP is described in the following steps.Let:SET_A represent the sequence of all the n aircrafts in the given instance.SET_B represent the allocated runway corresponding to each aircraft in SET_Aa1, a2 are integers to indicate the positions of elements in SET_A and SET_BSET_A[a1, a2] represent the sequence of aircrafts from position a1 to a2 in SET_ASET_B[a1, a2] represent allocated runways of aircrafts from position a1 to a2 of SET_B.RH-HPSO-LS algorithm:Step 1. Input parameters of RH: W, R and parameters of HPSO-LS algorithm: α, swarm_size, num_iter.Step 2. Generate SET_A as per the FCFS order of the target landing times of all the n aircrafts. Initialize SET_B={ϕ}. Initialize a1=1 and a2=W. If a2>n, then set a2=n.Step 3. Apply the HPSO-LS algorithm for the aircrafts in SET_A[a1, a2]. The aircrafts in SET_A[a1, a2] are rearranged based on the optimized sequence obtained with HSPO-LS algorithm and the runway allocations corresponding to these aircrafts are assigned to SET_B[a1, a2].Step 4. If a2=n, go to step 5.Else if (a2+R)≤n, then set a1⟵a1+R and a2⟵a2+R. Go to step 3.Else if (a2+R)>n, then set a1⟵n−W+1 and a2⟵n. Go to step 3.Step 5. SET_A and SET_B are the optimized sequence and runway allocations, respectively, of all the n aircrafts in the given instance. Generate the schedule corresponding to the SET_A and SET_B using the schedule generation procedure and determine the total penalty cost.The HPSO_LS algorithm in step 3 of the RH-HPSO-LS algorithm is elaborated in the following steps.Step 3.1. If a1>1, then obtain the partial scheduleSa1−1corresponding to the sequence of aircrafts in SET_A[1, a1−1] and runway allocations in SET_B[1, a1−1] using the schedule generation procedure. Delete runway allocations in SET_B[a1, a2].Step 3.2. Initial swarm generation: arrange the aircrafts in SET_A[a1, a2] as per the FCFS order of the target landing times. Generate the initial swarm for the aircrafts in SET_A[a1, a2] using the position vector generation procedure shown in Figs. 5 and 6. The sequence of aircrafts land_seq is first generated followed by the runway allocations run_alloc. If a1>1, use SET_A[1, a1−1], SET_B[1, a1−1] and the corresponding partial scheduleSa1−1while allocating runways to aircrafts in land_seq using the position vector generation algorithm. The position vector of each particle q (q=1,2,…swarm_size) is assigned to par_pos(q) and the total penalty cost is assigned to par_sol(q).Step 3.3. Perform local search to improve each particle’s position par_pos(q). If a1>1, use SET_A[1, a1−1], SET_B[1, a1−1] and the corresponding partial scheduleSa1−1while generating schedules for each neighbourhood position vector. Generate the partial schedulesSa1throughSa2using the partial scheduleSa1−1each time a neighbourhood position vector is evaluated.Step 3.4. The best position found by each particle is updated in pbest_pos(q) and its corresponding penalty cost is assigned to pbest_sol(q). The global best particle and its penalty cost is updated in gbest_pos and gbest_sol, respectively.Step 3.5. Termination check: if atleast half of the number of particles in the swarm have converged to the global best solution or if the specified number of iterations num_iter is reached or if gbest_sol is zero, go to step 3.7. Otherwise go to step 3.6.Step 3.6. Update the position of each particle as per the procedure shown in Fig. 7. Determine the total penalty cost corresponding to each particle using the schedule generation procedure. If a1>1, use SET_A[1, a1−1], SET_B[1, a1−1] and the corresponding partial scheduleSa1−1while generating schedules for each particle position vector. Go to step 3.3.Step 3.7. Rearrange the aircrafts in SET_A[a1, a2] as per the sequence in gbest_pos and assign the corresponding runway allocations to SET_B[a1, a2]. Return to the step 4 of RH-HSPO-LS algorithm.The performance of the proposed algorithms, HPSO-LS and RH-HPSO-LS, is evaluated using a set of benchmark instances taken from the OR library (http://people.brunel.ac.uk/∼mastjjb/jeb/orlib/airlandinfo.html). The algorithms were coded in C language and run on a PC with 3.4GHz Intel core I7-2600K quad-core (8 threads) processor and 4GB RAM. The performance of the two algorithms is compared with two PSO variants from literature and the results obtained by solving the mixed-integer programming (MIP) model using CPLEX software (IBM ILOG CPLEX Optimization studio version 12.5.1 [33]). The performance of the proposed algorithms is also compared with the reported results of the existing approaches from literature. Table 2shows the existing approaches used for comparison including the PC used and the separation time considered across runways.The parameters of the two proposed algorithms, HPSO-LS and RH-HPSO-LS, were fine tuned by performing experiments on benchmark instances for different sets of values. Fig. 9shows the influence of parameters W and R on average objective value and average computation time obtained by executing the RH-HPSO-LS algorithm on the 500 aircrafts—single runway instance for 10 replications.The scatter plot reveals the following. Small values of W make the algorithm short sighted [28] and yields poor quality solutions. Increasing the value of W improves the average objective value, but the computation time also increases due to increase in computational burden on the algorithm. For a specific value of W, decreasing the value of R increases the computation time due to the increase in number of windows to be optimized. Therefore, the values for W and R have to be chosen in such a way that the algorithm is able to generate the best landing sequence and runway allocations for the first R number of aircrafts in each window and has the minimum overall computation time.Fig. 10shows the influence of parameter α on average of the best objective values, overall average of objective values and overall average of computation times obtained by executing the RH-HPSO-LS algorithm on eight large size benchmark instances with 10 replications for each instance. The graph reveals that, though the algorithm is able to obtain the same best objective values for the entire range of parameter α, the average objective values obtained are not consistent. The algorithm is less consistent for large values of α as it generates landing sequences very close to the FCFS sequence and the algorithm converges quickly at sub-optimal solutions. Lower values of α generate more random sequences, and the algorithm is less consistent in finding the best objective value in the set number of iterations. Lower values of α also require more computation time due to the slower convergence of algorithm. Since, the algorithm provided most consistent results for α=1.6, the same was used for performance analysis.The following sets of parameter values were found to be efficient in terms of solution quality and computation time.HPSO-LS algorithm: α=1.6, swarm_size=16, num_iter=40.RH-HPSO-LS algorithm: W=30, R=10, α=1.6, swarm_size=16, num_iter=40.The proposed algorithms were run 10 times for each instance. The best objective value (BEST) and the average (AVG) of the 10 replications for each instance were obtained to analyse the performance of the two proposed algorithms. The local search section of the code in both the algorithms was parallelized using Open Multi-Processing (OpenMP) [34]. The average computation time (in seconds) of the 10 replications obtained by executing the algorithms on a single thread (t1) and eight threads (t8) of the CPU are obtained in order to analyse the efficiency of the two proposed algorithms.In order to analyze the performance of the proposed PSO approaches, two other variants of PSO proposed for parallel machine scheduling problems were chosen from literature. The particle position representation and position updating of the two PSO variants were taken from literature and applied in the algorithmic structure shown in Fig. 3 of this paper. The two variants are coupled with the local search (LS) procedure and implemented in the RH framework presented in Sections 3.4 and 3.5, respectively. The descriptions of the PSO approaches (namely, VAR1 and VAR2) are as follows:The PSO approach, adapted from Ref. [35], uses an m×n matrix with real values for particle position and velocity representation (where n is the number of aircrafts and m is the number of runways). Each column of the matrix corresponds to an aircraft and the elements in the rows of each column indicate the priority value corresponding to each runway. Let pijindicates the priority value of aircraft i on runway j in the position matrix and let vijindicates the velocity in the m×n velocity matrix corresponding to aircraft i and runway j. Each aircraft is first assigned a runway with the maximum priority value (pij1≤j≤mmax,∀i). The landing sequence is generated by arranging the aircrafts (i=1,2,..n) in the decreasing order of the maximum priority values (pij1≤j≤mmax). The initial swarm is first generated using the position vector generation procedure presented in Section 3.4 of this paper. The initial swarm, which is generated using the job-to-position representation [35], is then encoded into the m×n matrix with priority values in the range [0, 4] according to the procedure given in Ref. [35]. The initial velocity matrix for each particle is also generated as per the procedure given in Ref. [35]. As proposed in Ref. [35], the values of elements vijin the velocity matrix are always bounded in the range [vmin, vmax] such that|vij|≤XCmax. The position matrix corresponding to the particle’s personal best and the global best are updated in each iteration. Each element in the velocity matrix and the position matrix is updated using Eqs. (9) and (10) given in Section 3.1 of this paper. If the position updating corresponding to a particle results in an infeasible solution, the position updating is repeated five more times with different values of rand1 and rand2 in Eq. (9). If the position updating still does not provide a feasible solution, then a new position matrix is generated for the particle using the position vector generation procedure. After position updating, the position matrix is decoded into the discrete job-to-position representation and the local search (LS) procedure is applied. The position matrix is modified according to the improved solutions obtained in the LS procedure using the solution representation modification procedure presented in Ref. [35]. The parameter values were set by fine tuning through trials and the best values in terms of solution quality and computational time were found to be: c1=0.1, c2=0.2, w=0.1, XCmax=1.0. The parameter values set are less than the best values reported in Ref. [35]. Using the parameter values reported in Ref. [35], the algorithm was found to generate infeasible solutions (due to the time window constraints) after position updating and the performance was poor mainly in terms of computational time for most of the instances.The PSO approach, adapted from Refs. [36,37], uses a 1×n matrix with real values for particle position representation (where n is the number of aircrafts), wherein each element in the matrix corresponds to one aircraft. The initial swarm, generated using the position vector generation procedure, is encoded into real values in the range [1, m+1] (where m is the number of runways). The integer part of each element in the position matrix gives the runway allocation for each aircraft. The landing sequence is generated by arranging the aircrafts in the decreasing order of the decimal part of the elements. The initial velocity of each particle is a 1×n matrix with real values generated randomly in the range [vmin, vmax]. The position and velocity matrix of each particle is updated using Eqs. (9) and (10) given in Section 3.1 of this paper. The values of elements in the velocity matrix are always bounded in the range [vmin, vmax] and the values of the elements in the position matrix are bounded in the range [1, m+1] using the procedure presented in Ref. [36]. If the position updating corresponding to a particle results in an infeasible solution, the position updating is repeated five more times with different values of rand1 and rand2 in Eq. (9). If the position updating still does not provide a feasible solution, then a new position matrix is generated for the particle using the position vector generation procedure. After position updating, the position matrix is decoded into the discrete particle position representation and the local search (LS) procedure is applied. The position matrix is modified according to the improved solutions obtained with the LS procedure using a repair mechanism similar to the one presented in Ref. [17]. In the LS procedure, the pair-wise interchange of runways is performed by interchanging the integer part of the elements in the position matrix. For pair-wise interchange of aircrafts in the landing sequence, the decimal part of the position vectors are interchanged. The insertion operation is performed by rearranging the decimal part of the elements in the position matrix according to the change in the sequence. The parameter values were set by fine tuning through trials and the best values were found to be: c1=0.2, c2=0.4, w=0.2, [vmin, vmax]=[−1, 1].Tables 3 and 4show the computational results of the two proposed algorithms (HPSO-LS and RH-HPSO-LS) and its comparison with results obtained using CPLEX software. Table 3 shows the results obtained for the single runway instances and the multiple runways instances with SDij=1,∀(i,j), whereas Table 4 shows the results obtained for the multiple runways instances with SDij=0,∀(i,j). For each problem instance, CPLEX was run on all the eight threads of the processor for a maximum CPU time of 3600s and the best solution obtained within the set time limit is reported. For some instances, the CPLEX software provided the optimal solution, which are highlighted (in bold) in Tables 3 and 4 with computation times less than 3600s.The results obtained with the proposed algorithms (HPSO-LS and RH-HPSO-LS), shown in Tables 3 and 4, were verified for its correctness using CPLEX concert technology (callable libraries to implement the CPLEX solver in C/C++) [33]. The best landing sequence and runway allocations obtained with the proposed algorithms were input as values of the decision variables (yij,zirand δij) to the mixed integer programming (MIP) model of the ALP instance (Eqs. (1)–(8) in Section 2 of this paper) using CPLEX concert technology and run on the CPLEX solver to verify the results by generating landing schedules (xi) and the objective value. In the literature, Pinol and Beasely [6] have used CPLEX concert technology to determine schedules and objective values in their proposed scatter search (SS) and Bionomic algorithm (BA). The CPLEX concert technology can also be used in place of the schedule generation procedure (described in Section 3.3) in the proposed HPSO-LS and RH-HPSO-LS algorithms. However, for a given landing sequence and runway allocations, the proposed schedule generation procedure generates schedules and the objective value much faster (almost 100 times faster) than that obtained with CPLEX solver. The CPLEX concert technology was used for verifying the correctness of coding (in C language) of the proposed schedule generating procedure.Tables 3 and 4 also show the results obtained with the two PSO variants. The local search procedure in the two PSO variants was parallelized using OpenMP. The objective values and the computational times reported in the Tables 3 and 4 are obtained by running the two PSO variants on all the eight processing threads of the CPU. The other parameters of the two PSO variants were set the same as in RH-HPSO-LS algorithm: W=30, R=10, α=1.6, swarm_size=16, num_iter=40. Since the optimization window is set as W=30 and the number of aircrafts in the Airland1 to Airland6 instances are less than or equal to 30, the RH-HPSO-LS algorithm executes the same sequence of codes as the HPSO-LS algorithm. Hence, the results of RH-HPSO-LS algorithm for these instances are similar to the HPSO-LS algorithm.Tables 3 and 4 show the percentage gap (% GAP) between the RH-HPSO-LS algorithm and the other algorithms used for comparison (i.e. HPSO-LS, RH-VAR1-LS and RH-VAR2-LS) in terms of the best objective values found. The percentage gap (% GAP) is calculated as(11)%GAP=A−UU×100where U is the best objective value obtained with the proposed RH-HPSO-LS algorithm and A is the best objective value obtained with the other approaches.The comparison between the proposed algorithms, HPSO-LS and RH-HPSO-LS, reveals that the two algorithms are equally competent in terms of the quality of solutions found. Only for one instance (instance no. 13-2-1), the best objective value found by HPSO-LS algorithm is inferior to the RH-HPSO-LS algorithm. The RH-HPSO-LS algorithm outperforms the HPSO-LS algorithm in terms of computational time for large size instances. The RH-HPSO-LS algorithm is consistent in terms of average (AVG) of the 10 replications and the number of times the best solution is found. The RH-HPSO-LS algorithm performs three to five times faster with multi-thread processing using OpenMP.The CPLEX software was capable of finding the optimal solution for a few large size instances (highlighted in bold in Tables 3 and 4) within the set time limit of 3600s. The comparison between RH-HPSO-LS algorithm and CPLEX reveals that the RH-HPSO-LS algorithm has found better solutions for four large size instances (highlighted in bold). In terms of computational time, the RH-HPSO-LS algorithm performs much better than CPLEX.The comparison of the RH-HPSO-LS algorithm and the two PSO variants from literature reveal that the three PSO algorithms are equally competent in terms of consistency (average of the 10 replications) and the best objective values found. The RH-HPSO-LS algorithm was found to be relatively better than the two PSO variants in terms of computational time particularly for the two and three runways instances. Varying the parameter values of the two PSO variants did not significantly improve its computational time, however, the consistency (average of the 10 replications) of the algorithms deteriorated significantly. The computational time for the two PSO variants was found to be relatively higher mainly due to the number of infeasible solutions generated after position updating in each iteration, the number of iterations the local search procedure took to improve the particles in each iteration and the number of iterations required for half of the particles in the swarm to converge to the same best objective value in each rolling horizon window.Tables 5 and 6show the percentage gap (% GAP) between the proposed RH-HPSO-LS algorithm and the existing approaches from literature in terms of the best objective values found for large size instances. One possible complication in using Eq. (11) is that for some problems U (or A) is zero in which case % GAP is taken as zero if and only if both U and A are zero, otherwise it is undefined [6]. The smaller size instances have not been considered for comparison as the CPLEX software and most of the existing approaches have provided optimal solutions in short computation time. The results of bionomic algorithm (BA) from Ref. [6] are not taken for comparison in Table 6 as the objective values reported are much inferior compared to the scatter search (SS) approach. The CPLEX software provided optimal solutions for a few instances in Ref. [9], which is highlighted in bold in Tables 5 and 6. In Ref. [9], the CPLEX software was run for a maximum CPU time of 1000s for each instance.The ILS approach [15] provided improved solutions for four multiple runways instances that are better than the solutions obtained with CPLEX and all the other approaches (including the RH-HPSO-LS algorithm), shown with negative values of % GAP (i.e. instance nos. 9-3-0, 10-3-0, 10-4-0 and 11-4-0) in Table 6. However, in the case of these four multiple runways instances, the CPLEX software found the optimal solution within the set time limit of 3600s, which can be seen in Tables 4 and 6. Therefore, the improved values reported in Ref. [15] with ILS approach for the four multiple runways instances indicate possible errors in their results. These four instances are easily solved to optimality with CPLEX in short computation time. Hence, the results of the four multiple runway instances reported for ILS have not been considered for performance comparison in this paper. In Ref. [15], the performance of ILS approach has been compared with the SA-VND [9] and SA-VNS [9] approaches, and the improved results reported with the ILS approach also contradicts with the results reported as optimal using CPLEX software in Ref. [9] (shown in Table 6). In the case of other multiple runways instances (with SDij=0,∀(i,j)), the solutions obtained with ILS approach [15] are inferior compared to the PSA approach [12], as shown in Table 6. The PSA approach performs relatively better than all the other existing approaches for multiple runways instances with SDij=0,∀(i,j).In the case of single runway instances, CAO [8], SA-VND [9] and ILS [15] approaches perform relatively better than the other existing approaches. In Ref. [15], the ILS approach provided improved solution (shown with negative value of % GAP in Table 5) for the Airland11-single runway instance (instance no. 11-1), which is better than the solutions obtained with CPLEX and all the other approaches (including the RH-HPSO-LS algorithm).One of the important requirements of an approach for ALP is that it should be able to solve the instances in short computational time. In a real-life situation, the air-traffic controller has to make decisions quickly so as to provide instructions to the pilots regarding the allocated runway, flight path, approach speed and altitude, so that the aircrafts can be sequenced to land according to the assigned landing times [1,8]. Figs. 11–13show the comparison between RH-HPSO-LS algorithm and the existing approaches in terms of average computation time required to generate the best objective values for large size instances. The RH-HPSO-LS algorithm is executed on a high-end PC compared to the PCs used for the existing approaches. Therefore, a one to one comparison will not reveal the true performance gap between the approaches.The computational times for SS and BA algorithms [6] have not been shown in Figs. 11 and 13 as the reported values are much higher than the other existing approaches. The performance of TDA [14] is much inferior compared to the two existing approaches, HBA [11] and PSA [12], mainly in terms of computational time for the multiple runways instances which is evident from Fig. 13. The TDA approach consists of a dynamic constraint generation algorithm that uses optimization software to solve the problem. Faye [14] compared the linear programming (LP) relaxation of their time discretization method with other time discretization methods from literature and stated that the most important part of the CPU time of their method is spent in loading the problem, which takes upto ten times the time it requires to resolve the problem. Faye [14] also stated that the time for loading the problem increases with the increase in number of runways. These statements clearly reveal the drawback of using optimization software in their approach. Even the first iteration results of TDA approach (reported in Ref. [14]) takes very high computational time compared to the final results obtained with the RH-HPSO-LS algorithm.The performance comparisons from the Tables 5 and 6 and Figs. 11–13 reveal that SA-VND [9] and PSA [12] have shown better performance than the other existing approaches in terms of solution quality and computational time, considering both single and multiple runways instances. Out of the 24 large size single runway and multiple runways instances, the RH-HPSO-LS algorithm provided better solutions than PSA and SA-VND in 12 and 15 instances, respectively. In comparison with all the existing approaches from literature, the RH-HPSO-LS algorithm found better solutions for three single runway instances, four multiple runways instances with SDij=1 (∀(i,j)) and seven multiple runways instances with SDij=0(∀(i,j)).Hence, it can be concluded from the computational results that the proposed RH-HPSO-LS algorithm is an effective approach to solve the ALP in short computational time.

@&#CONCLUSIONS@&#
