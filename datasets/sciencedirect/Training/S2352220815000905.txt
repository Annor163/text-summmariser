@&#MAIN-TITLE@&#
Product line process theory

@&#HIGHLIGHTS@&#
Notions of bisimulation for product line process calculi are studied.Compositionality (congruence) results are proved for the notions of bisimulation.Sound axiomatization for the a calculus of product lines (PL-CCS) is provided.The axiomatization is proved ground-complete for closed terms with finite behavior.Product line bisimulation is characterized by the multi-valued Modal mu-Calculus.

@&#KEYPHRASES@&#
Software product line,Process theory,Product line bisimulation,Strict strong bisimulation,μ-Calculus,Axiomatization,

@&#ABSTRACT@&#
Software product lines (SPLs) facilitate reuse and customization in software development by genuinely addressing the concept of variability. Product Line Calculus of Communicating Systems (PL-CCS) is a process calculus for behavioral modeling of SPLs, in which variability can be explicitly modeled by a binary variant operator. In this paper, we study different notions of behavioral equivalence for PL-CCS, based on Park and Milner's strong bisimilarity. These notions enable reasoning about the behavior of SPLs at different levels of abstraction. We study the compositionality property of these notions and the mutual relationship among them. We further show how the strengths of these notions can be consolidated in an equational reasoning method. Finally, we designate the notions of behavioral equivalence that are characterized by the property specification language for PL-CCS, called multi-valued modal μ-calculus.

@&#INTRODUCTION@&#
Software product line (SPL) engineering has become an established trend in software development, where a family of similar software products with minor differences are developed in tandem, instead of developing each specific software product separately [1]. SPL engineering benefits from systematic reuse throughout the system life cycle and enables mass development and customization of numerous products. Hence, the development cost and the time to market for an SPL is substantially decreased, compared to the cumulative development cost and time of the isolated products [2]. To this aim, various software engineering activities have to be adapted to cope with the differences among the artifacts for different products, called variability. Variability introduces a new complexity dimension and hence, this calls for a genuine treatment of variability in different artifacts (such as requirement specification, architectural design, detailed design, and implementation artifacts). Such a treatment should also allow for a collective analysis of product line behavior (e.g., in testing and verification [3,4]) to deal with the inherent complexity of SPLs.At the highest level of abstraction, an SPL can be specified by a set of features that satisfy the specific needs of a particular market segment or mission [5]. A feature identifies “a prominent or distinctive unit of requirement which can be either a user-visible behavior, aspect, quality, or characteristic of a software system” [6]. Hence, a product can be specified by a subset of features. To specify an SPL, the features are organized in a hierarchical model, called a feature model. It identifies commonalities and differences among the products of the SPL in terms of their features and it identifies suitable relations among features, such as optional, mandatory, or mutually exclusive. More concrete specifications capture structural and behavioral aspects of an SPL. For instance, the architecture description languages Koala [7] and xADL [8] concentrate on structural modeling of SPLs. Modal transition systems (MTSs) [9] and Featured transition systems (FTSs) [10], however, concentrate on behavioral modeling (we refer to [11] for an overview of such behavioral models). MTSs capture the behavior of SPLs by defining state transitions as optional or mandatory, while FTSs annotate transitions with a set of features. Behavioral models typically come equipped with a product derivation method; e.g., a product, derived from a feature model, can project an FTS into a labeled transition system (LTS).Formal verification techniques provide strong tools to analyze complex systems to guarantee their correctness. Process algebra is a formal approach to describe the behavior of communicating concurrent systems in a compositional manner. Product Line Calculus of Communicating Systems (PL-CCS) [12,13] is an extension of Milner's Calculus of Communicating Systems (CCS) [14]. PL-CCS extends CCS by adding the binary variant operator⊕ito model behavioral variability in SPLs. More specifically, process termp1⊕1p2, wherep1andp2are CCS process terms, specifies a family of two alternative products, namelyp1orp2(the index i in⊕iis used to designate repeated choices that have to be made in the same way; when no repetition of indices is present, the indices can be safely ignored). The semantics of a PL-CCS specification is given in terms of three different models: the flat semantics, the unfolded semantics, and the configured-transition semantics[12]. A PL-CCS specification can be turned into a product, specified by a CCS term, by resolving the variability points, i.e., the variant operators, by deciding on whether their right or left process is chosen. The flat semantics of a PL-CCS term is given in terms of the semantics of all derivable products, denoted by CCS terms. A product family LTS (PF-LTS) is an extension of an LTS, where labels and states are paired with configuration vectors that maintain the configuration of variants. PF-LTSs provide the unfolded semantics of PL-CCS terms and are derived through a set of structural rules in a systematic way. The structural rules given in [12] work on a restricted set of PL-CCS terms in order to be compositional. The configured-transition semantics is defined over the unfolded semantics by merging all states that only differ in their configuration parts. This provides the most succinct model of PL-CCS terms. Hence, in the developments to come, we mostly focus on the configured-transition semantics of PL-CCS. In particular, we provide a set of structural rules that derive a configured-transition semantics for PL-CCS terms directly.Equational reasoning is the cornerstone of the algebraic approach to process theory. To furnish PL-CCS with a proper equational theory, we study a number of notions of behavioral equivalence, based on strong bisimilarity [15]. A summary of these notions, their properties and the results establishing their relationship is depicted in Fig. 1. We start with a set of axioms that we expect to be sound for a model of PL-CCS and define the notion of strict strong bisimilarity, which is a natural extension of strong bisimilarity in the SPL setting. Namely, strict strong bisimilarity requires bisimilar product lines to behave bisimilarly for all common configurations. This turns out to be a fully compositional notion for PL-CCS, but too strong of a notion for some of our intuitive axioms. For example, strict strong bisimilarity rejectsp⊕iq=q⊕ip, which is an intuitive axiom. Subsequently, we introduce a strictly coarser notion, called product line bisimilarity, which does satisfy the axioms we defined for PL-CCS. However, this notion is shown to satisfy a weaker compositionality property. Namely, it is compositional for a subset of PL-CCS terms, called fully expanded terms. To remedy the latter issue, we show that all PL-CCS term can be rewritten into this subset using a sound transformation, thanks to the strong compositional notion of strict strong bisimilarity. Since strict strong bisimilarity implies product line bisimilarity this transformation is also sound for the latter notion and hence, resolves its compositionality issue. Finally, we introduce configuration bisimilarity, which is an alternative yet equivalent notion for product line bisimilarity. The main motivation for introducing configuration bisimilarity is that it allows for reasoning about the product line behavior as a whole and hence, dispenses with scrutinizing individual products' behaviors.Our axiomatization is useful to identify common parts (i.e., the mandatory parts) among the products of a family, to reorganize the functionality of a family specification to behaviors for which appropriate components exist, to derive products of a family to validate a model in terms of its intended systems (where each product is specified by a CCS term), and to manipulate functionalities assigned to products of a product line at the syntactic level.Regarding an equational theory for PL-CCS, our work improves upon [13], where a number of algebraic laws to restructure a product line specification were given. However, we are not aware of any complete axiomatization of PL-CCS to date. For example, the laws of [13] are restricted to families with the same number of variants and exclude intuitive equalities likep⊕iq=q⊕ipandp⊕ip=p. It is worth noting that our notion of configuration bisimilarity is reminiscent of the notion of branching bisimilarity introduced in [16].PL-CCS also comes equipped with a property specification language that is a variant of the multi-valued modal μ-calculus [12]. A configured transition system can also be viewed as a multi-valued modal Kripke structure [12] and hence, formulae in the multi-valued modal μ-calculus can be evaluated naturally in this semantic domain. The corresponding model checking method verifies a family at once, and its result defines the set of products that meet the given property. In this paper, we show that the multi-valued modal μ-calculus of [12] is the logical characterization of our notion of product line bisimilarity (and hence, also our notion of configuration bisimilarity). This provides another evidence of suitability for our main notions of behavioral equivalence.The contributions of this paper can be summarized as follows:•We introduce a means to specify product lines with infinite behavior, following the approach of [17], by extending PL-CCS with recursive specifications.We provide a set of structural rules to derive the configured-transition semantics of PL-CCS directly.We study different notions of bisimilarity over the configured-transition semantics. To this end, we provide a set of intuitive axioms that should be satisfied. We prove different compositionality (congruence) results for the notions of bisimilarity and relate them to each other.We provide a sound axiomatization of PL-CCS terms modulo product line bisimilarity, which additionally allows one to derive any sound equation on closed terms with finite-state behavior (in technical terms, it is a ground-complete axiomatization).We show that the multi-valued modal μ-calculus is the characterizing logic for our product line bisimilarity.The rest of this paper is structured as follows. Section 2 introduces the PL-CCS syntax and semantics. Section 3 defines our notions of behavioral equivalence and relates them. Section 4 provides a set of sound and complete axioms to syntactically manipulate product lines. Section 5 illustrates the applicability of our axiomatization in the analysis of product lines. Section 6 presents the multi-valued modal μ-calculus as well as a logical characterization of product line bisimilarity. Section 7 provides an overview of existing approaches on modeling and verification of SPLs. Finally, Section 8 concludes the paper.To our knowledge, PL-CCS [12,13] is the first process algebra introduced to formally specify and verify product lines in an algebraic manner. To give a semantics to PL-CCS terms in [12,13], the binary variant operators are assigned an index in a pre-processing step. Following the same principle, we index the binary variant operator of PL-CCS with a natural number. This allows for defining a unique semantic model for each PL-CCS term and also specify multiple variation points that should be resolved in the same manner. Moreover, any unnumbered PL-CCS term can be considered an indexed PL-CCS term by assigning arbitrary distinct natural numbers to each and every binary variant operator.To specify product lines with infinite behavior, we extend PL-CCS with the recursion operator〈X|E〉taken from [17]. It encompasses both the CCS recursion operatorrecX.t(which is specified in our syntax as〈X|X=deft〉) and the standard way to express recursion in ACP (where usually only guarded recursion is considered via systems of equations E) [17].LetAbe the set of process names which are used as recursion variables in recursive specifications and ranged over by A and B. Moreover assume that Σ a finite set of input action labels,Σ‾={a‾|a∈Σ}is the set of output actions, andτ∉Σ∪Σ‾the unobservable action. Then, the set of all actions Act is defined asΣ∪Σ‾∪{τ}. By definition, we have thata̿=a.The core syntax of PL-CCS comprises deadlock 0, action prefixa.−(for eacha∈Act), choice +, binary variant⊕iwherei∈N, and parallel composition ∥. It also includes process renaming[f]wheref:Act↦Actis a renaming function withf(a‾)=f(a)‾, andf(τ)=τ, restriction ∖L whereL⊆Act. Additionally, it has process names, and recursion operator〈A|E〉where E is a recursive specification overA, denoted byE(A)for short. A recursive specification is defined by a set of recursive equations that contains precisely one recursive equationA=deftAfor each process nameA∈A, wheretAis a term over the PL-CCS signature and process names fromA. The PL-CCS syntax is summarized by the following grammar:t::=0|a.t|t+t|t⊕it|t∥t|t[f]|t∖L|A|〈A|E〉Process terma.tdenotes a process that first performs action a and then behaves as t. Alternative compositiont1+t2nondeterministically behaves ast1ort2. Variant operator⊕idefines a behavioral variation point. Familyt1⊕it2consists of the two alternative families specified byt1andt2. Binary variant operators⊕i, or variants for short, with identical indices i are resolved in the same manner. PL-CCS terms can be composed using the parallel composition operator ∥. Process termt1∥t2denotes the concurrent execution of two processest1andt2, of which the actions can be interleaved or synchronized whenevert1andt2are ready to execute an input and the corresponding output action simultaneously. The process termt[f]behaves as t, with every action renamed according to the renaming function f. The process termt∖Lcan perform any action that is not included in L. A process name A denotes a specific process, and the recursion operator〈A|E〉represents a solution of the recursive specificationE(A)where A acts as the initial variable. A solution of a recursive specificationE(A)is a set of process terms{sA|A∈A}such that if for allA∈A,sAis substituted for A, the equations of E correspond to equal elements (in the model of our equational theory), i.e.,sA=t{sX/X|X∈A}, whereA=deft∈E. The guardedness criterion for recursive specifications ensures that this solution is unique. As far as unguarded recursions are concerned, following the approach of CCS and ACP [18], we consider the solution that has the least set of transitions. In Section 4, we explain the guardedness criterion. In the remainder of this paper, we use the notions of process term, product line, and family interchangeably.Note that the term defining process name A in a recursive specification may include recursive specifications. A term is called closed, if every process name A occurs in the scope of a binding recursive specificationE(A)such thatA∈A. For instance, in the closed term〈X|{X=defa.0⊕1b.〈Y|{Y=defY+c.X}〉}〉, X is bound by the outer recursive specification. As usual, we use the notationt{s/A}to denote the substitution of a closed term s for every free occurrence of process name A in t. We use〈t|E〉, where E is a recursive specification overA, to denotet{〈A|E〉/A|A∈A}, i.e., t where, for allA∈A, all free occurrences of A in t are replaced by〈A|E〉.By adopting〈A|E〉instead of the CCS recursion operator, we can easily specify SPLs in which a process name definition is shared. For instance,〈p1|{p1=defp2∥p2,p2=defb.0⊕1c.0}〉is equivalent to the CCS notationμX.(μY.b.0⊕1c.0∥μY.b.0⊕1c.0).Index i is called bounded int1⊕it2. The bounded indices of term t, denoted bybi(t), are those that are reachable from the root of its parse tree. We definebi(t)=fbi(t,∅), where the auxiliary function fbi is defined inductively as follows:fbi(0,S)=∅fbi(t∖L,S)=fbi(t,S)fbi(a.t,S)=fbi(t,S)fbi(t[f],S)=fbi(t,S)fbi(t1+t2)=fbi(t1,S)∪fbi(t2,S)fbi(t1∥t2,S)=fbi(t1,S)∪fbi(t2,S)fbi(t1⊕it2,S)={i}∪fbi(t1,S)∪fbi(t2,S)fbi(A,S)=∅fbi(〈A|E∪{A=deft}〉,S)=fbi(〈t|E∪{A=deft}〉,S∪{A}),ifA∉Sfbi(〈A|E∪{A=deft}〉,S)=∅,ifA∈S.An index i is free in t, iff it is not bounded. We denote byt[i/j]the term that is obtained by replacing all⊕jby⊕iin t (we dispense with the inductive definition as it is straightforward).Intuitively, the behavior of a product line family is defined by the cumulative behavior of its products. These products are obtained by resolving the choice in the binary variant operators. The resolution may take place at various points of execution and hence, to record such choices the semantics needs to record whether the choice is unresolved (denoted by ?), resolved in favor of the left-hand-side product (denoted by L), or resolved in favor of the left-hand-side product (denoted by R). Also resolving one instance of a binary variant operator may resolve the choice for other instances. For instance, configuring the variant j as R in(a.0⊕ib.0)⊕jc.0, makes it unnecessary to configure the variant i. Configuration status of variation points bounded in a process term with maximum index n are recorded in a configuration vectorν∈{L,R,?}n, where the ith element of the vector is denoted byν|i. We denote by Config the set of all possible configuration vectors, ranged over by ν and λ. Expressionν|i/xdenotes the result of replacing the ith element of ν byx∈{L,R}. A configuration is called full when all its elements are configured, i.e., are in{L,R}. Two configurations ν and λ that do not have any conflict on a variation point are called consistent. This concept is formalized below.Definition 1Consistent configuration vectors [12]Configuration vectorsν,λ∈{L,R,?}nare consistent, denoted byν≍λ, if and only if∀i∈{1,…,n}:((ν|i=?)∨(λ|i=?)∨(ν|i=λ|i)).Given two consistent configuration vectors ν and λ, their unification, denoted byν⊙λmerges the configurations of their variation points as follows:(ν⊙λ)|i=X∈{L,R,?}iff eitherν|i=X∧λ|i=?orν|i=?∧λ|i=Xorν|i=λ|i=X.Configuration vectorν′is more concrete than ν (or ν is more abstract thanν′), denoted byν⊑ν′, iff∀i∈{1,…,n}:((ν|i=?)∨(ν|i=ν′|i))[12]. Hence, each configuration vector ν represents a set of configuration vectors{ν′|ν⊑ν′}.We briefly explained the three different semantic models of PL-CCS terms in Section 1: the flat semantics, the unfolded semantics, and the configured-transition semantics[12]. Since our equivalence relation and the multi-valued modal μ-calculus are defined over the configured-transition semantics, we next elaborate on how this semantics is derived directly using our structural operational semantics rules.The configured-transition semantics induces an LTS, in which the labels are pairs inAct×Config. Formally, a configured-transition system (CTS) is a tuple〈S,s0,Act×Config,→〉, where S is a set of states,s0∈Sis an initial state and→⊆S×Act×Config×Sis a set of transition relations. The notations→α,νs′is used for(s,(α,ν),s′)∈→and is representative for all transitionss→α,ν′s′, whereν⊑ν′. The CTS semantics of a PL-CCS term t has the set of all terms as its states, t as the initial states, and the least relation satisfying the rules in Fig. 2as its transition relation.The rule Prefix indicates the execution of a prefix action, whereν?denotes a configuration vector in which no element is configured. Choice specifies the non-deterministic behavior of the choice operator in terms of its operands. Res defines that termt∖Lis only allowed to do actions that are not in L. Select defines the behavior of a family in terms of its products, by deciding about the ith variant operator. The side condition prohibits any reconfiguration, if it was previously configured. Call defines the behavior of〈A|E〉in terms of the behavior of the right-hand side of the equationA=deftin the recursive specification E. Par explains that a process in a parallel composition can proceed independently of the other parallel component. Sync states that two processes in a parallel composition can be synchronized on an action, if both are ready to perform input and output counterparts simultaneously. Sincet1andt2resolve variants in their scopes, their resolutions are unified for their parallel composition in Sync. Finally, Rename renames all actions using a function f.The symmetric versions of rules Choice, Select, and Par are also present, but are not given explicitly here for the sake of brevity.Example 2Using the rules in Fig. 2, the configured-transition semantics of〈X|E〉, whereE={X=def(a.(b.X⊕1c.0)+d.0)⊕2e.0}, is given in Fig. 3a. The derivation tree inducing the transition labeled bya,〈?,L〉is given below:Other transitions are derived similarly. On deriving the transitions ofb.〈X|E〉⊕1c.0with the help of Prefix and Select, only the first variant point can be configured, and consequently it returns to state〈X|E〉with the actionb,〈L,?〉or state 0 with the actionc,〈R,?〉, as shown in Fig. 3a.Returning to state〈X|E〉in Example 2, makes it possible to reconfigure any previously configured variant. For the sake of compositionality, resolutions of variants are open to any possible configuration in our SOS rules. However, as it is explained in the next paragraph and Section 3.1, in deriving the behavior of a product/a set of related products only consistent resolutions are followed.The semantic model of each product of t, identified by the full configurationνf, can be derived by removing the transitions from t whose configuration vector is not consistent withνf. LetΠ(t,νf)denote the resulting LTS. Formally speaking,Π(t,νf)→aΠ(t′,νf)ifft→a,νt′andν⊑νf. Therefore, only resolutions that are consistent with the full configuration, i.e.,ν⊑νf, are allowed and consequently reconfiguration is prohibited. See Fig. 3b, 3c, 3d, and 3e for the semantic models of products derived from X for the given configuration vectors〈L,L〉,〈R,L〉,〈L,R〉, and〈R,R〉respectively (initial states are highlighted in gray). It should be noted that the semantic models derived for the configuration vectors〈L,R〉and〈R,R〉have only one reachable state from the initial state through the action e.Following the approach of ACP [18], we define a set of axioms (as the main part of our process theory or equational theory) as primary and then investigate the models that they have. The most intuitive model of a process theory is the term algebra (the algebra with the same operators of equational theory) modulo a congruence. In this section, we first discuss about different notions of equivalence relation to reason about product lines. Next, we discuss about the congruence property of the previously defined relations.Table 1summarizes the axioms we have in mind for PL-CCS. We look for an appropriate notion of bisimilarity that supports the given equations. AxiomsA1−3define commutativity, associativity and idempotency for the binary variant operator. AxiomsA1,2ensure that two families are equivalent when they produce the same set of products, irrespective of their orders in variant operators. However, their application is restricted: i should be free in p and q forA1, while i should be free in r and j should be free in p forA2. For instance,a.0⊕1(b.0⊕1c.0)produces two productsa.0andc.0, but(b.0⊕1c.0)⊕1a.0producesa.0andb.0, and consequently, as expected they are not equivalent. AxiomA3removes a repeated product from a family, and implies that two product families are equivalent iff they produce similar products, irrespective of their multiplicity. AxiomA4defines distributivity for prefix over binary variant, while axiomsA5,6define distributivity for choice over binary variant. These rules allow for postponing the product selection by factorizing the common initial action/behavior respectively. AxiomsD1,2define distributivity for parallel over binary variant. These two axioms reveal the difference between alternative choice and binary variant. AxiomsA5,6andD1,2are useful to reduce redundancy by factorizing common parts.Strong bisimulation [15] is very efficient to check and affords a neat theory: many other notions in the branching spectrum can be reduced to it by adding a standard set of axioms [19]. An LTS over a set of labels L is defined by〈S,s0,L,→〉, where S is a set of states,s0∈Sis an initial state, and→⊆S×L×Sis a set of transitions. The notations→atis used for(s,a,t)∈→. We typically identify LTSs with their initial states. Intuitively two labeled transition systems are equivalent, if they produce the same set of actions (observable behavior) and have the same branching structure:Definition 3Strong bisimulationTwo LTSs s and t are strongly bisimilar, notations∼t, iff there is a strong bisimulation relationRover their states such that:•(s,t)∈R, andfor each pair(s′,t′)∈R:–∀s″⋅s′→αs″⇒∃t″⋅t′→αt″and(s″,t″)∈R, and∀t″⋅t′→αt″⇒∃s″⋅s′→αs″and(s″,t″)∈R.Definition 3 can be readily used for CTSs (since CTSs can be considered LTSs with a structure on the set of labels L). However, this simple adoption of Definition 3 can lead to some counter-intuitive observations.For example, according to this definition,a.0+b.0is strongly bisimilar toa.0⊕1b.0. However, these two processes should not be considered equivalent intuitively. The familya.0+b.0produces one product which has a non-deterministic behavior in performing actions a and b. By contrast, the familya.0⊕1b.0produces two products, namelya.0andb.0, and each product has deterministic behavior by performing solely a or solely b. As another concern, this relation cannot identifya.(b.0⊕1c.0)anda.b.0⊕1a.c.0, while both have two productsa.b.0anda.c.0; consequently, this bisimulation relation does not support axiomA4. Therefore, the appropriate notion of bisimilarity over families must relate any product in one family to a product in the other such that their behaviors are strongly bisimilar.A full configuration is called valid with respect to term t, if its length is not less than the maximum index inbi(t). For instance,〈L〉is not valid forb.〈X|E〉⊕1c.0, whereE={(a.(b.X⊕1c.0)+d.0)⊕2e.0}, while〈L,?,L〉is valid. LetVFConfig(t)denote the set of all valid full configurations with respect to t. Intuitively, two product families are equivalent when they produce bisimilar sets of products:Definition 4Strict strong bisimulationTwo product line terms s and t are strictly strongly bisimilar, denoted bys≈PLt, iff for any valid full configurationνf∈VFConfig(s)∩VFConfig(t),Π(s,νf)∼Π(t,νf).However, strict strong bisimilarity does not support axiomsA1,2; to see this, observe thatΠ(a.0⊕1b.0,〈L〉)≁Π(b.0⊕1a.0,〈L〉),Π((a.0⊕1b.0)⊕2c.0,〈L,R〉)≁Π(a.0⊕1(b.0⊕2c.0),〈L,R〉)andΠ((a.0⊕2b.0)⊕1c.0,〈R,L〉)≁Π(a.0⊕2(b.0⊕1c.0),〈R,L〉). However, axiomA3is supported by strict strong bisimilarity, e.g.,(a.0⊕1b.0)⊕2(a.0⊕1b.0)≈PLa.0⊕1b.0since for anyνf∈{〈L,R〉,〈L,L〉,〈R,R〉,〈R,L〉},Π((a.0⊕1b.0)⊕2(a.0⊕1b.0),νf)∼Π(a.0⊕1b.0,νf).To make Definition 4 be insensitive to the placement of families in a binary variant composition, and consequently to support axiomsA1,2, the notion of bisimulation can be revised as follows.Definition 5Product line bisimulationTwo product line terms s and t are product line bisimilar, denoted bys≃PLt, if and only if:•∀ν1f∈VFConfig(s)⋅∃ν2f∈VFConfig(t)⋅Π(s,ν1f)∼Π(t,ν2f), and∀ν2f∈VFConfig(t)⋅∃ν1f∈VFConfig(s)⋅Π(s,ν1f)∼Π(t,ν2f).Theorem 6Product line bisimilarity is an equivalence relation.See Appendix A for the proof. Confining the behaviors of two CTSs into full configurations disallows any reconfiguration of variants whose resolutions are left open in the semantic models (as it was explained in Section 2.2).Matching each and every valid full configuration in the product line bisimilarity is very tedious. This process may require examining all possible pairs of configurations to find a suitable match. (Yet it does eventually reduce to checking strong bisimilarity for a large number of finite-state behaviors, which is decidable [20].) Hence, it would be appealing to have an appropriate notion of bisimilarity that decides the equivalence of PL-CCS terms at once (without considering all full configurations individually). We provide such a relation, called configuration bisimulation next and prove that it coincides with product line bisimilarity. Therefore, all the results for product line bisimilarity also hold for configuration bisimilarity. Also, to facilitate reasoning about product lines and also establish an algebraic theory for product line processes, we provide a sound and complete axiomatization for product line and configuration bisimilarity. Using this axiomatization, a term can be restructured at the syntactic level to its equivalent terms without the need to generate and compare the state spaces. In the process of providing a sound and complete axiomatization, we use product line bisimilarity which makes our proofs much simpler.First, we define the notion of configuration inspired by [16]. As a first step, we would like to classify the transitions in terms of their configuration vectors; all transitions with consistent configurations are called a consistent transition set and they can potentially belong to a family. Subsequently, we define a bisimulation relation that relates states in terms of their consistent transition sets. In other words, it is required to relate not only states, but also their consistent transition sets. Consider Fig. 4, which illustrates this by an example. The terms in this figure are not product line bisimilar, as the left one consists of four (behaviorally different) products while the right one consists of two. However, a notion of bisimulation that only considers consistent transition sets in each state (as shown in Fig. 4) cannot distinguish them. The consistent transition set{(d,〈L,?〉),(a,〈?,?〉)}can be enabled together for a product/family. For instance, consider the productd.0+a.c.0, which is identified by the full configuration〈L,R〉in the left CTS. It is derived from the consistent transition sets highlighted in Fig. 4. These consistent transition sets are matched to the corresponding sets in the right CTS. However, the matched sets do not belong to a family, and consequently cannot specify a product. The reason stems from the related statesb.0⊕2c.0andb.0. Stateb.0⊕2c.0is reachable by the consistent transition set{(d,〈L,?〉),(a,〈?,?〉)}for two products (i.e.,{〈L,R〉,〈L,L〉}). Therefore, its consistent transition set{(c,〈?,R〉)}is enabled for product〈L,R〉. However, its related stateb.0is only reachable for one product, which does not generate a matching consistent transition set. To summarize, we need to note for which family a state is reachable in order to match its enabled consistent transition sets with respect to that family. Furthermore, this book-keeping family disallows any reconfiguration of variants which have been previously resolved.A partitioning of a configuration vector ν consists of configuration vectorsν1,⋯,νnsuch that∀i,j≤n⋅((i≠j)⇒νi≭νj), and∀νf⋅(ν⊑νf⇒∃j≤n⋅(νj⊑νf)). For instance,{〈?,L〉,〈L,R〉,〈R,R〉}is a partitioning of〈?,?〉. A partitioning of ν, denoted bypν, regards configurations over transitions of s, denoted byPar(s,ν,pν), if and only if∀ν1∈pν⇒∃α,ν1′,s′(s→α,ν1′s′∧ν1′⊑ν1)∨∄α,ν1′,s′(s→α,ν1′s′∧ν1′≍ν1). Transitions of s whose configurations are more abstract thanν∈pν1, wherePar(s,ν1,pν1), constitute a consistent transition set. Assume s and t are related for familiesν1andν2, respectively. In the below-defined notion of configuration bisimulation, we match consistent transition sets of s defined bypν1, wherePar(s,ν1,pν1), to consistent transition sets of t defined bypν2, wherePar(t,ν2,pν2).Definition 7Configuration bisimulationA class of binary relationsRν1,ν2⊆S×S, whereν1,ν2∈Config, is a configuration simulation relation if and only if for eachs,t∈Ssuch that(s,t)∈Rν1,ν2, there existspν1andpν2, wherePar(s,ν1,pν1)andPar(t,ν2,pν2)such that for anyν1′∈pν1, there existsν2′∈pν2and:•s→α,ν1″s′andν1″⊑ν1′⇒∃t′,ν2″⋅t→α,ν2″t′,ν2″⊑ν2′, and(s′,t′)∈Rν1′,ν2′;t→α,ν2″t′andν2″⊑ν2′⇒∃s′,ν1″⋅s→α,ν1″s′,ν1″⊑ν1′, and(s′,t′)∈Rν1′,ν2′.For instance,a.(b.0⊕1c.0)≃Ca.c.0⊕1a.b.0is witnessed by the configuration bisimulation relationsR〈?〉,〈?〉={(a.(b.0⊕1c.0),a.c.0⊕1a.b.0)},R〈R〉,〈L〉={(b.0⊕1c.0,c.0),(0,0)},R〈L〉,〈R〉={(b.0⊕1c.0,b.0),(0,0)}. Howevera.(b.0⊕10)≄Ca.b.0as the only partitioning of〈?〉regarding the state transitions ofb.0⊕10is{〈R〉,〈L〉}and then the behaviorb.0⊕10for family〈R〉cannot be matched to any behavior ofa.b.0.Theorem 8For any PL-CCS s and t,s≃PLt⇔s≃Ct.We assumes≃PLt, we show thats≃Ct. For all valid full configurationsν1f∈VFConfig(s)andν2f∈VFConfig(t), constructRν1f,ν2fas:Rν1f,ν2f={(s′,t′)|Π(s,ν1f)∼Π(t,ν2f)witnessed byR′∧(Π(s′,ν1f),Π(t′,ν2f))∈R′}It is easy to check that R is a configuration bisimulation relation.We assumes≃Ctis witnessed by the class of configuration bisimulation relationsRν1,ν2, whereν1,ν2∈Config, we show thats≃PLt. To this aim, for anyν1f∈VFConfig(s), we findν2f∈VFConfig(t)such thatΠ(s,ν1f)∼Π(t,ν2f)and vice versa. LetB={ν2|(s′,t′)∈Rν1,ν2∧ν1⊑ν1f}. Chooseb∈Bsuch that∄ν∈B∖{b}⋅b⊑ν. Take a configurationν2fsuch thatb⊑ν2f. It is trivial thatR′={(Π(s′,ν1f),Π(t′,ν2f))|(s′,t′)∈Rν1,ν2∧ν1⊑ν1f∧ν2⊑ν2f}is a strong bisimulation witnessingΠ(s,ν1f)∼Π(t,ν2f).  □Partitioning each family and then matching its consistent transition sets is very complex and may need to examine all possible partitionings to find a suitable match. Since product line and configuration bisimilarity coincide, with the aim to provide a sound and complete axiomatization, we use product line bisimilarity which makes our proofs much simpler. Therefore, all results for product line bisimilarity also hold for configuration bisimilarity.In this section, we study the congruence property of strict and product line bisimulation relations, and provide a syntactic restriction over PL-CCS terms that makes product line bisimilarity a congruence with respect to the PL-CCS operators.Strict strong bisimilarity is a congruence for PL-CCS terms. For instance,〈p2′|{p2′=defb.0⊕1c.0}〉≈PLb.0⊕1c.0, induces that〈p2′|{p2′=defb.0⊕1c.0}〉∥〈p2′|{p2′=defb.0⊕1c.0}〉≈PL(b.0⊕1c.0)∥(b.0⊕1c.0).Theorem 9Strict strong bisimilarity is an equivalence and a congruence for the PL-CCS term algebra.See Appendix A for the proof.The case for product line bisimulation is a bit more intricate. To illustrate the involved issues, observe that(d.0⊕1e.0)∥(b.0⊕1c.0)≄PL(d.0⊕1e.0)∥(c.0⊕1b.0), whileb.0⊕1c.0≃PLc.0⊕1b.0. The reason is that the configurations〈R〉and〈L〉ofb.0⊕1c.0are matched to the configurations〈L〉and〈R〉ofc.0⊕1b.0respectively, but each pair of matched configurations chooses a different product ind.0⊕1e.0. However,(d.0⊕1e.0)⊕2(b.0⊕1c.0)≃PL(d.0⊕1e.0)⊕2(c.0⊕1b.0), since⊕2makes the configurations of its operands independent of each other. To guarantee congruence for product line bisimilarity, we impose a constraint on the PL-CCS syntax. In(d.0⊕1e.0)∥(b.0⊕1c.0), there are two binary variants indexed by 1. Hence, once one resolves the choice betweend.0ande.0, the same choice has to made betweenb.0andc.0. We call a product line fully expanded when all its variants can be configured independently from the configuration of other variation points.This constraint was first introduced in [12] with the different intention of compositionality for their structural rules. We revise their definition to enforce that different binary variant choices can be made independent of each other. To formally define a fully expanded term, we use its term-dependency graph which is a directed labeled graph. Its construction for a term t is explained on the term(a.〈Y|E〉+e.0)∥〈Z|E〉, whereE={Y=defb.0⊕1c.Z,Z=defc.Z⊕2d.Y}. Its nodes comprise the nodes of the parse tree of t together with additional nodes labeled〈Ai|Ei〉andEi(i.e., the gray and the white nodes in Fig. 5, respectively). Its edges comprise the edges of the parse tree of t (i.e., the thick solid edges in Fig. 5) plus edges connecting〈Ai|Ei〉to the node labeledAiin the term-dependency graph ofEi(i.e., the dashed edges in Fig. 5), and the edges of recursive specificationsEi. The term-dependency graph ofEi(Ai)consists of nodes labeledAifor eachAi∈Ai, together with the nodes of the parse trees for termtifor eachAi=defti∈Ei. Its edges comprise the edges of the parse trees (i.e., the thin solid edges in Fig. 5) plus the edges connectingAito the roots of the parse trees of the corresponding right-hand sides, i.e.,ti(i.e., the thick dashed edges in Fig. 5). Additionally, we add edges from leaves of the parse trees labeledAito the node labeled withAiin its binding recursive specification (i.e., the dotted edges in Fig. 5).Definition 10Fully expanded termsA PL-CCS term is fully expanded if and only if in its term-dependency graph, for each two distinct simple paths starting at an arbitrary common node and ending at (common or distinct) nodes labeled with⊕i, they have both passed through a common node that is labeled with⊕j, for somej≠i.Recall that a simple path is a path in a graph which does not have repeating vertices. This constraint rules out systems such as〈p1|{p1=defp2∥p2,p2=defb.0⊕1c.0}〉, since the parallel composition in the equation ofp1has two simple paths to⊕1. However, these paths do not pass through a node labeled with⊕j,j≠1, beforehand. Nevertheless, it accepts systems such as〈p4|{p4=def(p2⊕2p2)∥(b.0⊕3c.0),p2=defb.0⊕1c.0}〉, since all simple paths of the parallel composition in the equationp4to⊕1have already passed through⊕2, as shown in Fig. 6. The same holds for simple paths of the node labeled withp4. Such systems were not accepted by the Definition given in [12]. The term-dependency graph of Fig. 5 satisfies the condition of Definition 10.Theorem 11Product line bisimilarity is a congruence on the fully expanded PL-CCS term algebra.See Appendix A for the proof. Restricting to fully expanded PL-CCS terms is not important in practice (when terms are manipulated at the syntactic level), since a term can be rewritten using our axioms supported by strict strong bisimilarity into a fully expanded form (see Theorem 12 in Section 4.2). Note that the side condition of axiomA2guarantees that a fully expanded term remains fully expanded after being restructured by this axiom. For instance, although(a.0⊕1b.0)⊕2(c.0⊕1d.0)is fully expanded,a.0⊕1(b.0⊕2(c.0⊕1d.0))is not.We extend the axioms given in Section 3 to reason about parallel, recursive behaviors with finite-state models, and indexed binary variants. To axiomatize the interleaving behavior of parallel composition and terms with variants with an identical index, we extend the PL-CCS syntax and semantics with new operators in Section 4.1.We provide PL-CCS axioms that are sound with respect to product line bisimilarity in Section 4.2. Furthermore, we identify those that are also valid with respect to strict strong bisimilarity. Our axiomatization in Table 2subsumes standard axioms of CCS for choice operator (C1−4,R1−4,E1−4), axioms of ACP corresponding to the well-known elimination theorem [21] (P1−3,5,6andS1,2,4−6), and axioms of CCS to reason about recursive behaviors [22] (Fold, UnFold, and Ung). We explain that a term can be manipulated using axioms supported by strict strong bisimilarity (without changing the order of operands in binary variants) to be rewritten into a fully expanded form, and then manipulated with all axioms valid for product line bisimilarity. We prove ground-completeness (completeness over closed terms) of our axiomatization for a subset of PL-CCS terms, namely, those with finite-state behaviors in Section 4.3.Our axiomatization borrows from the process algebra ACP[23] two auxiliary operators (left merge and communication merge) to axiomatize the interleaving and the synchronizing behavior of parallel composition, respectively. Furthermore, we extend the process theory with two new sets of indexed operators (left and right selector), to restrict the behavior of a term regarding configuration of the variant indexed by that number.In the left merge compositiont1t2, the left operand (t1) performs an action and then continues in parallel witht2. In the communication merget1|t2, both operands are synchronized on their initial actions and then continue in parallel composition. The left selector operatorL(t,i)makes all variants indexed by i be configured as left. Therefore, it only allows behaviors whose configurations on the variant indexed by i are consistent with left. The right selector operatorR(t,i)behaves symmetrically. The structural operational semantics rules of operators to derive CTSs are given in Fig. 7.We proceed to complete the axiomatization of PL-CCS modulo product line bisimilarity. The axioms are given in Table 2. AxiomsC1−4define commutativity, associativity, idempotence, and unit element for the choice operator.AxiomP1defines the parallel composition of two families in an interleaving semantics, as in the process algebra ACP[23]; AxiomP2explains the behavior of the left merge operator in terms of its left operand, if it can do an action. However, if it cannot do any action, the result is a deadlock, as explained byP6. AxiomsP3,4define left-distributivity of choice and binary variant over the left merge operator, respectively. AxiomP5defines right-distributivity of binary variant over the left merge operator. AxiomS1defines the commutativity property for the communication merge operator. AxiomsS2,3(together withS1) define distributivity of choice and binary variant over the communication merge operator respectively. AxiomsS4,5,6define the behavior of communication merge operator; when the operands are ready to do matched input and output communication actions, they can be synchronized and the result of their synchronization is the unobservable action τ as explained byS4. However, if either they are not matched (S5) or one of the operands cannot do any action (S6), the result is a deadlock.AxiomsR1,4andE1,2,4define the behavior of renaming and restriction operators respectively. AxiomsR2,3andE3,5define distributivity of choice and binary variant over the renaming and restriction operators, respectively.Axiom Dec decomposes a recursive specification E made up of multiple (finitely-many) equations into several nested recursive specifications made up of a single equation. Axiom UnFold expresses the existence of a solution for any recursive specification E: the constant〈A|E〉is a solution of the recursive specification E. Fold expresses uniqueness of a solution for a guarded recursive specification: if y is a solution for A in E, and E is guarded, theny=〈A|E〉. Note that UnFold and Fold correspond to the Recursive Definition Principle (RDP) and Recursive Specification Principle (RSP) in ACP. An occurrence of a process name A in t is called guarded, if and only if this occurrence is in the scope of an action prefix operator. A recursive specification is called guarded, if and only if all occurrences of all its process names in the right-hand sides of all its equations are guarded, or it can be rewritten to such a recursive specification using the axioms of the theory and the equations of the specification [17]. This guardedness criterion ensures that any product line has a unique solution. Axiom Ung makes it possible to turn the unguarded recursive specification{A=defA+t}into a guarded one. Axiom Dri derives the products of a recursive specification: the solution of a recursive specification〈A|{A=deft1⊕it2}〉is〈A|{A=deft1}〉⊕i〈A|{A=deft2}〉. Axioms UnFold, Fold, and Ung are standard for CCS terms (with finite state behaviors modulo branching bisimulation) [22].AxiomsN1−5handle binary variants with an identical index. Whenever the left (right) operand is selected inp⊕iq, then all i-indexed variants in p (q), should select their left (right) operands accordingly. AxiomN5removes all occurrences of⊕iat the root ofp⊕iqin operands p and q. In other words, with the help ofN1−5, the occurrence of i in subtrees ofp⊕iqbecomes unique. For instance, consider the product line〈X|{X=defb.X⊕1a.0}〉, with two products〈X|{X=defb.X}〉and〈X|{X=defa.0}〉obtained using axiom Dri. However, by applying axiom UnFold and substituting of X with its defining term, one can derive〈X|{X=defb.X⊕1a.0}〉=(b.(〈X|{X=defb.X⊕1a.0}〉)⊕1a.0)=b.(〈X|{X=defb.X}〉⊕1〈X|{X=defa.0}〉)⊕1a.0. By axiomsA4andN1,5,b.(〈X|{X=defb.X}〉⊕1〈X|{X=defa.0}〉)⊕1a.0is reduced tob.〈X|{X=defb.X}〉⊕1a.0, which derives two productsb.〈X|{X=defb.X}〉anda.0(that are strongly bisimilar to the products of〈X|{X=defb.X⊕1a.0}〉). AxiomN6changes the index of a binary variant term. For example,(a.0⊕1b.0)⊕2(c.0⊕1d.0)=(a.0⊕1b.0)⊕2(c.0⊕3d.0). Consequently, axiomA2can be applied, resulting(a.0⊕1b.0)⊕2(c.0⊕1d.0)=a.0⊕1(b.0⊕2(c.0⊕3d.0)).It should be noted thatt≈PLsimpliest≃PLs. All axioms, except forA1,2andN6, are supported by strict strong bisimilarity. Generally speaking, to manipulate a PL-CCS term, as stated in Theorem 12, first it can be converted into a fully expanded form with the help of axioms supported by strict strong bisimilarity, and then manipulated with all axioms.Theorem 12Any PL-CCS term t can be rewritten by axiomsA4−6,D1,2,P4,5,S1,3,R3,E5, Dri, andN1−5into a form that is fully expanded.See Appendix B for the proof. With the help of axiomsA4−6,P4,5,S1,3,R3,E5, and Dri, one can convert a PL-CCS term into a term such that its binary variants do not occur in the scope of any CCS operators. Then, by axiomsN1−5, the term becomes fully expanded. Therefore, it can be manipulated using all the axioms. The soundness of derivations, when the order of binary variants operands are fixed, follows from Theorem 9, and when terms are fully expanded, follows from Theorem 11.Theorem 13SoundnessThe axiomatization, given inTables 1 and 2, is sound for the term algebraP(PL-CCS)/≃PL, i.e., for all closed PL-CCS termst1andt2,t1=t2impliest1≃PLt2.See Appendix C for the proof.Example 14AxiomsD1,2in Table 1 can be derived from the other remaining axioms. The derivation forD1is:r∥(p⊕iq)=P1r(p⊕iq)+(p⊕iq)r+r|(p⊕iq)=P4,5,S2,3(rp⊕irq)+(pr⊕iqr)+(r|p⊕ir|q)=A5,6(((rp+pr+r|p)⊕i(rp+pr+r|q))⊕i((rp+qr+r|p)⊕i(rp+qr+r|q)))⊕i(((rq+pr+r|p)⊕i(rq+pr+r|q))⊕i((rq+qr+r|p)⊕i(rq+qr+r|q)))=N1,3,5(rp+pr+r|q)⊕i(rq+qr+r|q)=P1(r∥p)⊕i(r∥q).In [13], a set of algebraic laws was provided includingA4,A6,D1, and Dri. Their algebraic laws are sensitive to the numbering of variants and the placement of their operands. Therefore, the laws do not support idempotence and commutativity properties of the binary variant (axiomsA1,3). By prohibiting application of axiomsA1,2andN6while removing variants with an identical index with the help of axiomsN1−5, we can rewrite a term into a fully expanded one. Subsequently, with the help of axiomsA1,2andN6, our axiomatization becomes insensitive to the placement of operands in binary variants or binary variant indices.We prove that the axiomatization in Tables 1 and 2 is ground-complete for PL-CCS terms with finite-state models modulo product line bisimilarity. Following the approach of [17], to restrict to PL-CCS terms with finite-state transition systems, we provide a syntactical restriction for constants〈A|E〉. We consider so-called finite-state PL-CCS, denoted byPL-CCSf, which is obtained by extending PL-CCS with essentially finite-state recursive specifications: a recursive specification E is essentially finite-state, if it has only finitely many equations and in the right-hand sides of all equations of E, no process name occurs in the scope of static operators, namely, parallel composition, left- and communication merge, restriction, and renaming operators.For instance, PL-CCS term〈Y|{Y=def(a.0⊕1b.0)∥c.Y}〉is not a finite-state PL-CCS process. To see this, observe that it can derive the sequence of transitions〈Y|{Y=def(a.0⊕1b.0)∥c.Y}〉→c,〈?〉(a.0⊕1b.0)∥〈Y|{Y=def(a.0⊕1b.0)∥c.Y}〉→c〈?〉(a.0⊕1b.0)∥(a.0⊕1b.0)∥〈Y|{Y=def(a.0⊕1b.0)∥c.Y}〉→c,〈?〉…, which leads to an infinite state space. This sequence results from the occurrence of process name Y in the context of a parallel composition.Proposition 15Finite-state behaviorsConsider aPL-CCSfterm t; the transition system for t generated by the operational rules has only finitely many states.This Proposition can be proved by resolving the binary variants, which are finite. Therefore, a finite set of CCS terms are derived such that each CCS term generates finitely many states [22].Theorem 16CompletenessThe axiomatization, given inTables 1 and 2is ground-complete for the term algebraP(PL-CCSf)/≃PL, i.e., for all closed finite-statePL-CCSftermst1andt2,t1≃PLt2impliest1=t2.See Appendix D for the proof.The advantage of our sound and complete axiomatization is that we can prove equality of PL-CCS terms at a syntactic level by transforming one term to another. Hence, one does not need to generate the huge state space, which was required to check the notions of bisimilarity introduced in Section 3. This process can be facilitated and mechanized with the help of theorem provers, or term rewriting systems. Consequently, terms can be transformed by our axiomatization into a basic form, such as linear process specifications in the mCRL2 language [24,25], over which different analyses can be performed, either manually or using tools. This basic form acts as a symbolic representation of the state space of a model, which is comparatively small. A set of tools such as model checker, state space visualizer, and behavioral simulator exist that run over this basic representation and can be adapted to our setting. Furthermore, a number of optimization approaches such as τ-confluence reduction [26], that work on the level of this basic format, can simplify it prior to any analysis. The transformation process into a basic form can be mechanized in the same way as [27] within a small amount of time. Similarly, PL-CCS terms can be reduced to their possible products (which are simple CCS terms) in a syntactic way to be validated in terms of their intended properties.A formal framework for modeling and analyzing SPLs should support modular design, derivation (configuration) of individual systems from a product line model, and restructuring them into various syntactic forms [13]. Our process theory supports them all. In our case, we support a few different forms of restructuring: for example, we support “moving variation points throughout the hierarchical specification of an SPL towards its leaves or its root” [13]. We also support “modeling individual systems using a higher or lower degree of common parts” [13]. Therefore, a designer can model the functionality of an SPL irrespective of the existing components. Later with the aim of reuse, the functionality can be restructured to behaviors for which appropriate components exist. A restructuring mechanism is also appealing when a new functionality (which corresponds to a new feature) is added. We illustrate how our framework supports deriving products or restructuring of SPLs in following sections.Using our axiomatization, one can derive the products of a family, i.e., rewrite a process term into a term which comprises binary variants of CCS terms.Example 17For instance, consider CCS terms p, q, and s (which naturally do not contain the binary variant operator); the family(q⊕1(a.(s⊕2p)))⊕3a.scan generate three pairwise non-bisimilar products:(q⊕1(a.(s⊕2p)))⊕3a.s=A2q⊕1((a.(s⊕2p))⊕3a.s)=A4q⊕1((a.s⊕2a.p)⊕3a.s)=A1q⊕1((a.p⊕2a.s)⊕3a.s)=A2q⊕1(a.p⊕2(a.s⊕3a.s))=A3q⊕1(a.p⊕2a.s)Example 18We can compare product lines〈p1|{p1=defp2∥p2,p2=defb.0⊕1c.0}〉and〈p1′|{p1′=defb.0⊕1c.0∥b.0⊕2c.0}〉.p1generates two non-bisimilar products, whilep1′generates three pairwise non-bisimilar products, concludingp1≠p1′. To see this, observe the following derivations:p1=UnFold〈p2|{p1=defp2∥p2,p2=defb.0⊕1c.0}〉∥〈p2|{p1=defp2∥p2,p2=defb.0⊕1c.0}〉=UnFold(b.0⊕1c.0)∥(b.0⊕1c.0)=P1,C3((b.0⊕1c.0)(b.0⊕1c.0))+((b.0⊕1c.0)|(b.0⊕1c.0))=P4,5,S3((b.0b.0⊕1c.0b.0)⊕1(b.0c.0⊕1c.0c.0))+((b.0|b.0⊕1c.0|b.0)⊕1(b.0|c.0⊕1c.0|c.0))=N1,3,5(b.0b.0)⊕1(c.0c.0)+(b.0|b.0)⊕1(c.0|c.0)=P2,S5,C3,4b.(0∥b.0)⊕1c.(0∥c.0)=P1,6,S6b.b.0⊕1c.c.0p1′=UnFold(b.0⊕1c.0)∥(b.0⊕2c.0)=D1,2((b.0∥b.0)⊕2(b.0∥c.0))⊕1((c.0∥b.0)⊕2(c.0∥c.0))=P1,6,S6(b.b.0⊕2(b.c.0+c.b.0))⊕1((c.b.0+b.c.0)⊕2c.c.0)=A1−3,C1b.b.0⊕1((b.c.0+c.b.0)⊕2c.c.0)Next, we show that every PL-CCS term can be rewritten into a normal form comprising binary choices over CCS products.Theorem 19Let⨁i≤npidenote(p0⊕1(p1⊕2(…⊕npn)…))ifn>0, andp0ifn=0. Using the axiomatization inTables 1 and 2, each PL-CCS term t can be rewritten into the form⨁i≤npi, wherepis are CCS processes.See Appendix B for the proof. With the help of axiomsA4−6,D1,2,P4,5,S1,3,R3,E5, and Dri, one can convert a PL-CCS term into another term such that its binary variants do not occur in scope of any CCS operators. Later by axiomN1−6, the indices of variants become unique. Therefore, byA1,2, it can be rewritten into the desired format.With the help of our axiomatization, we can factorize the common parts and simplify the structure of product line terms. We can also identify the mandatory parts of a product line; the parts that exist in any product.Example 20Consider a Sensor process that is replicated in different parts of a car windscreen WindScreen, such as wiper WipFam and fog remover FogFam[12]:WindScreen=defWipFam⊕1FogFamWipFam=defSensor∥WiperFogFam=defSensor∥FogRemwhere Sensor detects the different conditions of precipitation, Wiper and FogRem offer different operational modes for wiper arm movement, and windscreen warmer concerning environmental conditions, respectively. Using our axioms, WindScreen specification is restructured as follows:WindScreen=defWipFam⊕1FogFam=UnFold(Sensor∥Wiper)⊕1(Sensor∥FogRem)=D1Sensor∥(Wiper⊕1FogRem)The new specification for WindScreen reveals that Sensor is the mandatory part of our windscreen family. The structural specification (i.e., the architecture) of WindScreen consists of two components, a Sensor and a component, which can be either Wiper or FogRem.Assume that the Sensor has two qualities, namely, high and low. The low quality sensor cannot distinguish between heavy and little rain (specified by hvy and ltl actions) and can only discriminate between no rain and rain[12]. The high quality sensor can, however, make such distinctions as specified below:Sensor=defSensL⊕2SensHSensL=defnon.SensL+ltl.Raining+hvy.Raining+noRain‾.SensLRaining=defnon.SensL+ltl.Raining+hvy.Raining+rain‾.RainingSensH=defnon.SensH+ltl.Medium+hvy.Heavy+noRain‾.SensHMedium=defnon.SensH+ltl.Medium+hvy.Heavy+rain‾.MediumHeavy=defnon.SensH+ltl.Medium+hvy.Heavy+hvyRain‾.HeavyThe specification of Sensor can be similarly examined to reveal the common behaviors. To this aim, we first restructureSensL⊕2SensHto factor out the common behaviors:SensL⊕2SensH=UnFold(non.SensL+ltl.Raining+hvy.Raining+noRain‾.SensL)⊕2(non.SensH+ltl.Medium+hvy.Heavy+noRain‾.SensL)=N1,3,5((non.SensL+ltl.Raining+hvy.Raining+noRain‾.SensL)⊕2(non.SensH+ltl.Raining+hvy.Raining+noRain‾.SensL))⊕2((non.SensL+ltl.Medium+hvy.Heavy+noRain‾.SensH)⊕2(non.SensH+ltl.Medium+hvy.Heavy+noRain‾.SensH))=A4,5(non.(SensL⊕2SensH)+ltl.Raining+hvy.Raining+noRain‾.SensL)⊕2(non.(SensL⊕2SensH)+ltl.Medium+hvy.Heavy+noRain‾.SensH)=UnFold(non.Sensor+ltl.Raining+hvy.Raining+noRain‾.SensL)⊕2(non.Sensor+ltl.Medium+hvy.Heavy+noRain‾.SensH)=N1,3,5,A4,5non.Sensor+ltl.(Raining⊕2Medium)+hvy.(Raining⊕2Heavy)+noRain‾.SensorSimilarlyRaining⊕2MediumandRaining⊕2Heavycan be examined:Raining⊕2Medium=UnFold,N1,3,5,A4,5non.(SensL⊕2SensH)+ltl.(Raining⊕2Medium)+hvy.(Raining⊕2Heavy)+rain‾.(Raining⊕2Medium)Raining⊕2Heavy=UnFold,N1,3,5,A4,5non.(SensL⊕2SensH)+ltl.(Raining⊕2Medium)+hvy.(Raining⊕2Heavy)+(rain‾.(Raining⊕2Heavy)⊕2hvyRain‾.(Raining⊕2Heavy))By applying Fold, the new specification of Sensor is obtained as follows:Sensor=defnon.Sensor+ltl.RainMed+hvy.RainHvy+noRain‾.SensorRainMed=defnon.Sensor+ltl.RainMed+hvy.RainHvy+rain‾.RainMedRainHvy=defnon.Sensor+ltl.RainMed+hvy.RainHvy+(rain‾.RainHvy⊕2hvyRain‾.RainHvy)The new specification explains that resolving variability between SensL and SensH can be postponed until the variability between performing output actionsrain‾andhvyRain‾is resolved in case it is possible to have heavy rain.In [28], PL-CCS was compared with FTS in addressing variability via modeling the above-mentioned example. There, it was concluded that modeling in PL-CCS can result in verbose descriptions since common parts have to be duplicated [29]. However, in our experience, PL-CCS facilitates modular design without forcing the designer to factor out common parts. Later the specification can be restructured as illustrated by the above-given example. For instance, actions non, ltl, hvy, andnoRain‾are common among SensL and SensR, while their behaviors does not change after performing actions non andnoRain‾. Such common actions and behaviors are factored our by rewritingSensL⊕2SensRtonon.Sensor+ltl.(Raining⊕2Medium)+hvy.(Raining⊕2Heavy)+noRain‾.Sensor. Therefore, the modeler is not forced to identify common actions and behaviors to derive its model. The semantics of our resulting specification is even more compact than the FTS model of [28] by factorizing out common behaviors as much as possible; the part of behavior in which both sensors does not change their behaviors as long as action hvy is performed, is factored out in our case.In this section, we show that product line bisimilarity induces the same identification of PL-CCS terms as the multi-valued modal μ-calculus. In this section, we first review the logic and then explain how it characterizes product line bisimilarity.The multi-valued modal μ-calculus [12] combines Kozen's modal μ-calculus [30] and multi-valued μ-calculus as defined by Grumberg and Shoham [31]. LetVbe the set of propositional variables. The set of multi-valued modal μ-calculus formulae is given by the following grammar:φ::=true|false|Z|φ∨φ|φ∧φ|〈a〉φ|[a]φ|ηZ.φ,η∈{ν,μ}wherea∈ActandZ∈V, and the fixed point quantifiers μ and ν are variable binders.Letmv−Lμdenote the set of closed formulae generated by the above grammar. The semantics of a formula for a PL-CCS term is the set of configurations satisfying it. All configurations satisfy true in all states. A configurationν′satisfies a formulaϕ1∨ϕ2in state s if it satisfies eitherϕ1orϕ2in state s. A configurationν′satisfies a formula〈a〉φin state s if it has a transitions→a,νs′such thatν⊑ν′andν′satisfies φ in states′. A configurationν′satisfies a formula[a]φin state s if for all transitionss→a,νs′such thatν⊑ν′,ν′satisfies φ in states′. Equations with recursive variables are used to describe properties of behaviors with an infinite depth. For instance,X=def〈a〉X∨〈b〉truespecifies configurations (i.e., products) that they satisfy〈b〉trueeither in the initial state, or the state reached after performing a (possibly infinite) sequence of a-actions (with consistent configurations). Since an equation may have many solutions, the maximum and minimum solutions are selected byνZ.ϕandμZ.ϕ, respectively. Considering Z as a mapping from the states to a set of configurations,μZ.ϕis valid for the smallest mapping Z that satisfies the equationZ=ϕ. SimilarlyνZ.ϕis valid for the largest mapping Z that satisfies equationZ=ϕ. For instance, the propertyμX.〈a〉X∨〈b〉truespecifies that “eventually an action b follows a (possibly empty) sequence of a actions”. This property holds for the configuration〈L,L〉in the state〈X|E〉of CTS in Fig. 3a.The semantics of φ, denoted by〚φ〛, is a functionS→P(Config)that defines the set of configurations that satisfy formula φ for each given state. Given an environmentρ:V→(S→P(Config)), which maps free variables in φ toS→P(Config),〚φ〛ρdefines the semantics of φ with respect to ρ in Table 3.Example 21Regarding the rules in Table 3, the semantics of〚〈b〉true〛in the state(b.〈X|E〉⊕1c)of the CTS in Fig. 3a is{〈L,R〉,〈L,L〉}, sinceRb(b.〈X|E〉⊕1c.0,〈X|E〉)={〈L,R〉,〈L,L〉}and〚true〛(〈X|E〉)=P(Config). It can be shown thatf={(b.〈X|E〉⊕1c.0)↦{〈L,R〉,〈L,L〉},〈X|E〉↦{〈L,L〉},0↦∅}is the semantics ofμX.〈a〉X∨〈b〉truesince〚〈a〉X〛[X↦f]=λs.⋃{Ra(s,s′)∩X(s′)}={〈X|E〉↦{〈L,L〉},b.〈X|E〉⊕1c↦∅,0↦∅},〚〈b〉true〛={b.〈X|E〉⊕1c↦{〈L,R〉,〈L,L〉},〈X|E〉↦∅,0↦∅},f=〚〈a〉X∨〈b〉true〛[X↦f], and it is the minimum mapping that satisfies the equationX=〈a〉X∨〈b〉true.Model checking logical formula ϕ over a PL-CCS term is supposed to result in the set of full configurations for which the property holds. Intuitively, two PL-CCS terms are logically equivalent when for each logical formula, there exists a non-empty set of products in one product line satisfying it if and only if there exists such a non-empty set in the other. For instance,(a.0+b.0)⊕1b.0is not logically equivalent toa.0⊕1b.0as the logical formula〈a〉true∧〈b〉trueis satisfied by the former for the configuration〈L〉, but it is not satisfied by the latter for any configuration.Definition 22Logical equivalenceTwo PL-CCS terms s and t are logically equivalent, denoted bys∼Lt, iff∀φ∈mv−Lμ⋅(〚φ〛(s)≠∅⇔〚φ〛(t)≠∅).As stated before, product line bisimilarity and logical equivalence coincide. The following Theorem states that if two PL-CCS terms are not product line bisimilar, then there is a logical formula that can distinguish them.Theorem 23For any PL-CCS terms s and t,s≃PLtiffs∼Lt.See Appendix E for the proof.

@&#CONCLUSIONS@&#
We proposed an equational reasoning technique to reason about software product lines at the syntactic level. To this aim, we defined product line bisimilarity by finding a mapping between products of two terms, identified by their configuration vectors. We also introduced a configuration-oriented bisimilarity that compares families at once. We proved that product line and configuration bisimilarity coincide. To facilitate checking the bisimilarity relations, we provided a sound and complete axiomatization over closed and finite-state behaviors. We characterized the distinguishing power of our equivalence relations in terms of a multi-valued modal μ-calculus.Instead of working at the semantic level and finding a mapping between products, one can use our axioms and restructure a term to its equivalent terms, e.g., such that the mandatory and optional parts are factored out separately. The restructuring mechanism can also be initiated to group the functionality of an SPL to behaviors for which appropriate components exist. Furthermore, one can derive the possible products of a term, specified by CCS terms to validate an SPL model in terms of its various products.We intend to exploit the PL-CCS process theory as a formal framework for specifying the structural and behavioral aspects of product lines, following the approach of [50]. We intend to investigate a basic form, such as linear process specification in mCRL2, over which different analysis and optimizations can be executed. Then, PL-CCS terms can be automatically transformed into the basic form in the same way of [27]. Finding a minimization algorithm for configuration bisimulation is another line of research. Furthermore, pre-order notions of literature can be compared in the general setting of FTS, which is a very expressive model for SPLs [11].