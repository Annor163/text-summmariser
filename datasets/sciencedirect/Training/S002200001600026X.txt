@&#MAIN-TITLE@&#
HEX: Scaling honeycombs is easier than scaling clock trees

@&#HIGHLIGHTS@&#
The HEX grid is a Byzantine fault-tolerant and self-stabilizing clock distribution.We argue that HEX is a robust alternative to buffered clock trees.HEX guarantees a small clock skew between neighbors with moderately balanced delays.HEX seamlessly integrates with multiple synchronized clock sources.We provide both theoretical analysis and simulations of the worst-case/average skew.

@&#KEYPHRASES@&#
Clock distribution,Byzantine fault-tolerance,Self-stabilization,Skew analysis,Simulations,

@&#ABSTRACT@&#
We argue that a hexagonal grid with simple intermediate nodes is a robust alternative to buffered clock trees typically used for clock distribution in VLSI circuits, multi-core processors, and other applications that require accurate synchronization: Our HEX grid is Byzantine fault-tolerant, self-stabilizing, and seamlessly integrates with multiple synchronized clock sources, as used in multi-synchronous Globally Synchronous Locally Asynchronous (GALS) architectures. Moreover, HEX guarantees a small clock skew between neighbors even for wire delays that are only moderately balanced. We provide both a theoretical analysis of the worst-case skew and simulation results that demonstrate a very small average skew.

@&#INTRODUCTION@&#
Being able to distribute a synchronized clock signal to a large number of spatially distributed functional units is crucial for the synchronous design paradigm. In Very Large Scale Integration (VLSI) circuits, multi-core processors, and other hardware devices (as well as in master-slave-type network clock synchronization approaches like IEEE1588 [1]), this is accomplished by means of a clock tree, which distributes the clock signal supplied by a single clock source to all functional units attached as leaf nodes. Topologies that guarantee equal wire lengths from the root to the leaves are used to ensure that clock pulses arrive at all functional units (i.e., those making up a synchronous sub-system) simultaneously. Such topologies are, for example, H-trees,33H-trees are recursively constructed from a H-shaped wiring topology by attaching four smaller H-shapes to the four open ends.combined with carefully engineered wire geometries, clock signal regeneration buffers, etc. This must be achieved with a clock skew, i.e., maximum difference of the occurrence real-times of corresponding clock pulses at different functional units, well below half the clock cycle time: When a functional unit sends some data, say, on local clock count 1000, the receiver is expected to receive and process the data when clock 1001 occurs according to its clock count.Clock trees are attractive for several reasons. Besides conceptual simplicity, their height is only logarithmic in the number of the leaves (which is proportional to the die area), and the number of internal clock wires is linear in this number. As trees are planar graphs, it would (in principle) even be possible to route these links on a single interconnect layer.These advantages come at a price, though: Elaborate clock tree engineering must ensure that the maximum delay discrepancy remains below the acceptable clock skew, which is very difficult for clock speeds in the GHz range [2–5]. Modern clock trees thus incorporate complex wire geometries and strong clock buffers, implying large area and power consumption [6]. Moreover, mitigating the inevitable skews from disjoint root-leaf paths requires extended topologies, such as trees with cross-links, meshes and multi-level trees [5,7].An even more serious issue with clock trees is lacking robustness, which also arises in applications where there are no severe skew requirements. First of all, at the top level, a single clock source obviously constitutes a single point of failure. This is avoided by Globally Asynchronous Locally Synchronous (GALS) [8] architectures, where different parts of a chip are clocked by different clock sources and clock trees. However, using independent and hence unsynchronized clock domains gives away the advantages of global synchrony and thus requires non-synchronous cross-domain communication mechanisms or synchronizers [9–12]. Multi-synchronous clocking [13,14] (also called mesochronous clocking [15]), which guarantees some upper bound on the skew between clock domains, has been invented to avoid this. The resulting architectures can rely on a common time base, which is attractive not only for application programmers, but also for metastability-free high-speed communication between different clock domains [16].Still, the problem of limited robustness of clock trees persists even in GALS architectures: If just one internal wire or clock buffer in a clock tree breaks, e.g., due to some manufacturing defect or breakdown [17], all the functional units supplied via the affected subtree will stop working correctly. Therefore, it is desirable to have fairly small clock trees in a GALS system, necessitating a large number of synchronized clock domains. Overcoming the fundamental scalability and robustness issues of clock trees hence introduces the new challenge of robustly establishing tight synchronization among a large number of clock domains.ContributionIn this paper, we tackle this problem by proposing an alternative way for distributing a synchronized clock signal throughout an integrated circuit. Our approach, termed HEX, is based on a sufficiently connected wiring topology, namely, a hexagonal grid.44Note that clock distribution by means of our HEX grid is fundamentally different from using a clock mesh [5] for averaging out large clock skews among nearby leaf nodes.At each grid point, we place an (intermediate) node that controls when the clock pulses are forwarded to adjacent nodes and supplies the clock to nearby functional units, typically using a small local clock tree. It will turn out that HEX compares favorably to clock trees in most aspects.In particular, with respect to robustness, our approach supports multiple synchronized clock sources, and tolerates Byzantine failures of both clock sources and nodes. Its resilience to failures scales with the size of the grid, in the sense that it supports a constant density of isolated Byzantine nodes, and it can handle a larger number of more benign failures like broken wires, or mute clock sources and nodes. It is self-stabilizing [18], in the sense that it recovers from an arbitrary number of transient faults, despite persisting isolated Byzantine failures.Furthermore, HEX has enticing properties with respect to the achievable skew between neighbors in the grid, which are typically the ones who need to communicate synchronously with each other. First, wires between HEX nodes are much shorter than in a clock tree: Assuming a constant spatial node density, the total number of nodesn=Θ(s2)is proportional to the square of the width and height s of a quadratic grid.Ass=Θ(n), the wire length between neighbors in HEX is, with optimal layout (cf. Section 5), onlyΘ(1). By contrast, the height of a clock tree isΘ(log⁡n)thus, even with optimal layout, their will be neighbors which are separated by a wire length ofΩ(n). HEX hence neither requires strong clock buffers nor special wire geometries, so that the maximal difference ε of the end-to-end delays between neighbors in the grid could easily be kept small even by moderate engineering efforts.Second, for a proper embedding of the HEX topology, physically close nodes are reasonably well-synchronized. It is well-known, e.g., from [19], that no deterministic clock synchronization algorithm can guarantee a worst-case skew between all pairs of nodes that is better thanDε/2, where D is the diameter of the underlying communication graph. Moreover, the gradient clock synchronization lower bounds established in [20] reveal that the skew between neighbors cannot be better thanΩ(εlog⁡D). We will show that the neighbor skew provided by HEX is at mostO(Dε2), where D is in fact the width of the grid. Depending on the number and severity of faults, this skew bound gracefully degrades.Paper organizationAfter a short description of related work, the HEX topology and algorithm as well as the system model are introduced in Section 2. In Section 3, we provide a detailed analysis of the worst-case neighbor skew of HEX (Section 3.1), discuss the effect of faulty nodes on the skew (Section 3.2), and analyze the self-stabilizing properties of HEX (Section 3.3). As the complexity of the skew analysis explodes for an increasing number of faults, the detailed analysis in the case of a single Byzantine faulty node is provided in Appendix A. In Section 4, we provide the corresponding results of our extensive simulation experiments, which have been obtained via a custom Modelsim-based simulation and analysis framework. In Section 5, we discuss practical extensions of HEX, in particular, frequency multiplication and alternative grid topologies. Some conclusions and directions of future work in Section 6 complete the paper. A glossary of the notations used can be found on the last page of this paper.Related workApart from the rich literature on clock tree engineering and extended topologies for skew reduction, see for example [2–7,17,21,22], we are not aware of much research on alternative clock distribution techniques. An exception is the work on distributed clock generation without local oscillators, which inherently also solves the problem of clock distribution. These approaches are essentially based on (distributed) ring oscillators, which are formed by gates arranged in a feedback loop. In [23], a regular structure of closed loops of an odd number of inverters is used for distributed clock generation. Similarly, [24,25] employ local pulse generation cells, arranged in a two-dimensional grid, with each cell inverting its output signal when its four inputs (from the up, down, left, and right neighbor) match the current clock output value. A more elaborate approach along the same lines uses an array of PLLs that are mutually synchronized among each other, using digital feedback exchanged across some (sparse) communication topology, like a grid [26–28]. To the best of our knowledge, none of these approaches has been analyzed for its fault-tolerance properties, not to speak of self-stabilization.The only fault-tolerant clock generation approaches for multi-synchronous GALS systems known to us are the Byzantine fault-tolerant DARTS approach [29,30] and our self-stabilizing Byzantine fault-tolerant FATAL algorithm proposed in [31]. However, both approaches are complex and require a fully connected topology. Consequently, they are not useful for distributing a synchronized clock to a large number of functional units, but are rather suitable candidates for the clock sources required by our HEX grid.We consider a set of nodes executing a pulse generation and forwarding algorithm, which communicate by message passing over a communication network whose underlying undirected communication graph is a cylindric hexagonal grid.Formally, the directed communication graph(V,E)of our HEX grid is defined as follows (see Fig. 1): LettingL∈Ndenote its length andW∈Nits width, the set of nodes V is the set of tuples(ℓ,i)∈[L+1]×[W]. Here,[L+1]:={0,…,L}denotes the row index set, referred to as layers, and[W]:={0,…,W−1}the column index set of the nodes in the grid. For each node(ℓ,i)∈V,0<ℓ∈[L+1],i∈[W], the following links are in E: Incoming and outgoing links to neighboring nodes of the same layer, namely from(ℓ,i)to(ℓ,i−1modW), called the left neighbor of(ℓ,i), and to(ℓ,i+1modW), called the right neighbor (and vice versa from the left and the right neighbor to(ℓ,i));(ℓ,i)also has incoming links from(ℓ−1,i), called its lower left neighbor, and(ℓ−1,i+1modW), called its lower right neighbor. Hence, if(ℓ,i)is in a layerℓ∈[L], then it has outgoing links to(ℓ+1,i−1modW), its upper left neighbor, and(ℓ+1,i), its upper right neighbor. Fig. 1 depicts the structure of the resulting HEX grid and shows a node's communication channels within the grid. The neighboring nodes of node(ℓ,i)form a hexagon, hence the name HEX grid. Due to the fact that column coordinates are modulo W, the HEX grid has a cylindric shape; we will discuss the issue of embedding a HEX grid on a chip in Section 5.Each node of the grid runs an algorithm that can broadcast trigger messages (representing clock pulses) over its outgoing links, as well as receive trigger messages over its incoming links. Each fault-free link guarantees a communication delay (i.e., the time between sending and receiving a trigger message) within[d−,d+]⊂(0,∞), whereε:=d+−d−. Having ε without any constraint, however, could render a few worst-case constructions (based on Definition 2) overly conservative. This can be avoided by the additional constraintε≤d+/2, which guarantees a property similar to the triangle inequality. Each node further has access to a (possibly inaccurate) clock to measure timeouts.Nodes at layer 0 are special as they act as primary clock sources, i.e., they execute a pulse generation algorithm like the one of [30,31] that generates synchronized and well-separated consecutive initial trigger messages. For each pulse numberk∈N, the time between any (non-faulty) node in layer 0 generating itskthtrigger message and another node in layer 0 generating its(k+1)thtrigger message is sufficiently large. The precise meaning of “sufficiently large” depends on the desired fault-tolerance properties; we will elaborate on this in Section 3.3. Note that it is desirable to keep the maximal time between pulses small in order to guarantee a high operating frequency.Nodes at layers larger than 0 run the HEX pulse forwarding algorithm specified in Algorithm 1. Basically, nodes forward pulse k once they received trigger messages for pulse k from two adjacent neighbors. Since clock pulses and trigger messages carry no information beside their occurrence, care must be taken in order not to generate multiple trigger messages for a single pulse. The simple solution we use here relies on a sufficiently large separation between thekthand(k+1)thpulse (for each k), which relieves us from locally keeping track of pulse counts. For each link, a node memorizes a received trigger message only for some time betweenTlink−andTlink+,Tlink+≥Tlink−, where the slackTlink+−Tlink−accounts for inaccurate local timers, and then forgets the reception of the message by clearing the memory flag associated with the link. After having forwarded its pulse, a node goes to sleep (i.e., will not locally trigger further pulses) for some time betweenTsleep−andTsleep+≥Tsleep−. Upon waking up, it clears all its memory flags. Note that there would be no need for the individual link timeout mechanism ([Tlink−,Tlink+]) described above if the algorithm always started from a properly initialized state. It is required, however, for also guaranteeing self-stabilization from arbitrary states in the presence of persistent Byzantine faults.The precise conditions forTlink−andTsleep−follow from the analysis and are discussed in Section 3.3. Due to its simplicity, Algorithm 1 can easily be implemented by means of an asynchronous state machine, see Fig. 7a in Section 4.In this section, we analyze skew and fault-tolerance properties of the HEX algorithm in the topology presented in the previous section. Recall that nodes in layer 0 generate synchronized pulses, which the nodes in higher layers just propagate upwards; this results in a “pulse wave” as depicted in Fig. 8. Bytℓ,i(k), we denote the triggering time of node(ℓ,i), i.e., the time when it forwards thekthpulse of the grid. Generally, we will use superscript(k)to denote variables associated with thekthpulse.We will now analyze the propagation of a single pulse wave,55To keep the notation simple, we will drop the superscript(k)indicating the pulse number during this section.assuming that the constraints (C1) and (C2) below are satisfied and no nodes are faulty. In a nutshell, our constraints ensure that, initially, all nodes have cleared their memory flags and are waiting for the next pulse generated by the nodes in layer 0.(C1)Tlink−is sufficiently large so that no trigger message from a neighbor is “forgotten” before the corresponding message from another neighbor arrives. Thus we can be sure that a node which is not sleeping will be triggered by a wave.Tsleep−,Tsleep+, and the time between pulses (controlled by the layer 0 nodes) are large enough so that (i) every node will be triggered at most once per wave and (ii) no node sleeps when the next wave arrives.We first introduce the concept of “left zig-zag paths”, which will play an essential role in bounding the worst-case triggering times of adjacent nodes in a single pulse wave.Definition 1Causal links and pathsA node is left-triggered/centrally triggered/right-triggered in a given execution, if the satisfied guard from Algorithm 1 causing the node to trigger is having received trigger messages from the left and lower left/lower left and lower right/lower right and right neighbors, respectively. In each case both of the respective links are causal. A causal path consists of causal links only.Note that a link being causal implies that its endpoint is triggered at leastd−time after its origin. For instance, if(ℓ,i)is left-triggered, the links((ℓ,i−1),(ℓ,i))and((ℓ−1,i),(ℓ,i))are causal, while((ℓ,i+1),(ℓ,i)),((ℓ−1,i+1),(ℓ,i))are not.The following definition backtraces a sequence of causal links from a given destination node, either to the node in layer 0 starting the causal chain or to some specific column of interest. Note that this can be done for any destination node in a given execution.Definition 2Left zig-zag pathsGiven are a layer0<ℓ∈[L+1]and column indicesi,i′∈[W],i<i′.66Recall that column indices are implicitly taken modW, so in principle we would have to account for this in the definition. However, in our proofs we will exploit the translation and mirror symmetry of the grid w.r.t. column indices so that we can always assume thati<i′, avoiding more involved notations. For example, ifi=W−1, then some node in the column to the right (which has column index 0) is considered as having indexi′=W.The causal left zig-zag pathplefti′→(ℓ,i)is composed of rightward links((ℓ′,j−1),(ℓ′,j))and up-left links((ℓ′−1,j+1),(ℓ′,j)). It is inductively defined as follows. We start with the 0-length path((ℓ,i)). Suppose that in some step of the construction the current path originates at node(ℓ′,j)withℓ′>0. If(ℓ′,j)is left-triggered, we extend the path by adding the rightward link((ℓ′,j−1),(ℓ′,j))as first link (and(ℓ′,j−1)as its origin). Otherwise, the up-left link((ℓ′−1,j+1),(ℓ′,j))is causal and can be added as prefix to the path (and(ℓ′−1,j+1)as its origin). In the case of adding an up-left link the construction terminates if either (i)j+1=i′and the path now contains more up-left than rightward links (we will callplefti′→(ℓ,i)a triangular path in this case) or (ii)ℓ′−1=0andj+1arbitrary (a non-triangular path).The following simple facts about left zig-zag paths follow almost immediately from their definition.Lemma 1Every left zig-zag pathplefti′→(ℓ,i)constructed according toDefinition 2is finite. Ifplefti′→(ℓ,i)is a triangular path and starts at(ℓ′,i′), for some0≤ℓ′<ℓ, then each of its prefixes π is also a triangular path.ProofSince causal paths are acyclic, there must be fewer than W left links before the construction goes down one layer; the finiteness of ℓ hence implies the finiteness ofplefti′→(ℓ,i). Now assume that some prefix π of a triangular pathplefti′→(ℓ,i)starting at(ℓ′,i′)is not a triangular path, i.e., has at least as many rightward links than up-left ones. Then, the suffix of π must start in(ℓ″,i″)withi″≥i′, and must have more up-left links than rightward ones. Since the suffix must hence cross columni′from right to left, the construction of Definition 2 would already have terminated here.  □We now provide a very important technical lemma, which reveals a connection between the triggering times of two nodes(ℓ,i)and(ℓ,i+1)at the same layer ℓ: If the left node is the end of a left zig-zag triangular path starting at node(ℓ′,i′)and has a distance ofr>0columns to the right node, the latter cannot trigger later than the left node plus a time offset of at mostrd−+(ℓ−ℓ′)ε. Note that we assume here thati′−ℓ≥0, i.e., that W is large enough such that no wrap-around occurs. The bound provided by Lemma 2 also holds in the general case, but then it may not be tight.Lemma 2Suppose that path π is a prefix of some left zig-zag triangular pathplefti′→(ℓ″,i″), and that π starts at node(ℓ′,i′)and ends at node(ℓ,i)withℓ>0. Letr>0be the number of up-left links minus the number of rightward links along π. Thentℓ,i′≤tℓ,i+rd−+(ℓ−ℓ′)ε.ProofBy Lemma 1, π is a triangular path and hence indeedr>0. For simplicity of our arguments, we setℓ′=0(i.e., we shift all layer indices byℓ′and the new value of ℓ now representsℓ−ℓ′) and assume thati′−ℓ≥0, i.e., that W is large enough such that no wrap-around occurs within the triangle.77Our proof also holds for the general case, though, provided (i) one just neglects the fact that some of the index pairs may actually refer to the same node (which does not affect our argument) and that (ii) certain left zig-zag paths in our construction cannot occur (which may lead to an overly conservative bound).Consequently, we only need to consider the set S of nodes in the triangle with corners(0,i′),(ℓ,i′−ℓ), and(ℓ,i′)shown in Fig. 2.Observe thatplefti′→(ℓ″,i″)starts at the lower corner of the triangle and the prefix π never leaves it. By induction on thekthleft-diagonal(k,i′),…,(ℓ,i′−(ℓ−k))(fork∈[ℓ+1]) of the triangle, we will prove that each node p that is both on the diagonal k and either on π or to the right of π is triggered at the latest at time(1)tp≤tℓ,i−(ℓ−r)d−+kd+.Since(ℓ,i′)is on diagonal ℓ, this impliestℓ,i′≤tℓ,i+rd−+ℓε. Undoing the initial index shift (i.e., replacing ℓ byℓ−ℓ′), the claim of the lemma follows.First, we show directly that Eq. (1) holds for each node p on π: Observe that node(ℓ,i)is on diagonal(ℓ−r). Hence, a node p that is h hops from(ℓ,i)on π must be on a diagonalk≥(ℓ−r)−h. Sinceplefti′→(ℓ″,i″)is causal, it follows that(2)tp≤tℓ,i−hd−≤tℓ,i−(ℓ−r)d−+kd−≤tℓ,i−(ℓ−r)d−+kd+,showing the statement for nodes on π.Note that all nodes on diagonal 0 are either on or to the left of π, hence we already covered the induction anchor atk=0. For the induction step from k tok+1, observe that any node will be left-triggered within at mostd+time once both its left and lower-left neighbors are triggered. For any node p on the(k+1)thdiagonal that is strictly to the right of π, its left and lower-left neighbor are on the diagonal k of S and either on π or to the right of π. The statement for diagonal k thus impliestp≤tℓ,i−(ℓ−r)d−+kd++d+as required. On the other hand, nodes lying on π are covered by Eq. (2), which completes the induction step.  □In the following definition, we will introduce the different notions related to the skew between nodes. Besides the maximum (unsigned) intra-layer skew of neighboring nodes at the same layer and the (signed) maximum inter-layer skew w.r.t. the layer below, we also define the skew potential of layer ℓ. Informally, the latter provides a measure for the adversary's ability to exploit the existing skew of the nodes in layer ℓ to increase the skew of neighboring nodes in layerℓ+1. By this, we mean that the adversary can, in the worst case, force a node at layerℓ+1to left-trigger strictly before it is centrally triggered by its layer-ℓ neighbors. It is not too difficult to prove88In fact, this proof is embedded in the proof of Lemma 4. In a nutshell, it shows that such an early left-triggering would only be possible if the left neighbor itself was early left-triggered as well. By continuing this argument inductively over the entire layer, a left neighbor will eventually be reached that cannot be left-triggered, which provides the required contradiction.that this is only possible if the skew between neighbors at layer ℓ is strictly larger thand−. Hence, we define the skew potential below in a way that results in a positive value only in the latter case.Definition 3Distance, skew, and skew potentialFori,j∈Z, letd:=i−jmodWand define the cyclic distance as|i−j|W:=min⁡{d,W−d}. Forℓ∈[L+1], we define(i)the intra-layer skew of layer ℓ asσℓ:=maxi∈[W]⁡{|tℓ,i−tℓ,i+1|},the skew potential on layer ℓ asΔℓ:=maxi,j∈[W]⁡{tℓ,i−tℓ,j−|i−j|Wd−}.the inter-layer skew of layer ℓ asσˆℓ:=maxi∈[W]⁡{tℓ,i−tℓ−1,i,tℓ,i−tℓ−1,i+1}.Note that every pair of nodesi,joccurs twice (asi,jandj,i) in the max-term of the skew potential in (ii) above, which implies that only a non-negative time difference can determineΔℓ. Moreover, asj=iis not excluded, we always haveΔℓ≥0.We first prove a weak bound on the maximal skew at the upper layers that holds independently of the initial skew potentialΔ0. Note that this result implies tolerance of HEX against arbitrary layer 0 skews, at the expense of “losing” layersℓ∈[W−2]. This behavior is also clearly visible in the simulation results shown in Figs. 9 and 12.Lemma 3ForW>2and allℓ∈{W−2,…,L},Δℓ≤2(W−2)ε.ProofConsider any fixedi,i′∈[W],i<i′(wrap-around cases are symmetrical) and assume thatℓ=W−2; we will argue later on why the proof below also coversℓ>W−2. We distinguish two cases.Case 1plefti′→(ℓ,i)starts at node(ℓ′,i′)for someℓ′∈{1,…,ℓ−1}. Then, by Lemma 2,tℓ,i′≤tℓ,i+(i′−i)d−+(ℓ−ℓ′)ε≤tℓ,i+(i′−i)d−+ℓε.Case 2plefti′→(ℓ,i)starts at node(0,j),j∈[W]. Then the path has length at least2ℓ−(i′−i), since at least ℓ up-left andℓ−(i′−i)right links are required for the path to originate at layer 0. Denote byt0the earliest time when a pair of two adjacent nodes in layer 0 are both triggered. Clearly, thekthnode onplefti′→(ℓ,i),k≥2, cannot be triggered before timet0+(k−1)d−because it is connected by a causal path of lengthk−1to a layer-0 node that is triggered at or after timet0. Hence,tℓ,i≥t0+(2ℓ−(i′−i))d−and thus(3)tℓ,i≥t0+(2(W−2)−(i′−i))d−.Denote by(0,j)a node withmax⁡{t0,j,t0,j+1}=t0; by the definition oft0, such a node exists. We claim that all nodes in layerW−2are triggered no later than timet0+2(W−2)d+. This follows by induction on the layersλ∈[W−1], where the hypothesis is that all nodes(λ,j−λ),(λ,j−λ+1),…,(λ,j+1)are triggered until timet0+2λd+; an illustration of the first layers is shown in Fig. 3. Since in layer λ these are2+λnodes, i.e., all W nodes in layerW−2, this will prove the claim of our lemma.By the definition oft0, the induction hypothesis holds forλ=0. To perform the step from λ toλ+1, observe that all nodes(λ+1,j−λ),(λ+1,j−λ+1),…,(λ+1,j)are triggered no later than timet0+(2λ+1)d+, since by the hypothesis their lower left and lower right neighbors are triggered at leastd+before that time. Until timet0+2(λ+1)d+, nodes(λ+1,j−(λ+1))resp.(λ+1,j+1)must also follow since they are right- resp. left-triggered (if not triggered differently before), which completes the induction.The result of our induction proof impliestℓ,i′≤t0+2(W−2)d+and hence, by using Eq. (3),tℓ,i′−tℓ,i≤(i′−i)d−+2(W−2)ε.Overall, since i andi′>iwere arbitrary, from the two cases and the symmetry properties of the grid, we conclude thatΔℓ=maxi,i′∈[W]⁡{tℓ,i′−tℓ,i−|i′−i|Wd−}≤2(W−2)ε, as claimed.Finally, since the above proof did not require any specific property to be respected by layer 0 nodes, it also applies literally if we replace layerW−2by ℓ and layer 0 by layerℓ−W+2. This concludes the proof of Lemma 3.  □Next, we derive more refined bounds on the intra-layer skew between two neighboring nodes at the same layerℓ>0: In contrast to Lemma 3, we now take the maximal skew in previous layers into account. Unfortunately, its proof is complicated by the fact that we need to distinguish three different cases that might lead to the worst-cast skewsℓ,ibetween nodes(ℓ,i)and(ℓ,i+1). They depend on whether the skewsλ,iof the corresponding nodes(λ,i)and(λ,i+1)at some (suitably chosen) layer λ issλ,i≤d+(Case 1) or elsesλ,i>d+(Cases 2 and 3).Informally, Case 1 is characterized by a V-shaped growth of the worst-case skew: Our detailed proof will show thatsλ,iincreases a most by ε with every layer. By contrast, in the other cases, the nodes(λ,i)and(λ,i+1)at layer λ are already “torn apart”. The worst-case skew in this case is determined by a left zig-zag pathplefti+1→(ℓ,i)that causestℓ,ito be as small as possible on the one hand, and a “slow” causal path ending at(λ,i+1)that makestℓ,i+1as large as possible on the other hand. Cases 2 and 3 are distinguished according to the two possibilities whereplefti+1→(ℓ,i)can start here: Case 2 applies when it originates at some node(0,j0)withj0≠i+1, whereas Case 3 is characterized by a triangular path starting at(ℓ′,i+1).Lemma 4For allℓ0∈[L]andℓ∈{ℓ0+1,…,L}, it holds for eachi∈[W]that|tℓ,i−tℓ,i+1|≤d++⌈(ℓ−ℓ0)εd+⌉ε+Δℓ0.ProofFix some value ofℓ≥1and assume, without loss of generality, thatℓ0=0. To simplify our arguments, we also assumetℓ,i<tℓ,i+1(as the other cases are symmetric, this is sufficient).Defineλ0:=⌊ℓd−/d+⌋, which maximizesλ0under the constraint thatλ0d+≤ℓd−. Thus, a “slow” chain of trigger messages will completeλ0hops within the time a “fast” chain requires for ℓ hops. We obtain(4)ℓ−λ0=ℓ−⌊ℓd−d+⌋=⌈ℓεd+⌉;recall that−⌊x⌋=⌈−x⌉.We distinguish three cases:Case 1V-shaped skews (Fig. 4a):tλ,i+1≤tλ,i+d+for someλ≥λ0. We choose λ maximal with this property, so thattλ′,i+1>tλ′,i+d+for allλ′∈{λ+1,…,ℓ}. Notice that this implies that, for all suchλ′, node(λ′,i)cannot be right-triggered, as the links((λ′,i+1),(λ′,i))cannot be causal. Hence, all links((λ′−1,i),(λ′,i))must be causal in this case. By induction onλ′, we can thus infertℓ,i≥tλ,i+(ℓ−λ)d−.Furthermore,tλ′,i+1>tλ′,i+d+ensures that the trigger message from(λ′,i)to(λ′,i+1)arrives well before timetλ′,i+1. Thus, node(λ′,i+1)will be triggered at the latest when the trigger message from its lower left neighbor(λ′−1,i+1)arrives. Again by induction onλ′, we infer thattℓ,i+1≤tλ,i+1+(ℓ−λ)d+, and hence(5)tℓ,i+1≤tλ,i+(ℓ−λ+1)d+.Combining these bounds and applying Eq. (4), we obtaintℓ,i+1−tℓ,i≤(ℓ−λ)ε+d+≤d++⌈ℓεd+⌉ε.Case 2Non-V-shaped skews, non-triangular (Fig. 4c): Case 1 does not apply andplefti+1→(ℓ,i)starts at some node(0,j0), forj0≠i+1. Ifplefti+1→(ℓ,i)contained more left-up links than rightward links, it would contain a subpath originating at a node in columni+1that also would have more left-up than rightward links. This is not possible, since then the construction would have terminated at this node, either resulting in the path originating at a layerℓ′>0or at node(0,i+1). Henceplefti+1→(ℓ,i)is of length2ℓ+rfor somer≥0andj0=i−rmodW.For all indicesj∈{i+1,i+2,…,i+1+λ0}, we have that|j−j0|W≤j−i+r, and hence, by definition of the skew potential, alsot0,j−t0,j0=t0,j−t0,j0−|j−j0|Wd−+|j−j0|Wd−≤Δ0+|j−j0|Wd−≤Δ0+(λ0+r+1)d−.Recalling the length ofplefti+1→(ℓ,i)established above, we obtain that(6)tℓ,i≥t0,j0+(2ℓ+r)d−≥t0,j−Δ0−(λ0+r+1)d−+(2ℓ+r)d−=t0,j−Δ0+(2ℓ−λ0−1)d−.Moreover, by induction onλ∈{0,…,λ0}, it follows that all nodes(λ,j′)∈{(λ,i+1),…,(λ,(i+1+λ0−λ)modW)}are triggered at timetλ,j′≤maxi<j≤i+λ0+1⁡{t0,j}+λd+. Plugging in Eq. (6) implies(7)tλ,j′≤tℓ,i+Δ0−(2ℓ−λ0−1)d−+λd+and hencetλ0,i+1≤tℓ,i+Δ0−(2ℓ−λ0−1)d−+λ0d+≤tℓ,i+Δ0−(ℓ−λ0−1)d−;the second inequality holds by the definition ofλ0, which impliesλ0d+≤ℓd−.Since Case 1 does not apply, we havetλ,i+1>tλ,i+d+for allλ0≤λ≤ℓ. We can hence use the same argument as used for deriving Eq. (5) to show thattℓ,i+1≤tλ0,i+1+(ℓ−λ0)d+. It follows thattℓ,i+1≤tλ0,i+1+(ℓ−λ0)d+≤tℓ,i+d−+(ℓ−λ0)ε+Δ0=tℓ,i+d−+⌈ℓεd+⌉ε+Δ0,where the last equality follows from Eq. (4).Case 3Non-V-shaped skews, triangular (Fig. 4b): Neither Case 1 nor Case 2 apply. In this case,tλ,i+1>tλ,i+d+for allλ∈{λ0,…,ℓ}, andplefti+1→(ℓ,i)is a triangular path starting at node(ℓ′,i+1)for someℓ′<λ0−1: By construction, the first (causal) link ofplefti+1→(ℓ,i)is((ℓ′,i+1),(ℓ′+1,i)), implying that node(ℓ′+1,i+1)is triggered no later than timetℓ′+1,i+d+=max⁡{tℓ′,i+1+d+,tℓ′+1,i+d+}. Hence, since Case 1 does not apply, we must indeed haveℓ′+1<λ0.Let(λ0,j0)be the last node on the causal pathplefti+1→(ℓ,i)that is still in layerλ0. Observe thatj0+r−u=i, where r (resp. u) is the number of rightward (resp. up-left) hops ofplefti+1→(ℓ,i)after(λ0,j0). We apply Lemma 2 to the prefix π ofplefti+1→(ℓ,i)ending at(λ0,j0), i.e., seti:=j0,i′=i+1andr:=i+1−j0in this lemma, which yieldstλ0,i+1≤tλ0,j0+(i+1−j0)d−+(λ0−ℓ′)ε.Since Case 1 does not apply, we can use the same induction as used before Eq. (5) to prove thattℓ,i+1≤tλ0,i+1+(ℓ−λ0)d+. We thus obtaintℓ,i+1≤tλ0,j0+(i+1−j0)d−+(λ0−ℓ′)ε+(ℓ−λ0)d+=tλ0,j0+(ℓ−λ0+i+1−j0)d−+(ℓ−ℓ′)ε.By construction,plefti+1→(ℓ,i)is of length2(ℓ−ℓ′)−1and its prefix ending at node(λ0,j0)is of length2(λ0−ℓ′)−(i+1−j0). Therefore, the length of the suffix ofplefti+1→(ℓ,i)starting at(λ0,j0)is2(ℓ−λ0)+(i−j0). As this suffix is a causal path, we havetℓ,i≥tλ0,j0+(2(ℓ−λ0)+(i−j0))d−.Altogether, we arrive attℓ,i+1−tℓ,i≤(ℓ−ℓ′)ε−(ℓ−λ0−1)d−≤ℓε−(ℓεd+−1)d−=d−+ℓε2d+≤d++⌈ℓεd+⌉εaccording to Eq. (4).Since the claimed bound holds in each of the (exhaustive) cases considered, the proof of Lemma 4 is completed.  □We remark that it is possible to construct, by deterministically choosing appropriate link delays, worst-case executions that almost match the bounds established in Lemma 4; an example is shown in Fig. 5.In the proof of Lemma 4, in particular, in Case 2 (Fig. 4c), we silently assumed that the starting node(0,j0)of the left zig-zag pathplefti+1→(ℓ,i)on the left side does not “collide” (due to a wrap-around) with one of the slow nodes(0,i+1),…,(0,i+λ0+1)on the right side. Whereas this is reasonable for wide grids, this is not realistic if W is small. Considering such a collision prohibits some of the worst-case scenarios considered, and hence possibly makes the worst-case skew result provided by Lemma 4 overly conservative. We therefore provide the following corollary, which takes this width constraint into account.Corollary 1Setδ:=d−/2−ε. For each layerℓ∈{W,…,L}and alli∈[W], it holds that|tℓ,i−tℓ,i+1|≤max⁡{d++⌈Wεd+⌉ε,Δℓ−W+d+−Wδ}.ProofThe proof is mostly analogous to the one of Lemma 4, withℓ0resp.Δ0replaced byℓ−Wresp.Δℓ−W. Case 2 needs a slightly different treatment, though, by assuming w.l.o.g.ℓ=Wand recomputing the bound Eq. (6) for all indicesj∈{i+1,i+2,…,i+λ0+1}astℓ,i≥t0,j−Δ0−|j−j0|Wd−+(2ℓ+r)d−≥t0,j−Δ0+3ℓd−2,where we conservatively setr=0and exploit that|j−j0|W≤W/2=ℓ/2in the second step. The analogon of Eq. (7) in the proof of Lemma 4, forλ∈{0,…,λ0}and(λ,j′)∈{(λ,i+1),…,(λ,(i+1+λ0−λ)modW)}, hence readstλ,j′≤tℓ,i+Δ0−3ℓd−2+λd+and thus leads totλ0,i+1≤tℓ,i+Δ0−3ℓd−2+λ0d+≤tℓ,i+Δ0−ℓd−2,where we used thatλ0d+≤ℓd−by the definition ofλ0. Finally, re-using the resulttℓ,i+1≤tλ0,i+1+(ℓ−λ0)d+from the proof of Lemma 4, we arrive attℓ,i+1≤tℓ,i+Δ0+(ℓ−λ0)d+−ℓd−2≤tℓ,i+Δ0+ℓε+d+−ℓd−2=tℓ,i+Δ0+d+−Wδ,where we used Eq. (4) to derive the second inequality.Checking the bounds from Case 1 and Case 3 in Lemma 4, we see that they are smaller or equal to the left term in the maximum on the right hand side of the claimed bound. The bound for the differently treated Case 2 matches the right term in the maximum.  □We are now ready to derive our main result, namely, bounds on the worst-case skews between neighbors.Theorem 1Skew bounds—fault-free caseSuppose thatε≤d+/7. IfΔ0=0, then the intra-layer skewσℓ(recallDefinition 3) is uniformly bounded byd++⌈Wε/d+⌉εfor anyℓ∈[L+1]. In the general case,∀ℓ∈{1,…,2W−3}:σℓ≤d++2Wε2/d++Δ0.∀ℓ∈{2W−2,…,L}:σℓ≤d++⌈Wε/d+⌉ε.The inter-layer skew of layerℓ∈[L+1]∖{0}, for alli∈[W], is determined bytℓ−1,i−σℓ−1+d−≤tℓ,i≤tℓ−1,i+σℓ−1+d+andtℓ−1,i+1−σℓ−1+d−≤tℓ,i≤tℓ−1,i+1+σℓ−1+d+.ProofAssume first thatΔ0=0. For the sake of the argument, imagine that the HEX grid would start at layer−(W−1), where for alli∈[W]and allℓ∈{−(W−1),…,0}we would have thattℓ,i=ℓd+. Clearly, starting from any execution on the actual grid, this would result in a feasible execution on the extended grid if we choose all link delays on the imagined links to bed+. It follows thatΔℓ=0for allℓ∈{−(W−1),…,0}. From Lemma 3, we obtain thatΔℓ≤2(W−2)εfor allℓ∈{1,…,L}(since we have negative layer indices until−(W−1), the lemma also applies to layers1,…,W−3). Now we apply Corollary 1 to all layersℓ∈{1,…,L}, yielding that(8)σℓ≤max⁡{d++⌈Wεd+⌉ε,W(2ε−δ)+d+}.Sinceε≤d+/7, we haved−≥6d+/7andδ≥2d+/7and thus2ε−δ≤0; the maximum in Eq. (8) is hence dominated by the first term. This proves the first statement.Now consider the case whereΔ0is arbitrary. The bound onσℓforℓ∈{1,…,2W−3}follows from Lemma 4. Forℓ≥2W−2, observe first that we can apply Lemma 3 to all layersℓ∈{W−2,…,L}. Hence the same bound as in the previous case holds due to Corollary 1 applied to layersℓ∈{2W−2,…,L}.The third inequality of the theorem holds sincetℓ−1,i−σℓ−1+d−≤min⁡{tℓ−1,i,tℓ−1,i+1}+d−≤tℓ,i≤max⁡{tℓ−1,i,tℓ−1,i+1}+d+≤tℓ−1,i+σℓ−1+d+;the last inequality is proved analogously.  □We now extend the analysis from the fault-free case to the case of some faulty nodes in the grid. We still confine our examination to a single pulse; we will show later that the necessary preconditions for this type of analysis will eventually be satisfied, no matter what the initial states of the nodes are.Since the communication structure of our algorithm is extremely simple, it is not difficult to understand the “options” of Byzantine nodes for disrupting the system's operation within a single pulse, given that all correct nodes have cleared their memory and await the next pulse. If faulty nodes have the possibility to cause a correct node to generate a “false” pulse (i.e., to trigger without the immediate support of other correct nodes) this will clearly break our protocol: Once this happens, this will cause a chain reaction distributing the false pulse just like a correct one.A similar problem arises if a correct node(ℓ,i)has a second faulty neighbor (even if it is just a crash fault) and the two faults are not the left and right neighbors. If both faulty neighbors omit to send trigger messages, the node is not going to be triggered. However, if a Byzantine neighbor does send a trigger message, at some time after(ℓ,i)has received a trigger message from another neighbor, but before the respective link timeout expires, it is immediately triggered. Hence, a Byzantine node can trigger(ℓ,i)late in this case, again creating a “false” pulse.Finally, if both the left and right neighbors of correct nodes may fail, we could have every second node in an entire layer failing, which would prevent the propagation of pulses if these nodes do not send messages. With these issues in mind, we arrive at the following sufficient condition for triggering all nodes exactly once per pulse.Condition 1Fault separationFor each node, no more than one of its incoming links connects to a faulty neighbor.We use the following definition to summarize skews.Definition 4Forℓ∈[L+1]∖{0}, we say that layer ℓ has skew at most σ if, for any two correct neighbors(ℓ,i)and(ℓ′,i′),|tℓ,i−tℓ′,i′|≤σwithℓ−1≤ℓ′≤ℓ, and layerℓ−1has skew at most σ. The skew for layer 0 is given by the used clock generation scheme. If layer L has skew at most σ (i.e., any two correct neighbors have skew at most σ) we say that the pulse has skew at most σ.If Condition 1 is satisfied and all correct nodes have cleared all memory flags before a pulse arrives, it is straightforward to derive a (fairly coarse) skew bound.Lemma 5Suppose all correct nodes in layer 0 send trigger messages during[tmin,tmax],Condition 1holds, and no correct node in any layerℓ′∈[ℓ+1], whereℓ∈[L+1], memorizes a trigger message from another correct node or is sleeping at timetmin+ℓ′d−. Withfℓ≤fdenoting the number of layersℓ′∈[ℓ]containing some faulty node, all correct nodes on layer ℓ are triggered at times within[tmin+ℓd−,tmax+(ℓ+fℓ)d+]. In particular, the pulse has skew at mostσ(f)<tmax−tmin+εL+fd+.ProofBy induction on ℓ. Clearly the statement is true forℓ=0. The step is trivial for the lower bound, since Condition 1 implies that each node needs to receive a trigger message from a correct neighbor to be triggered, which is delayed by at leastd−time. If the upper bound is satisfied forℓ∈[L]and all nodes in layer ℓ are correct, certainly all nodes in layerℓ+1are triggered withind+time. If there is a faulty node in layer ℓ, the upper bound allows for2d+time for all nodes on layerℓ+1to be triggered. If a correct node on layerℓ+1has a faulty neighbor on layer ℓ, Condition 1 necessitates that either its right or its left neighbor is correct and has only correct neighbors on layer ℓ; the claim hence follows, as the node will be left- or right-triggered within2d+time.  □This lemma shows that even in the presence of multiple faults the time to complete a pulse increases only moderately. Thus, increasing the time between pulses (originating from layer 0) accordingly will maintain a clean separation of pulses.While Lemma 5 guarantees bounded skew and suggests that actuallyσ(f)=σℓ+O(fd+), whereσℓis the fault-free layer ℓ intra-layer skew given in Theorem 1, a more detailed reasoning is required to prove such a bound. Unfortunately, the number of cases that needs to be considered in a formal proof explodes quickly. A large number of cases needed to be examined already in the fault-free case, and dealing with just a single fault became sufficiently tedious for being relegated to Appendix A. Informally, the reasoning employs the following arguments: For a Byzantine faulty node, there are only two options for increasing the skew between neighbors: (i) “shortcut” a causal path to the fast node and (ii) refrain from triggering nodes to inhibit the propagation of the pulse to the slow node.Dealing with (i) is straightforward: If during the construction of a causal path we run into a Byzantine node, we follow the other incoming causal link of the predecessor node instead, thereby avoiding the Byzantine node, and resume the construction. This is particularly simple for the left zig-zag paths used in Cases 2 and 3 of Lemma 4; see Fig. 6for an example of how this might look like, where the faulty node is located at(ℓ−1,j0). When dealing with (ii), the situation is similar. Instead of circumventing faulty nodes in the construction of a causal path, we now need to avoid relying on them to trigger correct nodes. Fig. 6 also gives an example for this, for a faulty node at(1,i+1). Consult Appendix A for the detailed discussion of these (and similar) cases.Consequently, in order to increase skews significantly, several faulty nodes need to be in a region that causally affects two neighbors. In a setting where delays are random, it seems unlikely that the elaborate patterns required for large skews will arise, in particular if faults are not in close vicinity of each other. The simulations in Section 4 support this view, showing moderate increase of skews despite a significant number of faults.We point out that crash failures, where nodes simply cease operating, are more benign. Instead of breaking the entire system, two adjacent crash failures on some layer just effectively crash their common neighbor in the layer above and affect the skews of surrounding nodes. We refer to [32] for simulations concerning crash faults.Self-stabilization is the ability of the system to recover from an unbounded number of transient faults [18], which may put the system into an arbitrarily erroneous state. When transient faults cease, the system will resume normal operation within a bounded stabilization time—ideally even in the presence of a bounded number of persistent faults. In this section, we will show that HEX is self-stabilizing even in the presence of up to f Byzantine faulty nodes that satisfy Condition 1; under the assumption that correct nodes faithfully execute the HEX algorithm, the pulse generation will eventually work as specified in Lemma 5, even when all nodes start from arbitrary internal states. Note that this can also be guaranteed for the pulse generation at layer 0, by using a self-stabilizing and Byzantine fault-tolerant algorithm likeFATAL+[31]; the details are outside the scope of this paper, however.The analysis in Section 3.1 assumed thatTlink−,Tsleep−, and the time between pulses are sufficiently large for all correct nodes to clear their memory and complete their sleeping period before the next pulse arrives. In the previous section, we argued that faulty nodes have an adverse, but bounded, effect on the skew and the time to complete a pulse. To ensure self-stabilization, we account for this by some additional slack in the time between thekthand(k+1)thpulses, enabling nodes to reach consistent states even when the initial states are arbitrary. Any choice of parameters thus represents a trade-off between the frequency at which pulses can be issued and the fault-tolerance properties of the system. The following condition provides conservative bounds for the parametersTlink−,Tlink+,Tsleep−, andTsleep+, as a function of the number of faults and the inaccuracy of the implementation's local time measurements. We stress that, to ensure self-stabilization, the timers must be designed so that they expire withinTsleep+andTlink+time, respectively, even when started from an arbitrary internal state.Condition 2Timing constraintsFork∈N, definetmin(k):=mini∈[W](0,i)correct⁡{t0,i(k)}andtmax(k):=maxi∈[W](0,i)correct⁡{t0,i(k)}.An execution of Algorithm 1 has pulse separation timeS, if, for allk∈N, it holds thattmin(k+1)≥tmax(k)+S. For a given number of Byzantine faults f in the grid with stable skewσ(f), we defineTlink−(f):=σ(f)+εTlink+(f):=ϑTlink−(f)Tsleep−(f):=2Tlink+(f)+2d+Tsleep+(f):=ϑTsleep−(f)S(f):=Tsleep−(f)+Tsleep+(f)+εL+fd+.Here,ϑ≥1bounds the maximum clock drift, in the sense thatt′−t≤T′−T≤ϑ(t′−t)for all real-timest′≥twith clock readingsT′,T.Before we can cast the algorithm's self-stabilization properties into a theorem, we need to specify what it means for the HEX pulse propagation to have stabilized up to a certain layer.Definition 5Stabilized pulse propagationFor an execution of Algorithm 1 on the HEX grid, we say that layerℓ∈[L+1]is stable with skew at most σ in pulse k, if:•All layersℓ′∈[ℓ]are stable with skew at most σ in pulse k;Node(ℓ,i),i∈W, is not sleeping at timetmin(k)+ℓd−, and it does not memorize any trigger messages from correct neighbors at this time;Layer ℓ has skew at most σ in pulse k.Suppose that, given values f andσ(f), an execution ofAlgorithm 1satisfies the following prerequisites:•There are at most f Byzantine faulty nodes satisfyingCondition 1.The stable skew is at mostσ(f).The parametersTlink−,Tlink+,Tsleep−, andTsleep+inAlgorithm 1are chosen in accordance withCondition 2.The pulse separation time is larger thanS(f), as specified byCondition 2.Note that this, in particular, implies that all correct neighbors will satisfy the skew boundσ(f)in all pulsesk>L. In order to prove the theorem, we first show a helper statement saying that if all layers up to layer ℓ are stable in some pulse, they will satisfy the claim of the theorem in all subsequent pulses.Lemma 6Assume that the preconditions ofTheorem 2are satisfied and that all layersℓ∈[L+1],ℓ′∈[ℓ+1], are stable with skew at mostσ(f)in pulsek∈N. Then, these layers are also stable with skew at mostσ(f)in pulsek+1, and for each correct node(ℓ,i), there is a unique triggering timetℓ,i(k)during[tmin(k)+ℓd−,tmin(k+1)+ℓd−).ProofSince we have that all layersℓ′∈[ℓ+1]are stable, Lemma 5 shows that all nodes in these layers are triggered during[tmin(k)+ℓ′d−,tmax(k)+(ℓ′+fℓ′)d+]. For each node(ℓ′,i)in such a layer, lettℓ′,i(k)be the minimal such triggering time (we still need to establish that there is only one). Since the stable skew is at mostσ(f), for any node(ℓ′,i)with0≠ℓ′≤ℓ, the triangle inequality yields that its correct neighbors on layersℓ′andℓ′−1trigger within2σ(f)of each other. Hence, all trigger messages from correct neighbors are received within a time window of duration2σ(f)+ε. We haveTsleep−(f)>2Tlink−(f)>2σ(f)+ε, implying that nodes will not memorize any late pulse k trigger messages from correct neighbors after waking up. We thus conclude that, for each node(ℓ′,i),tℓ′,i(k)<tmin(k+1)+ℓ′d−is unique. WithTsleep:=Tsleep+(f)+Tsleep−(f), our assumptions yieldtmax(k)≤tmin(k+1)−S(f)<tmin(k+1)−Tsleep−εL−fd+.Hence, the upper bound on the pulse k triggering times of layerℓ′nodes established in Lemma 5 leads to(9)tℓ′,i(k)≤tmax(k)+(ℓ′+fℓ′)d+<tmin(k+1)−Tsleep−εL−fd++(ℓ′+fℓ′)d+≤tmin(k+1)−Tsleep+ℓ′d−.We thus observe that no node will be sleeping or have memorized any trigger messages from other correct nodes at timetmin(k+1)+ℓ′d−. Since we assumed thatσ(f)is a bound on the stable skew, the requirements of Definition 5 are met for pulsek+1and all layersℓ′∈[ℓ+1], as claimed.  □With this lemma, the proof of Theorem 2 boils down to showing that if layer ℓ is stable in pulse k, then layerℓ+1is stable in pulsek+1.Proof of Theorem 2We prove the theorem by induction on ℓ, where the hypothesis is that the claims of the theorem are satisfied by all layersℓ′∈[ℓ+1]. Forℓ=0, the statement is trivial. For the step from ℓ toℓ+1, repeated use of Lemma 6 reveals that it is sufficient to show that layerℓ+1is stable in pulseℓ+2.By the induction hypothesis and Lemma 5, no correct node in layer ℓ sends trigger messages during[tmax(ℓ+1)+(ℓ+f)d+,tmin(ℓ+2)+ℓd−]. Using exactly the same derivation as for Eq. (9) in the proof of Lemma 6, we find that any triggering message originating in a correct layer ℓ node must have arrived at any correct layerℓ+1node before timet:=tmin(ℓ+2)−(Tsleep+(f)+Tsleep−(f))+(ℓ+1)d−. We will complete the proof by showing that this entails that correct nodes(ℓ+1,i)will neither sleep nor memorize trigger messages from correct nodes at timetmin(ℓ+2)+(ℓ+1)d−.To this end, suppose that starting from the above time t, nodes on layerℓ+1do not receive trigger messages from correct nodes on the previous layer. By Algorithm 1, nodes will forget messages that arrived more thanTlink+(f)time ago. Thus, the latest time when a correct node(ℓ+1,i)in layerℓ+1could be triggered due to a remembered message from some correct neighbor on layer ℓ is smaller thant+Tlink+(f).Hence, consider the case that(ℓ+1,i)has a faulty neighbor on layer ℓ. W.l.o.g., assume that the faulty neighbor is node(ℓ,i+1)(the other case is symmetric). By the above reasoning,(ℓ+1,i)can only be left-triggered at or after timet+Tlink+(f), which in addition requires a memorized trigger message from(ℓ+1,i). Thus, if neither(ℓ+1,i)nor(ℓ+1,i+1)are triggered during[t−d+,t+Tlink+(f)), neither node can be triggered anymore: Condition 1 guarantees that both nodes have no other faulty neighbor than(ℓ,i+1), and the above reasoning applies also to(ℓ+1,i).Therefore, assume that one of them, say(ℓ+1,i+1), is triggered at timetℓ+1,i+1∈[t−d+,t+Tlink+(f)). It will not wake up (and therefore not be triggered again) before timetℓ+1,i+1+Tsleep−(f). Node(ℓ+1,i)receives the trigger message from(ℓ+1,i+1)by timetℓ+1,i+1+d+and therefore either (a) forgets it by timetℓ+1,i+1+Tlink+(f)+d+or (b) is triggered during[tℓ+1,i+1,tℓ+1,i+1+Tlink+(f)+d+). If(ℓ+1,i)is triggered, its corresponding trigger message to(ℓ+1,i+1)arrives by timetℓ+1,i+1+Tlink+(f)+2d+≤tℓ+1,i+1+Tsleep−(f). This message thus arrives at(ℓ+1,i+1)before it wakes up again. When(ℓ+1,i+1)wakes up, it clears its memory and will not be re-triggered before(ℓ+1,i)is triggered again (or the next pulse arrives on layer ℓ). But(ℓ+1,i)cannot be triggered again: If it was not triggered (Case (a)), it forgot any previous trigger messages, and if it was (Case (b)), it clears its memory upon waking up. Consequently,(ℓ+1,i+1)cannot be triggered again either.Overall, no node on layerℓ+1is triggered after timetℓ+1,i+1+Tlink+(f)≤t+2Tlink+(f)+d+or receives trigger messages from correct nodes after timet+2Tlink+(f)+2d+≤t+Tsleep−(f)(until timetmin(k+1)+(ℓ+1)d−). Hence, all nodes are awake by timet+Tsleep−(f)+Tsleep+(f)>t+Tsleep−(f)+Tlink+(f)and have forgotten all spurious messages. By the previous observations, this concludes the proof.  □As mentioned earlier, the analytic results obtained in the previous sections are limited to worst-case skews. Hence, we conducted extensive simulation experiments to complement them with representative statistical data. This data reveals the following major facts about HEX:(1)Average skews considerably smaller than worst-case. The quite fancy scenarios required for establishing the worst-case skews in Theorem 1 already suggested that they are very unlikely to occur in practice. Indeed, we were not able to generate neighbor skews that came close to the worst case under uniformly and independently distributed link delays.Small, localized fault effects. As argued in Section 3.3, HEX should implicitly confine the effects created by a faulty node to a small neighborhood. Our simulation results revealed that faults typically affect direct neighbors only, and become invisible after one additional hop. This is true even for clustered crash faults and multiple (separated) Byzantine faults.Stabilization times much smaller than guaranteed by theoretical analysis. The layer-wise stabilization used for bounding the worst-case stabilization time in Section 3.3 assumes an involved worst-case scenario on each layer, which appears to be very unlikely in practice. Simulations of the original version [33] of the HEX algorithm already revealed typical stabilization times that are much smaller than the predicted worst case. The link timeouts added in Algorithm 1 cause HEX to reliably stabilize within two clock pulses, even in scenarios with multiple faults.Our simulation framework has been built around Mentor Graphics® ModelSim 10.1d, which allows accurate digital timing simulations of circuit designs specified in VHDL (Very High Speed Integrated Circuit Hardware Description Language). It is used to simulate an entire HEX grid, which consists of multiple instances of a VHDL implementation of Algorithm 1 embedded into a custom testbench. The latter has the following purposes:(1)Set the grid size and instantiate the corresponding number of nodes as well as interconnecting wires.Provide the layer 0 clock sources (i.e., generate the clock pulse of node(0,i),i∈[W]) at timet0,i,ρin simulation run ρ, with some pre-selected skews. Clock sources for a single pulse and for multiple pulses per run are supported.Control the individual link delays during the simulation. Both random delays (uniform within[d−,d+]) and deterministic delays are supported.Control fault injection during the simulation: links can be declared correct, Byzantine (choose output constant 0 resp. 1 corresponding to no resp. fast triggering), or fail-silent (output constant 0); declaring a node Byzantine or fail-silent is equivalent to doing so for each of its outgoing links. The selection of faulty nodes and/or links can be done deterministically or randomly in different simulation runs ρ, but remains fixed for all pulses generated in a multi-pulse simulation run ρ.The VHDL implementation of Algorithm 1 consists of a few fairly simple design entities only: An asynchronous state machine, a threshold gate, sleep and link timers driven by start/stoppable oscillators, and resettable memory flags. The asynchronous state machine, shown in Fig. 7a, consists only of three states, which are visited cyclically: In the (initial) ready state, it waits for the trigger condition in Algorithm 1 to become true. The state machine then proceeds to the firing state, where it emits a pulse, and then moves into the sleeping state. One resettable memory flag per incoming link is used to memorize the occurrence of a pulse from the respective neighbor. It is reset when the state machine takes the transition from the sleeping state to ready, or when the respective link timer generates a timeout. Fig. 7b provides the simple state machine for the memory flag: Starting from the (initial) ready state, it waits for the reception of a trigger message, which results in a transition to the state memorize and the setting of the corresponding memory flag. After the timeoutTlink, the memory flag is reset and the state machine returns to the ready state.The implementation of the above state machine is completely asynchronous and has been generated using the Petrify tool [35]; the designs of the timers, start/stoppable oscillators, and memory-flags are based on the designs provided in [36]. The complete HEX node was synthesized with Synopsys® Design Compiler version C-2009.06-SP4, using the UMC 90 nm standard cell library [37]. Note that we had to augment this library by a custom Muller C-Gate [38] developed in the context of the DARTS project [30,39]. The detailed timing analysis of the HEX node implementation revealed an end-to-end switching delay, without wire delays, in the interval[0.161,0.197]ns.Although HEX is, by design, metastability-free in the absence of failures, we cannot rule out the possibility that faulty nodes cause metastable upsets [40] of state-holding devices such as memory flags. However, as laid out in more detail in [36], the probability that a faulty node produces a signal transition within the picosecond-range window of vulnerability is extremely small and can be further decreased by means of synchronizers [11] or elastic pipelines [38]. In our simulations, we may hence safely exclude metastability-inducing behavior.Using our testbed, we conducted the following types of simulation experiments:(A) Statistical evaluation of the neighbor skews. These experiments require simulation runs involving only a single pulse propagating through the HEX grid. The primary quantities of interest in simulation run ρ are:•the (absolute) skews|tℓ,i,ρ−tℓ,i−1,ρ|between neighbors(ℓ,i)and(ℓ,i−1)in the same layer ℓ,the (signed) skewstℓ,i,ρ−tℓ−1,i,ρandtℓ,i,ρ−tℓ−1,i+1,ρof every node(ℓ,i),ℓ>0, relative to its direct layerℓ−1neighbors(ℓ−1,i)resp.(ℓ−1,i+1).Forop∈{avg,q95,max⁡}, we define the average, 95%-quantile, and maximum (absolute)•layer ℓ intra-layer skew in run ρ:σℓ,ρop:=opi∈[W]{|tℓ,i,ρ−tℓ,i+1,ρ|};intra-layer skew in run ρ:σρop:=opi∈[W],ℓ∈[L+1]∖{0}{|tℓ,i,ρ−tℓ,i+1,ρ|};intra-layer skew in simulation set R:σop:=opi∈[W],ℓ∈[L+1]∖{0},ρ∈R{|tℓ,i,ρ−tℓ,i+1,ρ|}.inter-layer skew between layer ℓ andℓ−1in run ρ:σˆℓ,ρop:=opi∈[W]Tℓ,i,ρ;inter-layer skew in run ρ:σˆρop:=opi∈[W],ℓ∈[L+1]∖{0}Tℓ,i,ρ;inter-layer skew in simulation set R:σˆop:=opi∈[W],ℓ∈[L+1]∖{0},ρ∈RTℓ,i,ρ.(B) Statistical evaluation of the stabilization time. These experiments require multiple pulses. Essentially, the system is started, with every node in an arbitrary state, and then attempts to forward a sequence of pulses generated at layer 0 (with bounded skew and a certain separation time). Using post-processing of the recorded triggering times, we compute the stabilization time as the number of pulses needed for the intra- and inter-layer skews to persistently fall below a layer-dependent threshold.Both types of experiments were performed with and without faulty nodes of different types. Note that the triggering times of faulty nodes are of course not considered when computing the inter- and intra-layer skews.We conducted a suite of simulations that complement the analytic intra- and inter-layer worst-case skew bounds given in Theorem 1 by statistical data. First, Fig. 8resp. Fig. 9show a 3D plot of a typical pulse propagation wave in a fault-free grid withL=50andW=20, end-to-end delays in[7.161,8.197]ns(ε=1.036ns), and layer 0 skews all 0 resp. ramping up/down byd+. The end-to-end delays result from combining the assumed wire and routing delays with the switching delay bounds. The latter were determined by the ModelSim timing analysis of the HEX node to lie within[0.161,0.197]ns. For the wire and routing delays, we more or less arbitrarily assumed a value within[7,8]ns. Since the absolute values do not really matter for our simulations, our choice just reflects the facts that (i) communication delays dominate switching delays and (ii) that the delay uncertainty ε is not too large compared tod−in modern hardware devices. Throughout this section, we hence assume delay values that are uniformly distributed within[d−,d+]=[7.162,8.197]ns. The grid (sliced between widthW−1and0≡Wfor readability, and truncated to the first 30 layers) lies in the(ℓ∈[L+1],i∈[W])plane and the z-dimension shows the triggering timetℓ,iof the corresponding node(ℓ,i). To further improve readability, we connected all points(ℓ,i,tℓ,i)and(ℓ,i+1,tℓ,i+1),i∈{0,…,W−2}. It is apparent that the wave propagates evenly throughout the grid, nicely smoothing out the initial skew differences.Table 1shows average(σavg), 95%-quantile(σq95), and maximal(σmax)intra-layer and minimal(σˆmin), 5%-quantile(σˆq5), average(σˆavg), 95%-quantile(σˆq95), and maximal(σˆmax)inter-layer skews, respectively, in the absence of faulty nodes and taken over all nodes and 250 simulation runs, in the setting described above.Four different choices for the layer 0 skews between neighbors were used: The triggering times of the layer 0 nodest0,iare (i) all 0 (resulting inσ0=0and skew potentialΔ0=0), (ii) uniformly in[0,d−](i.e.,σ0≈d−andΔ0=0), (iii) uniformly in[0,d+](i.e.,σ0≈d+andΔ0≈ε), and (iv) ramping-up/down byd+:t0,i+1=t0,i+d+for0≤i<W/2andt0,i+1=t0,i−d+forW/2≤i<W−1, i.e.,σ0=d+andΔ0≈Wε/2=10.36. Note that (iii) resp. (iv) reasonably model the average case and worst-case input provided by a layer 0 clock generation scheme with neighbor skew boundd+, respectively.Inspecting Table 1 reveals that not a single instance in the collected data showed a skewσmax>d+=8.197nsresp.σˆmax>2d+=16.394ns. In scenarios (i) to (iii),σˆmin≈d−, i.e., all nodes were always triggered by their lower neighbors (obviously, this latter property is violated in scenario (iv) due to the excessive initial skews). A comparison with the worst-case results of Theorem 1, which boundσmax≤21.63nsand[σˆmin,σˆmax]⊆[−14.47,29.83]nsfor scenarios (i) and (ii), reveals a much better typical skew in every scenario.The histograms of the skew distributions in scenario (i) are shown in Fig. 10; scenarios (ii) and (iii) look similar. One observes a sharp concentration with an exponential tail. Only in scenario (iv), as already indicated by the large values ofq95in Table 1, there is a visible cluster near the end of the tail that is again caused by the large initial skews, see Fig. 11.Given the considerable differences between the minimum (σˆmin) and maximum (σˆmax) inter-layer skew in Table 1, in conjunction with its non-zero bias, the question of layer-dependence arises. Fig. 12providesσˆℓmin,σˆℓavgandσˆℓmax, along with their standard deviations, over the layersℓ∈[30]∖{0}in case of scenario (iii) resp. (iv). The diagrams reveal that the fairly discrepant skews observed in lower layers start to smooth out after layerW−2, in accordance with Lemma 3, which shows that the behavior observed in Fig. 9 is very typical. To avoid cluttering the diagrams, we omittedσˆℓq5andσˆℓq95, which are close toσˆℓminresp.σˆℓmax.Next, we back up the results of our analysis in Section 3.3: We consider f uniformly placed failures under the constraint that Condition 1 holds. In each run, each Byzantine node randomly selects its behavior on each outgoing link as either constant 0 (fail-silent) or constant 1. A typical pulse with a single faulty node(1,19), marked as a red dot, is shown in Fig. 13; Fig. 14depicts a sample scenario with 5 Byzantine faulty nodes.In Table 2, we list the statistical results forf=1. One observes that the behavior for scenarios (i) to (iii) is very similar, hence we will showcase the main points by examining scenario (iii) and (iv) more closely.In Figs. 15aresp. 15c, we show box-plots of minimum,5%-quantile, average,95%-quantile, and maximum intra- resp. inter-layer skews from 250 runs withf∈[6]faults for scenario (iii).99Note that for the absolute values of the intra-layer skew, the minimal and5%-quantile values are close to zero and, thus, of little relevance.A comparison of valuesf>0withf=0reveals that skews increase moderately. In particular, the skews increase substantially slower than the derived worst-case bound of roughly5fd+. Furthermore, Figs. 15b and 15d show the same data, except that, in addition to the faulty nodes themselves, also their outgoing 1-hop neighbors are discarded from the data set (h=1). Here, a comparison of the casef=0and anyf>0reveals that all fault effects have essentially disappeared or are mitigated notably, which confirms that HEX exhibits strong fault-locality. Concerning fail-silent nodes, all results are qualitatively similar, albeit with smaller skews.Fig. 16gives the same plots for scenario (iv). Apart from the expected increase in skews, we observe two points worth mentioning. First, a single fault essentially causes the “worst-case” skew. This demonstrates that, as already indicated by scenario (iii), skew effects of multiple faults do not accumulate, or do so in a very limited way. Second, the maximal intra-layer skews typically exceed the inter-layer skews. An explanation for this behavior is provided in Fig. 17: Intuitively, for “ramped” triggering times generated at layer 0, the pulse propagates “diagonally” (cf. Fig. 9) instead of “vertically” (= layer by layer). This limits the power of the HEX grid to mitigate Byzantine behavior, as it is implicitly optimized for propagating pulse waves vertically.We now present the results of the multi-pulse simulations conducted for evaluating stabilization time statistics. The same scenarios as in our single-pulse experiments were used here. For the timeouts and the pulse separation timeS, we used nominal values that are compatible with the (scenario-dependent) maximum skew observed forf∈[6]Byzantine or fail-silent nodes. These skews where determined via the previous simulations, plus a slack ofd+accounting for the fact that we work with a statistical sample showing an exponential tail. Timeouts and pulse separation times were computed according to (a modified1010Condition 2 does not take into account that triggering signals in our HEX implementation have non-zero duration, resulting in slightly increased values.version of) Condition 2, assumingϑ=1.05. The results are shown in Table 3.For each scenario, fault-number, and fault-type, we executed 250 simulation runs. For each run, f faulty nodes were placed uniformly at random under the constraint that Condition 1 held. Then, starting with all non-faulty nodes in random initial states, 10 consecutive pulses were generated, where placement and behavior of faulty nodes remained fixed during an individual run. For each run ρ, the firing timestℓ,i,ρ(k)of all pulses1≤k≤10were recorded; thanks to the large pulse separation times, unambiguously assigning a corresponding pulse number to a triggering time (after initial spurious triggering events ceased) was easy.Due to the fact that our simulations only cover the first 10 pulses, it could occur that some runs do not stabilize (yet). Even worse, we cannot rule out the possibility that a run which seems stable violates the skew bounds in some later pulse. However, our actual experiments showed that non-stabilizing runs occur only in scenarios in which the a priori chosen skew boundσ(f,ℓ)was smaller than the maximal skews reported in Table 2, i.e., whereσ(f,ℓ)was too small. We are hence confident that our stabilization time estimates can be considered representative for realistic skew bounds.Our stabilization time estimate for each run is computed (off-line) as the minimal pulse k with the property that the maximal layer ℓ intra- resp. inter-layer skew, for every layerℓ∈[L+1], is below the a priori chosen skew boundσˆ(f,ℓ)resp.σ(f,ℓ). As the former directly depends on the latter (cf. Theorem 1), we used 4 different choicesC∈{0,1,2,3}for the skew bound, obtained by settingσ(f,ℓ)=(4−C)d+forC∈{1,2,3}resp. the very conservative skew bounds resulting from Lemma 5 forC=0.Fig. 18aresp. Fig. 19ashows both the average and the average + standard deviation of the stabilization times for scenario (iii) resp. (iv) for Byzantine faults. Similarly, Fig. 18b resp. Fig. 19b shows scenario (iii) resp. (iv) in case of fail-silent faults. By and large, unless C is chosen aggressively large, resulting in too smallσ(f,ℓ), HEX usually stabilizes after the very first pulse. For large C, the average stabilization time estimates go up moderately. Given that the number of simulation runs that did not stabilize within 10 pulses was low (<25%even in the most unfavorable scenario), however, we can safely infer that the typical stabilization time of HEX is indeed much lower than the worst-case stabilization time boundL+1established in Theorem 2. The results verify that the already good self-stabilization properties of the original HEX algorithm reported in [32] are further improved by the additional link timeouts.Finally, we also computed the stabilization time estimates for the very same scenarios after also discarding the single-hop outgoing neighbors of faulty nodes (h=1). In this case, HEX turned out to stabilize after the very first pulse in every run. This again confirms the strong fault locality property claimed for the HEX grid.

@&#CONCLUSIONS@&#
We proposed a candidate for a scalable and fault-tolerant alternative for clock distribution in VLSI circuits, multi-core processors, and other hardware devices. Our approach supports multiple synchronized clock sources and is self-stabilizing even in the presence of a large number of non-clustered Byzantine failures of both clock sources and HEX nodes. Theoretical worst-case analysis and elaborate simulation experiments have been used to show that HEX guarantees a small skew between neighbors in the grid.Part of our current/future work on HEX is to explore the properties of alternative topologies, which may be chosen to improve clock skews and/or resilience. Moreover, we are working on self-stabilizing Byzantine fault-tolerant higher-level services that may benefit from the enticing properties of HEX.Recall that the various cases encountered in our analysis (i.e., mainly in Lemma 4) are always tackled by the following generic pattern:•Consider a causal path (typically a left zig-zag path) leading to a node(ℓ,i)on some layer ℓ (“fast node”), which is supposed to be triggered much earlier than its neighbor(ℓ,i+1)on the same layer (“slow node”).Derive a lower bound on the triggering time of the fast node in relation to the triggering times of the nodes on the causal path, from the length of the path and the fact that delays are at leastd−.Derive an upper bound on the triggering time of the slow node, from the bounds on the triggering times of the nodes on the causal path, the fact that delays are at mostd+, and bounds on the skew in some previous layers.We will follow the general structure of the proof of Lemma 4 in terms of the discussed cases, where we also generalize Lemma 2 once it is needed. It is straightforward to see that similar arguments apply to Lemma 3 and Corollary 1, so we will omit these from the discussion.Case 1 V-shaped skews (Fig. 4a):tλ,i+1≤tλ,i+d+for some maximalλ≥λ0Case 1 implicitly uses a simple causal path construction, which we now need to make explicit. Since the case considers columns i andi+1only, we distinguish two subcases in which we need to modify the approach.Case 1a: The faulty node is(ℓ′,i+1)for someℓ′∈{λ0,λ0+1,…,ℓ−1}We backtrace the “rightmost” causal (not necessarily zig-zag) path ending in(ℓ,i), i.e., if the current source of the path is right-triggered, the incoming link from the right neighbor is added; if it is centrally triggered, the link from the lower right neighbor; otherwise, the one from the lower left neighbor. Several possibilities exist:(1)We reach columni+1in a layerλ>ℓ′. In this case, eithertλ,i+1≤tλ,i+d+(if((λ,i+1),(λ,i))is in the causal path) ortλ+1,i+1≤tλ+1,i+d+(if((λ,i+1),(λ+1,i))is in the causal path). We can hence proceed exactly as in the fault-free setting in Case 1 of Lemma 4.The causal path reaches the faulty node, i.e., we would add one of the links((ℓ′,i+1),(ℓ′+1,i))or((ℓ′,i+1),(ℓ′,i)). In the first case,(ℓ′+1,i)must have been centrally triggered. We add the link((ℓ′,i),(ℓ′+1,i))instead and resume the construction. In the second case,(ℓ′,i)must have been right-triggered. We add the link((ℓ′−1,i+1),(ℓ′,i))instead and resume the construction, which will eventually terminates in one of the following two ways:(2a)We reach columni+3at some layerλ≥λ0(see Fig. A.22afor an example).We reach layerλ0−1before we reach columni+4.Regarding (2a), we know that the causal path to(ℓ,i)originates in some layerλ≥λ0. By the same induction as used in Lemma 2, one can show that every node on thekthleft-diagonal on or to the right of the causal path has a triggering time that is at mostkd+more than the maximal triggering time of any node on the causal path on diagonal 0. In fact, since the causal path is not necessarily a triangular left zig-zag path here (see Fig. A.22a), the induction itself works only for nodes on or to the right of the causal path which are also above horizontal segments of the causal path. However, the direct proof that establishes the induction basis also shows that the assertion trivially holds for nodes on these horizontal segments also.For the, in terms of the lower bound ontℓ,i, worst-case causal path, which goes from(λ,i+3)via(λ,i+1)and(λ+1,i)to(ℓ′,i), the induction starts at the left-diagonal(λ,i+1)to(λ+1,i)with maximal triggering timetλ+1,i. Observe that node(ℓ′,i+3)isℓ′−λ+2diagonals from, e.g., node(λ,i+1). It hence follows that all correct nodes in columnsi+1,i+2, andi+3in layers λ toℓ′that are on or to the right of the causal path—in particular, nodes(ℓ′,i+2)resp.(ℓ′,i+3)—will be triggered by timetλ+1,i+(ℓ′−λ+1)d+resp.tλ+1,i+(ℓ′−λ+2)d+. Consequently,(ℓ′+1,i+1)will be triggered by timetλ+1,i+(ℓ′−λ+4)d+, and it follows thattℓ,i+1≤tλ+1,i+(ℓ−λ+3)d+. Since we have thattℓ,i=tλ+1,i+(ℓ−λ−1)d−, comparison with Case 1 of Lemma 4 reveals that the resulting skew isO(d+)larger, so this case is covered.To deal with (2b), we can argue similarly, provided that, for some layerλ≥λ0, nodes(λ,i+1),(λ,i+2), and(λ,i+3)are triggered before or shortly after(λ,i), i.e., thattλ,i+k≤tλ,i+k−1+d+for1≤k≤3. If this holds true, we are essentially in Case 1 of Lemma 4, except that the causal path leading to(ℓ,i)resp. to(ℓ,i+1)need not start at(λ,i)resp.(λ,i+1)but rather at(λ,i+k−1)resp.(λ,i+k)for some1≤k≤3. Note that this shift results from the need to avoid the faulty node in the causal path construction; as in (2a), it changes the resulting skew by at mostO(d+).Still, there is also the possibility that there is noλ≥λ0wheretλ,i+k≤tλ,i+k−1+d+for1≤k≤3holds. We will deal with these cases (which correspond to Case 2 and 3 in Lemma 4) below.Case 1b: The faulty node is(ℓ′,i)for someℓ′∈{λ0,λ0+1,…,ℓ−1}In this event, we use essentially the same approach as for Case 1a, except that we shift it one column to the left: Now the construction of the causal path might encounter a left-triggered node whose lower-left neighbor is the faulty node, forcing the construction to evade to columni−1; in turn, columni+3is not needed any more to circumvent the faulty node when deriving an upper bound ontℓ,i+1. See Fig. A.22b for an example.Case 2 Non-V-shaped skews, non-triangular (Fig. 4c): Case 1 does not apply andplefti+1→(ℓ,i)starts at some node(0,j0), forj0≠i+1If the above Subcase (2b) of Case 1a does not apply, the causal path to the fast node(ℓ,i)can be constructed independently of the causal path to the slow node(ℓ,i+1): For everyλ∈{λ0,…,ℓ}, there are neighbors (usually(λ,i)and(λ,i+1), except for the possible column shift needed for circumventing the faulty node) with a difference in triggering times of more thand+.When constructing the left zig-zag path ending at(ℓ,i), the faulty node may be approached either via some correct node's left link or lower-right link: In the former case, we evade via the other causal link to the lower-left neighbor. If we would reach the faulty node via the lower-right link, we first backtrack/go one hop to the right before we go down-right and finally down-left (see Fig. 6). Clearly, this makes the causal path shorter and thereby decrease the triggering time bound for the fast node by at mostO(d−). The latter is of course only possible if the faulty node is in a column smaller than i.If the faulty node is in column i ori+1, however, which led to the index shift byk∈{1,2,3}mentioned in (2a) above, we need to constructplefti+2→(ℓ,i)orplefti+3→(ℓ,i)instead ofplefti+1→(ℓ,i). In these left zig-zag paths, we can pass around the faulty node to the right. Note that this may actually increase the fast node's triggering time bound byO(d−), albeit the resulting decrease of the skew bound is by far outweight by the simultaneous increaseO(d+)of the triggering time of the slow node (which is caused by circumventing the faulty node in the causal path to(ℓ,i+1), as also discussed in (2a) above).The same is true if the faulty node lies in the triangular region with corners(0,i+1),(0,i+1+λ0), and(λ0,i+1)used in Case 2 (Fig. 4c), see Fig. 6. In fact, even a fail-silent node could not prevent that(λ0,i+1)is triggered quickly here: By adding a few nodes, if necessary, and arguing that the faulty node can be bypassed by right- or left-triggering, at mostO(d+)time is lost. This finally covers Case 2 of Lemma 4.Case 3 Non-V-shaped skews, triangular (Fig. 4b): Neither Case 1 nor Case 2 applyThe reasoning for circumventing the faulty node in the construction of the (now triangular) left zig-zag path in Case 3 of Lemma 4 is the same as for Case 2 above. For computing the triggering time of the fast node, though, we also need to adapt Lemma 2 to cope with a faulty node within the part of the triangle with corners(ℓ′,i+1),(λ0,i+1−ℓ′), and(λ0,i+1)in Fig. 4b that is to the right ofplefti+1→(ℓ,i). Note that the latter possibly needed to evade the faulty node as well, see Fig. A.23a.Recall that the proof of Lemma 2 proceeds by induction over the left-diagonals of the triangle. As already argued in (2a), the modified shape of the zig-zag path does not invalidate the statement of the lemma. Moreover, if the faulty node has column index smaller than i, its right and upper right neighbors will be centrally and right-triggered, respectively, at mostO(d+)later (if they are not triggered otherwise earlier) than indicated by the bounds derived in the original Lemma 2. Examples of the two basic cases that may occur here are shown in Fig. A.23. This covers all possibilities for Case 3 of Lemma 4, except the ones where the faulty node has column index i ori+1. In this event, as already argued before, we fall back to consideringplefti+2→(ℓ,i)orplefti+3→(ℓ,i), which again allows the causal path leading to the slow node to pass the faulty node on its right.