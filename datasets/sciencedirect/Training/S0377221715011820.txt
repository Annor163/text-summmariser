@&#MAIN-TITLE@&#
Optimal restricted due date assignment in scheduling

@&#HIGHLIGHTS@&#
We study an integrated scheduling and due date assignment problem.Each job can be assigned a different due date and its value is upper bounded.The criteria include earliness, tardiness and due date assignment penalties.We show that the problem is equivalent to a two stepwise weighted tardiness problem.We study several special cases and mainly focus on providing approximation results.

@&#KEYPHRASES@&#
Scheduling,Due date assignment,Approximation algorithms,Earliness,Tardiness,

@&#ABSTRACT@&#
In classical scheduling problems it is common to assume that the due dates are predefined parameters for the scheduler. In integrated systems, however, due date assignment and scheduling decisions have to be carefully coordinated to make sure that the company can meet the assigned due dates. Thus, a huge effort has been made recently to provide tools to optimally integrate due date assignment and scheduling decisions. In most cases it is common to assume that the assigned due date(s) are not restricted. However, in many practical cases, assigning due dates too far into the future may violate early agreements between the manufacturer and his customers. Thus, in this paper we extend the current literature to deal with such a constraint. This is done by analyzing a model that integrates due date assignment and scheduling decisions where each job may be assigned a different due date whose value cannot exceed a predefined threshold. The objective is to minimize the total weighted earliness, tardiness and due date assignment penalties. We show that the problem is equivalent to a two stepwise weighted tardiness problem, and thus for a large set of special cases it is stronglyNP-hard, even when the scheduling is done on a single machine. We then provide several special cases that can be solved in polynomial time, and present approximation results for a slightly modified (and equivalent) problem on various machine settings.

@&#INTRODUCTION@&#
Objective functions that include both earliness and tardiness penalties are now very popular in the scheduling literature due to the increasing interest in Just-in-Time (JIT) production in industry. When due dates are given in advance the most common objective in a JIT scheduling environment is to find a schedule S that minimizes(1)Z(Sa)=∑j=1n(βjEj+γjTj),whereJ={1,…,n}is the set of n jobs to be scheduled, and for any job j ∈ J, djis the due date, and βjand γjare nonnegative parameters representing the per unit earliness and tardiness costs, respectively. Moreover, for a given schedule S, Cjrepresents the completion time of job j;Ej=max{0,dj−Cj}represents the earliness of job j; andTj=max{0,Cj−dj}represents the tardiness of job j. Scheduling problems with the objective of minimizing Z(S) in (1) are usually referred to as earliness-tardiness scheduling problems. Such problems arise in a scheduling environment where customers are not interested in receiving their jobs either earlier or later than the due date. Thus, if a job is finished prior its due date, it has to be held in inventory until that date. Consequently, this job incurs an earliness cost depending on the length of time it is held in inventory. This earliness penalty cost can result from deterioration, storage, insurance, etc. On the other hand, if a job is delivered after the due date, it incurs a tardiness cost that depends on how tardy the job is. The tardiness penalty can result from customer dissatisfaction, contract fines, and exposure to potential loss of reputation (Chen, 1996).Earliness-tardiness scheduling problems have attracted the attention of many researchers (see, e.g., Sundararaghavan and Ahmed, 1984; Hall and Posner, 1991; Hall, Kubiak, and Sethi, 1991; Hassin and Shani, 2005; Davis and Kanet, 1993; Sivrikaya-Serifoğlu and Ulusoy, 1999 and Sourd and Kedad-Sidhoum, 2008). A survey on those problems can be found in Baker and Scudder (1990) and Lauff and Werner (2004). In all these papers, the main assumption is that due date quotation and scheduling decisions are made separately. Thus, due dates are given in advance as predefined parameters. In an integrated (centralized) system, however, due dates are determined by taking into account the ability to meet them. This is why an increasingly large number of recent studies view due date assignment (DDA) as part of the scheduling process and show how the ability to control due dates can be a major factor in improving system performance (see Gordon, Proth, and Strusevich, 2004 and Kaminsky and Hochbaum, 2004 for extensive surveys on this subject).In a JIT scheduling environment where both due date assignment and scheduling decisions are integrated, it is common to include a due date assignment penalty within the objective function. This penalty reflects the fact that promising delivery dates too far into the future may force a company to offer price discounts in order to retain its business. In fact, the most common objective in the scheduling literature involving DDA decisions (see, e.g., Seidmann, Panwalkar, and Smith, 1981; Panwalkar, Smith, and Seidmann, 1982; Chen, 1996; Shabtay and Steiner, 2006 and Shabtay and Steiner, 2008; Mosheiov and Yovel, 2006; Li, Ng, and Yuan, 2011 and Drobouchevitch and Sidney, 2012) is to find a schedule S and a set of due datesd=(d1,d2,…,dn)that minimizes(2)Z(S,d)=∑j=1n(αjmax{0,dj−Aj}+βjEj+γjTj),where for job j ∈ J, αjis a nonnegative parameter representing the per unit lead time cost, and Ajrepresents the lead time that is considered to be acceptable (and thus there is no lead time cost if the due date is set to be less than or equal to Aj).Several methods to assign due dates have been considered in the literature. The most commonly used ones are (i) the common DDA method (usually referred to as the CON DDA method), where all the jobs are assigned the same due date; (ii) the slack due date assignment method (usually referred to as the SLK DDA method), where the jobs are given an equal flow allowance that reflects an equal waiting time; and (iii) the unrestricted due date assignment method (usually referred to as the DIF DDA method), where each job can be assigned a different due date. A common assumption is that the assigned due dates (in the DIF method) or the common due date or slack values (in the CON and SLK methods) are not restricted. However, in many practical cases, assigning a due date too far into the future may not be acceptable or may even violate an earlier agreement between the manufacturer and its customers. Thus, in this paper we extend the literature devoted to the DIF DDA by including a limitation on the assigned due dates. We do this by analyzing a set of scheduling problems in which the objective is to find a schedule S and a set of due datesd=(d1,d2,…,dn)that minimizes the objective in (2), subject to the condition that(3)dj≤d¯jforj=1,…,n,whered¯jrepresents an upper limit on the assigned due date for job j.For ease of presentation, we use the classical X|Y|Z three-field notation introduced by Graham, Lawler, Lenstra, and Rinnooy Kan (1979) when referring to each scheduling problem. The X field describes the machine environment, with X ∈ {1, Pm, Qm, Rm, Fm, Jm, Om}, whereX=1implies that the scheduling is done on a single machine;X=Pmimplies that the scheduling is done on a set of m identical parallel machines;X=Qmimplies that the scheduling is done on a set of m uniform machines working in parallel;X=Rmimplies that the scheduling is done on a set of m unrelated machines working in parallel; andX=Fm,X=JmandX=Omrefer to flow-shop, job-shop and open-shop scheduling systems, respectively. In all the above cases, it is assumed that m is fixed, i.e., that the number of machines in the shop is not part of the instance. If, on the other hand, the number of machines is part of the instance, we remove the ``m′′ from the X field, such that, for example,X=Pindicates that the scheduling is done on a set of m identical parallel machines, where m is not fixed. The Y field includes the set of job-processing characteristics and constraints. In our frameworkY={Y¯,DIF,dj≤d¯j},where DIF implies that the due dates are assignable according to the DIF DDA method, anddj≤d¯jimply that the assigned due date for job j cannot exceedd¯j.Y¯is the set of all other job-processing characteristics and constraints (excluding DIF anddj≤d¯j). This set (Y¯) may include entries such as rjwhich means that jobs may not be available from time zero; pmtn which means that preemption is allowed; prec which means that there are precedence constraints between jobs; and sp-graph which means that there is a precedence constraint relation that can be represented by a series-parallel graph. The Z field contains the objective function for the scheduling problem, and it will usually refer to the one defined in (2).Seidmann et al. (1981) were the first to study scheduling problems using the DIF DDA method. They focus on the case where (i) the scheduling is done on a single machine; (ii) the per unit earliness, tardiness and due date assignment costs are job-independent (that isαj=α,βj=βandγj=γforj=1,…,n); (iii) the acceptable lead times are job-independent (that isAj=Aforj=1,…,n); and (iv) there is no limitations on the value of the assigned due dates. They showed that the resulting1|DIF|∑j=1n(αmax{0,dj−A}+βEj+γTj)problem is solvable in O(nlog n) time. Shabtay and Steiner (2008) extended the analysis in Seidmann et al. (1981) to capture various multi-machine settings as well. They showed that for any machine environment X, theX|DIF|∑j=1n(αmax{0,dj−A}+βEj+γTj)problem is equivalent to theX|dj=A|w∑j=1nTjproblem, where A is a fixed common due date for all jobs andw=min{α,γ}. Based on this equivalence they concluded that (i) problemsPm|DIF|∑j=1n(αmax{0,dj−A}+βEj+γTj)andQm|DIF|∑j=1n(αmax{0,dj−A}+βEj+γTj)are ordinaryNP-hard; (ii) thePm|DIF|∑j=1n(αdj+βEj+γTj)problem is solvable in O(nlog n) time; (iii) theRm|DIF|∑j=1n(αdj+βEj+γTj)is solvable in O(n3) time; and that (iv) problemsF2|DIF|∑j=1n(αdj+βEj+γTj)andO2|DIF|∑j=1n(αdj+βEj+γTj)are stronglyNP-hard. Note, however, that based on the equivalence between theX|DIF|∑j=1n(αmax{0,dj−A}+βEj+γTj)andX|dj=A|w∑j=1nTjproblems (w=min{α,γ}), when eitherα=0orγ=0,we have that the objective value is equal to zero independent of the job schedule. The reason is that whenα=0,by settingdj=Cjforj=1,…,nwe can obtain a solution with a zero value, which is independent of the actual Cjvalues (i.e., independent of the job schedule). Similarly, whenγ=0we can obtain a solution with a zero objective value by settingdj=0forj=1,…,n. Here as well the result is independent of the actual schedule.Shabtay and Steiner (2006) studied the extended version of the single machine problem, where the per unit earliness, tardiness and due date assignment costs are job-dependent as is the acceptable lead time. They proved that the resulting1|DIF|∑j=1n(αjmax{0,dj−Aj}+βjEj+γjTj)problem is equivalent to the well-known1∥∑j=1nwjTjproblem withwj=min{αj,γj}and fixed due datesdj=Ajforj=1,…,n. Based on this and on the stronglyNP-hardness result for the1∥∑j=1nwjTjproblem (see Lawler, 1977), they concluded that the1|DIF|∑j=1n(αjmax{0,dj−Aj}+βjEj+γjTj)problem is stronglyNP-hard. Moreover, they showed that the1|DIF|∑j=1n(αjmax{0,dj−Aj}+βjEj+γjTj)problem is solvable in O(nlog n) time when eitherAj=0or whenAj=Aandwj=min{αj,γj}=wforj=1,…,n.Our main objective in this paper is to analyze theX|Y¯,DIF,dj≤d¯j|∑j=1n(αjmax{0,dj−Aj}+βjEj+γjTj)problem for various settings of X andY¯. Owing to the results in Shabtay and Steiner (2006) above this problem is stronglyNP-hard even whenX=1,Y¯=∅andd¯j≥Σj=1npj. Thus, we are mainly interested in exploring the borderline between easy and hard special cases of the problem, and providing approximation results for the hard cases.Let us consider a given schedule S for theX|Y¯,DIF,dj≤d¯j|∑j=1n(αjmax{0,dj−Aj}+βjEj+γjTj)problem that fixes the set of completion times to beC(S)=(C1(S),C2(S),…,Cn(S)). It is easy to see from (2) that, given a schedule S, the due date assignment problem has a separable objective function. Thus, we can determine the optimal due date for job j by determining the djvalue that minimizes(4)Zj(dj)=αjmax{0,dj−Aj}+βjmax{0,dj−Cj(S)}+γjmax{0,Cj(S)−dj},subject to the condition in (3). We refer to the above DDA problem by DDA(S, j), and bydj*(S)we denote its optimal due date assignment.Lemma 1The optimal solution for the DDA(S, j) problem satisfies thatdj*(S)≤Cj(S),i.e.,Ej(S)=max{0,dj*(S)−Cj(S)}=0Let us assume that there exists an optimal solution for the DDA(S, j) problem withdj*(S)>Cj(S). We define an alternative solution for the this problem by settingdj(S)=Cj(S). This procedure reduces the earliness cost byβj(dj*(S)−Cj(S))>0and obviously does not increase the due date assignment cost. The fact that job j is not tardy in both solutions contradicts the optimality ofdj*(S)and completes the proof.□As a result of Lemma 1 the DDA(S, j) problem reduces to determine the djvalue that minimizesZj(dj)=αjmax{0,dj−Aj}+γj(Cj(S)−dj)subject todj≤min{d¯j,Cj(S)}.Lemma 2If Cj(S) ≤ Aj, thendj*(S)=Cj(S). Moreover, if Cj(S) > Aj, thendj*(S)=Aj if αj> γj, anddj*(S)=min{d¯j,Cj(S)}otherwise.If Cj(S) ≤ Ajthen settingdj*(S)=Cj(S) implies thatZj(dj*(S))=0.It is easy to see that if Cj(S) > Ajit is not optimal to assign dja value less than Aj(i.e., we have thatdj*(S)≥Aj). Thus, we have thatAj≤dj*(S)≤min{d¯j,Cj(S)},which also implies thatZj(dj)=αj(dj−Aj)+γj(Cj(S)−dj)=(αj−γj)dj+γjCj(S)−αjAj. The lemma now directly follows from the fact that for Cj(S) > Aj, Zj(dj) is a linear function of djwith a slope ofαj−γj.□By Lemma 2, if Cj(S) ≤ AjthenZj(dj*(S))=0. Moreover, if Cj> AjthenZj(dj*(S))=γj(Cj(S)−Aj)if αj> γjandZj(dj*(S))=(αj−γj)min{d¯j,Cj(S)}+γjCj(S)−αjAjif αj≤ γj. Therefore, we have that(5)Zj(dj*(S))=γjmax{0,Cj(S)−Aj}ifαj>γj,and that(6)Zj(dj*(S))={0ifαj≤γjandCj(S)≤Aj(αj−γj)min{d¯j,Cj(S)}+γjCj(S)−αjAjifαj≤γjandCj(S)>Aj.According to (6) if both αj≤ γjand Cj(S) > Aj, then(7)Zj(dj*(S))=(αj−γj)min{d¯j,Cj(S)}+γjCj(S)−αjAj=αj(min{d¯j,Cj(S)}−Aj)+γj(Cj(S)−min{d¯j,Cj(S)})=αj(min{d¯j,Cj(S)}−Aj)+γjmax{0,Cj(S)−d¯j}=αj(min{d¯j,Cj(S)}−Aj+max{0,Cj(S)−d¯j})+θjmax{0,Cj(S)−d¯j},whereθj=γj−αj≥0. Now, note that the value ofZj(dj*(S))in eq. (7) equalsαj(Cj(S)−Aj)+θjmax{0,Cj(S)−d¯j}for both cases where eithermin{d¯j,Cj(S)}=d¯jormin{d¯j,Cj(S)}=Cj(S). This together with the fact thatZj(dj*(S))=0if Cj(S) ≤ Ajimplies that(8)Zj(dj*(S))=αjmax{0,Cj(S)−Aj}+θjmax{0,Cj(S)−d¯j}ifαj≤γj.Note that, due to our assumption thatAj≤d¯j,the value in (8) is indeed equal to zero when Cj(S) ≤ Aj. By combining the results in (5) and (8), we can conclude that theX|Y¯,DIF,dj≤d¯j|∑j=1n(αjmax{0,dj−Aj}+βjEj+γjTj)problem is equivalent to theX|Y¯|∑j=1nfj(Cj)problem, where(9)fj(Cj)={αjmax{0,Cj−Aj}+θjmax{0,Cj−d¯j}ifαj≤γjγjmax{0,Cj−Aj}ifαj>γj}.Letφj=min{αj,γj}andλj=max{0,θj}=max{0,γj−αj}forj=1,…,n. Then the value of fj(Cj) in (9) can be rewritten in a more compact form as(10)fj(Cj)=φjmax{0,Cj−Aj}+λjmax{0,Cj−d¯j}.From the above analysis, the following theorem is now straightforward.Theorem 1For any X andY¯,theX|Y¯,DIF,dj≤d¯j|∑j=1n(αjmax{0,dj−Aj}+βjEj+γjTj)problem is equivalent to theX|Y¯|∑j=1nφjmax{0,Cj−Aj}+∑j=1nλjmax{0,Cj−d¯j}problem withφj=min{αj,γj}andλj=max{0,γj−αj}.The next theorem follows directly from Theorem 1 and the facts that (i) the1∥∑j=1nwjTjproblem is stronglyNP-hard (see Lawler, 1977); (ii) the1|dj=d|∑j=1nwjTjproblem is ordinaryNP-hard (see Jinjiang, 1992); and (iii) the1∥∑j=1nTjproblem is ordinaryNP-hard (see Du & Leung, 1990).Theorem 2TheX|Y¯,DIF,dj≤d¯j|∑j=1n(αjmax{0,dj−Aj}+βjEj+γjTj)problem is stronglyNP-hard ifY¯=ϕeven when the scheduling is done on a single machine (X=1). This result holds even for the special cases where either one of the following conditions holds for allj=1,…,n: (i) γj≤ αj (ii) γj> αj (iii)d¯j≥Σj=1npjand (iv)d¯j=Aj. Moreover, the1|DIF,dj≤d¯j|∑j=1n(αjmax{0,dj−Aj}+βjEj+γjTj)problem is ordinaryNP-hard for each of the above four cases ((i)–(iv)) even if we also have that bothd¯j=dandAj=Aforj=1,…,n. In addition, the1|DIF,dj≤d¯j|∑j=1n(αjmax{0,dj−Aj}+βjEj+γjTj)problem is ordinaryNP-hard even if bothαj=αandγj=γforj=1,…,n.Note that in addition to being equivalent to theX|Y¯,DIF,dj≤d¯j|∑j=1n(αjmax{0,dj−Aj}+βjEj+γjTj)problem, there is also the following direct implication for theX∣Y¯∣∑j=1nφjmax{0,Cj−Aj}+∑j=1nλjmax{0,Cj−d¯j}problem in solving scheduling problems with a two stepwise weighted tardiness function. In this set of problems, for each job j there are two given due dates, Ajandd¯j,withAj≤d¯j. Job j incurs no penalty if completed until the first due date, Aj, but completing job j after Ajresults in a job-dependent penalty ofφj(Cj−Aj). In addition, a penalty ofλj(Cj−d¯j)occurs if the manufacturer fails to complete the job until the later due date,d¯j.In this section we focus on the special case where (i) the per unit lead time costs are job-independent (that isαj=αforj=1,…,n); (ii) the per unit tardiness costs are job-independent (that isγj=γforj=1,…,n); and (iii) the acceptable lead times are job-independent (that isAj=Aforj=1,…,n). Seidmann et al. (1981) studied a single machine variant of this special case, where in addition to (i), (ii) and (iii) above we also have that all jobs share the same per unit earliness cost (that is,βj=βforj=1,…,n). They proved that the resulting1|DIF|∑j=1n(αmax{0,dj−A}+βEj+γTj)problem is solvable in O(nlog n) time by scheduling the jobs in an SPT order.According to Theorem 1, the1|DIF,dj≤d¯j|∑j=1n(αmax{0,dj−A}+βjEj+γTj)problem is equivalent to the1||∑j=1nφmax{0,Cj−A}+∑j=1nλmax{0,Cj−d¯j}problem withφ=min{α,γ}andλ=max{0,γ−α}. If α ≥ γ, the equivalent problem is1||∑j=1nγmax{0,Cj−A},which is solvable in O(nlog n) time by scheduling the jobs in an SPT order. However, if α < γ then the equivalent problem is1||∑j=1nαmax{0,Cj−A}+θ∑j=1nmax{0,Cj−d¯j}withθ=γ−α. This problem isNP-hard being that forα=0it is equivalent to the1|dj=d¯j|γ∑j=1nTjproblem. Thus, we have the following corollary:Corollary 1The1|DIF,dj≤d¯j|∑j=1n(αmax{0,dj−A}+βjEj+γTj)problem is solvable in O(nlog n) time if α ≥ γ, and is ordinaryNP-hard otherwise.Corollary 1 implies that the extension of the problem studied by Seidmann et al. (1981) to the case where every job has an individual upper bound,d¯j,on its assigned due date does not add any complexity to the problem as long as α ≥ γ. However, if α < γ it is exactly the individual upper bound that makes the problem hard to solve.Next, we consider the special case where in addition to (i), (ii) and (iii) above we also have thatdj≤d¯forj=1,…,n. Based on Theorem 1, the resultingX|DIF,dj≤d¯|∑j=1n(αmax{0,dj−A}+βjEj+γTj)problem is equivalent to theX||φ∑j=1nmax{0,Cj−A}+λ∑j=1nmax{0,Cj−d¯}problem withφ=min{α,γ}andλ=max{0,γ−α}. If the scheduling is done on a single machine (X=1), then it is easy to show that the SPT order minimizes both∑j=1nmax{0,Cj−A}andλ∑j=1nmax{0,Cj−d¯}. Thus, we have the following corollary:Corollary 2The1|DIF,dj≤d¯|∑j=1n(αmax{0,dj−A}+βjEj+γTj)problem is solvable in O(nlog n) time.Note that here as well the result obtained by Seidmann et al. (1981) can be viewed as a special case of the result in Corollary 2 whend¯≥∑j=1npj.For α ≥ γ theX|DIF,dj≤d¯j|∑j=1n(αmax{0,dj−A}+βjEj+γTj)problem is equivalent to theX|dj=A|∑j=1nTjproblem. ThePm|dj=A|∑j=1nTjproblem is known to beNP-hard form=2as the problem of finding a schedule with a value of∑j=1nTj=0for the instance whereA=1/2×∑j=1npjis equivalent to theNP-hard multiprocessor scheduling problem (see Garey & Johnson, 1979). Since thePm|dj=A|∑j=1nTjproblem is a special case of problemsQm|dj=A|∑j=1nTjandRm|dj=A|∑j=1nTj,it is straightforward that the last two problems areNP-hard as well. ForA=0,theX|dj=0|∑j=1nTjproblem is equivalent to theX||∑j=1nCjproblem. This problem is known to be stronglyNP-hard forX=F2andX=J2(see Garey, Johnson, & Sethi, 1976) and also forX=O2(see Achugbue & Chin, 1982). Thus, the following corollary holds:Corollary 3TheX|DIF,dj≤d¯|∑j=1n(αmax{0,dj−A}+βjEj+γTj)problem isNP-hard for X ∈ {P2, Q2, R2} and is stronglyNP-hard when X ∈ {F2, J2, O2} even when α ≥ γ.We note that when α ≥ γ theQm|DIF,dj≤d¯j|∑j=1n(αmax{0,dj−A}+βjEj+γTj)problem can be solved in pseudo-polynomial time based on the algorithm provided in Shabtay and Steiner (2008) for the equivalentQm|dj=A|∑j=1nTjproblem.Consider the case where the scheduling is done on uniform parallel machines, jobs may have arbitrary release dates and all processing times are identical. Following our result in Theorem 1, the resultingQ|rj,pj=p,DIF,dj≤d¯j|∑j=1n(αjmax{0,dj−Aj}+βjEj+γjTj)problem is equivalent to theQ|rj,pj=p|∑j=1nφjmax{0,Cj−Aj}+∑j=1nλjmax{0,Cj−d¯j}problem. Whenλj=0forj=1,…,nthe latter problem reduces to theQm|rj,pj=p|∑j=1nφjmax{0,Cj−Aj}problem. As pointed out by Van Den Akker, Diepen, and Hoogeveen (2010), the complexity of this problem is still an open question even when the scheduling is done on a single machine. Note that for an arbitrary number of machines ifrj=0forj=1,…,n,then the resultingQ|pj=p|∑j=1nφjmax{0,Cj−Aj}+∑j=1nλjmax{0,Cj−d¯j}problem can be easily reduced to a bipartite weighted matching problem (BWMP) withn1=nmandn2=nvertices in each of the two sets of vertices in the bipartite graph. Li (2006) indicated that the BWMP can be solved inO(n2S(n1+n2,n1n2,C))time by applying the successive shortest path algorithm, whereS(n1+n2,n1n2,C)is the time required to solve a shortest path problem withn1+n2nodes, n1n2 arcs and a maximum arc coefficient of C. Currently, the best-known strongly polynomial bound for S(u, a, C) isO(a+ulogu). Thus, we can solve the BWMP inO(n2(n1n2+n1logn1))time, and we have the following corollary:Corollary 4TheQ|pj=p,DIF,dj≤d¯j|∑j=1n(αjmax{0,dj−Aj}+βjEj+γjTj)problem is solvable inO(n(n2m+nmlognm)=O(n3m)time (assuming that n ≥ m).In light of Theorem 2, it is natural to ask if there are approximation algorithms for the stronglyNP-hard cases of theX|Y¯,DIF,dj≤d¯j|∑j=1n(αjmax{0,dj−Aj}+βjEj+γjTj)problem. In the next section we provide such an algorithm for the single machine variant of the problem, while in the subsection that follows, we show that such an algorithm is not possible for most multi-machine variants, unlessP=NP. Thus, we provide approximation algorithms to a slightly modified (but equivalent from an optimization point of view) version of the problem.According to Theorem 1, the1|DIF,dj≤d¯j|∑j=1n(αjmax{0,dj−Aj}+βjEj+γjTj)problem reduces to the1||∑j=1nφjmax{0,Cj−Aj}+∑j=1nλjmax{0,Cj−d¯j}problem which is a two stepwise weighted tardiness problem. According to Congram, Potts, and Van de Velde (2002), the (single-step) weighted tardiness problem on a single machine is anNP-hard archetypal machine scheduling problem whose exact solution is difficult to derive even on very small inputs. To the best of our knowledge, the only non-trivial approximation result for the1||∑j=1nwjTjproblem is in Cheng, Ng, Yuan, and Liu (2005) who provided an (n−1)-approximation algorithm. This was done by constructing an auxiliary (modified) instance for the problem and by using Lawler’s algorithm (Lawler, 1973) to find the optimal solution which minimizes the maximal weighted tardiness with respect to the modified instance. In what follows, we show that a similar approach can yield the same approximation result for our1||∑j=1nφjmax{0,Cj−Aj}+∑j=1nλjmax{0,Cj−d¯j}problem.Given an instanceI={φj,λj,Aj,d¯j}for our1||∑j=1nφjmax{0,Cj−Aj}+∑j=1nλjmax{0,Cj−d¯j}problem, we define an auxiliary instanceI′={φj,λj,Aj′,d¯j′}with(11)Aj′=max{pj,Aj}andd¯j′=max{pj,d¯j}forj=1,…,n. We also define two auxiliary problems with respect to the auxiliary instance. The first is the1||∑j=1nφjmax{0,Cj−Aj′}+∑j=1nλjmax{0,Cj−d¯j′}problem and the second is the1||maxj=1,…,n{φjmax{0,Cj−Aj′}+λjmax{0,Cj−d¯j′}}problem which can be optimally solved in O(n2) time by applying Lawler’s algorithm (Lawler, 1973). Let SLbe the optimal schedule (job sequence) for the1||maxj=1,…,n{φjmax{0,Cj−Aj′}+λjmax{0,Cj−d¯j′}}problem. Job sequence SLis our proposed approximate sequence for the1||∑j=1nφjmax{0,Cj−Aj}+∑j=1nλjmax{0,Cj−d¯j}problem.Theorem 3SL provides an(n−1)-approximation for the1||∑j=1nφjmax{0,Cj−Aj}+∑j=1nλjmax{0,Cj−d¯j}problem.Let1||∑j=1nfj(Cj),1||∑j=1nfj′(Cj)and1||maxj=1,…,n{fj′(Cj)}be the original and the two auxiliary problems withfj(Cj)=φjmax{0,Cj−Aj}+λjmax{0,Cj−d¯j}andfj′(Cj)=φjmax{0,Cj−Aj′}+λjmax{0,Cj−d¯j′}. For any job permutation S we have thatmaxj=1,…,n{fj′(Cj(S))}≤∑j=1nfj′(Cj(S)).Consider the following three possible cases that can arise for job j, for a given instance of the1||∑j=1nfj(Cj)problem:•Case 1:pj≤Aj≤d¯j. It follows from (11) thatAj′=Ajandd¯j′=d¯j. Thus,fj′(Cj(S))=fj(Cj(S))for any S.Case 2:Aj≤pj≤d¯j. It follows from (11) thatAj′=pjandd¯j′=d¯j. Thus,fj(Cj(S))−fj′(Cj(S))=φjmax{0,Cj−Aj}−φjmax{0,Cj−pj}for any S. The fact that Cj≥ pjfurther implies thatfj(Cj(S))−fj′(Cj(S))=φj(pj−Aj)for any S.Case 3:Aj≤d¯j≤pj. It follows from (11) thatAj′=d¯j′=pj. Thus,fj(Cj(S))−fj′(Cj(S))=φjmax{0,Cj−Aj}+λjmax{0,Cj−d¯j}−φjmax{0,Cj−pj}−λjmax{0,Cj−pj}for any S. The fact that Cj≥ pjfurther implies thatfj(Cj(S))−fj′(Cj(S))=φj(pj−Aj)+λj(pj−d¯j)for any S.It is easy to conclude from the above three cases thatfj(Cj(S))−fj′(Cj(S))=φjmax{0,pj−Aj}+λjmax{0,pj−d¯j}for any S. Thus,(12)∑j=1nfj′(Cj(S))=∑j=1nfj(Cj(S))−∑j=1nφjmax{0,pj−Aj}−λj∑j=1nmax{0,pj−d¯j}.If we let S* be the optimal job permutation for the1||∑j=1nfj(Cj)problem, we have thatmaxj=1,…,n{fj′(Cj(SL))}≤maxj=1,…,n{fj′(Cj(S*))}.Consider a job permutation S and let [1] be the first job in S. Sinced¯[1]′≥A[1]′≥C[1](S)=p[1],we have thatf[1]′(C[1](S))=0,i.e., for any schedule the first scheduled job is not tardy with respect to both modified due dates (A[1]′andd¯[1]′). Thus, we have that(13)∑j=1nfj′(Cj(SL))≤(n−1)maxj=1,…,n{fj′(Cj(SL))}≤(n−1)maxj=1,…,n{fj′(Cj(S*))}≤(n−1)∑j=1nfj′(Cj(S*)).Following (12) we also have that(14)∑j=1nfj′(Cj(SL))=∑j=1nfj(Cj(SL))−∑j=1nφjmax{0,pj−Aj}−λj∑j=1nmax{0,pj−d¯j},and that(15)∑j=1nfj′(Cj(S*))=∑j=1nfj(Cj(S*))−∑j=1nφjmax{0,pj−Aj}−λj∑j=1nmax{0,pj−d¯j}.By inserting (14) and (15) into (13) we obtain that∑j=1nfj(Cj(SL))−∑j=1nφjmax{0,pj−Aj}−λj∑j=1nmax{0,pj−d¯j}≤(n−1)(∑j=1nfj(Cj(S*))−∑j=1nφjmax{0,pj−Aj}−λj∑j=1nmax{0,pj−d¯j})≤(n−1)∑j=1nfj(Cj(S*))−∑j=1nφjmax{0,pj−Aj}−λj∑j=1nmax{0,pj−d¯j},which implies that∑j=1nfj(Cj(SL))≤(n−1)∑j=1nfj(Cj(S*)),and the theorem follows.□The following theorem (presented in Shabtay and Steiner, 2008 and based on the results in Kovalyov and Werner, 2002) shows that when scheduling is done on a set of parallel machines, approximation algorithms are not likely to exist, even if all of the job’s parameters are identical (i.e.,αj=α,βj=β,γj=γandAj=Aforj=1,…,n).Theorem 4There can be no polynomial time ρ-approximation algorithm for the problem Pm|DIF|∑j=1n(αmax(0,dj−A)+βEj+γTj)with ρ < ∞ unlessP=NP.Since thePm|DIF|∑j=1n(αmax(0,dj−A)+βEj+γTj)problem is a special case of the Qm|DIF|∑j=1n(αmax(0,dj−A)+βEj+γTj)andRm|DIF|∑j=1n(αmax(0,dj−A)+βEj+γTj)problems, the above result holds for uniform and unrelated machines as well. One reason the problems are difficult to approximate is that the optimal objective value for an instance may be zero and any algorithm with a guaranteed approximation ratio would have to be optimal for such instances. Furthermore, the problem of finding out whether an instance has a schedule with zero tardiness on parallel machines is itselfNP-hard. One can easily obtain a result similar to that in Theorem 4 when the scheduling is done in flow-shop, job-shop and open-shop systems with more than two machines as in such systems the problem of whether an instance has a schedule with zero tardiness isNP-hard as well. This issue provides the motivation for an equivalent formulation for the problem that has no solution with zero value. This can be done by adding some positive b > 0 value to the objective function. Although approximating such a version of the problem may be somewhat easier, the next result by Kovalyov and Werner (2002) shows that even this version is unlikely to have a fully polynomial time approximation scheme (FPTAS).Theorem 5There can be no polynomial timeɛ−approximation algorithm for the problem Pm|DIF|∑j=1n(αmax(0,dj−A)+βEj+γTj)+bwith ε < 1/b unlessP=NP.Theorem 5 implies that it may be possible to obtain an approximation algorithm for thePm|DIF|∑j=1n(αmax(0,dj−A)+βEj+γTj)+bproblem only if the additive term b will be a polynomial function of the size of the data. Kolliopoulos and Steiner (2007) presented an efficient method for obtaining approximation results for the∑j=1nwjTj+∑j=1nwjdjcriterion in various machine environments with given due dates dj,j=1,…,n. These approximation results are based on exploiting the close relationship between the∑j=1nwj(Tj+dj)and the∑j=1nwjCjcriteria. However, this result cannot be directly imposed on our equivalent objective functionF(S)=∑j=1nfj(Cj)=∑j=1nφjmax{0,Cj(S)−Aj}+∑j=1nλjmax{0,Cj(S)−d¯j}as it is a two stepwise weighted tardiness function. Nevertheless, as we will show below, by adopting a similar approach to the one used in Kolliopoulos and Steiner (2007) we can derive similar approximation results for an equivalent formulation of our problem. Letb=∑j=1nφjAj+∑j=1nλjd¯jand consider our equivalent problem with a modified objective function of minimizingF˜(S)=∑j=1nfj(Cj)+b=∑j=1nφjmax{0,Cj(S)−Aj}+∑j=1nλjmax{0,Cj(S)−d¯j}+b. It is easy to observe thatF˜(S)=∑j=1nφjmax{Cj(S),Aj}+∑j=1nλjmax{Cj(S),d¯j}.Moreover, it is easy to observe that for any schedule S, we have that(16)F˜(S)≥∑j=1nφjCj(S)+∑j=1nλjCj(S)=∑j=1n(φj+λj)Cj(S),and thatF˜(S)≥∑j=1nφjAj+∑j=1nλjd¯j.The fact thatφj=min{αj,γj}andλj=max{0,γj−αj}implies thatφj+λj=γjforj=1,…,n. Thus, the inequality in (16) can be represented as(17)F˜(S)≥∑j=1nγjCj(S).Let us consider an algorithm A, which provides a ρ-approximation for theX|Y¯|∑j=1nγjCjproblem, i.e., for any instance of the problem it provides a solutionS˜which guarantees that∑j=1nγjCj(S˜)≤ρ∑j=1nγjCj(SΣγjCj*),whereSΣγjCj*is the optimal solution for the correspondingX|Y¯|∑j=1nγjCjproblem. Moreover, let S* be the optimal solution for ourX|Y¯|∑j=1nφjmax{Cj(S),Aj}+∑j=1nλjmax{Cj(S),d¯j}problem. Then the following holds:F˜(S*)≤F˜(S˜)=∑j=1nφjmax{Cj(S˜),Aj}+∑j=1nλjmax{Cj(S˜),d¯j}≤∑j=1nφjCj(S˜)+∑j=1nλjCj(S˜)+∑j=1nφjAj+∑j=1nλjd¯j=∑j=1nγjCj(S˜)+∑j=1nφjAj+∑j=1nλjd¯j≤ρ∑j=1nγjCj(SΣγjCj*)+∑j=1nφjAj+∑j=1nλjd¯j≤ρ∑j=1nγjCj(S*)+∑j=1nφjAj+∑j=1nλjd¯j≤ρF˜(S*)+F˜(S*)=(ρ+1)F˜(S*),and so does the following theorem:Theorem 6Consider a memberX0|Y¯0|∑j=1nγjCjof the family of scheduling problemsX|Y¯|∑j=1nγjCjfor which there exists a ρ-approximation algorithm. The same algorithm provides a(ρ+1)-approximation for theX0|Y¯0|∑j=1nφjmax{0,Cj−Aj}+∑j=1nλjmax{0,Cj−d¯j}+bproblem withb=∑j=1nφjAj+∑j=1nλjd¯j.Many approximation results can be derived from exploiting the above theorem. For example, the fact that we can optimally solve the1||∑j=1nwjCjproblem (wj=φj+λjforj=1,…,n) in O(nlog n) time by ordering the jobs in a nondecreasing order of pj/wj(Smith, 1956) implies that such an ordering provides a 2-approximation algorithm with O(nlog n) time complexity for the1||∑j=1nφjmax{0,Cj−Aj}+∑j=1nλjmax{0,Cj−d¯j}+bproblem withb=∑j=1nφjAj+∑j=1nλjd¯j. Table 1below includes a partial list of approximation results that can be derived for variousX0∣Y¯∣∑j=1nφjmax{0,Cj−Aj}+∑j=1nλjmax{0,Cj−d¯j}+bproblems, based on known results of the correspondingX0|Y¯0|∑j=1nγjCjproblems.Similar to Kolliopoulos and Steiner (2007), we next show that it is possible to improve the result in Theorem 6 in cases where a continuous LP-based formulation with certain characteristics are available. Let us consider a family of mathematical programs that includes a set of linear constraints, ς(C), defined on a set of completion time variables Cjforj=1,…,n. Set ς(C) is called a valid set of completion time constraints if the completion time Cj(j=1,…,n) satisfies the constraints in ς(C) for every feasible schedule (note, however, that not any solution that satisfies the constraints in ς(C) results in a feasible schedule). Let ς0(C) be a valid set of completion time constraints for a memberX0|Y¯0|∑j=1nφjmax{0,Cj−Aj}+∑j=1nλjmax{0,Cj−d¯j}+bof the family of scheduling problemsX|Y¯|∑j=1nφjmax{0,Cj−Aj}+∑j=1nλjmax{0,Cj−d¯j}+bwithb=∑j=1nφjAj+∑j=1nλjd¯j. We note that set ς0(C) depends on the specific machine environment (X0) and the set of processing characteristics and constraints (Y¯0) and is independent of the objective function being used. Moreover, letT^j=max{0,Cj−Aj},E^j=max{0,Aj−Cj},T˜j=max{0,Cj−d¯j},andE˜j=max{0,d¯j−Cj},and let FP(ς) be the following family of linear programs (with FP(ς0) ∈ FP(ς) being a member of this family):(18)min∑j=1nφj(T^j+Aj)+∑j=1nλj(T˜j+d¯j)subject to:(19)T^j=Cj−Aj+E^j,j=1,…,n(20)T˜j=Cj−d¯j+E˜j,j=1,…,n(21)ς(C)(22)Cj,T^j,T˜j,E^j,E˜j≥0,j=1,…,nSince for any feasible schedule at most one out of the variablesT^j(T˜j) andE^j(E˜j) can be positive, it is easy to see that any feasible schedule satisfies Eqs. (19) and (20). Thus, if ς0(C) is a valid set of completion time constraints for a memberX0|Y¯0|∑j=1nφjmax{0,Cj−Aj}+∑j=1nλjmax{0,Cj−d¯j}+bof the family of scheduling problemsX|Y¯|∑j=1nφjmax{0,Cj−Aj}+∑j=1nλjmax{0,Cj−d¯j}+b,so is the extended set defined above in (19)–(22). Note that the equation in (19) allows bothT^jandE^jto be positive, and the equation in (20) allows bothT˜jandE˜jto be positive. However, due to the objective in (18) this cannot be the case in an optimal solution for any member of the above defined set of linear programs. LetCj*forj=1,…,nbe the optimal set of completion times for FP(ς0). Since we cannot necessarily construct a feasible solution for theX0|Y¯0|∑j=1nφjmax{0,Cj−Aj}+∑j=1nλjmax{0,Cj−d¯j}+bproblem with this set of completion times, it is necessary to construct a procedure to produce a feasible solution out of the optimal solution for the FP(ς0) problem. Our approximation result depends on the existence of algorithmA(X0,Y¯0)which has the ability to construct a feasible schedule S that comes with a job-by-job approximation guarantee for the completion times., i.e., withCj(S)≤ρCj*forj=1,…,n,for some ρ ≥ 1. Given such a procedure, our proposed approximation procedure for theX0|Y¯0|∑j=1nφjmax{0,Cj−Aj}+∑j=1nλjmax{0,Cj−d¯j}+bproblem is as follows:Algorithm 1Approximation procedure for theX0|Y¯0|∑j=1nφjmax{0,Cj−Aj}+∑j=1nλjmax{0,Cj−d¯j}+bproblemStep 1. Compute an optimal solution for FP(ς0), and forj=1,…,nletCj*,T^j*,T˜j*,E^j*,E˜j*be the resulting optimal solution for problem FP(ς0).Step 2. By invoking an appropriate algorithmA(X0,Y¯0),compute a feasible schedule S for theX0|Y¯0|∑j=1nφjmax{0,Cj−Aj}+∑j=1nλjmax{0,Cj−d¯j}+bproblem withCj(S)≤ρCj*,j=1,…,n,for some constant ρ ≥ 1.Step 3. Output schedule S.If AlgorithmA(X0,Y¯0)exists, the output schedule S of Algorithm1provides a ρ-approximation for theX0|Y¯0|∑j=1nφjmax{0,Cj−Aj}+∑j=1nλjmax{0,Cj−d¯j}+bproblem withb=∑j=1nφjAj+∑j=1nλjd¯j.Due to the fact thatA(X0,Y¯0)computes a feasible schedule S for theX0|Y¯0|∑j=1nφjmax{0,Cj−Aj}+∑j=1nλjmax{0,Cj−d¯j}+bproblem withCj(S)≤ρCj*,j=1,…,n,for some ρ ≥ 1, we have thatT^j(S)=max{0,Cj(S)−Aj}≤max{0,ρCj*−Aj},and thatT˜j(S)=max{0,Cj(S)−d¯j}≤max{0,ρCj*−d¯j}.Letting S* be the optimal schedule for theX0|Y¯0|∑j=1nφjmax{0,Cj−Aj}+∑j=1nλjmax{0,Cj−d¯j}+bproblem, it follows that∑j=1nφj(T^j*+Aj)+∑j=1nλj(T˜j*+d¯j)=∑j=1nφj(max{0,Cj*−Aj}+Aj)+∑j=1nλj(max{0,Cj*−d¯j}+d¯j)=∑j=1nφjmax{Aj,Cj*}+∑j=1nλjmax{d¯j,Cj*}≤∑j=1nφj(max{0,Cj(S*)−Aj}+Aj)+∑j=1nλj(max{0,Cj(S*)−d¯j}+d¯j)≤∑j=1nφj(max{0,Cj(S)−Aj}+Aj)+∑j=1nλj(max{0,Cj(S)−d¯j}+d¯j)≤∑j=1nφj(max{0,ρCj*−Aj}+Aj)+∑j=1nλj(max{0,ρCj*−d¯j}+d¯j)=∑j=1nφjmax{Aj,ρCj*}+∑j=1nλjmax{d¯j,ρCj*}≤ρ(∑j=1nφjmax{Aj,Cj*}+∑j=1nλjmax{d¯j,Cj*}).Thus, the existence of algorithmA(X0,Y¯0)guarantees that Algorithm 1 provides a ρ-approximation for theX0|Y¯0|∑j=1nφjmax{0,Cj−Aj}+∑j=1nλjmax{0,Cj−d¯j}+bproblem.□According to Theorem 7, a large set of approximation results for variousX0|Y¯0|∑j=1nφjmax{0,Cj−Aj}+∑j=1nλjmax{0,Cj−d¯j}+bproblems can be obtained based on the ability to solve the corresponding FP(ς0) in polynomial time, and the existence of polynomial procedureA(X0,Y¯0)which computes a feasible schedule S for theX0|Y¯0|∑j=1nφjmax{0,Cj−Aj}+∑j=1nλjmax{0,Cj−d¯j}+bproblem withCj(S)≤ρCj*,j=1,…,n,for some ρ ≥ 1. For example, Hall, Schulz, Shmoys, and Wein (1997) showed that the corresponding FP(ς0) formulation for the1|prec|∑j=1nwjCjproblem can be solved in polynomial time, and that for this problem there also exists a polynomial procedureA(1,prec)withρ=2to construct a feasible solution S for the1|prec|∑j=1nφjmax{0,Cj−Aj}+∑j=1nλjmax{0,Cj−d¯j}+bproblem out of the solution of FP(ς0). It is easy to see from the analysis in Hall et al. (1997) that (i) the ability to solve the corresponding FP(ς) problem in polynomial time holds for any linear objective function (and thus holds also for our objective function in (18)); and that (ii) the existence ofA(1,prec)is independent of the objective function being used. Thus, we can conclude that by using Algorithm 1 with theA(1,prec)procedure presented in Hall et al. (1997) we can provide a 2-approximation procedure for the1|prec|∑j=1nφjmax{0,Cj−Aj}+∑j=1nλjmax{0,Cj−d¯j}+bproblem. Table 2below includes a list of approximation results that can be obtained for variousX0|Y¯0|∑j=1nφjmax{0,Cj−Aj}+∑j=1nλjmax{0,Cj−d¯j}+bproblems, based on Theorem 7. For each result we also include a reference for the paper that presents the correspondingA(X0,Y¯0)procedure.Consider the case where the scheduling is done on a single machine andd¯j=d¯andAj=Aforj=1,…,n. According to Theorem 1, the resulting1|DIF,dj≤d¯|∑j=1n(αjmax{0,dj−A}+βjEj+γjTj)problem is equivalent to the1||∑j=1nφjmax{0,Cj−A}+∑j=1nλjmax{0,Cj−d¯}problem withφj=min{αj,γj}andλj=max{0,γj−αj}. Ifλj=0(i.e., γj≤ αj) forj=1,…,nthen the problem reduces to the1||∑j=1nγjmax{0,Cj−A}problem, which is known to beNP-hard (Jinjiang, 1992). Lawler and Moore (1969) provide a pseudo-polynomial time algorithm to solve this problem, which was extended later by Kolliopoulos and Steiner (2006) to solve problems with a constant number of due dates. Since neither algorithms can be used to solve our1||∑j=1nfj(Cj)problem withfj(Cj)=φjmax{0,Cj−A}+∑j=1nλjmax{0,Cj−d¯},we next provide a different algorithm that solves the1||∑j=1nφjmax{0,Cj−A}+∑j=1nλjmax{0,Cj−d¯}problem in pseudo-polynomial time.Since fj(Cj) is a non-decreasing function of Cj, there exists an optimal solution in which the jobs are consecutively processed during time intervalI=[0,P]whereP=∑j=1npj. Without loss of generality, we assume thatd¯<P. Otherwise, ifd¯≥P,the1||∑j=1nφjmax{0,Cj−A}+∑j=1nλjmax{0,Cj−d¯}problem reduces to a1||∑j=1nφjmax{0,Cj−A}problem, which can be directly solved in pseudo-polynomial time by applying Lawler and Moore’s algorithm (Lawler & Moore, 1969). Let us now partition time interval I into three subintervals as follows:I1=[0,A),I2=[A,d¯)andI3=[d¯,P]. Moreover, for any given schedule, let S1 be the first job completed during time interval I2 and S2 be the first job completed during time interval I3. Note that, in any schedule, there is a job that is completed during time interval I3. However, this is not always the case with time interval I2. Consider, for example, a schedule S where there exists a job (say job j) that starts its processing at time t ∈ I1, and whose processing time (pj) is at leastd¯−t. In such a schedule no job is completed during time interval I2, and therefore we setS1=∅. Moreover, since job j is the first to be completed during time interval I3 (in S), we setS2=j.Now define a set of O(n2) auxiliary (restricted) problems denoted by1|(S1,S2)|∑j=1nfj(Cj)withfj(Cj)=φjmax{0,Cj−A}+∑j=1nλjmax{0,Cj−d¯},each of which fixes the identity of jobs S1 and S2. LetSbe the set of all possible couples (S1, S2); F*(S1, S2) be the optimal solution value for the1|(S1,S2)|∑j=1nfj(Cj)auxiliary problem; and Z* be the optimal solution value for the general1||∑j=1nfj(Cj)problem. Then, the following relation obviously holds:(23)F*=min(S1,S2)∈S{Z*(S1,S2)}.Due to (23), and the fact that|S|=O(n2),the existence of a pseudo-polynomial time algorithm for the1|(S1,S2)|∑j=1nfj(Cj)problem would directly imply the existence of a pseudo-polynomial time algorithm for the unrestricted1||∑j=1nfj(Cj)problem. Thus, in what follows we focus on providing a pseudo-polynomial time algorithm for the1|(S1,S2)|∑j=1nfj(Cj)problem.Given a solution for an instance of the1|(S1,S2)|∑j=1nfj(Cj)problem, let Cj, be the completion time of job j and Bibe the set of jobs completed within time interval Iifori=1,2,3,excluding jobs S1 and S2. Note that for any given schedule we have that(24)fj(Cj)={0forj∈B1φj(Cj−A)=φjCj−φjAforj∈S1∪B2φj(Cj−A)+λj(Cj−d¯)=(φj+λj)Cj−φjA−λjd¯=γjCj−φjA−λjd¯forj∈S2∪B3forj=1,…,n. The following lemma can be easily proved by using a simple pairwise interchange argument:Lemma 3In any optimal schedule, the jobs in B2are scheduled in a non-decreasing order of pj/φjand the jobs in B3are scheduled in a non-decreasing order of pj/γj.Let J(S1, S2) be the set of all jobs excluding jobs S1 and S2, and letn(S1,S2)=|J(S1,S2)|be the cardinality of set J(S1, S2). We note thatn(S1,S2)=n−1ifS1=∅,andn(S1,S2)=n−2otherwise. We next provide two different dynamic programming (DP) algorithms, the first for solving the1|(S1,S2)|∑j=1nfj(Cj)problem withS1=∅and the second for solving the same problem with S1 ≠ ∅.SinceS1=∅,no job completed within time intervalI2=[A,d¯)and S2 is the first job completed in time intervalI3=[d¯,P]. This further implies that job S2 begins its processing before time A, i.e., thatpS2≥d¯−A+1. Following Lemma 3 we renumber then−1jobs in J(∅, S2) in a non-increasing order of pj/γj. Similar to the algorithm presented by Lawler and Moore (1969), the state variable for the DP algorithm is (i, t) which corresponds to a partial schedule on job set{1,…,i},where t is the total processing time of the jobs assigned to B1. Let F(i, t) be the corresponding minimum cost for such a partial schedule. It is obvious that the condition thatt≤A−1has to be satisfied in any feasible partial schedule. The initial condition of each of the DPs is(25)F(0,t)={0ift=0∞otherwiseFor any0≤t≤A−1,we can reach state (i, t) from state(i−1,t−pi)by assigning job i to B1 (which is possible only if t ≥ pi) or from state(i−1,t)by assigning job i to B3. Since then−1jobs in J(∅, S2) are numbered in a non-increasing order of pj/γj, the assignment of jobs to set B3 is done from the end of the schedule. Thus, job i will be completed a timeP(n)−(P(i−1)−t)=∑j=inpj+t,whereP(k)=∑j=1kpj. It follows from (24) that the value of F(i, t) can be computed using the following recursion:(26)F(i,t)=min{F(i−1,t−pi)F(i−1,t)+γj(∑j=inpj+t)−φjA−λjd¯By using this recursion with the initial condition in (25), we calculate all F(i, t) values for any combination of0≤i≤n−1and0≤t≤A−1. At the end of the DP implementation, for any stateF(n−1,t)with0≤t≤A−1,we add the change in the objective value resulting from scheduling job S2. Since job S2 has to be completed within intervalI3=[d¯,P],ift+pS2≤d¯−1,we reset the value ofF(n−1,t)to ∞. Otherwise, according to (24), the cost addition of job S2 isγS2(t+pS2)−φS2A−λS2d¯. Thus, the optimal solution value for the1|(ϕ,S2)|∑j=1nfj(Cj)problem is given by the state(n−1,t)with the minimumF(n−1,t)+γS2(t+pS2)−φS2A−λS2d¯value among all calculatedF(n−1,t)values with0≤t≤A−1.Since0≤i≤n−1and0≤t≤A−1,we need to calculate the cost of O(nA) different states during the above DP implementation, each of which takes O(1) time according to (26). Thus, the following lemma holds:Lemma 4The1|(ϕ,S2)|∑j=1nfj(Cj)problem is solvable in O(nA) time.Let π1 and π2 be the job sequences corresponding to ordering then−2jobs in J(S1, S2) in a non-decreasing order of pj/φjand in a non-increasing order of pj/γj, respectively. According to Lemma 3, the jobs in B2 will be scheduled according to their order of appearance in π1 (from first to last), and the jobs in B3 will be scheduled according to the order of appearance in π2 (from last to first). Let πj(i) be the i’th element in πj, andJπ1(i)andJπ2(i)be the set of first i jobs in π1 and π2. Also letJ(i,j)=Jπ1(i)∪Jπ2(j)andP(i,j)=∑j∈J(i,j)pj. The state variable in the DP algorithm is (t1, t2, w2, J(i, j)), which corresponds to a partial schedule on job set J(i, j), where tiis the total processing time of the jobs assigned to Bifori=1,2,and w2 is the total φjweight of the jobs assigned to B2. Let F(t1, t2, w2, J(i, j)) be the corresponding minimum partial cost for such a partial schedule under the assumption that job S1 completes exactly at time point A (adjustments will be done at the end of the DP). It is obvious that the condition thatt1≤A−1has to be satisfied in any feasible partial schedule. In addition to this restriction, the conditions thatt1+t2≤d¯−pS1−1andt2≤d¯−A−1also have to hold in any feasible partial schedule. The set of t1 and t2 values that satisfies this three conditions is called a set of feasible t1 and t2 values. The initial condition of the DP algorithm is(27)F(t1,t2,w2,J(i,j))={0ift1=t2=w2=0andJ(i,j)=J(0,0)=∅∞otherwiseThen, the value of F(t1, t2, w2, J(i, j)) for any feasible t1 and t2 value depends on the four possible relations between J(i, j),J(i−1,j)andJ(i,j−1)as follows:Case 1J(i,j)=J(i−1,j)=J(i,j−1). For this case we have that(28)F(t1,t2,w2,J(i,j))=min{F(t1,t2,w2,J(i−1,j))F(t1,t2,w2,J(i,j−1))J(i,j)=J(i−1,j)andJ(i,j)≠J(i,j−1). For this case we can reach state (t1, t2, w2, J(i, j)) from one of the following three states: (i) from state(t1,t2,w2,J(i−1,j)); (ii) from state(t1−pπ2(j),t2,w2,J(i,j−1))by including job π2(j) in set B1 (which is possible only ift1≥pπ2(i)); or (iii) from state(t1,t2,w2,J(i,j−1))by including job π2(j) in set B3. Accordingly, we have that(29)F(t1,t2,w2,J(i,j))=min{F(t1,t2,w2,J(i−1,j))F(t1−pπ2(j),t2,w2,J(i,j−1))F(t1,t2,w2,J(i,j−1))+γπ2(j)(∑j=1npj−P(i,j−1)+t1+t2)−φπ2(j)A−λπ2(j)d¯whereP(i,j)=∑j∈J(i,j)pj.Note that (i) we do not assign job π2(j) in B2 (as such an assignment may violate Lemma 3), and that (ii) ift1<pπ2(j)we setF(t1−pπ2(j),t2,w2,J(i,j−1))=∞in (29).J(i,j)=J(i,j−1)andJ(i,j)≠J(i−1,j). For this case, we can reach state (t1, t2, w2, J(i, j)) from one of the following three states: (i) from state(t1,t2,w2,J(i,j−1)); (ii) from state(t1−pπ1(i),t2,w2,J(i−1,j))by including job π1(i) in set B1 (possible only ift1≥pπ1(i)); or (iii) from state(t1,t2−pπ1(i),w2−φπ1(i),J(i−1,j))by including job π1(i) in set B2 (possible only ift2≥pπ1(i)). Accordingly, we have that(30)F(t1,t2,w2,J(i,j))=min{F(t1,t2,w2,J(i,j−1))F(t1−pπ1(i),t2,w2,J(i−1,j))F(t1,t2−pπ1(i),w2−φπ1(i),J(i−1,j))+φπ1(i)t2Note that we do not assign job π1(i) in B3, as such an assignment may violate Lemma 3. Note also that in (30) we setF(t1−pπ1(i),t2,w2,J(i−1,j))to ∞ ift1<pπ1(i),and setF(t1,t2−pπ1(i),w2−φπ1(i),J(i−1,j))to ∞ if eithert2<pπ1(i)orw2<φπ1(i).J(i−1,j)≠J(i,j−1)≠J(i,j). In this case we can reach state (t1, t2, w2, J(i, j)) from one of the following four states: (i) from state(t1−pπ1(i),t2,w2,J(i−1,j))by including job π1(i) in set B1 (which is possible only ift1≥pπ1(i)); (ii) from state(t1,t2−pπ1(i),w2−φπ1(i),J(i−1,j))by including job π1(i) in set B2 (which is possible only ift2≥pπ1(i)andw2≥φπ1(i)); (iii) from state(t1−pπ2(j),t2,w2,J(i,j−1))by including job π2(j) in set B1 (possible only ift1≥pπ2(j)); or (iv) from state(t1,t2,w2,J(i,j−1))by including job π2(j) in set B3. Accordingly, we have that(31)F(t1,t2,w2,J(i,j))=min{F(t1−pπ1(i),t2,w2,J(i−1,j))F(t1,t2−pπ1(i),w2−φπ1(i),J(i−1,j))+φπ1(i)t2F(t1−pπ2(j),t2,w2,J(i,j−1))F(t1,t2,w2,J(i,j−1))+γπ2(j)(∑j=1npj−P(i,j−1)+t1+t2)−φπ2(j)A−λπ2(j)d¯,Note that we do not assign job π1(j) in B3, and job π2(j) in B2 as such an assignment may violate Lemma 3. Note also that in (31) we setF(t1−pπ1(i),t2,w2,J(i−1,j))to ∞ ift1<pπ1(i);F(t1,t2−pπ1(i),w2−γπ1(i),J(i−1,j))to ∞ if eithert2<pπ1(i)orw2<γπ1(i); andF(t1−pπ2(j),t2,w2,J(i,j−1))to ∞ ift1<pπ2(j).Using the recursion defined by (28)–(31) with the initial condition in (27), we calculate all F(t1, t2, w2, J(i, j)) values for any feasible t1 and t2 values, and all i, j and w2 values satisfying that0≤i≤n−2,0≤j≤n−2and0≤w2≤∑k=1iφπ1(k). Then, for any calculated state(t1,t2,w2,J(n−2,n−2)),we add the change in the objective value resulting from the exact scheduling of jobs S1 and S2. Since job S1 has to be completed within intervalI2=[A,d¯)and job S2 has to be completed within intervalI3=[d¯,P],if eithert1+pS1≤A−1ort1+pS1+t2+pS1≤d¯−1,we resetF(t1,t2,w2,J(n−2,n−2))to ∞. Otherwise, according to (24), the penalty for job S1 isφS1(t1+pS1−A). Moreover, since job S1 delays the start time of any job in B2 byt1+pS1−Aunits of time, we need to add additionalw2(t1+pS1−A)cost units to the objective value. In a similar way, according to (24), the penalty for job S2 isγS2(t1+pS1+t2+pS2)−φS2A−λS2d¯. Thus, the optimal solution value for the1|(S1,S2)|∑j=1nfj(Cj)problem with S1 ≠ ∅ is given by the state with the minimumF(t1,t2,w2,J(n−2,n−2))+(φS1+w2)(t1+pS1−A)+γS2(t1+pS1+t2+pS2)−φS2A−λS2d¯value among all(t1,t2,w2,J(n−2,n−2))states calculated by the DP procedure.Sincet1≤A−1,t2≤d¯−A−1,0≤i≤n−2,0≤j≤n−2and0≤w2≤∑k=1iφπ1(k),we need to calculate the cost ofO(n2A(d¯−A)∑j=1n−2φj)different states during the above DP implementation, each of which takes O(1) time according to the recursion defined by (28 )–(31). Thus, the following lemma holds:Lemma 5Any1|(S1,S2)|∑j=1nfj(Cj)problem with S1 ≠ ∅ is solvable inO(n2A(d¯−A)∑j=1nφj)time.The following theorem now directly follows from Lemmas 4 and 5 and the fact that solving the1||∑j=1nfj(Cj)problem requires the solution of O(n2) instances of the1|(S1,S2)|∑j=1nfj(Cj)problem with S1 ≠ ∅ and O(n) instances of the1|(S1,S2)|∑j=1nfj(Cj)problem withS1=∅:Theorem 8The1||∑j=1nfj(Cj)problem is solvable inO(n4A(d¯−A)∑j=1nφj)time.We studied a scheduling problem with due date assignment where the objective is to minimize the total weighted earliness, tardiness and due date assignment penalties. For each jobj∈{1,…,n},the due date assignment cost is assumed to be equal to zero if the due date (dj) does not exceed a given threshold Aj. Moreover, its value cannot exceed another predefined threshold ofd¯j,whered¯j≥Aj. We showed that the problem is equivalent to a two stepwise weighted tardiness problem, and thus it is stronglyNP-hard for a large set of special cases, even when the scheduling is done on a single machine. We then provide several special cases that are solvable in polynomial time and present an approximation algorithm for when the scheduling is done on a single machine. Since for most multi-machine systems, approximation algorithms do not exists unlessP=NP,we provide approximation results for a slightly modified problem. Finally, we present a pseudo-polynomial time algorithm to solve theNP-hard problem on a single machine with uniformd¯jand Ajvalues. Future research will be directed toward finding out if the pseudo-polynomial time algorithm can be converted into an FPTAS, and to study other due date assignment problems, where the due date values are upper bounded.

@&#CONCLUSIONS@&#
