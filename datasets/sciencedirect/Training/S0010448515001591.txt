@&#MAIN-TITLE@&#
Vectorizing NURBS surface evaluation with basis functions in power basis

@&#HIGHLIGHTS@&#
Direct evaluation of NURBS curves and surfaces.Basis functions precomputed in shifted power basis.Branchless vectorized linear search to compute span index.Vectorized evaluation of NURBS surface: x 3 speedup.

@&#KEYPHRASES@&#
NURBS,Evaluation,Vectorization,SSE,

@&#ABSTRACT@&#
Several known methods for direct evaluation of NURBS curves and surfaces are described. Runtime performance and simplicity of vectorization are discussed. An evaluation method, which uses basis functions precomputed in shifted power basis, is shown to be promising. This method for surfaces is vectorized with SSE2 intrinsics, yielding 3 times performance improvement over the non-vectorized version. Branchless vectorized linear search is proposed for span search, being most efficient for small number of knots. Binary search ending with a small linear search is shown to be most efficient for large number of knots, and good for general case. Performance comparison of the evaluation method and its equivalents from available geometric kernels is included.

@&#INTRODUCTION@&#
NURBS curves and surfaces are considered a standard for geometry representation in CAD models. Direct evaluation of NURBS is a basic routine that is required to work with NURBS.Many papers are devoted to direct evaluation of NURBS curves and surfaces. Generally speaking, it is desirable to make NURBS evaluation as fast as possible without losing numerical stability. Papers [1,2] are dedicated to reducing amount of operations for evaluation. The latter one uses Horner-like evaluation of Bernstein polynomials. A comparison of NURBS evaluation in several representations was done in  [3]. Nowadays, GPU computing is a modern trend. [4] is dedicated to NURBS evaluation completely on GPU.Current paper contains a brief survey of several known NURBS evaluation methods. A major performance improvement is achieved by vectorizing NURBS surface evaluation. The related decisions and results are presented. It is worth noting that high-performance NURBS evaluation on CPU is very important in CAD because it can be used anywhere in a geometric kernel, unlike a GPU version which can be beneficial only for algorithms that use massive evaluations of NURBS (more than 104 points at once). Also, geometric kernels use double precision to cope with great stability problems, and most of current consumer video cards still do not have proper double precision hardware, resulting in 10–30 times difference in peak single precision and double precision performance.The algorithms studied in the current paper were implemented and used during the development of Russian Geometric Kernel.11Russian Geometric Kernel is a geometric modeling kernel being developed in Russia according to the governmental program “National Technological Base”: “Developing Russian Licensable Software — a Mathematical Kernel for 3D-Modeling as a Basis of Computer Systems for Computer-Aided Design of Complex Engineering Products”.The paper is organized as follows. Section  2 briefly summarizes the notations and assumptions used throughout the whole paper. Then a survey of several known techniques is given. An algorithm for point evaluation based on basis functions is described in Section  4. Cox–de Boor formula and power basis representation are compared, the shifted power basis form is introduced. In Section  5 ideas of alternative methods are presented, which evaluate NURBS directly in 3D space. Table 2 summarizes the outlined methods at the end of the section. Section  6 is dedicated to extending the basis functions approach for derivatives evaluation. The chosen method is described in Section  7. Most of that section is dedicated to vectorized implementation of NURBS surface direct evaluation. Linear search and binary search for getting span index are compared in Section  7.2. Finally, a comparison of NURBS evaluation methods is done in Section  8.The following NURBS-related notations are used throughout the paper. Spline degree is denoted byd, and order is denoted byp(by definitionp=d+1). In case of surface subscriptsuandvare sometimes added to distinguish between quantities for U and V parameters. The number of control points is denoted byn(bynuandnvfor surfaces). The knots are denoted bykifori=0…n+p−1. The sequence of knots must be non-decreasing. NURBS must be clamped, i.e. multiplicities of the first and the last knots are equal top. Multiplicities of all the other (internal) knots must not exceedd. A span is an interval between two subsequent knots. There aren−dspans in total, though some of them may be degenerate if internal knots with multiplicity are present. Degree and knots sequence together define a family of basis functionsNi,d(t)fori=0…n−1. Control points and weights are denoted byPiandwifor curves(i=0…n−1), andPi,jandwi,jfor surfaces. These basis functions are used as coefficients to blend control points into a point on NURBS. For each span, there arepcontrol points that may contribute to the point position (called control points of the span). A NURBS is called polynomial (or non-rational) if all the weights are units, and it is called rational otherwise. Both NURBS curves and surfaces are in three-dimensional space.Most of NURBS present in CAD models have degrees not greater than three, though there are exceptions. Splines of degree one are usually present in extrusion and ruled surfaces. Quadric surfaces, tori, and surfaces of revolution yield degree-two NURBS. A lot of geometric shapes are approximated by cubic splines, so NURBS of degree three are often used too.High-performance computing on modern x86 CPUs cannot be done without vectorization. Although AVX instruction set is widely used already, processors without it are still common. An older instruction set for double precision calculations is SSE2, which was introduced somewhere around 2001. Nowadays SSE2 is often a prerequisite for a lot of different software, including CAD software. The current paper contains a major section dedicated to SSE2 optimization (see Section  7.1).For the sake of performance analysis, subtraction and addition are not distinguished, since they take the same amount of time and are usually performed on the same execution units. Also, paired multiplication and addition is often be counted as MAD operation. This reflects the fact that most of the modern processors have separate add and multiply execution units that can work simultaneously. Moreover, some architectures (for instance Intel Haswell) have support for fused multiply–add SIMD instructions. So the throughput of paired multiply and add together is usually equal to that of only multiply or only add operations. The other fact worth noting is that division operations are incredibly slow. For instance,  [5, Table C-15] states that division is 35 times slower than both multiplication and addition. Time of addition or subtraction is denoted byTadd, multiplication byTmul, division byTdiv, and multiplication with addition byTmad.All the performance measurements were done on a single computer with Intel Core i7-3770 3.4 GHz processor. Despite the fact that the processor has 4 physical cores, only a single core was always used. Intel LINPACK benchmark was used to estimate its computational performance in double precision. The benchmark achieves 23.2 GFlops on a single core of the processor. Note that the benchmark is based on AVX instructions, and its peak performance on SSE2 instructions is likely to be lower. All the programs were compiled by msvc2010 (Visual Studio 2010) for 32-bit architecture, including all the binaries of all the geometric kernels used.The evaluation of a NURBS curve starts with determination of a span which contains a given curve parameter. Letkbbe the last knot not exceeding valuetof the parameter. The indexb∈[d…n−1]is a result of the span search procedure. In case of a surface it is necessary to perform two span searches: along U and V surface parameters.Since the array of knots is sorted, the span can be found by binary search in logarithmic time. However, binary search necessarily consists of scalar instructions and branches. On the other hand, linear search can be implemented in vectorized way and without branches. Despite the bad asymptotic time, linear search is actually faster unless the number of knots is large. Detailed discussion on linear search will be given in Section  7.2.One of the ways to compute NURBS is to evaluate all the required basis functions first. Then the convex combination of all the influencing control points is calculated, with coefficients equal to basis functions values.The recurrent definition of the basis functions is(1){Ni,d(t)=t−kiki+d−kiNi,d−1(t)+ki+d+1−tki+d+1−ki+1Ni+1,d−1(t)Ni,0(t)=I(ki≤t<ki+1),whereI(condition)stands for indicator function: it is equal to one when condition is true, and to zero otherwise. Also, this formula is known as Cox–de Boor recursion formula.Since most of the basis functions are zero, inverted triangular scheme is used to compute only the required basis functions [6]. For each degreedonlyi∈[b−d;b]can yield nonzero values ofNi,d(t), wherebis the index determined by span search. The overall number of nonzero values is12d(d+1). An optimized algorithm for (1) is given in  [7, Algorithm A2.2]. The amount of operations isTdbf≈p22×(2Tadd+2Tmul+1Tdiv).For a cubic case, it is18Tadd+12Tmul+6Tdiv.Clearly, most of the computational time here is spent on division. One way to overcome this problem is to precompute(ki+d−ki)−1for alliandd. However, given the associated memory cost, it is more efficient to precompute other representations of basis functions instead. Another problem is the complex structure of computation which is hard to vectorize. The major advantages of using de Boor formula are: no precomputation required, numerical stability.Representation in power basis allows perhaps the fastest way to evaluate a polynomial. However, there is a major drawback: evaluation in power basis is unstable for high degree polynomials. More information can be found in  [8].All the nonzero basis functions can be stored as polynomials in power basis. More precisely, basis functionsNb−d,d(t),…,Nb,d(t)are stored for each nondegenerate span[kb;kb+1). They requirenp2real numbers of storage andO(np3)time to precompute.Unfortunately, storing basis functions in the form∑ajtjis not possible in practice. Computational error is unacceptable for cubic curves with many control points. This instability can be easily demonstrated on a cubic Bézier curve defined on a span [0.999;1.000]. In such case the basis function for the last control point isN3,3(t)=(x−0.9990.001)3. Clearly,N3,3(1)=1(i.e. the endpoint is located at the last control point). However, if we compute it in power basis form109(x3−2.997x2+2.994…x−0.997…), we will get error about10−7due to large magnitude of individual monomials.The problem is solved by shifting the power basis. All the polynomials on span[kb;kb+1]are stored in the form∑aj(t−kb)j, i.e. the left knot of the span is subtracted from the parameter value before polynomial evaluation. We have used the shifted power basis evaluation extensively in a geometric kernel, and we have not seen any instability on a real industrial case.Horner’s rule is used to evaluate polynomials. To calculate all the basis functions at a given parameter,ppolynomials must be evaluated in total. The amount of computations is:Tpoly=pd×Tmad.It is12Tmadfor cubic splines, which is clearly less than de Boor formula requires. What is more important, each polynomial is evaluated in the same way. As a result, it is easy to vectorize computation across polynomials.After basis functions are calculated, the final point is computed as convex combination of the control points of the span. In future this operation will be called “blending” of control points. The formulas and the number of operations in various cases are given in Table 1. If NURBS is non-rational (poly in table), one addition and one multiplication per control point can be saved compared to the rational case (rat in table).This part of NURBS evaluation is notable for taking most of the computational time for surfaces. For example, for a cubic polynomial curve it takes12Tmad, same as for basis functions evaluation via power basis. For a bicubic polynomial surface, it takes48Tmad+16Tmul, whereas basis functions can be evaluated in24Tmadtime. If derivatives are computed along with the values, this part takes even more time (see Section  6). Luckily, this part is also very simple both conceptually and structurally, so it can be easily vectorized efficiently.The rational case has a simple explanation in terms of homogeneous coordinates. Consider an auxiliary non-rational NURBS in four-dimensional space with same basis functions and control points in the form(wiPi(x),wiPi(y),wiPi(z),wi). A point on the rational 3D NURBS has homogeneous coordinates equal to the corresponding point on non-rational 4D NURBS. Although it seems that precomputingwiPiis beneficial, careful consideration reveals that it does not reduce overall amount of instructions.Another approach is to evaluate the point directly in 3D space without computing basis functions first.A Bézier curve can be evaluated by de Casteljau algorithm (see  [9, Section 2.3]). De Boor algorithm is a generalized version of de Casteljau algorithm which works for NURBS curves (see  [9, Section 5.4]). Both algorithms generate enough intermediate results to subdivide a curve into two subcurves at a given parameter. Also, there are versions of these algorithms for surfaces too.However, they require significantly more instructions to compute. For instance, evaluating a polynomial curve with de Boor algorithm takes timeTdbp≈p22×(3Tmad+3Tmul+3Tadd+1Tdiv),where3Tadd+1Tdivper step is spent on computing coefficients, and3Tmad+3Tmulper step is spent on taking convex combinations. For a cubic curve it results in18Tmad+18Tmul+18Tadd+6Tdivtime. This is strictly more than it takes to evaluate via basis functions with de Boor recursion formula.De Boor algorithm can be generalized for a surface as follows. Run de Boor algorithmptimes along U parameter to obtain control points of V-isoparametric curve. Then run once more along V parameter to obtain a point. Using the fact that coefficients are the same for all the runs along U, the time spent on bicubic polynomial surface is30×(3Tmad+3Tmul)+12×(3Tadd+1Tdiv).Just like de Boor recursion formula has its equivalent straight in 3D space, it is possible to directly use polynomials in 3D space too.In case of a curve, each coordinate on each span can be precomputed as a polynomial in power basis. This requires3npvalues of storage (4npfor rational case) andO(np3)precomputation time. Each evaluation requires3d×Tmadtime afterwards (4d×Tmad+Tdivfor rational case). For instance, it takes12Tmadtime for a cubic polynomial curve, which is twice less than evaluation via basis functions polynomials requires. Clearly, this way is the fastest among all considered in the current paper.For a surface, it is possible to precompute a two-variable polynomial for each coordinate on each UV-span. This takes3nunvpupvvalues of storage andO(nunvpupv+nupu3+nvpv3)precomputation time in non-rational case, and each point evaluation requires approximatelypupv×(3Tmad+1Tmul). This is equal to the time of blending control points (see Table 1), and it is slightly less than the time required to fully evaluate a surface via basis functions polynomials. However, the memory overhead is really discouraging.All the described evaluation methods are summarized in Table 2.It is often necessary to evaluate derivatives of NURBS along with a point. Consider a routine that evaluates all derivatives up to orderq. Here is a summary of various problems in solid modeling that use such a routine:1.q=0.•Evaluation of a single point by parameters.Tessellation without normals.q=1.•Surface tessellation with (non-approximate) normals.Inverse evaluation of parameters by a point (Newton’s method).Approximation by cubic spline.Transversal intersection of curves and surfaces (Newton’s method).Tracing of transversal surfaces intersection (tracing direction).q=2.•Point projection: finding locally closest point (Newton’s method).Singular intersection of curves and surfaces (Newton’s method).44See  [10, Chapter 3] or  [11, Chapter 6] for details about equation systems used to deal with singular intersections.Tracing of tangential surfaces intersection (tracing direction).2All the considered methods can be extended to produce derivatives up to any order.According to  [7, Section 2.3], the following formula can be used to evaluate derivatives:Ni,d(m)(t)=(d+1)!(d+1−m)!∑j=0mAm,jNi+j,d−m(t),whereAm,jis a triangular matrix(j=0…m)defined by{A0,0=1Am,j=Am−1,j−Am−1,j−1ki+j+p−m+1−ki+j.An implementation can be seen in  [7, Algorithm A2.3].It is hard to estimate computational time of the algorithm. Most importantly, the number of divisions is12(p(p−1)+q(q+3)). For example, to evaluate derivatives up to second order of a cubic family of basis functions, 11 divisions will be done.Horner’s rule can be used to evaluate all derivatives up to any prescribed order  [12]. To evaluate all derivatives up to orderq≤dof a polynomial∑i=0daitiatt=x, fill a trapezoidal table of values as follows55Uninitialized values are considered to be zeros in this formula.:{Ri−1=aiwherei=0…dRim=xRi+1m+Rim−1wherei=m…d,m=0…q.Then the derivatives can be extracted from the formuladmdtm(∑i=0daiti)(x)=m!Rmm.Instead of storing the whole tableR, it is possible to use onlyq+1additional variables. To achieve this, the table entries must be evaluated in orderi=d…0,m=0…min(q,i). The table can be filled in12(q+1)(2d−q)Tmadtime. For example, fully evaluating derivatives up to second order for a cubic polynomial takes6Tmad+Tmultime. Therefore, to evaluate derivatives for the whole family of cubic basis functions,24Tmad+4Tmultime is necessary.After all the necessary basis functions have been evaluated with derivatives up toqth order, the control points are blended. The blending operation for derivatives means taking linear combination of the control points (which is no longer convex).Suppose that the NURBS is polynomial. Then formulas from Table 1 can be used to calculate any derivative, given that corresponding derivatives of basis functions are used. For example, to evaluatemth derivative of a NURBS curve we use formula from the poly-curve entry of the table, but with coefficientsai=Nb−d+i,d(m)(t). To get a mixed derivative of orders/tof a surface,aishould containsth derivatives of basis functions along U, andbjshould containtth derivatives of basis functions along V.If the NURBS is rational, then the formulas from Table 1 cannot be used directly. We rely on homogeneous coordinates formulation instead (explained in Section  4.3). Consider a 3D rational NURBS curveR(t)and its equivalent non-rational 4D curve(P(t),w(t))in homogeneous coordinates. HereP(t)arex,y,zhomogeneous coordinates andw(t)is the lastwcoordinate.The formulation states thatR(t)=P(t)/w(t), orP(t)=R(t)w(t). By differentiating the last identitymtimes, the following equality is obtained:∑i=0m(mi)R(i)(t)w(m−i)(t)=P(m)(t).It can be used to compute derivatives ofR(t)one by one. For a surface, the equality looks similar:∑i=0s∑j=0t(si)(tj)R(i,j)(u,v)w(s−i,t−j)(u,v)=P(s,t)(u,v).The binomial coefficients can be precomputed. Then it takes the following amount of time to compute 3D derivatives from the derivatives of homogeneous coordinates:Thdercurve≈q22×(3Tmad+1Tmul)+q×3Tmul+1TdivThdersurf≈q2(q+5)224×(3Tmad+2Tmul)+(q+1)22×3Tmul+1Tdiv.Suppose that all derivatives up to second order are evaluated, i.e.q=2. Then for a cubic curve it takes9Tmad+12Tmul+1Tdiv, and for a bicubic surface it takes27Tmad+36Tmul+1Tdiv. Note that this is close to the number of operations required to blend control points once. However, one blending operation is done per each derivative computed. For instance, 3 blending operations are done for the curve and 6 blending operations for the surface (withq=2). This observation once again confirms that blending control points is the most computationally expensive part of NURBS evaluation.Our choice of NURBS evaluation algorithm was influenced by the needs of the geometric kernel being developed.First of all, a well-known and reliable algorithm was necessary as a solid foundation for future experiments. That is why we have implemented a standard approach described in  [7]. It evaluates basis functions by Cox–de Boor recursion formula (see Section  4.1). Derivatives of basis functions are evaluated in a standard way too (see Section  6.1). Control points blending is done afterwards (as in Section  4.3). Finally, in case of a rational NURBS, the 3D derivatives are computed (as described in Section  6.3).The next idea was to simplify basis functions evaluation and to get rid of slow division operations. Precomputation of basis functions in power basis was implemented and used in evaluation. Initially polynomials in the form∑aitiwere used, and a major instability was found soon on a NURBS with high number of control points. Then we switched to shifted polynomials∑ai(t−s)ias described in Section  4.2. As a result of turning from Cox–de Boor formula to polynomials, NURBS evaluation became faster. However, some operations of the geometric kernel (e.g. surfaces intersection) still showed high percentage of time spent in NURBS surface evaluation.The situation with NURBS curves was acceptable: a single evaluation of NURBS curve does not take too much time, especially compared to the time spent to process the obtained results in the higher-level algorithm. Another observation was that NURBS curves are often created as a cubic spline approximation of some curve. Such curves usually contain hundreds of points, and the number of evaluations performed for them is rather small. That is why it was not worth to precompute anything to further optimize the NURBS curve evaluation.At that moment there was no algorithmic potential left for optimizing NURBS surface evaluation. We had not tried de Boor algorithm in 3D space (described in Section  5.1), because it was conceptually slower than both algorithms which use basis functions. The only other algorithm we knew about that does fewer operations was evaluating bivariate polynomials in 3D (described in Section  5.2). This idea of precomputing piecewise-polynomial representation was rejected because of memory overhead.Finally, we decided to improve low-level performance. The amount of computation in a single evaluation of a NURBS surface is rather large, so vectorization can be used. As mentioned in Section  2, SSE2 is common nowadays, so 16-byte registers can be used to store and process two double precision floating point numbers at once.There are two conceptually different ways to vectorize a computational routine. The first one is to accelerate a single launch of the routine (i.e. single point evaluation). The second way is to vectorize across several launches of the routine (i.e. evaluate 2 or 4 points at once). An example of applying the second approach to evaluation of a cubic polynomial can be seen at Fig. 1. There are two reasons why this approach should not be applied to NURBS evaluation:1.The interface of the routine is changed: the caller must evaluate several points at once instead of evaluating points one by one. This is not possible for some algorithms like Newton iteration and curve tracing, which are inherently serial. Besides, it is not convenient to adapt algorithms to such interface.Each span has its own set of data used in evaluation.Given 4 points, the points would most likely get into different spans. As a result, a completely different set of data (i.e. knots, weights, control points) would be necessary to evaluate each point. It is not possible to vectorize such computation efficiently.If all the spans are the same, then the same data would be used for each point. However, this condition is hard to achieve. In fact, it is possible only if the user asks to evaluate a lot of points (i.e. significantly more than the number of rectangular spans) at once. In such case the points can be distributed across the spans first, and then a series of vectorized 4-point evaluations can be run on each span. As a result, the algorithm must be able to evaluate a lot of points at once to benefit from such a routine.The first approach is to compute a single point as usual, but to vectorize the internal computation. The main advantage of this approach is that the interface is not changed: every algorithm that evaluates NURBS surfaces can benefit from the vectorized routine without any code changes. Luckily, the most time-consuming part (i.e. blending control points) can be vectorized easily. Moreover, it is possible to evaluate all basis functions at once if the polynomials are stored in proper layout.As already noted in Section  3, span index can be found by binary search. In fact, std::lower_bound function of C++ STL library suits this case perfectly. Being a part of standard library, it is not very optimal though.It is also possible to perform a linear search to find the span. It can be implemented without branches by using the following observation. In a sorted array the index of the first element that is greater than or equal to the given value is exactly the number of elements which are less than the given value, because these elements are precisely the elements located to the left of the sought-for position. Therefore, we need only to count how many knots are less than the given parameter value.More specifically, the span index is computed as(2)span(t)=clamp[0;n−p](∑i=lr−1I(t>ki)+(l−p))+d,whereI(condition)denotes indicator function of condition,clamp[0;n−p]is a function that limits its argument to the range[0;n−p], and[l;r)is the range of knot indices participating in the search. Note that there is some freedom in choosing the range of knots to process because the first and the lastpknots do not affect the span index. That is why the indiceslandrcan be chosen arbitrarily, given that0≤l≤p≤n≤r≤n+p. For example,l=0andr=2⌈n2⌉can be chosen to satisfy alignment requirements of SSE2.The sum in (2) can be efficiently vectorized. _mm_cmplt_pd intrinsic is used to compare two knots with the parameter as a single operation. It produces values −1 when the condition is true, so _mm_sub_epi32 intrinsic allows to compute the number of knots. Full listing is given in the Appendix.Fig. 2shows comparison between different span search routines. Speed of full point evaluation on a bicubic NURBS surface was measured. Clearly, the binary search from STL is slower than the custom version of binary search. Vectorized linear search is very slow for large number of knots, but it is the fastest algorithm for small number of knots (32 or less). To take the best from both algorithms, we use a hybrid approach. It runs iterations of the custom binary search until the number of knots in question becomes 16 or less. Then the vectorized linear search is done for the remaining knots. The hybrid algorithm is not much slower than the linear search for small number of knots, and it becomes the fastest algorithm for large number of knots.All the basis functions are precomputed asppolynomials of degreedon each span. They are all evaluated simultaneously using extended Horner rule as described in Section  6.2.In order to vectorize evaluation across several polynomials, their coefficients are stored in a layout different from the obvious one. For each degree, the coefficients of terms of that degree (for all polynomials) are stored contiguously. Also, if the number of polynomials is odd, a zero polynomial is added for alignment, so there are2⌈p2⌉polynomials in total.The exact version of Horner’s rule used can be seen in Algorithm 1. The generic version of computation works the same way, but instead of having a single real number for each value,⌈p2⌉pairs of values are stored in XMM registers. An example of evaluating only values (without derivatives) of basis functions polynomials is shown in Fig. 3.There is some overhead in the generic version of the algorithm, which is significant when the amount of computation is small. In practice the evaluation is mostly called for NURBS orderp=2,3,4and required order of derivativesq=0,1,2. To remove the overhead, several special cases of the algorithm were implemented, which completely cover all the aforementioned cases. They noticeably improved performance: in all such scenarios, the evaluation speed without special cases is only 82%–85% of the speed with special cases.Being most computationally expensive, this part should work as fast as possible. For the sake of code simplicity, all the control points are premultiplied by weights and stored as 4D vectors (with weights) in a matrix.As explained in Section  6.3, the same control points blending operation must be performed for each derivative being evaluated. Each time proper derivatives of basis functions must be used as blending coefficients. As a result, control points blending can be expressed as a simple computational routine described just below.Letαiandβjbe row and column blending coefficients, andMi,jbe 4D control points involved in the computation. Note that the matrixMis a submatrix of sizer×cof the whole control points matrix. Ideally, the size of the matrixMshould bepu×pv, but it can slightly increase due to padding (e.g.c=2⌈pv2⌉). The blending result is(3)∑i=0r−1∑j=0c−1αiMi,jβj.The sum (3) is evaluated in the following way. First of all, the number of columnscmust be even. If orderpvis odd, then the arrayβof column coefficients is padded with a zero. The matrix is processed row by row, the points in each row are processed in pairs(j=2s,2s+1). A single _mm_mul_pd intrinsic allows to obtainαiβjproduct for both points at once in a XMM register. Then two control points involved are multiplied by correspondingαiβjcoefficients and added to global accumulators. Since each point has four coordinates, four _mm_mul_pd and _mm_add_pd are used to do this. Full listing of this routine is given in the Appendix.If run separately on a bicubic surface (4×4 points), this code runs at speed 59.6 millions of blending operations per second. Given that the code performs64Tmad+16Tmuloperations and considering MAD as two operations, 8.58 GFlops is achieved, which is 37.0% of the computational performance achieved by LINPACK benchmark. It is worth noting that other parts of computation significantly reduce performance (see final results in Section  8).The last part of NURBS surface evaluation is obtaining derivatives of 3D coordinates from the derivatives of homogeneous coordinates (see Section  6.3). Obviously, it is required only for rational NURBS, so this part can be omitted for non-rational ones.The generic version of this routine is implemented also with SSE2, but it is almost completely scalar. Only a bit of vectorization is applied to X and Y coordinates of vectors.More importantly, the real world applications usually require derivative orderq≤2. Special cases were implemented forq=0,1,2. For each case, explicit formulas were written down on a piece of paper and coded with SSE2. Given a bicubic surface, disabling these special cases decreases speed by 4% forq=0, by 12% forq=1, and by 17% forq=2.To help compiler reduce the overhead, it is worth to forceinline all the parts of NURBS surface evaluation into a single function. For point evaluation on a bicubic surface, consider three versions: with forced inlining, without forced inlining (compiler decides), and with forbidden inlining. The first one runs with maximal speed. The speed of the second one is 91% of this maximum, and of the third is only 86% of the maximum.The other thing worth mentioning is the size of the compiled binary code. Binaries of geometric kernels often take ten mebibytes or more space. Due to this reason, the complete size of NURBS evaluation code should not be very large, because otherwise instruction cache misses can ruin the performance. The whole function that evaluates NURBS surface with SSE2 is of size 4.36 kibibytes.It is worth noting that the vectorized evaluation is fully integrated into the geometric kernel. It checks whether the input parameters are out of domain and performs periodic normalization if necessary. The caller does not have either to know anything about SSE or to worry about memory alignment.Three routines for NURBS evaluation were implemented (only SSE being vectorized):1.via basis functions computed by de Boor formula (de Boor),via basis functions as precomputed polynomials (poly),vectorized evaluation on SSE2 as in case 2 (SSE, surfaces only).Several existing geometric kernels were used to compare with:1.The free OpenCASCADE kernel, version 6.8.0 (OCCT).Fully equivalent methods Geom_BSplineCurve::D0,D1,D2 and Geom_BSplineSurface::D0,D1,D2 were compared.The NLib library, part of smLib geometric kernel, version 8.7.6 (NLib).This library was initially implemented as sample code for  [7]. Fully equivalent functions N_CrvDerivs and N_SrfDerivs were used.The C3D geometric kernel, version V16-93302 (C3D).This kernel has no routines to compute all derivatives up to given order, only routines to compute a single specified derivative. We made several calls per point to compute all the necessary derivatives ordered by derivative order decreasing. Even though there is some caching scheme for results of evaluation at the last point, the comparison is still slightly unfair.Methods MbNurbs3D::PointOn,FirstDer,SecondDer were used for curves.Methods MbSplineSurface::PointOn,Derive?,Derive?? were used for surfaces.The performance of all the routines has been measured for various combinations of NURBS degree and maximal derivative order. Rational NURBS curves and surfaces were generated with random 16 knots along each parameter and random control points. Each speed was measured by running evaluations on a list of 1024 parameters in a loop until one second of time had passed.The results are shown in Tables 3 and 4. The vectorized version is about three times faster than the simple polynomial-based version. Evaluation of a bicubic surface with derivatives up to second order takes about2×(24Tmad+4Tmul)+6×(64Tmad+16Tmul)+(27Tmad+36Tmul)operations. Counting MAD operations as two, there are 1058 operations in total. It means that our vectorized evaluation achieves 4.031 GFlops, which is 17.4% of the computational performance achieved by LINPACK benchmark.Regarding stability of SSE evaluator, its results were sufficiently precise for the random surfaces benchmarked. For each total derivative order, we measured maximum norm of evaluation results, and maximum difference between results of de Boor and SSE evaluators. The ratio of these two values shows relative precision of the computation (for fixed total derivative order). The relative precision was about 10−15 most of the time, 3⋅10−14 was the largest value observed. Note that the numerical behavior can be totally different for different knots sequences.Evaluation methods poly and SSE require some preprocessing in order to work. Precalculated basis functions polynomials are used in both methods. Additionally, the vectorized routine SSE needs all data to be duplicated in correct layout. Despite the fact that we have not specifically optimized the precomputation of polynomials, we provide some data about how slow it is.In order to estimate time spent on preprocessing, we measured speed of two loops. In the first one a random NURBS is created and one point is evaluated on it. In the second one a random NURBS is created, it is fully preprocessed for corresponding evaluator, and one point is evaluated. Assuming that point evaluation takes negligible time, the speed of the preprocessing itself was calculated from this data. Cubic curves and bicubic surfaces were used. Surfaces have same number of knots along each parameter, as drawn in the plot.The results are provided in Fig. 4. When calculating polynomials for curves, 12 thousand curves with 64 knots can be processed per second, 2.5 thousand curves with 512 knots. Full preprocessing necessary for SSE surface evaluator works at speed 3.5 thousand surfaces per second with 64+64 knots, 100 surfaces with 512+512 knots.Fig. 5also shows how much evaluations must be done so that preprocessing pays off. ValueKis plotted on Y axis, when evaluatingKpoints with de Boor method takes same time as doing all the necessary preprocessing for faster evaluator and evaluatingKpoints then. Note thatKdepends on how much derivatives are evaluated.

@&#CONCLUSIONS@&#
