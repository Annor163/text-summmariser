@&#MAIN-TITLE@&#
Closed-form representation of matrix functions in the formulation of nonlinear material models

@&#HIGHLIGHTS@&#
Derivation of closed-form representation of 3×3 matrix functions.Closed form representation includes first and second derivatives.Solution to the ill-conditioning in the vicinity of multiple equal eigenvalues.Derivation based on symbolic description, automatic coding and automatic differentiation.Application includes finite strain Cam-Clay model.

@&#KEYPHRASES@&#
Matrix functions,Nonlinear materials,Automatic differentiation,Closed-form,Cam-Clay model,

@&#ABSTRACT@&#
The paper presents new approach to the evaluation of matrix functions operating over tensors that are essential part of formulation of complex nonlinear material models in mechanics of solids. A method is presented how to automatically derive numerically efficient closed-form representation of an arbitrary matrix function and its first and second derivatives for 3×3 matrices with real eigenvalues. The method offers an unique solution to the standard problem of ill-conditioning in the vicinity of multiple equal eigenvalues which is characteristic for all closed-form representations. A compiled library of subroutines with derived closed-form representation of most commonly used matrix functions along with their first and second derivatives has been created and is available for the use in general finite element environments. Consequently, the matrix functions can become as accurate, efficient and commonly available as their scalar counterparts, resulting in more common use of advanced strain and stress measures, such as Hencky strain measure which have so far been considered difficult for implementation. Accuracy and efficiency of the derived closed-form representations was compared with corresponding truncated series expansion and a speed up between 20 and 80 times has been observed depending on the matrix. The proposed methodology was tested on a set of selected nonlinear material models where matrix functions play an essential part in nonlinear finite element formulation.

@&#INTRODUCTION@&#
Many commonly used inelastic material models exhibit highly non-linear behavior. Solving such problems without appropriate formulation can cause large errors accumulating with each incremental step. One such example is incremental finite strain formulation of multiplicative elasto-plasticity where an exact preservation of the plastic incompressibility condition relies on appropriate time integration. It has been shown that an appropriate integration can be achieved by using exponential map integrators [1–3] with the exact matrix exponential as an essentials part of the algorithm. Additionally, derivatives of matrix exponential must be known, to derive consistent tangent matrix. Strain energy functions for finite strain elements can sometimes also be expressed with matrix functions. One example of inelastic model is finite strain Cam-Clay model [4], which has strain energy expressed with the logarithm of deformation tensor. In this case, the first derivative of the matrix logarithm is required to derive governing equations and the second derivatives of matrix logarithm to derive consistent tangent matrix. In all these cases the accuracy and numerical efficiency of the resulting finite elements depend strongly on the accuracy and numerical efficiency of the evaluation of matrix function and its derivatives. Accurate first derivatives of matrix functions can in theory be calculated with the use of finite differences method, but calculating accurate second order derivatives with the use of finite differences method is in general an ill-conditioned problem.Let us assume that there exists a numerical library of subroutines that numerically efficiently evaluates and returns selected matrix function and its first and second derivatives, calculated with machine precision accuracy on its whole definition interval. Then the matrix functions can be used in the same way as their scalar counterparts or any other elementary function. Consequently, the formulation and numerical implementation of complex non-linear material models where the use of matrix functions is essential can be greatly simplified. Machine precision accurate evaluation of matrix functions also improves the overall accuracy of numerical procedures. The paper presents a way how to automatically generate such a library by the means of an advanced automatic code generator AceGen[5], where an automatic differentiation technique [6] and automatic code optimization and generation are combined with symbolic system Mathematica[7].The calculation of a general matrix function of general n×n matrix is not a simple task. As a special case, Moler and Loan [8] have shown numerous possibilities of calculating matrix exponential. There is no general method which is completely satisfactory that would meet all demands regarding the numerical efficiency and accuracy of the results. Most commonly the methods for the evaluation of matrix functions are based on spectral decomposition [9–11] of the argument or its series expansion [12,10,13]. Spectral decomposition introduces the problem of accurate evaluation of eigenvalues and eigenvectors of a matrix, because they exhibit ill-conditioning and non-uniqueness in the vicinity of multiple equal eigenvalues. These areas require special treatment. Contrary to that the machine precision series expansion can be numerically inefficient, especially when higher order derivatives of matrix functions are also required. Among other possibilities, an arbitrary matrix function can be evaluated by differentiating an appropriate scalar generating function of eigenvalues of argument [14,15]. Since our interests lies with application in solid mechanics, we can limit ourselves to matrices of dimension 3×3. In this case the closed-form eigenvalues can be formulated analytically with trigonometric functions [16,3]. When eigenvalues are exactly equal, it is relatively easy to derive closed-form representation, but when they are nearly equal, ill-conditioning requires complicated asymptotic expansion of generating function.The approach where the matrix exponential is evaluated by differentiating an appropriate scalar generating function and the points of multiple equal eigenvalues are treated by series expansion of generating function was first introduced by Korelc and Stupkiewicz [3]. The use of matrix functions is in [3] focused on the use of matrix exponent as a part of volume preserving integration of evolution equations in finite strain plasticity. However, the benefits of the use of efficient and accurate closed form representation of matrix functions can be extended to other problems as well. For example, matrix logarithm can used to evaluate Hencky strain and matrix square root can be used to obtain stretch tensor without the use of polar decomposition. It turns out that the extension of the method presented in [3] for the evaluation of matrix exponential and its first derivative to general matrix functions and higher order derivatives is neither certain nor trivial. This is manly due to the two reasons. The coefficients of the expansion of a generating function in vicinity of multiple equal eigenvalues can only be obtained in closed form by a lengthy and complicated limiting process. In the case of matrix exponent, the generating function can be split into volumetric and deviatoric part which simplifies the series expansion. This is not the case for other matrix functions. In this work, the method is extended to matrix logarithm, matrix square root and matrix power. In [3] the consistent linearization of elasto-plastic problem only needed accurate evaluation of first derivative of matrix exponent. If the matrix function appears as a apart of strain energy function then the consistent linearization of the problem requires also second derivative of matrix function. In this work, the method is extended to include accurate closed-form representation of second order derivatives of all considered matrix functions.The program code for matrix function and its first order derivative can be automatically generated with AceGen at the same time as the rest of the element code. However, the second derivative of matrix function is a sixth order tensor and the derivation time of the closed form representation of the second derivative is too long for the real time code generation. The problem was solved in this work by creation of a compiled library of all matrix functions. The combination of ADB formulation, automatic code generator AceGen and compiled matrix functions library leads to the process that generates moderate size codes for complex material models in real time. The usual problem associated with automatic code generation, which is extremely large code sizes, is avoided with the proposed combination of tools.The closed-form representations of the mentioned matrix functions and their first and second derivatives will be derived for an arbitrary 3×3 matrix with real eigenvalues. Accuracy and efficiency of the derived closed-form matrix functions will be compared in the vicinity of multiple eigenvalues with its series expansion. Errors are in the range of machine precision for all matrix functions. The error grows with each derivative and is below 10−13 for the first derivatives, while errors of the second derivatives are below 10−10 on ill-conditioned areas.Finally, the numerical efficiency of the closed-form representation of matrix functions will be compared on various hyper-elastic and finite strain elasto-plastic models where the use of matrix functions and its derivatives is required including standard isotropic Neo-Hookean and Hencky hyper-elastic models and finite strain elasto-plastic model. At the end the use of several closed-form matrix functions within the same material model will be shown on an example of modified Cam-Clay soil model. Its strain energy can be expressed with matrix logarithm and the plastic evolution equation with matrix exponential.The presented closed-form representations of matrix function enable accurate, stable and numerically effective implementation of complex material models. The described procedure can be generalized to any matrix function, whether it be a simple square root of left or right Cauchy-Green tensor to calculate the stretch tensor or deformation or to calculate a tensor of logarithmic Hencky strains.Development of the closed-form representations of matrix functions and their first and second derivatives will be shown for 3×3 matrices that exhibit 3 real eigenvalues. Thus, the matrix in general does not need to be symmetric. However, the derived closed-form representation does not include the case where the matrix exhibits complex eigenvalues. Closed-form representations of the selected matrix functions and their first and second derivatives will be derived using AceGen[5] automatic code generation system and computer algebra system Mathematica[7].According to Lu [14], where an appropriate theoretical background of the method is given, a general matrix functionF(A)can be formulated as derivative of an appropriate generating functionG(A)with respect to the elements of the transposed matrix. Generating functionG(A)is defined as sum of auxiliary functionsg(λi)=∫f(λi)dλi, which are integrals of an equivalent scalar functionf(λi)applied on eigenvalues λiof matrixA. The general form of arbitrary matrix function is thus written as(1)g(λi)=∫f(λi)dλi,(2)G(A)=∑ig(λi),(3)F(A)=∂G(A)∂AT.In order to obtain a closed-form representation of matrix function, a closed-form representation of eigenvalues λiof 3×3 matrixAas a function of components ofAis needed first. Eigenvalues correspond to the roots of the cubic characteristic polynomial that can be easily obtained in various closed forms. However, as discussed in detail in [16] and [3], a special closed-form representation of eigenvalues is required in order to obtain machine precision matrix functions on the whole definition interval. The procedure to determine an appropriate closed-form representation of eigenvalues of 3×3 matrix is given in [3] and summarized here. First matrixAis split into volumetricA׳׳=λvIand deviatoricA׳=A-A׳׳parts, whereλv=13tr(A)represents eigenvalues of volumetric part. The volumetric-deviatoric split is performed here, to reduce round-off errors present in the vicinity of multiple eigenvalues [16]. The characteristic polynomial of matrixA′is then written in the following form:(4)λ׳3-12pλ׳-q=0,p=trA׳A׳T,q=detA׳.The eigenvalues ofA′can be written in closed-form using trigonometric functions as(5)λ1′=tcosϕ,λ2′=tcos(ϕ−2π3),λ3′=tcos(ϕ+2π3),where(6)t=23p,r=36qp3/2andϕ=13arccosr.The eigenvalues of matrixAare then defined asλi=λv+λi′.Closed-form representation of eigenvalues leads to the closed-form representation of generating function G. However, in the vicinity of multiple equal eigenvalues, Eqs. (6) become singular or ill-posed. The nature of eigenvalues can be determined from the sign of the determinantΔ=12p3−27q2:1.ifΔ>0, thenAhas three distinct real eigenvalues;ifΔ=0, thenAhas multiple (one or two) real eigenvalues;ifΔ<0, thenAhas one real and two complex conjugate eigenvalues.Since an application in solid mechanics is considered,Δ≥0must hold to ensure that matrixAhas three real eigenvalues. This condition is equivalent to condition−1≤r≤1and also implies conditionp≥0. When p and r are approaching boundary values, the equations become ill-conditioned. Additionally, when finite precision arithmetic is used, a small perturbation of p over 0 or perturbation of r over±1can cause eigenvalues to become complex, which leads to numerical problems.The basic idea behind the proposed method is that, contrary to the ill-conditioned eigenvalues, the generating functions G(2) are everywhere smooth and numerically stable functions. Therefore, the above mentioned numerical problems can be avoided by replacing G with its appropriate asymptotic expansion in the vicinity of critical values of parameters p and r. The vicinity is defined by appropriate tolerances εpand εrthat depend on the chosen matrix function. In order to illustrate this property, a generating function of matrix power defined according to Eq. (2) asGpow=∑i=13λiη+1/(η+1)is plotted alongside eigenvaluesλi′for constant values ofλv=3andη=−2.5. In Fig. 1the region wherep→0is plotted for constant value of q=0 and in Fig. 2the region wherer→±1is plotted for constant value of t=2. Note that the imaginary part of G is zero and real part of G is smooth and well defined on the whole interval of interest(p≥0∧|r|≤1)in both cases.The presented critical cases require special treatment. For the first special case, where the parameter p reaches 0, the generating function is expanded around p=0 and denoted by Gp. It can be easily shown that when the first conditionΔ≥0is satisfied,p≥0and−136p3/2<q<136p3/2. It follows that forp<εp, when toleranceεp>0is sufficiently small, q also approaches zero. Therefore, a multivariate asymptotic expansion of G around p=0 and q=0 is chosen. The series expansion of general generating function then follows as(7)Gp=∑i=0np∑j=0nqi+j≤npq∂i+jG(p,q,λv)∂pi∂qj|p→0q→0piqji!j!.where the minimum number of terms npand nqand the maximum combined power npqdepend on the chosen matrix function.For the second special case, where parameter r reaches ±1, the generating function is expanded around r=±1 and denoted as Gras follows:(8)Gr=∑i=0nr∂iG(r,t,λv)∂ri|r→±1(r+sr)ii!,wheresr={1ifr<−1+εr,−1ifr>1−εr,whereεr>0is a sufficiently small tolerance for the second special case. Withsr=±1, two special cases ofr→−1andr→1are covered simultaneously. The generating function can then be written for all special regions for all matrix functions as:(9)G={Gpforp<εp,Grforr<−1+εr⋁r>1−εr,Gelse.The evaluation of matrix functionF(A)requires the evaluation of the first derivative of generating function. If the evaluation of the first derivative(DF(A))or the second derivative(D2F(A))of matrix function is required, the evaluation of higher order derivatives of generating function is also required, which increases the expansion order needed to ensure machine precision accuracy of higher derivatives. The values of tolerances εpand εrand the expansion order are determined for each matrix function individually and are presented later.The automation of derivation of matrix functions is done by means of the advanced automatic code generator AceGen[5], where automatic differentiation technique [6] and automatic code optimization and generation are combined with symbolic system Mathematica[7]. Automation procedure consists of two parts. First, the general form of generating function (2) and the coefficients of expansions (7) and (8) have to be derived in closed-form. Next, the first, the second and the third derivative of the generating function (9) with respect to matrixAhave to be obtained in closed-form.Coefficients of expansion (7)(∂i+jG∂pi∂qj|p→0q→0)are in general a function of λvand coefficients of expansion (8)(∂iG∂ri|r→±1)are in general a function of λvand t. Consequently, the coefficients can be obtained only with a rather lengthy and complicated limiting process. For that purpose symbolic tool Mathematica[7] was successfully used in order to automatize the first part of procedure.Direct use of Mathematica for the second part of procedure leads to uncontrollable growth of expressions and consequently slow program code. Thus, a more sophisticated algorithm has to be used. Let us assume that we have a computer code that evaluates the generating functionG(A). From the computer code for the evaluation of generating functions the computer code for the evaluation of matrix function and its first and second derivatives with respect to matrixAcan be obtained using automatic differentiation technique (see e.g. [6,17]) and the corresponding automatic differentiation tools, e.g. AceGen. If the backward mode (also named adjoint) of automatic differentiation technique is combined with code-to-code implementation (see e.g. [6]) of automatic differentiation technique, as is the case with AceGen, then the resulting code is also numerically efficient. Following the notation introduced in [18],δ^f(x)/δ^xis here used as an automatic differentiation operator. This leads to the following automatic differentiation based formulation of matrix function and its derivatives:(10)F(A)=δ^G(A)δ^AT,DF(A)=∂F(A)∂A=δ^F(A)δ^AandD2F(A)=∂2F(A)∂A2=δ^(DF(A))δ^A.Eqs. (9) and (10) form together a basis for an algorithm for the automation of the formulation of matrix functions. The algorithm is presented in Algorithm 1. First the value of generation function is defined according to (9). The matrix function and its required derivatives are then derived according to (10). Based on the presented procedure codes for the evaluation of an arbitrary matrix functions can be written, such as matrix exponential, logarithm, power, square root and others. On examples at the end it will be shown that the combination of code-to-code transformation and backward mode of automatic differentiation leads to highly numerically efficient and machine precision accurate codes. Efficiency of the numerical code can be further improved when a structure of argumentA(e.g. sparsity or symmetry) is exploited. This is done automatically by the code optimization capabilities of code generator AceGen.Algorithm 1Automation of calculation of matrix function and its derivatives.λv←13tr(A);A′←A−λvI;p←tr(A′.A′T);q←det(A);Δ←12p3−27q2;ifΔ<0then|Exit;//MatrixAhascomplexeigenvaluesend ifIf matrix function requires A to be positive definite(det(A)>0),additional conditions are required;ifp<εpthen|G←Gp(p,q,λv);//Gissymbolicallyexpandedaroundp=0andq=0.else|t←23p;r←36qp3/2;ifr>−1+εrandr<1−εrthen|G←G(r,t,λv);//Generalcaseelse|ifr<−1+εrthen|sr←1else|sr←−1endifG←Gr(r,t,λv,sr);//Gissymbolicallyexpandedaroundr=±1.endifendifCalculation of matrix function and its derivatives using automatic differentiation;F(A)←δ^Gδ^AT;DF(A)←δ^F(A)δ^A;D2F(A)←δ^DF(A)δ^AreturnF(A),DF(A),D2F(A)The general formulation of matrix functions was presented in previous Sections 2.1 and 2.2. Here, some examples of the most common matrix functions will be presented. The most common matrix functions observed in solid mechanics are matrix exponential(expA), logarithm(logA), square root(A)and arbitrary real power(Aη). Equivalent scalar functionf(λi), corresponding auxiliary functiong(λi)according to Eq. (1) and the generating functionG(λi)according to Eq. (2) are for all considered matrix functions presented in Table 1.Two special regions have to be considered where the generating function is ill-conditioned and it has to be replaced by its series expansion. The necessary order of expansions and the border between the regions were determined after an extensive numerical experiments were preformed using the high-precision arithmetic in Mathematica. The largest numerical error appears in the evaluation of the second derivatives of matrix function. Consequently, the boundary of the regions and the necessary order of expansion cannot be determined by examining the error of the generating function alone.Fig. 3depicts a characteristic example of the error of the second derivative of matrix exponential, matrix power and matrix logarithm for the second special caser→1. The error is shown for the general form of generating function G and the third-order (nr=3) series expansion around r=1. A general third-order expansion of generating function G aroundr=±1follows from (8) as(11)Gr=G|r→±1+∂G∂r|r→±1(r+sr)+∂2G∂r2|r→±1(r+sr)22+∂3G∂r3|r→±1(r+sr)36.The third-order expansion has been chosen because it is the highest order for which we were able to derive closed form expressions of the coefficients of the series expansion. The error of the general form decreases with the distance from the critical point r=1 and the error of the series approximation increases with the distance from the critical point. Thus, the optimal choice for the border between the regions is where the two error curves intersect. In the case of matrix exponential the intersection appears approximately atεr=1−r=0.002and for the other functions approximately atεr=0.001. From Fig. 3 we can see thatεr=0.002leads to the maximum error of the second derivative of matrix exponential approximately 10−12 and for the other functionsεr=0.001leads to the maximum error of the second derivative approximately 10−11. It is obvious that by decreasing the value of εrthe required order of series expansion nrcan be decreased, however the intersection point would then move closer to the critical point and the maximum error would be increased.Similar analysis can also be done for the first critical region wherep→0. Series expansion is for the first special case defined by a maximum order derivative npof G with respect to p, maximum order derivative nqwith respect to q and the maximum combined power npqas defined by Eq. (7). Again the maximum order of expansion is chosen and the border between the regions is placed approximately at the intersection of the error curves. As opposed to the previous case, the closed form expressions of the coefficients of the series expansion (7) can be derived for an arbitrary order of expansion. For the chosen np=7, nq=4 andnpq=7the matrix exponential leads toεp=0.2while other matrix functions giveεp=0.05for chosen np=8, nq=6 andnpq=8. The series expansion of generating function of matrix exponential is more accurate than of the other functions. Consequently, matrix exponential requires lover order of expansion and expansion accurately covers larger region. The series expansion of the generating function is a polynomial function, free of trigonometric functions and consequently numerically more efficient. This is shown on examples in Section 3. Thus, it is beneficial for εpto be as large as possible as long as the derived equations fulfill the condition for the machine precision accurate results.The chosen order of expansion and the tolerances are summarized for all considered matrix function in Table 2. The chosen values lead to the program codes that return machine precision accurate matrix functions on the whole definition interval. High precision is retained also for the first derivatives of matrix functions, while the error of the second derivatives remains below 10−10. Some characteristic results of the numerical experiments are for both special cases presented in Section 3. The derived formulas of generating function expansion for the both special cases and for all considered matrix functions are given in Appendix A.Numerical efficiency and accuracy of derived codes for the evaluation of matrix functions and their first and second derivatives is analyzed in this chapter on a set of numerical examples.The following matrices will be used for assessment:(12)M1=[a+1−111011−12]andM2=I+14[01110a+1110]where a is a free parameter. By varying the value of a the matrices undergo transition between the general form of generating function (G) and the two special cases (Gpand Gr). The generating functions of matrixM1undergo transition from the first special case (Gp) into the second special case (Gr), while the generating functions of matrixM2undergo transition from the second special case (Gr) into the general form (G) as depicted in Fig. 4. Since tolerances εpand εrare different for matrix exponential and other considered functions (see Table 2), the transition happens at different values of parameter a. For exponential, parameter a is taken from interval[0,0.8]and for other functions from interval[0,0.4].For the purpose of comparing accuracy and efficiency of the closed-form representation, matrix functions are alternatively defined by respective infinite power series expansion. The series expansions can be formulated from matrix functions׳ scalar counterparts. They are generally convergent on specific area and under certain conditions. The exponential of second-order tensorAcan be defined by the following infinite power series:(13)expA=∑i=0∞1i!Ai=I+A+12A2+16A3+⋯.Series is absolutely convergent for arbitraryA. The logarithm of second-order tensorAcan be defined by the following infinite power series:(14)logA=∑i=0∞22i+1((A−I)·(A+I)−1)(2i+1)=2(A−I)·(A+I)−1+23((A−I)·(A+I)−1)3+25((A−I)·(A+I)−1)5….Series is absolutely convergent for positive definite matrixA. The power of second-order tensorAcan be defined by the following infinite power series:(15)Aη=∑i=0∞(ηi)(A−I)i=I+η(A−I)+(η2)(A−I)2+(η3)(A−I)3+⋯.Series is absolutely convergent for eigenvalues of matrixAon interval0<λi<2.A representative algorithm for the evaluation of the matrix logarithm series expansion is presented in Algorithm 2. Derivatives of matrix functions are derived directly with automatic differentiation techniques. The desired accuracy of incrementεTof the second derivative of the matrix function׳s approximation is prescribed, and each of the series terminates when the norm of increment of the second derivative falls below the desired tolerance. The number of terms needed for series is therefore guided by the accuracy of the second derivative, which is larger than the number of terms needed for matrix function. Therefore, the accuracy of matrix function and its first derivative is automatically satisfied, when the second derivative has the desired accuracy.Algorithm 2Automation of code derivation for truncated series approximation of matrix logarithm and its first and second derivatives.n←0,B←(A−I)·(A+I)−1,C←BandF(A)←0;repeat|B←B.C;Finc←22n+1B;F(A)←F(A)+Finc;DFinc←δ^Fincδ^A;DF(A)←DF(A)+DFinc;D2Finc←δ^DFincδ^A;D2F(A)←D2F(A)+D2Finc;n←n+1;until‖D2Finc‖2<εT2;returnF(A),DF(A)andD2F(A)Approximations derived using Algorithm 2 are used for comparison with closed-form matrix functions derived using Algorithm 1. All program codes were generated using AceGen automatic code generator that can generate codes in various program languages. Codes for the evaluation of the closed-form representation of matrix functionsF(M)and their derivativesDF(M)andD2F(M)were generated in C language using standard machine precision.The accuracy is compared with truncated series approximation of the corresponding matrix functionF(M)refand its derivativesDF(M)refandD2F(M)ref. For the purpose of comparison of accuracy, codes for the evaluation of reference value were generated in Mathematica language and evaluated with 100-digit high precision arithmetics in Mathematica. The accuracy of the method is defined by the Frobenius matrix norm of the differences between the results of closed-form representation and the corresponding series approximation and shown successively in Figs. 5–8. The error of the functions is defined by∥F(M)−F(M)ref∥F, of the first derivative byΔDF=∥DF(M)−DF(M)ref∥Fand the second derivative byΔD2F=∥D2F(M)−D2F(M)ref∥F. Only the error of the first and the second derivatives is shown. The error of matrix function itself is not shown on graphs, since it is in all cases below 10−14. With higher derivatives, the error increases. The error of the first derivatives is below 10−13, and the error of the second derivatives below 10−10 for both matrices considered (M1andM2) and all matrix functions considered. The errors are highest at the transition from various representations of generating functions (see Fig. 4). When distancing away, all errors fall below 10−14. It can be concluded that all matrix functions and their first and second derivatives are sufficiently numerically accurate.For the test of numerical efficiency both codes, closed-form representation and truncated series, were derived in C language in order to maximize the objectivity of comparisons. Closed-form representations of matrix functions are compared with their truncated series counterparts evaluated with accuracyεT=10−16. The numerical efficiency is checked for both matricesM1andM2. Let us define with(16)tF=time(F,DF,D2F)the CPU time needed to evaluate matrix functionFtogether with its first and second derivativesDFandD2F, whereFcan be matrix exponentexpM, matrix logarithmlogM, matrix square rootMor matrix powerMη. Similarly(17)tF,ser=time(Fser,DFser,D2Fser)defines the CPU time needed to evaluate their truncated series counterparts. In the case of closed-form representation, time depends on the selected closed-form representation of generating function (G, Gpor Gr) and is constant within the same region as presented in Fig. 4. In the case of truncated series, time depends on the convergence rate that in turn depends on the maximum eigenvalue of the matrix which in general grows with the growth of free parameter a.First, the numerical efficiency is compared for different selected closed-form representations of generating functions (G, Gpor Gr). The time needed to evaluate the selected matrix functionFtogether with its first and second derivative is normalized againsttexpM,G, which is the time needed to evaluate matrix exponential and its first and second derivative in the region where a general closed-form representation of generating function G is used. Results are presented in Figs. 9a, 10a, 11a and 12a for all matrix functions considered. From these figures, the relative numerical efficiency of the evaluation of particular matrix function can be estimated for all forms of generating function. We can see that all functions have similar evaluation times and that the evaluation of functions in the regionp←0is approximately twice as fast as the general case. The only exception is the evaluation of matrix logarithm where the computational time is approximately the same for all regions.Second, the numerical efficiency of closed-form representation against the numerical efficiency of truncated series approximations is depicted in Figs. 9b, 10b, 11b and 12b for all matrix functions considered. The time needed for the evaluation of matrix function together with its first and second derivative using truncated series approximationtF,seris in all cases normalized against the time needed for the evaluation of closed-form representationtF. It can be observed that there is a huge difference in time between closed-form representation and truncated series approximation in all cases. The series approximations have longer times for factors in the range from 10 to 20 times for matrix logarithm, 30 to 70 times for matrix exponential and from 15 to 40 times for matrix power and square root. In [3] it was shown that the time for the evaluation of matrix exponential without derivatives is similar for both implementations and that the truncated series are approximately 5 times slower when the first derivative must also be evaluated. The huge increase in the presented case is due to expensive evaluation of the second derivative. Additionally, the accuracy of the second derivative must be monitored, which is also a numerically expensive operation.In order to eliminate the administrative time, the calculation oftFandtF,serwas repeated 200,000 times. All simulations were performed on Intel i7-2700K 3.50GHz based PC with Microsoft Windows 7 64bit OS and MinGW 5.1.3 compiler with 16GB of DDR RAM. When evaluating the efficiency, a single thread was used.The advantages of the closed-form representation of matrix functions will be shown on various hyperelastic and finite strain elasto-plastic models where the use of matrix functions and their derivatives is required. All the elements were derived following the automatic differentiation based formulation of nonlinear finite elements (or ADB formulation) proposed in [18] and extended to general finite strain plasticity in [3]. ADB combines symbolic description of basic equations and simultaneous code optimization with automatic differentiation based derivation of element contribution to the global equilibrium equations (also called element residual vector) and the element contribution to the global tangent matrix. The ADB formulation of hyperelasticity and finite strain plasticity is in detail explained in [18] and [3] and it will not be repeated here. Only the hyperelastic strain energy functions and plastic evolution equations specific for particular material model are presented here.For the basic hyperelastic model the isotropic Hencky model [19] is chosen, where strain energy is expressed with the logarithm of stretches. Isotropic Hencky strain energy function is written as(18)WHencky=κ2θ2+μ∥e^∥2whereθ=log(JF)is logarithm of Jacobian of deformation gradientJF=detFand μ and κ are shear and bulk moduli. Thee^is deviatoric part of Eulerian logarithmic deformation tensorethat can be calculated directly from the left Cauchy-Green deformation tensorb=FFTbye^=12log(JF−2/3b). Note that matrix logarithm is in code directly evaluated using closed-form matrix logarithm representation. The evaluation of the element residual vector requires the evaluation of the first derivative of the matrix logarithm and the evaluation of the element tangent matrix the second derivative of matrix logarithm.For the comparison of efficiency, the standard hyperelastic Neo-Hookean material is chosen, since it does not require the use of matrix functions. The strain energy function of Neo-Hookean material is chosen as(19)WNeoHooke=λ2JF-12+μ12trb-3-logJFwhere λ and μ are Lame׳s constants.The standard multiplicative finite strain elastoplasticity framework (see e.g. [20]) is employed here. In this framework the strain energies (18) and (19) are expressed with elastic left Cauchy-Green deformation tensorbe(20)be=FeFeT=FCp−1FTand determinant of elastic deformation gradientJFe=detbe.Cp−1is an inverse of plastic right Cauchy-Green deformation tensor. The components ofCp−1are internal variables of the problem defined separately for each material (integration) point. The evolution equations forCp−1are given as−12Lvbe=Δγ̇nbe, whereLvbeis Oldroyd derivative ofbe,n=∂ϕ∂τis direction of flow and ϕ the yield function. Evolution equations can be written in discretized form as(21)FCp-1-exp-2γ-γnnnfFCp,n-1=0where γ is plastic multiplier and nfis normalizing factor that is usually 1. Note that matrix exponential is in code directly evaluated using closed-form representation of matrix exponential. Alternatively the evolution equations can also be integrated using standard backward-Euler scheme [20](22)FCp-1-Cp,n-1FT+2γ-γnnnfbe=0.Two yield functions will be used, i.e. the standard Huber-von Mises and a more complex modified Cam-Clay yield function.Standard Huber-von Mises yield function takes the form(23)ϕMises=23∥τ′∥−σy(γ)whereτ′is deviatoric part of Kirchoff stress tensor andσy(γ)yield stress. Kirchoff stress tensor can be evaluated directly from elastic strain energy function asτ=2be∂W(be)∂be. Isotropic exponential hardening law (see e.g. [20]) can be written as(24)σy(γ)=σy0+Khγ+R∞(1−exp(−δγ))with material constantsσy0,Kh,R∞and δ.As a more complex example an elasto-plastic modified Cam-Clay model at finite strains is chosen. Modified Cam-Clay model is a basic model for soil, the volumetric strain energy of which is expressed with logarithm of stretches and its plastic yield surface is ellipsoid, the radius of which changes with the change of porosity. The model will be formulated according to Ortiz and Pandolfi [4]. Elastic strain energy of Cam-Clay model is equal to Hencky strain energy, already given by Eq. (18). The Cam-Clay yield surface is given as(25)ϕCamClay=q2+α2p(p−pc)where pcis consolidation pressure,p=13tr(σ)is Cauchy hydrostatic pressure andq=23∥σ′∥,σ′=σ−pIis deviatoric stresses and α defines the slope of critical state line. Cauchy stressσ=τ/JFcan be derived from Kirchoff stressτ=2be∂WHencky∂be+JFp0, where p0 is initial pressure in soil. According to Ortiz and Pandolfi [4] the normalizing factor nffor modified Cam-Clay model leads tonf=1α2tr(n)2+23∥n′∥. The hardening law for consolidation pressure is given as(26)pc=prefexp(θpθrefp)whereθp=log(JF/JFe)is plastic logarithmic volumetric strain,prefis the reference consolidation pressure andθrefpis the reference logarithmic volumetric strain. All together four material constants are needed.The presented hyper-elastic strain energy functions and yield functions are combined in order to get elements with various combinations of matrix functions and their derivatives. The material models considered are defined in Table 3and the actual appearance of matrix functions and their derivatives within the definition of element residual and tangent matrix in Table 4.All codes for the evaluation of matrix functions together with the first and second derivatives were derived and compiled in advance. A compiled numerical library was formed and included when all the object files were linked together to form single executable file.All material models were implemented within a standard izoparametric, four noded, displacement based, axisymmetric finite element, integrated with a standard four point Gauss integration rule. For each material model a separate code was generated containing user subroutine that evaluates elements residual vector and tangent matrix. All codes were fully optimized according to particular model and automatically derived using the AceGen[5] automatic code generation system. The number of formulas derived during the code generation process and the physical size of the file containing the C code with the subroutine for the evaluation of element residual vector and tangent matrix are presented in Table 5. Note that matrix functions are part of compiled numerical library, thus the code size and the code derivation time do not include derivation time and code size of matrix functions themselves. That is the reason why the code size does not differ much between the elasto-plastic elements based on exponential map and the elements based on standard backward-Eurler scheme.We can see that the combination of ADB formulation, automatic code generator AceGen and compiled matrix functions libraries leads to the process that generates moderate size codes for complex material models in real time. The usual problem associated with automatic code generation, which is extremely large code sizes, is avoided with the proposed combination of tools.Numerical efficiency of various elements will be compared on an example of axisymmetrical domain of dimension 1×1 discretized with 100×100 elements. The displacement 0.5 on top surface is prescribed and the displacement on vertical side is free. Simulation was done in 24 time steps so that at the end the domain is stretched by 50%. Due to the uniform strain-stress state all the integration points remain in either plastic or elastic regime. Initial yield stress was chosen so that all integration points remain in the same state during the whole simulation. The same elastic and plastic material parameters were used for all models and are presented in Table 6.The problem was solved using Newton–Raphson iterative procedure and consistently linearized tangent matrix. Thus, a quadratic convergence of the Newton–Raphson iterative procedure is expected. In Table 7the norm of the increment of displacement for all Newton–Raphson iterations during a typical time step is presented. It can be seen that the quadratic convergence is achieved for all elements. Additionally, the total number of Newton–Raphson iterations performed during the simulation and the average number of Newton–Raphson iterations per time step are presented in Table 8. As expected, the level of nonlinearity also affects the convergence. Elements based on Hencky strain energy function, thus employing matrix logarithm, converge more slowly than elements based on simple Neo-Hookean strain function, and the elements based on Cam-Clay yield function converge more slowly than the elements based on the simple Hubert-von Mises yield function.For the assessment of numerical efficiency of automatically generated codes, the average time needed for the evaluation of element residual vector and element tangent matrix (orKe&Retime) are presented in Table 8 for hyperelastic elements and elasto-plastic elements based on exponential map and in Table 9for elasto-plastic elements based on backward-Euler scheme. Parallelization of the code was disabled during the numerical efficiency test in order to get more objective comparisons.It can be observed that there is a approximate increase by 7 times inKe&Retime for Hencky hyperelastic model when compared to Neo-Hokean hyperelastic model as a result of the evaluation of matrix logarithm together with its first and second derivatives. The same ratio is valid for the comparison of theKe&Retime between the Huber-von Mises elasto-plastic model based on Neo-Hooken and Hencky strain energy function. Also the averageKe&Retime is about 40% longer if complex Cam-Clay compressible plasticity is used instead of Hubert-von Mises for the same strain energy function. The maximal difference in total evaluation time between the elasto-plastic elements based on exponential map and the same elements based on backward-Euler scheme is only 18%. This can be attributed to the fact that the backward-Euler scheme leads to asymmetric tangent matrix while the exponential map preserves the symmetry of the tangent matrix. Additional numerical cost for the formulation and solution of the asymmetric system of equations compensates the more costly integration scheme based on exponential map. The results presented in Tables 8 and 9 also show that in the case of incompressible elasto-plastic models the backward-Euler scheme does not fulfill the incompressibility conditiondetFp=1.

@&#CONCLUSIONS@&#
In this work, we have demonstrated a method for deriving a closed-form representation of an arbitrary matrix function and its first and second derivatives of 3×3 matrix with real eigenvalues. The presented method offers a unique solution to the standard problem of ill-conditioning in the vicinity of multiple equal eigenvalues. Numerical tests show that the error of matrix function itself is of the order of 10−14. The error of its first derivative is maximum5×10−13and the error of the second derivative is maximum 10−10.The efficiency of the proposed closed-form representation of matrix functions together with its first and second derivatives was compared with the corresponding truncated series approximation. The results show that the truncated series approximations are from 20 to 80 times slower than the proposed closed forms, depending on the matrix.A compiled numerical library of C subroutines was created which returns the evaluated matrix function and its first and second derivatives, defined with almost machine precision on whole definition area using AceGen automatic code generation system. Consequently, the matrix functions can be considered and used within the element formulation in the same way as other elementary functions and the formulation of complex non-linear materials can be greatly simplified.The proposed methodology was tested on a set of selected hyperelastic and elasto-plastic material models where the matrix functions play an essential part of formulation. In all cases the derived C code was less than 200Kbytes large. The paper demonstrated that the combination of automatic differentiation based formulation of nonlinear finite elements, automatic code generator AceGen and a library of compiled matrix functions leads to the process that generates moderate size finite element codes for complex material models in real time.