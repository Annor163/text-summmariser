@&#MAIN-TITLE@&#
A multi-threaded algorithm for computing the largest non-colliding moving geometry

@&#HIGHLIGHTS@&#
Introduce a novel algorithm to compute largest volume to pass along a path.Introduce also a multi-threaded version of the algorithm.Novel use of the existing data structures that scale linearly with the problem size.Abstracts away the geometry so it can be used with any combination of geometries.

@&#KEYPHRASES@&#
Collision detection,Multi-threaded,Largest non-colliding volume,

@&#ABSTRACT@&#
In this article we present an algorithm to compute the maximum size of an object, in three dimensions, that can move collision-free along a fixed trajectory through a virtual environment. This can be seen as a restricted version of the general problem of computing the maximum size of an object to move collision-free from a start position to a goal position. We compute the maximum size by dividing the object into numerous small boxes and computing which ones collide with the virtual environment during the movement along the given trajectory. The algorithm presented is optimized for multi-threaded computer architectures and also uses data structures that leave a small memory footprint making it suitable for use with large virtual environments (defined by, e.g., millions or billions of points or triangles).

@&#INTRODUCTION@&#
Being able to determine whether a virtual object can pass through a virtual environment without collision is a fundamental problem in virtual design. Depending on the exact problem at hand, there exist hundreds of papers addressing this problem from all sorts of aspects. In this paper we focus on a lesser studied problem of utmost importance for industrial designers. We are interested in being able to compute the largest object that can travel collision-free from a start configuration to a goal configuration. By the largest object we mean the object that has the largest volume according to some user defined way of measuring volume (as explained below). In this paper, we confine the object to travel along a fixed trajectory through a fixed virtual environment.This academic investigation is motivated by numerous real life problems (see below) and the basic motivation for this article is the virtual verification of car designs. In particular, one wants to know if a new car design can pass through an assembly line without colliding with other objects and if it does collide, what are the minimal design changes that need to be made to avoid the collisions. This information can also be used for future design problems if the environment and trajectory remain the same (as is typical for factory installations).Another motivation for this study was to improve the sustainability of current technologies. In particular, the results of this paper are intended to allow companies to reuse the existing facilities by giving designers a guarantee that their new designs fit in the current industrial installation and also letting them know the minimum changes to both the object they are designing and/or the industrial environment if necessary. This virtual verification saves the designer significant time much earlier in the design phase. Currently to determine whether a new model design fits along an assembly line or not, one is required to build a physical mock-up of a car (or whatever is being produced) and run it through an assembly line to check for collisions. Such a process is obviously much slower and costlier than having a simple virtual tool to directly test a new design and suggest which minimal changes need to be made.Significant design changes are often very costly, hence the goal of many designers is to know what the minimal structural design changes are to make sure objects do not collide with each other. Typical applications where computing the largest non-colliding designs plays an important role include, inter alia, the ability to route and path plan objects through tight spaces such as engines  [1] and other assembly components, designing robots for tight spaces in path planning applications  [2,3], etc. Once the set of colliding parts has been discovered one can then apply any of the numerous algorithms to effect the necessary design changes to avoid collisions (e.g.  [4,5]).The problem we are interested in can be defined more exactly as follows. LetAbe some geometrical object (set of NURBs, polygon soup, points, etc.) that bounds some volume of space andBanother geometrical object (representing the surrounding environment). We wish to compute the remaining non-colliding space bounded byAafterAhas traveled along a given trajectory (motion, path, etc.) defined by a set of rigid transformations. We would like to remove all parts of the space bound byAthat collide with any part ofBduring the set of rigid transformations. From the design perspective, the remaining non-colliding volume can be used to alter the original geometry so that it can pass along the original path collision-free. In addition, we are also interested in determining how much largerAcan be and still have parts of the enlarged volume not colliding with any part ofB.To compute the largest remaining non-colliding volume to travel along a given path, we developed an algorithm as follows. Our algorithm first allows the user to specify the largest volume object they are interested in, sayA. We then compute a bounding box aroundAand divide the box into smaller subboxes with fixed side lengths defined by the user (so-called tolerance). This size represents the level of error acceptable to the user. An hash-based octree containing the surrounding environment is then created and used to compute collisions between the environment and the object during its motion. As collisions are detected between the subboxes and the octree, subboxes are removed. The final remaining set of subboxes left at the end of the motion represents the largest shape that can pass through the environment along the path with the given user tolerance. The algorithms used here are located at the confluence of algorithms for finding the maximum empty subset of a given domain  [6], collision detection  [7] and being able to compute boolean operations for arbitrary geometries  [8].The remainder of this paper is organized as follows. In the next section, we present our algorithm and its analysis as well as the existing literature relevant to each part of the algorithm. We then present our experimental results, which are followed by a discussion of the results from the previous section. In the final section we conclude.

@&#CONCLUSIONS@&#
