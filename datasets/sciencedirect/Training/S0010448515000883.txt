@&#MAIN-TITLE@&#
A simple strategy for defining polynomial spline spaces over hierarchical T-meshes

@&#HIGHLIGHTS@&#
A strategy for defining cubic tensor product spline functions is proposed.Simple rules for inferring local knot vectors to define blending functions for a given T-mesh.Examples of application of the strategy for adaptive refinement in isogeometric analysis and CAD.

@&#KEYPHRASES@&#
Isogeometric analysis,Multivariate splines,Local refinement,T-mesh,Nested spaces,

@&#ABSTRACT@&#
We present a new strategy for constructing spline spaces over hierarchical T-meshes with quad- and octree subdivision schemes. The proposed technique includes some simple rules for inferring local knot vectors to defineC2-continuous cubic tensor product spline blending functions. Our conjecture is that these rules allow to obtain, for a given T-mesh, a set of linearly independent spline functions with the property that spaces spanned by nested T-meshes are also nested, and therefore, the functions can reproduce cubic polynomials. In order to span spaces with these properties applying the proposed rules, the T-mesh should fulfill the only requirement of being a 0-balanced mesh. The straightforward implementation of the proposed strategy can make it an attractive tool for its use in geometric design and isogeometric analysis. In this paper we give a detailed description of our technique and illustrate some examples of its application in isogeometric analysis performing adaptive refinement for 2D and 3D problems.

@&#INTRODUCTION@&#
The main drawback of using B-splines and NURBS for geometric design is the impossibility to perform local refinement. T-splines were introduced by Sederberg et al.  [1] as an alternative to NURBS. Based on the idea of admitting meshes with T-junctions and inferring local knot vectors by traversing T-mesh edges, T-splines have provided a promising tool for geometric modeling that allows to perform local refinement without introducing a large number of superfluous control points. Later, in  [2], T-splines were incorporated to the framework of isogeometric analysis. Isogeometric analysis (IGA) was introduced in 2005 by Hughes et al. in  [3,4]. It has arisen as an attempt to unify the fields of CAD and classical finite element methods. The main idea of IGA consists in using for analysis the same functions that are used in CAD representation of the geometry.To use spline functions for numerical analysis and obtain a proper convergence behavior, these functions must meet some requirements: linear independence, polynomial reproduction property, local supports and possibility to perform local adaptive refinement. This issue has been the object of numerous research works in recent years.Analysis-suitable T-splines, proposed by Scott et al. in  [5], are a class of T-splines defined over T-meshes that should meet certain topological restrictions formulated in terms of T-junction extensions. Basis functions defined over an extended analysis-suitable T-mesh are linearly independent  [6] and form a partition of unity. The refinement algorithm allows to accomplish highly localized refinements and constructs nested T-spline spaces, but it presents an elevated implementation complexity and, as far as we know, the generalization of the strategy to 3D cases is still an open question.Another approach to the problem of local enrichment of the approximation space is the hierarchical refinement, originally introduced by Forsey and Bartels in  [7] and later developed in  [8]. Recently, hierarchical refinement technique in the context of isogeometric analysis was described in  [9–11]. This approach is based on a simple and natural idea to construct multilevel spaces by replacing coarse level functions with finer basis functions. Starting from an initial uniform mesh, hierarchical refinement scheme leads to sequential construction of nested spline spaces with linearly independent basis functions. Simplicity of its implementation and straightforward generalization to 3D make it an attractive option for local refinement. However, a drawback of this strategy is the impossibility to define a spline space over a given arbitrary T-mesh as well as the presence of redundant basis functions and excessive support overlapping. An interesting theoretical approach to the latter problem was given in  [12]. The truncation technique is applied to redefine the function supports and reduce their overlapping.Other options for performing local refinement of spline spaces areC1-continuous PHT-splines  [13] or local refined splines (LR-splines)  [14].In the present paper we propose another possible alternative for the construction of spline functions that span spaces with nice properties. The technique we present here is designed for hierarchical T-meshes (multilevel meshes) with a quad- and octree subdivision scheme. This type of meshes can be efficiently implemented with tree data structures  [15] which are frequently used in engineering. Due to the elevated complexity of all current strategies, the main goal we pursue here is the simplicity and low computational cost of the implementation, both in 2D and 3D. For that, we have to assume a restriction on the T-mesh. Namely, the T-mesh should fulfill the requirement of being a 0-balanced mesh. A balanced mesh condition is usually imposed to have gradual transition from the coarse mesh to the finer zones. In addition, for our technique, this condition is an obligatory prerequisite that the T-mesh should fulfill. Assuming this reasonable restriction over the T-mesh, we can define easily cubic spline functions that span spaces with desirable properties: linear independence,C2-continuous, cubic polynomial reproduction property, nestedness of spanned spaces and a straightforward implementation. The key of the strategy lies in some simple rules used for inferring local knot vectors for each blending function.The paper is organized as follows. Some basic concepts about B-splines and T-meshes are given in Section  2. Section  3 includes the general scheme of our strategy and the description of its main stages. In Section  4 we explain in detail the key of our technique, that is, the rules used for inferring function supports in order to span spaces with desirable properties. In Section  5 the properties of the defined functions are given and the issue of support overlapping and sparsity of stiffness matrix is discussed. Computational examples of performing adaptive refinement for 2D and 3D Poisson problems are presented in Section  6. Conclusions are given in Section  7.We start with a brief summary of the main concepts about B-splines.A set of B-spline basis functionsBi,p(i=1,2,…,n)of degreep, inferred from a non-decreasing sequenceΞ={ξ1,ξ2,…,ξn+p+1}, called knot vector, is defined by the Cox–de Boor recursion formulaBi,0(ξ)={1ifξi≤ξ<ξi+1,0otherwise.Bi,p(ξ)=ξ−ξiξi+p−ξiBi,p−1(ξ)+ξi+p+1−ξξi+p+1−ξi+1Bi+1,p−1(ξ).A knot vectorΞis called open knot vector if the first and the last knots are repeatedp+1times. At each knot of multiplicitymthe basis functions areCp−m.A B-spline curve is defined as a linear combination of B-spline basis functionsS(ξ)=∑i∈IPiBi,p(ξ),where coefficientsPi∈Rsare called control points, typicallys=2or 3.Multivariate B-splines are defined as a tensor product of univariate B-spline functionsBi,p(ξ)=∏k=1dBik,p(ξk),whereξ=(ξ1,…,ξd)and the multi-indexi=(i1,…,id)∈I. The multi-index set is defined byI={1,2,…,n1}×⋯×{1,2,…,nd}.A B-spline surface (solid) is defined as a linear combination of bivariate (trivariate) B-spline functionsS(ξ)=∑i∈IPiBi,p(ξ),where the control pointsPi∈Rs(s=2or 3) form a control mesh.For more details about B-splines see  [16].In order to overcome the drawback of tensor product structure, which does not allow to perform local refinement, it is necessary to admit T-junctions in the mesh. The concept T-junction is similar to hanging node in the classical finite element method. An axes-aligned grid that allows T-junctions is called T-mesh. As was mentioned in the previous section, there are several strategies to define tensor product spline functions over T-meshes and one of these strategies is T-splines. The underlying idea of T-splines consists in defining blending functions by means of a set of local knot vectors instead of a global knot vector, as in the case of B-splines or NURBS. A local knot vector for each bivariate functionBαis inferred by traversing the T-mesh edges in both parametric directions starting from a vertexvαof the mesh (the anchor), see Fig. 1. For a pair of local knot vectorsΞαj=(ξ1j,ξ2j,ξ3j,ξ4j,ξ5j),j=1,2the bicubic spline functionBαis defined asBα(ξ1,ξ2)=B[Ξα1](ξ1)B[Ξα2](ξ2), whereB[Ξαj](ξj)is an univariate B-spline corresponding to the knot vectorΞαj. In general, T-spline blending functions do not span a polynomial space. Some additional restrictions on the T-mesh configuration  [5] should be satisfied in order to span a polynomial spline space. If these restrictions are not verified, the T-splines should be normalized in order to form a partition of unity. This leads to rational blending functions:Rα(ξ1,ξ2)=Bα(ξ1,ξ2)∑β∈ABβ(ξ1,ξ2), whereAis the index set of the basis spanned by the T-mesh. These rational blending functions are capable of reproducing a constant function, but, in general, cannot reproduce a polynomial of a higher order. A T-spline approximation is constructed as a linear combination of all blending functions:S(ξ1,ξ2)=∑α∈APαRα(ξ1,ξ2).In this section we describe our strategy to define tensor product spline functions over hierarchical T-meshes. The strategy we propose has some similarity with T-splines in as much as we define the blending functions from local knot vectors that are inferred by traversing the T-mesh edges. Some additional rules and requirements are imposed for the local knot vectors in order to obtain spline spaces with nice properties. The strategy is mainly motivated by the idea of preserving an original basis function if it cannot be reproduced with the basis of the new space after a refinement. For example, in the initial mesh of Fig. 2(a), we define a basis functionNαassociated to the vertexα. Then, we perform some cell refinements as shown in Fig. 2(b). It is easy to check that the new T-spline space obtained in Fig. 2(b) is not capable of reproducing the original basis functionNα. However, if we define the functionNˆαas shown in Fig. 2(c), keeping in this case the initial basis unaltered in the new refined space, we guarantee the nestedness of spline spaces.In our strategy, the process of spline space construction for a given T-mesh can be divided in the following three steps:1.Mesh pretreatment (0-balancing).Inferring local knot vectors.Modification of local knot vectors.Next, we give a description of each step of the process.Due to their simplicity, quadtree and octree meshes are attractive tools for performing adaptive refinement in IGA and geometric modeling. To guarantee a good quality of the approximation space constructed over a mesh, it is preferable to have a gradual transition from the coarse mesh to the finely refined zone. That is why it is common to work with balanced quadtree and octree meshes. The strategy we propose in this paper is designed exclusively for the 0-balanced T-meshes. A mesh with tree structure is said to be 0-balanced if for anyk, no cell at levelkshares a vertex (0-face) with a cell at level greater thank+1. In other words, a 0-balanced quadtree mesh implies that any cell has contact (through vertex, edge or face) only with cells that differ at most in one level of depth. An example of 0-balanced procedure quadtree is shown in Fig. 3(b). To obtain a 0-balanced quadtree, a standard balancing procedure is applied. Note that refinements performed during the 0-balancing procedure do not propagate, see  [17].It should be highlighted that 0-balancing the T-mesh is an essential prerequisite for the construction of spline spaces by means of our technique. In general, if the T-mesh is not 0-balanced, our rules for inferring local knot vectors do not lead to polynomial spaces. Also, it is important to emphasize that, for our 2D (3D) T-meshes, a subdivision of any cell is performed by subdividing the cell in 4 (8) equal subcells so that, all cells of the same level have the same size and the edge size of ak-level cell is twice larger than the edge size of a(k+1)-level cell.Let us consider a T-meshTof the squared parametric domainΩ=[0,1]d,d=2or 3. We call regular node the node of the mesh that is not a T-junction. We associate a blending function only to regular nodes of the mesh, as it is usual in classical finite element methods when working with hanging nodes. The skeleton of ad-dimensional meshTis the geometric set of points composed of the union of all(d−1)-faces of the mesh and it is denoted byskt(T). That is, for a 2D space, the mesh skeleton is the union of all the edges of the mesh, and the skeleton of a 3D mesh is the union of all its faces.To define our cubic tensor product spline blending functions over a givend-dimensional T-mesh, a local knot vector fordparametric directions should be assigned to each functionNα:Ξαj=(ξ1j,ξ2j,ξ3j,ξ4j,ξ5j),j=1,…,d. Similarly to  [1], these knot vectors are inferred by traversing the T-mesh skeleton. For simplicity, let us describe this procedure for a two-dimensional T-mesh. Starting from the central knot(ξ31,ξ32), i.e., the anchor of the function, we walk across the T-mesh until intersecting perpendicularly a mesh edge. According to our strategy, we should skip over the T-junctions where the missing edge is perpendicular to the direction of our marching, see Fig. 4. When the boundary of the parametric domain is reached while walking across the mesh, we repeat knots creating an open knot vector structure along the boundary, see Fig. 4(c). Note that all interior knots have multiplicity 1. Thus, we obtain for meshTa set of blending functions{Nα}α∈AT, whereATis the index set. Fig. 5illustrates an example of T-mesh in the parameter space and the anchors of all blending functions defined over this mesh. Any interior regular node has exactly one function associated to it and the boundary nodes have more than one function associated due to the open knot vector structure.The process of inferring local knot vectors can be resumed as follows:•Blending functions are associated only to regular nodes of the mesh.Local knot vectors are inferred by walking across the mesh until intersecting the mesh skeleton. This intersection should not coincide with a T-junction perpendicular to the marching direction.Boundary knots are repeated to create an open knot vector structure along the boundary.Next, in order to span a spline space with good properties, some function supports should be modified. This issue is addressed in the next subsection.The key of our strategy lies in some simple rules used for the modification of the function supports that lead to the construction of a polynomial spline space over a given 0-balanced T-mesh. In order to describe the idea, let us introduce some notation. For the local knot vectorsΞαj=(ξ1j,ξ2j,ξ3j,ξ4j,ξ5j),j=1,…,dlet us denote the length of each knot interval asΔij=ξi+1j−ξij,j=1,…,dandi=1,…,4.The support of ad-variate blending functionNαis ad-dimensional rectangular box:[ξ11,ξ51]×⋯×[ξ1d,ξ5d]. We are going to call frame of a function support the union of all(d−2)-faces of this box and we will denote it byfrm(suppNα). That is, for the rectangular support of a bivariate function, the frame is the union of the four vertices of this rectangle. For the cuboidal support of a trivariate function, its frame is composed of the union of the twelve edges of this cuboid.Once the function supports are inferred, we modify them in such a way that, for each blending functionNα, its knot vectorsΞαjj=1,…,dverify the following simple conditions:Condition 1Local knot vectors of thed-variate functionNαverify11Except the cases involving repeated knots that are explained at the end of Section  4.1.(1)Δ1j⩾Δ2j=Δ3j⩽Δ4j,j=1,…,d.Condition 2The frame of the function support should be situated over the mesh skeleton:(2)frm(suppNα)∈skt(T).Thus, the function supports that do not meet Condition 1 or 2 should be modified. To perform this modification we extend the original support by changing some knot intervals until the resulting support satisfies both conditions. We are going to refer to these support modifications as Extension rule 1 and 2, respectively. In the next section we give a detailed description of this procedure for 2D and 3D cases.Here, we present simple support Extension rule 1 and 2 to obtain local knot vectors that fulfill Conditions 1 and 2 formulated in the previous section. We proceed as follows. First, if after traversing the T-mesh skeleton the local knot vectors of a function do not satisfy Condition 1, we modify some of their knots in order to meet Condition 1. Then, the fulfillment of Condition 2 is checked and, if it is not satisfied, another appropriate modification of the support is carried out. As a result of these modifications we obtain a new extended support with local knot vectors which verify both conditions. These modifications are easily implemented taking into account the balanced tree structure of the mesh. Let see in detail this procedure.To clarify the notation, in the rest of the paper we denote the parametric coordinates as(ξ,η,ζ)and it is related to the previous notation as(ξ1,ξ2,ξ3)=(ξ,η,ζ). Consequently,(Ξ1,Ξ2,Ξ3)=(Ξ,H,Z)and(Δi1,Δi2,Δi3)=(Δiξ,Δiη,Δiζ).In order to facilitate the description and illustration of the strategy, some concepts and notation introduced in Section  3 have to be particularized to the 2D case. The skeletonskt(T)of a two-dimensional meshTis the union of all edges of the mesh. For a bivariate function let us denote the vertices of its rectangular support asV1,1=(ξ1,η1),V5,1=(ξ5,η1),V5,5=(ξ5,η5)andV1,5=(ξ1,η5). Then, the frame of a function support is the union of its four vertices, i.e.,frm(suppNα)={Vn,m,n,m∈{1,5}}. Fig. 6illustrates the introduced notation for a bivariate function support.Formulation of Condition 1 for the local knot vectorsΞandHis simple and does not need any clarification. Condition 2 adapted to 2D case is formulated as follows: The four vertices of a function support should be situated over the mesh edges.Extension rule 1If the local knot vectorΞof a function does not satisfy Condition 1, we modify this vector by skipping over the minimal number of knots untilΔ1ξ⩾Δ2ξ=Δ3ξ⩽Δ4ξis verified, and analogously, forH. This modification is made independently for each parametric direction applying certain extension rules. Let us see an example of support extension for a bivariate function. Leftmost function support shown in Fig. 7(a) does not meet Condition 1. For the knot vectorΞwe haveΔ3ξ>Δ4ξ, so the knot intervalΔ4ξshould be modified. Let us denoteh=max(Δ2ξ,Δ3ξ)=max(Δ2η,Δ3η). Note that both maxima coincide due to the quadtree structure and the fact that the T-junctions are skipped. Then, the fifth knotξ5is redefined asξ5∗←ξ3+2h. For the local knot vectorHwe haveΔ2η>Δ3η, so the knotsη4andη5should be modified asη4∗←η3+h,η5∗←η3+2h.Extension rule 2Once Condition 1 is satisfied, in order to fulfill Condition 2, we check whether the vertices of the function support are situated over the mesh edges. If not, we modify the knot vectors by skipping over a knot for both parametric directions and placing this vertex over the mesh edges. Fig. 7(b) illustrates this procedure. The checking is performed independently for each of the four quadrants of the function support. Note that for our 0-balanced quadtree we should make this checking only for some functions. For example, without loss of generality, the support vertexV5,5=(ξ5,η5)must be checked only ifΔ3ξ=Δ4ξ=Δ3η=Δ4η. An example of a function support violating Condition 2 is illustrated in Fig. 7(b). The vertexV5,5=(ξ5,η5)of this support is not situated over a mesh edge, so the fifth knots for both parametric directions should be redefined asξ5∗←ξ3+3h,η5∗←η3+3h, and thus, the new vertexV5,5is placed over the mesh edges.The extension of any other function support is completely analogous to these two examples. In all possible cases, the extension of a function support implies to change one or two knot intervals by duplicating its size.Detailed algorithms for Extension rule 1 and 2 used to modify a bivariate function support according to Conditions 1 and 2 are given in Algorithms 1 and 2.Fig. 8shows some examples of support modification. Functions that satisfy both conditions and should not be modified are given in Fig. 8(a). Examples of support extension according to Condition 1 are shown in Fig. 8(b)–(e). And Fig. 8(f)–(h) illustrates support extension according to Condition 2 or both.Note that an exception for Condition 1 is a knot vector that contains a knot interval of length 0 due to the open knot vector structure along the boundary. In this case, a knot vector should fulfill the inequality (1) not taking into account the knot intervals of length 0. Consequently, an exception for the application of the extension rules is the case when the boundary of the parametric domain is reached traversing the T-mesh edges, see Fig. 8(c)–(e).Remark 1It is important to highlight that the application of the extension rules always places the new knots over the mesh edges, i.e., the extension rules just skip over some knots, but do not create knots that are not induced by the T-mesh.Remark 2Note that in the case when a function support violates Condition 2, the extension of this support in order to place its vertex over the mesh skeleton can be made by modifying only one of the knot vectors instead of both. This option leads to the loss of symmetry for the spline space and to the non-uniqueness of the resulting function support. So, for simplicity, we extend the knot vectors in both parametric directions.In this section we give a description and illustration of the proposed strategy for defining trivariate spline functions over 0-balanced octree T-meshes.The skeletonskt(T)of a three-dimensional meshTis the union of all faces of the mesh. For a trivariate function let us denote the vertices of its support asVn,m,k=(ξn,ηm,ζk)wheren,m,k∈{1,5}. And the edge of a support formed by the two verticesVn,m,kandVp,q,ris denoted asE(n,m,k),(p,q,r). Then, the framefrm(suppNα)of a trivariate function support is the union of its twelve edges. Fig. 9illustrates the introduced notation for the support of a trivariate blending function.The formulation of Condition 1 for the local knot vectors of a trivariate function is analogue to the 2D case. Condition 2 adapted to 3D meshes is stated as follows: Edges of the cuboidal function support should be situated over the mesh faces.The implementation of the strategy for 3D is similar to the 2D case. To satisfy Condition 1, Extension rule 1 is applied to each of the three local knot vectors of a function analogously to the 2D case using Algorithm 1.Extension rule 2. In order to fulfill Condition 2, we check whether the edges of a function support are situated over the mesh faces. If not, the two knot vectors perpendicular to this edge should be modified by skipping over a knot for both parametric directions and placing this edge over the mesh faces. This checking is performed independently for each of the eight quadrants of the function support and, in each quadrant, three edges should be checked. Fig. 10illustrates the support extension procedure for the quadrant of the vertexV5,1,1. Due to the octree structure only two cases can take place: (i) the quadrant contains one edge that is not situated over the mesh faces or (ii) the quadrant contains three edges and a vertex that are not situated over the mesh skeleton. Now we study each case.(i)If a quadrant contains one edge that does not fulfill Condition 2, then two knot vectors perpendicular to this edge are modified, see Fig. 10(a). For the function support shown in Fig. 10(a) left, the edgeE(5,1,1),(5,1,5)is not situated over the mesh faces. Therefore, its two knot vectorsΞandHperpendicular to this edge are modified in order to place the edge over the mesh faces, namely, knotsξ5andη1are redefined asξ5∗←ξ3+3handη1∗←η3−3h, whereh=max(Δ2ξ,Δ3ξ)=max(Δ2η,Δ3η)=max(Δ2ζ,Δ3ζ).If a quadrant contains three edges that are not situated over the mesh faces, then the three knot vectors are modified by skipping over a knot for each of the three parametric directions, see Fig. 10(b). VertexV5,1,1and the three edges connected to it are not situated over the mesh skeleton, so all the three knot vectors are modified to place the three edges over the mesh faces:ξ5∗←ξ3+3h,η1∗←η3−3h,ζ1∗←ζ3−3h.Algorithm 3 explains the Extension rule 2 used to modify a trivariate function support according to Condition 2.Here, we summarize the properties and some characteristics of the spline spaces constructed by means of our method.For any 0-balanced meshT, the set of blending functions defined according to our strategy spans the spaceST=span{Nα:α∈AT}with the following properties:1.Functions{Nα}α∈ATareC2-continuous.Functions{Nα}α∈ATare linearly independent.Spaces spanned by nested T-meshes are also nested:T1⊂T2⇒ST1⊂ST2.Polynomial reproduction property:P3(Ω)∈ST.A rigorous proof of these properties is currently under preparation and we plan to give it in a future work. However, for a better understanding of the strategy, some clues should be mentioned.For the proof of linear independence of our blending functions it is essential to take into account that we do not repeat knots in the interior of the domain, and each regular node of the T-mesh has only one function assigned to it. Some reasoning from  [18] can be used to proof the linear independence of such functions.A brief outline of the proof of the property (3) is given in the Appendix of the present paper.It is worth mentioning that we have carried out numerous numerical experiments and the claimed properties were verified in all of them.It should be pointed out that the proposed strategy can lead, in some cases, to increased overlapping of the function supports of different refinement levels, which can affect the conditioning and sparsity of the stiffness matrix. This effect can take place in some problems with a very sharp singularity when the area marked to refine by the error indicator at each iteration is smaller than the area occupied by the supports of the previous level. According to our strategy, a cell refinement always adds at least one new blending function, while a function of the coarse level is replaced by the finer ones only if all the cells that share their anchor are refined. To avoid a possible accumulation of the functions of different refinement levels, the following strategy can be adopted: if a function support intersects a cell marked to be refined, then the coarsest cells sharing the anchor of the function are refined, see Fig. 11(a) and (b).Application of this strategy is illustrated in Fig. 11(c) and (d). In this example, let us suppose that the problem has a singularity at the center of the domain, and at each iteration, we refine only the four cells adjacent to the singularity point. Then, at each iteration there are functions whose support is not changed, see Fig. 11(c). However, if at each iteration we perform additional refinements, functions of the coarser level are replaced by the finer ones, see Fig. 11(d). This approach is similar to the one used in hierarchical refinement where all supports that intersect the marked cell are also refined in order to guarantee the replacing of the supports of the previous level by the finer ones at each refinement step. Application of this additional refinement, where needed, can reduce an excessive function overlapping and improve the stiffness matrix conditioning and sparsity. However, due to the unnecessary extension of the refined zone, the optimal rate of convergence can be lost. In practice, we did not observe a significant advantage of this approach, and taking into account its computational cost, we do not apply this strategy in the computational examples presented in this paper. Moreover, it was observed that for a large variety of problems, the excessive support overlapping is avoided naturally after various refinement steps due to the behavior of the error indicator.On the other hand, another possible solution for this problem is a more accurate and selective definition of the function supports in order to obtain a space with better support locality. The strategy we propose in this paper can be improved by including more sophisticated rules for inferring function supports, but that would probably lead to a more expensive implementation.In this section we present computational examples of the application of our technique in geometric design and analysis for problems involving adaptive refinement. The proposed method is tested by performing surface interpolation and resolution of 2D and 3D Poisson problems using IGA.Here we construct a spline representation of a surface given by a triangulation. First, a global parameterization of the surface triangulation is obtained by means of the method proposed by M. Floater in  [19]. As a result, we have one-to-one mapping from planar triangulation of the parametric domain (unit square) to the surface triangulation. Then, a quadtree T-mesh adapted to the planar triangulation is constructed. For this purpose we have chosen the following simple criterion. We start from a coarse T-mesh and refine it until each cell of the mesh contains no more than a certain number of points of the input triangulation (3 in our case). The spline approximation of the surface is built as a linear combination of our blending functionsS(ξ)=∑α∈ATCαNα(ξ).The control pointsCαare found by imposing the interpolation conditionsxβ=∑α∈ATCαNα(ξβ),∀ξβ,β∈AT,whereξβare interpolation points in the parametric domain andxβare their images in the physical space determined by the triangular parameterization. As interpolation points we use the anchors of the functions, i.e., the regular nodes of the T-mesh, and some additional interpolation points associated to functions whose local knot vectors contain repeated knots on the boundary. These additional points are situated at the midpoint of the edges that have contact with the boundary and coincide approximately with the maximum point of the corresponding blending functions. See  [20] for more details.The resulting spline surface, parametric T-mesh and input surface triangulation are shown in Fig. 12.In this example we interpolate the function(3)u(r)=r12,defined on the square domain[0,1]2, beingr=(x−0.5)2+(y−0.5)2.The spline approximation of the surface (3) is built as a linear combination of our blending functionsuh(ξ)=∑α∈ATCαNα(ξ).And the control pointsCαare found by imposing the interpolation conditionsu(ξβ)=∑α∈ATCαNα(ξβ),∀ξβ,β∈AT.Adaptive refinement is performed according to the indicator based on exactL2interpolation error:η(Ωe)2=‖u−uh‖L2,Ωe2=∫Ωe(u−uh)2dΩ.A cellΩeis marked to be refined ifη(Ωe)>γmaxi{η(Ωi)}, beingγ∈[0,1].Some steps of adaptive refinement for the surface interpolation (3) are shown in Fig. 13, and Fig. 14illustrates the convergence inL2-norm andH1-seminorm.In this subsection we present an example of the resolution of a Poisson problem on a square domainΩ=[0,1]2using isogeometric analysis. Let us consider the problem(4)−△u=finΩ,u=gon∂Ω.Its variational formulation consists in findingu∈Vg(Ω)such thata(u,v)=(f,v)∀v∈V0(Ω),wherea(u,v)=∫Ω∇u⋅∇vdΩand(f,v)=∫ΩfvdΩ.The test function space isV0(Ω)={v∈H1(Ω):v∣∂Ω=0},and the solution space isVg(Ω)={v∈H1(Ω):v∣∂Ω=g}.LetTbe a T-mesh ofΩ. Then we denote withVT(Ω)the finite dimensional space spanned by the spline blending functions defined overT, and withVgT,T(Ω)the subspace of functions ofVT(Ω)that are equal togTat the boundary, wheregTis an interpolant ofg.The isogeometric approximation consists in findinguh∈VgT,T(Ω)such thata(uh,vh)=(f,vh)∀vh∈V0,T(Ω).The problem (4) is set up in such a way that its analytical solution is a function with singularities taken from  [12] and given by(5)u(x,y)=exp(−7(x−0.5)2+(y−0.5)2)+exp(−7(x−0.25)2+(y−0.25)2)+exp(−7(x−0.75)2+(y−0.75)2).We perform an adaptive refinement based on an a posteriori error indicator to improve the quality of the numerical solution. We have chosen a simple residual-type error estimator given byη(Ωe)2=‖h(f+Δuh)‖0,Ωe2=∫Ωeh2(f+Δuh)2dΩ,wherehis the diameter of the cellΩe. The estimator is jump free through the cell interfaces because of the smoothness of the isogeometric approximation. A cellΩeis marked to be refined ifη(Ωe)>γmaxi{η(Ωi)}, beingγ∈[0,1].During the assembly process we accomplish the numerical integration on each element (cell) of the mesh, therefore it should be taken into account that for exact integration results (when possible) the numerical integration should be performed on each Bezier element, that is, on the subregion of the cell where the blending functions are pure polynomials. For our balanced quadtree meshes it implies to subdivide some cells in 2 or 4 subelements. However, taking into account the smoothness of the functions across the subelements boundary, more efficient quadrature rules can be used. For example, in  [21] authors propose a numerical procedure to compute weights and points of quadrature rules on macro elements. These rules are exact for blending functions and efficient in the sense that requires less evaluations than classical Gauss rules on each element.Some steps of adaptive refinement for the problem (4) and the numerical solution corresponding to the final refinement iteration are shown in Fig. 15. The convergence behavior of the adaptive refinement inL2-norm andH1-seminorm is shown in Fig. 16(a) and (b). The evolution of the density of the stiffness matrixA, its condition number and the comparison of these values for an uniform refinement are represented in Fig. 16(c) and (d), respectively. The density of the matrixAis the fraction of non-zero elements and the condition number is defined asκ(A)=‖A‖2‖A−1‖2.In the next example, we present the result of the resolution of a Poisson problem on a complex domain. We denote byΩ̂=[0,1]2the parametric domain and byΩthe physical or computational domain. Now the spline blending functions are defined over a meshTof the parametric domain. GivenΩ, we build a one to one parametric transformationS, that mapsΩ̂toΩ, i.e.S:Ω̂→Ω, using the algorithm described in our previous work  [20]. This technique, based on a T-mesh untangling and optimization procedure, allows us to obtain a good quality parameterization suitable for application of IGA. The procedure is an extension of the ideas presented in our works  [22–25]. Another method for parameterization of computational domain, based on pillowing technique, was given in  [26,27].The mean ratio Jacobian is used to evaluate the quality of the parameterization in the sense of its orthogonality and uniformity. Fig. 17(a) and (b) show the colormap of the parameterization quality for our parametric and physical domains. It should be mentioned that for all numerical examples the parameterization of the computational domain is performed using the same blending functions that are used for the solution approximation, so isoparametric concepts holds during isogeometric analysis. That is, ifVT(Ω̂)is the finite dimensional space spanned by the spline functions associated to a parametric meshT, then the parametric mappingSis constructed as a linear combination of functions fromVT(Ω̂)and the discrete approximation spaceVT(Ω)in physical domain is defined as follows:VT(Ω)={v∈H1(Ω):v=v̂∘S−1,for allv̂∈VT(Ω̂)}.Now we consider a Poisson problem with the Dirichlet boundary condition onΩ, which exact solution is a function with steep wave front given byu(r)=arctan(α(r−r0)),wherer=(x−xc)2+(y−yc)2, the parameterαdetermines the steepness of the wave front andr0is its location. In this exampleα=200andr0=0.6. The center of the wave front(xc,yc)=(0,0)is situated outside our computational domain, so the function is smooth inΩ. The numerical solution of the problem and the mesh corresponding to the final refinement iteration is shown in Fig. 18. As expected, the error estimator has marked for refinement the zone of the wave front. The evolution of the exact error inL2-norm andH1-seminorm are shown in Fig. 19.The next computational example is the resolution of a 3D Poisson problem using IGA. The computational domain is a spline approximation of a sphere portion, see Fig. 20. The initial uniform mesh was composed of 4×4×4 cells. The approximation is constructed using our spline blending function. The Poisson problem with Dirichlet boundary condition is set up so that the analytical solution of the problem isu(r)=sin(1α+r),wherer=x2+y2and parameterα=1/10π. This is a smooth function with an oscillation near the origin. Results of the final refinement iteration are shown in Fig. 20. The convergence behavior of the adaptive refinement is illustrated in Fig. 21.In this paper we have proposed a strategy for definingC2-continuous cubic tensor product spline functions over quadtree and octree T-meshes. We only demand these T-meshes to be 0-balanced and this requirement can be easily satisfied by using a standard balancing procedure. The proposed strategy includes simple instructions used for inferring local knot vectors to define blending functions. We conjecture that the resulting spline spaces have nice properties: linear independence and the characteristic that spaces spanned by nested T-meshes are also nested. The above mentioned properties were verified in numerous numerical experiments and we plan to provide a rigorous proof in our next work.The implementation of our technique is straightforward taking into account the balance mesh restriction. Examples of adaptive refinement using IGA for 2D and 3D Poisson problems have been presented. In all of them, optimal rates of convergence have been obtained. We believe that the simplicity of our technique can make it an attractive tool for its application in IGA and geometric design.In future works we also plan to improve the strategy obtaining a better locality of the function supports.

@&#CONCLUSIONS@&#
