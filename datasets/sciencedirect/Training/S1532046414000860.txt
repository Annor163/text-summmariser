@&#MAIN-TITLE@&#
Small sum privacy and large sum utility in data publishing

@&#HIGHLIGHTS@&#
We identify the dilemma allowing inference attacks on privacy preserving publishing.We show that utility and privacy guarantees can co-exist.We propose a mechanism, called SPLU-Gen, for offering small count privacy and large count utility.We introduce a sophisticated reconstruction method for enhanced utility.We provide a comprehensive set of experiments on two real datasets.

@&#KEYPHRASES@&#
Privacy preserving data publishing,Inference attacks,Privacy versus utility,

@&#ABSTRACT@&#
While the study of privacy preserving data publishing has drawn a lot of interest, some recent work has shown that existing mechanisms do not limit all inferences about individuals. This paper is a positive note in response to this finding. We point out that not all inference attacks should be countered, in contrast to all existing works known to us, and based on this we propose a model called SPLU. This model protects sensitive information, by which we refer to answers for aggregate queries with small sums, while queries with large sums are answered with higher accuracy. Using SPLU, we introduce a sanitization algorithm to protect data while maintaining high data utility for queries with large sums. Empirical results show that our method behaves as desired.

@&#INTRODUCTION@&#
In a recent work by Cormode [7], it is shown that despite much progress in two main branches of privacy models for data publishing, namely differential privacy [13], and various syntactic methods such as k-anonymity [26] andℓ-diversity [20], inference-based attacks can still be successful. The study is based on the ability of an attacker to construct accurate classifiers on top of releases protected by state-of-the-art privacy preserving data publishing techniques.The empirical study result above is in fact consistent with the result from [10]. Following the model in [10], given a datasetd=(d1,…,dn)∈{0,1}n, a query q is a subset of{1,2,…,n}, and its true answeraq=∑i∈qdi. Hence, the query q determines a subset of d, and the answer for q is the number of entries in the subset. Given algorithmAfor query response, we say thatA(q)is within∊perturbation if it deviates from the true answer by no more than∊.Ais within∊perturbation ifA(q)is within∊perturbation for all q. If an adversary can reconstruct with time complexityt(n)the entire database very accurately, then the databaseD=(d,A)is said to bet(n)-non-private. The following theorem from [10] says that any privacy preserving algorithm renders the database useless, and conversely utility in the published data implies privacy breach.Theorem 1[10]LetD=(d,A)be a database whereAis withino(n)perturbation thenDis poly (n)-non-private.The above findings are based on the assumption that all inference attacks are to be defended, and any relatively accurate information derivable from the published data is considered privacy breaching. This is quite inconsistent with the simultaneous requirement of utility whereby minimum distortion is to be introduced so that the published data are as close to the original data as possible. Here we show that the dilemma can be resolved by a segregation of utility and privacy.The key point as observed by Cormode is that privacy and utility are closely related. As stated in the conclusion in [7], “release of (anonymized) data may reveal hitherto unknown population parameters which compromise individual privacy. … in some settings, these population statistics may represent exactly the desired utility of the data collection and publication.” This remark highlights the issue to be resolved. The key is how to differentiate between utility and privacy. Once we identify the utility of the data and once users agree that this utility has no conflict with their privacy, the proper solution is not to insist on protection for the information related to the utility. We provide a way to differentiate what concepts may be reasonable to be disclosed for utility. If users indeed have concerns about the disclosure of such concepts there is always the option of not releasing any data. This provides for a better alternative for the status quo of releasing the data knowing that certain inference attacks are possible.To our knowledge, there is no known model for the separation of concepts that need protection and those that need to be maintained for utility purposes, in privacy preserving data publishing. Some previous works [11,19] study the adjustment of parameters in the anonymization process for the trade-off between privacy and utility. The problem studied in such works is very different and in their model, all concepts are treated equally in terms of utility and privacy. We assume that aggregate queries of large sums should be answered relatively accurately for utility, while those with very small sums should not. Consider an example from [13] where a datasetD′tells us that almost everyone involved in a dataset is two footed. Knowing with high certainty that an individual is two footed fromD′is not considered a privacy issue since it is true for almost everyone in the dataset.1There may be scenarios where our assumption does not hold. That is, even if something is true for most tuples inD′, the information is still sensitive. An example would be a dataset containing only information about patients with a certain cancer disease. In such a case knowing that a person is in the dataset is already considered sensitive, and all attributes will be sensitive. Hence, our proposed model becomes irrelevant and does not apply.1Large sum concepts are statistical and of value for utility. In contrast, small count concepts are non-statistical and the protection of small counts has been well-studied in the topic of security in statistical databases [1].Our main contributions are summarized as follows.(1)We propose a framework, called SPLU, which allows releasing data for answering large sum queries with high accuracy to provide utility, while offering high inaccuracy for small sum queries in order to ensure privacy. We point out that not all inference attacks should be defended.To demonstrate the feasibility of the concept of SPLU, we propose a data sanitization mechanism, called SPLU-Gen, for achieving this goal. SPLU-Gen is based on randomized perturbation on the sensitive values.We introduce a sophisticated reconstruction algorithm which takes into account the global data distribution. This improves on the known reconstruction approach in syntactic methods and leads to higher data utility.We have conducted experiments on two real datasets to show that SPLU-Gen provides protection for small sums and high utility for large sum queries. We note that existing mechanisms may readily support SPLU, which is an encouraging result.In Fig. 1, we outline the SPLU-Gen mechanism for data sanitization and the query processing based on the sanitized data. The dataset on the left of the figure is passed as input to SPLU-Gen. The input is processed and as a result, a sanitized dataset is published. Querying is applied on the sanitized data, and the query result is generated by a reconstruction algorithm. The user will receive relatively accurate results for large sum queries and inaccurate results for queries of small sums.The rest of the paper is organized as follows. Section 2 presents the SPLU model. Section 3 describes the mechanism SPLU-Gen. Section 4 is about count reconstruction and properties of SPLU-Gen. Section 5 considers multiple attribute aggregations. Section 6 is on empirical study, and Section 7 is on related works. Section 8 concludes this work.We consider the data model in previous works on k-anonymity [26] andℓ-diversity [20]. This data model assumes that a set of attributes form a quasi-identifier, the values of which for a target individual can be known to the adversary from other sources, and also one or more sensitive attributes which need to be protected. Hence, there are two kinds of attributes in the dataset, the non-sensitive attributes (NSA) and the sensitive attributes (SA). In Fig. 2(a) we show a given dataset D. In table D, the attribute id is for the tuple id. The attributes Age and Zip-Code are considered non-sensitive attributes and they form a quasi-identifer. The term quasi-identifier indicates that it may be possible to identify an individual based on the respective attribute values. For example, it is possible that Age 90 and Zip-Code [12–17k] uniquely determine an individual, if there is only one resident aged 90 in the area of Zip-Code [12–17k]. Such attributes are considered not sensitive. In table D, Disease is a sensitive attribute.In this model we do not perturb the non-sensitive values but may alter the sensitive values to ensure privacy. This is a commonly used data model and it corresponds to the initial problem settings with real world applications [25,22].We are given a dataset (table) D which is a set of N tuples that follow the above data model. A concept c in D is a predicator formed by the conjunction of value assignments to a set of attributes in D. Our problem is how to generate and replace the sensitive values for the tuples in D to be published in the output datasetD′.D′should satisfy both utility for large sum querying and privacy protection for small sum queries.In Fig. 1(b), we show a possible published datasetD′, which is a sanitized counterpart of dataset D. We shall discuss in Section 3 about howD′is generated from D.We define the requirements of our model in the following.Given a dataset D, an anonymized data setD′generated by sanitization mechanismA, and a concept c involvings∈SA, letfcbe the true frequency of c in D andfc′be the estimated frequency of c fromD′.Definition 1large sum utilityConcept c has a(∊,TE,Tf)utility guarantee if(1)Pr|fc′-fc|⩾εfc⩽TEforfc⩾TfThe above definition says that a concept c has a(∊,TE,Tf)guarantee if whenever the frequencyfcof c is aboveTfin D, then the probability of a relative error of more thanεis at mostTE.Definition 2small sum privacyWe say thatAsatisfies SSP-privacy requirement w.r.t.(ε,TP,α)if(2)Pr|fc′-fc|⩾εfc⩾TPforfc⩽αOur problem is to design a database sanitization mechanismAwhich conforms to SPLU by supporting large sum utility as well as small sum privacy.The threshold for small sum privacy should be set by the application based on the level of security that is desired. Similarly for the threshold for large sum utility. Note that the two thresholds may be different, so that there can be some frequencies that we guarantee neither privacy nor utility. These thresholds are specifications to be given by the users. Also note that a user needs to first decide if the attributes with large sums are sensitive. As we have discussed in Footnote 1 in Section 1, there are scenarios where they can be sensitive. If large sum data are sensitive, our model will be irrelevant.We shall also make use of the following definition for privacy guarantee.Definition 4privacy guaranteeConcept c has a(ε,TP)privacy guarantee ifPr|fc′-fc|⩾εfc⩾TP.The above definition of small sum privacy resembles the definition of differential privacy in [12] in that probabilistic bounds are adopted. However, the exact formulations are quite different. A randomized algorithmAis said to give∊-differential privacy if for all datasets D andD′differing on at most one row, for allS∈Range(A),Pr[A(D)∈S]⩽e∊×Pr[A(D′)∈S], where the probability space is over the coin flips ofA, andRange(A)denotes the output range ofA.The goal of small sum privacy is to ensure that information that applies to a small number of individuals would not be released without introducing a significant amount of error probabilistically. SPLU is defined based on the estimated frequency. It will be up to the anonymization process to ensure that the estimated frequency is not accurate. We shall propose a mechanism SPLU-Gen that has a good guarantee in Section 3.We do not exclude the possibility that existing methods may also be shown to satisfy SPLU. In our empirical studies we show that Anatomy may achieve high enough relative errors for small sums and good utility for large sums. Also we show that∊-differential privacy may achieve high relative error for small sums with a proper choice of∊. However, these are empirical results and not theoretical guarantees. There may be future works to show that both techniques conform to SPLU under certain settings.In this section, we make use of a randomization technique to guarantee a tapering accuracy for the estimated values from large counts to small counts. In [4], a retention replacement perturbation (RRP) scheme for categorical sensitive values is proposed. This scheme keeps the original sensitive value in a tuple with a probability of p and randomly picks any other value to substitute for the true value with a probability of(1-p). Not all randomization techniques are equally effective. For example, if we simply generate sensitive values in the published records based on the original distribution of SA (let us refer to this distribution based randomization technique as DBR), the correlation with the NSA values will be lost since the generation of SA value for each tuple is based on the same p.d.f. In what follows, we propose a mechanism, called SPLU-Gen, which introduces uniform probability for replacement over a subset of the domain. We will show that this mechanism is a solution to our problem in Definition 3.SPLU-Gen generates a datasetD′given the dataset D. We assume that there is a single sensitive attribute (SA) S in D. Later we shall discuss the more general case of multiple sensitive attributes. We make the same assumption as in previous works [20,30] that the dataset is eligible, so that the highest frequency of any sensitive attribute value does not exceedN/γ. Furthermore we assume that N is a multiple ofγ(it is easy to ensure this by deleting no more thanγ-1tuples from the dataset). There are four main steps for SPLU-Gen:[Step 1] Include the tuple id as an attribute id in D. The first step of SPLU-Gen is an initialization step, whereby the dataset D goes through a projection operation on id and the SA attribute S. Let the resulting table beDs. That is,Ds=Πid,S(D). Note that the non-sensitive values have no influence on the generation ofDs.Fig. 3(a) shows a given dataset D, which is the same as the dataset in Fig. 1(a). After Step 1, the projected table ofDsis shown in Fig. 3(b).[Step 2] The set of tuples inDsis partitioned into groups of sizeγeach in such a way that in each partitioned group, the sensitive value of each tuple is unique. Let there be r partitioned groups,P1,…,Pr; in each groupPi, there areγtuples, andγdifferent sensitive values. We call each partitioned group a decoy group. If tuple t is inPj, we say that the elements inPjare the decoys for t. We also refer toPjasP(t). With a little abuse of terminology, we also refer to the set of records in D with the same id’s as the tuples in this decoy group asP(t). One can adopt some existing partitioning method in the literature ofℓ-diversity (e.g. [30]). We require that the method be deterministic. That is, given aDs(which involves only id and S), there is a unique partitioning from this step.Consider dataset D in Fig. 3(a). Letγ=3. Fig. 3(c) shows a possible partitioning of the tuples in D into 3 groups. In each group, there are 3 tuples with distinct Disease values.[Step 3] For each given tuple t inDs, we determine the partitionP(t). Let the sensitive values inP(t)bes1′,…,sγ′. For each of these decoy values, there is a certain probability that the value is selected for publication as the sensitive value for t. For a value not ins1′,…,sγ′, the probability of being published as the value for t is zero. In the following we shall also refer to the sets1′,…,sγ′asdecoys(t). Suppose that a tuple t has sensitive valuet.sin D. We create the tuplet′and initialize it to t. Next we generate a value to replace the S value int′by selectingsiwith probabilitypi, so thatpi=pforsi=t.spi=q=(1-p)1γ-1forsi≠t.s,si∈decoys(t)pi=0forsi∉decoys(t)We setp=q=1/γin our mechanism, which has the nice property that the cases forsi=t.sandsi≠t.sare identical.For tableDsin Fig. 3(b), with the partitioned groups in Fig. 3(c) and (d) shows a possible resulting tableDs′after the randomization process in Step 3. Sinceγ=3,p=q=1/3. For example, in the first group of tuples 1, 2 and 4, each of the diseases of Hiv, Flu and Fever has a probability of 1/3 to be assigned as the sensitive value for each tuple in this group.[Step 4] The set of tuplest′created in the previous step forms a tableDs′. Remove the s column from D, resulting inDN. Form a new tableD′by joiningDs′andDNand retaining only NSA and S in the join result. The tuples inD′are shuffled randomly. FinallyD′andγare published.Given D in Fig. 3(a). In Fig. 3(e), we show the table after joiningDs′andDN. Removing the id attribute from this table gives usD′. Next, the tuples inD′are randomly shuffled and Fig. 3(f) shows the published dataset.□Our method can be seen as a variation of the Retention Replacement Perturbation (RRP) scheme which is known to preserve good utility [4]. In particular the correlation of SA with NSA is maintained by the retention of the SA value for each tuple with probability p.2Since the sensitive value has some stickiness with the original tuple with a probability of p, an adversary with background knowledge that two individuals have the same SA value can launch an attack if both individuals happen to retain the SA value and the value is extremely rare. To handle such attacks we may adopt suppression of rare values. This, however, is beyond the scope of this work.2In comparison with partitioning based methods forℓ-diversity [20] such as Anatomy [30], there are some major observations. Firstly, Anatomy can be seen as introducing a random permutation in each group, whereas our method draws values in each group with replacement rather than without replacement. Hence, both methods can preserve the distribution of SA well. However, random permutation has a known problem of privacy leak for infrequent values, which need suppression for privacy reason [17]. The honest recording of SA values resulting from the permutations in Anatomy preserves the exact counts of the sensitive values for all frequencies, and there is no protection for the small counts. SPLU-Gen is based on a probabilistic assignment of values to sensitive attributes in the tuples. Due to the randomization, as we shall see in later analysis, the small counts will be protected by large expected error in the results of queries for such counts.Secondly, the partitioning information is not released by SPLU-Gen, in contrast to Anatomy and related approaches, in which the anonymized groups or buckets are made known in the data publishing. When the partitioning is known, each tuple has a limited set ofℓpossible values, hence Anatomy is known to suffer from background knowledge attack where the adversary hasℓ-1pieces of information for eliminating the possibilities. For SPLU-Gen, by withholding the partitioning information, and with the possibility that a value existing in D may not exist inD′, the possible values for the sensitive attribute is the entire domain. Another advantage of not releasing the partitioning information is that it makes the de Finetti attack [18] and the foreground attack in [28] mechanisms inapplicable, since both attacks are based on the knowledge of the partitioned groups. Both attacks are possible for Anatomy.In this section we examine how to answer count queries for the sensitive attribute based on the published datasetD′. Let|D|=N, so that there are N tuples in D. Consider a sensitive value s. Let the true frequency of s in D befs. By Algorithm SPLU-Gen, there will befsdecoy groups which contain s in the decoy value sets. Each tuple in these groups has a probability ofp=1γto be assigned s inD′. The probability that it is assigned other valuess¯is1-p. There arefsγsuch tuples.LetNs′denote the number of times that s is published inD′. The random variableNs′follows the binomial distribution with parametersfsγand p.PNs′=x=fsγxpx(1-p)fsγ-xThe expected value isfsγp. Since we setp=q=1/γ, the expected count of s inD′is given byes=pγfs=fs. That is, to estimate the true count of an SA value s, we simply take the count of s inD′,fs′.Theorem 2The estimation offsbyfs′is a maximum likelihood estimation (MLE).LetL(D)be the likelihood of the observationfs′inD′, given the original dataset D.L(D)=Pr(fs′|D)From Mechanism A′, givenfsoccurrences of s in D, there will be exactlyγfstuples that generate s inD′with a probability of p. The remaining tuples have zero probability of generating a s value. The probability thatfs′occurrences of s is generated inD′is given byL(D)=Pr(fs′|D)=γfsfs′pfs′(1-p)γfs-fs′wherep=1/γ. This is a binomial distribution function which is maximized whenfs′is at the mean value ofγfsp=fs. In particular,lnL(D)=c+fs′lnp+(γfs-fs′)ln(1-p)for a constant c. Settingddp(lnL(D))=fs′p-γfs-fs′1-p=0givesfs=fs′. □To examine the utility of the datasetD′, we ask how likely it is forfs′to be close tofs. We also need to provide protection for small counts. Next, we show that our method simultaneously discloses useful information where the sum is large and hence safe, and withholds accurate information when the sum is small.To answer the question about the utility for large sums, we derive a bound for the relative error. If there arefstuples with s value, thenn=γfstuples in D will have a probability of p to be assigned s inD′. The setting of value s to the tuples inD′corresponds to a sequence ofγfsindependent Bernoulli random variables,X1,…,Xγfs, each with parameter p. HereXi=1corresponds to the event that s is chosen for the i-th tuple, whileXi=0corresponds to the case where s is not chosen. Sincep=1/γandn=γfs,fs=np.Theorem 3Forε>0,(3)Pr|fs′-fs|⩾εfs⩽1γε2fs2The proof of the utility of the published data for large sums is based on Chebychev’s Theorem: If X is a random variable with meanμand standard deviationσ, then for any positive k,Pr(|X-μ|<kσ)⩾1-1k2andPr(|X-μ|⩾kσ)⩽1k2.LetX1,X2,…,Xn,…be a sequence of independent, identically distributed random variables, each with meanμand varianceσ2. Define the new sequence ofX‾ivalues byX‾n=1n∑i=1nXi,n=1,2,3,….From Chebychev’s inequality,P|X‾n-μX‾n|⩾kσX‾n⩽1k2whereμX‾n=E[X‾n]=μ,σX‾n=E[(X‾n-μ)2]=σ2nand k is any positive real number. Choosek=∊nσfor some∊>0, we get(4)Pr|X‾n-μ|⩾∊⩽σ2∊2n.We use the above reasoning to derive the utility of our published data for large sums. If there arefstuples with s value, thenn=γfstuples in D will have a probability of p to be assigned s inD′. The setting of value s to the tuples inD′corresponds to a sequence ofγfsindependent Bernoulli random variables,X1,…,Xγfs, each with parameter p. HereXi=1corresponds to the event that s is chosen for the i-th tuple, whileXi=0corresponds to the case where s is not chosen.The mean valueμX‾n=p. Also,σX‾n2=p(1-p)/n. From Inequality (4),Pr|X‾n-μ|⩾∊⩽p(1-p)∊2n2=p(1-p)∊2γ2fs2. We setp=1γ, hence(5)Pr|X‾n-μ|⩾∊⩽1γ3∊2fs2Note thatX‾nis the count of s inD′divided by n, andn=γfs. Hence, the occurrence of s inD′isfs′=γfsX‾n.Rewriting Inequality (5), we getPr|γfsX‾n-γfsμ|⩾γfs∊⩽1γ3∊2fs2Sinceμ=p=1/γ,Pr|fs′-fs|⩾γ∊fs⩽1γ3∊2fs2.With the above inequality, we are interested in how differentfs′is fromfs. Since the deviation is bounded byγ∊fs, it is better to use another variableε=γ∊to quantify the difference.Pr|fs′-fs|⩾εfs⩽1γε2fs2□Our estimation ises=fs′, hence the above gives a bound on the probability of error in our estimation. Iffsis small, then the bound is large. In other words the utility is not guaranteed, which means better privacy protection.Given a desiredεand a desiredγ, we may find a frequency thresholdTfso that forfsabove this threshold, the probability of error in Inequality (3) is below another thresholdTEfor utility. We can set the RHS in the above inequality to be this threshold.Lemma 1SPLU-Gen provides a(∊,TE,Tf)utility guarantee for each sensitive value, whereTf=1γε2TE12Hence, givenεandTE, we can determine the smallest count which can provide the utility guarantee.Fig. 4shows the relationship between the possible values ofTfandTE. The utility is better for smallTE, and the value ofTEbecomes very small when the count is increasing towards 900. Note that it also means that for concepts with large counts, privacy protection is not guaranteed, since the accuracy in the count will be high.Next, we show how our mechanism can inherently provide protection for small counts. From Inequality (3), small values offswill weaken the guarantee of utility. We can in fact give a probability for relative errors based on the following analysis.The number of s inD′is the total number of successes infsγrepeated independent Bernoulli trials with probability1γof success on a given trial. It is the binomial random variable with parametersn=γfsp=1γ, andq=1-p. The probability that this number is x is given bynxpxqn-x=γfsx1γx1-1γγfs-x.Example 1Iffs=5,γ=10, for anε=0.3bound on the relative error, we are interested to know how likely it is forfs′to be close to 5 within a deviation of 1. The probability thatfs′is between 4 and 6 is given by∑x=4650x0.1x0.950-x=0.52. Hence, the probability thatfs′deviates fromfsby more than0.3fsis 0.48.From Definition 4, a sensitive value s has a(ε,TP)privacy guarantee if the probability that the estimated count ofs,fs′, has a relative error of more thanεis at leastTP. In Example 1, the value s has a(0.3,0.48)privacy guarantee. We can derive the following.Lemma 2Considering only single SA value concepts, SPLU-Gen with parameterγsatisfies SSP-privacy with respect to(ε,TP,α), whereTP=minfs∈[1..α]1-∑x=⌈(1-ε)fs⌉⌊(1+ε)fs⌋γfsx1γx1-1γγfs-xNote that this guarantee is independent of the dataset size and independent of the data distribution. Also note that a closed form approximation by replacing the binomial with a normal distribution is not applicable here since the value offsof interest is very small.Example 2A graph is plotted in Fig. 5for the expected error for small values offs. Here the summation in the above probability is taken fromfs′=⌈0.7fs⌉tofs′=⌊1.3fs⌋. We have plotted for differentfsvalues the probability given by1-∑x=⌈0.7fs⌉⌊1.3fs⌋γfsx1γx1-1γγfs-x. Due to the rounding effects of the summation over integer values of x, the graph has a sawtooth shape. This graph shows that the relative error in the count estimation is expected to be large for sensitive values with small counts. From this graph, we can derive that for single SA value concepts, givenα=3,ε=0.3,TP=0.6, SPLU-Gen withγ=10satisfies SPLU-privacy with respect to(ε,TP,α). The graph also shows that the choice ofγhas little impact on the guarantee.In this section we consider the reconstruction of counts for sets of values. For example, we may want to estimate the count of tuples with both lung cancer and smoking, or the count of tuples with gender=female, Age=60 and disease=allergy. First we shall consider the estimation of counts for predicates involving a single sensitive attribute, then we extend our discussion to predicates involving multiple sensitive attributes.Assume that we have a set of non-sensitive attributes NSA and a single sensitive attribute SA. Let us consider queries involving both NSA and SA. We may divide such a query into two components: P and s, whereP∈domain(NA)(NA⊆NSA), ands∈domain(SA). For exampleP=(female,60)ands=(allergy). Note that the non-sensitive attributes are not distorted in the published dataset. This can be seen as a special case of generating a non-sensitive value for the individual t by selectingsiwith probabilitypi, so thatpi=1forsi=t.s; andpi=0forsi≠t.s.Suppose we are interested in the count of the co-occurrences of non-sensitive values P and sensitive value s.Definition 5state iThere are 4 conjunctive predicates concerning P and s, namely,ϕ0=P‾∧s‾,ϕ1=P‾∧s,ϕ2=P∧s‾, andϕ3=P∧s. If a tuple satisfiesϕi, we say that it is at state i.The distributions of the predicates in D andD′are given bycnt(ϕi)andcnt′(ϕi), respectively. Herecnt(ϕi)(cnt′(ϕi))is the number of tuples satisfyingϕiin D (D′).For simplicity we letxi=cnt(ϕi)andyi=cnt′(ϕi), hence the a priori distribution concerning the states in D is given byx={x0,x1,x2,x3}, and the distribution inD′is given byy={y0,y1,y2,y3}. Hence, y contains the observed frequencies.Definition 6Transition matrix MThe probability of transition for a tuple from an initial state i in D to a state j inD′is given byaij. Valuesaijform a transition matrix M.LetPr(ri|x)be the probability that a tuple is at state i inD′given vector x for the initial state distribution. The following can be derived.(6)Pr(r0|x)=1N1-x1+x3Nx0+γ-1γx1(7)Pr(r1|x)=1Nx1+x3Nx0+1γx1(8)Pr(r2|x)=1N1-x1+x3Nx2+γ-1γx3(9)Pr(r3|x)=1Nx1+x3Nx2+1γx3The above equations are based on the mechanism generatingD′from D. Let us consider the last equation, the other equations are derived in a similar manner. For each true occurrence of(P,s), there is a1γprobability that it will generate such an occurrence inD′. If there arex3such tuples, then the expected number of generated instances will bex3/γ.Other occurrences of(P,s)inD′may be generated by thex2tuples satisfying P but witht.s≠s(P,s‾). Each such tuple t satisfies P for the non-sensitive values and it is possible thats∈decoys(t). We are interested to know how likely it is thats∈decoys(t).There are in totalNγpartitions. There can be at most one s tuple in each partition. Hence,fsof the partitions contain s in the decoy set, and if a tuple t is in such a partition, thens∈decoys(t). The probability of having s indecoys(t)for a tuple t witht.s≠sis the probability that t is in one of thefspartitions above given thatt.s≠s. Note that the condition in this probability ist.s≠sand not on more detailed information about t. This probability is given byfs/Nγ=fsγN. Sincefs=x1+x3, this probability isx1+x3Nγ. The total expected occurrence of(P,s)is given byx3γ+x1+x3Nγx2γ. We can convert this into a conditional probability that a tuple inD′satisfies(P,s)given x, denoted byPr(r3|x). This gives Eq. (9).Rewriting Eqs. (6)–(9) with the transition probabilities in Fig. 6gives the following:(10)Pr(ri|x)=∑j=03ajixjNEq. (10) shows thatajiis the probability of transition for a tuple from an initial state j in D to a state i inD′.We adopt the iterative Bayesian technique for the estimation of the counts ofx0,…,x3. This method is similar to the technique in [4] for reconstructing multiple column aggregates.Let the original states of tuplest1,…,tNin D beU1,…,UN, respectively. Let the states of the corresponding tuples inD′beV1,…,VN. From Bayes rule, we havePr(Uk=i|Vk=j)=P(Vk=j|Uk=i)P(Uk=i)P(Vk=j)SincePr(Uk=i)=xi/N, andPr(Vk=j|Uk=i)=aij,(11)Pr(Uk=i|Vk=j)=aijxiN∑r=03arjxrNPr(Uk=i)=∑j=03Pr(Vk=j)Pr(Uk=i|Vk=j)Hence, sincePr(Vk=j)=yj/N,Pr(Uk=j)=xj/Nand from Eq. (11), we have(12)xiN=∑j=03yjNaijxiN∑r=03arjxrNWe iteratively update x using the following equation(13)xit+1=∑j=03yjaijtxit∑r=03arjtxrtWe initializex0=y, andxtis the value of x at iteration t. In Eq. (13),aijtrefers to the value ofaijat iteration t, meaning that the value ofaijtdepends on setting the values ofx=xt. We iterate untilxt+1does not differ much fromxt. In our experiments, the stopping criterion is that for all0⩽i⩽3,|xit+1-xit|/xit⩽0.01. The value of x at this fixed point is taken as the estimated x value. In particular,x3is the estimated count of(P,s).So far we have considered that there is a single sensitive attribute in the given dataset. Suppose instead of a single sensitive attribute (SA), there are multiple SAs. Let the sensitive attributes beS1,S2,…Sw. We can generalize the randomization process by treating each SA independently, building decoy sets for eachSi.For predicates involving{P,s1,s2,…,sw}, where P is a set of values for a set of non-sensitive attributes,si∈domain(Si), there will beK=2w+1different possible states for each tuple. We let(P,s1,s2,…,sw)stand for(P∧s1∧s2…∧sw). For reconstruction of the count for(P,s1,s2,…,sw), we form a transition matrix for all theK=2w+1possible states. It is easy to see that the case of a single SA in Section 5.1 is a special case where the transition matrix M is the tensor product of two matricesM0andM1,A=M0⊗M1, whereM0is for the set of non-sensitive values andM1is fors1, and they are defined as follows:M0=1001Mi=1-fsi/Nfsi/N(γ-1)/γ1/γIn general, with sensitive attributesS1,…,Sw, the transition matrix is given byM=M0⊗M1…⊗Mw.Let the entries in matrix M be given bymij. We initializex0=yand iteratively update x using the following equation(14)xit+1=∑j=0K-1yjmijtxit∑r=0K-1mrjtxrtIn Eq. (14),xtis the value of x at iteration t.aijtrefers to the value ofmijat iteration t, meaning that the value ofmijtdepends on setting the values ofx=xt. We iterate untilxt+1does not differ much fromxt. In our experiments the stopping criterion is that for all0⩽i⩽3,|xit+1-xit|/xit⩽0.01. The value of x at this fixed point is taken as the estimated x value. In particularxK-1is the estimated count of(P,s1,…,sw).For the multiple attribute predicate counts, we also guarantee that privacy for small sums will not be jeopardized.Lemma 3Let s be a sensitive value with a(ε,Tp)privacy guarantee, then the count for a multiple column aggregate involving s also has the same privacy guarantee.Without loss of generality, consider a multiple attribute aggregate of(P,s), whereP∈domain(NSA). Since the randomization of s is independent of the NSA attributes, the expected relative error introduced for(P‾,s)is the same as that for(P,s). The total expected error for(P‾,s)and(P,s)must not be less than that dictated by the(ε,TP)guarantee since otherwise the sum of the two counts will generate a better estimate for the count of s, violating the(ε,TP)privacy for s. Hence for(P,s)the privacy guarantee is at least(ε,TP). □Letϕ=(P,s)be a predicate with sensitive value s. andP∈domain(NA)(NA⊆NSA). There are two possible cases as follows. CASE 1: There existsfϕoccurrences ofϕin D and there is no other occurrence of s in D. CASE 2: There existsfϕoccurrences ofϕin D and there exists other occurrence(s) of s in D.Lemma 4In CASE 1, the estimation offϕbyfs′is a maximum likelihood estimation (MLE).There are in totalfϕoccurrences of s in D. Hence estimating the number of s in D also estimates the number ofϕin D. With SPLU-Gen, givenfϕoccurrences of s in D, there will be exactlyγfstuples that generates s inD′with a probability of p, wherep=1/γ. The remaining tuples have zero probability of generating a s value. The maximum likelihood of the estimation byfs′follows the same argument as that in the proof of Theorem 2.□For CASE 2, suppose there arefϕoccurrences ofϕin D andfP‾sother occurrences of s. Letϕ1=(P‾∧s). Estimation offϕbyfs′will be affected by other occurrences of s inD′that may be generated from groups containing records satisfyingϕ1. Supposefs′is taken to be the estimation offϕ, then we can show that the probability of the estimation error exceeding a given relative error threshold is always at least the same as that in CASE 1: if there is no occurrence ofϕ1, the probability thatfs′is withinεof the truefϕvalue is given byProbA=∑x=⌈(1-ε)fϕ⌉⌊(1+ε)fϕ⌋γfϕx1γx(1-1γ)γfϕ-x. If there arex′instances of s generated by instances ofϕ1, the probability will becomeProbB=∑x=⌈(1-ε)fϕ⌉-x′⌊(1+ε)fϕ⌋-x′γfϕx1γx(1-1γ)γfϕ-x. It is easy to show thatProbB⩽ProbA.We next consider how to derive the SPLU-privacy property of SPLU-Gen. For CASE 1, the number ofϕinD′is the total number of successes infϕγrepeated independent Bernoulli trials, with a probability of1γfor success on a given trial. Hence, we can derive the(ε,TP)privacy guarantee forϕas in Section 4.2.For CASE 2, let us consider the scenario thatx′, the number of occurrences of s due to occurrences ofϕ1, has also been given for the estimation offϕ. In this case the estimation offϕbyfs′-x′will be the maximum likelihood estimation (MLE) forfϕ, with the argument given for Lemma 4, and the privacy guarantee is the same as CASE 1. If the value ofx′is not given, the estimation offϕwill no longer have the MLE guarantee, and therefore we use the CASE 1 guarantee as a bound for the overall guarantee. Hence, we have the following result.Theorem 4SPLU-Gen with parameterγsatisfies SSP-privacy with respect to(ε,TP,α), whereTP=minfϕ∈[1..α]1-∑x=⌈(1-ε)fϕ⌉⌊(1+ε)fϕ⌋γfϕx1γx1-1γγfϕ-x□We have implemented our mechanism SPLU-Gen and compared it with some existing techniques that are related in some way to our method. The objectives of our empirical study are the following: (1) While we have shown in Section 4 that SPLU-Gen satisfies small sum privacy and large sum utility, we would like to see the actual results in a real dataset. Hence, in our experiments we adopt the measure of relative error to illustrate the privacy and utility levels, where a higher relative error corresponds to more privacy and less utility. (2) Demonstrate the effectiveness of our sophisticated reconstruction mechanism, which makes the querying results more accurate for large sum queries compared to previous approach. We shall compare with Anatomy. (3) Show that∊-differential privacy may not preserve small sum privacy with some known parameter settings, and therefore careful parameter setting is needed. (4) Show that the choice of retention based randomization is sound by comparing with a randomization algorithm (DBR) that does not have a retention probability for the original SA value in each tuple. (5) Show that correlation for the case of multiple SA attributes can be preserved. (6) Show that the computations involved are not costly.All algorithms are implemented in C++ and tested on a machine with Intel (R) Core (TM) i3 3.10GHz CPU and 4.0GB RAM. The program for Anatomy is provided by the first author of [30].For step 2 of mechanism SPLU-Gen, we need to partition tuples inDsinto sets of sizeγeach and each partition containsγdifferent sensitive values. We have adopted the group creation step in the algorithm for Anatomy [30]. In this algorithm, all tuples of the given table are hashed into buckets by the sensitive values, so that each bucket contains tuples with the same SA value. The group creation step consists of multiple iterations. In each iteration a partition (group) withγtuples is created. Each iteration has two sub-steps: (1) find the set L with theγhash buckets that currently have the largest number of tuples. (2) From each bucket in L, randomly select a tuple to be included in the newly formed partition. Note that the random selection in step (2) can be made deterministic by picking the tuple with the smallest tuple id.We use two real datasets. The first dataset is CENSUS,3Downloadable at http://www.ipums.org.3which contains the information for American adults. The second dataset, CADRMP, is from a publicly available4Downloadable at http://www.cse.cuhk.edu.hk/adafu/medical-data.html, originally from http://www.hc-sc.gc.ca/dhp-mps/medeff/databasdon/structure-eng.php.4real hospital database.The CENSUS dataset consists of 8 categorical dimensions: Gender (cardinality 2), Education (17), Marital (6), Race (9), Work-class (10), Country (83), Age (78), and Occupation (50). From the CENSUS dataset, we form datasets with increasing cardinalities. First, we randomly sampled 500k tuples from the real dataset, then we further randomly sampled five datasets from the 500k tuples, with cardinalities ranging from 100k to 500k, the 100k dataset is used as the default. Occupation is chosen as the sensitive attribute, while it is combined with Age for experiments with multiple sensitive values.For the dataset CADRMP, there are 8 tables: Reports, Reactions, Drugs, ReportDrug, Ingredients, Outcome, and Druginvolve. Reports consists of patients’ basic personal information. Reactions has a foreign key PID that references the attribute ID in Reports and an attribute to indicate the patient’s disease. Reports contains records for 42,264 different individuals. A patient may have multiple diseases. We first pre-process the dataset so that we retain only the most frequent disease for each patient. Next we join the tables Reports and Reactions in order to link the patient information with the disease information. There are 42,264 tuples in the joined table with 17 attributes each. The attributes are Report-id (cardinality 42264), Report-no (6998), Gender-English (5), Age (107), Age-unit (1), Weight (316), Height (245), Manufacture-id (3241), Date-of-Last-Follow-up (1200), Serious (3), Feature-of-Report (12), Report-Type (11), Notifier-Type (12), Notifier-Location (13), ADR-id (42264) and Disease (1346). Disease will be used as the sensitive attribute.In the experiment we consider count queries, which have been used for utility studies for partition-based methods [30] and randomization-based methods [21]. Count queries are generated according to the method described in Appendix 10.9 in [5]. Specifically, we generate random predicates with up to 3 of the non-sensitive attributes, each of which is combined with a randomly selected value in the domain of the sensitive attribute to form a query. We count the tuples satisfying such a query, which is of the formA1=v1∧…∧Ad=vd∧SA=vs, where eachAiis a distinct non-sensitive attribute, SA is the sensitive attribute, and theviandvsare values from the domains ofAiand SA, respectively. The selectivity of a query is defined as the percentage of tuples that satisfy the conditions in the query. In most of our analysis, we group queries according to their distinct selectivity ranges. We consider the queries with selectivity no more than 10 as small counts. Large count queries are those with[0.5%,5%)selectivity in the CENSUS dataset, and with[1%,9%)selectivity in the CADRMP dataset. A pool of 5000 small count queries and a pool of 5000 large count queries are generated for each dataset. When a selectivity s is considered without a range, we report on the average relative error of the estimated count for all queries that pass the selectivity threshold s. For a single query, if the correct answer is a and the returned answer isa′, then the relative error is given by|a-a′|/a. For a set of Q queries, if the sum of relative error for all queries in the set is E, then the average relative error isE/Q.Given queries in the pool, we calculate the average relative error between the actual count (from the original dataset) and the estimated count (from the published dataset) as the metric for utility. As discussed earlier, we differentiate between small counts and large counts. Specifically, we vary the selectivity (denoted by s, which is the ratio of the actual count to the cardinality of dataset) for large counts. For small counts, we require the actual count to be no more than 10. We evaluate the influence of variousγvalues, and also the cardinalities of dataset on the utility. To assess the efficiency, we record the running time of our data publishing algorithm.In this subsection we report on the results for the CENSUS dataset. We shall consider the utility for large sums, the privacy for small sums, and the comparison with other algorithms.We first consider the utility of the anonymized data for queries with sufficient sums. The results are shown in Fig. 9(a). For selectivity (i.e., large counts) between 2% and 5%, the relative error is around 10%. The relative errors are bounded by 20% for other selectivities between 0.5% and 5%. Another observation is that the relative error is the smallest when the selectivity is the greatest at 4–5%. This shows the desired effect that the result is more accurate for large sums. In Fig. 8, we plot the relative errors for increasing selectivity from [0.5%, 1%), [1%, 2%), …, to [4%, 5%), and we notice a drop of the relative error as selectivity reaches 5%, which is the desired behavior.We have also run some special queries on the dataset by generalizing the domain of attribute age into intervals so that each age interval spans about 8% of the tuples, this allows us to generate queries with selectivities between 5% and 8%. With such queries, and withγ=5, dataset of size 100K, the average relative error for SPLU-Gen is 0.01, which is very small, and it shows that the utility for larger sums is very high.We plot the relative errors of queries with small counts in Fig. 7, where the counts are smaller than 10. We see that the error is sufficiently high to ensure privacy, consistent with our requirement that answer for small count should be inaccurate enough to prevent privacy leakage. The relative error also displays a positive linear correlation withγ. Asγbecomes bigger, higher uncertainty is introduced and privacy for small counts is ensured at a higher level. It also indicates that a small value ofγsuch as 5 is sufficient for a big relative error.We have implemented three existing methods:∊-differential privacy, Anatomy, and the distribution based randomization technique (DBR). DBR is described in Section 3, it generates SA values based on the distributions in the original dataset.The first other method we have implemented is querying with∊-differential privacy. We add independently generated noise with distributionLap(Δf/∊)to the true query result, and this ensures∊-differential privacy [14]. The parameter∊is public and as stated in [13], it may be set to values such as 0.01, 0.1, or in some cases,ln2orln3, and in particular, an example ofΔf=1and∊=ln2is used for illustration. For this set of experiments, we are not comparing∊-differential privacy with other methods. We aim to study the effects of different values of∊on small sum privacy. We have plotted the result of relative error for small count queries (count between 1 and 10) in Fig. 7 for the cases ofΔf=1and∊=ln3and also∊=ln2. We can see that the relative error is quite small compared to the other methods, and can lead to privacy concerns. If∊is set smaller, the relative error will become bigger. This result shows that differential privacy mechanism may violate the small sum privacy requirement if the parameters are not set properly. Therefore, careful selection of parameters is needed.To compare with the Anatomy method, we set bothγandℓin Anatomy to the same value,γ=ℓ=5. The answers for Anatomy are estimated using the method in [30]. We then choose different settings of s (selectivity) and N (sizes of dataset) to evaluate their performance. We first examine the relative error for small counts (see Fig. 7). In comparison it is noted that SPLU-Gen achieves a highest error rate for larger values ofγ, which shows that SPLU-Gen is more sensitive to the group sizes. In Fig. 8, we compare the methods in terms of their achieved utility by setting N=300K and varying the selectivity. SPLU-Gen has a decreasing pattern for the relative error with decreasing selectivity, which is consistent with the SPLU model. Anatomy does not exhibit a similar trend. These results can be explained by the use of a randomization and reconstruction technique in SPLU-Gen which directly corresponds to the law of large numbers. For large count queries, the average relative errors for Anatomy and SPLU-Gen are shown in Fig. 9(b) and (a), respectively. The overall error of our method is smaller than that of Anatomy and also there is better correspondence of utility with selectivity. This helps to show the superiority of our reconstruction mechanism.Next we consider the comparison with the distribution based randomization algorithm DBR. For DBR, the maximum likelihood estimations for sums of SA or predicates involves both NSA and SA are the corresponding counts in the published data. While DBR makes use of the original SA distribution in the randomization, and hence can preserve it well, it does not try to retain the original SA value in a given tuple. Hence, the correlation of the NSA and SA is not preserved. This affects the utility of DBR for predicates involving both NSA and SA. From Fig. 9(c), we see that DBR leads to higher relative errors for large sum queries. In Fig. 8, for DBR, we observe larger errors for smaller selectivities compared to SPLU-Gen, and an increase in error for larger selectivity. There is no obvious trend as the utility fluctuates with the correlations in the original datasets, where higher inaccuracy results if the original dataset exhibits more correlations for the chosen query.Next we report our results on the medical dataset CADRMP. This dataset is comparatively smaller than CENSUS, with only 42,264 data records. The smaller size makes the results less stable compared to CENSUS. We shall again examine the utility for large sums, the privacy for small sums and the comparison with other methods. Since the relative errors in general for CADRMP are lower for small counts, we have attempted to set the default value ofγto 10 as is set in [30]. However, there exists some sensitive value with a frequency above 10%, hence CADRMP violates the eligibility condition [30,20] and Anatomy becomes infeasible. Hence, we setγto the nearest feasible value of 9.The results for utility are shown in Fig. 11. We plot the relative errors for increasing selectivity from [1%, 2%), [2%, 3%), …, to [8%, 9%). The relative errors range from below 10% to below 30%. The trend is not clear as the greatest errors occur in the middle at selectivity[5%,6%), and is the lowest at selectivity[6%,7%). The errors from the three methods, SPLU-Gen, Anatomy, and DBR are quite similar in trend. One explanation to this fluctuation is that the given dataset has a smaller size and the cardinality of the sensitive value is large, which introduces more uncertainty for the errors. The cardinality of Disease in CADRMP is 1346. Compared to the cardinality of 50 for Occupation in CENSUS, Disease is much more diverse. This makes the results more unstable across the different methods. Hence, users may first analyze the diversity of their data attributes and take note of its possible impact on the results. Overall, the relative errors for SPLU-Gen and Anatomy are both small for the large sum queries and both methods provide utility for such queries.We varyγfrom 2 to 9 in Fig. 10to measure the relative error for small count queries. The relative errors from SPLU-Gen, Anatomy, DBR and DP are plotted. The resulting trend is similar to the results from CENSUS. SPLU-Gen has a clearly higher relative error rate compared to the other methods atγ=4or above, and hence provides better small sum privacy.In Fig. 10 we also show the results of querying with∊-differential privacy [14]. As stated in [13],∊may be set to values such as 0.01, 0.1, or in some cases,ln2orln3. We have plotted the result of relative errors for small count queries (count between 1 and 10) in Fig. 10 for the cases ofΔf=1and∊=ln3and also∊=ln2. We can see that for∊=ln3, the relative error is quite small compared to the other methods, and can lead to privacy concerns. If∊is set smaller the relative error will become bigger. This result is similar to that for CENSUS.We also consider the utility in scenarios where a query involves more than one sensitive value. To this end, we choose Age and Occupation as the sensitive attributes in CENSUS. The two sensitive attributes are randomized independently and then combined for data publishing To allow queries of large selectivities, we first generalize the domain of Age into ten intervals; without this step, most of the resulting counts are too small and the range of selectivity is limited. The relative error for multiple-dimension aggregates involving two sensitive attributes is shown in Fig. 12, whereγranges from 2 to 8. Although the selectivity is very low (0.1–0.7% for this case), the overall accuracy can match that of the single-sensitive-attribute scenario.The computational overhead mainly comes from the partitioning process. We have adopted the partitioning method of Anatomy. This algorithm can be implemented with a time complexity ofO(N(1+Vγ)), where N is the cardinality of the table, and V is the number of distinct values of the sensitive attribute. We measure the running time for the case of single sensitive attribute on the largest 500K dataset, varyingγfrom 2 to 10. For all chosenγvalues, our algorithm can finish within 10 s for a 500K dataset, which is practical to be deployed in real applications.We also consider the querying efficiency at the user side. To estimate the answer, a user will compute each component of the vector y, and do matrix multiplications to iteratively converge to the answer x. When each component of y changes by no more than1%, we terminate the iteration and measure the querying time and number of iterations. In our experiments, SQLITE35See http://docs.python.org/library/sqlite3.html.5serves for querying y, and we consider the case with two sensitive attributes which involves the most number of components in y, implying the largest computational cost. The result shows that the Bayesian iterative process takes negligible time, while the major cost comes from the querying step. In particular, it takes less than 1ms on average, and 10ms in the worst case, for the iterative process to converge. The median and average of the number of iterations is 16 and 325, respectively. In total, the average measured time for a query is 1612ms, which poses little computational burden on users.As pointed out in Section 2, the thresholds for small sum privacy and large sum utility can be determined by users. The users may decide based on both theoretical analysis and experimental results. With SPLU-Gen, we have the properties as given in Lemmas 1 and 2, and some analytical results are shown in Figs. 4 and 5. The figures show the utility for large sums of 100 or above for different values of∊, and privacy guarantee for small sums of less than 10. Our experimental results in this section support similar findings. The user can decide on the suitable thresholds based on these results. We have set the parameter ofγto values of 5, 9, and 10 with satisfactory outcomes. Hence, we would recommend the use ofγvalues between 5 and 10 for SPLU-Gen.

@&#CONCLUSIONS@&#
