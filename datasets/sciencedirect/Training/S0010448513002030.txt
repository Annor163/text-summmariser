@&#MAIN-TITLE@&#
A high capacity reversible data hiding method for 2D vector maps based on virtual coordinates

@&#HIGHLIGHTS@&#
We develop a high capacity reversible data hiding method for 2D vector maps.Virtual coordinates are exploited to expand the capacity.The data capacity achieves nearly2c(c≥1)bits/vertex.The reversibility, invisibility, and computational complexity are good.For polylines and polygons, content preserving operations can be resisted.

@&#KEYPHRASES@&#
Reversible data hiding,Data capacity,2D vector map,virtual coordinates,

@&#ABSTRACT@&#
In this paper, we propose a high capacity reversible data hiding method for 2D vector maps based on virtual coordinates. In the scheme, we calculate two virtual coordinates for each eligible coordinate, and embedc(c≥1) secret bits by modifying the state value of the interval which is created by the two corresponding virtual coordinates. Since nearly every coordinate can carrycbits, the data capacity in bits achieves nearly2ctimes the number of vertices in the vector map. In addition, to resist content preserving operations, the vertex traversing order is defined. Experimental results and analysis show that the proposed method provides good reversibility, invisibility and computational complexity and is robust against the feature rearrangement and vertex reversing attacks for polylines and polygons.

@&#INTRODUCTION@&#
Today, 2D vector maps, the fundamental data of geographical information systems (GISs), have been intensively applied in military, civil cartography, urban planning, forestry etc. The acquisition of such data is a high cost process  [1–5]. These vector geo-spatial data can be easily replicated, manipulated and distributed. On the other hand, thanks to powerful available tools and equipment, it is very easy even for an amateur to illegally modify and copy these valuable data. Tools that help us verify the integrity and protect the copyright of the 2D vector map content are thus essential.In the past few years, many new techniques and concepts based on data hiding or steganography have been introduced as a means for tamper detection  [6,7] and copyright protection  [1–5,8–19] in 2D vector maps. Data hiding can be defined as a process that hides data in a multimedia object. In most cases of data hiding, the original content is modified, and hence distorted in order to embed the hidden information in an irreversible way, i.e., they cannot recover the original data. However, due to the required high-precision nature of 2D vector maps, it is critical to reverse the embedded content back to the original version after the hidden data are retrieved. The techniques satisfying this requirement are reversible (also referred to as invertible, lossless, or distortion-free) data hiding. Those methods embed the secret data into the host signal in an invertible manner so that after the hidden data are extracted, the signal can be restored to its original form.Currently, research on reversible data hiding is mainly focused on images  [20–31]. Vector graphics are relatively new media forms for many applications, such as GIS and computer aided design (CAD). Some reversible data hiding schemes have been proposed for 3D graphic models  [32–39]. In 2001, Dittmann and Benedens  [32] proposed an invertible labeling algorithm by exploiting the method in  [33], which embeds data by adding faces and vertices. Although the data capacity is high, the extra bandwidth it requires for transmitting the added vertices and faces may be undesirable. Considering a triangle as a two-state geometrical object, Cayre and Macq  [34] described a reversible data hiding algorithm that hides data by modifying the triangle’s state according to the bit to be hidden. This method provides good robustness against translation, rotation and scaling transformations. However, it does not have large enough capacity and it takes too much time. In  [35], the minimum spanning tree (MST) and the connectivity of edges are used in a reversible data hiding scheme for 3D graphic models. Although it does not change the position of vertices in the 3D space, the embedding capacity is too low (close to 0.06 bit/vertex). Wu and Cheung  [36] proposed a method that embeds one bit into a mesh face by modulating the distance from the mesh faces to the mesh centroid. Despite the low capacity (at most 1 bit/face), the original mesh can only be approximately recovered. Based on the idea of sequential quantization, Cheung and Wu concealn−1secret bits in a mesh withnvertices in  [37]. Although the capacity is high (around 1 bit/vertex), it also only approximately recovers the original content. Another scheme is proposed by Wu and Dugelay  [38], where prediction-error expansion  [31] is used for obtaining good hiding capacity (about 3 bits/vertex).Of special interest to this paper is the work done by Wang and Wang  [39]. They firstly sort the coordinates of each axis in the point-sampled model to create intervals, and then embedcsecret bits into an interval by modifying the state value of the interval. The data capacity of this method is high (around 1.5cbits/vertex). However, when it is applied to the vector data in which the coordinates exhibit low correlation, the distortion may be not small. Besides, the computational complexity may be high since the coordinates have to be sorted before embedding.The reversible data hiding schemes for 2D vector maps  [17–19]have been presented a little besides 3D graphic models. Voigt et al.  [17] hide the secret data by modifying the frequency coefficient in the integer discrete cosine transform (DCT) domain according to the embedded bit being 1 or 0. Since this algorithm is realized in the frequency domain, controlling the embedding distortion in the spatial domain seems complex. Besides, the data capacity is not high. In  [18], two reversible data hiding schemes based on the idea of difference expansion  [23] are proposed: one hides data by modifying the differences between adjacent coordinates, and the second by manipulating the Manhattan distances between neighboring vertices. The data capacities of these methods are at most 1 bit/vertex and 0.5 bit/vertex, respectively. The two approaches have good invisibility in maps with dense vertices whereas the performance could be seriously decreased for maps whose coordinates exhibit low correlation. To provide good invisibility, Zhou et al.  [19] offered a reversible data hiding algorithm that embeds secret bits by modifying the difference histogram which is established by the differences of neighboring vertices. The maximum embedding capacity of this method is 1 bit/vertex. Furthermore, to make the difference expansion suitable for 2D CAD engineering graphics with low data correlation, Peng et al. made an improvement in  [40]. By hiding secret bits in the scale factor of the relative coordinates, this approach provides high embedding capacity (at least 1 bit/vertex) and good invisibility. However, because the distance between every two vertices has to be calculated for selecting the reference vertices, the computational complexity may be very high. Another drawback of the aforementioned schemes for 2D vector graphics  [17–19,40] is that they are not robust against content preserving operations such as feature rearrangement and vertex reversing.To embed a large amount of data with insignificant visual distortion of the original vector map in which the coordinates exhibit low correlation, and simultaneously increasing the robustness against content preserving operations, we propose a reversible data hiding method for 2D vector maps based on virtual coordinates. The proposed algorithm is inspired by the reversible data hiding approach by Wang and Wang  [39]. Rather than sorting the coordinates to yield intervals for data embedding, we divide the distance between the maximum coordinate and the minimum coordinate of each axis into segments, calculate two virtual coordinates according to the segment which an eligible coordinate is within, and modify the state value of the interval created by the two virtual coordinates to accommodate secret bits. For achieving robustness against content preserving operations, the vertex traversing order is defined. The advantages of the proposed method include the following: (1) the data capacity can be very large, nearly2c(c≥1) bit/vertex, wherecis the number of secret bits each eligible coordinate carries; (2) the reversibility, invisibility, and computational complexity are good; (3) for polylines and polygons, feature rearrangement and vertex reversing operations can be resisted. The experimental results and analysis will be given to reveal the advantages of the proposed method.The paper is organized as follows. We briefly review the reversible data hiding method by Wang and Wang  [39] and present our improvement based on virtual coordinates in Section  2. In Section  3, we propose our reversible data hiding scheme. Our experimental results and an analysis of the algorithm are provided in Section  4. Finally, conclusions are summarized in Section  5.In this section, we briefly review Wang and Wang’s  [39] scheme in Section  2.1, and describe our improvement based on virtual coordinates in Section  2.2.The basic idea of Wang and Wang’s algorithm  [39] is as follows. Given a list of vertices, the coordinates of each axis are first sorted to produce sorted lists; then every sorted list is divided into intervals, each of which contains three adjacent sorted coordinates. Finally,c(c≥1)secret bits are embedded into an interval by modifying the interval’s state value.The state value of an interval is defined as follows. Supposex1,x2andx3(x1≤x2<x3)are three adjacentxcoordinates in the sortedX-axis. The interval betweenx1andx3can be divided intoP(P≥2)equal subintervals. The index of the subinterval which the coordinatex2is located on indicates the interval’s state value. Since the watermark is embedded by movingx2betweenx1andx3, the watermarkedx2remains within the range[x1,x3). As a result, no watermarked coordinate exceeds the original coordinate range, and all the watermarked vertices are within the original vertex range.Denote the interval which contains the three adjacentxcoordinates (x1,x2andx3) in the sortedX-axis asQ(x1,x2,x3), and the watermark to be embedded asw(0≤w<2c).In the embedding phase, therstate of the intervalQis first calculated,(1){r=0ifx2<(x1+x3)/2r=1ifx2≥(x1+x3)/2.Then, the intervalQis divided into2c+1equal subintervals. The state valuesof the watermarked intervalQ′, i.e., the index of the subinterval which the embedded coordinatex2′should be located on is computed by(2)s=2c×r+w.Finally, the embeddedx2′is obtained by movingx2to thesth subinterval,(3)x2′=x1+s×(x3−x1)/2c+1+κ/2c,where(4)κ=x2−(1−r)×x1−r×(x1+x3)/2.After watermark embedding,x1≤x2′<x3still holds and ifx1<x2<x3holds,x1<x2′<x3will hold. That is, the watermarked coordinates still keep their original sorted order and no watermarked coordinate exceeds the original coordinate range. Besides, assuming the length ofQislQ,x2moves less thanlQ/2for embedding the watermarkw.In the extraction phase, therstate of the watermarked intervalQ′(x1′,x2′,x3′)(x1′≤x2′<x3′), which consists of the three watermarked coordinatesx1′,x2′andx3′, is also first calculated with Eq. (1).Then, each subinterval’s lengthlsis computed according to the embedded intervalQ′,(5)ls=(x3′−x1′)/2c+1.Next, the state valuesof the embedded intervalQ′is calculated,(6)s=⌊(x2′−x1′)/ls⌋.Then, the embedded watermarkwis obtained,(7)w=s−r×2c.Finally, the original coordinatex2is restored,(8)x2″=(1−r)×x1′+r×(x3′+x1′)/2+2c×κ′,where(9)κ′=x2′−x1′−s×(x3′−x1′)/2c+1.The above is Wang and Wang’s approach.In order to improve the data capacity and decrease the computational complexity of Wang and Wang’s algorithm  [39], we create intervals by calculating two neighboring virtual coordinates for every coordinate rather than sorting the coordinates of each axis to yield intervals. To provide good invisibility, we control the embedding distortion by appropriately selecting the length of each interval.We need to point out that in our improved method the minimum and maximum coordinates of each axis do not carry watermarks.Given a list of vertices, we first divide the distance between the maximum and the minimum coordinates of each axis into equal segments. Then, for each coordinate, two neighboring virtual coordinates are calculated according to the segment which the coordinate is within, and an interval is formed by combining the coordinate itself and its two neighboring virtual coordinates. After that, every new formed interval can carry a watermark by modifying its state value.We use theX-axis to illustrate the embedding and extraction processes. SupposeX={xi|i∈[1,n]}is anxcoordinate list composed ofnelements,xminis the minimum coordinate ofXandxmaxis the maximum coordinate ofX.In the embedding stage, we first find the minimum and maximum coordinates ofX(xminandxmax).Then, we divide the distance betweenxminandxmaxintoDx(Dx≥2)equal segments. According to the number of segmentsDx, the length of each segmentltcan be calculated by(10)lt=(xmax−xmin)/Dx.After that, for any coordinatexi(i∈[1,n])ofX, we calculate two neighboring coordinatesxilandxirfor it, and obtain an intervalQi(xil,xi,xir)by combining the coordinatexiand its two calculated neighboring coordinates (xilandxir) according to the indexuxi(0≤uxi≤Dx−1)of the segment whichxiis within,(11){uxi=⌊(xi−xmin)/lt⌋xil=xmin+uxi×ltxir=xmin+(uxi+1)×lt.We regard the neighboring coordinates (xilandxir) ofxiwhich is calculated by Eq. (11) asxi’s two virtual coordinates. As illustrated in Fig. 1, the two virtual coordinates (xilandxir) ofxialso indicate the boundary of theuxith segment. Because the calculated virtual coordinates do not really exist in the coordinate listX, they are illustrated in dark gray.Finally, a watermarkw(0≤w<2c)can be embedded into an interval by modifying its state value with Eqs. (1)–(4). Sincexminandxmaxare used to calculate the two neighboring virtual coordinates for each coordinate, correct calculation of the two virtual coordinates of each coordinate and correct watermark extraction in the data extraction phase may be impossible if they are used to embed watermarks. As a result,xminandxmaxdo not carry watermarks in our method. Therefore, if anxcoordinate e.g.,xi, can be used to carry a watermark, its corresponding intervalQi(xil,xi,xir)should satisfy the following condition,(12){xil≤xi<xirxi≠xminxi≠xmax.We call anxcoordinate that satisfies the above condition an eligible x coordinate. Similarly, assumingymaxandyminare the maximum and the minimum coordinates in theY-axis,yiis aycoordinate, andyilandyirareyi’s two neighboring virtual coordinatess, we callyian eligibleycoordinate if it satisfies that(13){yil≤yi<yiryi≠yminyi≠ymax.In the rest of this paper, we call a coordinate an eligible coordinate if it is an eligible x coordinate or an eligible y coordinate.After watermark embedding, a watermarked coordinate listX′={xi′|i∈[1,n]}is obtained.In the above embedding procedure, an eligible x coordinateximoves less thanlt/2to embed a watermark. That is, the Euclidean distance between a vertex and its watermarked version is less thanle, where(14)le=(lt2)2+(lt2)2=lt2=xmax−xmin2Dx.Therefore, to make sure that the embedding distortion does not exceed the vector map’s precision toleranceτ, we can assign a value toDxso that(15)le≤τ.In other words, to ensure the validity of the map data,Dxshould satisfy the following condition,(16)Dx≥xmax−xmin2τ.As a simple implementation, we assign a value toDxby(17)Dx=⌈xmax−xmin2τ⌉.During watermark extraction, similar steps are followed.First, we find the maximum coordinatexmax′and the minimum coordinatexmin′ofX′.Then, the distance betweenxmin′andxmax′is divided intoDx′(Dx′≥2)equal segments, and the length of each segmentlt′is calculated with Eq. (10).Next, for any watermarked eligiblexcoordinatexi′(i∈[1,n])ofX′, two neighboring virtual coordinatesxil′andxir′are computed according to the indexuxi′(0≤uxi′≤Dx′−1)of the segment whichxi′is located on with Eq. (11), and a watermarked intervalQi′(xil′,xi′,xir′) is formed by combining the coordinatexi′and its two neighboring virtual coordinatesxil′andxir′.Finally, for any watermarked eligible x coordinatexi′ofX′, the embedded watermark is extracted from its corresponding watermarked intervalQi′and the originalxiis restored using Eqs. (1) and (5)–(9). After extracting the embedded watermarks from all the eligiblexcoordinates, the original coordinate listXcan be recovered.According to Eqs. (5)–(9), a watermark is extracted from a watermarked eligiblexcoordinatexi′by calculating the state value of its corresponding embedded intervalQi′, i.e., the index of the subinterval whichxi′is located on. If the calculated state value is not the same as the one used in the embedding stage, the extracted watermark will not be equal to the embedded one. Denote the length of each subinterval calculated with Eq. (5) for theX-axis aslxs′. In general,lxs′is a double-precision number, which gives from 15 to 17 significant decimal digits precision. Oncelxs′is no more than10−15, the calculated state value may be not the same as the original one, and the extracted watermark may be not equal to the embedded one. Hence, to guarantee correct extraction,lxs′should satisfy the following condition(18)lxs′=lt′/2c+1=xmax′−xmin′Dx′×2c+1=xmax′−xmin′⌈xmax′−xmin′2τ⌉×2c+1>10−15.Similarly, assumingymax′andymin′are the maximum and the minimum coordinates in the watermarkedY-axis,Dy′is the number of equal segments into which the distance betweenymax′andymin′is divided, andlys′is the length of each subinterval calculated with Eq. (5) for theY-axis, to guarantee correct extraction,lys′should satisfy the following condition(19)lys′=ymax′−ymin′Dy′×2c+1=ymax′−ymin′⌈ymax′−ymin′2τ⌉×2c+1>10−15.This means that the value ofcshould satisfy that(20)c<cmin,where(21)cmin=min(log2(xmax′−xmin′⌈xmax′−xmin′2τ⌉×10−15)−1,log2(ymax′−ymin′⌈ymax′−ymin′2τ⌉×10−15)−1).Therefore, assuming the number of eligible coordinates isNe, we can get the upper limit of the data capacity of the improved algorithmUcby(22)Uc=Ne×cmin.The above is our improved method. Sincexminandxmaxdo not carry watermarks, no watermarked coordinate exceeds the range(xmin,xmax)after watermark embedding. In the watermark extraction stage,xminandxmaxcan still be correctly identified and the virtual coordinates of each watermarked coordinate can be correctly obtained. Thus, correct extraction of the embedded watermarks and recovery of the original content can be ensured.In this section, the improved reversible data hiding method described in Section  2.2 is implemented in the reversible data hiding algorithm for 2D vector maps.Our proposed scheme is introduced in two stages. First of all, we explain how it prepares the vertices to be watermarked and embeds the secret data. Later, we will introduce how it extracts the secret data and recovers the original content.The data embedding process consists of two basic steps: (i) Vertex preparation and (ii) Data embedding.As we embed the secret data into the vertices one by one, correct data extraction may be impossible once the vertex traversing order has been changed. In order to resist feature rearrangement and vertex reversing attacks, we provide different vertex traversing orders for different types of features.For obtaining the vertex order of polylines, the first vertex and the last vertex of each polyline are sorted. The vertex that has bigger coordinate value is called a start vertex, and the vertex that has smaller coordinate value is called an end vertex. Within each polyline, the vertices are traversed from the start vertex to the end vertex. For obtaining the polyline order, the start vertices of the polylines are sorted, and the polylines are scanned from the polyline that has the biggest start vertex to the polyline that has the smallest start vertex.For polygons, the vertex traversing order is similar to that of polylines except that the start vertex and the end vertex of each polygon are obtained by sorting the second vertex and the penultimate vertex, and within each polygon, the vertices are traversed from the start vertex to the end vertex, to the start vertex.As for points, the vertices are scanned according to the vertex order stored in the vector map file.In our method, the start vertex and the end vertex of each polyline or polygon are used to indicate the vertex order of the polyline or the polygon. Since indicating the vertex order within a polyline or a polygon is very important for the scheme to resist feature rearrangement and vertex reversing attacks, the coordinates of the start vertices and the end vertices should not be used to embed secret bits. This means that for a vector mapM, the coordinates which can be used to embed watermarks should be searched from the eligible coordinates ofVMexcept the coordinates ofVMne, whereVMis the set ofM’s vertices andVMneis the set of the start vertices and the end vertices ofM.Therefore, assumingMminxandMmaxxare the minimum and maximum coordinates in theX-axis, andMminyandMmaxyare the minimum and maximum coordinates in theY-axis, if an eligiblexcoordinatexecan be used to embed a watermark, it should meet the following condition,(23){xe≠Mminxxe≠Mmaxxxe∉VMne.If an eligibleycoordinateyecan be used to carry a watermark, it should meet the following condition,(24){ye≠Mminyye≠Mmaxyye∉VMne.In the following, we call an eligiblexcoordinate a watermarkxcoordinate if it satisfies the condition defined in Eq. (23), an eligibleycoordinate a watermarkycoordinate if it satisfies the condition defined in Eq. (24), a coordinate a watermark coordinate if it is a watermarkxcoordinate or a watermarkycoordinate, and a vertex a watermark vertex if it contains a watermark coordinate. The watermark vertices will be used to carry the secret message in the data embedding stage.Suppose a secret bit streamS={sj|sj∈{0,1},j∈[0,L−1]}of lengthLis the secret data to be embedded into the vector mapM, andNwis the number ofM′s watermark coordinates. To make sure that each watermark coordinate ofMcarries a watermark, we assume thatL=Nw×c.We embed the secret data using the following five steps.Step  1. Convert the secret bit streamSinto a secret data sequenceW={wi|wi∈{0,2c−1},i∈[0,Nw−1]},(25)wi=si×c×2c−1+si×c+1×2c−2+⋯+s(i+1)×c−1×20.Step  2. Scramble the elements ofWunder the control of a private keyK. Denote the scrambled data sequence asWs={wis|wis∈{0,2c−1},i∈[0,Nw−1]}. The scrambling algorithm is briefly described in the Appendix.Step  3. Scan the vertices of the whole vector mapMto get the maximumxcoordinateMmaxx, the minimumxcoordinateMminx, the maximumycoordinateMmaxyand the minimumycoordinateMminy.Step  4. According to the vertex traversing order, scan the vertices ofMand obtain the ordered watermark vertices usingMmaxx,Mminx,MmaxyandMminy.Step  5. EmbedWsinto the watermark coordinates of the ordered watermark vertices by exploiting the method described in Section  2.2.1.After data embedding, an embedded vector mapM′is derived.The process of data extraction and data recovery goes as follows.Step  1. Scan the vertices of the whole vector mapM′to get the maximumxcoordinateMmaxx′, the minimumxcoordinateMminx′, the maximumycoordinateMmaxy′and the minimumycoordinateMminy′.Step  2. Obtain the ordered embedded watermark vertices according to the vertex traversing order defined in Section  3.1.1. Suppose the number of embedded watermark coordinates ofM′isNw′.Step  3. Extract the secret sequenceWs′={wis′|wis′∈{0,2c−1},i∈[0,Nw′−1]}from the watermark coordinates of the ordered embedded watermark vertices and recover the original content ofM′using the method described in Section  2.2.2.Step  4. Descramble the elements ofWs′and obtain the embedded data sequenceW′={wi′|wi′∈{0,2c−1},i∈[0,Nw′−1]}with the private keyK. The descrambling process is presented in the Appendix.Step  5. Convert the data sequenceW′into binary formS′={sj′|sj′∈{0,1},j∈[0,Nw′×c−1]},(26)sj′=⌊w⌊j/c⌋′−∑m=⌊j/c⌋×cj−1sm′×2c−(mmodc)−12c−(jmodc)−1⌋.The above is our reversible data hiding scheme for 2D vector maps.

@&#CONCLUSIONS@&#
In this paper, we present a high capacity reversible data hiding method based on virtual coordinates. The basic concept of the proposed algorithm is Wang and Wang’s reversible data hiding scheme  [39]. To embed large amounts of data with insignificant visual distortion of the original vector map, and simultaneously decreasing the computational complexity, the method based on virtual coordinates is presented. In addition, for tolerating content preserving operations, the vertex traversing order is defined. The data capacity achieves nearly2cbits/vertex. The experimental results and analysis indicate that the proposed approach has good performances in reversibility, invisibility, data capacity and computational complexity and is robust against feature rearrangement and vertex reversing operations for polylines and polygons.Meanwhile, the proposed scheme offers a significant advantage over other reversible data hiding methods in that no embedded coordinate exceeds the original coordinate range, i.e., it can be integrated with block-based fragile watermarks for authentication.In this paper, the improved reversible data hiding method was described as applied to 2D vector maps in shapefile format. This method can also be applied to other kinds of 2D vector graphics (e.g., 2D vector map in MapInfo TAB format and CAD drawings in DXF format) and 3D vector graphics (e.g., point-sampled geometry) which have similar data structures as 2D vector maps for achieving high capacity and low distortion.There are two main drawbacks in our scheme. First, the robustness of this algorithm is still very weak. Second, the topological relations between features are not considered during data hiding. Our future research will focus on enhancing the robustness of the scheme to support some other applications where higher robustness is required, and increasing the convenience of keeping the topological relations between features.Here, we describe the scrambling process used in Section  3.1.2 and its corresponding descrambling process exploited in Section  3.2.In Section  3.1.2, the secret data sequenceW={wi|wi∈{0,2c−1},i∈[0,Nw−1]}is scrambled under the control of the private keyKby the following four steps.Step  1. Generate an integer sequenceP={pi|i∈[0,Nw−1]},(29)pi=i.Step  2. Generate a random sequenceR={ri|i∈[0,Nw−1]}under the control of the private keyK.Step  3. Shuffle the elements ofPby swappingpj(j∈[1,Nw−1])andprjmod(j+1). Denote the shuffledPasP′={pi′|i∈[0,Nw−1]}.Step  4. According toP′, adjust the order ofW’s elements and obtain the scrambled sequenceWs={wis|wis∈{0,2c−1},i∈[0,Nw−1]}by(30)wis=wpi′.In Section  3.2, we can descramble the extracted secret sequenceWs′={wis′|wis′∈{0,2c−1},i∈[0,Nw′−1]}with the private keyKby the following:Step  1. According to the private keyKand the number ofWs′’s elementsNw′, get the shuffled random integer sequenceP″={pi″|i∈[0,Nw′−1]}using Steps  1–3 described in the scrambling process.Step  2. According toP″, adjust the order ofWs′’s elements and obtain the descrambled sequenceW′={wi′|wi∈{0,2c−1},i∈[0,Nw′−1]}by the following equation(31)wpi″′=wis′.The above is the scrambling algorithm we used in the data embedding and extraction processes.