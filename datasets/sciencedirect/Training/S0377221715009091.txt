@&#MAIN-TITLE@&#
An enhanced branch-and-bound algorithm for the talent scheduling problem

@&#HIGHLIGHTS@&#
The talent scheduling problem is formulated as an IP model.An enhanced B&B algorithm is proposed for the problem.We employ a novel lower bound and memoization technique in the B&B.Two new dominance rules are employed to reduce the search space.Our algorithm outperforms the existing best approach.

@&#KEYPHRASES@&#
scheduling,Talent scheduling,Branch-and-bound,Dynamic programming,Dominance rules,

@&#ABSTRACT@&#
The talent scheduling problem is a simplified version of the real-world film shooting problem, which aims to determine a shooting sequence so as to minimize the total cost of the actors involved. In this article, we first formulate the problem as an integer linear programming model. Next, we devise a branch-and-bound algorithm to solve the problem. The branch-and-bound algorithm is enhanced by several accelerating techniques, including preprocessing, dominance rules and caching search states. Extensive experiments over two sets of benchmark instances suggest that our algorithm is superior to the current best exact algorithm. Finally, the impacts of different parameter settings, algorithm components and instance generation distributions are disclosed by some additional experiments.

@&#INTRODUCTION@&#
The scenes of a film are not generally shot in the same sequence as they appear in the final version. Finding an optimal sequence in which the scenes are shot motivates the investigation of the talent scheduling problem, which is formally described as follows. LetS={s1,s2,…,sn}be a set of n scenes andA={a1,a2,…,am}be a set of m actors. All scenes are assumed to be shot on a given location. Each scene sj∈ S requires a subset a(sj) ⊆ A of actors and has a duration d(sj) that commonly consists of one or several days. Each actor aiis required by a subset s(ai)⊆S of scenes. We denote by Π the permutation set of the n scenes and define ei(π) (respectively, li(π)) as the earliest day (respectively, the latest day) in which actor i is required to be present on location in the permutation π ∈ Π. Each actor ai∈ A has a daily wage c(ai) and is paid for each day from ei(π) to li(π) regardless of whether he (or she) is required in the scenes. The objective of the talent scheduling problem is to find a shooting sequence (i.e., a permutation π ∈ Π) of all scenes that minimizes the total paid wages.Table 1presents an example of the talent scheduling problem, which is reproduced from de la Banda, Stuckey, and Chu (2011). The information of a(sj) and s(ai) is determined by the m × n matrix M shown in Table 1(a), where cell Mi, jis filled with an “X” if actor aiparticipates in scene sjand with a “ · ” otherwise. Obviously, we can obtain a(sj) and s(ai) bya(sj)={ai|Mi,j=X}ands(ai)={sj|Mi,j=X},respectively. The last row gives the duration of each scene and the rightmost column gives the daily cost of each actor. If the shooting sequence isπ={s1,s2,s3,s4,s5,s6,s7,s8,s9,s10,s11,s12},we can get a matrix M(π) shown in Table 1(b), where in cell Mi, j(π) a sign “X” indicates that actor aiparticipates in scene sjand a sign “–” indicates that actor aiis waiting at the filming location. The cost of each scene is presented in the second-to-last row and the total cost is 604. The cost incurred by the waiting status of the actors is called holding cost, which is shown in the last row of Table 1(b). The optimal solution of this instance isπ*={s5,s2,s7,s1,s6,s8,s4,s9,s3,s11,s10,s12}whose total cost and holding cost are 434 and 53, respectively.The talent scheduling problem was originated from Adelson, Norman, and Laporte (1976) and Cheng, Diamond, and Lin (1993). Adelson et al. (1976) introduced an orchestra rehearsal scheduling problem, which can be viewed as a restricted version of the talent scheduling problem with all actors having the same daily wage. They proposed a simple dynamic programming algorithm to solve their problem. Cheng et al. (1993) studied a film scheduling problem in which all scenes have identical duration. They first showed that the problem is NP-hard even if each actor is required by two scenes and the daily wage of each actor is one. Next, they devised a branch-and-bound algorithm and a simple greedy hill climbing heuristic to solve their problem. Later, Smith (2003) applied constraint programming to solve both the problems introduced by Adelson et al. (1976) and Cheng et al. (1993). In her subsequent work, namely Smith (2005), she accelerated her constraint programming approach by caching search states.The talent scheduling problem we study in this article was first formally described by de la Banda et al. (2011). This problem is a generalization of the problems introduced by Adelson et al. (1976) and Cheng et al. (1993), where scenes may have different durations and actors may have different wages. However, it is a simplified version of the movie shoot scheduling problem (MSSP) introduced by Bomsdorf and Derigs (2008). In the MSSP, we need to deal with a couple of practical constraints, such as the precedence relations among scenes, the time windows of each scene, the resource availability, and the working time windows of actors and other film crew members. Recently, Liang, Zhang, Qin, Guo, and Lim (2014) proposed a branch-and-bound algorithm to solve the talent scheduling problem and achieved better results than de la Banda et al. (2011).In literature, there exist several meta-heuristics developed for the problem introduced by Cheng et al. (1993). Nordström and Tufekci (1994) provided several hybrid genetic algorithms for this problem and showed that their algorithms outperform the heuristic approach in Cheng et al. (1993) in terms of both solution quality and computation speed. Fink and Voß (1999) treated this problem as a special application of the general pattern sequencing problem, and implemented a simulated annealing algorithm and several tabu search heuristics to solve it.The talent scheduling problem is a very challenging combinatorial optimization problem. The current best exact approach by de la Banda et al. (2011) can only optimally solve small- and medium-size instances. In this paper, we propose an enhanced branch-and-bound algorithm for the talent scheduling problem, which uses the following two main techniques:•Dominance rules. When a partial solution represented by a node in the search tree can be dominated by another partial solution, this node need not be further explored and can be safely discarded.Caching search states. The talent scheduling problem can be solved by dynamic programming algorithm (see de la Banda et al. (2011)). It is beneficial to incorporate the dynamic programming states into the branch-and-bound framework by a memoization technique. In the branch-and-bound tree, each node is related to a dynamic programming state. If the search process explores a certain node whose already confirmed cost is not smaller than the value of its corresponding cached state, this node can be pruned.There are three main contributions in this paper. Firstly, we formulate the talent scheduling problem as a mixed integer linear programming model so that commercial mathematical programming solvers can be applied to the problem. Secondly, we propose an enhanced branch-and-bound algorithm whose novelties include a new lower bound, caching search states and two problem-specific dominance rules. Thirdly, we achieved the optimal solutions for more benchmark instances by our algorithm. The experimental results show that our branch-and-bound algorithm is superior to the current best exact approach by de la Banda et al. (2011).The remainder of this paper is organized as follows. In Section 2, we present the mixed integer linear programming model for the talent scheduling problem. Next, we describe our branch-and-bound algorithm in Section 3, including the details on a double-ended search strategy, the computation of the lower bound, a preprocessing step, the state caching process and the dominance rules. The computational results are reported in Section 4, where we used our algorithm to solve over 200,000 benchmark instances. Finally, we conclude our study in Section 5 with some closing remarks.The talent scheduling problem is essentially a permutation problem. It tries to find a permutation (i.e., a schedule)π=(π(1),…,π(n))∈Π,where π(k) is the kth scene in permutation π, such that the total cost C(π) is minimized. The value of C(π) is computed as:C(π)=∑i=1mc(ai)×(li(π)−ei(π)+1)We set the parametermi,j=1ifMi,j=Xandmi,j=0otherwise. The total holding cost can be easily derived as:H(π)=∑i=1mc(ai)×(li(π)−ei(π)+1−∑j=1nmi,jd(sj))Apparently, for this problem minimizing the total cost is equivalent to minimizing the total holding cost (de la Banda et al., 2011).We create two dummy scenes s0 andsn+1to represent the first and the last scenes to be shot, namely,π(0)=s0andπ(n+1)=sn+1. The starting days for shooting s0 andsn+1are equal to zero and∑j=1nd(sj)+1,respectively. The durations of s0 andsn+1are both equal to zero. The talent scheduling problem can be formulated into an integer linear programming model using the following decision variables:xk, j: a binary variable that equals 1 if scene sjis scheduled immediately after scene sk, and 0 otherwise.tj: the starting day for shooting scene sj.ei: the earliest shooting day that requires actor ai.li: the latest shooting day that requires actor ai.The integer programming model is given by:(1)(IP)min∑i=1mc(ai)(li−ei+1)(2)s.t.∑j=1nx0,j=1(3)∑k=1nxk,n+1=1(4)∑j=1,k≠jn+1xk,j=1,∀1≤k≤n(5)∑k=0,k≠jnxk,j=1,∀1≤j≤n(6)∑j=1,k≠jntjxk,j=tk+d(sk),∀0≤k≤n(7)t0=0,tn+1=∑j=1nd(sj)+1(8)ei≤tj,∀1≤i≤m,1≤j≤n,mi,j=1(9)tj+d(sj)−1≤li,∀1≤i≤m,1≤j≤n,mi,j=1(10)xk,j∈{0,1},∀0≤k≤n,1≤j≤n+1(11)ei,li,tj≥0andinteger,∀1≤i≤m,0≤j≤n+1The objective (1) is to minimize the total cost, whereli−ei+1is the number of days in which actor aiis present on location. Constraints (2) and (3) ensure that the first and the last scenes are s0 andsn+1,respectively. Constraints (4) and (5) guarantee that every scene has exactly one immediate successor and one immediate predecessor, respectively. Constraints (6) state that the starting day of scene sjis determined by the starting day of its predecessor scene sk. Moreover, these constraints prevent sub-tours from occurring. Constraints (8) and (9) ensure that the earliest and the latest shooting days that require actor aiare determined by the starting days of scenes in which he (or she) is involved.Observe that Constraints (6) are nonlinear. To linearize them, we introduce a set of additional variables zk, j(0 ≤ k ≤ n, 1 ≤ j ≤ n, k ≠ j), and setzk,j=tjxk,j. We know thatzk,j=tjifxk,j=1andzk,j=0otherwise. Thus, zk, jcan be restricted by the following four linear constraints:(12)zk,j≥0(13)zk,j≤tj(14)zk,j≥tj+L(xk,j−1)(15)zk,j≤Lxk,jwhere L is a sufficiently large positive number. Accordingly, Constraints (6) can be rewritten as:(16)∑j=1,k≠jnzk,j=tk+d(sk),∀0≤k≤nThe objective (1) and Constraints (2)–(5), (7)–(16) constitute an integer linear programming model (ILP) for the talent scheduling problem. This ILP is quite difficult to be optimally solved by commercial integer programming solvers, e.g., ILOG CPLEX. Preliminary experiments revealed that only very small-scale instances, e.g.,n=10andm=5,can be optimally solved by CPLEX 12.1. This is mainly because the linear relaxation of the ILP model cannot provide a high-quality lower bound for the problem.Branch-and-bound is a general technique for optimally solving various combinatorial optimization problems. The basic idea of the branch-and-bound algorithm is to systematically and implicitly enumerate all candidate solutions, where large subsets of fruitless candidates are discarded by using upper and lower bounds, and dominance rules. In this section, we describe the main components of our proposed branch-and-bound algorithm, including a double-ended search strategy, a novel lower bound, the preprocessing stage, the state caching strategy and two dominance rules. For the rest of this discussion, we choose minimizing the total holding cost as the objective of the talent scheduling problem.The solutions of the talent scheduling problem can be easily presented in a branch-and-bound search tree. Suppose we aim to find an optimal permutation π*=(π*(1),π*(2),…,π*(n)). A typical branch-and-bound process first determines the first k scenes to be shot, denoted by a partial permutation(π^(1),…,π^(k)),at level k of the search tree. Then, it generatesn−kbranches, each trying to explore a node by assigning a scene toπ(k+1). At some tree node at levelk+1,there is a known partial permutation(π^(1),π^(2),…,π^(k+1))and a set ofn−k−1unscheduled scenes. If the lower bound LB to the value of the solutions that contain the partial permutation(π^(1),π^(2),…,π^(k+1))is not less than the current best solution value (i.e., an upper bound UB), then the branch to the node associated withπ^(k+1)can be safely discarded. Once the search process reaches a node at level n of the tree, a feasible solution is obtained and the current best solution may be updated accordingly.The above search methodology can be called the single-ended search strategy. As did by Cheng et al. (1993) and de la Banda et al. (2011), we can employ a double-ended search strategy that alternatively fixes the first and the last undetermined positions in the permutation. That is to say, the double-ended search determines a scene permutation following the orderπ(1),π(n),π(2),π(n−1)and so on. When using the double-ended search strategy, a node in some level of the search tree corresponds to a partially determined permutation with the form(π^(1),…,π^(k−1),π(k),…,π(l),π^(l+1),…,π^(n)),where 1 ≤ k ≤ l ≤ n and the value of π(h) (k ≤ h ≤ l) is undetermined. We denote by B the set of scenes scheduled at the beginning of the permutation, namelyB={π^(1),π^(2),…,π^(k−1)},and by E the set of scenes scheduled at the end, namelyE={π^(l+1),π^(l+2),…,π^(n)}. The remaining scenes are put in a set Q, namelyQ=S−B−E. Moreover, for convenience, we denote byB→andE→the partially determined scene sequences at the beginning and at the end of a permutation, i.e.,B→=(π^(1),…,π^(k−1))andE→=(π^(l+1),…,π^(n)).The double-ended search strategy is beneficial to solving the talent scheduling problem. As pointed out by de la Banda et al. (2011), more accurate lower bounds can be obtained by increasing the number of fixed actors. The actor required by the scenes in both B and E is labeled fixed since the total number of his/her on-location days is fixed and his/her cost in the final schedule already becomes known (Cheng et al., 1993). We do not need to consider any fixed actor in the later stages of the search process, which certainly reduces the size of the problem. Leta(Q)=∪s∈Qa(s)be the set of actors required by at least one scene in Q⊆S. The set of all fixed actors can be defined byF=a(B)∩a(E).A generic double-ended branch-and-bound framework is given in Algorithm 1. The operator “○” in lines 3, 11 and 15 indicates concatenating two partially determined scene sequences. The functionsearch(B→,Q,E→)returns the optimal solution to the talent scheduling problem with knownB→andE→; we denote this problem byP(B→,Q,E→). The optimal solution of the talent scheduling problem can be achieved by invokingsearch(B→,Q,E→) withB=E=∅andQ=S. The function evaluate(solution) returns the objective value of solution. The functionlower_bound(B→∘s,Q−{s},E→)provides a valid lower bound to problemP(B→∘s,Q−{s},E→),where the set B of scenes is scheduled before scene s and the setS−B−{s}of scenes is scheduled after scene s. If the lower bound (LB) at some branch-and-bound tree node is greater than the upper bound (UB), we discard this node (see lines 12–14, Algorithm 1). Note that UB is a global variable. The branch-and-bound search tries to schedule each remaining scene s immediately afterB→,and then swaps the roles ofB→andE→to continue building the search tree (see line 15, Algorithm 1). Note that we useR(B→)to denote the reverse sequence ofB→. For example, ifP(B→,Q,E→)=P((1,2),{3,4},(5,6)),thenP(R(E→),Q,R(B→))=P((6,5),{3,4},(2,1)).The problemP(B→,Q,E→)corresponds to a node in the search tree. Its lower boundlower_bound(B→,Q,E→)can be expressed as:lower_bound(B→,Q,E→)=cost(B→,E→)+lower(B,Q,E),wherecost(B→,E→),called past cost, is the cost incurred by the path from the root node to the current node, andlower(B,Q,E)provides a lower bound to future cost, i.e., the holding cost to be incurred by scheduling the scenes in Q. We discuss the past costcost(B→,E→)in this section and leave the description oflower(B,Q,E)in Section 3.4.WhenB→andE→have been fixed, a portion of holding cost, namelycost(B→,E→),is determined regardless of the schedule of the scenes in Q. The past costcost(B→,E→)is incurred by the holding days that can be confirmed by the following three ways:1.For the actor ai∈ a(B) ∩ a(E), the number of his/her holding days in any complete schedule can be fixed (Cheng et al., 1993).For the actorai∈a(B)∩a(Q)−a(E),the number of his/her holding days in the time period for completing scenes in B can be fixed.For the actorai∈a(E)∩a(Q)−a(B),the number of his/her holding days in the time period for completing scenes in E can be fixed.Furthermore, we use cost(s, B, E) to represent the newly confirmed holding cost incurred by placing scene s ∈ Q at the first unscheduled position, namely the position after any scene in B and before any scene inS−B−{s}. Note that cost(s, B, E) is irrelevant to the orders of scenes in B and E. Obviously, we havecost(B→∘{s},E→)=cost(B→,E→)+cost(s,B,E),which implies that the past cost of a tree node is the sum of the past cost of its father node and the newly confirmed holding cost incurred by branching. As a result, the lower bound function can be rewritten as:lower_bound(B→∘s,Q−{s},E→)=cost(B→,E→)+cost(s,B,E)+lower(B∪{s},Q−{s},E).The value of cost(s, B, E) is incurred by the following two types of actors:Type 1. If actor aiis included in neither a(B) ∩ a(E) nor a(s) but is still present on location during the days of shooting scene s (i.e., ai∉ a(B) ∩ a(E), ai∉ a(s) andai∈a(B)∩a(Q−{s})), he/she must be held during the shooting days of scene s.Type 2. If actor aiis not included in a(B) ∩ a(E) but is included in a(E), and scene s is his/her first involved scene (i.e., ai∉ a(B) and ai∈ a(s) and ai∈ a(E)), the shooting days of those scenes inQ−{s}that do not require actor aican be confirmed as his/her holding days.To demonstrate the computation ofcost(B→,E→)and cost(s, B, E), let us consider a partial schedule presented in Table 2, whereB→=(s1,s2),E→=(s5,s6)andQ=S−B−E={s3,s4}. In the columns “cost(B→,E→)”, “cost(s3, B, E)” and “cost(s4, B, E)”, we present the corresponding holding cost associated with each actor. For example, the value ofcost(B→,E→)can be obtained by summing up the values in all cells of the column “cost(B→,E→)”. Since actor a1 is a fixed actor, his/her holding cost must bec(a1)(d(s2)+d(s4))no matter how the scenes in Q are scheduled. Actor a2 is involved in B and Q but is not involved in E, so we can only say that the holding cost of this actor is at least c(a2)d(s2). Similarly, actor a3 has an already incurred holding cost c(a3)d(s5). For actors a4 and a5, we cannot get any clue on their holding costs from this partial schedule and thus we say their already confirmed holding costs are both zero. Suppose scene s4 is placed at the first unscheduled position. Since actors a2 and a4 must be present on location during the period of shooting scene s4, the newly confirmed holding cost iscost(s4,B,E)=(c(a2)+c(a4))d(s4). If we suppose scene s3 is placed at the first unscheduled position, the newly confirmed holding cost is only related to actor a3, namely,cost(s3,B,E)=c(a3)d(s4).Defineo(Q)=a(S−Q)∩a(Q)as the set of actors required by scenes in both Q andS−Q(de la Banda et al., 2011). Then, cost(s, B, E) can be mathematically computed by:(17)cost(s,B,E)=d(s)×c(o(B)−o(E)−a(s))+∑s′∈Q−{s}d(s′)×(c((a(s)−o(B))∩o(E))−c((a(s)−o(B))∩o(E)∩a(s′))),where c(G) is the total daily cost of all actors in G⊆A, i.e.,c(G)=∑a∈Gc(a).We use Table 3 to explain Expression (17). All actors can be classified into 16 patterns according to whether they are required by the scenes in sets B, {s},Q−{s}and E. If an actor is required by at least one scene in some set, the corresponding cell in columns 2–5 is filled with a sign “X”; otherwise it is filled with a sign “ · ”. In columns 6–12, if an actor is included in some actor set, the corresponding cell is filled with “1”; otherwise, it is filled with “0”. For example, for pattern 2 actors that has(B,{s},Q−{s},E)=(·,X,X,X),we can derive that all actors of this pattern must be included in setso(E),a(s),a(s)−o(B)and(a(s)−o(B))∩o(E)and cannot exist in sets o(B),o(B)−o(E)ando(B)−o(E)−a(s).From Table 3, we can observe that seto(B)−o(E)−a(s)only contains type 1 actors that have pattern(B,{s},Q−{s},E)=(X,·,X,·). Thus, the first component of Expression (17) corresponds to type 1 actors. Set(a(s)−o(B))∩o(E)contains type 2 actors that have either pattern(B,{s},Q−{s},E)=(·,X,X,X)or pattern(B,{s},Q−{s},E)=(·,X,·,X). The second component of Expression (17) is the holding cost of type 2 actors during the shooting days for the scenes inQ−{s}.The holding costs of all fixed actors will not change in the later stages of the search. We use set ANto contain all non-fixed actors, namelyAN={ai∈A:ai∉a(B)∩a(E)}. When solving problemP(B→,Q,E→),we only need to consider the actors in AN. As did by de la Banda et al. (2011), the problemP(B→,Q,E→)can be further simplified as:•We remove from ANall actors that are required by only one scene. This is because such actors will not bring about extra holding cost.We exclude from ANall non-fixed actors that are not required by the scenes in Q.If scenes s1 and s2 satisfya(s1)∩AN=a(s2)∩AN,then we replace them with a single scene with durationd(s)=d(s1)+d(s2)since they can be regarded as duplicate scenes. The correctness of merging duplicate scenes has been proved by de la Banda et al. (2011).The example shown in Table 4illustrates the preprocessing steps. In the problem given by Table 4(a), actor a4 is fixed and actor a5 is not required by the scenes inQ={s1,s2,s3,s4}. Therefore, we can remove actors a4 and a5 to makeAN={a1,a2,a3}. Now sincea(s2)∩AN=a(s3)∩AN={a1,a2,a3},we can merge scenes s2 and s3. After these preprocessing steps, we get a simplified problem as shown in Table 4(b), wheres2′is the scene created by merging scenes s2 and s3.In de la Banda et al. (2011), the authors proposed a lower bound to the future cost. They generated two lower bounds using (o(B)−F,Q) and (o(E)−F,Q) as input information, and claimed that the sum of these two lower bounds is still a lower bound (denoted by L0) to the future cost. The reader is encouraged to refer to de la Banda et al. (2011) for the details of this lower bound.In this section, we present a new implementation of lower(B, Q, E). Suppose σ is an arbitrary permutation of the scenes in Q. We define xias the holding cost of actor aiduring the period of shooting the scenes in Q with the order specified by permutation σ. If lower(B, Q, E) =minσ{∑i∈ANxi},we get the minimum possible future cost. However, it is impossible to get the value ofminσ{∑i∈ANxi}unless all σ are checked. Instead, we propose a method to produce a lower bound tominσ{∑i∈ANxi}.If an actor aisatisfies ai∉ a(B), ai∉ a(E) and ai∈ a(Q), the lowest possible holding cost of this actor during the period of shooting the scenes in Q may be zero. Therefore, we only consider the actors in setAN′=(o(B)−F)∪(o(E)−F)⊆AN. For any two different actorsai,aj∈AN′,we can derive a constraintxi+xj≥ci,j,where ci, jis a constant computed based on the following four cases:Case 1:ai,aj∈o(B)−F. Letai(s)=“X” if actor aiis required by scene s andai(s)=“ · ” otherwise. For any scene s ∈ Q, the tuple (ai(s), aj(s)) must have one of the following four patterns: (X, X), (X, · ), ( ·, X), ( ·, · ). First, we schedule all scenes with pattern (X, X) immediately after the scenes in B and schedule all scenes with pattern ( ·, ·) immediately before the scenes in E. Second, we group the scenes with (X, · ) and the scenes with ( ·, X) into two sets. Third, we schedule these two set of scenes in the middle of the permutation, creating two schedules as shown in Table 5. If only actors aiand ajare considered, the optimal schedule must be either one of these two schedules. The value of ci, jis set to the holding cost of the optimal schedule related to only actors aiand aj. For the schedule in Table 5(a), if we defineS1={s∈Q|(ai(s),aj(s))=(X,·)},then the holding cost is c(aj) × d(S1), whered(S1)=∑s∈S1d(s). Similarly, for the schedule in Table 5(b), we have a holding cost c(ai) × d(S2), whereS2={s∈Q|(ai(s),aj(s))=(·,X)}. Accordingly, we setci,j=min{c(aj)×d(S1),c(ai)×d(S2)}.Case 2:ai,aj∈o(E)−F. We schedule all scenes with pattern (X, X) immediately before the scenes in E and schedule all scenes with pattern ( ·, ·) immediately after the scenes in B. The remaining analysis is similar to that in Case 1.Case 3:ai∈o(B)−Fandaj∈o(E)−F. We schedule all scenes with pattern (X, · ) immediately after the scenes in B and schedule all scenes with pattern ( ·, X) immediately before the scenes in E. If there does not exist a scene with pattern (X, X), the holding cost may be zero and thus ci, jis set to zero; otherwise ci, jis set to min {c(ai), c(aj)} × d(S0), whereS0={s∈Q|(ai(s),aj(s))=( ·, · ) }, which can be observed from Table 6.Case 4:ai∈o(E)−Fandaj∈o(B)−F. This case is the same as Case 3.A valid lower bound to the future cost (i.e., the value of lower(B, Q, E)) can be obtained by solving the following linear programming model:(18)(LB)zLB=min∑ai∈AN′xi(19)s.t.xi+xj≥ci,j,∀ai,aj∈AN′,i≠j(20)xi≥0,∀ai∈AN′The value of zLBmust be a valid lower bound tominσ{∑i∈ANxi}. If the daily holding cost of actor aiis an integral number, decision variable xishould be integer. When all variables xiare integers, the model (LB) is an NP-hard problem since it can be easily reduced to the minimum vertex cover problem (Karp, 1972). If all variables xiare treated as real numbers, this model can be solved by a liner programming solver. For some instances, the (LB) model needs to be solved a very large number of times. To save computation time, we apply the following two heuristic approaches to rapidly produce two lower bounds, i.e., L1 and L2, to zLB. Obviously, L1 and L2 are also valid lower bounds to the future cost.Approach 1: Sum up the left-hand-side and righ-hand-side of Eq. (19), generating(|AN′|−1)∑ai∈AN′xi≥∑ai,aj∈AN′,i≠jci,j. The valid lower bound L1 is defined as:L1=∑ai,aj∈AN′,i≠jci,j/(|AN′|−1).Approach 2: Sort ci, jin descending order. If we select a ci, j, we call the corresponding xiand xj marked. Beginning from the largest ci, j, we select all ci, jwhose xiand xjare not marked until all xiare marked. The valid lower bound L2 equals the sum of all selected ci, j. This approach was termed the greedy matching algorithm (Drake & Hougardy, 2003). To demonstrate the process of computing L2, we consider the following six constraints:x1+x2≥2,x1+x3≥7,x1+x4≥6,x2+x3≥12,x2+x4≥8,x3+x4≥5.We first selectc2,3=12and mark x2 and x3. Then, we can only selectc1,4=6since x1 and x4 have not been marked. Now all xiare marked and the value of L2 equals 18.In our algorithm, we set lower(B, Q, E) = max {L0, L1, L2}.In de la Banda et al. (2011), the talent scheduling problem was solved by a double-ended dynamic programming (DP) algorithm, where a DP state is represented by ⟨B, E⟩. The DP algorithm stores the best value of each examined state, denoted by 〈B, E〉.value, which equals the minimum past cost of all search paths associated with sets B and E.We embed this DP process in our branch-and-bound framework by use of memoization technique (Michie, 1968). More precisely, when the search process reaches a tree nodeP(B→,Q,E→),it first checks whether the value ofcost(B→,E→)is less than the current 〈B, E〉.value. If so, it updates 〈B, E〉.value bycost(B→,E→); otherwise, the current node must be dominated by some node and therefore can be safely discarded.A better state representation for the DP algorithm is ⟨o(B), o(E), Q⟩, whereQ=S−B−E; this was discussed by de la Banda et al. (2011) as follows. The cost of scheduling the scenes inQ=S−B−Edepends on o(B) and o(E) rather than B and E. SupposeB→Q→E→andB′→Q→E′→are two permutations of S, where B, Q, E, B′ and E′ are the corresponding sets of scenes. Ifo(B)=o(B′)ando(E)=o(E′),then the holding costs incurred byQ→in these two permutations are equal. Moreover, if there are two states ⟨o(B), o(E), Q⟩ and ⟨o(B′), o(E′), Q⟩ that haveo(B)=o(E′)ando(E)=o(B′),they are equivalent due to the symmetric property of the problem. Thus, we only need to memoize the state ⟨o(B), o(E), Q⟩ that satisfies o(B) ≤ o(E). We compare o(B) with o(E) based on the lexicographical order of the actor indices. For example, giveno(B)={a1,a2,a4,a5}ando(E)={a1,a3,a6,a7},we have o(B) ≤ o(E) since the index of a2 is less than that of a3.We also use the memoization technique to prune the search tree node. The process of checking whether a given node associated with problemP(B→,Q,E→)can be pruned is depicted in Algorithm 2. All states are stored in a hash table hashTable. This algorithm first designates a storage slot in the hash table for state ⟨o(B), o(E), Q⟩ using function hash(o(B), o(E), Q). This hash function is used to map the search key to an index; the index gives the place in the hash table where the corresponding record should be stored. First, we transform our state to a search key. Let us consider an example with four actors and five scenes. If(o(B),o(E),Q)=({1,3,4},{2,4},{1,2,3,4}),its binary code (i.e., search key) is 1011010111110, where {1, 3, 4}, {2, 4} and {1, 2, 3, 4} correspond to 1011, 0101 and 11110, respectively. Note that o(B) and o(E) are two sets of actors and Q is a set of scenes. Second, we get the corresponding decimal number of the binary code. Third, we calculate “the decimal number mod C”, where C is the number of storage slots, to obtain the index of the storage space. In each storage space, a value is stored.If the storage slot contains the state and the current value of the state is less than or equal tocost(B→,E→),the algorithm returns true, implying that the given node can be pruned (see lines 4–5, Algorithm 2). Next, it checks whether the state〈o(B),o(E),Q−{s}〉(s ∈ Q) exists in the hash table and has a value less than or equal tocost(B→,E→)(see lines 7–12, Algorithm 2). If such state exists, the given node can also be pruned. The correctness of this pruning condition is guaranteed by Property 1, which was derived from the second theorem in de la Banda et al. (2011).Property 1SupposeB→Q→E→andB′→Q′→E′→are two permutations of S, where B, Q, E, B′, Q′ and E′ are the corresponding sets of scenes. Ifo(B)=o(B′),o(E)=o(E′),Q⊆Q′ and the scenes inQ→follow the order in which they appear inQ′→,then the holding cost incurred byQ→is not greater than that incurred byQ′→.Ideally, the hash function should assign each state to a unique storage slot, i.e., no hash collisions happen. However, this ideal situation is rarely achievable due to the huge number of states and the inadequate storage space. When solving the talent scheduling problem, we do not have sufficient storage space to store the exponential number of search states and therefore different states may be assigned by the hash function to the same storage slot, leading to hash collisions. To resolve this issue, we employ a mechanism called direct mapped caching scheme. Assume the direct mapped cache consists of C slots, each of which can only store one item. If an item is to be stored in a slot that already contains another item (i.e., a hash collision occurs), it may either replace the existing item or be discarded, which is decided by function replace(index, pc). Several previous articles, such as Hilden (1976) and Pugh (1988), have discussed the replacement strategies implemented in replace(index, pc). In this work, we tried latest and greedy caching strategies. The first strategy deals with the hash collisions by simply overwriting the cache slot while the second one stores in the cache slot the item that has smaller value. If we choose the latest caching strategy, replace(index, pc) always returns true. If the greedy caching strategy is selected and the new state has a value less than that of the existing state, replace(index, pc) returns true.The direct mapped caching scheme can effectively prune the search nodes using limited storage space. When a state is revisited again but it has been removed from the cache during the previous stages, the search can still continue to explore its corresponding subtree. In Section 4, we experimentally analyze the impact of different values of C and the two replacement strategies on the performance of our branch-and-bound algorithm.Dominance rules were widely used in branch-and-bound algorithms (Braune, Zäpfel, & Affenzeller, 2012; Kellegöz & Toklu, 2012; Ranjbar, Davari, & Leus, 2012; Zhang, Qin, Zhu, & Lim, 2012) and dynamic programming algorithms (Dumas, Desrosiers, Gelinas, & Solomon, 1995; Mingozzi, Bianco, & Ricciardelli, 1997; Rong & Figueira, 2013) for eliminating search states. The purpose of dominance rules is to identify the partial solution represented by a node in the search tree that is dominated by another partial solution. The dominated partial solution need not be further explored and can be safely pruned. In our branch-and-bound algorithm, two new dominance rules are introduced to reduce the search space.At a branch-and-bound tree node associated with problemP(B→,Q,E→),we suppose that scene s1 is the scene to be scheduled immediately after B and scene s2 belongs toQ−{s1}. If a(s1) ∪ o(B) ⊇ a(s2) ∪ o(B) and a(s1) ∪ o(E) ⊆ a(s2) ∪ o(E), then the branch associated with scene s1 can be ignored.Tables 7and 8are used to explain this dominance rule. In Table 7,Q={s1,s2}∪Ω1∪Ω2,where Ω1 and Ω2 are two arbitrary subsets ofQ−{s1,s2}andΩ1∩Ω2=∅. Actors in ANcan be classified into twelve patterns according to whether they are required by the scenes in sets B, E, {s1} and {s2}. Since we do not need the information related to Ω1 and Ω2, all cells in columns 4 and 6 remain empty. Similar to Table 3, the numbers 1 and 0 in the right part of Table 7 indicate whether an actor is included in the corresponding actor set.In the absence of the information in columns 4 and 6, we cannot directly judge whether pattern 4 actors are included in o(B) and whether pattern 8 actors are included in o(E). However, we know that all remaining actors are non-fixed and must be required by the scenes in Q. In other words, if some pattern 4 and 8 actors are kept in AN, then they must be required by some scene in Ω1 ∪ Ω2. Therefore, we fill the corresponding cells with “1” (see the numbers in bold in Table 7).We list in the left part of Table 8 all actor patterns that satisfy the conditions a(s1) ∪ o(B)⊇a(s2) ∪ o(B) and a(s1) ∪ o(E)⊆a(s2) ∪ o(E). Table 8 shows that branching to scene s1 is dominated by branching to scene s2. After exchanging the positions of scenes s1 and s2, the holding costs for pattern 1, 4–5, 8–9 and 12 actors remain unchanged while the holding costs for pattern 3 and 6 actors are probably reduced. Thus, scheduling scene s2 immediately after B must result in less or equal holding cost than scheduling scene s1 at that position.At a branch-and-bound tree node associated with problemP(B→,Q,E→),we suppose that s1 is the scene to be scheduled immediately after B and s2 belongs toQ−{s1}. If a(s1) ∪ o(B)⊇a(s2) ∪ o(B) andc((a(s1)∪o(B))∩(a(s2)∪o(E)))−c(a(s2)∪o(B))>0,then the branch associated with scene s1 can be ignored.We list in the left part of Table 9 all actor patterns that satisfy the conditions a(s1) ∪ o(B)⊇a(s2) ∪ o(B). The right part of Table 9 is the result of shifting scene s2 immediately before scene s1 and immediately after B. From Table 9, we can get the following four observations: (1) the holding costs for pattern 5 actors remain unchanged; (2) the holding costs for pattern 1, 3, 8–10 and 12 actors are probably reduced; (3) the holding cost of each actor aiwith pattern 2 or 4 is probably increased by c(ai)d(s2); (4) the holding cost of each pattern 6 actor aiis definitely decreased by c(ai)d(s2). If the decreased amount (related to pattern 6 actors) is greater than the increased amount (related to pattern 2 and 4 actors), then shifting scene s2 immediately before scene s1 must lead to a cost reduction. Given that a(s1) ∪ o(B)⊇a(s2) ∪ o(B) is satisfied, the set a(s1) ∪ o(B)) ∩ (a(s2) ∪ o(E) includes pattern 1, 3, 5–6 and 9 actors and the set a(s2) ∪ o(B) includes patterns 1–5, and 9 actors. This means both a(s1) ∪ o(B)) ∩ (a(s2) ∪ o(E) and a(s2) ∪ o(B) include pattern 1, 3, 5, 9 actors. So we can derive thatc((a(s1)∪o(B))∩(a(s2)∪o(E)))−c(a(s2)∪o(B))is equal to the cost of all pattern 6 actors minus the cost of all pattern 2 and 4 actors. Thus, if a(s1) ∪ o(B)⊇a(s2) ∪ o(B) andc((a(s1)∪o(B))∩(a(s2)∪o(E)))−c(a(s2)∪o(B))>0,scheduling scene s2 immediately after B must result in less or equal holding cost than scheduling scene s1 at that position.Our enhanced branch-and-bound algorithm for the talent scheduling problem is given by Algorithm 3, where the value of past cost z is initialized to zero at the root node. The preprocessing stage is realized by functionpreprocess(Q,AN)(see line 9, Algorithm 3). The state caching technique is adopted through functioncheck(B→,Q,E→)(see line 10, Algorithm 3), where the details of this function is described in Algorithm 2. The function isDominated(B→,Q,E→,AN,z,s)employs the proposed two dominance rules to check whether branching to some scene s is dominated by other branches. In function isDominated(B→,Q,E→,AN,z,s),we check in turn whether s can be dominated by the scene inQ−{s}. If scene s can be dominated, then this function returns true and thus the corresponding node can be eliminated. The function lower(B∪{s},Q−{s},E)returns a valid lower bound to the future cost of the problem at some search node.Our algorithm was coded in C++ and compiled using the g++ compiler. All experiments were run on a Linux server equipped with an Intel Xeon E5430 CPU clocked at 2.66 gigahertz and 8 gigabytes RAM. The algorithm only has two parameters, namely the number (C) of cached states and the caching strategy used. After some preliminary experiments, we setC=225and chose the greedy caching strategy when solving the benchmark instances. In this section, we first present our results for the benchmark instances and then compare them with the results obtained by the best two existing approaches. Finally, we exhibit by experiments the impacts of the parameters on the overall performance of the algorithm. All computation times reported here are in CPU seconds on this server. All instances and detailed results are available in the online supplement to this paper at: http://www.tigerqin.com/publicatoins/talent-scheduling-problem.In order to evaluate our algorithm, we conducted experiments using two benchmark data sets (Types 1 and 2), downloaded from http://people.eng.unimelb.edu.au/pstuckey/talent/. The Type 1 data set was introduced by Cheng et al. (1993) and Smith (2005), including seven instances, namely MobStory, film103, film105, film114, film117, film118 and film119. Since these instances have small sizes, ranging from 18 × 8 (18 scenes by 8 actors) to 28 × 8, they were easily solved to optimality. Table 10 shows the results obtained by our branch-and-bound algorithm, the constraint programming approach in Smith (2005) and the dynamic programming algorithm in de la Banda et al. (2011). From this table, we can see that our algorithm reduced the number of subproblems significantly for each instance with much less computational efforts. In our branch-and-bound algorithm, a subproblem corresponds to a search tree node. Note that the results taken from Smith (2005) were produced on a PC with 1.7 gigahertz Pentium M processor, and the results from de la Banda et al. (2011) were produced on a machine with Xeon Pro 2.4 gigahertz processors and 2 gigabytes RAM.The Type 2 data set was provided by de la Banda et al. (2011). Following a manner almost identical to that used by Cheng et al. (1993), de la Banda et al. (2011) randomly generated 100 instances for each combination ofn∈{16,18,20,…,64}andm∈{8,10,12,…,22},for a total of 200 instance groups and 20,000 instances. They tried to solve these instances using their dynamic programming algorithm with a memory bound of 2 gigabytes. For each instance, if the execution did not run out of memory, they recorded the running time and the number of subproblems generated. They reported the average running time and the average number of subproblems for each Type 2 instance group with more than 80 optimally solved instances; these two average values were computed based on the optimally solved instances.We tried to solve all Type 2 instances using our branch-and-bound algorithm with a time limit of 10 minutes and a memory of 2 gigabytes. Our algorithm requires some memory to store the information of the search tree and a limited number of states. The amount of memory available can fully satisfy this requirement and thus the out-of-memory exception did not occur. Table 11 gives the number of instances optimally solved in each Type 2 instance group, where an underline sign (“_”) is added to the cell associated with the instance group with less than 80 optimally solved instances. For an instance group, if our algorithm optimally solved 80 or more instances while the dynamic programming algorithm failed to achieve so, the number in its corresponding cell is marked with an asterisk (*). From this table, we can see that our algorithm managed to optimally solve all instances with the number of scenes (n) not greater than 32 or the number of actors (m) not greater than 10. However, the dynamic programming algorithm by de la Banda et al. (2011) only optimally solved more than 80 out of 100 instances for the instance groups with n ≤ 26. Their approach even did not optimally solve all instances withm=8andn=64. In this table, 89 out of 200 instance groups are marked with asterisks, which clearly indicates that more Type 2 benchmark instances were successfully solved to optimality by our branch-and-bound algorithm. Although our machine is slightly more powerful, this cannot account for the dramatic difference in the number of optimally solved instances, it is reasonable to conclude that our branch-and-bound algorithm is more efficient than the dynamic programming algorithm.Tables 12–13 show the average running time and the average number of search nodes, respectively, over all optimally solved instances for each instance group. Like in Table 11, the instance groups with less than 80 optimally solved instances are marked with “_”. From Table 13, we can easily find that the average number of search nodes generated for each instance group with “_” exceeds 3,000,000.To further compare our results with those reported by de la Banda et al. (2011), we pictorially show in Fig. 1 the ratio of the average number of subproblems (i.e., search nodes) generated by our algorithm to that generated by the dynamic programming algorithm. Each point in these curves corresponds to an instance group whose average number of subproblems was reported by de la Banda et al. (2011). On average, the number of subproblems generated by our algorithm is less than 22 percent of that generated by the dynamic programming algorithm, which should be attributed to the use of the new lower bound and domination rules. Moreover, we can observe some trends from these curves. The ratio first decreases as the number of scenes increases, which implies that our algorithm can eliminate more subproblems. Then, the ratio increases with the number of scenes. This is because hash collisions happened more frequently, reducing the opportunities of pruning search nodes and therefore increasing the number of subproblems.We take the value of C from {0, 25, 210, 215, 220, 225}, whereC=0means that cache is not used. Considering the two caching strategies, we have 12 parameter combinations in total. We tested these 12 parameter combinations using a portion of the Type 2 instances. Specifically, the first 5 instances were selected from each instance group, for a total of 1000 instances. We also imposed a time limit of 10 minutes on each execution of our algorithm. The results of those optimally solved instances were recorded for analysis.Fig. 2 illustrates the number of optimally solved instances under each parameter setting. This figure shows that more caching states lead to more optimally solved instances under both caching strategies. Under the latest caching strategy, the number of instances optimally solved increases from 854 (C=0) to 922 (C=225). Under the greedy caching strategy, this number increases from 854 to 939. When C is relatively small (e.g., C ≤ 215), hash collisions occur frequently and the latest caching strategy leads to slightly better performance than the greedy caching strategy. The greedy caching strategy may store more states associated with the subproblems at the early level of the search tree, which cannot be used to effectively prune the nodes. We conjecture that since the latest caching strategy stores the newly encountered states and a certain state is revisited in short period with high probability, the pruning can occur with more opportunities and then the number of subproblems is reduced. When C is large (e.g., C ≥ 220), the greedy caching strategy leads to more optimally solved instances than the latest caching strategy. This may be because a smaller state value in the caching slot is likely to eliminate more subproblems during the search process.To further test the impacts of different parameter settings on the average number of subproblems generated, we selected five Type 2 instance groups, namely 40 × 18, 46 × 16, 52 × 14, 58 × 12 and 64 × 10. All instances in these five groups can be optimally solved using our branch-and-bound algorithm within 10 minutes of running time. We pictorially show the results associated with some parameter settings in Fig. 3. We can clearly observe that the average number of subproblems generated decreases as the number of cached states increases. This is in accordance with our intuition since more cache slots store more states, which helps prune more search nodes and therefore reduces the number of subproblems. This figure also reveals that the greedy caching strategy outperforms the latest caching strategy in terms of the average number of subproblems generated whenC=220orC=225,while the latest caching strategy generally generates fewer subproblems when C is small, i.e.,C=210orC=215. As a result, we adopted the greedy caching strategy andC=225in the final implementation of our branch-and-bound algorithm.We studied the impacts of the new lower bounds and the dominance rules by removing one type of component in turn and executing the resulting algorithm on the 1000 selected instances used in the previous section. Therefore, we have four versions of the branch-and-bound algorithm, which are:1.B&B1 that uses only the lower bound from de la Banda et al. (2011) and does not include the dominance rules;B&B2 that uses both the lower bound from de la Banda et al. (2011) and our newly proposed lower bounds, but does not include the dominance rules;B&B3 that uses only the lower bound from de la Banda et al. (2011) and includes the dominance rules;B&B4 that uses the lower bound from de la Banda et al. (2011), our newly proposed lower bounds and the dominance rules.The computational results are presented in Tables 14–15, where the numbers of instances optimally solved by B&B1 – B&B4 are 561, 625, 895 and 938, respectively. These results imply that the introduction of the dominance rules and the newly proposed lower bounds increases the performance of the branch-and-bound algorithm significantly. Obviously, compared with the new lower bounds, the dominance rules contribute more for the better performance of the enhanced branch-and-bound algorithm.Finally, we generated some new instances and evaluated the impacts of the distributions of “X”. The instance generation procedure is described as follows:1.The first 5 instances are selected from each instance group provided by de la Banda et al. (2011), for a total of 1000 instances.The values of d(sj) and c(ai) and the number (ni) of scenes that require actor aiin each new instance are the same as those in its corresponding instance generated by de la Banda et al. (2011).We generate nirandom numbers between 1 and n using Binomial (p = 0.3) and Poisson (λ=⌈n⌉) random number generators. These numbers indicate the set of scenes in which actor aiis in. If the random number generator generates a number that has already been included in the set, we discard it and generate another one until nidifferent numbers are generated. That is, we generate two new instances from each of the selected instance, for a total of 2000 new instances.From these new instances, we observe that an actor usually participates in a set of consecutive scenes. In Tables 16–17, we present an example generated by de la Banda et al. (2011) and a new instance generated using the Binomial (p = 0.3) random number generator. Experimental results shown in Table 18reveal that our enhanced branch-and-bound algorithm can handle these new instances very efficiently. All these 2,000 instances have been optimally solved within several seconds.

@&#CONCLUSIONS@&#
In this paper, we proposed an enhanced branch-and-bound algorithm to solve the talent scheduling problem, which is a very challenging combinatorial optimization problem. This algorithm uses a new lower bound and two new dominance rules to prune the search nodes. In addition, it caches search states for the purpose of eliminating search nodes. The experimental results clearly show that our algorithm outperforms the current best approach and achieved the optimal solutions for considerably more benchmark instances.We present a mixed integer linear programming model for the talent scheduling problem in Section 2. A possible future research direction is to design mathematical programming algorithms for the talent scheduling problem, such as branch-and-cut algorithm and branch-and-bound coupled with Lagrangian relaxation and sub-gradient methods.