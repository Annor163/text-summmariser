@&#MAIN-TITLE@&#
A sweep and translate algorithm for computing voxelized 3D Minkowski sums on the GPU

@&#HIGHLIGHTS@&#
Algorithm for computing voxelized Minkowski sum of two input polyhedra.New decomposition formula for computing Minkowski sum, with proof.Efficient GPU implementation using stencil shadow volumes.

@&#KEYPHRASES@&#
Minkowski sums,GPU,Voxelization,Stencil shadow volume,

@&#ABSTRACT@&#
Computing the Minkowski sum of two arbitrary polyhedra inR3is difficult because of high combinatorial complexity. We present an algorithm for directly computing a voxelization of the Minkowski sum of two closed watertight input polyhedra for applications such as path planning that do not require a boundary representation as output. We introduce a new decomposition formula for computing the Minkowski sum and prove its correctness. We describe an efficient Graphics Processing Unit (GPU) implementation of the algorithm using stencil shadow volumes to create a solid voxelization of the Minkowski sum.

@&#INTRODUCTION@&#
Minkowski sums are a fundamental operation for many applications in Computer-Aided Design and Manufacturing, such as solid modeling (offsetting and sweeping), collision detection, toolpath planning, assembly/disassembly planning, and penetration depth computation. Despite the simplicity of its mathematical definition, computing the Minkowski sum of two arbitrary polyhedra inR3is generally difficult because of its high combinatorial complexity. In this paper, we present a new algorithm for directly computing a voxelization of the Minkowski sum of two closed watertight polyhedra. This algorithm runs on the Graphics Processing Unit (GPU) and directly creates a voxelization without having to compute a boundary representation (B-rep).The Minkowski sum of two point setsAandBinRnis defined as(1)A⊕B={a+b∣a∈A,b∈B}whereaandbdenote the coordinate vectors of arbitrary points inAandB, and + denotes vector addition. In this paper we will not distinguish between points and vectors; i.e., a point will also represent the vector pointing from the origin to itself. Unless otherwise specified, we will use lower case letters for points and upper case for sets of points.From the above Minkowski sum definition, and the commutativity and associativity of vector addition, the following two properties (commutativity and associativity) of Minkowski sums hold:(2)A⊕B=B⊕A,(3)(A⊕B)⊕C=A⊕(B⊕C).The translation of a point setAby a vectord, denoted asAd, can be represented as the Minkowski sum of point setAand another point set that contains only pointd; i.e.,(4)Ad=A⊕{d}.For simplicity, we will denoteA⊕{d}as eitherA+dorAd.The shape of a Minkowski sum is translation invariant. If we translate one of the input models by a specific vectord, the Minkowski sum will also translate by the same vector, or mathematically,(5)Ad⊕B=A⊕Bd=(A⊕B)d.Another equivalent definition of Minkowski sums using the concept of translation is(6)A⊕B=⋃a∈ABa=⋃b∈BAb.The equivalence of (1) and (6) can be shown as below:A⊕B={a+b∣a∈A,b∈B}⟺A⊕B={a+B∣a∈A}⟺A⊕B=⋃a∈ABa.Definition (6) implies a method often used to manually construct and visualize Minkowski sums. IfAandBrepresent polygons inR2or polyhedra inR3,A⊕Bcan be generated by “sweeping”Aalong the boundary ofBand then taking the union of the sweep withB(or vice versa). Fig. 1shows the 2D Minkowski sum of a square and a triangle generated by sweeping the triangle along the boundary of the square. A 3D example is shown in Fig. 2, where the 3D Minkowski sum is generated by sweeping the tetrahedron over the six boundary faces of the cube. The two examples given in Figs. 1 and 2 are simple convex models. When both input models become non-convex, their Minkowski sum can still be generated by sweeping one over the other, but the final shape will become more complex (Fig. 3). In this paper, we develop the mathematics behind the “sweep-along-the-boundary” behavior—we give both an accurate mathematical description and a strict proof. Based on this mathematical formulation, we then introduce a new formula that decomposes the Minkowski sum of two closed watertight objects as the union of the Minkowski sum of their boundaries and a translation of each input object. Finally, for an efficient implementation, we use a stencil shadow volume technique to voxelize the union and create a solid voxelization of the Minkowski sum.We now discuss some commonly used approaches for Minkowski sum computation algorithms that can take non-convex polyhedra as inputs. Although the Minkowski sum of two convex polyhedra has complexity ofO(mn)(heremandndenote the numbers of triangles of each input polyhedron) and can be computed very efficiently  [1,2], the Minkowski sum of two non-convex polyhedra can have complexity as high asO(m3n3)and becomes much more difficult to compute. Most algorithms for non-convex objects fall into two main categories: convex decomposition or convolution.The basic idea of convex-decomposition based algorithms is decomposing the input non-convex polyhedra into convex pieces, computing all the pairwise Minkowski sums of these convex pieces, and then taking their union. It is based on the following property of Minkowski sums (distributivity):Proposition 1(A∪B)⊕C=(A⊕C)∪(B⊕C).Proofx∈(A∪B)⊕C⟺x=y+c,y∈A∪B,c∈C⟺x=a+corb+c,a∈A,b∈B,c∈C⟺x∈A⊕Corx∈B⊕C.Then(A∪B)⊕C=(A⊕C)∪(B⊕C).□There are three steps in convex-decomposition based approaches: convex decomposition, computing the Minkowski sum of convex pieces, and union computation. While it is desirable to compute an optimal (minimum number of pieces) convex decomposition, this problem is known to be NP-hard  [3]. Several practical algorithms are known to compute a sub-optimal or approximate convex decomposition  [4–6]. The second step is typically performed using either the convex hull or Gaussian map approaches  [1,2]. The third step, computing the union of the intermediate Minkowski sum pieces, is usually time consuming since the number of pairwise Minkowski sum pieces has quadratic complexity (in the timings given in  [7], the time used for computing the union dominates the whole algorithm). Givennpolyhedral objects, their union can have combinatorial complexity ofO(n3)[8].Based on the algorithms used for convex decomposition and union computation, convex-decomposition based approaches for Minkowski sum computation can be either exact or approximate. The exact algorithms allow robust implementation and are able to find low dimensional boundaries, i.e., they are able to identify dangling faces or lines and singular points in the Minkowski sums [9–11]. However, these algorithms are limited to relatively simple objects because of their performance. To compute the Minkowski sum of two polyhedra bounded by only hundreds of triangles, it usually takes tens of minutes  [12]. Varadhan and Manocha proposed another convex-decomposition based algorithm to compute an approximated boundary of Minkowski sums  [7]. Instead of computing the exact union of pairwise Minkowski sums, they compute a signed distance field and extract its zero iso-surface. Their algorithm provides geometrical and topological guarantees by using an adaptive subdivision algorithm. However, the performance of their algorithm is impacted by the large number of convex pieces after decomposition. The timing reported in their paper shows that computing the distance fields for tens of thousands of pairwise convex Minkowski sums usually takes 5–50 min.Convolution-based approaches have also been proposed for computing the boundary of Minkowski sums. Usually they start with a set of surface primitives that is a superset of the Minkowski sum boundary. These surface primitives are then trimmed and filtered to form the final boundary.For objects with smooth boundary surfaces, their convolution is well defined. If we denote the convolution of two surfaces as⋆, then the convolution of two smooth boundary surfaces∂Aand∂Bis defined as(7)∂A⋆∂B={a+b∣a∈∂A,b∈∂B,na=nb},wherenadenotes the unit outward normal at pointa. A 2D example of the convolution of two smooth curves is shown in Fig. 4. Note that the convolution in this context is different from its usual definition of “convolving two functions”. For two objects the convolution of their boundaries is a superset of the boundary of their Minkowski sum and also a subset of the Minkowski sum of their boundaries  [13,14]; i.e.,(8)∂(A⊕B)⊆∂A⋆∂B⊆∂A⊕∂B.If both objects are convex, it is easy to show that∂A⋆∂B=∂(A⊕B)[1]. If at least one of them is non-convex, the convolution may become self-intersecting (see Fig. 4 for an example), and the Minkowski sum boundary can be extracted by trimming and filtering the convolution surfaces.Polyhedra do not have smooth boundary surfaces, and the outward normals at their vertices and edges are not well defined. The definition of convolution for polyhedra is much more complicated, especially for non-convex polyhedra. In the work by Ghosh  [1], the convolution of two polyhedra is defined using the concept of Gaussian maps (called “slope diagrams”), and for non-convex input, an additional concept called “negative objects”. In that definition, the convolution of two polyhedra can be seen as an extension of Eq. (7), which defines the convolution of smooth boundary surfaces, wherenaandnbare replaced with the corresponding features (a single point, a geodesic arc, or a patch, depending on the position ofaorbon the boundary) to which pointsaandbare mapped to on the Gaussian sphere, and then instead of checking whether the two outward normals are the same, the intersection of the two features is checked.Computing the exact convolution of two polyhedra (which is the superset of the boundary of their Minkowski sum) is difficult itself since it involves 3D arrangements and Boolean operations. Usually people compute the exact convolution only if both input models have smooth boundaries and if explicit parameterization of both boundaries exists  [13,14]. Many convolution-based approaches for polyhedra just start with∂A⊕∂Bas the convolution  [15,16], and then filter and trim its surface primitives to extract the final Minkowski sum boundary. The filtering and trimming operations may become very complex since the number of generated surface primitives has quadratic complexity and they may intersect each other arbitrarily in 3D space. The algorithm proposed in our previous work  [17] uses this basic approach.Below we briefly discuss some existing convolution-based algorithms. Guibas and Seidel presented an output sensitive algorithm for computing the convolution of 2D curves  [18]. Kaul and Rossignac introduced a set of criteria to cull out facets that are not part of the Minkowski sum boundary  [16]. These criteria were used later in other works  [19,15,20,17]. Peternell and Steiner studied how to extract the Minkowski sum boundary from the convolution of two objects with piecewise smooth boundaries  [14]. As discussed in the previous paragraph, Lien started with a brute force convolution, which is simply defined as∂A⊕∂B, and then computed facet–facet intersections as 2D arrangements on each facet  [15]. Then he introduced the novel idea of using collision detection tests to merge and filter cells from 2D arrangements. Unfortunately the 2D arrangements and collision detection become both time and memory consuming when the size and complexity of the input models increase.To overcome the computational complexity introduced by 3D operations, some approaches seek to use other lower dimensional representations. Voelcker and his group suggested using “ray representations” (ray-reps) to reduce 3D Minkowski sum computation to 1D Boolean operations  [21,22], but no practical implementation of this algorithm is known. Lien proposed a point-based approach that creates a point set covering the Minkowski sum boundary  [19]. This approach starts with a set of points both on and inside the Minkowski sum boundary. Several filters, including the ones introduced in  [16], are used to cull out points that are not on the boundary to generate the final point set. The main drawback of this approach is that its result includes no information of the interior of the Minkowski sum. Kavraki proposed voxelizing both input models, then converting the Minkowski sum to the convolution (the usual mathematical convolution, not the convolution of two surfaces mentioned in the previous section) of two 3D arrays representing the voxels, and finally computing the convolution using a fast Fourier transform (FFT)  [23]. The main drawback of this approach is the low resolution (1283 or 2563) used for the voxelization due to memory limitations  [24,25], since each voxel needs to be represented as a floating point number (it would require 512×512×512×4=512 MB if a floating point number uses 4 bytes).Some algorithms have also been introduced for handling specific types of objects. Seong et al. presented an algorithm for computing Minkowski sums of surfaces generated by slope-monotone closed curves  [26]. Mühlthaler and Pottmann introduced an explicit parameterization of the convolution of two ruled surfaces  [13], which was defined in Eq. (7). Barki et al. proposed an approach for computing the Minkowski sum of a convex polyhedron and a non-convex polyhedron whose boundary is completely recoverable from three orthogonal projections  [27]. Other authors have introduced fast algorithms for the special case of rotating convex polyhedra by tracking the changes to the topology of the arrangement on the Gaussian sphere  [28–30].Most existing algorithms, as discussed above, compute either an exact  [11,2,10,31] or an approximated  [14,7] boundary representation (B-rep) of the Minkowski sum. A B-rep is convenient for rendering and visualization due to its explicit representation of surface boundaries, but it cannot be directly applied to many applications where we are more interested in the interior of the Minkowski sum instead of its boundary. In motion planning, even if we have computed a B-rep based configuration-space, it usually needs to be sampled in order to construct a connectivity roadmap  [32,33]. In collision detection and assembly/disassembly, we need to determine whether a point is inside or outside of the Minkowski sum, which usually requires a parity check for B-reps. If we consider higher dimensional Minkowski sums (e.g., 3D motion planning involving both translation and rotation requires computing and representing 6D Minkowski sums), a B-rep is not an appropriate representation any more.To overcome the shortcomings of B-rep based Minkowski sums, our algorithm described in  [17] considers using a GPU-based algorithm to compute a voxelized representation as an alternative to the traditional B-rep. A voxelized representation provides a uniform and simple description for objects and can be easily extended to higher dimensions. The voxelized representation of Minkowski sums is more advantageous in applications where a B-rep would need to be sampled or point membership classification (determining whether a point is inside a B-rep solid or not) would need to be performed. It provides sample points used to build the connectivity roadmap in motion planning with no need of further computation, and also provides immediate collision feedback by simply checking if a certain voxel is set to one or zero. However, the algorithm proposed in  [17] cannot compute holes in Minkowski sums.As explained in Section  1.2, to manually draw the Minkowski sum of two simple shapes, one usually sweeps one shape along the boundary of the other. (In fact this method works for complex 3D objects too, but it is easier to perform manually for simple shapes.) Such an example is shown in Fig. 5(a). Here we sweep the yellow triangle along the boundary of the green rectangle. Some subtleties of this common approach include:–A reference point needs to be specified forB. This reference point is placed on and swept along the boundary ofA. Theoretically this point can be chosen arbitrarily. One usually uses a point on the boundary ofBfor convenience. In Fig. 5(a), we use pointras the reference point.BeforeBis swept,Aneeds to be translated by the vector defined by the reference point ofB. Usually one simply sweepsBalong the boundary ofAwithout translatingA, just because the origin is taken as the reference point. If the reference point is not the origin, a translation ofAis necessary. In Fig. 5(a), the green square is translated by vectorr.Just sweepingBalong the boundary ofAdoes not necessarily cover the whole Minkowski sumA⊕B. In the example in Fig. 5(b), an empty rectangle inside the Minkowski sum is not covered by the sweep. This empty rectangle will be covered byAafter it is translated by vectorrifris chosen to be a point ofB(either on the boundary or in the interior), as one normally does. (An analogous case for the swept volume of a compact manifold sweeping along a one-parameter trajectory was proved in  [34].)Mathematically “sweepingBalong the boundary ofA” is represented byB⊕∂A. To cover the empty area that is not covered by the sweep, we need a translation ofA. A key observation is that as long asAis translated by a vector defined by any point ofB, it will cover the empty area (see Fig. 5(c)). We summarize this observation in the proposition below and also give a strict proof. A similar proposition was introduced in the technical report by Menon and Voelcker  [21], though the origin was assumed to be inside ofB(or translated before and after). In our proposition below, we do not put any restriction on the origin and give a more concise proof.Proposition 2SupposeAandBare two singly connected watertight objects, andpbis an arbitrary point ofB(either on the boundary or in the interior). ThenA⊕B=(B⊕∂A)∪(A+pb).ProofLetCdenote(B⊕∂A)∪(A+pb),∀pb∈B. By definition,B⊕∂A⊆A⊕BandA+pb⊆A⊕B. ThereforeC⊆A⊕B. We only need to prove thatA⊕B⊆C; i.e.,∀c∈A⊕B, we need to show thatc∈C.For anyc∈A⊕Bthere must exist pointsaandb,a∈Aandb∈B, such thatc=a+b. Ifa∈∂A, thenc∈B⊕∂A⊆C. Ifa∉∂A, thenamust lie in the interior ofA. Now we consider−B+(a+b)(Bis reflected around the origin and then translated by vectora+b). After this transformation, pointbwill coincide with pointa(since−b+(a+b)=a). Note thatbcan be either on the boundary or in the interior ofB. Now consider the intersection between the boundaries ofAand−B+(a+b). SinceAand−B+(a+b)share at least one common pointa, andais in the interior ofA, either these two boundaries intersect each other, or one of them completely contains the other, for a total of three different cases to consider (see Fig. 6).•Case (1):∂(−B+(a+b))and∂Aintersect. Supposea′is the intersection,a′∈∂Aanda′∈∂(−B+(a+b)). Sincea′∈∂(−B+(a+b)),∃b′∈Bsuch thata′=−b′+a+b. Thenc=a+b=(a+b−b′)+b′=a′+b′∈∂A⊕B⊆C.Case (2):−B+(a+b)⊆A. Then∀pb∈B,−pb+a+b∈A⇒−pb+c∈A⇒c∈A+pb⊆C.Case (3):A⊆−B+(a+b). Then∀pa∈∂A⊆A,pa∈−B+(a+b)⇒pa∈−B+c⇒−pa∈B+(−c)⇒c−pa∈B⇒c∈B+pa⊆B⊕∂A⊆C.Thus for all the three cases, we havec∈C. This provesA⊕B⊆C. ThusA⊕B=C.□Proposition 2 mathematically expresses the “sweep-along-the-boundary” method used to generate Minkowski sums. In fact, as suggested by our proof above, we find that the proposition can be further extended. In case (1),b′must be on the boundary ofB; in case (3),pacan be any point ofA, not just a point on the boundary ofA. Another reason the proposition might be extended is thatAandBare symmetric in the expressionA⊕B(i.e., they can be swapped without causing any change), but they are not in the expression(B⊕∂A)∪(A+pb).The extended proposition is given below. It shows that the Minkowski sum of two singly connected watertight objects can be decomposed as the union of the Minkowski sum of their boundaries and a copy of each object translated by a vector defined by any point of the other object. Its proof is very similar to the one for Proposition 2. To the best of our knowledge, this is the first mathematical formulation and explanation of the relationship between the Minkowski sum of two objects and the Minkowski sum of their boundaries.Proposition 3SupposeAandBare two singly connected watertight objects, andpaandpbare two arbitrary points ofAandBrespectively (either on the boundary or in the interior). ThenA⊕B=(∂A⊕∂B)∪(A+pb)∪(B+pa).ProofLetCdenote(∂A⊕∂B)∪(A+pb)∪(B+pa),∀pa∈Aand∀pb∈B. By definition,∂A⊕∂B⊆A⊕B,A+pb⊆A⊕B, andB+pa⊆A⊕B. ThenC⊆A⊕B. We only need to prove thatA⊕B⊆C; i.e.,∀c∈A⊕B, we need to show thatc∈C.For anyc∈A⊕Bthere must exist pointsaandb,a∈Aandb∈B, such thatc=a+b. Ifa∈∂Aandb∈∂B, we havec∈∂A⊕∂B⊆C. Otherwise, eithera∉∂Aorb∉∂B. Without loss of generality we assume thata∉∂A. Thenamust lie in the interior ofA. Now we consider−B+(a+b)(Bis reflected around the origin and then translated by vectora+b). After this transformation, pointbwill coincide with pointa(since−b+(a+b)=a). Note thatbcan be either on the boundary or in the interior ofB. Now consider the intersection between the boundaries ofAand−B+(a+b). SinceAand−B+(a+b)share at least one common pointaandais in the interior ofA, either these two boundaries intersect each other, or one of them completely contains the other, for a total of three different cases to consider (see Fig. 6).•Case (1):∂(−B+(a+b))and∂Aintersect. Supposea′is the intersection,a′∈∂Aanda′∈∂(−B+(a+b)). Sincea′∈∂(−B+(a+b)),∃b′∈∂Bsuch thata′=−b′+a+b. Thenc=a+b=(a+b−b′)+b′=a′+b′∈∂A⊕∂B⊆C.Case (2):−B+(a+b)⊆A. Then∀pb∈B,−pb+a+b∈A⇒−pb+c∈A⇒c∈A+pb⊆C.Case (3):A⊆−B+(a+b). Then∀pa∈A,pa∈−B+(a+b)⇒pa∈−B+c⇒−pa∈B+(−c)⇒c−pa∈B⇒c∈B+pa⊆C.Thus for all the three cases, we havec∈C. This provesA⊕B⊆C. ThusA⊕B=C.□Propositions 2 and 3 apply to any singly connected watertight object. Note that for a degenerate object that has zero volume (such as a surface, a line, or a point embedded in 3D space), its boundary is the same as the object itself. If both input models are triangulated polyhedra, their boundaries are the sets of their boundary triangles. Proposition 3 can then be rewritten as the corollary below.Corollary 1SupposeAandBare two triangulated polyhedra (singly connected and watertight),FAandFBare the sets of their respective boundary triangles (faces), andpaandpbare two arbitrary points ofAandBrespectively (either on the boundary or in the interior), then we haveA⊕B=(FA⊕FB)∪(A+pb)∪(B+pa).To computeFA⊕FB, we need to compute the Minkowski sum of two triangles in 3D space. Generally the Minkowski sum of two triangles in 3D (Fig. 7) is a polyhedron with 9 boundary faces (4 triangles and 5 quadrilaterals). These boundary faces are determined by the relative position of the two triangles in 3D space. To further simplify the computation, we use the proposition below to reduce the Minkowski sum of two triangles to the union of Minkowski sums of triangles and edges, which are simply triangular prisms.Proposition 4SupposeAandBare two triangles in  3D space, andEAandEBare the sets of their respective boundary edges, thenA⊕B=(A⊕EB)∪(B⊕EA).ProofLetCdenote(A⊕EB)∪(B⊕EA). By definition,A⊕EB⊆A⊕BandB⊕EA⊆A⊕B, soC⊆A⊕B. It remains only to prove thatA⊕B⊆C.If the two planes containingAandBrespectively are not parallel, call their intersection lineL(see Fig. 8). If the two planes are parallel, take any line parallel to them asL. For anyc∈A⊕Bthere must exist pointsaandb,a∈Aandb∈B, such thatc=a+b. If at least one ofaandbis on an edge of the two triangles, we havec∈A⊕EB⊆Corc∈B⊕EA⊆C. Otherwise, bothaandbare in the interior of the triangles; call the intersections of the line, passing througha(respectively,b) and parallel toL, with the edges ofA(respectively,B)a1anda2(respectively,b1andb2). We compare the lengths of the four line segmentsaa1,aa2,bb1, andbb2. Without loss of generality, supposeaa1has the smallest length out of the four, thenb+a−a1∈B. This gives usc=a+b=(b+a−a1)+a1∈B⊕EA⊆C. Note that the above reasoning still holds if all four line segments have the same length or ifAandBintersect.Therefore we have∀c∈A⊕B,c∈C; i.e.,A⊕B⊆C.□Based on Corollary 1 and Proposition 4, we can decompose the Minkowski sum of two polyhedra as the union of a series of prisms and a translation of both input polyhedra, as shown in the proposition below.Proposition 5SupposeAandBare two triangulated polyhedra,FAandFBare the sets of their respective boundary triangles,EAandEBare the sets of their respective edges, andpaandpbare two arbitrary points ofAandBrespectively (either on the boundary or in the interior), thenA⊕B=(FA⊕EB)∪(FB⊕EA)∪(A+pb)∪(B+pa).ProofFor any trianglefA∈FAandfB∈FB, suppose the edge sets offAandfBareEfAandEfBrespectively. From Proposition 4,fA⊕fB=(fA⊕EfB)∪(fB⊕EfA). Then from Proposition 1 (distributivity), we haveFA⊕FB=(∪fA∈FA{fA})⊕(∪fB∈FB{fB})=∪fA∈FA,fB∈FB(fA⊕fB)=∪fA∈FA,fB∈FB((fA⊕EfB)∪(fB⊕EfA))=(∪fA∈FA,fB∈FBfA⊕EfB)∪(∪fA∈FA,fB∈FBfB⊕EfA)=((∪fA∈FA{fA})⊕(∪fB∈FBEfB))∪((∪fB∈FB{fB})⊕(∪fA∈FAEfA))=(FA⊕EB)∪(FB⊕EA).Now applying Corollary 1,A⊕B=(FA⊕FB)∪(A+pb)∪(B+pa)=(FA⊕EB)∪(FB⊕EA)∪(A+pb)∪(B+pa).□From Proposition 5, we know that the Minkowski sum of two polyhedra can be decomposed as the union of the following four components:–FA⊕EB, which is a series of prisms formed by sweeping each triangle ofAalong each edge ofB;FB⊕EA, which is a series of prisms formed by sweeping each triangle ofBalong each edge ofA;A+pb, which is a translation ofAby a vector defined by any point ofB;B+pa, which is a translation ofBby a vector defined by any point ofA.Each one of these four components can be computed easily. To compute Minkowski sums using Proposition 5, we need to find a way to compute their union efficiently, which will be described in the next section.Suppose objectAhas|FA|triangles and|EA|edges, and objectBhas|FB|triangles and|EB|edges, then in total we have|FA|⋅|EB|+|FB|⋅|EA|prisms for(FA⊕EB)∪(FB⊕EA). Including the two translated objectsA+pbandB+pa, we need to compute the union of|FA|⋅|EB|+|FB|⋅|EA|+2polyhedral objects in order to computeA⊕Busing Proposition 5. The combinatorial complexity of the union can be as high asO(|FA|⋅|EB|+|FB|⋅|EA|+2)3[8], which is of the same magnitude as the worst-case complexityO(|FA|3|FB|3)of the Minkowski sumA⊕B. Even if bothAandBhave just thousands of triangles, the union consists of millions of objects, and in the worst case its number of facets can be on the order of 1018. Computing an exact union of such a large number of polyhedra is not practical. Exact boundary evaluation of a union of this size is slow and prone to robustness problems.Instead of computing the union exactly, we propose approximating it by using GPU-based voxelization techniques. In a voxelized representation, each object is represented by a 3D gridMij(1≤i,j≤n, wherenis the resolution) that corresponds to the 3D space occupied by a bounding box enclosing the object. Each voxelMijis set to either 1 or 0 according to whether it is located inside or outside of the object. In a conservative voxelization  [35], as long as the voxel intersects with the object, it is set to 1 (Fig. 9(a)); in other voxelizations, the center of the voxel is used as a representative point to determine whether the voxel is inside or outside of the object (Fig. 9(b)), which is also the behavior of standard rasterization algorithms required by 3D graphics APIs such as OpenGL and Direct3D. In our approach for voxelizing Minkowski sums, we follow the latter convention.Voxelization algorithms can be classified into surface voxelization (only the boundary is voxelized) and solid voxelization (the whole interior is voxelized). A surface voxelization can be created from a solid voxelization by simply checking if a voxel has any outside neighbors, as in  [17]. A solid voxelization can also be created from a surface voxelization by using the parity check rule (explained below), if a single watertight object is being voxelized  [36]. In the current work we directly create a solid voxelization for the Minkowski sum, since our goal is to avoid the computational complexity involved in evaluating the complete boundary of the Minkowski sum.Most solid voxelization algorithms are based on parity checking and work for a single watertight object  [36–40]. The parity check is based on the principal that a ray shooting from a point inside (or outside) the object will have an odd (or even) number of intersections with the object boundary respectively, as shown in Fig. 10(a). To perform the parity check using OpenGL, we can set the near clipping plane to the current slice (here we define a slice as the intersection of the object with a plane; the parity check for all the pixels on the same slice will be performed together) and the far clipping plane to be infinity, and then render the object. Only the portion of the object that is between the near and far clipping planes is rendered. The parity flag for each pixel is initialized to be zero. Then it is toggled between one and zero for each rendered fragment at its position (these fragments can be processed in arbitrary order). After the rendering is complete, any pixel inside the object will have a flag of one, and any pixel outside will have a flag of zero. Flag toggling can be implemented using either XOR operations with the color buffer or GL_INVERT operations with the stencil buffer.The parity check, however, does not work for the union of watertight objects. As shown in Fig. 10(b), to voxelize the union of a rectangle and a triangle, the parity flag of the indicated point is zero after rendering, but in fact it is inside the union. We need a slightly more complex check to correctly classify inside and outside voxels for the union of objects.The technique used in stencil shadow volumes  [41,42] has been applied to solid voxelization of individual watertight objects as well as their union  [43,44]. It strengthens the above parity check by taking into consideration the orientation of boundary surfaces. Instead of simply toggling the flag between one and zero for each rendered fragment, they increase it by one for back faces and decrease it by one for front faces, as shown in Fig. 11. After the rendering is complete, any pixel inside the union will have a non-zero stencil value, while any pixel outside the union will have a zero stencil value. The increments and decrements can be implemented using the two-sided stencil test provided by OpenGL extension GL_EXT_stencil_two_side. Note that the increments and decrements are performed with wrapping enabled to avoid saturation (otherwise the stencil value will be clamped at the maximum value and zero); thus for an 8-bit stencil buffer, increasing 255 by one will return 0 and decreasing 0 by one will return 255.The final voxelization is stored in a 3D texture, where a 3D texture of sizeX×Y×Zcan be seen asZimages of sizeX×Ystacked together, each one of which can be independently set as the draw buffer to store the color of currently rendered pixels. Each image is a 2D array of texels (texture elements), and each texel has four color channels (RGBA), with each color channel using eight bits. Thus each image has 32 slices, with each bit representing the plane of a specific slice. Each voxel is represented by a single bit, thus for a voxelization with a resolution of 512×512×512, the 3D texture should have a size of 512×512×16 (16=512/32), which uses only 16 MB of video memory.We map bits of the 3D texture to the voxels of the voxelization using color encoding  [37]. Suppose the resolution of the voxelization isN×N×N, the index of a voxel is (xv,yv,zv) (ranging from 0 toN−1), and it corresponds to thenbitbit of the texel with index (xt,yt,zt) in the 3D texture. Then the following relationships hold:(9)xt=xvyt=yvzt=⌊zv/32⌋nbit=zv−32zt.Fig. 12shows a 2D example of color encoding. For the purpose of illustration, we assume each texel has a bit depth of eight, though in reality it is 32.The overall algorithm for computing a solid voxelization ofA⊕Bfor closed watertight objectsAandBis given in Algorithm 1 and explained below. Suppose the resolution of voxelization isN×N×N. We first need to create a 3D texture of sizeN×N×(N/32)with a bit depth of 32. We also create a framebuffer object and a stencil buffer, and attach the stencil buffer to the framebuffer object. Next we create a display list for all the triangular prisms and two translated objects according to Proposition 5. The bounding box of the Minkowski sum, which can be computed easily by adding up the minimum and maximum points of the two input models along thex,y, andzdirections, is divided intoNslices along thezdirection.Now we perform the voxelization slice by slice. For each slice, we first need to set the near clipping plane at the current slice and the far clipping plane slightly beyond the maximumzof the bounding box. We also need to set the two-sided stencil operation to be increasing for back faces and decreasing for front faces. We disable the draw buffer for now since we do not need to render the display list to a color buffer; instead we only need to fill the stencil buffer. Now we call the display list to render the prisms and the two translated objects. Note that only the portion between the near and far clipping planes is rendered. After rendering, the stencil buffer is filled with zeros and non-zeros, indicating whether the corresponding voxel is outside or inside the Minkowski sum.Now we can use the stencil buffer to find corresponding bits in the 3D texture. To do this, we first need to attach the current image of the 3D texture (we haveN/32images in total, and each image corresponds to 32 slices) as the draw buffer. If it is theith slice (0≤i≤N−1), we attach the⌊i/32⌋th image, so we only need to change the attached image every 32 slices. We also need to compute an RGBA color in which only the bit corresponding to the current slice is set to one and all the other bits are zeros. In fact we create a table in advance that includes all the 32 possible RGBA color values(0x00000001,0x00000002,0x00000004,0x00000008,0x00000010,…,0x40000000,and0x80000000), and look up the correct color value in the table instead of computing it on the CPU. For theith slice, we use the(i−32⌊i/32⌋)th color value in the table. The logical pixel operation is set to OR to avoid overwriting previously computed bits. Since we only need to write to the pixels whose stencil value is non-zero, we set the stencil test to pass if the stencil value is non-zero. Now we render a quadrilateral that is slightly larger than thexyprojection of the bounding box to set the bits on the current slice.We repeat this process for all the slices. Finally the 3D texture will contain all the information of the solid voxelization.The main drawback of the above algorithm is the large number of prisms to be rendered. If bothAandBhave thousands of triangles, there will be millions of prisms. However, we can show that we do not need to render all the prisms for each slice. If a prism does not intersect with the current slice, it is either entirely between the near and far clipping planes (prismCin Fig. 13), which does not change the final stencil value, or entirely in front of the near clipping plane (prismBin Fig. 13), which is not rendered at all. Therefore for each slice, instead of rendering all the prisms, we only need to render those prisms with which the current slice intersects. Especially for complex polyhedra generated by tessellating smooth models, their boundary triangles are usually very small. The prisms formed by these triangles are therefore small compared to the Minkowski sum, and they usually intersect with only a small number of slices. Then by first computing a list of prisms intersecting with each slice, we can reduce the number of prisms rendered for each slice and therefore the time needed for rendering. It is straightforward to check whether a prism intersects with a slice or not—since the slice is perpendicular with thezaxis, we just need to check whether itszvalue is between the minimum and maximumzcoordinates of the prism.On the other hand, finding intersecting prisms for each slice also incurs some overhead. If we use just a single display list for all the slices, we only need to create and evaluate (i.e., process the input draw commands to generate final pixel information) the display list once, and then reuse it repeatedly without re-evaluating the data over and over again. But if we render different sets of prisms for each slice, we lose the benefits from using a display list; i.e., we have to re-evaluate the data for each slice.Therefore as a tradeoff, we group all the slices into several layers, each layer including a fixed number of slices. For each layer we compute a list of prisms intersecting with it, as shown in Fig. 14. We render the same list of prisms for all the slices in one layer, so they can reuse a single display list.Two factors need to be considered for choosing an appropriate value for the number of layers—the number and the size of display lists. If the number of layers is small, the generated display lists for each layer will be large; if the number of layers is large, the display lists will have smaller sizes, but at the same time we need to create more display lists. To determine an optimal value for the number of layers, we compute the voxelization of two Minkowski sums, representing two different types of input, using varying numbers of layers and compare the running timing. The first example (dragon⊕ball, Fig. 15) uses two polyhedra generated by tessellating smooth models, and the second (grate1⊕grate2, Fig. 16) uses two rectilinear models. The timings of both examples show that for both resolutions of 256×256×256 and 512×512×512, using 16 layers has the best performance. Compared to using a single display list for all the slices (i.e., the number of layers is one), using 16 layers has a 3× to 6× speedup.

@&#CONCLUSIONS@&#
