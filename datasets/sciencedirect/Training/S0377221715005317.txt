@&#MAIN-TITLE@&#
A comparison of column-generation approaches to the Synchronized Pickup and Delivery Problem

@&#HIGHLIGHTS@&#
We introduce the Synchronized Pickup and Delivery Problem.We develop four column generation approaches based on different subproblems.New labeling algorithms for the solution of two of the subproblems are devised.Extensive computational results to compare the strength of the approaches are reported.

@&#KEYPHRASES@&#
Vehicle routing,Pickup and delivery,Temporal synchronization,Labeling algorithm,Branch-and-cut-and-price,

@&#ABSTRACT@&#
In the Synchronized Pickup and Delivery Problem (SPDP), user-specified transportation requests from origin to destination points have to be serviced by a fleet of homogeneous vehicles. The task is to find a set of minimum-cost routes satisfying pairing and precedence, capacities, and time windows. Additionally, temporal synchronization constraints couple the service times at the pickup and delivery locations of the customer requests in the following way: a request has to be delivered within prespecified minimum and maximum time lags (called ride times) after it has been picked up. The presence of these ride-time constraints severely complicates the subproblem of the natural column-generation formulation of the SPDP so that it is not clear if their integration into the subproblem pays off in an integer column-generation approach. Therefore, we develop four branch-and-cut-and-price algorithms for the SPDP based on column-generation formulations that use different subproblems. Two of these subproblems are considered for the first time in this paper have not been studied before. We derive new dominance rules and labeling algorithms for their effective solution. Extensive computational results indicate that integrating either both types of ride-time constraints or only the maximum ride-time constraints into the subproblem results in the strongest overall approach.

@&#INTRODUCTION@&#
In the family of one-to-one Pickup-and-Delivery Problems (PDPs), customer requests consist of transporting goods or people between paired origin and destination points: for each request a specific good or person has to be picked up at one location and to be transported to the corresponding delivery location. Typically, the task is to design a set of minimum-cost routes satisfying all customer requests subject to pairing and precedence, and other problem-specific constraints. For details on different PDP-variants we refer to the recent surveys (Berbeglia, Cordeau, Gribkovskaia, & Laporte, 2007; Cordeau, Laporte, & Ropke, 2008; Parragh, Doerner, & Hartl, 2008).A well-studied one-to-one PDP is the Pickup-and-Delivery Problem with Time Windows (PDPTW) (e.g., Dumas, Desrosiers, & Soumis, 1991; Ropke & Cordeau, 2009; Baldacci, Bartolini, & Mingozzi, 2011) in which vehicle routes must respect pairing and precedence, capacities, and time windows. In this article, we introduce the Synchronized Pickup and Delivery Problem (SPDP). It extends the PDPTW by imposing additional constraints that couple the service times at the pickup and delivery locations of the customer requests in the following way: a delivery node has to be serviced within prespecified minimum and maximum time lags (called ride times) after the service at the corresponding pickup node has been completed. Because both pickup and delivery are performed by the same vehicle, these additional constraints are temporal intra-route synchronization constraints. As a generalization of the PDPTW the SPDP is clearlyNP-hard.As pointed out, e.g., by Dohn, Rasmussen, and Larsen (2011) or Drexl (2012), synchronization aspects are highly relevant in routing practice and there is a growing interest on Vehicle Routing Problems (VRPs) with synchronization constraints in the research community. We see the SPDP as the prototypical VRP with temporal intra-route synchronization in the sense that synchronization takes place only within disjunctive pairs of nodes and that there are no other non-standard constraints present. In this respect, the development of an effective algorithm for solving the SPDP constitutes a central building block for the solution of richer VRPs with synchronization constraints.A special case of the SPDP is the so-called Dial-a-Ride Problem (DARP) in which only a maximum ride time is specified for each pickup-and-delivery pair. The DARP mainly arises in door-to-door transportation services for school children, handicapped persons, or the elderly and disabled (see, e.g., Russell and Morrel, 1986; Madsen, Ravn, & Rygaard, 1995; Toth & Vigo, 1997; Borndörfer, Klostermeier, Grötschel, & Küttner, 1997). In this context, maximum ride times are used to guarantee a certain service level by limiting the time a passenger is on board of the vehicle. A similar service-related use of maximum ride-time constraints is described by Plum, Pisinger, Salazar-González, and Sigurd (2014) in the context of liner shipping service design. When there is a limit on the total working hours of drivers (Ceselli, Righini, & Salani, 2009) or when transporting perishable goods (Azi, Gendreau, & Potvin, 2010), the time a vehicle is away from the depot has to be restricted. This can be modeled by imposing a maximum ride-time constraint on a dummy request originating and destinating at the depot. Similarly, one might want to have a limit on both the minimum and maximum duration of the routes in order to achieve an even work-distribution of the drivers.Other applications of temporal intra-route synchronization in which minimum and maximum ride times are relevant include the planning of security guards where locations have to be inspected repeatedly within given time intervals (Bredström & Rönnqvist, 2008). There, no actual pickup at one location followed by a delivery at another location takes place. Instead, just a pairing and precedence relation between the services at the nodes forming a customer request is given. Similar planning problems arise in home health care, e.g., when patients have to be monitored by a nurse several times a day (Eveborn, Flisberg, & Rönnqvist, 2006; Rasmussen, Justensen, & Dohn, 2012). Note that in many health care applications, including those considered in Eveborn et al. (2006) and Rasmussen et al. (2012), it is not mandatory that the patients are always treated by the same nurse, i.e., these problems are of a more general nature than the one considered in this paper. The temporal aspects of this more general synchronization constraints are considered in (Dohn et al., 2011). However, personnel consistency often plays an important role in health care problems (Kovacs, Golden, Hartl, & Parragh, 2014; Rasmussen et al., 2012) so that it may be reasonable to have specific patients monitored by a single staff member only and, hence, to require pairing and precedence of the corresponding services.The contributions of this paper are the following: First, we introduce the SPDP as the prototypical VRP with temporal intra-route synchronization. This problem has to the best of our knowledge not been considered before. Second, we develop four exact solution approaches to the SPDP based on column-generation formulations whose master programs are formulated on different sets of variables implying different subproblems. Two of these subproblems are considered for the first time in the literature. One of them is the natural subproblem of the SPDP, in which time windows as well as temporal intra-route synchronization with both minimum and maximum ride times have to be dealt with. In the other one, maximum ride-times are relaxed. We derive new dominance rules and labeling algorithms for their solution. The other subproblems are solved with algorithms proposed by Dumas et al. (1991) and Gschwind and Irnich (2015), respectively. Finally, to compare the strength of the different solution approaches, we report extensive computational results over a large number of test instances with different characteristics regarding the number of customer requests and the tightness of capacity, time-window, and minimum and maximum ride-time constraints. The analysis shows that integrating either both types of ride-time constraints or only the maximum ride-time constraints into the subproblem results in the strongest overall approach regarding the number of optimal solutions, computation times, and remaining integrality gap.Integer column-generation methods have proven to be very successful in solving many VRP-variants including PDPs (e.g., Dumas et al., 1991; Ropke & Cordeau, 2009; Baldacci et al., 2011). The column-generation master programs of such approaches typically are extended set-partitioning models formulated on variables representing feasible routes for the problem at hand. These formulations provide stronger bounds compared to other formulations like, e.g., arc-flow formulations or extended set-partitioning models formulated on a relaxed set of variables, if the respective subproblem does not possess the integrality property (Lübbecke & Desrosiers, 2005). This is the case for many VRPs where the subproblems are typically Elementary Shortest-Path Problems with Resource Constraints (ESPPRC, Desaulniers, Desroisiers, Ioachim, Solomon, Soumis, & Villeneuve, 1998). However, the overall success of an integer column-generation approach for VRP-variants relies not only on strong bounds but also on the effective solution of the subproblem.This is the main challenge when synchronization comes into play (Drexl, 2012). In the case of inter-route synchronization, additional constraints have to be included in the master programs (Desaulniers et al., 1998). Because of the dual variables associated with these constraints, the resulting subproblems are highly complex (e.g., Christiansen & Nygreen, 1998; Ioachim, Desrosiers, Soumis, & Bélanger, 1999; Dohn et al., 2011) and cannot be solved by standard dynamic-programming labeling algorithms. This is also true for intra-route synchronization where no additional linking constraints are necessary. There, the increased complexity of the subproblems is not caused by additional duals but by the synchronization constraints themselves, which may be hard to incorporate into the subproblem. For the DARP, e.g., Hunsaker, Savelsbergh, and problems (2002) have demonstrated that in the presence of time windows and maximum ride times checking the feasibility of a given route is intricate. Clearly, the effective generation of such routes within a column-generation approach is even more challenging.In the case of intra-route synchronization, the complexity of the subproblems can be reduced by relaxing one or more types of constraints in the subproblem and handling them in the master programs instead (see, e.g., Ropke & Cordeau, 2005 for the DARP or Cherkesly, Desaulniers, & Laporte, 2014 for the PDPTW with LIFO Loading). The resulting easier-to-solve subproblems come at the cost of weaker lower bounds and, thus, larger branch-and-bound trees. Often, it is a priori not clear what is the best compromise between the strength of the CG formulation and the hardness of the subproblem.The recent work of Gschwind and Irnich (2015) provides insights regarding this trade-off for the DARP: they proposed a branch-and-cut-and-price algorithm that handles all route constraints of the DARP in the subproblem which is solved by means of an effective labeling algorithm. In a computational study, they compared the strength of their approach to the branch-and-cut-and-price algorithm of Ropke and Cordeau (2005) that uses a subproblem in which the maximum ride-time constraints are relaxed. The results indicated that their approach significantly outperforms the algorithm of Ropke and Cordeau (2005) in terms of computation times and number of solved instances. However, they also tested their approach with a different labeling algorithm that uses a weaker dominance rule and observed that in this case the approach with the relaxed subproblem of Ropke and Cordeau (2005) shows the better overall performance. Decisive for the success of the approach using the stronger formulation, thus, is the availability of an effective pricing procedure for the harder subproblem.Compared to the DARP, the additional presence of minimum ride times significantly complicates the natural subproblem of the SPDP. As a result, the dominance rule that we are able to derive for its solution is much weaker compared to those that can be used for the subproblems in which one or both types of ride-time constraints are relaxed. Therefore, we propose and compare the efficiency of four column-generation algorithms for the SPDP. Each algorithm uses a different subproblem: one that handles all route constraints of the SPDP, one that relaxes the minimum ride times, one that relaxes the maximum ride times, and one that relaxes both types of ride-time constraints.The remainder of the paper is organized as follows. Section 2 defines the SPDP and presents column-generation formulations of it. The dominance rules and labeling algorithms we use for solving the different subproblems are detailed in Section 3. In Section 4, we briefly describe our basic branch-and-cut-and-price algorithm and report extensive computational results. The paper ends with a short conclusion.In this section, we give a formal definition of the SPDP and describe different column-generation formulations of it.The SPDP is defined on a directed graphG=(N,A)with node setN=P∪D∪{0,2n+1}and arc set A. The subsetsP={1,…,n}andD={n+1,…,2n}contain the pickup and delivery nodes of n transportation requests, respectively. Node 0 denotes the origin depot and node2n+1the destination depot. For each requesti=1,…,n,a minimum ride timeLiand a maximum ride timeL¯iare specified, coupling the service times at the pickup node i and the delivery nodei+n.With each node i ∈ N, a non-negative service duration siand a demand disuch thatdi=−di+nfor alli=1,…,nare associated. We assumed0=d2n+1=0. A time window [ai, bi] in which the service has to be started is associated with each node i ∈ N. When arriving at node i prior to ai, the vehicle has to wait until time aibefore starting its service. Furthermore, it is allowed to delay the start of service voluntarily at any node and any time. We assume that there is no restriction on the length of the waiting times. The possibility of delaying the start of service at some nodes is crucial for the feasibility of routes in the presence of ride times and time windows (see Hunsaker et al., 2002; Gschwind & Irnich, 2015).With each arc (i, j) ∈ A, a routing cost cijand a travel time tijare associated. We assume that both routing costs and travel times are non-negative and satisfy the triangle inequality. To serve the n transportation requests, a fleet K of identical vehicles with capacity C is located at the depot 0.The SPDP consists in finding |K| vehicle routes starting and ending at the depot nodes 0 and2n+1,respectively, such that each request is served exactly once and the total routing costs are minimal. Thereby, the routes have to satisfy the following conditions:Pairing and precedence. For each request i, pickup node i and delivery nodei+nare visited on the same route, and the pickup node i is visited first.Capacity. The load of the vehicle must not exceed C at any time.Time windows. For each node i, the start of service must lie within the time window [ai, bi].Ride times. The service at a delivery nodei+nhas to start at leastLiand at mostL¯iunits of time after the service at the corresponding pickup node i has been completed.Note that it is not straightforward to decide on the feasibility of a route in the SPDP sense due to the presence of the different types of potentially contrasting temporal constraints. More precisely, to verify the feasibility of a given router=(h1,…,hq)withh1=0andhq=2n+1one has to find a time scheduleTr=(τ1,…,τq)satisfying(1)τi+shi+thihi+1≤τi+1∀i=1,…,q−1,(2)ahi≤τi≤bhi∀i=1,…,q,(3)τi+shi+L̲hi≤τjifhi+n=hj,(4)τi+shi+L¯hi≥τjifhi+n=hj,where τidenotes the start of service at node hi. Constraints (1) ensure consistency of the service times along the route. Inequalities (2) impose time windows, while (3) and (4) are minimum and maximum ride-time constraints, respectively. A schedule satisfying (1)–(4) is called feasible. We denote byTrthe set of all feasible schedules for a route r. Furthermore, letTr(t)={Tr∈Tr:τq≤t}be the set of feasible schedules with start of service τqat the last node hqnot later than t. All definitions and notations for routes and schedules are also used for partial routes, i.e., withhq≠2n+1,and corresponding partial schedules. Note that for partial routes it is possible to visit only the pickup node of a request i. In this case, no ride-time constraints (3) or (4) have to be respected for this request in a partial schedule.To formulate the SPDP as a set-partitioning problem, let Ω be the set of all SPDP-feasible routes. The cost of a route r ∈ Ω is denoted by cr. Moreover, for each route r and each request i ∈ P denote byair∈Zthe number of times request i is performed by route r. Let λrbe binary variables indicating if route r is used in the solution. The SPDP can then be formulated as follows:(5)(IMP)min∑r∈Ωcrλr(6)s.t.∑r∈Ωairλr=1∀i∈P,(7)∑r∈Ωλr=|K|,(8)λr∈{0,1}∀r∈Ω.The objective function (5) minimizes the total routing costs. Partitioning constraints (6) ensure that all requests are served exactly once. Equality (7) imposes the number of routes in the solution, while (8) are binary conditions for route variables.Typically, the number |Ω| of feasible routes is very large so that model IMP cannot be solved directly. We, therefore, use an integer column-generation approach to solve it. The linear relaxation of the so-called integer master program IMP is initialized with a proper subset of routes and missing routes with negative reduced cost are added dynamically. Integrality is ensured by integrating this process into a branch-and-bound algorithm (Lübbecke & Desrosiers, 2005).To identify negative reduced-cost routes the column-generation subproblem has to be solved. Let πi, i ∈ P and μ be the dual variables associated with constraints (6) and (7), respectively. The reduced cost of arc (i, j) ∈ A is defined as(9)c˜ij={cij−πiifi∈P,cijotherwise.The reduced costc˜rof a route r ∈ Ω isc˜r=∑(i,j)∈A(r)c˜ij−μwhere A(r) denotes the sequence of arcs traversed by route r. The subproblem is then given by(10)minr∈Ω{c˜r}.The set-partitioning model IMP is the most natural formulation for column-generation based approaches to VRP-variants including the SPDP in the following sense: the variable set Ω consists of all routes that are feasible for the problem at hand, i.e., the subproblem takes care of all constraints relating to single routes, while the master program comprises only coupling constraints. Decisive for the success of approaches based on such a formulation is that an effective solution procedure for generating feasible routes with negative reduced cost is available. For the SPDP, this means being able to simultaneously handle time-window and ride-time constraints, among others, that together impose a complex scheduling problem. The key difficulty lies in the trade-off between servicing nodes as early as possible, which is the best strategy for time windows and minimum ride times, and servicing them as late as possible, which is preferable for maximum ride times. Integrating this trade-off into a solution procedure is highly intricate and, therefore, the natural subproblem of the SPDP is significantly more complex than the natural subproblem of many related VRPs (see also Section 3.4).An alternative approach is to formulate the master program in relaxed routing variables r ∈ Ω′⊇Ω that may violate one or several types of constraints relating to a single route. This can be promising when generating routes r ∈ Ω is complex, while working with the relaxed set Ω′ results in a well-solvable subproblem. A relaxation that is used in many column-generation approaches to VRPs is to drop the elementarity condition of routes, i.e., to allow multiple visits at the same node. This has the advantage that the resulting subproblems are solvable in pseudo-polynomial time (Desrochers, Desrosiers, & Solomon, 1992) while the original elementary versions areNP-hard in the strong sense (Dror, 1994). In this case, the partitioning constraints (6) ensure that non-elementary routes can never be part of an integer solution. Thus, IMP with variable set Ω′ has the same set of optimal solutions as IMP with variable set Ω.This property, however, does not hold for all relaxations Ω′ of Ω and a route r ∈ Ω′∖Ω that is infeasible for the original problem might then be part of an integer solution. Consequently, the constraints that have been relaxed in the subproblem must be enforced in the master program to ensure feasibility of the solutions . Adding infeasible path elimination constraints (IPEC) is one way of doing this. LetIbe the set of all paths that are infeasible with respect to the constraints that have been relaxed in the subproblem. Moreover, for any infeasible pathI∈Iand any route r let bIrbe the number of times route r traverses arcs of path I. The IPEC can then be written as(11)∑r∈Ω′bIrλr≤|I|−1∀I∈I,where |I| denotes the length of the infeasible path I, i.e., the number of its arcs. We denote by IMP-I a master program that incorporates the set-partitioning model (5)–(8) formulated on a relaxed variable set Ω′ together with the IPEC (11) to handle the remaining route constraints.Obviously, approaches based on formulation IMP benefit from stronger LP-bounds compared to approaches using formulation IMP-I. The reason is that SPDP-infeasible routes, which are excluded in the former, may be convex-combined to form routes that do not violate the IPEC in the latter. Typically, the tighter LP-bounds lead to smaller search trees for IMP-based approaches. This comes at the cost of a harder to solve subproblem and it is a priori not clear which formulation enables the overall strongest algorithm.In the following sections, we consider branch-and-price algorithms for the SPDP based on four different column-generation formulations. We denote by IMPminmaxthe approach working on variable set Ω in the master program. The addition of IPEC is not necessary in this case and the master program comprises only coupling constraints. The corresponding subproblem SPminmaxhas to generate SPDP-feasible routes.The other approaches formulate their master programs in routing variables r ∈ Ω′ that relax either the minimum ride times, the maximum ride times, or both. By IMP-I we denote the algorithm that ignores both minimum and maximum ride times in the subproblem (denoted SP) and handles them using IPEC in the master program. SP is the natural subproblem of the PDPTW and generates routes that respect pairing and precedence, capacity, and time-window constraints, i.e., a time schedule satisfying constraints (1) and (2) exists for such routes.The approach that handles only the maximum ride times in the subproblem and uses routing variables where the minimum ride times have been relaxed is denoted by IMP-Imax. The corresponding subproblem is SPmax. It is the natural subproblem of the DARP. Routes generated by SPmax satisfy pairing and precedence, and capacity constraints. Moreover, these routes can be assigned a time schedule respecting constraints (1), (2), and (4). IMP-Imin and SPmin are the analog to IMP-Imax and SPmax where minimum ride rimes are handled in the subproblem.In this section, we describe solution algorithms for the different subproblems SP, SPmax, SPmin, and SPminmax. All four subproblems are ESPPRC which are typically solved using dynamic-programming labeling algorithms (Irnich, Desaulniers, & Desrosiers, 2005). In a labeling algorithm, partial paths are gradually extended in a graph G seeking to find a minimum-cost path from the source node to the sink node. The partial paths are represented by labels that store the accumulated cost and resource consumption along the path. We denote byPℓthe partial path corresponding to label ℓ. Decisive for the effectiveness of a labeling algorithm is the use of strong dominance rules to eliminate unpromising labels. A more detailed discussion on ESPPRC and labeling algorithms can be found, e.g., in Irnich et al. (2005).Note that for the rest of this paper we consider the non-elementary versions of the four subproblems for the following two reasons. First, preliminary computational results indicated that the linear-relaxation lower bounds of the master programs obtained by subproblems with the elementarity conditions were rarely stronger compared to the corresponding non-elementary subproblems. This resulted in slightly weaker overall algorithms for the former. Second, the extension of all dominance rules and labeling algorithms to the elementary case is straightforward (see Ropke & Cordeau, 2009; Gschwind & Irnich, 2015). In the presence of pairing and precedence, non-elementarity means that a request can be picked up again, after it has been picked up and delivered. Hence, several pickup-and-delivery pairs of the same request can be present in a path. For ease of notation, however, we assume for the rest of the paper that all partial paths are elementary. Furthermore, we assume that the service duration is zero for all nodes. All proofs and arguments are analog when considering non-elementary partial paths and non-zero service durations.Also, we assume that the reduced-cost matrix satisfiesc˜ij≤c˜ik+c˜kjfor all (i, j) ∈ A, k ∈ D. Ropke and Cordeau (2009) call this property the delivery triangle inequality (DTI). It enables the use of stronger dominance rules for all considered subproblems. Roughly speaking, the DTI ensures that visiting an additional delivery node is never beneficial. Ropke and Cordeau (2009) also show how to transform a reduced-cost matrix that does not satisfy the DTI into one that does, while maintaining the cost of each route unchanged. Hence, working with this assumption is no restriction.All notation previously introduced for (partial) routes is also used for (partial) paths in the following. Moreover, we use the same notation for all subproblems. The meaning should be clear from the context. The set of feasible schedulesTPfor a pathP,e.g., always refers to feasibility regarding the temporal constraints that are present in the considered subproblem.SP is an elementary shortest-path problem with pairing and precedence, capacities, and time windows. It is the natural subproblem of the PDPTW. In this context, it has been subject to prior research (Baldacci et al., 2011; Dumas et al., 1991; Ropke & Cordeau, 2009) and strong dominance rules exist for its solution by a labeling algorithm.In what follows, we summarize the main concepts of Dumas et al. (1991) and Ropke and Cordeau (2009) for solving SP. Both the dominance rule and the labeling strategy for SP also serve as basis for the solution approaches to the other subproblems in Sections 3.2–3.4. Table 1summarizes all resources that are needed in the solution algorithms for the different subproblems and indicates which resource is relevant for which subproblem.Within each label ℓ, the following information has to be stored: the node ηℓ the label belongs to, its reduced costc˜ℓ,the earliest start of service tℓ at node ηℓ, and the set of open requests Oℓ (requests that have been picked up but not yet delivered). Then, the following dominance rule is valid for SP (Dumas et al., 1991):Proposition 1(Dom-SP) A feasible label ℓ1 dominates a label ℓ2if(12)ηℓ1=ηℓ2,c˜ℓ1≤c˜ℓ2,tℓ1≤tℓ2,Oℓ1⊆Oℓ2.We now briefly describe the labeling algorithm of Dumas et al. (1991) for solving SP. In addition to the resources needed for dominance in Proposition 1, they store at each label ℓ the load lℓ of the vehicle when leaving ηℓ, enabling a fast consistency check regarding capacity. The extension of a label ℓ along arc (ηℓ, x) ∈ A is only allowed if either x∉Oℓ if x ∈ P, orx−n∈Oℓif x ∈ D, orOℓ=⌀ifx=2n+1holds. Otherwise, pairing and precedence are not satisfied resulting in an infeasible label. Furthermore, consistency with respect to time-window and capacity constraints is ensured by requiringtℓ+tηℓ,x≤bxandlℓ+dx≤C,respectively.If extending label ℓ along arc (ηℓ, x) ∈ A is feasible, a new label ℓ′ is created. Its resources are determined according to the following resource extension functions (REFs):(13)ηℓ′=x,c˜ℓ′=c˜ℓ+c˜ηℓ,x,tℓ′=max{ax,tℓ+tηℓ,x},lℓ′=lℓ+dx,(14)Oℓ′={Oℓ∪{x}ifx∈P,Oℓ∖{x−n}ifx∈D.To reduce the number of labels that have to be processed in the algorithm, unpromising labels are eliminated using dominance rule Dom-SP. Moreover, labels that cannot be feasibly completed to node2n+1can be discarded. For SP, pairing constraints require that each feasible completion to a label ℓ must visit the delivery nodesi+nof all open requests i ∈ Oℓ and thereby obey all time-window constraints (see Dumas et al., 1991 for details).In SPmax, the natural subproblem of the DARP, paths have to respect pairing and precedence, capacities, time windows, and maximum ride times. The latter two impose that for each feasible path a time schedule satisfying inequalities (1), (2), and (4) must exist. The main difficulty for solution approaches to SPmax is to deal with these partially contrasting temporal constraints. In fact, they impose a trade-off between servicing all nodes as early as possible and servicing pickup nodes as late as possible. The implication for labeling algorithms is as follows. Considering only the earliest start of service (as in Dom-SP) is not sufficient to guarantee dominance with respect to the temporal constraints of SPmax (see Example 1 of Gschwind & Irnich, 2015). Thus, one either has to include additional time-related resources in a dominance rule based on Dom-SP or come up with a different strategy to deal with the temporal constraints of SPmax.Recently, Gschwind and Irnich (2015) proposed an effective labeling algorithm for solving SPmax that uses an extended version of Dom-SP as dominance rule. The basic idea is the following: Let ℓ be a label withOℓ≠⌀. For each open request i ∈ Oℓ, the corresponding maximum ride-time constraint (4) imposes an upper bound on the start of service at delivery nodei+nrestricting the set of feasible completions to ℓ. Clearly, a larger value for this bound is preferable. As a result, dominance between two labels is only possible if for each of its open requests the dominating label has a larger upper bound value for the start of service at the respective delivery node. Determining these bounds, however, is not straightforward. They obviously depend on the actual service times at the corresponding pickup nodes within the pathPℓ. Thereby, the possibility to delay the start of service at some nodes has to be incorporated.To formalize their approach in a dominance rule, Gschwind and Irnich (2015) first define the latest possible delivery timeldℓi,i.e., the latest feasible start of service at the delivery node, of an open request i ∈ Oℓ as a function in the start of service t ≥ tℓ at the current node ηℓ. LetPℓ=(h1,…,hq=ηℓ)be the path corresponding to label ℓ. Then,ldℓhi(t)with t ≥ tℓ and hi∈ Oℓ is given by(15)ldℓhi(t)=min{bhi+n,τ¯i(t)+L¯hi},whereτ¯i(t)=maxTPℓ∈TPℓ(t){τi}is the latest feasible start of service at the pickup node hiwhile τq≤ t.Moreover, two important properties ofldℓhi(t)are proven. First, they show that all open requests and the associated latest delivery times can be treated independently in the dominance criterion. Second, they show that the functionsldℓhi(t)are of the formldℓhi(t)=min{k1i+t,k2i}with constantsk1iandk2i. With this property, the comparison of two such functions can be simplified to comparing them at two distinct points of time.LetBℓibe the point of time whenldℓi(t)becomes constant. The following proposition describes a valid dominance rule for SPmax (Gschwind & Irnich, 2015):Proposition 2(Dom-SPmax) A feasible label ℓ1 dominates a label ℓ2 if(16)ηℓ1=ηℓ2,c˜ℓ1≤c˜ℓ2,tℓ1≤tℓ2,Oℓ1⊆Oℓ2,and(17)ldℓ1i(tℓ1)+(tℓ2−tℓ1)≥ldℓ2i(tℓ2)andldℓ1i(Bℓ1i)≥ldℓ2i(Bℓ2i)∀i∈Oℓ1.The labeling algorithm of Gschwind and Irnich (2015) for solving SPmax is analog to that of Dumas et al. (1991) for SP sketched in Section 3.1. The additional presence of maximum ride times and the use of dominance rule Dom-SPmax involve only some minor modifications (see Gschwind & Irnich, 2015 for details). A key factor for the effectiveness of the labeling algorithm is that the information on the latest possible delivery timesldℓi,i∈Oℓsignificantly enhances the elimination of labels that cannot be feasibly completed to node2n+1.Subproblem SPmin is an elementary shortest path problem with pairing and precedence, capacity, time-window, and minimum ride-time constraints. To the best of our knowledge, SPmin has not been considered before and an effective labeling algorithm for its solution is presented here for the first time.Similar to SPmax, different types of temporal constraints are present in SPmin. More precisely, a schedule satisfying inequalities (1)–(3) must be assignable to each feasible path. The main task for a labeling approach to SPmin based on Dom-SP is to ensure consistency of the dominance rule with these constraints.In contrast to SPmax, however, the temporal constraint system of SPmin is rather straightforward to handle in a labeling algorithm. Both types of constraints that couple the service times at two different nodes are less or equal constraints (from front to back of the path). Consequently, the optimal strategy regarding time-window constraints, i.e., servicing all nodes as early as possible, is also an optimal strategy in the additional presence of minimum ride-time constraints. This implies that waiting and delaying the service at some node is never beneficial and the possibility to do so can be neglected. Still, inequalities (3) induce that a time schedule in SPmin is linked not only between consecutive nodes. Thus, for a label ℓ not only the service time at the current node ηℓ, but also the service times at the pickup nodes of all open requests i ∈ Oℓ are important.To obtain a formal dominance criterion for SPmin, we follow the approach of Gschwind and Irnich (2015) for SPmax. For each open request i ∈ Oℓ of label ℓ, the minimum ride-time constraints impose a lower bound on the start of service at the delivery nodei+n. We define this earliest possible delivery timeedℓhifor request hi∈ Oℓ as(18)edℓhi=max{ahi+n,tℓ+tηℓ,hi+n,τ̲i+L̲hi},whereτ̲i=minTPℓ∈TPℓ{τi}withPℓ=(h1,…,hq=ηℓ)is the earliest feasible start of service at the pickup node hi. Regarding the set of feasible completions to ℓ, a small valueedℓhiis obviously less restrictive than a larger one. Furthermore, the following lemma shows that for each feasible pathPthe time scheduleT̲Pwhich assigns each node its earliest feasible start of service is feasible. Thus, the valuesedℓhican be treated independently in a dominance rule.Lemma 1LetP=(h1,…,hq)be a feasible partial path. Then,T̲P=(τ̲1,…,τ̲q)∈TP.The proofs of all lemmas and propositions are presented in Appendix A in the online supplement of this paper.Using the valuesedℓi,we obtain the following extension to Dom-SP that is a valid dominance criterion for SPmin:Proposition 3(Dom-SPmin) A feasible label ℓ1 dominates a label ℓ2 if(19)ηℓ1=ηℓ2,c˜ℓ1≤c˜ℓ2,tℓ1≤tℓ2,Oℓ1⊆Oℓ2,andedℓ1i≤edℓ2i∀i∈Oℓ1.SPmin can be solved using the labeling algorithm of Section 3.1 for solving SP. Let ℓ′ be the label resulting from the extension of label ℓ along arc (ηℓ, x). The REFs for the additional resourcesedℓ′i,i∈Oℓ′are(20)edℓ′i={max{ax+n,tℓ′+tx,x+n,tℓ′+L̲x}ifi=x,max{edℓi,tℓ′+tx,i+n}otherwise.Moreover, the REF (13) for the earliest start of service tℓ has to be replaced by(21)tℓ′={max{edℓx−n,tℓ+tηℓ,x}ifx∈D,max{ax,tℓ+tηℓ,x}otherwise.Again, the informationedℓiis used for eliminating labels that cannot be completed to feasible0−(2n+1)-paths.Subproblem SPminmaxis the natural subproblem of the SPDP in which generated paths represent SPDP-feasible routes, i.e., they have to respect pairing and precedence, capacities, time windows, and minimum and maximum ride times. The implied scheduling problem is (1)–(4). It simultaneously includes both minimum and maximum ride times which significantly complicates SPminmaxcompared to SPmax and SPmin. The key problem is the interference of different types of ride-time constraints of different requests so that a straightforward combination of the approaches of Sections 3.2 and 3.3 is not possible. We demonstrate this in more detail in the following.Generalizing the basic idea of Gschwind and Irnich (2015), the minimum and maximum ride times of an open request i ∈ Oℓ impose a lower bound (edℓi) and an upper bound (ldℓi) on the start of service at the delivery nodei+n. Again, a small valueedℓiand a large valueldℓiare preferable. The implied optimal strategies for the start of service at the pickup node i, i.e., an early-as-possible service to minimizeedℓiand a late-as-possible service to maximizeldℓi,are clearly opposing. Even more, different strategies for the pickup times of different open requests may interfere. More precisely, servicing one node late may imply that another one cannot be serviced early, and vice versa. As a result, there is generally no feasible time schedule that minimizes the valuesedℓifor some i ∈ Oℓ and at the same time maximizes the valuesldℓjfor some other j ∈ Oℓ. Thus in SPminmax,the open requests and the associated earliest and latest delivery times cannot be treated independently in a dominance rule. Table 2gives a small example to illustrate this.Let ℓ1 and ℓ2 be two labels representing the pathsPℓ1=(0,i,j,k)andPℓ2=(0,j,i,k). Assume identical travel times of 10 between all nodes. Furthermore, let the minimum and maximum ride times for all requests be 40 and 50, respectively. The time windows of nodes 0, i, j, and k are specified in Table 2, while the time windows at the corresponding delivery nodes are assumed to be not binding ([0, ∞]). Then, the earliest possible delivery times of requests i and j for label ℓ1 (as defined in Section 3.3) areedℓ1i=max{0,50+10,10+40}=60andedℓ1j=max{0,50+10,20+40}=60. The latest possible delivery timesldℓ1iandldℓ1jas defined in Section 3.2 are, in general, functions in the start of service at the current nodeηℓ1=k. Here, the only feasible start of service at node k is at time 50. Thus, we only need to consider the valuesldℓ1i(50)=min{∞,30+50}=80andldℓ1i(50)=min{∞,40+50}=90,which imply delaying the start of service at node i until time 30 and at node j until time 40. It is easy to see, however, that there is no feasible time scheduleTPℓ1that at the same time allows a latest possible delivery time of 80 for request i and an earliest possible delivery time of 60 for request j . Note that the former implies a service time not smaller than 30 at node i while the latter implies a service time not larger than 20 at node j.As a result, simply combining the relations foredℓiandldℓiof dominance rules Dom-SPmin and Dom-SPmax does not lead to a valid dominance criterion for SPminmax. The completionQ=(j+n,i+n,k+n,2n+1),e.g., is feasible for label ℓ2 but infeasible for ℓ1, althoughedℓ1x<edℓ2xandldℓ1x(50)>ldℓ2x(50)hold forx=i,j,k(see Table 2).The example above has shown that the interdependence of different open requests has to be incorporated when trying to dominate labels in SPminmax. Roughly speaking, this means that one has to be careful when determining the earliest and latest delivery times of the open requests of a label.On the one hand, there are completions where one or more requests can only be delivered at the earliest or latest possible time. Consequently, for a dominated label ℓ we have to consider the best possible values for feasible delivery times of all open requests i ∈ Oℓ, i.e., we consideredℓiandldℓi(t),t≥tℓas defined in Sections 3.3 and 3.2, respectively. Note again that hereTPℓrefers to the set of all schedules satisfying constraint system (1)–(4).On the other hand, a completion might generally require picking up some open requests early and some other open requests late. For a dominating label ℓ withPℓ=(h1,…,hq=ηℓ)we, therefore, determine two bounds on the service time of an open request hi∈ Oℓ that are independent of the service times at the other open requests hj∈ Oℓ∖{hi}.First, we use the following upper boundτ̲iO(t)for an early-as-possible service at a pickup node hiwithin pathPℓ. Practically speaking,τ̲iO(t)gives the earliest service time at hithat can be attained without restricting the pickup times of the other open requests. Or from the opposite perspective, when scheduling all other open requests hj∈ Oℓ∖{hi} in the most unfavorable way for picking up hiearly, i.e., as late as possible, then the earliest possible service time at hithat is still feasible isτ̲iO(t). Formally,τ̲iO(t)=minTPℓ∈T̲Pℓi(t){τi}withT̲Pℓi(t)={TPℓ∈TPℓ(t):τj≥τ¯j(t)∀hj∈Oℓ∖{hi}}. Note thatτ̲iO(t)is a function in t, as the timesτ¯j(t)depend on t.Second and analog toτ̲iO(t),a lower bound for a late-as-possible service at node hiis denoted byτ¯iO(t). It gives the latest feasible start of service at the pickup node hisuch that the start of service at all other open requests hj∈ Oℓ∖{hi} takes its minimal valueτjand τq≤ t, i.e.,τ¯iO(t)=maxTPℓ∈T¯Pℓi(t){τi}withT¯Pℓi(t)={TPℓ∈TPℓ(t):τj≤τ̲j∀hj∈Oℓ∖{hi}}. Maximizing the service at himay delay the start of service τqat the current node ηℓ. Thus,τ¯iO(t)is also a function in t.Usingτ̲iO(t)andτ¯iO(t)we have the following upper and lower bounds for the earliest and latest delivery times of an open request hi∈ O, respectively:(22)ed¯ℓhi(t)=max{ahi+n,tℓ+tηℓ,hi+n,τ̲iO(t)+L̲hi},(23)ld̲ℓhi(t)=min{bhi+n,τ¯iO(t)+L¯hi}.Denote byb˜ℓthe latest feasible start of service at node ηℓ for a label ℓ whose parent label is ℓ′. The valueb˜ℓis given bymin{bηℓ,ldℓηℓ−n(b˜ℓ′)}if ηℓ ∈ D andbηℓotherwise. Then, a valid dominance rule for SPminmaxis as follows:Proposition 4(Dom-SPminmax) A feasible label ℓ1dominates a label ℓ2if(24)ηℓ1=ηℓ2,c˜ℓ1≤c˜ℓ2,tℓ1≤tℓ2,Oℓ1⊆Oℓ2,and(25)ed¯ℓ1i(t)≤edℓ2iandld̲ℓ1i(t)≥ldℓ2i(t)∀i∈Oℓ1,t∈[tℓ2,b˜ℓ2].Applying dominance rule Dom*-SPminmaxrequires the comparison of different functions in inequalities (25) which is clearly not practicable for general functions within a labeling algorithm. The following lemma characterizes the shape of the functionsed¯ℓi(t),ldℓi(t),andld̲ℓi(t)allowing for a simplified version of Dom*-SPminmax.Lemma 2LetXbe the set of allX=(x1,…,xq)∈Rqsatisfying(26)ai≤xi≤bi∀i=1,…,q,(27)xi+cij≤xj∀j=2,…,q;i<j,(28)xi+dij≥xj∀j=2,…,q;i<j,with real-valued constants ai, bi, cij, and dij. DenoteX(t)={X∈X:xq≤t},t∈R. Let also bex¯i=maxX∈X{xi},x̲i=minX∈X{xi},x¯i(t)=maxX∈X(t){xi},andx̲i(t)=minX∈X(t){xi}. Furthermore, define byXS̲(t)={X∈X(t):xi≤x̲i(t)∀i∈S̲}and byXS¯(t)={X∈X(t):xi≥x¯i(t)∀i∈S¯}withS̲,S¯⊆{1,…,q}. Denotex¯iS̲(t)=maxX∈XS̲(t){xi}andx̲iS¯(t)=minX∈XS¯(t){xi}. Finally, let t*be the smallest t withX(t)≠⌀. Then, the following properties hold:1.x¯i(t)=min{ki1,ki2+t}for alli=1,…,q,t≥t*with constantski1andki2.x̲i(t)=x̲ifor alli=1,…,q,t≥t*.x¯iS̲(t)=min{ki1,ki2+t}for alli=1,…,q,t≥t*with constantski1andki2.x̲iS¯(t)=max{ki1,min{ki2,ki3+t}}for alli=1,…,q,t≥t*with constantski1,ki2,andki3.Clearly, the scheduling problem (1)–(4) of SPminmaxis a special case of the constraint system (26)–(28) considered in Lemma 2. Thus, the functionsed¯ℓi(t),ldℓi(t),andld̲ℓi(t)are of the formsed¯ℓi(t)=max{ki1,min{ki2,ki3+t}},ldℓi(t)=min{ki4,ki5+t},andld̲ℓi(t)=min{ki6,ki7+t},where allki·are constants. Herewith, the comparison of the functions in Dom*-SPminmaxcan be reduced to comparing them at two distinct points of time. Denote byB̲ℓiandB¯ℓithe points of time such thatld̲ℓi(t)=ld̲ℓi(B̲ℓi)anded¯ℓi(t′)=ed¯ℓi(B¯ℓi)holds for allt≥B̲ℓiandt′≥B¯ℓi,respectively. Then, the following dominance rule for SPminmaxresults:Proposition 5(Dom-SPminmax) A feasible label ℓ1dominates a label ℓ2if(29)ηℓ1=ηℓ2,c˜ℓ1≤c˜ℓ2,tℓ1≤tℓ2,Oℓ1⊆Oℓ2,(30)ed¯ℓ1i(tℓ1)≤edℓ2ianded¯ℓ1i(B¯ℓ1i)−max{0,B¯ℓ1i−b˜ℓ2}≤edℓ2i∀i∈Oℓ1,and(31)ld̲ℓ1i(tℓ1)+(tℓ2−tℓ1)≥ldℓ2i(tℓ2)andld̲ℓ2i(B̲ℓ1i)≥ldℓ2i(Bℓ2i)∀i∈Oℓ1.Note that for determining valid boundsed¯ℓhiandld̲ℓhion the earliest and latest delivery times of request hithat do not restrict the pickup times of other open requests hj∈ Oℓ∖{hi}, it is generally not necessary to consider the maximum and minimum valuesτ¯jandτjfor the starts of service at the nodes hj. Instead, it is sufficient to ensure that all hjcan be delivered at their earliest or latest possible delivery timesedℓhjandldℓhj. These times induce starting the service not later thanedℓhj−L̲hj≥τ̲jand not earlier thanldℓhj−L̲hj≤τ¯j. Hence, bounds that are stronger thaned¯ℓiandld̲ℓican be obtained enabling more dominance when used in Dom-SPminmax. For simplicity of notation and exposition this has been disregarded in the derivation of Dom-SPminmax. All proofs, however, are analog.Dom-SPminmaxcan further be strengthened by using a concept proposed by Gschwind and Irnich (2015) for Dom-SPmax. Let ℓ be the parent label of ℓ′. The informationedℓiandldℓion the feasible delivery times of open requests i ∈ Oℓ can be used to determine an upper bound on the start of service at nodeηℓ′for whichPℓ′can be completed to a feasible0−(2n+1)-path. This bound, which is generally smaller thanb˜ℓ′,strengthens the dominance relation in Dom-SPminmax(see Section 4.6 in Gschwind & Irnich, 2015 for details).The basic course of our labeling algorithm with Dom-SPminmaxfor solving SPminmaxis identical to those in Sections 3.1–3.3. When creating a new label ℓ′, the resourcesηℓ′,c˜ℓ′,lℓ′,andOℓ′are updated using the REFs (13) and (14). The earliest start of servicetℓ′is set according to the adapted REF (21).Determining the values of the resources related to feasible delivery times of open requestsi∈Oℓ′is intricate. Because of the simultaneous handling of minimum and maximum ride-time constraints, the information on the earliest and latest delivery is interdependent. As a consequence, the determination of these values is much more complex than in the isolated cases in SPmin and SPmax. The key problems are the following: When creating a new label ℓ′, the implied scheduling problem has additional constraints compared to the scheduling problem implied by the parent label ℓ. These constraints impose bounds on the start of service at the current nodeηℓ′that may restrict other service times within the schedule. The impact on these service times may further propagate throughout the constraint system (see proofs of Proposition 4 and Lemma 2) so that their effect on the earliest and latest pickup times at the open requestsi∈Oℓ′is non-trivial to identify. Moreover, if the extended label ℓ′ ends at a delivery nodeηℓ′∈D,then the corresponding requestηℓ−nis no longer open. For all open requestshi∈Oℓ′,this reduces the set of requests whose latest and earliest service times have to be taken into account when determining the boundsτ̲iOandτ¯iO,respectively. Thus, the relation between the resource valuesed¯ℓ′i(tℓ′),ed¯ℓ′i(B¯ℓ′i),ld̲ℓ′i(tℓ′),andld̲ℓ′i(B̲ℓ′i)withi∈Oℓ′and the corresponding valuesed¯ℓi(tℓ),ed¯ℓi(B¯ℓi),ld̲ℓi(tℓ),andld̲ℓi(B̲ℓi)of the parent label ℓ is highly complex.As a result, we were not able to derive simple update formulas for the resources related to feasible delivery times of open requests. We suspect that if there are REFs for these resources carrying along several auxiliary resources needed for the calculations is necessary. It also seems mandatory for the computation of these resources to know the actual node sequencePℓ′represented by label ℓ′.In our algorithm, the earliest and latest delivery times are computed from scratch within each label. To do so, we use a generalized version of the feasibility test of Tang, Kong, Lau, and Ip (2010) for the DARP to obtain a feasible schedule with early-as-possible service times for all nodes which provides the valuesedℓ′i,i∈Oℓ′. Starting from this schedule, we repeatedly delay the service at distinct nodes to obtain the remaining delivery times. This is done using the concept of forward time slack originally introduced by Savelsbergh (1992) for the TSPTW. Note that it is not necessary to consider the complete pathPℓ′for these computations. Instead, it is sufficient to take into account the subpath between the node at which the vehicle was empty for the last time and the current nodeηℓ′. For technical details on the adapted feasibility test of Tang et al. (2010) and the adapted version of the forward time slack we refer to a companion paper (Gschwind, 2015).The elimination of labels with no feasible completion to node2n+1makes use of both the earliest possible delivery timesedℓiand the latest possible delivery timesldℓi. With this information, the label elimination strategy is very effective.This section summarizes the computational experiments that we have conducted to compare the performance of the four different branch-and-cut-and-price approaches to the SPDP.In the following, we briefly describe the main components of the basic branch-and-cut-and-price algorithm. Based on this algorithm, we devise our four different integer column-generation approaches to the SPDP. Each of the approaches formulates the master problem on a different variable set implying subproblem SP, SPmin, SPmax, or SPminmax. The subproblems are solved using the respective labeling algorithms of Sections 3.1–3.4.Time-window tightening and arc elimination is performed according to the rules proposed by Desrochers et al. (1992), Dumas et al. (1991), and Cordeau (2006) for the VRPTW or tailored to the PDPTW or the DARP. The integration of minimum and maximum ride-time constraints into these rules is straightforward.To speed up the column-generation process, heuristics can be used to identify negative reduced-cost columns fast. When the heuristics are unable to find additional columns, one has to resort to an exact method to solve the subproblem. In our algorithms, we tried two straightforward pricing problem heuristics. The first is to solve a more relaxed subproblem, e.g., solving SP when actually having to solve SPmax, and to drop all routes that are infeasible for the actual subproblem. The other is to solve the subproblem on a reduced network only. Preliminary computational tests indicated that the benefits from using these heuristics were rather limited for all algorithms.In our branch-and-cut-and-price algorithms, we use the following types of valid inequalities: 2-path inequalities (Kohl, Desrosiers, Madsen, Solomon, & Soumis, 1999), rounded capacity inequalities in a form proposed by Ropke and Cordeau (2009) for the PDPTW, fork inequalities (Ropke, Cordeau, & Laporte, 2007), and two different liftings of IPEC introduced by Ascheuer, Fischetti, and Grötschel (2000) for the TSPTW and Cordeau (2006) for the DARP. Heuristic separation procedures proposed by Ropke and Cordeau (2009) are used to separate 2-path inequalities, rounded capacity inequalities, and fork inequalities. For the exact separation of the lifted IPEC we use a straightforward enumeration procedure (see Ascheuer et al., 2000). SPDP-feasibility of an integer solution obtained by approaches using a relaxed variable set Ω′ is, thus, guaranteed by the lifted IPEC.A hierarchical branching scheme is used to obtain integer solutions in our algorithms. We first branch on the number of vehicles, if fractional. We then branch on the outflow of a node set of cardinality two. Both branching rules are enforced by adding a single linear constraint to the master problem. The structure of the subproblems remains unchanged. The branch-and-bound tree is explored with a best-first strategy and no upper bounds are given to the algorithm.All algorithms described in this paper were implemented in C++ using CPLEX 12.2 as LP-solver. Arc costs and travel times are computed with double precision. The experiments were performed on a standard PC with an Intel(R) Core(TM) i7-2600 at 3.4 gigahertz with 16 gigabyte main memory using a single thread only. The time limit was set to one hour.The test instances used in the computational study are all based on the benchmark set for the DARP originally introduced by Cordeau (2006) and later extended by instances with larger problem sizes by Ropke et al. (2007). For a detailed description of these instances and their generation we refer to Cordeau (2006).The DARP benchmark set consists of random Euclidean instances with problem sizes reaching from two vehicles and 16 customer requests to eight vehicles and 96 customer requests. Additional larger instances with up to ten vehicles and 120 customer requests were generated in the same fashion as the DARP instances. All these instances are characterized by small vehicle capacities and narrow time windows. To also consider harder instances in which these constraints are less restrictive, three new instances were constructed from each original instance by enlarging both capacities and time-window lengths by factors of 4/3, 5/3, and 6/3.In the original benchmark set, there are two subsets of instances (type a and type b) with different characteristics regarding customer demand and vehicle capacity. Moreover, the maximum ride times are specified by a fixed valueL¯for each subset and are identical for all requests and all instances of the given subset. In the way the instances are constructed (the time windows are specified either for the pickup or the delivery node of a request) the maximum ride-time constraint of each request is always restrictive, independent of how small or largeL¯is chosen. Specifying the minimum ride times analogously, i.e., setting them to one identical valueLfor each request raises the following issue: if the valueLis chosen small, the minimum ride-time constraints of many requests are redundant because the direct travel time between pickup and delivery node of the request is already larger thanL. IfLis chosen large enough so that none of the minimum ride-time constraints is redundant, many instances of the benchmark become infeasible. We, therefore, chose not to use fixed values for the ride times in our test instances. Instead, we modeled both maximum and minimum ride times for each request proportional to the direct travel time between pickup and delivery node of a request so that none of the ride time constraints is redundant a priori. As a result, it is assured that none of the ride-time constraints is redundant, which in our opinion provides the fairest benchmark for the comparison of the different algorithms. Moreover, it allows us in a good way to create instances with different characteristics regarding the tightness of the ride-time constraints. More precisely, in our instances the maximum ride time of a request is equal to the product of the direct travel time and a random number chosen according to a uniform distribution over a given interval. We considered the two intervals [2.25, 2.75] (for more restrictive maximum ride times) and [2.75, 3.25] (for less restrictive maximum ride times). The minimum ride times were specified in a similar fashion using the intervals [1.75, 2.25] and [1.25, 1.75] for generating instances with more restrictive and less restrictive minimum ride times, respectively.The complete benchmark comprises 864 instances labeled in the form RT-TW-iK-n, where n denotes the number of requests, K denotes the number of vehicles, andi∈{a,b}denotes the subset the instance originates from. Moreover,TW=Arefers to the original instances with small vehicle capacities and time-window lengths, whileTW=B,TW=CandTW=Ddenote the instances in which these values have been enlarged by factor 4/3, 5/3, and 6/3, respectively. The characteristics regarding ride times are specified byRT∈{MM,ML,LM,LL},where M and L indicate the more restrictive and less restrictive cases, respectively, while the first character refers to minimum ride times and the second character refers to maximum ride times. Note that some of the small instances are infeasible in the presence of minimum and maximum ride-time constraints. We allowed the use of additional vehicles to obtain well-defined instances in these cases. All instances are available at http://logistik.bwl.uni-mainz.de/Dateien/SPDP.zip.Table 3summarizes our results averaged over all benchmark instances. Tables 4and 5present averaged results for the subclasses A, B, C, D and MM, LM, ML, MM, respectively. In each table, we also report the results averaged only over the larger instances with n > 80 requests. More detailed results can be found in Tables B.1–B.8 in Appendix B in the online supplement of this paper. The columns of the tables have the following meaning:Treenumber of optimal solutions (opt), average computation time in seconds (t (seconds)), and average percentage integrality gap (percent gap) of the respective branch-and-cut-and-price algorithmnumber of optimal solutions (opt) and average percentage integrality gap (percent gap) in the root nodeaverage percentage time spent for the solution of the subproblem (sp), separation (sep), and reoptimization of the master program (lp)number of solved branch-and-bound nodes (nd) and subproblems (sp)number of generated columns (col) and cuts (cut)The results in Table 3 indicate that algorithms IMPminmaxand IMP-Imax are clearly superior to IMP-Imin and IMP-I. The overall performance of the two stronger approaches IMPminmaxand IMP-Imax is comparable. In total, IMPminmaxis able to solve 786 out of the 864 instances to optimality, four more than IMP-Imax. Both approaches solve 127 out of the 192 instances with n > 80. Regarding computation times, IMP-Iminmaxis on average also slightly faster than IMP-Imax. Algorithm IMP-Imin is inferior to both of the former approaches regarding number of solved instances, computation times and remaining integrality gap. IMP-I performs even worse on all these numbers.The superiority of IMPminmaxand IMP-Imax over IMP-Imin and IMP-I can be attributed to the following reasons. First, the root node lower bounds of IMPminmaxand IMP-Imax are significantly stronger resulting in smaller search trees for these approaches. Second, for IMP-Imin and IMP-I substantially more cuts are added to the master programs severely complicating their reoptimization. This is also the reason why the average number of solved nodes is smaller for approaches IMP-Imin and IMP-I compared to approach IMP-Imax. While IMP-Imax explores a huge number of nodes when solving difficult instances, algorithms IMP-Imin and IMP-I spend a lot of time reoptimizing the master programs and, thus, can solve only few nodes within the time limit. When comparing instances solved by all approaches, the number of explored nodes is indeed much higher for approaches IMP-Imin and IMP-I.The more disaggregated results in Tables 4 and 5 indicate that all findings from the overall results regarding the performance of the different approaches do also hold for all subclasses of instances. This means that the characteristics of the ride-time constraints have only limited influence on the relation of the strengths of the considered algorithms. This is also true for vehicle capacity, customer demands, and time-window lengths.Another interesting result of our experiments is that handling the maximum ride-time constraints in the subproblem seems to be more important than integrating the minimum ride times into the subproblem. Our interpretation is that the minimum ride-time constraints are often satisfied without explicitly considering them for the following reasons: When the time windows are narrow, many customer requests are picked up at their origin node i at time ai. In these cases, the time-window tightening rules ensure that the minimum ride times are respected. With wide time windows, on the other hand, several other customer nodes are often visited in between the pickup and delivery of a request. This increases the ride times of the respective request compared to the direct travel times so that the minimum ride-time constraints might already be satisfied.

@&#CONCLUSIONS@&#
