@&#MAIN-TITLE@&#
Descendants, ancestors, children and parent: A set-based approach to efficiently address XPath primitives

@&#HIGHLIGHTS@&#
Set-based access to XML data.Improved XPath primitive operations.Up to eight orders of magnitude speed-up.

@&#KEYPHRASES@&#
In-memory XPath processing,NESTOR,Set-based data models,Data structures,

@&#ABSTRACT@&#
XML is a pervasive technology for representing and accessing semi-structured data. XPath is the standard language for navigational queries on XML documents and there is a growing demand for its efficient processing.In order to increase the efficiency in executing four navigational XML query primitives, namely descendants, ancestors, children and parent, we introduce a new paradigm where traditional approaches based on the efficient traversing of nodes and edges to reconstruct the requested subtrees are replaced by a brand new one based on basic set operations which allow us to directly return the desired subtree, avoiding to create it passing through nodes and edges.Our solution stems from the NEsted SeTs for Object hieRarchies (NEASTOR) formal model, which makes use of set-inclusion relations for representing and providing access to hierarchical data. We define in-memory efficient data structures to implement NESTOR, we develop algorithms to perform the descendants, ancestors, children and parent query primitives and we study their computational complexity.We conduct an extensive experimental evaluation by using several datasets: digital archives (EAD collections), INEX 2009 Wikipedia collection, and two widely-used synthetic datasets (XMark and XGen). We show that NESTOR-based data structures and query primitives consistently outperform state-of-the-art solutions for XPath processing at execution time and they are competitive in terms of both memory occupation and pre-processing time.

@&#INTRODUCTION@&#
The eXtensible Markup Language(XML) (W3C, 2006; 2008) is the standard technology for semi-structured data representation, processing, and exchange and it has been widely used and studied in several fields of computer science, such as databases, information retrieval, digital libraries, and the Web.An XML document is a hierarchy which contains elements nested one inside another and it is naturally modeled as a tree, where elements are nodes and parent-child relations are edges among them. When it comes to process and access XML, fundamental operations rely on the retrieval of a subset of the XML nodes or the data contained in them by satisfying path constraints which are typically expressed in the XML Path Language (Xpath) (W3C, 1999a, 2010a).Given the performance demands of XML processing and the complexity of XPath (Mathis et al., 2015), efficient path queries which involve navigation and subtree reconstruction—i.e., the backbone of XPath—are required in order to speed-up the access to XML data and to develop efficient end-services. Several solutions have been proposed over time to improve efficiency in processing XML path queries and all of them resort to focus on navigational aspects in some sense: use of secondary indexes to speed-up tree navigation and node selection (Chandrasekar et al., 2009; Liu et al., 2008; Wang et al., 2005); node labeling techniques to avoid expensive joins and recursion arising from navigation in the tree representation produced by shredding XML into relation tables (Alkhatib & Scholl, 2009; Cohen et al., 2010; O’Neil et al., 2004); and, alternative methods to parse and navigate in-memory DOM trees (Wang et al., 2007).In this paper we propose a paradigm shift for XPath querying by departing from the above mentioned navigational-like approaches and introducing a brand new one, relying on basic set operations. Instead of using edges between nodes or adjacency matrices for representing a tree, we represent a hierarchy as a family of nested sets where the inclusion relationship among sets allows us to express parent/child relations and each set contains the elements belonging to a specific sub-hierarchy. In this way, rather than navigating in a tree and reconstructing sub-hierarchies by traversing nodes and edges, we answer queries by serving the correct subset(s) which already contain all the requested elements (sub-hierarchy) just in one shot or may request minimal intersection/union operations to obtain the desired elements, thus avoiding the need to collect them one-by-one as it happens in the other approaches. This method provides a sizeable improvement in the time requested for answering a navigational query and it is competitive in terms of space occupation and pre-processing time.More in detail, the proposed solution is based on the NEsted SeTs for Object hieRarchies (NEASTOR) formal model (Ferro & Silvello, 2013) which is an alternative way, based on the notion of set-inclusion, for representing and dealing with hierarchical data, as XML is. Since XPath supports a number of powerful modalities and many applications do not need to use the full language but exploit only some fragments (Benedikt et al., 2005a, 2005b; Gottlob et al., 2003, 2005), we focused this work only on those XPath fragments which, according to Benedikt et al. (2005a): (i) support both downward and upward navigation; (ii) are recursive, thus allowing navigation also along the ancestor and descendant axes and not only parent and child axes; and (iii) are non-qualified, i.e. without predicates testing properties of another expression. Therefore, we focus on efficient in-memory execution of four kinds of navigational queries over hierarchical data—descendants, ancestors, children, and parent of a given element—which represent a basic means for accessing and retrieving data from XML.The original contributions of the paper consist of the in-memory data structures and algorithms needed to instantiate the NESTOR formal model and perform the navigational queries listed above as well as a thorough experimentation against state-of-the-art solutions.We present three alternative in-memory dictionary-based data structures instantiating the NESTOR model: Direct Data Structure(DDS), Inverse Data Structure(IDS), and Hybrid Data Structure(HDS). For each query primitive we have two different modalities: the set-wise modality where we access the structure of the XML tree and the element-wise modality where we access the content of the XML tree. These data structures are defined with no assumption on document characteristics and underlying physical storage and they could be employed by any existing solutions for speeding-up XPath primitives execution. For each data structure and modality, we define algorithms for performing the descendants, ancestors, children, and parent operations and we study their computational complexity.We compare the four target query primitives against state-of-the-art in-memory implementations of XPath—three java-based solutions (i.e., Xalan, Jaxen and JXPath) based on in-memory DOM navigation and a highly-efficient native XML database management system based on node labeling (i.e., BaseX)—in order to assess the benefits in terms of faster execution times. For experimentation, we used three different datasets adopted in the digital libraries, information retrieval and database fields respectively:•Digital archives: the main characteristic of archives lies in their hierarchical structure used to retain the context of the archival records. Encoded Archival Description(EAD) (Pitti, 1999) is an XML-based representation of archives used to provide access to archival data. We have chosen digital archives since they are a challenging domain within digital libraries, which requires the use of all the four target query primitives and consist of deeply nested XML files.Collaborative knowledge: Wikipedia is a mass collaboration effort for the creation and spreading of knowledge (Fallis, 2008). The INitiative for the Evaluation of XML Retrieval(INEX) (Baeza-Yates et al., 2006; Fuhr & Lalmas, 2005) prepared in 2009 the INEX Wikipedia Collection (Schenkel et al., 2007), an XML-ified and semantically-enriched version of the English Wikipedia. The 2009 INEX Wikipedia collection has been considerably exploited to investigate several aspects of XML retrieval, including mixing content-oriented and structure-oriented queries as well as focusing on efficiency (Beckers et al., 2010; Geva et al., 2009; Schenkel & Theobald, 2009). This domain only focuses on the descendants query primitive.Synthetic data: since we have a focus on efficiency, synthetic data allow us to investigate how the proposed data structures and query primitives behave when accessing XML files several orders of magnitude larger than those typically found in the two previous cases and XML trees with increasing complexity in terms of depth and the average and maximum number of children of a node, i.e. the node fan-out. We use two synthetic datasets widely adopted in the database field: XMark and XGen.The experimental findings show that the NESTOR-based data structures and query primitives consistently outperform state-of-the-art XPath solutions at query time and are competitive also from the pre-processing time and main memory occupation viewpoints. From the results achieved the set-based approach proves to be highly efficient and can represent a valid alternative to tree navigation for fast XML querying.NESTOR data structures and query primitives, as well as the code for conducting the experiments, have been implemented in Java and, to ease reproducibility of the results, they are available as open source at the following address: http://nestor.dei.unipd.it/.The rest of the paper is organized as follows. Section 2 provides relevant background information; Section 3 describes the NESTOR data structures and the realization of the set-based query primitives; Section 4 discusses the experimental setup while Sections 5 and 6 present the experimental outcomes. Finally, Section 7 draws some conclusions and provides an outlook for future work.

@&#CONCLUSIONS@&#
In this paper we presented a brand new approach to address XML query primitives relying on basic set operations. This represents a paradigm shift with respect to the navigational-like approaches widely studied and employed in the past. The approach we proposed is based on the NESTOR formal model which represents hierarchical relationships between the nodes of a tree as inclusion dependencies between sets. We implemented the model by means of three alternative in-memory data structures—Direct Data Structure(DDS), Inverse Data Structure(IDS), and Hybrid Data Structure(HDS)—with the ultimate goal of enabling more efficient access to XML data. On top of these data structures we developed the descendants, ancestors, children and parent XML query primitives showing how they can exploit the characteristics of each data structure to limit and, in several cases, to completely avoid tree navigation and subtree reconstruction and studying the computational complexity.In particular, we have experimentally shown that NESTOR data structures allow us to outperform state-of-the-art solutions and, on real datasets, they may even perform better than their theoretical worst-case complexity. For example, DDS descendants element-wise and IDS ancestors element-wise primitives are answered in constant time without requiring navigation, recursion or subtree reconstruction; whereas, in several other cases the operations rely on highly-efficient lookups plus set-based operations (intersection and union) between arrays of integers. In the majority of cases—see HDS element-wise and DDS set-wise primitives—the set-based operations can be executed very efficiently, whereas, in just very few cases—e.g. the IDS children element-wise primitive and the IDS descendants element-wise primitive—set-theoretical operations can be quite demanding thus leading to higher execution times.The choice of the NESTOR data structure to be used depends on the application being considered. We have seen that in the digital archives context HDS is the best choice if all the four query primitives are equally frequent since it is highly effective (even though not always the best) for all the tested cases; on the other hand, if the ancestors element-wise primitive is highly used as it may happen in an application that has to recreate the archival context of a given unit and thus has to return all the elements from a leaf of the XML tree to the root, then IDS is the best choice by far.The collaborative knowledge domain based on the Wikipedia INEX collection presents us with a specific context where all the XML queries are based on the descendants element-wise primitive. In this context, DDS is the best choice being optimized for returning all the descendant elements of a node in constant time without requiring any additional operations. Some of the INEX topics require to execute set-operations (i.e. unions and intersections) between the result sets of several descendants element-wise primitive operations and also in these cases we have seen that DDS is the most effective solution given that set-theoretical operations can be performed quite efficiently.The evaluation conducted on synthetic datasets allows us to pinpoint that NESTOR primitives scale up well when the size, the depth, the max fan-out and the total number of nodes of an XML document grow. Indeed, for all the considered XML documents and for all the four query primitives at least one of the NESTOR data structures performs better that any other alternative solution.Therefore, the experimental results confirm that for XPath primitives NESTOR-based data structures outperform consolidated and state-of-the-art solutions, such as BaseX or the best performing Java XPath libraries. From the pre-processing time point-of-view NESTOR data structure are highly competitive with the other solutions and in particular HDS proves to be the fastest one for the collaborative knowledge. From the space occupation perspective, HDS is the best solution for the digital archive and the collaborative knowledge domains while for big XML files with many nodes and fixed depth (i.e. XMark files) BaseX is the best solution optimizing the storage for XML documents with many nodes containing few data.Many interesting extensions can be explored as future work, some of which are briefly discussed in the following.Set-theoretical operations (unions and intersections) are particularly well-suited for being optimized by graphical processors (Che et al., 2008; Owens et al., 2007) and thus they could be executed very efficiently without requiring any significant change in the NESTOR data structures. NESTOR data structures have not been optimized for space occupation as, for example, BaseX is. Therefore, an interesting future work is to investigate the adoption of some compression techniques to improve on space occupation and to understand their impact on and trade-off with execution time. In this line of reasoning we plan to explore the use of minimal hash functions (Botelho et al., 2007; Chazelle et al., 2004) in place of hash tables, since they are used for efficient storage and fast retrieval. Indeed, these functions can be used within the data structures we presented here without requiring any changes in their specification.The application of efficient algorithms developed in the context of formal concept mining (Kuznetsov & Obiedkov, 2002) to the NESTOR operations represents another viable research direction that may lead to an improvement of average performances of the presented algorithms.We plan to explore the efficiency of NESTOR data structures with respect to the full set of XPath operations, such as XPath predicates, in order to address the whole classification of XPath fragments of (Benedikt et al., 2005a). This work should then be complemented with the formal definition of creation, deletion and update operations on XML via NESTOR, the study of their properties and their experimental evaluation in order to have a fully-fledged management suite for XML based on the NESTOR approach that can efficiently deal also with dynamic and incremental XML.We plan to investigate secondary memory representations of NESTOR in order to develop new query primitives and to compare with ready-to-use secondary memory-based solutions.Finally, when it comes to further possible application domains of NESTOR, it would be interesting to explore how keyword-based access to (semi-)structured data (Bergamaschi et al., 2015) can benefit from the performance improvements and the efficiency gains provided by NESTOR in order to deal with the massive and heterogeneous amount of data these systems are faced with.