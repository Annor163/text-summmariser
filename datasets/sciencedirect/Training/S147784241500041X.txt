@&#MAIN-TITLE@&#
On the verification of architectural reconfigurations

@&#HIGHLIGHTS@&#
Describes approach to ensure fundamental principles of a system in reconfigurations.Specifies principles as constraints in an architectural description language.Translates constraints into a two-layer graded hybrid logic.Derives interpretation models from specifications of architectures and reconfigurations.Provides equivalence and refinement notions to compare reconfigurations.

@&#KEYPHRASES@&#
Architectural reconfiguration,Architectural description language,Modal logic,Graded hybrid logic,

@&#ABSTRACT@&#
In a reconfigurable system, the response to contextual or internal change may trigger reconfiguration events which, on their turn, activate scripts that change the system׳s architecture at runtime. To be safe, however, such reconfigurations are expected to obey the fundamental principles originally specified by its architect. This paper introduces an approach to ensure that such principles are observed along reconfigurations by verifying them against concrete specifications in a suitable logic. Architectures, reconfiguration scripts, and principles are specified in Archery, an architectural description language with formal semantics. Principles are encoded as constraints, which become formulas of a two-layer graded hybrid logic, where the upper layer restricts reconfigurations, and the lower layer constrains the resulting configurations. Constraints are verified by translating them into logic formulas, which are interpreted over models derived from Archery specifications of architectures and reconfigurations. Suitable notions of bisimulation and refinement, to which the architect may resort to compare configurations, are given, and their relationship with modal validity is discussed.

@&#INTRODUCTION@&#
The purpose of dynamic architectural reconfiguration [1] is to maintain the quality level of a system as contextual or internal conditions vary. This is primarily achieved through a combination of sensors, which somehow measure the system, and actuators, i.e., scripts which modify the system׳s architecture under specified situations. Reconfigurations, however, may disrupt the basic design principles, originally fixed by the architectural patterns in use. Therefore, a mechanism is required to ensure that emerging reconfigurations conform to the design principles, regardless of how they take place.This paper introduces an approach to provide such a mechanism. It focuses on reconfigurations that constitute undesired sequences of change, or that lead to forbidden configurations. Design principles are specified as formulas in a modal logic, and then are verified against models of reconfigurations. For this, we extend an architectural description language (ADL) [2] called Archery[3,4], which is a domain specific language[5] used to animate, analyse and verify system׳s architectures. It is organized as a core and a number of modules. The core is for modelling architectures in terms of architectural patterns, and the modules are for specifying constraints and reconfiguration scripts. A constraint restricts either structure, behaviour or possible reconfigurations of a system. Reconfiguration scripts are executed by a configuration manager when conditions, specified as constraints, hold. The language semantics is given by a translation into a process algebra [3], for the behavioural part, and by an encoding into bigraphical reactive systems [4], for the structural part. Constraints are translated into a modal logic and are verified against models derived from architectural specifications [6–8]. We extend Archery׳s syntax and the underlying mathematical framework to support models and properties of reconfigurations.The underlying logic proposed here is a two-layer graded hybrid logic. As usual in modal logic, models are relational structures over a state space (whose elements are called worlds, states, or points). Being hybrid, the logic is equipped with both nominals and a reference operator. The former is a proposition that is only satisfied at the world it identifies. The latter constrains a formula to hold at the world named by a specified nominal. Together they make possible to express, for instance, that two worlds are identical, or that their relationship is irreflexive. Other features of the logic are its hierarchical character [9], which enforce two layers of description, the use of graded modalities to describe the cardinality of relations, and operations to select and iterate over a set of relations. Hierarchical formulas allow us to describe models organized into layers of abstraction, which result from the common practice of refining a world into a more elaborated model. Data parameters are also allowed in relations.Notions of simulation and bisimulation are introduced for models of this logic. They provide refinement and equivalence relations, respectively, in order to discuss whether a script can replace, or be interchanged, with another.Global properties of the logic are studied. Reconfiguration scripts are said to be equivalent if, and only if, they satisfy the same formulas. Preservation of modal equivalence by bisimilarity is proved, and a full Hennessy–Milner like theorem arises for the non-graded fragment.In this context, the contributions of the article are an ADL to define two-level constraints whose first level describes reconfigurations and the second, the resulting configurations; the characterization of the associated logic as well as of suitable notions of model bisimulation and refinement; a derivation of models from architectural specifications; and finally a translation that takes constraints and yields a formula in the two-layer graded hybrid logic. Behavioural constraints and triggers are not dealt here; the interested reader is referred to the first author forthcoming thesis [10].The approach proposed here is illustrated with a fragment of the blood transfusion process, the architecture of a medical procedure which is critical in the sense that it may involve risk to patients [11]. In particular, it requires ensuring blood compatibility between the donor and the patient, since an incompatible transfusion can cause a reaction with fatal consequences. A major source of these incidents is misidentification, which might occur at stages of the process that require checking patient׳s identity, or handling material with patient identification data. Architectural principles are laid down to prevent misidentification, and the approach is used to verify them.Organization: After describing the blood transfusion example in Section 2, a background summary of the Archerylanguage is provided in Section 3, Section 4 presents the logic, introduces bisimulation and refinement relations, and studies their properties. Section 5 introduces the derivation of models, the translation of constraints, and illustrates the approach with the verification of some constraints from the example. Then Section 6 describes related work, and Section 7 sums up and mentions ongoing and future work.The example process starts after a blood transfusion is prescribed to a patient and ends when the patient is discharged. The procedure is supported by a software system, accessed through mobile devices by the involved staff that includes a physician, nurses, and the administration. It requires collecting a blood sample from the patient, establishing blood group and factor, selecting suitable blood units, performing the actual transfusion, and monitoring the patient for a given period of time. The patient is discharged when such period ends without any adverse reaction being observed. Fig. 1depicts an example configuration using an informal notation, in which white rectangles represent components, small grey rectangles, ports, and arrows, interactions. It includes a patient (pat), a physician (phy), two nurses (n1 and n2), and the administration (adm).The staff, however, may change during the procedure. Nurses can enter (leave, resp.) the ward, and can be assigned (unassigned, resp.) to (from, resp.) a blood transfusion patient. These changes must avoid configurations in which a misidentification is more likely to occur, and proceed under the supervision of the administration.Consider, for instance, the sequence of reconfigurations represented by the transition system on the left of Fig. 2that substitutes nurse n2 with n3. We focus on configurationsc0,c3,c5, and c7, which are refined into (informal) architectural diagrams on the right. Configuration c0 is similar to that described in Fig. 1. In configuration c3, a nurse (n3) has entered the ward and checked in with administration, the latter represented by the two connections between n3 and adm. Then, nurse n2 is unassigned from patient pat, which is represented in c5 by the absence of connections between them. Subsequently, nurse n3 is assigned to the patient and the result is shown in configuration c7. The sequence finalizes with nurse n2 leaving the ward (removed from the configuration).Several architectural principles are defined to prevent configurations in which a misidentification might occur. It is requested that a physician and at least two nurses are assigned to each patient undergoing a blood transfusion. The physician orders and monitors the procedure, one nurse leads it, and the other assists the former to prevent a misidentification. Then, it must be kept invariant in every configuration that any patient must have (S1) a designated physician; and (S2) at least two nurses assigned. Changes, on the other hand, must observe the following constraints: (R1) upon entering a ward, a nurse must check-in with administration before receiving any patient assignment; (R2 ) a nurse cannot be unassigned from a patient if less than two nurses are left assigned; and (R3) a nurse must have no assignments before checking out with administration and leaving.In the example, configuration c5 does not satisfy S2. We use reconfiguration constraints to ensure that changes observe these requirements, and avoid error-prone situations.The specification of an architecture comprises one or more (architectural) patterns, a main architecture, and data specifications. A pattern defines (architectural) elements (components and connectors) and might have associated constraints (see syntax in Fig. 3). For instance, pattern Ward defines elements Patient, Physician, Nurse, and Administration in Listing 1 to represent configurations that carry out blood transfusions.Listing 1Blood transfusion pattern.Each element includes an interface that contains one or more ports, each of which is defined by a polarity, a port type, and a name. The polarity indicates how communication among attached ports flows, and can be either inor out. Ports are synchronous: actually a suitable process algebra expression can be used to emulate any other port behaviour. The port type indicates how many participants are necessary for a communication to take place, and can be either and, xor, or or. While an andport requires all attached participants to synchronise, a xorport requires exactly one. In between, an interaction with an orport requires at least one, but it may include any number of participants. For instance, the interface of Administration defines xorports patI and patO. An element can optionally include a behaviour: a set of actions, and a set of process descriptions expressed in a subset of themCRL2process algebra. The sequel focuses on the structural dimension and excludes such behavioural specifications.Instances – architectures and element instances – are defined according to the syntax in Fig. 4. They are stored in variables that are defined by an identifier and a type that must match an element or pattern name. See, for instance, line 1 of Listing 2. Allowed values are instances of a type (element or pattern), that do not necessarily need to match the variable׳s own type.Listing 2A configuration for performing a blood transfusion.An architecture describes the configuration a set of instances adopt. It contains a token that must match a pattern name, a set of variables, an optional set of attachments, and an optional interface. The type of each variable in the set is limited to an element in the pattern the architecture is instance of. An attachment indicates which output port communicates with which input port; each includes port references to an output and to an input port. A port reference is an ordered pair of identifiers: the first one matching a variable identifier, and the second matching a port of the variable׳s instance. For instance, the attachments in the example configuration connect two nurses with a patient and the administration. The architecture interface is a set of one or more port renamings. Each port renaming contains a port reference and a token with the external name of the port. Ports not included in this set are not visible from the outside. An architecture can have associated constraints, which are defined as described in Section 3.3.Reconfiguration scripts are sequences of operations that affect the structure of architectures. Configuration managers execute them when the associated triggering conditions are met. They also have the ability to stop, reconfigure, and restart architectures from a given state.Reconfiguration operations are devoted to the creation and removal of instances, attachments, renamings and variables, as well as to the movement of instances. Table 1shows name, format, and a brief description of them.Scripts that change configurations by performing a blood transfusion are shown in Listing 3. Moving a Nurse (instance) into a Ward (configuration) represents allowing the nurse in. Attaching a Nurse to Administration materializes checking the nurse in. Similarly, if the attachment is to a Patient, it represents assigning the nurse to the patient. These scripts are triggered by constraints that describe behaviour the participants show.Listing 3Reconfiguration scripts for nurse management.For instance, the sequence of reconfigurations shown in Fig. 2 is the result of executing such scripts as follows:•enter(w,n3) lets nurse n3 in,checkIn(n3,adm) checks n3 in (conf. c3),unassign(pat,n2) unassigns nurse n2 from the patient (conf. c5),assign(pat,n2) assigns n2 to the patient (conf. c5), andleave(n2) lets nurse n2 out of the ward.The constraint language allows us to precisely describe design decisions by associating constraints to a pattern, or to a pattern instance [7]. A constraint restricts design dimensions – structure, behaviour, or reconfigurations – through one or more formula declarations (see Fig. 5).The language for declaring formulas is defined generically. The actual languages are instances of it, obtained by making constructs specific to the design dimension that is intended to be restricted. We present the generic language and instances for specifying both (i) constraints over structure; and (ii) two-layer constraints whose upper and lower layers restrict reconfigurations and obtained structures.A formula is interpreted from a local and internal point of view over a modelM– a labelled graph whose nodes W are called worlds. Each edge is labelled by a modal symbol M, taken from a set Mod. A modal symbol identifies an accessibility relationR[M]inW×W, where an ordered pair(w1,w2)indicates that it is possible to access w2 from w1 through an edge with label M. Formulas are interpreted at a specific world withinM. But note that in a two-layer modelM, there is a modelM′associated to each w inM.Actual models are derived from specifications of architectures and their reconfigurations. The resulting graphs correspond to a metamodel given by the dimension being restricted [12]. The two corresponding metamodels are presented as a class diagram, and define the structure of such graphs. The diagrams present the types of nodes and how their instances are related. Modal symbols (relation labels in the diagram) name relations between either constituents of an architecture, or two configurations, where the second is obtained upon executing an operation to the first, in a reconfiguration sequence. In the latter case, a syntax for the structure of symbols, which represent the execution of reconfiguration operations, is also provided.The language provides symbol termsSymTto match symbols according to their structure. They are built upon atomic symbols and filters. A filter is either a path identifying a configuration variable, a configuration variable type, a variable for configuration variables, or a port identifier. Actual atomic symbols and filter combinations depend on the language instantiation.Symbol formulasSymFallow for selecting and operating upon sets of symbols, and binding variables in symbol terms (see Fig. 6). A symbol formula can be either a symbol term, a constant, a negated symbol formula, a conjunction, a disjunction, or a quantifier. Constantstrueandfalserepresent the universe (Mod) and the empty sets, respectively. Negation, conjunction and disjunction represent the corresponding set operations of complement, intersection and union. Quantifiers bind configuration variables in filters. A type in a filter is a simplified version of an existential quantifier. The relations that aSymFselects are calledSymF-relations.Formula declarations consist of an identifier, optional configuration parameters, and a formula (see Fig. 7). Configuration parameters are used to let pass identifiers of configuration variables to a formula.A formulaFis either a propositional formula, a modal formula, a graded modality formula, a hybrid formula, a quantifier, or a nested formula. Propositional, modal, and graded formulas describe the model in terms of the underlying metamodel. A proposition characterizes a feature in a given world. Modal and graded operators scan worlds according to accessibility relations passed as a parameter in the form of a relation formulaRelF.Relation formulas combine relations. A relation formulaRelFis either a symbol formula, a concatenation, a union, or an iteration. A concatenation returns the composition of two relations, and a union their union. An iteration is the successive concatenation of relations defined by a relation formula. There are two types: one that admits the absence of the relation, and one that requires at least one occurrence of it.In a modal formula, a possibly formula〈RelF〉Findicates that the present world isRelF-relatedwith another world satisfying (formula)F, whereas a necessarily formula[RelF]Findicates that anyRelF-relationshipfrom the present world leads to a world satisfyingF.Similarly, graded modality formulas come in two flavours as well. An at least formula〈n,RelF〉Fthat is satisfied at worlds whereFholds in at least n+1RelF-relatedworlds, and an all but formula[n,RelF]Fthat describes worlds whereFholds in all but at most nRelF-relatedworlds.Hybrid formulas are built of a nominalI, which is satisfied if the current world is the unique world referenced by suchI, and of a reference operatoratIF, satisfied if at the world named byI,Fis.A nested formula consists of an identifier, and actual configuration parameters, and describes nested models. The usage of configuration parameters by nested constraints depends on the restricted dimension. Language instances vary in the constructs they offer, as it is indicated on their introduction.Models for interpreting structural constraints are derived from architectures, according to the metamodel shown in Fig. 8. Worlds are instances, ports, actions, variables, port references, attachments, names, and renamings. The relationships among worlds conform the relations in function R, and their labels become plain atomic modal symbols ASYM. For convenience, the extra symbols attdand evtare also included. The former identifies the relationship between two worlds representing variables connected through an attachment. It is obtained asR[vref]○○R[strt]○○R[end]○R[vref], whereR[s]○denotes the converse of a relation. The latter is obtained asR[prt]∪R[act].Propositions are classified as follows: (a) Naming propositions that hold when evaluated at a (world) w representing an action or port with their name. They exist for each name used in actions and ports. (b) Meta-type propositions that hold when w belongs to a specific participant set, e.g., PatternInstance. (c) Emptiness proposition (namely Empty) that holds when w is a variable with no associated instance. (d) Type propositions that test if w is an instance or a variable of a type in the specification. For example, the Ward pattern generates propositions Ward, Physician, Patient, Nurse, and Administration.Each variable in an architectural specification defines a nominal in the set Nom. Each nominal holds exactly at the world that represents the corresponding variable. In addition, they are also included in a subset NomTYPE, depending on the variable׳s type. Variables and parameters in formulas are bound to nominals.Structural constraints that specify requirements S1 and S2 are shown in Listing 4. In both cases, a parameter p receives a nominal referencing (a world that represents) a patient. The first constraint requires the specific patient to have an attached physician. It uses a reference operator that holds if the rest of the constraint holds at the patient. This happens when a physician is attached to the patient in the configuration, which is indicated with a possibly operator for the relation that attachments in configurations give rise to. The second constraint requires the patient to have at least two nurses assigned. The at least operator is used in this case to indicate that a number of nurses, greater than one, are expected to be attached to the patient.Listing 4Nurses per patient.Interpretation models for reconfiguration constraints have two layers. Each world represents a configuration and has an associated model for interpreting nested structural constraints. Relationships represent reconfiguration operations.The metamodel for reconfigurations consists of a single type and a reflexive relation (see Fig. 9). The type represents configurations that an architecture may adopt, and the reflexive relation stands for a family of relations among configurations. An ordered pair of configurations is in one of such relations whenever a reconfiguration operation leads from the first to the second configuration. Relation labels vary according to the operation and to its parameters. Then, worlds and symbols of the model correspond to configurations and reconfiguration operations, respectively.Reconfiguration constraints exclude nominals, and redefine symbol terms to yield symbols that represent actual reconfiguration operations. Symbol terms consist of an operation name and filters, according to the syntax shown in Fig. 10, allowing us to match operation invocations (see Table 1).The reconfiguration constraint in Listing 5 specifies restriction R1 that ensures that a nurse first checks-in and then receives patient assignments. Assume the initial configuration in Listing 2, and a nurse in a variable n3. A sequence of script executions will not satisfy the constraint if it allows the nurse in, and assigns the nurse to a patient, without checking the nurse in.Listing 5No assignment before check-in.Reconfiguration constraint in Listing 6 specifies R2. It ensures that any sequence of scripts that unassigns a nurse leaves enough assigned. Again, assume that a sequence of scripts are triggered replacing nurse n2 with nurse n3 in the initial configuration, such as in Fig. 2. Since the sequence executes the unassignmet first, it fails to satisfy the constraint, because it leaves the patient with only nurse n1 assigned. Note that the nested constraint only checks the situation of the patient whom nurse has been unassigned.Listing 6All unassigments leave enough nurses assigned to patients.Reconfiguration constraint in Listing 7 checks restriction R3, which ensures that any checkout takes place if the nurse has no patient assigned. It fails if, for instance, in a reconfiguration sequence such as the one in Fig. 2, nurse n2 is checked out without unassigning the patient first.Listing 7No assignments before checking-out.Under some circumstances it is interesting to relax structural constraints during the execution of a sequence of scripts, as long as they hold in the final configuration. For instance, when a patient enters, it may initially not have a physician and nurses assigned to him. The constraint in Listing 8 establishes that properties S1 and S2 must hold whenever a sequence of scripts cannot progress.Listing 8Patients safe configurations.Underlying the semantics of architectural descriptions and reconfigurations in Archery, is a powerful logic enabling the description of two-layer models, the reference to possible states (i.e. configurations) as well as to relations between them and their cardinality. As usual, such relations are denoted by modal symbols.Formulas are called state formulas and are built upon regular formulas that define strings of modal symbols, which in turn are taken from sets given by symbol formulas. Their designation comes from their interpretation as (the) sets of states (in which they hold).Symbol formulas, on the other hand, are interpreted as sets of modal symbols, and built as described in Definition 1. Modal symbols may take a data expression as a parameter, which is either a variable v or a function f with data expressionse,…,eas parameters. Symbol formulas represent sets as follows: an atomic modal symbol m is a singleton set{m}; the symbol⊤is the set Sym of all atomic modal symbols in the model; the negation¬αis the complement of the set given by α; the conjunctionα∧α′is the intersection of the sets given by α andα′; an atomic modal symbol with a data parameter m(e) is the singleton set{m(a)}, where a is the value obtained upon evaluating e; and the universal quantifier∀v:D.αis the union of the sets obtained upon replacing v with each possible a in the set given by α.Definition 1Symbol formulasLetDVarandFuncbe disjoint sets of variables and function symbols, respectively. The set Exp of data expressions is recursively defined byek∋vk∣fk(ek,…,ek)fork∈{0,1}wherevk∈DVarkhas a type Dk, andfk∈Funckhas typeDk×…×Dk→Dk. Let Sym be a set of atomic modal symbols. The set MForm of symbol formulas is recursively defined, fork∈{0,1}, byαk∋mk∣⊤k∣¬αk∣αk∧αk∣mk(e)∣∀vk:Dk.αkwheremk∈Symk.□For simplicity, a single data parameter is used in formulas. Multiple data parameters are obtained through projections of a composite data sort. At each level, the following operators are given by abbreviation:⊥=¬⊤,α∨α=¬(¬α∧¬α),∃v:D.α=¬∀v:D.¬α.Regular formulas are defined according to the grammar in Definition 2. At both levels, their constructs are concatenation (β.β), sum (β+β) and iteration (β⁎), which are interpreted as relational composition, union and transitive reflexive closure, respectively. Additionally, the transitive closure β+ is given byβ.β⁎.Definition 2Regular formulasThe set RForm of regular formulas is recursively defined byβk∋αk∣βk.βk∣βk+βk∣βk⁎fork∈{0,1}whereαk∈MForm.□State formulas are formed according to the grammar in Definition 3. At both levels, a formula is either a nominal (i), a proposition (p), a negation (¬φ), a conjunction (φ∧φ), a possibility (〈β〉φ), a graded possibility (〈n,β〉φ), or local reference (@iφ) to a state I. State formulas describe two-layer models by allowing basic constructs φb1 at level 0.Definition 3State formulasA signature is an n-family of disjoint, possibly empty, sets of symbolsΔ=(Propk,Nomk)k∈{0,1}. The setSForm(Δ)of state formulas is recursively defined asφ0∋φ1b∣i0∣p0∣¬φ0∣φ0∧φ0∣〈β〉0φ0∣〈n,β〉0φ0∣@i0φ0andφ1b∋p1∣i1∣〈β〉1φ1∣〈n,β〉1φ1∣@i1φ1φ1∋i1∣p1∣¬φ1∣φ1∧φ1∣〈β〉1φ1∣〈n,β〉1φ1∣@i1φ1wherepk∈Propk, andik∈Nomkfork∈{0,1}.□Additionally, at both levels, the following constructs are defined by abbreviation:⊥=¬⊤,φ1∨φ2=¬(¬φ1∧¬φ2)φ1→φ2=¬φ1∨φ2,φ1↔φ2=φ1→φ2∧φ2→φ1[β]φ=¬〈β〉¬φ,¬〈n,β〉φ=[n,β]¬φDefinition 42-layer modelA 2-layer modelM∈Model(Δ)is a tupleM=(Mk)k∈{0,1}=(Wk,Qk,Rk,Vk)k∈{0,1}recursively defined as follows:•(Wk)k∈{0,1}are disjoint sets;(Qk)k∈{0,1}are predicates withQ0⊆W0andQ1⊆W0×W1such thatW1={w1:∃w0∈W0.Q0(w0)∧Q1(w0,w1)};(Rk:Modk→Qk×Qk)k∈{0,1}is a pair of functions; and(VkProp,VkNom)k∈{0,1}are pairs of functions:○V0Prop:Prop0→P(W0)andV1Prop:Prop1×Q0→P(W1), andV0Nom:Nom0→W0andV1Nom:Nom1→W1.Let us fix the following notation: expressionm[d↦r]denotes a mapm′in whichm′(d′)=m(d′)for alld′≠dandm′(d)=rotherwise;supp(m)denotes the set of values mapped bymand is called its support.Definition 5SatisfactionLetDdenote the set of values of a variable v of type D, and letv=(vk)k∈{0,1}be a pair of data environments. The value of a data expression is given by a pair of interpretation functions(〚〛k,vk:Exp→Dk)k∈{0,1}given by〚vk〛k,vk≜vk(vk),〚fk(ek,…ek)〛k,vk≜fk(〚ek〛k,vk,…,〚ek〛k,vk),parametric on a data environmentvk:DVark→Dkthat assigns a value to a variable, and such thatvar(ek)⊆supp(vk), wherevar(ek)denotes the variables occurring in an expression ek.The interpretation of a symbol formula is given by a pair of functions(〚〛k,vk:MForm→Modk)k∈{0,1}defined inductively as〚mk(ek)〛k,vk≜{mk(〚ek〛k,vk)},〚⊤k〛k,vk≜Modk〚¬αk〛k,vk≜Modk⧹〚αk〛k,vk,〚αk∧αk〛k,vk≜〚αk〛k,vk∩〚αk〛k,vk〚∀vk:Dk.αk〛k,vk≜⋂a:Dk〚αk〛vk′,wherevk′=vk[v↦a].The interpretation of a regular formula is given by a pair of functions(∥∥k,vk:RForm→Relk)k∈{0,1}defined inductively as follows:∥α∥k,vk≜{(w,w′):(w,w′)∈R[s]forsomes∈〚α〛k,vk}∥βk.βk′∥k,vk≜∥βk∥k,vk○∥βk′∥k,vk∥βk+βk∥k,vk≜∥βk∥k,vk∪∥βk∥k,vk∥β⁎∥k,vk≜∥β∥k,vk⁎whereRelkis the set of all relations inQk×Qk,∥β1∥k,vk○∥β2∥k,vkis a concatenation, and∥β∥k,vk⁎is a transitive reflexive closure.LetMbe a 2-layer model. The satisfaction of state formulas w.r.t. a data environmentvis given by a pair of relations(⊨k)k∈{0,1}defined as follows:(1)M0,v0,w0⊨0φ1biffM1,v1,w1⊨1φ1bandQ1(w0,w1)forsomew1∈W1(2)Mk,vk,wk⊨kikiffwk=VkNom(ik)(3)M0,v0,w0⊨0p0iffw0∈V0Prop(p0)(4)M1,v1,w1⊨1p1iffw1∈V1Prop(p1,w0)andQ1(w0,w1)(5)Mk,vk,wk⊨kφk∧φk′iffMk,vk,wk⊨kφkandMk,vk,wk⊨kφk′(6)Mk,vk,wk⊨k¬φkiffitisfalsethatMk,vk,wk⊨kφk(7)Mk,vk,wk⊨k〈β〉kφkiffMk,vk,vk⊨kφkforsomevr∈Wr,r∈{0,…,k}suchthat((w0,…,wk),(v0,…,vk))∈∥β∥k,vk(8)Mk,vk,wk⊨k〈n,β〉kφkiffn<|{vk:Mk,vk,vk⊨kφkforsomevr∈Wr,r∈{0,…,k}suchthat((w0,…,wk),(v0,…,vk))∈∥β∥k,vk}|(9)Mk,vk,wk⊨k@ikφkiffMk,vk,VkNom(ik)⊨kφkfork∈{0,1}, and eachwr∈Wr,r∈{0,…,k}withQk(w0,…,wk).□Bisimulation offers a basic, actually quite strong, form of equivalence between models of the logic proposed in this section, and consequently between Archeryconfigurations. This section introduces suitable notions of bisimulation and refinement and explores their relationship with logical satisfaction. This leads to a Hennessy–Milner like theorem of broad relevance. We start by recalling what a bisimulation is in the standard (one layer) hybrid modal logic:Definition 6BisimulationLetM=(W,R,V)andM′=(W′,R′,V′)be two hybrid models over the same signature. A bisimulation betweenMandM′consists of a relationZ⊆W×W′such that(Nom)for anyi∈Nom,V(i)ZV′(i),for anyσ∈Prop∪NOM,w∈V(σ)iffw′∈V′(σ);for any positive n, for eachm∈Symand for any n distinctvk∈W,k∈0,…,nsuch(w,vk)∈R[m], there are n distinctvk′∈W′,k∈1,…,n, such that(w′,vk′)∈R′[m]withvkZvk′for anyk∈0,…,n.for any positive n, for eachm∈Symand for any n distinctvk′∈W′,k∈0,…,nsuch(w′,vk′)∈R′[m], there are n distinctvk∈W,k∈1,…,n, such that(w,vk)∈R[m]withvkZvk′for anyk∈0,…,n.A hierarchical bisimulation between two hierarchical modelsM=(Wk,Qk,Rk,Vk)k∈{0,1}andM′=(Wk′,Qk′,Rk′,Vk′)k∈{0,1}consists of a family of relations(Zk⊆Qk×Qk′)k∈{0,1}, such that•for anyk∈{0,1}, Zkis a bisimulation,for anyw0,w0′such thatw0Z0w0′,(i)and for each w1 such that andQ1(w0,w1)there is aw1′such that(10)(w0,w1)Z1(w0′,w1′)and eachw1′such that andQ1′(w0′,w1′)there is a w1 such that (10)The following result establishes bisimulation invariance with respect to the proposed logic.Theorem 1Let Z be a bisimulation between the hierarchical modelsM=(Wk,Qk,Rk,Vk)k∈{0,1}andM′=(Wk′,Qk′,Rk′,Vk′)k∈{0,1},andw∈W,w′∈W′two states such that(w0,w1)Z1(w0′,w1′). Then, for any data environmentvand for any formula φ, we have thatM1,v1,w1⊨1φiffM1′,v1,w1′⊨1φWe start observing that, since both Z1 and Z0 are bisimulations, the invariance of 0-sentences across Z0 and the invariance of 1-sentences across Z1, with the exception of sentences φb1, can be proved as in the standard hybrid modal logic with graded modalities (e.g.[13,14]), by induction over the structure of the sentences. The preservation of the latter comes as follows:M1,v1,w1⊨1φ1b≡{defn.of⊨k}M0,v0,w0⊨0φ1bforsomew1suchthatQ1(w0,w1)≡{step⋆}M0′,v0,w0′⊨0φ1bforsomew1′suchthatQ1′(w0′,w1′)≡{defn.of⊨k}M1′,v1,w1′⊨1φ1bFor step ⋆ note that items (i) and (ii) in Definition 7 assure the existence ofw1∈W1andw1′∈W1′such that(w0,w1)Z1(w0′,w1′). Hence, the equivalence is justified by the invariance result for of hybrid logics with graded modalities.□The existence of a Hennessy–Milner like theorems for the logic is now discussed. For this, let us consider that a hierarchical modelMis image-finite when each of its outer and inner accessibility relations are image-finite, i.e., for eachw∈Wkandm∈Symk, the sets{w′:(w,w′)∈R[m]k},k∈{0,1}, are finite.Actually, for any two image-finite modelsMandM′and for anyw∈Wandw′∈W′we can prove the equivalence of statements:(i)M1,w1⊨1φiffM1′,w1′⊨1φThere is a bisimulationZ⊆W×W′betweenMandM′.Finally we observe that the recent work [15] presents a description logic with graded modalities that is endowed with a bisimulation notion satisfying a Henessy–Milner property. Its ZIG-ZAG correspondence, however, is established by a bijective relation, which is a very strong condition in view of our purposes.We introduce, in this section, a property preserving relation between hierarchical models.Definition 8LetM=(W,R,V)andM′=(W′,R′,V′)be two hybrid models over the same signature. A simulation betweenMandM′consists of a relationS⊆W×W′such that(Nom)for anyi∈Nom,V(i)ZV′(i),for anyσ∈Prop∪NOM, ifw∈V(σ)thenw′∈V′(σ);for any positive n, for eachm∈Symand for any n distinctvk∈W,k∈0,…,nsuch(w,vk)∈R[m], there are n distinctvk′∈W′,k∈1,…,n, such that(w′,vk′)∈R′[m]withvkSvk′for anyk∈0,…,n.A hierarchical refinement between two hierarchical modelsM=(Wk,Qk,Rk,Vk)k∈{0,1}andM′=(Wk′,Qk′,Rk′,Vk′)k∈{0,1}consists of a family of relations(Sk⊆Qk×Qk′)k∈{0,1}, such that•for anyk∈{0,1}, Skis a simulation,for anyw0,w0′such thatw0S0w0′, and for each w1 such that andQ1(w0,w1)there is aw1′such that(w0,w1)S1(w0′,w1′).Next theorem establishes the preservation of properties over across. The proof is omitted since it can be directly derived from the one of Theorem 1. Note however that, since the refinement relation just imposes the directional preservation of the propositions and atomic formulas, the preservation of negation, and consequently of boxes, is lost. Hence,Theorem 2Let S be a refinement relation between the hierarchical modelsM=(Wk,Qk,Rk,Vk)k∈{0,1}andM′=(Wk′,Qk′,Rk′,Vk′)k∈{0,1}andw∈W,w′∈W′two states such that(w0,w1)Z1(w0′,w1′). Then, for any data environmentvand for any formula φ without diamonds and negations, we have thatM1,v1,w1⊨1φimpliesM1′,v1,w1′⊨1φ.Verifying a constraint over a specification requires deriving an interpretation modelMand then translating the constraint into the corresponding logic. The derivation of interpretation models for structural constraints is detailed in Appendix A. On the other hand, the derivation of two-layer models can be found in [10],Reconfiguration constraints become formulas of a 2-layer modal logic. Translations differ on how variables are treated. In structural constraints, variables are bound to nominals. Then, the meaning offorallx:TYPEIDis the conjunction of formulasatxF[x/i], for eachi∈Nomvar:TYPEID, where[x/i]denotes the substitution of x by i inF. Dually, the meaning ofexistsx:TYPEIDFis a disjunction of formulasatxF[x/i], for eachi∈NomTYPEID. Note that in reconfiguration constraints, variables become data variables. The types that a pattern defines become data sorts, configuration variables become values of such sorts, and ports become values of a port data sort. Appendix B provides the precise definition of the translations.To illustrate our approach, we verify now the constraint safeUnassign (in Listing 6) over the sequence of script executions that replaces a nurse, shown in Fig. 2.First, it is shown that the initial configuration satisfies the nested structural constraint enoughNurses (see Listing 4). The result of translating the Archeryspecification of the initial configuration into an interpretation model is shown in Fig. 11. It is partial since instances of administration and physician are omitted. In addition, names (see the metamodel) and their relationships are also dropped. Each node in the graph represents a world and includes an identifier in the first line; the satisfied propositions in the second line; and the satisfied nominals in the third line. A short code is used for the propositions that depend on the pattern: N (Nurse) and Pat (Patient). A short symbol is used to avoid using the longer symbols of propositions: V (Variable), PI (PatternInstance), EI (ElementInstance), P (Port), I (In), O (Out), A (Attachment), R (Renaming), PR (PortReference), Act (Action), and N (Name).The resulting model is simplified into the model shown in Fig. 12(a), by considering the relation attd, which is the only one present in the formula. It does not show worlds representing instances in variables, ports, and attachments.The nested constraint is translated into formula@pat〈1,attd〉Nurse.with the parameter bound to pat, the unique patient in the initial configuration. Its verification proceeds as follows:@pat〈1,attd〉Nurse={by(4)}@pat〈1,attd〉{w2,w4}={by(8)}@pat{w3}={by(9)}WThe formula is satisfied by the initial configuration.In contrast, configuration c5 in Fig. 2 does not. Nurse n2 was unassigned before assigning n3. The derived model is shown in Fig. 12(b) and the verification is as follows:@pat〈1,attd〉Nurse={by(4)}@pat〈1,attd〉{w2,w4,w5}={by(8)}@pat∅={by(9)}∅The model for the sequence of script executions, which is referred as subs0 in the sequel, is partially shown in Fig. 13. Its first level consists of the primitives that result from the execution of subs0, and it shows the nested models for the initial configuration c0 and for the configuration upon the unassignment of the nurse c5.The translation of the reconfiguration constraint safeUnassign, shown in Listing 6, yields formula[⊤⁎.detach(pat,nurO,n2,patI)]ψ(pat),where ψ stands for the formula of constraint enoughNurses. The symbol term is replaced by the only symbol that matches the criteria within the necessity operator. Likewise, the parameter of the nested constraint is fixed to the unique variable of type Patient in the successive configurations. The formula is verified as follows:[⊤⁎.detach(pat,nurO,n2,patI)]ψ(pat)={by[β]φ=¬〈β〉¬φ}¬〈⊤⁎.detach(pat,nurO,n2,patI)〉¬ψ(pat)={by(1)}¬〈⊤⁎.detach(pat,nurO,n2,patI)〉¬(W⧹{c5})={by(6)}¬〈⊤⁎.detach(pat,nurO,n2,patI)〉{c5}={by(7)and〈β.β′〉=〈β〉〈β′〉}¬〈⊤⁎〉{c4}={by(7)and〈β.β′〉=〈β〉〈β′〉fourtimes}¬{c0}={setcomplement}W⧹{c0}Since the result excludes the initial configuration, reconfigurations subs0 fail to satisfy the constraint. On the other hand, the reconfigurations in Fig. 14(a), subs1 in the sequel, satisfy it, as they assign the patient to n3 before unassigning n2. Reconfigurations subs0 and subs1 are not bisimilar, and none of them are refinement of the other.Consider now reconfiguration subs2 in Fig. 14(b). It proceeds as subs1, but offers an optional sequence of operations that the configuration manager can perform. Nurse n4 is let in, and checked in by such additional operations. Reconfigurations subs2 and subs1 are not bisimilar, but subs2 is a refinement of subs1. The relation that satisfies Definition 9 contains pairs(cj,cj′)where cjandcj′are in the interpretation models of subs1 and subs2, respectively, andj∈{0…10}. Since subs2 is a refinement of subs1, Theorem 2 can be applied to avoid verifying constraints already valid in subs1. However, since the constraint we are studying includes diamonds, it is out of the scope of such a theorem, and the verification on subs2 is still required.

@&#CONCLUSIONS@&#
This paper proposes the use of hierarchical constraints to ensure that architectural reconfigurations on a system proceed as expected. Resulting configurations respect system׳s architectural principles, as inherited from the specific architectural pattern adopted or originally fixed by the software architect. The Archerylanguage is used to specify architectures, reconfigurations and constraints. Translations into a two-layer graded hybrid logic are presented, which enable the formal verification of constraints. The approach is illustrated with the verification of architectural principles that must be respected by (re)configurations of a service architecture for the blood transfusion procedure.Ongoing work is concerned with the specification of nested behavioural constraints, the usage of constraints for triggering reconfiguration scripts, and the provision of tool-support for a fragment of the language that excludes nesting, i.e., constraints that can be translated into a graded hybrid logic. Future work, on the other hand, includes the study of tool-support for the whole constraint language, and the development of a comprehensive case study in the context of electronic government.