@&#MAIN-TITLE@&#
A novel and provably secure biometrics-based three-factor remote authentication scheme for mobile client–server networks

@&#HIGHLIGHTS@&#
We point out that Yeh et al.’s scheme is not secure because it has several disadvantages in security.We point out that Khan et al.’s scheme is not secure with some weaknesses.We present a new three-factor scheme based on ECC.We prove our scheme secure with a formal proof and analysis.By comparing with some latest schemes, our scheme is more practical for application due to the security and efficiency.

@&#KEYPHRASES@&#
Three-factor,Biometrics,Formal proof,User anonymity,

@&#ABSTRACT@&#
The biometrics, the password and the storage device are the elements of the three-factor authentication. In 2013, Yeh et al. proposed a three-factor user authentication scheme based on elliptic curve cryptography. However, we find that it has weaknesses including useless user identity, ambiguous process, no session key and no mutual authentication. Also, it cannot resist the user forgery attack and the server spoofing attack. Moreover, Khan et al. propose a fingerprint-based remote authentication scheme with mobile devices. Unfortunately it cannot withstand the user impersonation attack and the De-synchronization attack. Furthermore, the user’s identity cannot be anonymous, either. To overcome the disadvantages, we propose a new three-factor remote authentication scheme and give a formal proof with strong forward security. It could provide the user’s privacy and is secure. Compared to some recent three-factor authentication schemes, our scheme is secure and practical.

@&#INTRODUCTION@&#
Nowadays, network communication develops faster and faster. But it is well-known to everyone that such open environment is insecure. An attacker may use every kind of information he can master to forge a legal user, or at least get useful data from the information. A remote user authentication scheme plays an important role in establishing communication over insecure channels. Researchers have studied two-factor authentication [1–3] schemes using both a password and a memory device for over 20years. Persons who own the two elements at the same time can login the special system. Furthermore, because biometrics recognition becomes a popular issue in the past decades, researchers have developed three-factor remote authentication schemes to enhance the security of network communication. With rapid development of mobile technology, mobile devices like PDAs, mobile cells turn to be the memory devices in authentication schemes. In recent years, many three-factor authentication schemes have been presented [4–17].In 2009, Fan and Lin [4] proposed a three-factor authentication scheme with public-key and symmetric cryptosystems. In 2010, Li and Hwang [5] proposed a three-factor authentication scheme with low computation using only hash function. But Das [6] pointed out that Li-Hwang’s scheme had some design flaws and then presented a new biometrics-based scheme. However, An [7] showed that Das’s scheme had disadvantages like under the impersonation attack and the server spoofing attack. Then a new scheme was proposed after criticizing. Unfortunately Khan and Kumari [8] pointed out that An’s scheme was vulnerable to the password guessing attack and the forgery attack and lacked mutual authentication and user anonymity. User anonymity is an important character in evaluation nowadays. Also, the above schemes in [5–7] do not make the user’s identity hidden in the authentication phase. It is harmful for the users if their identities are exposing to attackers. However, Yeh et al. [9] claimed that design flaws existed in Fan et al.’s scheme and it was under the insider attack. So they presented a new biometrics-based scheme employing elliptic curve cryptosystem(ECC). Unfortunately, we find the scheme has the weaknesses including useless user identity, ambiguous login and authentication process, no session key and no mutual authentication. Furthermore, it could not resist the user impersonation attack.In 2012, Chen et al. [11] proposed a new biometrics-based three-factor authentication scheme with mobile devices. In the same year, Truong et al. [12] claimed that Chen et al.’s scheme was under the replay attack, the forgery attack and without user anonymity. They gave their scheme after analysis. However, Khan et al. [13,18] criticized the above two schemes in [11,12] due to the off-line password guessing attack and so on. Khan et al. proposed a new scheme in [13]. However, we find that this scheme cannot keep user anonymity or strong forward security and is vulnerable to the user impersonation attack. Also, since the collected biometrics cannot be the same in different logins, Khan et al.’s scheme is under the De-synchronization attack. The meaning of this attack is that the relative data during a legal user’s normal authentication process are incongruous. For example, when the user’s biometric information input in the login phase is compared with the original template collected in the registration phase without pre-dealing tools, such as the fuzzy extractor, the attack will happen.Furthermore, in this paper we present a new three-factor user authentication scheme using the mobile device to overcome the weaknesses and prove the scheme secure with a formal security model.The remainder of the paper is organized as follows: Section 2 shows the preliminaries that contain notations used through the paper, some knowledge about ECC, fuzzy extractor and some premises for analyzing the paper. In Sections 3 and 4 we list schemes in [9,13] and point out their disadvantages. Our scheme is showed in Section 5. The formal security proof and security analysis of our scheme are in Sections 6 and 7 respectively. The performance comparison between our scheme and some recent schemes is in Section 8. Finally, the conclusion is in Section 9.The notations are listed below:Ui,IDi,PWi,Bithe i-th user with his identity, password and biometricsS,IDs,x,Qsthe remote server with its identity, private key and public keyAthe adversary/attackerlsthe security length parameter, for hash values and random numbersh(·),h1(·)one-way hash functions:{0,1}∗↦{0,1}lssku,skssession keys generated byUiand S respectivelyEk(·)/Dk(·)the symmetric encryption/decryption function with key k⊕/⊗X-OR/N-OR operationThe elliptic curve equation onE(Fp)is in the form:y2=x3+ax+bmodp, wherea,b∈Fpand4a3+27b2modp≠0. We omitmodpin the latter part.Assumption 1Elliptic curve discrete logarithm problem (ECDLP): given pointsP,Q∈G, it is hard to compute the integerαwhereQ=αP.Elliptic curve Diffie–Hellman problem (ECDHP): given pointsαP,βP∈G, whereα,βare random integers, it is hard to compute the valueαβP.Definition 1Human beings’ biometrics can be extracted nearly uniform random strings via a(M,me,l,τ,∊)fuzzy extractor. A fuzzy extractor includes a pair of randomized processes(Gen,Rep). w is the input biometrics for distribution W on M of min-entropyme.Rb∈{0,1}lis the extracted secret string.Pb∈{0,1}∗is a helper string. Persons may input biometric information with error-tolerance by the fuzzy extractor. Moreover, (1)Gen(w)=(Rb,Pb): The fuzzy extractors make sure that the static distanceSD((Rb,Pb),(Ul,Pb))⩽∊andUldenotes the uniform distribution with l-bit binary strings. (2)Rep(w′,Pb)=Rb: The fuzzy extractors make sure that ifdis(w,w′)⩽τandPb,Rbwere produced by Gen at first,Rep(w′,Pb)=Rb.We list two special cases about the match process.Definition 2(1) The distance between two templates w andw′for the same biometric information is low with high probability. That is to say,Pr[dis(w,w′)⩽τ]⩾1-εfn. Hereεfnis the “false negative” rate. (2) IfW1andW2are biometric information distributions for two persons, the distance between their templatesw1andw2is high with great probability. With a boundτ′>τ,Pr[dis(w1,w2)>τ′]⩾1-εfp.εfpis the ”false positive” rate.Assumption 3Some basic assumptions are illustrated below for analyzing the remote authentication schemes. (1) S’s private key x, hash values and random numbers resists guessing. (2) The collision of the hash function cannot be found in polynomial time. Also, the message encrypted by symmetric encryption algorithm cannot be decrypted by the attackers who do not own the key. (3) According to [4], the three-factor authentication must be secure even if A gets two of the three factors.We show the abilities of the attacker A according to the listed remote three-factor authentication schemes in Section 1.We concentrate on A’s abilities and the corresponding data without considering the way to achieve them. Note that Case (5) is a special point only to describe the character of strong forward security. (1) All users’ passwords are in a finite set and can be guessed by A. (2) A can control the insecure public channel between the users and S, such as eavesdropping, intercepting, creating and modifying any transmitted messages. (3) A may get the memory device from the user and extract information from it [19]. (4) A can know the previous session keys. (5) According to [3], even if A can get all of the user’s and the server’s long-term data, such as information in memory device and the server, and user’s identity, password and biometrics, he still cannot compute the past session keys. If this case is applied, Case (4) never happens.Yeh et al.’s scheme consists of four phases: initiation, registration, login and authentication. They are as follows:S chooses the finite cyclic additional group G generated by a point P with a large prime order n over a finite fieldFpon an elliptic curve. Thenx,Qs=xPandh(·)are selected as S’s private key, the public key and the one-way hash function. At last, S stores x and publishesE(Fp),G,PandQs.1.UientersIDi,PWiandBi, selects a random stringriand computesh(PWi⊕ri)andri⊕Bi. ThenUisendsIDi,h(PWi⊕ri)andri⊕Bito S through a secure channel.After receiving the message fromUi,ScomputesW=h(P⊕h(PWi⊕ri))and storesW,h(·),PandQsinto a smart card and sends it toUivia a secure channel.Uichecks whetherW=h(P⊕h(PWi⊕ri))is right. If it is correct,Uiaccepts the card. Then he stores the sketchσBi(ri)usingBias an encryption key.1.UiinputsPWiand submitsBi∗. The card decryptsσBi∗(ri)and recoversri. Then the card calculatesBBi∗=ri⊕Bi∗.S computes W and verifiesW?=h(P⊕h(PWi⊕ri)). If it is true, S accepts the login request. Otherwise, S rejects it.1.Uichooses a private keyquandNufromBBi∗, and computesQu=quP,Q1=quQsandMu=Nu+Qu+Q1.UimakesQuto be his public key and sendsm1={Q1,Qu,Mu}to S.S computesQ1=xQuandNu′=Mu-Qu-Q1and checksNu′?=Nu. If it is false, S rejects the session.S selects a random pointNsand computesQs′=x′P,Ts=Nu′+Qs+Q1andMs=Ns+Qs+Q1+Nu′. Then S sendsm2={Ts,Ms,Qs′}to S.UichecksNu?=Ts-Qs′-Q1. If it is true, S is authenticated. ThenUicomputesNs′=Ms-Qs-Q1-Nu′andL=Ns′+Qu+Q1and sends L to S.S checksNs?=L-Qu-Q1. If it is true, S acceptsUi’s login request.Moreover, in Section 5.2.4 of Yeh et al.’s paper, there is a password change phase. We also list the process here.Uiselects a new passwordPWinewand sendsIDi,h(PWinew⊕ri)andri⊕Bito S. S computesWnew=h(P⊕h(PWinew⊕ri))and replaces W withWnewinUi’s smart card.We illustrate the weakness as follows: (1) The userUionly inputsPWiandBi∗in the login phase.IDiis useless because it is not used. (2) In the login phase, no information is transmitted to S. We doubt how to validate W on the server side. In the registration phase, S only stores W into the smart card but not in itself. So it knows neither W norh(PWi⊕ri∗). So step 2 of the login phase cannot be done. (3) At the beginning of authentication,Uicomputes his public keyQu. It is wasteful to compute a constant in every authentication. (4) In step 2 of Authentication, S checksNu′?=Nuafter computingNu′. It is strange becauseUidoes not sendNuto S. (5) In step 3 of Authentication, S computesQs′=x′P. In fact, there is no newx′produced by S. We can see thatQs′=Qsin step 4 of Authentication. S need not computeQsagain. Furthermore, it is wasteful to sendQstoUiinm2. (6) In the registration and password change phases,Uisubmitsri⊕Bito S, but S does not do anything referring tori⊕Bi. Sori⊕Biis useless in the two phases.(1) For user impersonation attack: According to Yeh et al.’s scheme,QuisUi’s public key. That is to say,quis always the same number. Similarly,Q1=quxPis constant, too. So A can get onem1, generate a random pointNu∗and computeMu∗=Nu∗+Qu+Q1. The forgedm1∗={Q1,Qu,Mu∗}appears. After A getsm2={Ts,Ms,Qs′},L=Ms-Qs-Q1-(Ts-Qs-Q1)=Ms-Tscan be calculated and sent to S. Until now the user impersonation attack is finished. (2) For server spoofing attack: If A getsm1={Q1,Qu,Mu}, it is easy to computeNu=Mu-Qu-Q1from the message. Then he could calculateTs=Nu+Qs+Q1and select a random pointNs∗. FinallyMs=Ns∗+Qs+Q1+Nuand a messagem2∗={Ts,Ms,Qs}can be generated. So the server spoofing attack is successful.There is no session key formed at the end of the authentication. That will make it easy for A to pretend to be one entity and eavesdrop the content in the following part of the session. Also, according to the last item, A can forge all the messages in the channel. So this scheme does not reach mutual authentication.Khan et al.’s scheme has four phases: registration, login, mutual authentication and session key agreement and password change. The password change phase does not relate to the attacks, so we omit it here. Furthermore, in this scheme,IDsis a secret identity only known by S.1.UichoosesIDi,PWiand inputs them with the biometricsBi.Niis a random number. ThenUisubmits the message to S via a secure channel.S generates a random numberei, computes the following data:hpwi=h(PWi∥Ni)⊗Bi,Ci=hpwi⊕h(x∥IDs),Ei=hpwi⊕h(x∥ei∥IDs),Fi=hpwi⊕ei,Ri=h(IDi⊕h(x∥ei∥IDs))⊕hpwiandVi=hh(IDi⊕h(x∥ei∥IDs))(Bi). Then it sendsCi,Ei,Fi,RiandVito the user’s mobile device through a secure channel.Uistores the data and injectsIDi⊕Niinto the mobile device.UiinputsIDi,PWiandBion sensor and the mobile device does the following steps:1.CalculatesNi=(IDi⊕Ni)⊕IDi,hpwi=h(PWi∥Ni)⊗BiandGi=Ri⊕hpwiand checkshGi(Bi)?=Vi. If the equation does not hold, the session terminates.Generates a nonceNuand computes the data:ei=hpwi⊕Fi,C1=Nu⊕Ei⊕hpwi,RCIDi=IDi⊕h(Nu)⊕ei,C2=Fi⊕CiandC3=hGi(Nu∥ei). Then the message{RCIDi,C1,C2,C3}is sent to S.1.S computesei′=C2⊕h(x∥IDs),Nu=C1⊕h(x∥ei′∥IDs)andIDi=RCIDi⊕h(Nu)⊕ei′with checkingIDi. Then it calculatesh(IDi⊕h(x∥ei′∥IDs))and checksC3?=hh(IDi⊕h(x∥ei′∥IDs))(Nu∥ei′). If they are not equal, rejects the session. S generates a nonceNs, computesS1=h(h(IDi⊕h(x∥ei′∥IDs))∥Ns∥Nu∥ei′∥IDi)andD1=Ns⊕ei′and sends{S1,D1}toUi.UicomputesNs=D1⊕eiand checksS1?=h(Gi∥Ns∥Nu∥ei∥IDi). If the equation does not hold, the mobile device rejects the session. Otherwise, it computesS2=h((Ei⊕hpwi)∥Ns∥h(x∥IDs))and sendsS2to S.Uicomputes the session keysku=h(Gi∥Ns∥ei∥IDi∥(Ei⊕hpwi)∥Nu).S checksS2?=h(h(x∥ei′∥IDs)∥Ns∥h(x∥IDs)). If it is right, S calculatessks=h(h(IDi)⊕h(x∥ei′∥IDs)∥Ns∥ei′∥IDi∥h(x∥ei′∥IDs)∥h(x∥IDs)). Otherwise S terminates the session.A registered attacker A can calculateNA=(IDA⊕NA)⊕IDA,hpwA=h(PWA∥NA)⊗BAandh(x∥IDs)=CA⊕hpwAby retrieving(IDA⊕NA)andCAfrom his own mobile device.h(x∥IDs)is used for every registered user. Then if A gets(Ci,Ei,Fi,Ri)fromUi’s mobile device and(RCIDi,C1,C2,C3)fromUiin the public channel and computeshpwi=Ci⊕h(x∥IDs),ei=Fi⊕hpwi,h(x∥ei∥IDs)=Ei⊕hpwi,Gi=h(IDi⊕h(x∥ei∥IDs))=Ri⊕hpwi,Nu=C1⊕Ei⊕hpwiandIDi=RCIDi⊕h(Nu)⊕ei. So A can getUi’s real identityIDiand Khan et al.’s scheme cannot make the users anonymous.After the above operations, A has masteredei,Ei,Ci,Fi,GiandIDi. He can select a random numberNuto produce the message{RCIDi,C1,C2,C3}according to the login steps. Once receiving fromS,Acan computeNs=D1⊕ei.S2is constructed byEi⊕hpwi,Nsandh(x∥IDs).skuis built withGi,Ns,ei,IDi,Ei⊕hpwiandNu. So the whole attack process can be perfectly finished.In each login phase, the mobile device uses the temporary input biometricsBito calculateGi, and checkshGi(Bi)?=Vi. Without the pre-dealing tool, like a fuzzy extractor, the checking is hard to pass and the De-synchronization attack appears.Once A getshpwi,ei,h(x∥IDs),h(x∥ei∥IDs)andh(IDi)⊕h(x∥ei∥IDs), he can calculate every session keyh(Gi∥Ns∥ei∥IDi∥(Ei⊕hpwi)∥Nu)in every session without the long-term secret keys, such as x. So the scheme lacks strong forward security.Our scheme contains five phases: Initialization, Registration, Login, Authentication and Password change. The login and authentication phases are in Fig. 1.S producesE(Fp),Gand P like Yeh et al.’s scheme. But there is no public keyQsandIDsis known in the system.1.A userUichooses his identityIDi, passwordPWiand a nonceri, imprintsBivia a terminal and getsGen(Bi)=(Rbi,Pbi). ThenUisubmitsIDi,Hi=h(PWi∥Rbi)⊕rito S through a secure channel.S chooses a random numberei, computesB1∗=h(IDs∥x∥ei)⊕Hi⊕h(IDi∥ei)andB2∗=h(IDi∥x)⊕Hiand then sendsB1∗,B2∗,PandeitoUivia a secure channel.UicomputesB1=B1∗⊕riandB2=B2∗⊕ri. ThenUistoresB1,B2,P,Pbiandeiinto a mobile device.UiinputsIDi,PWiandBi∗on the terminal. The mobile device selects random numbersα∈Zn∗andui, and computes the data:Rbi=Rep(Bi∗,Pbi),C1=αP,C2=B1⊕h(PWi∥Rbi)⊕h(IDi∥ei)⊕ui,C3=B2⊕h(PWi∥Rbi),C4=h(C1∥C2∥C3∥ei∥ui)andC5=Eui(IDi∥C4). ThenUisends the messagem1={C1,C2,C5,ei}to S.1.Once S receivesm1, it computesui′=h(IDs∥x∥ei)⊕C2, and decryptsC5to getIDi′andC4′. Then it calculatesC3′=h(IDi′∥x)and checksC4′?=h(C1∥C2∥C3′∥ei∥ui′). If it is not right, S rejects the session. If three wrongm1appear in a defined short time,IDiwill be frozen. Otherwise, S does the following step.S chooses random numbersβ∈Zn∗andei‾, and calculates the data:C6=h(IDs∥x∥ei‾)⊕h(IDi′∥x),C7=βP,C8=C2′⊕ei⊕ei‾,C9=h(IDi′∥x)⊕ui′,sks=h1(C1∥C7∥βC1),C10=h(IDi′∥IDs∥C6∥C8∥C9∥sks∥ei‾)andC11=EC9(C6∥C8∥C10). Then S sendsm2={C7,C11}toUi.AfterUireceivesm2, the mobile device computesC9′=C3⊕ui, decryptsC11and getsC6′,C8′andC10′. Then the mobile device calculatesei‾′=C8′⊕C2⊕eiandsku=h1(C1∥C7∥αC7)and checksC10′?=h(IDi∥IDs∥C6′∥C8′∥C9′∥sku∥ei‾′). If the equation does not hold,Uiwill stop the session.The mobile device computeseinew=ei‾′andB1new=C6′⊕C3⊕h(PWi∥Rbi)⊕h(IDi∥einew), and replaceseiandB1witheinewandB1newrespectively.1.Uidoes the Login phase, and sends an extra password change request to S. S does the first step of Authentication. If it is right, S computesSa=h(ui′∥ei∥C3′∥C2∥C1), and sendsSawith a permission toUi. Otherwise, S rejects the request.WhenUireceivesSaand the permission, he first checksSa?=h(ui∥ei∥C3∥C2∥C1). If it is right, he will input a new passwordPWinewand new biometric informationBinewat the same time in the terminal. The mobile device computesGen(Binew)=(Rbinew,Pbinew),B1new2=B1⊕h(PWi∥Rbi)⊕h(PWinew∥Rbinew)andB2new=B2⊕h(PWi∥Rbi)⊕h(PWinew∥Rbinew). Then it replacesB1,B2andPbiwithB1new2,B2newandPbinewrespectively.Based on [20], we prove our scheme with a formal security model. Here we suppose that only a user U and a server S join our protocolP. During the execution ofP,Uand S can have many instances, respectively. Each instance owns a number k and is an oracle. One instance is an execution ofP. We useUkandSkas the k-th instance for U and S, orIkwith no differentiation. An oracle has three possible states: accept, reject or⊥. The oracle reaches the accept state when it receives the correct message. Otherwise it reaches the reject state. If no decision has occurred or no result has been returned, the state⊥appears. Here we omit the three-time limitation in the authentication phase.Before the instances begin, U has registered on S and owns an identity ID, a password PW, his biometrics B and a mobile device includingB1,B2,P,Pband e. S owns the secret key x and an identityIDs. PW is in a dictionary D with quantity∣D∣.According to Section 2.4, the attacker A completely controls the channel, and tries to break the privacy of the authentication processes or the session keys. A can make some styles of queries and get answers.Some definitions are listed to explain the security of the scheme as follows and readers can find the referred queries for our scheme in Table 1.Partnering:UiorSjhas a partnerpidUiorpidSj, a session keyskUiorskSjand a session identitysidUiorsidSjif it is accepted and has formed a session key.UiandSjare partners whenpidUi=Sj,pidSj=Ui,sidUi=sidSjandskUi=skSj.sfs-fresh:Ikissfs-freshwhile any of the following condition does not occur: (1) AReveal(Ik)orReveal(pidIk)appears. (2) ACorrupt(Ik)orCorrupt(pidIk)happens beforeTest(Ik). (3) ForUi, all three kinds ofCorrupt(Ui,z)are asked.sfs-security: We define that the advantage of the adversary A againstPis the probability of correctly guessing the bit b, which is generated in theTest(Ik)query. Also,Ikis accepted andsfs-fresh. If A outputsb′, the advantage is defined asAdvPsfs(A)=2Pr[b=b′]-1. We consider our scheme issfs-secureifAdvPsfs(A)is negligibly greater thanmax{O(qs)(1∣D∣,12l,εfp)}, depending on the security parameterls. Hereqsis the query times ofSend(Ik,m).Moreover, we list two extra computation assumptions.1.Elliptic Curve Decisional Diffie–Hellman (ECDDH) assumption:aP,bPand cP are elements in G. A can decide ifcP=abP.Elliptic Curve Gap Diffie–Hellman (ECGDH) assumption: Given aP and bP in G, the probability of calculating abP with an ECDDH oracle in time t isAdvGECGDH(t).Theorem 1G is a cyclic group on an elliptic curve with order n. D is the password dictionary with size∣D∣. The security lengthlsis for hash values and random numbers. l is the length of extracted biometric secret string andεfpis the probability of “false positive”.Pis our scheme. For any attacker A running with time upper bound t makes Send queries, Execute queries and hash oracle queriesh,h1forqs,qe,qhandqh1times, wheret′=t+O((qe+qs)Tm)andTmis the time of a scalar multiplication in G,(1)AdvPsfs(A)⩽O((qs+qe)2)n-1+O(qh2+qh12+(qs+qe)2)2ls+O(qs+qh+qh1)2ls-1+max2qs1∣D∣,12l,εfp+O((qs+qe)2qh1AdvGECGDH(t′))We define games fromG0toG5andSucciis the event that A guesses the bit b forGiin the test session successfully. According to our model, A need not guess or compute the user’s identity due to only one user. The games are listed as follows:GameG0: This is the real scheme with the random oracle model. We see thatAdvPsfs(A)=2Pr[Succ0]-1. We choose a random bitb′if the game aborts or stops without answers from A or A has not finished the games due to more queries or more time than the upper bounds.GameG1: We simulate all the oracles for queries and use three lists to store the answers to the oracles.Lhstores the answers to hash oracles. But if the random oracles are queried by A, the records are stored inLA.LPis for transcripts between U and S. All oracles are demonstrated in Table 1. Through the simulation,Pr[Succ1]=Pr[Succ0].GameG2: We simulate all oracles in gameG1, but some collisions should be avoided on the transcripts.C1,C7may be the same points ande,e‾and u may be the same random numbers in different transcripts. Also, collisions may happen among hash values. If the above cases occur, the game is aborted.G2andG1are indistinguishable unless the collisions of points, hash values and random numbers appear. According to birthday paradox, we can see that∣Pr[Succ2]-Pr[Succ1]∣⩽O((qs+qe)2)2(n-1)+O(qh2+qh12)2ls+1+O((qs+qe)2)2ls+1.GameG3: In this game, we abort the game if A has luckily calculated correctC5andC11without hash queries. According toC5=Eu(ID∥C4)andC11=EC9(C6∥C8∥C10), it means that A has obtained correctC2,C3,C4,C6,C8,C9andC10. Here we defineK1=h(IDs∥x∥e),K2=h(ID∥x)andK3=h(IDs∥x∥e‾). And we can see:C2=K1⊕u,C3=K2,C4=h(C1∥K1⊕u∥K2∥e),C6=K2⊕K3,C8=K1⊕e⊕e‾,C9=K2⊕uandC10=h(ID∥IDs∥K2⊕K3∥K1⊕e⊕e‾∥K2⊕u∥sk∥e‾).Because e,e‾and u can be selected with no limitation, we can only discussK1,K2,K3,C4andC10. They only appear in Send queries. Some rules in Send queries should be changed to achieve the goal.To respond toSend(Sj,C1,C2,C5,e),Sjshould check if(C1∥K1⊕u∥K2∥e,C4)∈LAand(C1,C2,C5,e)∈LP. If either of them fails, S terminates the game. The probability for this is bounded byO(qs)2ls.Moreover, if a legal user producesK1andK2, he has to ask the hash query(PW∥Rb,∗). Neither PW orRbis known by S. So S cannot check this case and the rules forSend(Sj,C1,C2,C5,e)cannot be changed. Also,(ID∥e,∗)∈LAshould be checked. Third,K1andK2are hash values appearing in the oracle(C1∥K1⊕u∥K2∥e,C4). So the probability for the case is bounded byO(qh)2ls.To respond toSend(Ui,C7,C11),Uishould check if(1,C1∥C7∥∗,∗),(ID∥IDs∥C6′∥C8′∥C9′∥∗∥e‾,C10)∈LAand(C1,C2,C5,e,C7,C11)∈LP. If any of them fails,Uistops the game. The probability is bounded byO(qh1)2lsfor(1,C1∥C7∥∗,∗), andO(qs)2lsfor(ID∥IDs∥C6′∥C8′∥C9′∥∗∥e‾,C10).Furthermore, suppose that A has asked hash queries for(ID∥IDs∥K2⊕K3∥K1⊕e⊕e‾∥K2⊕u∥∗∥e‾,C10), the user should check if(IDs∥∗∥e,K1),(ID∥∗,K2),(IDs∥∗∥e‾,K3)∈LA. If any of them fails, the game aborts. The probability of this case is bounded byO(qh)2ls.The two gamesG3andG2are indistinguishable unless S rejectsC5orUirejectsC11. So we have∣Pr[Succ3]-Pr[Succ2]∣⩽O(qs+qh+qh1)2ls.GameG4: In this game, we bring in the ECGDH problem. If A can get the session keyskuorskssuccessfully and win the game, we claim that we use A to solve the ECGDH problem. From Section 5, anyone can see that if A can compute the session key, he must ask a(1,C1∥C7∥∗)query. Here we denote the query as(1,αP∥βP∥αβP). So theh1(q)query should be modified as follows: Once A queries(1,αP∥βP∥X), we check if(1,αP∥βP∥∗,h1)∈LA. If it exists,h1is the answer. Otherwise, we checkX?=ECDDH(αP,βP)by the ECDDH oracle. If X is wrong, we reject the query. If X is right and the correspondingh1does not exist, we choose a random stringh1∈{0,1}ls, answer A withh1and store(1,αP∥βP∥X,h1)intoLA.According to the previous games, all hash results are random. So A has no advantage in guessing the session key sk in the test session only if A can successfully pass theh1oracle above. We call this event Guessing. Obviously we can see that∣Pr[Succ4]-Pr[Succ3]∣=Pr[Guessing].According to Section 2, the basis of discussing three-factor security is that the adversary can get data for at most two factors. We divide Guessing into two cases: online guessing attack and off-line attack.Case 1: The attacker A can use theCorrupt(Ui,z)query to get two factors before online guessing. If A gets PW and B, he has no way to start queries due to lack of data in the mobile device. SoCorrupt(Ui,1)is necessary for A and two subcases can be divided.Subcase 1: A has also queriedCorrupt(Ui,2)and needs to do online password guessing. He selects a password from D and makesSend(Sj,C1,C2,C5,e)queries. Suppose that the wrong passwords A used are abandoned and the number of them iswrong, the probability that the next password is wrong is bounded by1-1∣D∣-wrongwherewrong⩽qs. A can win in this Subcase with probabilityPr[Subcase1]=1-∏i=0qs-1(1-1∣D∣-i)=qs∣D∣.Subcase 2: A has also queriedCorrupt(Ui,0)and tries to pass the biometrics checking. In fact there are two ways to do this. One is guessingRb, with the probability12leach time. The other is the possible accident ”false positive” case with probabilityεfp. For example, according to [20], it is suitable thatεfp≈2-14. So this Subcase is bounded bymax{qs(12l,εfp)}.Case 2: First A usesCorrupt(Ui,1)to get the information stored in mobile device, then he asksCorrupt(Ui,0)orCorrupt(Ui,2)and sendsExecute(Ui,Sj)and hash oracles. The result of oneExecute(Ui,Sj)can be produced in two ways: one is a pure Execute query; the other is using successive Send queries. We know that A should askh1to win and then the ECGDH problem is broken. We can getαβPfromLAwith the bounded probability1qh1. So we getPr[Case2]⩽O(qh1AdvGECGDH(t′))wheret′=t+O((qe+qs)Tm).We can see thatG4andG3are indistinguishable unless Guessing occurs. So∣Pr[Succ4]-Pr[Succ3]∣⩽max{qs(1∣D∣,12l,εfp)}+O(qh1AdvGECGDH(t′)).GameG5: In this game, we think about the strong forward security mentioned in Section 2. According to the definition ofsfs-fresh,Aonly can askCorrupt(Ik)query afterTest(Ik)query. That means this situation only appears in the old games. For this situation, once A queries for Execute or hash oracles, the answers are selected from old transcripts. We choose two indexesγ,δ∈{1,2…qs+qe}. If the Test query does not corresponding to the case that U and S involved inγ-th query andδ-th query respectively, the game is aborted. According to the last case of GameG4, we can see that∣Pr[Succ5]-Pr[Succ4]∣⩽O((qs+qe)2qh1AdvPECGDH(t′)).After the above discussion, A has no advantage in guessing b. SoPr[Succ5]=12. Combining the above games, Theorem 1 is obtained.□In this Section, we show some concrete reasons to explain the security of our scheme and compare with some recent schemes [9,13–17] in Table 2. We use✓,×and?to denote that the scheme satisfies, does not satisfy and has no relation to the corresponding character.The passwordPWiand the biometric secret stringRbiare both protected by the hash function and a random numberriin the form ofh(PWi∥Rbi)⊕ri. So it can resist this attack. They cannot be got or guessed by the malicious administrator of the server S.We suppose A getsB1,B2,Pi,PbiandeifromUi’s mobile device and the transcription(C1,C2,C5,ei,C7,C11)from the communication channel. To satisfy three-factor security, we suppose A gets two factors ofUi. IfPWiorBiis compromised, A should try for the third one. Let’s analyze the cases. Suppose A knowsRbiviaBiand he aims to guess a passwordPW∗, he may calculateB1⊕h(PWi∥Rbi), which is the front half part ofC2. But he does not knowIDiand cannot guess the random numberui, so the latter part is secure and the password cannot be guessed. Similar situation occurs if A needsBi. So our scheme is not under the off-line guessing attack. Here we notice that the attacker A can obtain basic parameters needed in a session in Khan et al.’s scheme [13] without guessing, so we use?to fill the corresponding blank.As we have explained in Section 7.2, if A knows the information in the mobile device and either of the secret biometric string or password, he cannot guess the third factor. Moreover, our scheme has only three on-line chances for password or biometrics guessing. It is difficult for A to pass the authentication and our scheme keeps three-factor security so that it resists the user impersonation attack.If A wants to forge the messages fromS,xis a necessary element. However, according to our premises, it cannot be obtained. So A cannot calculateh(IDs∥x∥ei),h(IDs∥x∥ei′)orh(IDi∥x)and the scheme resists the server spoofing attack.Unlike Khan et al.’s scheme, our scheme employs the fuzzy extractor to cope with the biometrics. That will guarantee the probability of correct acceptance for legal users. But we find schemes in [15–17] do not employ the pre-dealing tools but cope with the input biometrics in the computation directly.If A gets some session keys luckily, other session keys will not be affected. A cannot calculateαβPfromαPandβPbecause the session keys are built with ECCDH problem. Note that schemes in [16,17] do not have session keys at the end of authentication phase, so we put?in the corresponding blanks in Table 2.In our scheme,IDiis encrypted by a random numberuiin messagem1. A can only obtainuiby calculatingh(IDs∥x∥ei)correctly. But it is difficult for A to get the value without knowing the server’s private key x. So the user’s identity remains anonymous in the session. But in Yeh et al.’s scheme there is no identity referred in transmitted messages in login and authentication and we use?to fill the blank. Also, the user’s identity is in plaintext in [14,17]. In [16], the user sends a stringh(IDi)∥nias a “random identity” in whichniis a value during the registration.h(IDi)is always the same and it could be thought as the user’s identity in the communication channel. We fill the corresponding blanks with×.It is obvious that the user’s password is freely selected by the user himself and there is also a special phase for the user to change the password. Here we point out that there is no password change phase in [16].We can see that in the authentication phase, S andUiboth calculate a session keyh1(αP∥βP∥αβP)based on ECCDH problem. That is opposite to [9,16,17], where no session keys are formed.If A has got all the long-term information of two participants and messages in channel, he still cannot know the previous session keys. It is simply because of the ECCDH problem. However, schemes in [9,16,17] do not have session keys at last, so this character does not exist for them.As we mentioned above, persons may input different biometric information with error-tolerance by the fuzzy extractor practically. Our scheme has the reproduction step for the error-tolerance while schemes in [13,15–17] do not refer that important operation. So our scheme is practical.We compare the time cost, the communication cost, and the transmission times in login and authentication phases, and security with [9,13–17] in this Section. The results are in Table 3.We use SHA1 as the hash function and its value length is 160 bits, same to the random number and the user’s identity. The symmetric encryption algorithm we employ is AES and each of the block is 128bits. The point in ECC group owns two coordinates and each of them is 160bits.Tm,Ta,Ts,ThandTRepare the time cost for one computation of scalar multiplication in G, point addition in G, symmetric encryption/decryption, hash function and biometrical secret string reproduction respectively. From [2],Tm=7.3529ms,Ts=0.1303msandTh=0.0004ms. And we getTa=0.0613mswith the same platform in [2].From Table 3, we can see that: (1) Our scheme is better than [9,15] in time cost. (2) Our scheme is better than [9] for the communication cost. (3) Our scheme uses less transmission times than [9,13,16]. (4) All the other schemes have security disadvantages without formal proof while ours is the only winner in the index “security and formal proof”. So our scheme is the best.

@&#CONCLUSIONS@&#
