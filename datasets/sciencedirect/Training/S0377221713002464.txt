@&#MAIN-TITLE@&#
Branch-and-price for staff rostering: An efficient implementation using generic programming and nested column generation

@&#HIGHLIGHTS@&#
We describe a nested column generation algorithm for staff rostering.We show how generic programming can be used within a column generation implementation.Our resulting system is faster and more flexible than traditional systems.We can obtain good solutions to practical staff rostering problems.

@&#KEYPHRASES@&#
OR in manpower planning,Generic programming,Branch-and-price,Scheduling,Staff rostering,

@&#ABSTRACT@&#
We present a novel generic programming implementation of a column-generation algorithm for the generalized staff rostering problem. The problem is represented as a generalized set partitioning model, which is able to capture commonly occurring problem characteristics given in the literature. Columns of the set partitioning problem are generated dynamically by solving a pricing subproblem, and constraint branching in a branch-and-bound framework is used to enforce integrality. The pricing problem is formulated as a novel three-stage nested shortest path problem with resource constraints that exploits the inherent problem structure. A very efficient implementation of this pricing problem is achieved by using generic programming principles in which careful use of the C++ pre-processor allows the generator to be customized for the target problem at compile-time. As well as decreasing run times, this new approach creates a more flexible modeling framework that is well suited to handling the variety of problems found in staff rostering. Comparison with a more-standard run-time customization approach shows that speedups of around a factor of 20 are achieved using our new approach. The adaption to a new problem is simple and the implementation is automatically adjusted internally according to the new definition. We present results for three practical rostering problems. The approach captures all features of each problem and is able to provide high-quality solutions in less than 15minutes. In two of the three instances, the optimal solution is found within this time frame.

@&#INTRODUCTION@&#
The generalized rostering problem is the problem of generating a feasible high-quality staff schedule (‘roster’) for a group of staff working collectively to provide some service. The roster will specify, for each staff member, the sequence of shifts and days off (termed the ‘roster-line’) to be worked during the roster period. This roster must satisfy pre-specified demand constraints which typically express minimum staffing requirements for individual shifts or time periods, and may include requirements for staff with certain skills or meeting particular contract conditions. The roster-line worked by each staff member is typically strictly governed by laws, union regulations and internal agreements, and has an associated quality measure. These requirements together can make it hard to create feasible rosters, let alone high quality ones.Rosters have traditionally been created manually by the head of the section or by an experienced member of the staff. Often, the rosters were made by modifying former rosters or by putting together roster-lines and parts of roster-lines which were known to be good. It takes a lot of experience to build good rosters and even with experience, the process of building the rosters is very time consuming. Therefore, there has been and still is a large demand for automated rostering tools. Within the last decade the supply of software products has increased significantly to meet this demand.One of the major obstacles to developing rostering software has been the varying requirements from one application to another. As a result, many rostering systems have been custom made to match the exact requirements of a particular company or institution. The main issue with this approach is the time and money needed for development of the system. For the same reason, automated scheduling systems have in the past been reserved for institutions with a large and very apparent need for automation. Our focus here is on developing a flexible but still efficient generic software framework that can be applied to a large variety of rostering problems. The system we have created has to be adapted to a given application, but this adaptation is easy and fast. Hence, using our approach, an effectively tailor-made product can be produced at significantly lower costs than before.Staff rostering has already received a lot of attention in the literature. We refer to the extensive reviews of Burke et al. [11], Ernst et al. [27], and Cheang et al. [13]. Also, Ernst et al. [26] present a massive collection of references to papers on rostering. The EURO Working Group on Automated Timetabling [14] provides a good up-to-date overview of the literature.The solution method presented here builds on the idea of column generation. Column generation is embedded in a branch-and-bound framework resulting in a so called branch-and-price algorithm; for an introduction to column generation, see [18]. Naturally, the literature on column generation solution methods to rostering is of special interest. Jaumard et al. [34] solve a nurse rostering problem using column generation. The subproblem is formulated as a shortest path problem with resource constraints, where each possible shift is represented by a node. It is solved with a two-stage algorithm proposed by the authors. Bard and Purnomo [3] solve a nurse rostering problem with individual preferences for the nurses. Columns are generated by a, so called, double swapping heuristic. High-quality solutions are found within minutes. In Bard and Purnomo [2] the model is extended to allow downgrading of workers with higher level skills. Beliën and Demeulemeester [5] schedule trainees in a hospital using branch-and-price. Interestingly, columns are generated for activities instead of the conventional columns for roster-lines of employees. The described problem of scheduling trainees is somewhat simpler than the generalized rostering problem, and only for this reason, it is possible to use the alternative column generation model. In a succeeding paper by the same authors [6], it is concluded that the activity-decomposed approach does not have the same modeling power. However, if the problem allows this model to be used, the performance may be enhanced by doing so.A column generation approach to the nurse rostering problem is also described by Maenhout and Vanhoucke [40]. The approach has a number of features in common with our approach. The authors describe different pruning and branching strategies, e.g. Lagrangian dual pruning and branching on the residual problem. Beliën and Demeulemeester [7] extend the nurse rostering model to include scheduling of the operating room and show that considerable savings can be made by integrating the two scheduling problems.Eitzen et al. [24] present a set covering model for a crew scheduling problem at a power station. Three column generation based solution methods are proposed to solve the set covering model: the column expansion method, the reduced column subset method, and branch-and-price. In the first, three phases are solved, where the skill set of each employee is gradually enlarged from one phase to the next. In the second, a restricted number of columns are generated randomly with no guarantee on quality. The latter method integrates dynamic column generation and constraint branching in a branch-and-bound framework. Al-Yakoob and Sherali [1] solve a crew rostering problem for a large number of gas stations using a column generation approach. The model takes the individual preferences of the employees into account. A heuristic founded on the column generation algorithm is able to solve realistic problems.In the column generating subproblem presented here, two shortest path problems with resource constraints are solved. Much literature has been published on shortest path problems with resource constraints; Irnich and Desaulniers [32] provides a good literature review. Desrosiers et al. [20] present an early version of the algorithm with time as the only resource, which is generalized by Desrochers [17]. Lübbecke [38] suggests discarding all labels that cannot lead to a column with negative reduced cost. Dumitrescu and Boland [22] introduce a more extensive preprocessing scheme. Righini and Salani [46] present a significant improvement in performance by using bidirectional search. Chabrier [12] utilize an idea on the potential value of each node to improve performance further.The idea behind the generic modeling of rules and preferences that we present is similar to that of an industrial system, described by Kohl and Karisch [36]. The authors describe a modeling tool, which is essentially a rule programming language, where the end user can maintain and modify rules in a flexible way. However, they also explain that the optimization method can only ‘ask’ simple questions about legality and cost.The work presented here is based primarily on the work of Smith [49], Nielsen [44] and Engineer [25]. Smith [49] presents a column generation setup to solve a nurse rostering problem from Middlemore Hospital in Auckland. Following the promising results for this initial application, two projects followed, with the aim of building a generalized rostering framework which would be able to solve various rostering problems. Nielsen [44] describes a general modeling framework for rostering problems. Roster-lines are generated by an enumerative scheme including some constraint programming techniques. The author uses experimental data from Auckland Healthcare. Engineer [25] applies column generation to various rostering problems. He formulates the pricing problem as a three stage nested shortest path problem with resource constraints as described by Mason and Smith [42] and solves it using label setting methods. The algorithm developed proved to be both efficient and versatile enough to allow solution of applications with very different characteristics.Our new approach extends the work of Engineer [25] by exploiting the computer science principle of generic programming. In generic programming, an algorithm abstracts over details, such as particular rostering rules, that are not essential for the design of the algorithm [33]. Generic programming allows ‘a single, generic algorithm [to] realize many concrete implementations’ and ‘provides maximal reusability without sacrificing performance’ [29]. Generic programming is an important growing area within computer science. For example, the Standard Template Library (STL) [30] and the associated Boost library [15] use generic programming to provide significant new capabilities for C++ programmers, while the Microsoft C# language has recently been enhanced to support generic programming. The importance of generic programming is shown by the inclusion of STL within the official C++ ISO standard [31], and the growing availability of generic libraries such as those for matrix manipulation [48], computational geometry [9], image processing [50], and numerical solution algorithms [39,16,52].Edmonds et al. [23] comment that ‘the generic programming paradigm has emerged as an approach for library development that simultaneously meets the needs of flexibility and performance.’ However, despite this growing recognition by the computer science community of the benefits generic programming can offer, applications of generic programming are difficult to find in the operations research (OR) literature. Exceptions include the general purpose Boost library [15], which includes a range of generic graph-based algorithms, and the METSlib Tabu search package [41]. As an example of some OR activity in this area, Edmonds et al. [23] have developed parallel algorithms for the shortest path problem as part of a new Parallel Boost Graph Library [4]. These libraries seek to provide programmers with components to use in their software. Our approach is different, in that we use generic programming to customize a full application to meet the specific needs of the optimization problem being solved. As we will see, generic programming provides us with a faster, more flexible solution approach.The contributions of this paper are a novel column generation algorithm and implementation using generic programming for the generalized rostering problem. Our work represents an important methodological contribution in that it demonstrates, for the first time, how generic programming can be applied within a column generation algorithm for a complex scheduling problem and shows that significant computational benefits can be gained using this new approach. Our modeling framework has proven sufficiently flexible to allow any constraint and cost we have observed in the literature to be modeled in the attribute-based setup. New instances are therefore solved without any modifications to the algorithm. Not only is the method versatile, it is also very efficient in its implementation. In a survey of the literature, Ernst et al. [27] point out that:Another important area requiring further work is generalization of models and methods. Currently, models and algorithms often require significant modification when they are to be transferred to a different application area, or to accommodate changes within an organization.Our approach alleviates exactly this problem in a very efficient way.In Section 2, we define the generalized rostering problem, and give details of our integer programming formulation and an overview of the column generation subproblem. We also discuss the generality of our approach. Our solution method is described in Section 3, and the details of our generic programming implementation are given in Section 4. Following this, an example is presented in Section 5 and computational results for three realistic rostering instances are discussed in Section 6. Finally, our conclusions are presented in Section 7.The inputs to a generalized rostering problem include staff, skills, shifts, and demands. Each shift is defined by a start date, start time and a duration that specifies when staff assigned to this shift will be at work. Each staff member has an associated subset of skills. These skills are combined with shifts to specify demands. For example, the company may specify that 2 or more ‘supervisor’ and/or ‘clinician’ staff shall be on duty from 10am to 12 noon next Tuesday. If the shifts that cover this time period are the Tuesday 8am–8pm ’D’ shift and 6am–2pm ’M’ shift, then this demand is expressed as a lower bound on the number of such shifts worked by staff with the clinician or supervisor skill. The earliest and latest shifts together define the scheduling time horizon of interest. The roster produced as output will specify the roster-line (sequence of shifts and days off) worked by each staff member during the scheduling horizon. We assume each staff member works no more than one shift per day, but nothing prevents the occurence of split shifts in which one shift represents two or more continuous periods at work during a day. A roster is feasible if all demands are satisfied using feasible roster-lines.The generalized rostering problem can be modeled as a generalized binary set partitioning problem. Each column corresponds to a possible roster-line for a certain staff member, while each row corresponds to a demand constraint. Some demands may be defined as soft constraints and a penalty is applied if the demand is not met. The master problem combines the roster-lines in order to meet the demand constraints, while the column generation subproblem must generate feasible roster-lines.The difficulty when modeling rostering problems is typically associated with the generation of high quality feasible roster-lines. As we illustrate in Section 2.3, the rules these roster-lines must satisfy may vary significantly from one problem to another. A column generator must be sufficiently flexible to handle these rules. We now formally define the master problem for which columns are generated.Following the terminology of Desrosiers and Lübbecke [19], we first formulate the ‘integer master problem’ as follows. Given a set of employees,E, and a set of demands,D, the objective of the integer master problem is to find a combination of roster-lines, one for each employee, such that all demands are met at the lowest possible cost (where a low cost corresponds to a high quality). The setReholds all feasible roster-lines for employeee∈E, where the definition of feasible depends on the particular rostering problem being solved. Three sets of decision variables are used.λeris a binary decision variable, whereλer=1if roster-line r is chosen for employee e andλer=0otherwise.sd-is the amount of under-coverage (slack) for demand d. Similarly,sd+is the amount of over-coverage (surplus) for demand d. The amount of permitted under-and over-coverage is regulated by bounds onsd-andsd+, respectively.Three sets of costs apply to the integer master problem.cergives the cost of roster-line r of employee e.cd-andcd+specify the cost of under-and over-coverage for demand d, respectively. Parameteraedrdescribes the roster-lines, withaedr=1if roster-line r of employee e contributes to demand d, andaedr=0otherwise. bdis the demand level to be met. The integer master problem is formulated as:(1)min∑e∈E∑r∈Recerλer+∑d∈Dcd-sd-+∑d∈Dcd+sd+(2)∑r∈Reλer=1∀e∈E(3)∑e∈E∑r∈Reaedrλer+sd--sd+=bd∀d∈D(4)λer∈{0,1}∀e∈E,∀r∈Re(5)0⩽sd-⩽ud-,0⩽sd+⩽ud+∀d∈DThe objective (1) is to minimize the total cost of all roster-lines while also minimizing penalties from under-and over-coverage. A final feasible solution contains one roster-line for each employee (2). All demands must be met or the appropriate slacksd-and surplussd+variables are adjusted accordingly (3)–(5) set the domains of the decision variables, whereud-andud+give the maximum under-and over-coverage permitted in (3).We will be solving this integer master problem using ‘branch-and-price’ in which the integer constraints (4) are relaxed to create the linear programming ‘master problem’. Furthermore, because we will be generating columns during the solution process, we will only have a subset of columns available at any stage. Let the setRe′contain the roster-lines of employee e generated so far. ReplacingRewithRe′in the master problem gives us the ‘restricted master problem’ that we will be solving at each step of our solution process.For any solution of the restricted master problem given byλer,sd-, andsd+, a dual solution exists. Let τebe the dual variables of constraints (2) and similarly, let πdbe the dual variables of constraints (3). If a primal solution does not exist, the dual problem is unbounded and no meaningful dual values can be found. Instead, τe, πddenote a dual ray that gives information on how to restore primal feasibility.The subproblem, also referred to as the pricing problem, generates new columns for the restricted master problem. Given a vector of dual values, the subproblem returns a column with negative reduced cost, if one exists, by solving a resource constrained shortest path problem. Such a column will enter the basis in the restricted master problem and the dual values will be updated. If no additional columns exist, the restricted master problem solution is optimal, and so we have solved the master problem.The subproblem is formulated as a three stage model and follows the setup described by Mason and Smith [42]. A roster-line is considered to be constructed from underlying entities. The association between the entities is illustrated in Fig. 1. A shift entity defines a period of time during which an employee is working. A series of shifts worked in succession (one per day) forms an on-stretch entity. The length of on-stretches may be constrained in terms of minimum and maximum number of hours, shifts, days, etc. A period of one or more days where the employee is not working is referred to as an off-stretch. An on-stretch followed by an off-stretch forms a work-stretch. There are often restrictions on how on-stretches and off-stretches can be combined. Finally, a roster-line consists of a sequence of work-stretches. A roster-line spans the full scheduling horizon and typically has to respect constraints on the total amount of hours worked, the number of weekends worked, etc.Shifts and off-stretches are referred to as simple entities while on-stretches, work-stretches and roster-lines are composite entities. Entities have attributes (also termed resources) which are tracked as the entities are constructed and extended. Attributes of a simple entity are part of the input data, whereas the attributes of a composite entity are calculated when the entity is created, using the attribute values of its component entities. A set of rules, typically stated as bounds on attribute values, define the validity of an entity. These rules should permit the construction of any entity that may occur as part of a legal roster-line. Rules may define hard constraints that must be satisfied or soft constraints for which a penalty (termed an attribute cost) is applied when a rule violation occurs. The attribute values are also used to calculate the cost associated with each entity. The cost of a new entity is calculated using costs derived from the entity’s attribute values and/or costs associated with its component entities. These entity costs may be employee dependent if staff have expressed individual preferences such as shifts requests.Different rules and preferences may apply to each employee; therefore a separate subproblem exists for each of the employees. Given a set of legal shifts,Se, for employee e, a set of feasible on-stretches,Oe, can be found. A set of legal work-stretches,We, is created for all compatible combinations of on-stretches inOeand all legal off-stretches,Fe. By sequencing legal work-stretches, roster-lines are generated and together define the setRe.The objective of the subproblem for employee e is to find the feasible roster-line with the most negative reduced cost or to prove that no roster-line with negative reduced cost exists. For a given employee e, we can compute an effective dual value for each shift by summing the dual values πdof the demandsd∈Dthat are contributed to by this shift when worked by employee e. The reduced cost of any entity can then be computed by subtracting from its cost the sum of the effective duals of the shifts contained in that entity. Off-stretches have fixed costs only, i.e. there are no duals associated with off-stretches. In the case of a roster-line, the dual of the corresponding employee constraint, τe, must also be included. When the subproblem is used to restore primal feasibility in the master problem, the reduced costs are based solely on the values of the dual ray, with all costs being treated as zero.As we discuss next, our use of this structure of nested entities, and the corresponding nested column generator we have developed, allows a computationally efficient expression of a wide range of rules and preferences. The user is free to specify what attributes need to be tracked by each entity type, and how these attribute values are calculated and used to determine the feasibility and/or cost of an entity. The use of nested entities allows the rules and preferences to be expressed where they naturally occur, ensuring that illegal or poor quality entities are rejected early in the column generation process.The extent to which our system can model and solve different rostering problems is limited by the modeling power of the integer master problem and the column generator. As we now discuss, our experience with problems drawn from the literature and from our own industry contacts suggests that this modeling approach, and in particular the nested column generation, can express and efficiently process all common rules and requirements.In a bibliographic survey by Cheang et al. [13] a list of commonly occurring constraints is presented, where the constraints are grouped into 16 different categories. Burke et al. [10] in a similar way list 26 sets of constraints that occur in practical nurse rostering problems. The list is a slight revision of a list originally formulated by Vanden Berghe [51].Furthermore, the work of Bliddal and Tranberg [8], Nielsen [44], Engineer [25] and Poulsen [45] together describe 10 practical problems. These practical problems have been given special attention in this project. From the reports, a number of common characteristics can be found. The problems have a fixed planning period and a fixed set of shifts. Each staff member has individual preferences and their own paid hours targets. Some specific shift transitions are banned and shift assignments may be fixed in advance. These characteristics are all captured by our current model.Each problem has individual rules. To illustrate, a few examples are listed below.•On all days: at least one of the staff members was also there the day before [8].A staff member cannot work two consecutive weekends [45].Minimize the number of different shifts in an on-stretch [45].One week with 60hours or more allows only 16hours the following week [45].If working night shifts, at least two consecutive night shifts must be scheduled [44].These constraints can easily be included in the model using appropriately defined attributes. Indeed, by introducing customized attributes, any of the constraints concerning internal roster-line rules can be implemented. A few rules reported in the literature concern roster-lines of multiple employees, and thus impact the master problem. These can be modeled as extended forms of the demand constraints presented in constraint (3). One such example concerns tutorship, where a ‘student’ employee must be supervised by another ‘tutor’ employee when at work. This can be modeled by introducing additional ‘tutorship’ demands in constraint (3), with zero right-hand sides (bd=0), for those periods when the student can work. Columns in which the student works during some time period haveaedr=-1in the associated tutorship constraint, while columns for employees who can act as a tutor during that time period haveaedr=+1in that constraint. Puttingud-=0andud+=∞then ensures that at least one tutor is on duty whenever the student is at work.With the suggested extensions, the model presented here is able to deal with all the constraints of Cheang et al. [13] and Burke et al. [10] and with all constraints seen in the 10 industry examples mentioned earlier.The restricted master problem as defined in Section 2.1 is an LP-problem and a standard solution tool (like CPLEX) can be applied to solve it. Branching is applied to remove fractional solutions from the solution space of the restricted master problem. In regular branch-and-bound algorithms, variable branching is the method of choice. It is, however, complex and in most cases highly inefficient to apply variable branching in a branch-and-price algorithm. Instead, we use constraint branching where certain constraints are (implicitly) introduced in the current restricted master problem.Here, we use a specialization of the constraint branching method proposed by Ryan and Foster [47]. If the solution of the restricted master problem is fractional, the columns of one or more employees are in the solution with a fractional value. As two columns of an employee are never identical, two fractionally selected columns will differ in at least one of the included shifts. This in turn means that the employee is not assigned to that shift with a value of 1. In a feasible integer solution, employees are always assigned to shifts (with a value of 1) or not assigned to them at all (a value of 0). We may therefore branch on the employee/shift assignment.When branching on an employee/shift assignment, the set of feasible columns of the employee is split into two subsets. One subset contains all columns for that employee in which the shift is included in the roster-line. The other subset contains the remaining columns for that employee. The two branches are created by removing the relevant roster-lines from the first and the second subset, respectively. In a branch-and-price setup, the branching decisions are imposed on new columns by forcing the subproblem of the particular employee to either include or exclude the shifts that have been branched on.During our computational testing (Section 6), we identified a number of strategies that reduced the solution times for our problems. Firstly, the solutions to the linear programming relaxations often satisfy employee preferences to some fractional degree, meaning that some employee has a mix of roster-lines whose costs come from only a few alternative values. Our experiments showed that where there are many possible branching candidates (fractional employee/shift assignments), one should avoid branches in which the banned columns on either side of the branch have similar costs, and instead prefer branches where these costs differ to the greatest degree. This quickly resolves the fractional preference satisfaction and gives an immediate impact on overall cost and/or feasibility. Finally, when solving an LP after branching and/or adding more columns, it was also found to have a positive effect to stop the solution process as soon as the LP value is equal to the lower bound of the root node. Traditionally, generation continues as long as columns with negative reduced cost exist. However, if the LP value is equal to the lower bound, such columns are only included in the basis because of degeneracy in the LP problem and will never decrease the objective value.As discussed in Section 2.2, the column generation subproblem involves the following steps as introduced by Mason and Smith [42].1.Shifts are combined into on-stretches.On-stretches and off-stretches are paired to form work-stretches.Roster-lines are generated by sequencing work-stretches.Our column generator always builds the complex entities by combining two simpler entities. For example, instead of describing an on-stretch by all the shifts it contains, we describe it by its last shift and its ‘parent’ on-stretch which contains all but the last shift in the on-stretch. This is illustrated in Fig. 2. Note that the parent on-stretch may be an infeasible on-stretch, and may be null if the on-stretch contains only one shift. The definition of the composite entities that follows from this approach gives:on-stretch+shift→on-stretchon-stretch+off-stretch→work-stretchroster-line+work-stretch→roster-lineThe three stages give rise to their own resource constrained shortest path problems. Attributes are algorithmically represented by resources. Each of these shortest path problems is solved by dynamic programming using label setting [32], where an entity is labeled using the values calculated for its attributes. Dominance is used to prevent unpromising entities proceeding to the next stage. The dominance rules associated with an attribute form part of the definition of that attribute. Each of these three problems is now addressed in detail.Note that while we give some examples, we do not attempt to list all the resources that occur in the column generation subproblem, nor do we give the formulae by which their values are calculated. While such an approach may be appropriate for a traditional column generation algorithm, our generic programming approach gives the user much greater freedom to define their own attributes and specify the rules by which their values are processed using any valid C++ expressions.The first stage of the column generation algorithm is to generate on-stretches from shifts. Shifts might have costs given by employee preferences, and will have dual values associated with them, as described earlier. There might also be costs associated with shift transitions, while typical attributes to track might include paid hours or the number of undesirable shifts. On-stretches are considered unique if they differ in their start time or end time, or if they have different non-dominated attribute values. We seek all unique minimum reduced cost on-stretches.The on-stretch generation problem is modeled as a shortest path problem with resources in a graph where nodes represent shifts. An example of such a graph is shown in Fig. 3. The graph consists of a node for each shift. Arcs between nodes exist when the two shifts are allowed to be consecutive in an on-stretch, i.e. they can be neither too close nor too far apart in time. To generate all on-stretches the all-to-all shortest paths problem is solved. This is done by solving a one-to-all shortest path problem from each of the nodes in the graph. For each of these problems, the start node is selected and the remaining graph is reduced to only allow on-stretches up to the maximum on-stretch length. Fig. 3 shows the shortest path problem with Node 1 as start node. If the maximum on-stretch length is 4days, all arcs leaving nodes 16–20 are removed.Nodes may be excluded in the graph in order to generate roster-lines without certain shifts. In Fig. 3, shift 10 has been excluded. Shifts may be disallowed if the employee does not have the appropriate skills and employees may simply be restricted from certain shifts as part of the input data for the problem, e.g. it is common to have employees that can never work night shifts or must have days off on particular days.The shortest path problems are solved with a label setting algorithm. The graph is acyclic and has an inherent topological order and the nodes are treated accordingly. All on-stretches are validated by checking the attribute values against the feasibility criterion given in the problem definition, and checks are performed to remove dominated entities (see Section 3.5). All unique non-dominated feasible on-stretches are sent to stage two.The second stage is the simplest of the three. On-stretches from stage one are combined with off-stretches to form work-stretches. The start time of an off-stretch is not specified exactly, but instead an off-stretch start time window is given along with a minimum off-stretch duration in hours. An on-stretch/off-stretch pair is considered compatible if the on-stretch finish time occurs within the off-stretch’s start time window. All compatible on-stretch/off-stretch pairs are constructed, and the resulting work-stretch attribute values are calculated and checked for feasibility. Workstretch costs will often be specified to discourage a long on-stretch being followed by a short off-stretch; these and any other workstretch costs are calculated at this stage. Domination tests are performed (see Section 3.5) to remove unpromising work-stretches before proceeding to the third stage. The second stage is visualized in Fig. 4.The roster-line generation problem is another acyclic shortest path problem with resource constraints. The problem has a node for each day in the horizon. The work-stretches generated in stage two are the transitions between days and hence become the arcs of the graph. Usually, the arc leads to the day after the work-stretch ended.In the generalized rostering problem, we have a predetermined start and end day, and this transfers to a source node and a sink node in the graph. The problem becomes a one-to-one shortest path problem. The labels applied to the end node represent complete roster-lines. Again, roster-line attributes of these roster-lines have to respect the feasibility criterion given in the problem definition. The best feasible roster-line is also the optimal solution to the pricing problem. A visualization of the shortest path problem is given in Fig. 5.For some attributes, it is possible to predict infeasibility prior to reaching the end node. Entities that can never lead to a feasible roster-line or a roster-line with negative reduced cost should be removed, as this results in fewer entities being constructed and hence a more efficient algorithm. We briefly describe the approach we implement below, and refer the reader to Dumitrescu and Boland [22] for a detailed discussion of this area.Our system performs a feasibility analysis for all those roster-line attributes that are additive in the sense that the calculated attribute values are summations over the values in the component entities. Each of these attributes is processed in turn to create bounds that define feasible values for that attribute. We also apply this process to the reduced cost values, which have an imposed upper bound of zero to ensure we find a negative reduced cost column.Let the set of feasible values for an additive attribute a at node i be defined by a lower bound,lbia, and an upper bound,ubia, with initial valueslb^iaandub^ia, respectively, as determined by the problem formulation. Because the roster-line graph is acyclic, the lower boundlbiacan be calculated as the minimum of all node i’s successor lower bounds minus the respective accumulation value of the associated successor arc. An upper bound can be computed in an analogous fashion. Thus letδi+denote the set of outgoing arcs for node i, letvwadenote the value of attribute a associated with arc w, and let each arc w represent a transition from node worig to node wdest. The bounds on an additive attribute a at each node i are then calculated by our system as follows:lbia=maxminw∈δi+lbwdesta-vwa,lb^iaubia=minmaxw∈δi+ubwdesta-vwa,ub^iaIn the same way as bounds can be propagated backwards from the end node, we can also propagate bounds forward. The domain for an additive attribute a at node i is defined by boundsdlia,duia, which are calculated as:dlia=maxminw∈δi-dlworiga+vwa,lbia,duia=minmaxw∈δi-duworiga+vwa,ubiawhereδi-is the set of incoming arcs at node i. These resulting domains can be used to eliminate arcs from the graph. We check all arcs against the value domain of their tail (origin) combined with the feasibile bounds of their head (destination). If, using that arc, none of the values of the domain for any attribute accumulate to values within the computed bounds, then the arc is deleted.This roster-line bounding scheme exploits the nested subproblem structure of our formulation in that the bounds are calculated using the attribute values of the work-stretches generated in the second stage of the nested subproblem. Thus, this nested structure is an essential component of our bounding scheme.Domination is an important concept in all three stages of the subproblem solution algorithm. An entity e1 is said to be dominated by entity e2 if any roster-line containing e1 is worse (or no better) than a new roster-line created by replacing e1 by e2. For example, a 3-day on-stretch O1=S1→S2→S3 containing shifts S1, S2, S3 might be dominated by O2=S1→S4→S3 if S2 and S4 are equivalent in paid hours, but S4 is preferred by the employee. An efficient column generation algorithm must be able to identify and remove dominated entities. In general, entity e1 is dominated by e2 if all e1’s attribute values are equal to, or worse than, e2’s. The definition of ‘equal to or worse than’ is attribute dependent, and thus dominance rules must be specified by the user as part of the user’s attribute definition. Careful attention must be paid to the dominance rules specified for attributes that are used to calculate other attribute values.

@&#CONCLUSIONS@&#
We have successfully implemented a generic programming implementation of a branch-and-price algorithm to solve the generalized rostering problem. The solution approach builds on a general underlying model and hence allows solution of problems with varying characteristics. From the literature and by looking at the rostering problems at hand, it was clear that a solution approach to the generalized rostering problem must be very flexible. At the same time, rostering problems are typically highly constrained and it is often a demanding task to even find feasible solutions. Therefore the solution approach must not only be flexible, but also very efficient.To meet these requirements, we have modeled the problem as a generalized set partitioning problem and built a generic programming branch-and-price algorithm to solve the problem. The pricing problem is solved using an innovative three-stage approach which allows us to exploit the structure inherent in rostering problems, helping make the problem tractable in realistic settings. Using this approach, it is possible to represent in our model all the rostering rules seen in the application of former projects [8,44,25,45], as well as all commonly occurring requirements listed by Cheang et al. [13] and Burke et al. [10].By following generic programming principles, we have developed a new approach for implementing branch-and-price in which we explicitly embed the problem definition in the program code. A separate executable is then created for each new problem definition, ensuring we achieve a high efficiency implementation throughout the algorithm. By embedding the problem definition in the code, we can realize much of the efficiency of a purpose built implementation without incurring the software development costs typically associated with such bespoke work. This also gives a more flexible system in that a user implementing the system can specify rules and attribute calculations using the full power of a programming language instead of being restricted to a set of pre-configured options. In a comparison to a former method, where the customization is included at run-time, a speed up of a factor 20 was observed, demonstrating the value of this new application of generic programming.The value of the algorithm was illustrated for three different rostering applications. The model captures all features of the realistic problems and provides high-quality solutions in less than 15minutes for a scheduling horizon of 4weeks. The greater use of heuristic components can be introduced in the future to allow for additional speedups.Burke et al. [11] state that:The current state of the art is represented by interactive approaches which incorporate problem specific methods and heuristics (that are derived from specific knowledge of the problem and the required constraints) with powerful modern metaheuristics, constraint based approaches and other search methods.We believe that we have provided a viable alternative to these methods. Furthermore, our compile-time customization constitutes a contribution not only to rostering. This approach can be applied to a wide range of optimization problems, and is likely to deliver similar improvements in run time performance.