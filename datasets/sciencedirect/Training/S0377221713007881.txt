@&#MAIN-TITLE@&#
Bicriteria hierarchical optimization of two-machine flow shop scheduling problem with time-dependent deteriorating jobs

@&#HIGHLIGHTS@&#
Examine a two-machine flowshop scheduling problem with deteriorating jobs.Minimize the total completion time subject to minimum makespan.Propose a mixed integer programming and branch-and-bound algorithm for the problem.Discuss dominant conditions and several polynomial-time solvable special cases.Examine the effectiveness and efficiency of the proposed algorithms.

@&#KEYPHRASES@&#
Scheduling,Deteriorating job,Hierarchical optimization,Mixed integer programming,Branch-and-bound,

@&#ABSTRACT@&#
We study a two-machine flowshop scheduling problem with time-dependent deteriorating jobs, i.e. the processing times of jobs are an increasing function of their starting time. The objective is to minimize the total completion time subject to minimum makespan. We propose a mixed integer programming model, and develop two pairwise interchange algorithms and a branch-and-bound procedure to solve the problem while using several dominance conditions to limit the size of the search tree. Several polynomial-time solvable special cases are discussed. Finally, numerical studies are performed to examine the effectiveness and the efficiency of the proposed algorithms.

@&#INTRODUCTION@&#
Machine scheduling problems with time-dependent deteriorating jobs have become an important and interesting topic in recent years. Examples of time-dependent deteriorating jobs often appear in manufacturing settings, such as maintenance jobs, where delay in processing a job often requires extra time to accomplish it. Similarly, when an instrument loses efficiency during work, the job processed later requires more machine time than that of the same job processed earlier. Such phenomenon is called the deteriorating effect. Reviews of scheduling problems with time-dependent deteriorating jobs can be found in Alidaee and Womer (1999), Cheng, Ding, and Lin (2004) and Gawiejnowicz (2008). Specifically, scheduling problem with simple linear deteriorating processing times in a single-machine setting was studied by Mosheiov (1994), who focused on classical performance measures (such as, makespan, and total flow time and sum of weighted completion time) and showed that all these problems are polynomial solvable. Gawiejnowicz, Lee, Lin, and Wu (2011) studied a single-machine scheduling problem with job’s processing time proportionally deteriorating to its starting time. Moreover, the case of multi-machine is examined by Wang, Ng, Cheng, and Liu (2006), Wu and Lee (2006) and Shiau, Lee, Wu, and Chang (2007), who considered simple linear deterioration in a two-machine flow shop to minimize the mean flow time. They used branch-and-bound algorithms with several dominance conditions to search for the optimal solution. Yang and Wang (2011) minimized the total weighted completion time in a two-machine flow shop with simple linear deterioration. Related literature also includes Mosheiov (1998, 2002), Wang and Xia (2006), Cheng, Sun, and He (2007), Dugardin et al. (2010) and Gawiejnowicz and Kononov (2010).The importance of multi-objective scheduling optimization is widely recognized and its interest is growing since industry needs to cope with multiple performance metrics. There are many multiple criteria scheduling optimization problems. One of the multiple criteria optimization problems is called secondary criterion scheduling problem, which is also known as hierarchical criteria problem. The hierarchical criteria problem starts with solving for the first priority criteria while ignoring the other criteria, then it solves the second priority criterion and ensures the optimal performance of the first criteria remains unchanged. Such problems are known as hierarchical scheduling problems in the literature (Lee & Vairaktarakis, 1993). Hierarchical scheduling problems appear quite naturally in a situation where there are several optimal solutions with respect to a specific objective and the decision maker needs to select from among these solutions the one with the best second objective. Gupta, Ho, and Van der Veen (1999) studied single machine hierarchical scheduling problem with customer orders and multiple job classes. Such a scheduling problem can be denoted as α∣β∣Fh(f2∣f1), where f1 and f2 denote the primary criterion and secondary criterion, respectively, and Fh(f2∣f1) represents the hierarchical optimization of criterion f2 given that criterion f1 is at its optimal value.Chen and Vempati (1992) and Rajendran (1993) independently proposed a branch-and-bound algorithm to optimally solve the problemF2‖Fh(∑Cj|Cmax). Nepalli, Chen, and Gupta (1996) and Gupta et al. (1999) constructed genetic algorithms and local search approach to improve the efficiency of Rajendran’s heuristic. Gupta, Venkata, Neppalli, and Frank Werner (2001) also proposed exact optimization algorithms based on dominance conditions for this problem and developed several polynomial heuristics. Likewise, T’kindt, Gupta, and Billaut (2002, 2003) formulated a mathematical programming model and developed heuristics for the same problem. A comprehensive survey of multiple criteria scheduling problems can be found in Nagar, Haddock, and Heragu (1995) and Hoogeveen (2005), particularly for the two-criterion ones. Lei (2009) also reviewed literature on multi-objective production scheduling problems. Toktas, Azizoglu, and Koksalan (2004) and Eren and Gner (2008) considered a problem of concurrent miinimization of makespan and earliness in a two-machine flow shop environment and developed a branch-and-bound procedure. Chiang, Cheng, and Fu (2011) considered a flow shop scheduling problem with minimum makespan and total flow time, and proposed a memetic algorithm by integrating a general multi-objective evolutionary algorithm.However, except for Gawiejnowicz, Kurc, and Pankowska (2006), we found no scheduling research involving multiple criteria with time-dependent deteriorating jobs. Gawiejnowicz et al. examined a single-machine bi-criteria scheduling problem to identify the pareto optimality that minimizes the total completion time and the makespan, and the optimality of a convex combination of∑Cjand Cmaxcriteria. In this paper, we study a two-machine flow shop scheduling problem with time-dependent deteriorating jobs to minimize the total completion time subject to minimum makespan. It is well known that the flow shop scheduling to minimize total completion time is NP-hard even if there are no deteriorating jobs (Garey, Johnson, & Sethi, 1976). Wang et al. (2006) proved that the two-machine flow shop scheduling problem to minimize total completion time with simple linear deterioration is NP-hard. Therefore, the problem we considered is also NP-hard.The remainder of the paper is organized as follows. In Section 2, we formalize the problem. A mixed integer programming model for the problem is developed in Section 3. Section 4 studies the polynomially solvable special cases. Several dominance conditions are discussed in Section 5. In Section 6, we propose a branch-and bound algorithm and describe the upper bound and the lower bound for the studied problem. Numerical studies are conducted in Section 7 to examine the effectiveness and efficiency of the proposed algorithms. Concluding remarks are given in Section 8.Let Ω={J1,J2,…,Jn} represent the set of jobs which are to be processed on a non-preemptive two-machine flow shop settings. Each job is required to be processed on machine M1 and then on machine M2. The processing time of each job proportionally deteriorates in time, that is pi,j=bi,jt, where bi,j(>0) denotes the deterioration rates of job Jion Mj(j=1,2), and t denotes the starting time that job Jiwill be processed. Briefly, for job Ji∈Ω, let αiand βibe the deterioration rate at M1 and M2, respectively. We assume that the machines are available at time t0=1. It is obvious that any optimal schedule will have no idle time between consecutive jobs on machine M1, and all the jobs processed on machine M2 either do not have to wait or do not have idle time in-between jobs. LetC[i]j(σ)be the completion time of the job located at the ith position in schedule σ on machine Mj(j=1,2). We can estimateC[i]2(σ)by the following equation:(1)C[i]2(σ)=maxC[i]1(σ),C[i-1]2(σ)(1+β[i])=max1⩽k⩽i∏j=1k(1+α[j])∏j=ki(1+β[j]),i∈Nwhere the subscript in [] denotes the processing position of a job in a sequence, andC[0]2(σ)=1.The objective of the studied problem is to find a sequence σ=(J[1],J[2],…,J[n]) that minimizes∑C[j](σ)subject to the minimum makespan criterion, where C[j](σ) is given by (1). We name this problem a hierarchical-criteria two-machine flow shop and denotes it asF2|pi,j=bi,jt|Fh(∑Cj|Cmax). It is known that the problem F2∣pi,j=bi,jt∣Cmaxis polynomially solvable by using Mosheiov’s Algorithm (2002): Divide the n-job set into two disjoint subsets, i.e. Ω1 and Ω2, where Ω1={Ji∣αi⩽βi} and Ω2={Ji∣αi>βi}; Order the jobs in Ω1 in non-decreasing order of αiand those jobs in Ω2 in non-increasing order of βi; Sequence jobs in Ω1 first, followed by Ω2.In this section, we expand Wilson’s model (1989) to build a mixed integer programming (MIP) model for problemF2|pi,j=bi,jt|Fh(∑Cj|Cmax). LetCmaxMbe the optimal value of the makespan obtained by using Mosheiov’s algorithm (2002), and δijbe a binary variable which equals 1 if job Jiis processed in the jth position in a sequence and 0, otherwise. In addition, letC[j]mbe the completion time of the job processed in the jth position in a sequence on machine Mm(m=1,2). The MIP model can be formulated as follows:(2)minZ=∑j=1nC[j]2s.t.∑i=1nδi,j=1,1⩽j⩽n(3)∑j=1nδi,j=1,1⩽i⩽n(4)C[j]1=C[j-1]11+∑i=1nδi,jαi,1⩽j⩽n(5)C[j]2⩾C[j]11+∑i=1nδi,jβi,1⩽j⩽n(6)C[j]2⩾C[j-1]21+∑i=1nδi,jβi,1⩽j⩽n(7)CmaxM⩾C[n]2(8)δi,j∈{0,1},1⩽i,j⩽n(9)C[j]m⩾1,m=1,21⩽j⩽n(10)C[0]1=C[0]2=1Constraints (2) and (3) ensure that only one job can be scheduled at one position and only one position can be occupied by one job at a time. Constraint (4) ensures that M1 will not be idle. Constraints (5) and (6) assure the starting time of the jth job at M2 is greater than or equal to the jth job’s completion time at M1 and the completion time of (j−1) th job on M2. Constraint (7) indicates that the solution is subject to the minimum makespan. Constraints (8) and (9) confirm that the boundary conditions for the decision variables are respected. The model contains n2+2n variables and 5n+1 constraints.In this section, we consider special cases ofF2|pij=bi,jt|Fh(∑Cj|Cmax)and derive properties of the optimal solution.Theorem 1For problemF2|pi,j=bi,jt,βj≡β|Fh(∑Cj|Cmax), an optimal schedule can be obtained by sequencing all jobs in non-decreasing order of αj.In order to prove the Theorem, three cases are considered below.Case 1. When αmin⩾β, we haveC[n]=(1+β)∏j=1n(1+αj)which means that Cmax=min{C[n]} can be minimized by sequencing all jobs in any order. Similar to Theorem 1 in Wang et al. (2006), the total completion time∑j=1nCj=(1+β)∑j=1n∏i=1j(1+αi)can be minimized by sequencing all jobs in non-decreasing order of αj.Case 2. When β⩾αmax, we have C[n]=(1+α[1])(1+β)nwhich means that Cmax=min{C[n]} can be minimized by sequencing all jobs in non-decreasing order of αj. Similar to Case 1,∑j=1nCj=(1+α[1])1+ββ[(1+β)n-1]can be minimized by sequencing all jobs in non-decreasing order of αj.Case 3. When αmin⩽β⩽αmax, the makespan varies according to the following scenarios:(i)If there are no idle time jobs in M2, then we have Cmax=(1+α[1])(1+β)n. Similar to Case 2, the optimal schedule can be obtained by sequencing all jobs in non-decreasing order of αj.If there are no waiting time jobs in M2, then we haveCmax=(1+β)∏j=1n(1+αj). Since αmin⩽β⩽αmax, there exists a job, i.e. job Jr, with its completion time at M1 later than its predecessor’s completion time at M2. Thus, total completion time of all jobs isFor problemF2|pi,j=bi,jt,αj≡α|Fh(∑Cj|Cmax), we have: (1) when α⩽βmin, an optimal schedule can be obtained by sequencing all jobs in non-decreasing order of βj; (2) when α⩾βmax, an optimal schedule can be obtained by sequencing all jobs in non-increasing order of βj.(1)For α⩽βmin, we haveCmax=(1+α)∏j=1n(1+βj). It is obvious that Cmaxcan be minimized by sequencing all the jobs in any order. Thus, total completion time of all jobs is∑j=1nCj=(1+α)∑j=1n∏i=1j(1+βi). Obviously, using pairwise interchange, an optimal schedule can be obtained by sequencing all jobs in non-decreasing order of βj.For α⩾βmax, we have Cmax=(1+β[n])(1+α)n. If 1+β[n]=min{1+βi∣1⩽i⩽n}, Cmaxcan be minimized by sequencing the remaining (n−1) jobs in any order. Therefore, total completion time of all jobs is∑j=1nCj=∑j=1n(1+α)j(1+β[j]). Obviously, an optimal schedule can be obtained by sequencing the jobs in non-increasing order of βj.□However, for the case βmin<α<βmax, the following example show that neither non-increasing schedule nor non-decreasing schedule is optimal schedule.Example 1There are five jobs to be processed in two-machine flow shop by M1 and M2 with deteriorating rates: α=0.4, β1=0.6, β2=0.5, β3=0.4, β4=0.3 and β5=0.2. We find that the minimum makespan is Cmax=7.338, and if the jobs are processed in non-increasing order of βj, then the total completion time is∑Cj=23.757. However, the schedule obtained in non-decreasing order of βjwith the makespan Cmax=9.220 is not an optimal schedule for minimizing makespan, and the total completion time is∑Cj=23.052. It shows that the non-increasing schedule obtains the minimum makespan but does not minimize the total completion time, while the non-decreasing schedule obtains the minimimum total completion time but breaks the premise condition of the minimized makespan.Next, we discuss the case of flow shop with dominant machines (Ho & Gupta, 1995). Machine Mjis considered to be dominated by Mk, if max{bi,j∣i=1,2,…,n}⩽min{bi,k∣i=1,2,…,n}, which can be abbreviated as Mj≺Mk.Theorem 3For problemF2|pi,j=bi,jt,M1≺M2|Fh(∑Cj|Cmax), if the first processed job is given and fixed, then an optimal schedule can be obtained by sequencing the remaining (n−1) jobs in non-decreasing order of βj.Under the condition M1≺M2, i.e. max{αi∣i=1,2,…,n}⩽min{βi∣i=1,2,…,n}, we haveC[i]=(1+α[1])(1+β[1])∏j=2i(1+β[j]),i=2,3,…,n. Since the first processed job is given and fixed, we know that Cmax=min{C[n]} is constant. Therefore, total completion time of all jobs is(11)∑j=1nCj=(1+α[1])(1+β[1])1+∑j=2n∏i=2j(1+β[i]).Obviously,∑j=2n∏i=2j(1+β[i])can be minimized by sequencing the remaining (n−1) jobs in nondecreasing order of βjexcept for job J[1]. Thus, the proof is completed.□For problemF2|pi,j=bi,jt,M1≻M2|Fh(∑Cj|Cmax), if the last processed job is given and fixed, then an optimal schedule can be obtained by sequencing the remaining (n−1) jobs in non-decreasing order ofαj(1+αj)(1+βj).Under the condition M1≻M2, i.e. min{αi∣i=1,2,…,n}⩾max{βi∣i=1,2,…,n}, we haveC[n]=(1+β[n])(1+α[n])∏j=1n-1(1+α[j]). Since the last processed job is given and fixed, we know that Cmax=min{C[n]} is constant. Therefore, total completion time of all jobs is(12)∑j=1nCj=∑j=1n∏i=1j(1+α[i])(1+β[j])=∑j=1n-1∏i=1j(1+α[i])(1+β[j])+∏i=1n-1(1+α[i])(1+α[n])(1+β[n]).The second term∏i=1n-1(1+α[i])(1+α[n])(1+β[n])in Eq. (12) is constant since the last processed job is given and fixed, and the first term∑j=1n-1∏i=1j(1+α[i])(1+β[j])can be minimized by sequencing the remaining (n−1) jobs in nondecreasing order ofαj(1+αj)(1+βj). Thus, the proof is completed.□From above analysis, we can find that the Theorem 2 is a special case of Theorem 3 and Theorem 4In this section, we present important dominance properties of sequences so as to facilitate eliminating of the nodes in the branch-and-bound algorithm when searching for the optimal solution.Property 1If a scheduleR=(σ,Ji,π)does not minimize the makespan, then the scheduleR′=(σ′,Ji,π′)cannot minimize the makespan of the problem, where σ and π are two partial sequences of jobs ordered according to Mosheiov’s algorithm. Jiis a job; and σ′ and π′ are different permutations of jobs of σ and π, respectively.We prove that the makespan ofR′=(σ′,Ji,π′), where σ′ and π′ are not ordered according to Mosheiov’s algorithm, is no less than that ofR=(σ,Ji,π), where σ and π are ordered according to Mosheiov’s algorithm.The makespan ofRcan be written asCmax(R)=maxCmax(σ)∏Jiπ(1+βj),∏σJi(1+αj)∏Jiπ(1+βj),∏σJi(1+αj)Cmax(π),Since σ and π are ordered according to Mosheiov’s algorithm, it follows that Cmax(σ)⩽Cmax(σ′) and Cmax(π)⩽Cmax(π′).Therefore, we haveCmax(R)⩽maxCmax(σ′)∏Jiπ′(1+βj),∏σ′Ji(1+αj)∏Jiπ′(1+βj),∏σ′Ji(1+αj)Cmax(π′)=Cmax(R′)and complete the proof.□For problemF2|pi,j=bi,jt|Fh(∑Cj|Cmax), if the deterioration rates of jobs satisfy the following conditions: αi⩽βi, Ji∈N, and for all Ji, Jj∈N, αi⩽αjimplies βi⩽βj(agreeable condition), then an optimal schedule can be obtained by sequencing the jobs in non-decreasing order of βj.Let σ1 and σ2 be two job sequences where their difference is a pairwise interchange of two adjacent jobs Jiand Jj, i.e. σ1=(π,Ji,Jj,π′) and σ2=(π,Jj,Ji,π′), where π and π′ are partial sequences and the deteriorating rates of job Jiand Jjsatisfy the given condition. Furthermore, we assume that there are (i−1) jobs in π. Thus, Jiand Jjare the ith and (i+1) th jobs in σ1, while Jjand Jiare scheduled in the ith and (i+1) th positions in σ2, respectively. Let A and B denote the completion time of the last job in π on M1 and M2, respectively. Then, we haveC2(π,Ji)=max{A(1+αi),B}(1+βi)=max{A(1+αi)(1+βi),B(1+βi)},C2(π,Jj)=max{A(1+αj),B}(1+βj)=max{A(1+αj)(1+βj),B(1+βj)}.From above, we have(13)C2(π,Ji)⩽C2(π,Jj).Similarly,C2(π,Ji,Jj)=max{A(1+αi)(1+αj),A(1+αi)(1+βi),B(1+βi)}(1+βj)=max{A(1+αi)(1+αj)(1+βj),A(1+αi)(1+βi)(1+βj),B(1+βi)(1+βj)}.C2(π,Jj,Ji)=max{A(1+αj)(1+αi),A(1+αj)(1+βj),B(1+βj)}(1+βi)=max{A(1+αj)(1+αi)(1+βi),A(1+αj)(1+βj)(1+βi),B(1+βj)(1+βi)}.By using the conditions above, we have(14)C2(π,Ji,Jj)⩽C2(π,Jj,Ji).combining inequalities (15) and (16) yields:C2(π,Ji)+C2(π,Ji,Jj)⩽C2(π,Jj)+C2(π,Jj,Ji).Sequentially interchanging of the adjacent pair of jobs in π′, we haveC2(σ1)⩽C2(σ2),and∑Cj(σ1)<∑Cj(σ2).Therefore, σ1 dominates σ2, and an optimal schedule can be obtained by sequencing the jobs in non-decreasing order of βj.□For problemF2|pi,j=bi,jt|Fh(∑Cj|Cmax), if αj=βjfor all jobs, then an optimal schedule can be obtained by sequencing the jobs in non-decreasing order of αj.The proof is similar to that of Property 2, and is omitted here.□For problemF2|pi,j=bi,jt|Fh(∑Cj|Cmax), if min{αi,βj}⩽min{αj,βi}, αi⩽αjand βi⩽βj, for 1⩽i<j⩽n, then an optimal schedule can be obtained by sequencing the jobs in non-decreasing order of αj.Let σ=(Jσ(1),Jσ(2),…,Jσ(i−1)), π=(Jσ(j+1),Jσ(j+2),…,Jσ(n)), Cm(σ) be the completion time of σ on Mm(m⩽2), and∑j=1i-1Cσ(j)2be the total completion time of σ. Consider two adjacent jobs Jiand Jj, and denote ρ=(σJiJjπ) and ρ′=(σJjJiπ). From the condition min{αi,βj}⩽min{αj, βi}, for 1⩽i<j⩽n, we recognize that the schedule ρ satisfies Mosheiov’s algorithm. We thus haveC2(σJiJj)⩽C2(σJjJi)C1(σJi)=C1(σ)(1+αi)⩽C1(σ)(1+αj)=C1(σJj);andC1(σJiJj)=C1(σ)(1+αi)(1+αj)=C1(σ)(1+αj)(1+αi)=C1(σJjJi),C2(σJi)=max{C1(σJi),C2(σ)}(1+βi)⩽max{C1(σJj),C2(σ)}(1+βj)=C2(σJj).Therefore, we findC2(σJi)+C2(σJiJj)⩽C2(σJj)+C2(σJjJi),and complete the proof.□For any two partial schedule σ and δ of the problemF2|pi,j=bi,jt|Fh(∑Cj|Cmax), if C2(σ)⩽C2(δ), then (σ, π) dominates (δ, π), where σ and δ are different permutations of the same subset of jobs and π is a partial schedule of the remaining jobs.The proof is similar to that of Property 4, and is omitted here.□We develop a branch-and-bound algorithm (B&B) to identify the optimal or near-optimal solution. Instead of systematically enumerating all candidate solutions, B&B discards en masse and employs upper and lower bounds and dominance conditions to reduce the search space. We detail the branch-and-bound algorithm next.Adapted from Mosheiov’s algorithm (2002), we develop a polynomial heuristic to obtain a primal sequence. Subsequently, we perform pairwise interchanges on the primal schedule to improve the performance, until further improvement of the objective function is impracticable. We now present the two-phase algorithm: Phase I is based on Mosheiov’s algorithm, while Phase II further improves the quality of the near-optimal solution by using standard pairwise interchange for each of the two partial schedules. Details are presented next.Two-phase algorithm (TPA)Phase IStep 1.1Let k=1, l=n, Ω1=Ω2=ϕ and Ω={J1, J2,…,Jn}=the current set of unscheduled jobs.Find λ=min{αi,βi∣Ji∈Ω}, i.e. identify the job with the smallest deterioration rate on any of the machines in the set of the unscheduled jobs.If λ=αifor some Ji, then schedule job Jiin the kth position, and Ω1=Ω1+{Ji}, Ω=Ω−{Ji} and k=k+1. If Ω≠∅, goto Step 1.2. Otherwise, goto 1.5.If λ=βifor some Ji, then schedule job Jiin the lth position, and Ω2=Ω2+{Ji},Ω=Ω−{Ji} and l=l−1. If Ω≠∅, goto Step 1.2. Otherwise, goto 1.5.Let σ={Ω1, Ω2}. Compute Cmax(σ) and∑Cj(σ).Phase IIStep 2.1Let m=1 and l=nSet i=m+1.Obtain σ′ by moving jobs J[i] in σ forward mth position, if Cmax(σ′)=Cmax(σ) and∑Cj(σ′)<∑Cj(σ), then σ=σ′.Set i=i+1, if i⩽k, goto Step 2.3.Set m=m+1, if m<k, goto Step 2.2; Otherwise, goto Step 2.6.Set s=l−1.Obtain σ′ by moving jobs J[s] in σ backward lth position, if Cmax(σ′)=Cmax(σ) and∑Cj(σ′)<∑Cj(σ), then σ=σ′.Set s=s−1, if s⩾n−k, goto Step 2.7.Set l=l−1, if l>n−k, goto Step 2.6, otherwise, goto Step 2.10.Output σ andUB1=∑Cj(σ).It is known that dominance conditions can reduce the number of interchanges and fully pairwise interchange may improve the quality of near-optimal solution. In addition, Property 5 acknowledges that the quality of partial dominant schedule can influence that of the final schedule. We thus propose an alternative heuristic algorithm to obtain a different upper bound. The steps are detailed below.Fully pairwise interchange algorithm (FPIA).Step 1.Let σ=(J1,J2,…,Jn) be a schedule obtained by Mosheiov’s algorithm, and compute Cmax(σ) and∑Cj(σ). Set π=σ and r=n.For σr=(J1,J2,…,Jr), swap the jobs in sequence positions r and (r−1) to obtain the schedulesσr′=(J1,J2,…,Jr,Jr-1)and σ′=(J1,J2,…,Jr, Jr−1,…,Jn). ComputeCmax(σr),∑Cj(σr),Cmax(σr′),∑Cj(σr′),Cmax(σ′)and∑Cj(σ′), respectively.IfCmax(σr′)⩽Cmax(σr)and∑Cj(σr′)⩽∑Cj(σr)or Cmax(σ′)⩽Cmax(σ) and∑Cj(σ′)<∑Cj(σ), set σ=σ′, r=n and return to Step 2, otherwise, goto Step 4.If r>2, then set r=r−1 and return to Step 2; otherwise, accept the schedule σ withUB2=∑Cj(σ)as the solution of the studied problem.By combining the solutions of TPA (UB1) and FPIA (UB2), we define the upper bound (UB) of the studied problem as.UB=min{UB1,UB2}The efficiency of the branch-and-bound algorithm also depends on the quality of the lower bound. ProblemF2|pi,j=bi,jt|Fh(∑Cj|Cmax)resembles problemF2|pi,j=bi,jt|∑Cjexcept for the primary optimality criterion of the makespan. Wang et al. (2006) and Shiau et al. (2007) developed lower bounds forF2|pi,j=bi,jt|∑Cj, which provide the foundation for our analysis. In this subsection, we establish the lower bounds for problemF2|pi,j=bi,jt|Fh(∑Cj|Cmax).Based on Mosheiov’s algorithm (2002), we develop schedule σ, which integrates schedules Ω1 and Ω2 to minimize the makespan. By definition, the completion time of the ith job isC[i](Ω1)=max∏j=1i(1+α[j]),C[i-1](Ω1)(1+β[i])⩾C[i-1](Ω1)(1+β[i]),where i=1,2,…,k.Similarly,C[i](Ω2)=max∏j=1k+1(1+α[j]),C[i-1](Ω2)∏l=k+1i(1+β[l])⩾∏j=1k+1(1+α[j])∏l=k+1i(1+β[l])for i=k+1,…,n.Therefore, the total completion time of (Ω1,Ω2) is(15)TC(Ω1,Ω2)=∑i=1kC[i](Ω1)+∑i=k+1nC[i](Ω2)⩾(1+α[1])(1+β[1])1+∑i=2k∏j=2i(1+β[j])+∏j=1k+1(1+α[j])∑i=k+1n∏l=k+1i(1+β[l])Since the partial schedules Ω1 and Ω2 are independent, a lower bound of TC(Ω1,Ω2) can be obtained by minimizing the term(1+α[1])(1+β[1])1+∑i=2k∏j=2i(1+β[j])and∑i=k+1n∏l=k+1i(1+β[l]), respectively. In order to minimize the first term, we can choose the first job to be processed and sequence the remaining (k−1) jobs in non-decreasing order of βj. Mosheiov (1994) proved that the second term can be minimized by sequencing the jobs in Ω2 according to the shortest remaining deterioration rate (SRDR) rule, while the minimum value of Eq. (17) can be obtained by sequencing the unscheduled jobs in nondecreasing order of the deterioration rates. Therefore, we obtain the first lower bound(16)LB1=(1+α[1])∑i=1k∏j=1i(1+β[j])+∏j=1k+1(1+α[j])∑i=k+1n∏l=k+1i(1+β[l])where β[k+1]⩽β[k+2]⩽⋯⩽β[n].In Section 3, we formulated a mixed integer programming (MIP) for the problem. In order to obtain a lower bound, we relaxed the zero-one variable δijto be a continuous one in [0,1]. Here we assume k jobs in a partial sequence σ=(J[1],J[2],⋯,J[k])(M=([1],[2],…,[k])) are scheduled. We modify the model in Section 3 to reflect the fact that only n−k jobs need to be scheduled. Details follow:minZ=∑j=1kC[j]2(σ)+∑j=k+1nC[j]2s.t.∑i∈N⧹Mδi,j=1,k+1⩽j⩽n∑j=k+1nδi,j=1,i∈N⧹MC[j]1=C[j-1]11+∑i∈N⧹Mδi,jαi,k+1⩽j⩽nC[j]2⩾C[j]11+∑i∈N⧹Mδi,jβi,k+1⩽j⩽nC[j]2⩾C[j-1]21+∑i∈N⧹Mδi,jβi,k+1⩽j⩽nCmaxM⩾C[n]2δi,j∈[0,1],i∈N⧹M,k+1⩽j⩽nC[j]m⩾1,m=1,2k+1⩽j⩽nC[0]1=C[0]2=1Therefore, our second lower bound denoted by LBM, is equal to Z∗, which is the optimal value of the objective function for the above relaxed MIP. Combining the linear relaxed MIP lower bound (LBM) procedure and LB1, we define the lower bound LB of the studied problem as:LB=max{LB1,LBM}After obtaining the global upper-bound and lower-bound, we now establish the branch-and-bound algorithm to solve theF2|pi,j=bi,jt|Fh(∑Cj|Cmax)problem. The branch-and-bound algorithm is described next.The branch-and-bound algorithmStep 1.Input basic job information and parameters: αi, βi, for i=1,2,…,n.(Find the upper-bound) Determine an upper-bound UB=min{UB1,UB2} of the problem, and label it as the current upper-bound.(Find the lower-bound) Determine a lower-bound LB=max{LB1,LBM} of the problem, and label it as the current lower-bound.(Move down the tree) Generate the ith node (i=1,2,…,n) at level j (j=1,2,…,n) in turn, so as to determine the job schedule.(Update the upper-bound) Apply Properties 2–4 to calculate the upper-bound of the unfathomed partial schedules. If the upper-bound for the unfathomed partial schedule is larger than the initial solution, eliminate the node and all the nodes beyond it in the branch. If the value of the completed schedule is less than the initial solution, and the makespan remains optimal; Use it as the new solution. Otherwise, eliminate it.(Update the lower-bound) For all jobs in Ω1 and Ω2 for level j, calculate the lower-bound of the unfathomed partial schedules, respectively. If the lower bound for the unfathomed partial schedule is less than the initial lower-bound, eliminate the node and all the nodes beyond it in the branch. If the value of the completed schedule is larger than the initial lower-bound, and the makespan remains optimal; Use it as the new lower-bound. Otherwise, eliminate it.(Stopping rule) Continue to explore all the nodes until no more nodes can be explored.Computational experiments were employed here to evaluate the performance of the proposed branch-and-bound algorithm (B&B). We randomly generated a large number of samples, and compared the proposed lower bound, upper bound and MIP solutions to the optimal solution while maintaining the optimal makespan. All the algorithms were implemented in Matlab. The deteriorating rates of jobs on M1 and M2 of the studied problem were generated from a uniform distribution over (0,1),and the number of jobs (n) in a sample may range from 5 to 50 jobs. For each sample size n, we randomly generated 20 cases and used the same data sets to test each of the proposed algorithms. Note that all results discussed in the following part are subject to the optimal makespan constraint.In the first part of the experiment, we compare the total completion time obtained by the MIP approach, the brand-and-bound algorithm (B&B), the upper bound algorithm (UB), the lower bound algorithm (LB), and the optimal solution for n=30, in which the optimal solution is derived through exhaustive enumeration. The results are displayed in Table 1, which shows that the solutions obtained by B&B are better than that of the MIP approach. The average upper bound found by TPA and FPIA is better than that of the lower bound (see the last row of Table 1). We found that the total completion time derived from B&B and from UB are comparable and both are very close to the optimal solution. Therefore, the optimal solutions of the studied problem can be approximated by the results obtained by B&BA within a much shorter computation time.In the second part of the experiment, we compare the results from the proposed algorithms with the optimal solution using the mean absolute percentage error. For each sample, we compute the percentage deviation, defined asVMIP-VoptVopt×100%,VB&B-VoptVopt×100%,VUB-VoptVopt×100%andVopt-VLBVopt×100%, where Voptis the optimal total completion time, while VMIP,VB&B,VUBand VLBare the solutions computed by the MIP approach, the branch-and-bound algorithm, the upper bound algorithm and the lower bound algorithm, respectively. The experiments are run for 12 different job sizes (n=5, 8, 10, 13, 15, 18, 20, 25, 30, 35, 40 and 50), and 20 replications are randomly generated for each n. The results are shown in Table 2.We find that the average differences are no more than 1% for small-sized problem (n⩽25). However, when problem size is greater than 40, the mean differences are more than 3.4%. We also find that the MIP approach does not guarantee optimal solutions within the specified computation time. Table 2 also shows that the upper bound improves the performance of the branch-and-bound algorithm much more than that of the lower bound for all problem sizes. Since the maximum performance difference between the UB and B&B solution is only 0.14% when n⩽40. We thus can use the UB heuristics to effectively and efficiently solve this multi-criteria hierarchical flow shop scheduling problem, especially when the problem size is large and the computation of B&B algorithm become unwieldy.Finally, we compare the solution efficiency in terms CPU time in seconds,. The results are given in Table 3. It shows that the average computation time for the MIP by the Matlab approach increases dramatically when n⩾35.

@&#CONCLUSIONS@&#
There has been a growing interest in studying the flow-shop scheduling problem with time-dependent deteriorating jobs. However, research is mostly limited to single performance measure. In this research, we address a two-machine flowshop scheduling problem with deteriorating processing time, with the goal of minimizing the total completion time subject to minimum makespan. We propose a mixed integer programming model, and a branch-and-bound algorithm combined with an upper- and a lower-bound for our problem. In order to limit the size of the search tree for the branch-and-bound algorithm, several dominance conditions are developed. We also present several polynomial-time solvable special cases. Numerical studies are performed to examine the effectiveness and efficiency of the proposed algorithms. We find that the proposed B & B and the UB algorithms are more practical to solve the real world problems than the conventional methods used to solve the MIP model. Further research can be extended to study other bi-criteria scheduling problems with time-dependent deteriorating jobs in a single- or multiple-machine situations.