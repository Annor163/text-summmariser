@&#MAIN-TITLE@&#
Password systems: Design and implementation

@&#HIGHLIGHTS@&#
A significant protection problem is to specify the access privileges held by each active subject on the protected objects.We associate a password system with each object, featuring a password for each access privilege.Access privileges are partitioned into privilege levels, for distribution and revocation.Password systems are implemented as hierarchical bidimensional one-way chains.

@&#KEYPHRASES@&#
Access right,Distribution,Key,Password,Revocation,

@&#ABSTRACT@&#
Critical infrastructures require protection systems that are both flexible and efficient. Flexibility is essential to capture the multi-organizational and state-based nature of these systems, efficiency is necessary to cope with limitations of hardware resources. To meet these requirements, we consider a classical protection environment featuring subjects that attempt to access the protected objects. We approach the problem of specifying the access privileges held by each subject. Our protection model associates a password system with each object; the password system features a password for each access privilege defined for this object. A subject can access the object if it holds a key matching one of the passwords in the password system, and the access privilege corresponding to this password permits to accomplish the access. Password systems are implemented as hierarchical bidimensional one-way chains. Trade-offs are possible between the memory requirements for storage of a password system and the processing time necessary to validate a key.

@&#INTRODUCTION@&#
Critical infrastructures are essentially physical processes controlled by networked computers. They are usually as vulnerable as any other interconnected computer system, but their failure may have a high socio-economic impact[1]; furthermore, they present distinguishing features that make their protection a problematic challenge[2]. In critical infrastructures, the use of wireless sensor and actuator networks (WSANs) is becoming pervasive, and consequently the network boundaries of the system become blurred. The integration of multi-hop WSANs withsupervisory control and data acquisition (SCADA) systems to monitor critical infrastructures is considered a promising approach [3], which extends the extent ofSCADAsystems and represents a cost-effective solution to the problem of limited deployment flexibility.However, the integration of WSAN with SCADA poses new cybersecurity challenges, e.g. an adversary equipped with a radio transceiver can access the wireless medium and attack sensors and actuators at little effort, to eavesdrop their state, alter their set-up, and issue fraudulent commands. Sensors and actuators are usually resource-scarce devices, and this precludes utilization of off-the-shelf protection solutions, e.g. digital signatures and trusted hardware. Furthermore, a protection system for critical infrastructures is required to comply with a multi-organizational nature and different operational states. In fact, subjects from distinct organizations are often involved in a single critical infrastructure. Each subject executes operations in the infrastructure, and almost all operations are based on a state model. It follows that the actions a subject can undertake in a given state may be forbidden in a different state.In the design and implementation of a protection system, these complex aspects of a critical infrastructure should be taken into careful account. In particular, the multi-organizational and state-based characteristics imply that the protection system should be able to grant and revoke access privileges with flexibility and efficiency. Fine-grained forms of protection should be supported at level of a single object (a data item, as well as a device). The requirements of the protection system in terms of computing power and storage overhead should be kept to a minimum to comply with the limited resources available in the physical objects. Access control has been listed among the technical and management activities aimed at limiting or containing cybersecurity events that are common across critical infrastructure sectors [4]. In particular, accesses to assets and associated facilities must be limited to authorized users, processes, or devices, and to authorized activities and transactions. A suitable management of access permissions is required to incorporate the principles of least privilege and separation of duties.In the following, we shall refer to a classic protection model featuring active entities, the subjects, which perform access attempts to passive entities, called objects[5,6]. Objects are typed; the type of a given object states the values that can be assumed by this object and the operations that can be applied to these values. The type also states the set of access rights and the associations between the operations and the access rights. In order to access an object G of a given type T to perform one of the operations of this type, a subject must possess the access rights permitting successful execution of this operation.A basic problem in every protection model is to specify the access rights that each subject holds on the protected objects. In a classical approach, a set of passwords is associated with each object, and each password corresponds to an access privilege defined in terms of one or more access rights [7–9]. Subject S is entitled to access object G if it possesses a key k matching one of the passwords associated with G. The key certifies that the subject holds the access rights corresponding to the matching password, and allows the subject to accomplish the operations made possible by these access rights. Keys are protected from forging by the password length [10]. If passwords are large and chosen at random, the probability to guess a valid key is vanishingly low.Subject S that possesses key k for object G can transfer the key to another subject S′. Consequently, S′ acquires the access rights for G that are granted by k. A salient problem of key distribution consists in allowing subject S to grant S′ only a part of the access rights included in the original key k. Key derivation is the process of transforming key k into another key k′ that grants a weaker privilege. This means that the new key k′ matches a password corresponding to the weaker privilege.In a centralized approach, key derivation can be obtained by associating a password manager with each object. The password manager receives a key corresponding to a given password and returns a key corresponding to a password with reduced access rights. This approach implies interaction between a subject and the password manager. In a different approach, the protection system includes a key derivation mechanism that allows subjects to transform keys into weaker keys autonomously.Ease of access privilege distribution certainly was one of the main reasons for the introduction of password-based protection. A subject that receives a key matching a given password is free to propagate the key further to other subjects; a result of this type will be simply obtained by a key copy. It follows that keys tend to propagate throughout the system.A related problem is that of key revocation[11–14]. A key is revoked when it can no longer be used for successful object access. The protection system should support a key revocation mechanism, and a revoke access right, so that a subject that holds this access right for given keys can revoke these keys. Revocation should be selective, so that only a subset of the keys distributed for a given object are revoked. Revocation should transitively extend throughout the system to all the copies of the revoked keys, as well as to all the keys derived from the revoked keys, and their copies.Of course, in a password-oriented system, a simple solution to the key revocation problem is password replacement. If we change the password for a given access privilege, all the keys matching this password are revoked. This solution does not meet the requirement to extend revocation automatically to all the keys derived from the key being revoked. It follows that a subject can circumvent revocation by taking advantage of the derived keys.In this paper, we present a model of a protection system based on typed objects, passwords and keys. Our model was designed to meet the following requirements:•A subject that holds a given key should be given the ability to derive new keys with reduced access privileges. The entire key derivation process should be local to the subject, with no need for intervention of a centralized password manager.Forms of selective key revocation should be supported. Revocation should be transitive with respect to key derivation, so that revocation of a given key k implies revocation of all copies of k, as well as of all the keys derived from k, and their copies.At the implementation level, trade-offs should be possible between the memory space necessary for password storage and the processing time for key validation, so that if low memory cost is not a stringent requirement, the time necessary to validate a key can be kept to a minimum, for instance.The rest of this paper is organized as follows. Section 2 introduces our protection model with special reference to access privileges and their division into privilege levels. The concept of access privilege distribution is introduced whereby a subject that holds an access privilege in a given privilege level can grant another subject this privilege as well as any weaker privilege in the same level. Our protection model associates a password system with each given object; the password system features a password for each access privilege defined for this object. Possession of an access privilege is certified by possession of a key matching one of the passwords in the password system. Section 3 presents an implementation paradigm of password systems taking the form of a hierarchical bidimensional one-way chain. Special attention is paid to key distribution and revocation. Section 4 discusses our protection system from a number of salient viewpoints, which include the memory costs for password storage and the relation to previous work. Section 5 gives concluding remarks.Let us refer to object type T, let op0,op1,… be the operations, and ar0,ar1,… be the access rights specified by T. For each operation, the definition of type T states the access rights that are necessary to execute this operation successfully. An access privilege is a collection of one or more access rights.In our protection model, each access privilege is always part of a privilege level. The privilege levels of type T are ordered from the highest lv0 to the lowest lvm−1, where quantity m is specific to T. Privilege level lviconsists an ordered sequence of access privileges api,0,api,1,… and different privilege levels may feature a different number of access privileges. A salient property is that, in level lvi, the j-th access privilege api,j inherits the access rights of all the subsequent, weaker access privileges api,j+1,api,j+2,… etc.When a subject creates an object, it is assigned access privilege ap0,0, i.e. the first (strongest) access privilege of the highest privilege level lv0. This privilege includes the own access right that incorporates the prerogatives of all the other access rights and also makes it possible to modify the composition of all access privileges. In all object types, the revoke access right for a given object makes it possible to revoke the access privileges for this object (access privilege revocation will be considered in subsequent Section 3.2); the delete access right makes it possible to delete the object; and, finally, the copy access right makes it possible to create copies of the object.Fig. 1shows the privilege levels of two object types, the Document type and the Buffer type. Besides access rights own, revoke, delete and copy, the Document type defines three access rights, namely read (R), write (W) and append (A; Fig. 1a). The read access right for a given document makes it possible to access the document for read; the write access right makes it possible to overwrite the document with new data; and the append access right makes it possible to add new data at the end of the document.As stated previously, each access privilege of a given level inherits the access rights in all the subsequent access privileges of that level. Inheritance suggests a compact representation of access privileges whereby each privilege is denoted by the new access rights only, i.e. in Fig. 1 we omit to specify the inherited access rights. The Document type defines three privilege levels. In level lv0, the composition of the last (weakest) access privilege is (R, W, A). The previous access privilege includes access right copy and inherits access rights R, W and A from the subsequent privilege. Then we have a stronger access privilege that adds access right delete, and the first (strongest) privilege that includes access right own.Besides own, revoke, delete and copy, the Buffer type defines access rights insert (I) and extract (E; Fig. 1b). Insert makes it possible to put data items into the buffer, extract makes it possible to get data items from the buffer. The highest privilege level lv0 is intended for the buffer owner, privilege level lv1 is intended for producer subjects, and privilege level lv2 is intended for consumer subjects.A subject that holds an access privilege of a given privilege level can distribute this privilege as well as any weaker privilege of the same level to other subjects. In the example of the Document type, access privilege ap1,2 includes the W access right and inherits the A access right from the subsequent privilege ap1,3; thus, the composition of ap1,2 is (W, A). A subject that holds ap1,2 can distribute this access privilege as well as subsequent privilege ap1,3.Function F is one-way if it is easy to evaluate but computationally hard to invert [15]. This means that given a value x it is easy to compute F(x), but given a value y it is computationally unfeasible to find an x so that y=F(x). A one-way chain is a sequence of values x0,x1,…,xn−1 such that xi=F(xi−1) for 0<i⩽n−1, i.e. each value is the result of the application of one-way function F to the previous value. The first value x0 is called the seed of the chain. A hierarchical bidimensional one-way chain is a collection of chains organized in two levels. At the first level, we have a single chain, which is called the primary chain. Each value of the primary chain is the seed of a chain at the second level (a secondary chain) [16].In our protection model, a password is associated with each access privilege. The resulting password system takes the form of a bidimensional one-way chain. The primary chain includes the passwords for the strongest access privilege of all privilege levels. The i-th password of the primary chain is the seed of the i-th secondary chain whose values correspond to the passwords for the access privileges in privilege level lvi. We shall denote the password for access privilege api,jby wi,j.In more detail, to set up the password system, password w0,0 corresponding to the own privilege is chosen at random. This password is the seed of the primary chain, which features m values, one value for each privilege level. A one-way function, called the primary function PF, is used to generate the subsequent passwords in the primary chain, i.e. w1,0=PF(w0,0), w2,0=PF(w1,0),…,wm−1,0=PF(wm−2,0). These passwords are associated with the first privilege of each privilege level, from the highest level lv0 to the lowest level lvm−1. Password wi,0 is the seed of the secondary chain for privilege level lvi. A further one-way function, the secondary function SFi, is used to set up the secondary chain for level lvi, so we have wi,1=SFi(wi,0), wi,2=SFi(wi,1),… etc.1Primary function PF and all secondary functions SFs can be effectively implemented by taking advantage of a parametric one-way function and different parameters. A parametric one-way function H is a function that given a value z and a parameter p it is computationally unfeasible to find an x so that z=H(x, p) [17]. Parametric one-way functions are families of one-way functions that are parameterized by parameter p. In a practical implementation of a parametric one-way function, we can take advantage of a symmetric encryption cipher, e.g. if G is a hash function and Ex(p) denotes the encryption of p using symmetric cipher E with key x, then H(x,p)=G(Ex(p)) is a parametric one-way function.1Fig. 2shows the password system for the two previous examples of object types, the Document type and the Buffer type. Let us refer to the Document type, for instance (Fig. 2a). To set up the password system, password w0,0 for the own privilege is chosen at random. A primary one-way function PF is used to generate the subsequent passwords w1,0 and w2,0 for the strongest privilege of the lower privilege levels. Each of these passwords is the seed of a secondary chain. For instance, for privileges level lv1, password w1,0 is the seed, and secondary one-way function SF1 is used to generate passwords w1,1 to w1,3 in the corresponding secondary chain. A key matching password w1,1 grants the corresponding access permission, which includes access right delete, and inherits access rights write and append from the subsequent access privileges in the first privilege level (see Fig. 1a).It is worth noting that, when a copy of a given object is generated by exercising the copy access right, the value of the new object is the same of the original, but the password system should be reconstructed so that the values of the passwords are different. This is necessary to avoid that a subject that holds a key for the original object can use this key to access the object copy.A subject S that holds a key k matching a given password wi,jcan transmit the access privilege corresponding to this password to other subjects by simply distributing a copy of the key to these subjects. Subject S may even distribute a key k′ derived from k and relevant to a weaker access privilege. A result of this type can be obtained by taking advantage of the structure of the password system and the password chains, as follows:•Subject S that holds key k matching password wi,0for the strongest access privilege of privilege level lvican derive key k′ matching password wi′,0for the strongest access privilege of a subsequent privilege level lvi′, i′>i. To this aim, S will apply primary function PF iteratively i′−i times.Subject S that holds key k matching password wi,jfor the j-th access privilege of privilege level lvican derive key k′ matching password wi,j′, j′>j for a weaker access privilege of the same privilege level. To this aim, S will apply secondary function SFiiteratively j′−j times.Subject S that holds key k matching password wi,0for the strongest access privilege of privilege level i can derive key k′ matching password wi′,jfor an access privilege of a lower privilege level lvi′, i′>i. To this aim, S will apply primary function PF iteratively i′−i times to find the key corresponding to the password wi′,0of the strongest access privilege of privilege level i′. Then, this key will be used to evaluate key k′ by applying the i-th secondary function SFiiteratively j times.Of course, a subject that holds a given key is not able to evaluate the key for a stronger access privilege in the same privilege level. This is a consequence of the fact that the passwords of a given privilege level are evaluated by iterated applications of a one-way function, which is computationally not invertible. Similarly, a subject that holds a key for the strongest access privilege of a given privilege level cannot evaluate the key for the strongest access privilege of a higher level.Key revocation can be effectively obtained by changing the one-way functions.2In an implementation taking advantage of a parametric one-way function (see footnote 1), the change of the primary function or of a secondary function will be simply obtained by changing the corresponding parameter.2In detail:•If we replace secondary function SFiwith a new one-way function, we revoke all the keys for the access privileges of privilege level lviexcept the key for the strongest privilege of this level, api,0. The new secondary function will be used to re-evaluate the passwords. A subject that holds a key for the strongest privilege of privilege level lvias well as of any higher privilege level can take advantage of the key derivation process illustrated in Section 3.1 to derive the new keys for the access privileges in lvi.If we replace primary function PF, we revoke all the keys except those matching password w0,0. Consequently, the whole password system will be reconstructed. The new primary function will be used to re-evaluate the password for the strongest privilege of each privilege level. Then, each secondary function will be used to re-evaluate the passwords for the remaining access privileges of the corresponding privilege level. A subject that holds a key matching password w0,0 will be in the position to derive the new keys.

@&#CONCLUSIONS@&#
