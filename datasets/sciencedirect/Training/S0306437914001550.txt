@&#MAIN-TITLE@&#
Dealing with change in process choreographies: Design and implementation of propagation algorithms

@&#HIGHLIGHTS@&#
Enabling flexibility and change in process choreographies.Proposing change propagation algorithms for process choreographies.Handling transitive change propagation across several partners.Ensuring consistency and compatibility when propagating changes.First comprehensive proof-of-concept implementation of change propagation framework for process choreographies.

@&#KEYPHRASES@&#
Process-aware information system,Process choreography,Change propagation,Process change,Business collaboration,

@&#ABSTRACT@&#
Enabling process changes constitutes a major challenge for any process-aware information system. This not only holds for processes running within a single enterprise, but also for collaborative scenarios involving distributed and autonomous partners. In particular, if one partner adapts its private process, the change might affect the processes of the other partners as well. Accordingly, it might have to be propagated to concerned partners in a transitive way. A fundamental challenge in this context is to find ways of propagating the changes in a decentralized manner. Existing approaches are limited with respect to the change operations considered as well as their dependency on a particular process specification language. This paper presents a generic change propagation approach that is based on the Refined Process Structure Tree, i.e., the approach is independent of a specific process specification language. Further, it considers a comprehensive set of change patterns. For all these change patterns, it is shown that the provided change propagation algorithms preserve consistency and compatibility of the process choreography. Finally, a proof-of-concept prototype of a change propagation framework for process choreographies is presented. Overall, comprehensive change support in process choreographies will foster the implementation and operational support of agile collaborative process scenarios.

@&#INTRODUCTION@&#
The optimal design and implementation of their business processes is crucial for enterprises. This not only applies to internal business processes, but also to collaborative processes whose execution involves different partner enterprises. Examples include cross-organizational manufacturing [1] and tourism [2]. The system-based support of such collaborative processes is realized by process choreographies[3]. In particular, a choreography model describes the interactions between the partner processes through message exchanges. In a supply chain process, for example, the Supplier interacts with the Manufacturer and the Manufacturer with the Customer. The Customer, for example, may place an order with the Manufacturer by sending a corresponding order message.In general, the interactions among the partners are visible to the outside and described by so called public process models (public model for short). In turn, the public models constitute views on the underlying internal partner processes, the so-called private processes. In particular, the models of the latter (i.e., private models) are not visible to the other partners due to confidentiality reasons. Altogether, a choreography model consists of the participating partners, a global view on all partner interactions, and the public as well as private models of the partners.Process change has been identified as crucial in most application domains [4–6,58]. The demand for changing business processes arises due to various reasons such as the advent of new regulations or the emergence of new competitors at the market. Research on this topic has been extensive and led to flexible process management technology realized as mature commercial (e.g., AristaFlow11www.aristaflow.com) and prototypical systems (e.g., CPEE22cpee.org). So far, however, approaches dealing with process changes have focused on scenarios in which a business process is entirely run within a single enterprise. In turn, little attention has been paid to changes of process choreographies, even though the latter demand for agility and flexibility as well [7–9].When applying changes to the processes supported by an information systems, in general, it must be ensured that neither structural nor behavioral soundness of the process is violated after the change [6]. For process choreographies, additional properties must be guaranteed due to the complexity introduced by the involvement of autonomous partners as well as the interactions between them. For example, assume that a particular partner applies a change to its private process. In addition to ensuring structural and behavioral soundness of this private process, it must be determined whether its change affects other partners in the choreography as well. Amongst others, this means that it must be checked whether the change of the private model affects the corresponding public model. In this case, it must be further ensured that the private model remains consistent with the public model. Note that this might require adaptations of the public model as well.In turn, changing the public model of a particular partner might affect its interactions with other public models, e.g., when deleting an activity that sends a particular message another partner is waiting for. In order to ensure compatibility between the public models of the involved partners, therefore, one may have to propagate the changes from one partner and its public model to the other partners and their public models. After adapting the public models of the partners, in turn, the consistency with the underlying private models must be re-checked to ensure overall consistency. Note that change propagation cannot always be restricted to direct partners, but might spread transitively over the entire process choreography.In general, propagating changes must not infringe the autonomy of the partners. In fact, adaptations becoming necessary to maintain the consistency and compatibility of the choreography should be suggested to partners, but the decision whether or not to adopt these adaptations must be left to them and may be subject to negotiations. In general, such negotiations can be costly and time-consuming, particularly in case of failure. This paper focuses on the fundamentals of change propagations in process choreographies whereas negotiation issues are discussed in [60,59]. Another challenge concerns the non-availability of information about the private processes of the partners. Hence, determining the adaptations required for the public and private models of the partners during change propagation is a difficult task.Altogether, an approach enabling change propagation in process choreographies must tackle the following research challenges:1.It must provide change propagation algorithms that ensure consistency and compatibility for all affected partners.It must handle transitive change propagation across multiple partners.In order to obtain an operational change propagation framework, we must further deal with implementation concepts required for realizing the change propagation algorithms for process choreographies.This paper provides an extended and revised version of the work we presented in [8]. First of all, [8] introduced fundamental notions as well as design decisions such as representing choreography processes as Refined Process Structure Trees (RPST) [12] and restricting the set of change operations to the insertion, replacement and deletion of process fragments (as described in [13]). This paper adopts these design decisions. Further on, [8] addressed Research Challenges 1 and 2 by providing propagation algorithms for change operations REPLACE and UPDATE, whereas other change operations were not considered. Finally, [8] discussed how the propagation algorithms ensure consistency and compatibility of the choreography model and highlighted the problem of transitive change propagation.Compared to [8], this paper provides significant revisions and extensions of the results related to Research Challenges 1 and 2. This includes (i) a fundamental revision of the previous definitions using the mapping functions between the different choreography models and – in the sequel – the propagation algorithms; (ii) the propagation algorithms for additional change operations (i.e., Insert and Delete), (iii) extensive illustrations of the algorithms, (iv) a revision of the Replace algorithm, (v) an extended discussion on transitivity when propagating changes in process choreographies, and (vi) an extension of the formal evaluation of consistency and compatibility in the context of respective change. Furthermore, this paper provides novel results regarding the technical evaluation of our approach. We propose an architecture for implementing a sophisticated change propagation framework for process choreographies. This architecture consists of three layers for defining, executing and changing processes. The core component of the change layer, which is realized as a proof-of-concept prototype, is the C3Editor. The latter allows for the import of private, public and choreography models from tools such as Signavio and jBPM. The C3Pro Editor visualizes the different models and enables the definition and application of changes to the private models. Furthermore, it determines and visualizes the partners affected by a change and the updates required for change propagation. To the best of our knowledge, this is the first prototype enabling change and change propagation in process choreographies. This paper is organized as follows: Section 2 introduces a motivating example, followed by fundamental definitions in Section 3. Section 4 then presents the change propagation algorithms we developed. Section 5 discusses the handling of transitivity when propagating changes in process choreographies. Our approach is evaluated in Section 6 regarding the consistency and compatibility of the choreography after change propagation. Section 7 provides the details on the architecture and proof-of-concept implementation. In Section 8, we discuss related work. Section 9 summarizes the paper.From the perspective of a single partner, three different, but overlapping viewpoints form a collaboration: the private model, public model, and choreography model [16].•The private model describes the internal business logic as well as the message exchanges this partner is engaged in; i.e., the private model corresponds to the executable process of this partner. In general, the internal logic is not visible to other partners.The public model sketches the message exchanges from the perspective of this single partner as well as their sequencing; i.e., it represents an abstraction of the private activities corresponding to the private model. Compared to the public model, the private model contains the business process logic not visible to the other partners.The choreography model provides a global view on the interactions of a collaboration; i.e., it captures all interactions among the partners as well as the dependencies between these interactions.We illustrate change propagation issues along the booking trip choreography example depicted in Fig. 1. This example is part of the choreography model described in [2]. It has been modeled using the choreography diagram elements of BPMN 2.0 and the Signavio tool [14]. The example describes a collaboration among four partners, i.e., traveler, travel agency, acquirer, and airline. The traveler sends booking information to the travel agency that, in turn, contacts the acquirer to request a credit check. If the traveler does not have enough credit, failure notifications are sent to the travel agency and airline, which inform the traveler about the reservation failure and purchase cancellation, respectively. Otherwise, an approval is sent to the travel agency and the airline is triggered to send the ticket and the purchase confirmation.Fig. 2depicts a BPMN collaboration diagram listing the public models of all partners involved in the choreography. Each public model includes the interactions the corresponding partner is involved in as well as the control flow between them. Note that Fig. 2 does not show the private models of the partners, which contain their internal activities (cf. Fig. 3). Finally, merged together, the public models lead to the choreography model.As motivated, in many application scenarios, the partners of a collaboration should be allowed to change their private processes. The specific challenge compared to local changes of a single process is to propagate change effects from one partner to the others [8,9] if required. For example, the TravelAgency might want to send a questionnaire about customer satisfaction to the Traveler after booking the ticket. This could be accomplished by inserting corresponding activities into the private model of the TravelAgency; e.g., DevelopQuestionnaire, which constitutes an internal activity not visible to other partners, and SendQuestionnaire, which constitutes the public activity to be added as well. Furthermore, a respective change request needs to be sent to the Traveler who should be able to receive the corresponding message and respond to it.In general, change propagation in process choreographies might become quite complex [8]. Consider the above example and assume that it is not the TravelAgency which initiates the collection of customer feedback, but the Airline through the Acquirer and TravelAgency. In this case, the initial change will cause transitive effects across multiple partners. To overcome this problem, the effects of this local change in the private model of one partner need to be propagated to the concerned partners. As a consequence, the interactions must be restructured accordingly.As a prerequisite for precisely defining the notions of private, public and choreography model, we need to be able to represent the control-flow relations between activities and interactions. With the Refined Process Structure Tree (RPST) [12], this paper adopts a structured representation for this. An RPST model corresponds to a decomposition of a process model into a set of single-entry, single-exit (SESE) fragments. Thereby, each node of an RPST represents a SESE fragment of the underlying process model. Consequently, the root node corresponds to the entire process model, whereas the child nodes of a node N correspond to the SESE fragments directly contained under N; i.e., the RPST parent–child relation corresponds to the containment relation between SESE fragments. As a key characteristic, the RPST can be constructed for any process model captured in a graph-oriented notation [17].We choose the RPST for various reasons. Besides being generic and language-independent, the RPST is indeed a structured tree representation of a given model. Note that structured process models are close to BPEL and are simpler to analyze and easier to comprehend than unstructured models. However, recent work has shown that most unstructured process models can be automatically translated into structured ones [18]. Additionally, computing and propagating changes for unstructured processes is rather complex and might violate the soundness of the choreography. Transforming unstructured processes into structured ones, therefore, eases the propagation of changes and ensures a more sound propagation. Furthermore, using tree structures instead of usual graph representations significantly reduces the complexity for calculating the impacts of a change (e.g. parsing, identifying fragments). Indeed, high-level change operations (cf. Section 3) refer to entire process fragments (i.e., sets of activities and gateways) instead of single nodes. As process models are block structured in RPSTs, in turn, this makes it easier to identify the fragments to be modified in the processes of the partners involved in a change. Finally, in [12] it was proven that the translation of the process models to block-structured languages (e.g. BPEL) becomes easier through their decomposition into RPST. The transformation of graph models to RPST is linear, idempotent and modular [12].Fig. 4depicts the tree model of the choreography scenario from Fig. 1. In essence, the interaction nodes of the original graph are mapped to leaves in the tree model and represent the Trivial nodes, whereas the control nodes (i.e., sequence (SEQ), choice (CHC), parallel (PAR), or loop (RPT)) are mapped to internal nodes (for more details see [12]).This section introduces the main definitions used throughout the paper. Section 3.1 provides the formal definitions related to the various models a choreography is composed of. In turn, Section 3.2 presents basic definitions related to change, change propagation, and change operations.A choreography includes three types of models: (i) the private model representing the executable process and including private activities as well as interactions with other partners, (ii) the public model (also called the interface of the process) highlighting solely the interactions of a given partner, and (iii) the choreography model giving a global view on the interactions between all partners. In the following we sketch the corresponding definitions.Definition 1(Structured) Private ModelA private modelπpof partner p corresponds to a tree with the following structure33We use the type definition syntax of the ML language [19].:Process::=PNodePNode::=Activity|ControlNode|EventActivity::=PrivateActivity|InteractionActivityInteractionActivity::=Send(Message,Receiver)|Receive(Message,Sender)ControlNode::=SEQ({PNode})|CHC({PNode})|PAR({PNode})|RPT(PNode)Event::=Start|EndSEQ corresponds to a sequence of fragments, CHC to a choice between two or more fragments, PAR to a parallel execution of several fragments, and RPT to an iteration over a fragment.In the private process model depicted in Fig. 3, fragmentFis represented as follows:SEQ(PAR(Send(payment_ok,airline),pr_activ2,Send(approval,travelAge_ncy)),XOR(pr_activ3,pr_activ4))The public model lpof a partner p reflects the external behavior of p; i.e., it includes the interactions with other partners as well as the constraints between them from the viewpoint of p:LocalModel::=LNodeLNode::=InteractionActivity|ControlNode|EventInteractionActivity::=Send(Message,Receiver)|Receive(Message,Sender)ControlNode::=SEQ({LNode})|CHC({LNode})|PAR({LNode})|RPT(LNode)Event::=Start|EndFig. 2 represents a collaboration diagram that illustrates the different public models of the book trip choreography example. Note that each panel defines the public model of one single partner.Definition 3(Structured) Choreography ModelA global choreography modelGrepresents a global view on the interactions between collaborating partners.ChoreographyModel::=CNodeCNode::=I(Sender,Receiver,Message)|ControlNode|EventControlNode::=SEQ({CNode})|CHC({CNode})|PAR({CNode})|RPT(CNode)Event::=Start|EndI corresponds to an interaction between partners Source and Destination (i.e., the exchange of message Message).An example of a choreography model is illustrated in Fig. 1. We define a fragmentFas a non-empty subtree of a private model, public model or choreography model with single entry and single exit edge (SESE). Regarding Definitions 1–3, a tree model fragment is represented by elements PNode, LNode and CNode, respectively. Next, we define a choreography as the aggregation of all elements necessary for ensuring a sound collaboration between the participating partners.Definition 4ChoreographyWe define a choreographyCas a tuple (G,P,Π,L, ψ, φ, ξ) where,•Gis the choreography model (cf. Definition 3).Pis the set of all participating partners.Π={πp}p∈Pis the set of all private models (cf. Definition 3).L={lp}p∈Pis the set of all public models (cf. Definition 2).ψ={ψp:lp↔πp}p∈Pis a partial mapping function between nodes of the public and private models.φ:l↔l′is a partial mapping function between nodes of different public models.ξ:G↔lis a partial mapping function between nodes of the choreography model and the public models.Functions ψ and φ can be used to check the consistency between public and private models (i.e., each private model must be consistent with the respective public model) as well as the compatibility between public models.In order to represent changes of a choreography, we consider four basic change patterns: REPLACE, DELETE, INSERT, and UPDATE (cf. Fig. 5).Definition 5Change PatternsChangePattern:≔REPLACE(oldFragment,newFragment)|DELETE(fragment)|INSERT(fragment,how,pred,succ)|UPDATE(activity,attribute,newValue)how::=Parallel|Choice|Sequenceattribute::=partner|role|Input|OutputREPLACE allows replacing an existing fragment with a new one. DELETE removes an existing fragment, whereas INSERT adds a new fragment to the process model between a predecessor node pred and a successor node succ. Finally, UPDATE allows modifying an attribute of a single activity as illustrated in Fig. 5. Note that more complex changes can be expressed by combining these four patterns. Change patterns are defined as follows:Definition 6Change OperationA change operation is a tuple (δ,σ) where σ is either the private, public or choreography model to be changed, and δ:σ↦σ′corresponds to the change that transforms σ intoσ′.Consider Fig. 3:DELETE(check_and_cash,πAcquirer)deletes the activitycheck_and_cashfrom the private model of the Acquirer.An abstraction functionabstrλ:σ↦σ′is a projection of a model σ according to criterion λ. The following holds:•∀n∈σwith n satisfies λ,⟹n∈σ′(n refers to node).∀n,n′∈σwithn,n′satisfying λ and n precedesn′inσ,⟹n,n′∈σ′∧nprecedesn′inσ′.Functionabstrλ(σ)transforms a source model σ into a target modelσ′that solely contains activities satisfying λ; e.g., a public model corresponds to an abstraction of a private model with respect tointeractionactivities(cf. Definitions 1 and 2). The abstraction of a private model may further contain structures not contributing to process execution (e.g., “empty” branches in a parallel branching). In this case, refactorings may be applied [20]. Next, we assume thatλ=p′refers to the interactions withp′. Hence,abstrp′(lp)corresponds to the abstraction of lpaccording to the interactions of p withp′. As result, we obtain a view on all interactions p has withp′. The abstraction function allows calculating the propagation effects; e.g., by identifying the effects a change of a private model has on its corresponding public model.Example 3The result of abstracting fragmentF(cf. Example 1) according to its interactions is as follows:PAR(Send(payment_ok,airline),Send(approval,travelAge_ncy))Assume thata∈pcorresponds to an interaction activity with a partnerp′. Then: The complement of a, which is denoted asa¯∈p′, corresponds to the opposite of a, i.e.,•send(message,p′)¯=receive(message,p).receive(message,p′)¯=send(message,p).Given an arbitrary set of nodes of a model σ, we define α as the function returning the smallest fragment in σ containing all these nodes. This function allows keeping the effects of a change as local as possible.Definition 9Smallest fragment αLet σ be a model andSbe a set of corresponding nodes. Then:ασ(S)returns the smallest fragment in σ containing all nodes fromS. Formally:ασ(S)=argminsize(F){F∈σ∣∀n∈S,n∈F}.In Fig. 1,αG({payment_ok,approval})=F3holds.Usually, determining the changes to be propagated to the partner processes requires knowledge about the activities executed before or after the changed fragment. In this context, the following definitions are useful.Definition 10Preset (Postset)The preset (postset) of a node n in model σ corresponds to the set of nodes in σ that can be executed directly before (after) n. Formally:•preset(n,σ)={n′∈σ|∃SEQ(n′,n)∈σ}postset(n,σ)={n′∈σ|∃SEQ(n,n′)∈σ}Consider Fig. 1. We obtainpreset(check_and_cash,G)={book_trip}andpostset(g1,G)={g2,g4}.In a model σ, the transitive preset (postset) of a node n, according to criterion λ, represents the set of nodes that satisfy λ and can be executed directly before (after) n.•T_presetλ(n,σ)=preset(n,abstrλ(σ))T_postsetλ(n,σ)=postset(n,abstrλ(σ))Consider Fig. 1. We obtain•T_presetAcquirer(check_and_cash,G)={start}, andT_postsetTraveler(g2,G)={credit_card_not_approved}.Our goal is to enable change propagation in choreographies with multiple interacting partner processes. Our approach is based on six major steps: (i) checking whether a change needs to be propagated or is isolated (i.e., the change is local), (ii) computing the private-to-public effects; i.e., propagating changes from the private model of the change initiator to its public model, (iii) computing the public-to-public effects; i.e., propagating changes to the partners involved, (iv) negotiating the changes with the concerned partners, (v) computing public-to-private effects (if negotiations have succeeded); i.e., each partner calculates internally the effects of the public changes on its private model, and finally (vi) checking the compatibility and consistency of the choreography and implementing the changes. Fig. 6details these steps and outlines the different actions required to achieve a sound propagation.When applying a change operation to a partner׳s private model, we extract all interaction activities concerned by the change–interaction activities are message exchanges with other partners (i.e., sending and receiving messages). If the list is empty (i.e., the change is restricted to the internal behavior), the other partners are not affected by the change. Hence, there is no need for any new agreement on the global choreography. Otherwise, the list of affected interactions is analyzed to identify all partners involved. Then, for each of these partners, a relative change computation is accomplished to determine the changes to be propagated. The latter are computed according to the change operation type. Then, a negotiation phase is launched with each affected partner. If all negotiations succeed, we apply consistency and compatibility checks to ensure the soundness of the obtained models. In turn, if these models are sound, we update the public models affected by the change as well as the choreography model and, if necessary, adapt concerned private models to their new public models. If negotiations do not succeed, either the change is canceled or it is tried to circumvent those partners with whom negotiations failed in the past. Note that this propagation strongly depends on the change pattern applied (i.e., INSERT, DELETE, REPLACE, or UPDATE). We sketch the different algorithms needed for propagating changes depending on the change pattern used. The propagation of change pattern UPDATE is not considered in this paper, but can be found in [8]. According to Fig. 6, the focus is on determining the public propagation effects of a single change (i.e., the parts in dark gray). In particular, we want to identify whether or not a change is isolated, and compute private-to-public and public-to-public effects. Negotiation and computing public-to-private-effects (i.e., effects of changing a partner׳s public model on its private model) are out of the scope of this paperThe INSERT pattern is used to add a new fragmentFto the private model πpof a partner p between two consecutive nodes pred and succ. In the following, we use the example depicted in Fig. 7to explain and illustrate the main propagation steps for propagating fragment insertions. Given a change operation δ of type INSERT applied to a partner׳s private model πp, andFbeing the fragment to be inserted in πpbetween two nodes pred and succ (cf. Step 1 in Fig. 7), the ripple effects of δ can be computed asfollows:1.Isolated or propagating changes: We first check whetherFcontains additional interactions or solely private activities by abstractingFwith respect to interactions (cf. Step 2 in Fig. 7). IfF′=abstrinteraction(F)is not empty (i.e.,Fcontains at least one node), new interactions have been added and a change propagation becomes necessary. Otherwise, the change is considered as isolated; i.e., no propagation is needed.Private-to-Public effects: In order to compute the impacts on the public model of the change initiator, we proceed as follows:•IfF′is not empty, we calculate the corresponding fragment to be added to the public model lpof change initiator p. The latter is the partner that initiated the change propagation. For this purpose, we use private-to-public mapping function ψ that transforms the elements ofF′into elements of lp. Note that this will be crucial if the private and public models are defined in terms of different modeling languages; e.g., in Fig. 7 the elements of πpandFmight be defined with BPEL, whereas the ones ofF″and lpare defined in BPMN (cf. Step 3 in Fig. 7).When insertingFbetween pred and succ in πp, this results in an insertion ofF″in lp. To maintain the consistency between πpand lp,F″should maintain the precedence relationship with pred and succ. Since pred and succ in πpmay be private activities without corresponding elements in lp, however, it becomes challenging to identify the insertion positionspred′andsucc′ofF″in lp(cf. Step 4 in Fig. 7). Therefore, we first check whether pred and succ constitute interaction activities or have corresponding elements in lp(ψ(pred)≠∅). In this case, we consider the corresponding positions in lp; i.e.,pred′=ψ(pred)andsucc′=ψ(succ)respectively. Otherwise, we look at the elements of πphaving corresponding elements in lpand directly preceding pred (i.e.,T_presetinteraction(pred)) and following succ (i.e.,T_postsetinteraction(succ)). Then,F″is inserted between the corresponding elements in lpas follows (cf. Step 5 in Fig. 7):○pred′=ψ○T_presetinteraction(pred)succ′=ψ○T_postsetinteractionsucc)Public-to-Public effects: In order to calculate the change impacts on the other partners, we proceed as follows:•We analyzeF″in respect to the list of partners involved in the change. For each of these partners, we identify the interactions this partner is involved in. Given a partner p1, this induces the calculation ofabstrp1(F″)(cf. Step 6 in Fig. 7). In turn, abstraction functionabstrp1returns a connected component including all interactions with p1; i.e.,F‴.F‴represents the fragment to be inserted into the public modellp1of p1. To preserve the compatibility of the collaboration, however, we must calculate the complement ofF‴(i.e.,Fp1=F‴¯) and update the public-to-public mapping function φ (cf. Step 7 in Fig. 7). The latter maintains the correlation between nodes of different public models.Given the fragmentF″to be inserted betweenpred′andsucc′in lp(cf. Step 5 in Fig. 7), how can we identify the insertion positions of the corresponding fragmentFp1inlp1; i.e., PosIn and PosOut (cf. Step 10 in Fig. 7). This becomes challenging ifpred′andsucc′of lphave no corresponding elements inlp1, or p has no interactions with p1. Utilizing the choreography modelGthen becomes primordial since it provides a global view on the interactions of all partners. Further, it contributes to identify the relationships between the elementspred′andsucc′of p, and the interaction activities of p1. The problem is shifted to finding the corresponding elements ofpred′andsucc′inG(i.e.,ξ(pred′)andξ(succ′)respectively), using the public-to-choreography mapping ξ. Then, we analyze the interactions inG, p1 is involved in, and which precedeξ(pred′)and followξ(succ′); i.e.,pred″=T_presetp1(ξ(pred′))andsucc″=T_postsetp1(ξ(succ′))respectively. Again, using the public-to-choreography mappingξ:G→lp1, we identify the insertion positions inlp1withPosIn=ξ(pred″)andPosOut=ξ(succ″). We distinguish two possible scenarios when insertingFp1:○Scenario 1: There exist no interaction activities betweenPosInandPosOutinlp1. In this case,Fp1should simply be inserted between PosIn and PosOut.Scenario 2: There exists a set S of interaction activities PosIn and PosOut inlp1. In this case,Fp1is merged with all elements of S.The DELETE change pattern allows removing an existing fragment from a process model. This becomes challenging if the fragment contains interaction activities referring to other partners. If we do not update the processes of these partners when deleting the interaction activities, incompatibilities in the choreography are introduced. For example, a partner might then wait for a message that will never arrive or send a message that will never be consumed. To avoid such errors, a propagation mechanism should be adopted that keeps the processes (i.e., the public models of the partners) compatible with each other. Further note that the deletion of an interaction might have transitive (i.e. indirect) effects that cannot be solely handled based on the process structure; i.e., knowledge about semantics is required.Example 7We consider a supply chain scenario. Assume that a local city council starts a new construction project and hence collaborates with a city planner being in charge of the project execution. In turn, the city planner interacts with several third party partners responsible for designing, supplying and building tasks. Therefore, if the city council cancels the project, the city planner must cancel his contracts with the other partners as well.This section does not consider the transitive effects of an interaction activity deletion, but only its direct structural effects. A non-exhaustive list of transitive scenarios as well as corresponding solutions are presented in Section 5. In the following, we use the example from Fig. 8to illustrate the most important steps for propagating activity deletions. Given a partner process πpand the fragmentF∈πpto be deleted, we proceed as follows:1.Isolated or propagating changes: We check whetherFsolely consists of private activities. In this case, the change can be considered as isolated and there is no need for any change propagation. If fragmentFcontains interaction activities, in turn, change propagation becomes necessary.Private-to-Public effects: To determine the impact the deletion of the interaction activity has on the public model of the change initiator, we apply the following steps:•We identify all interaction activities to be deleted by abstractingFwith respect to interactions; i.e.F′=abstrinteraction(F)(cf. Step 2 in Fig. 8).We identify the corresponding elements ofF′in the respective public model lpof p. To this end, we use private-to-public mapping function ψ and delete all elements ofF″=ψ(F)in lp(cf. Steps 3–4 in Fig. 8).Public-to-Public effects: To determine the change effects on the public models of the other partners, the following is applied: For each partner p1 involved inF″, we identify all interactions this partner is involved in by applying abstraction functionF‴=abstrp1(F″). For each element ofF‴, we determine the corresponding element inlp1using the public-to-public mapping function φ (i.e.,Fp1=φ(F‴)). Note that the elements ofFp1are not necessarily directly connected inlp1; they could be separated by other activities or gateways instead. To handle this case, for each of these elements we generate a separate delete operation. Finally, after each deletion, model refactorings may be applied (cf. Steps 5–7 in Fig. 8).It is noteworthy that the interactions between two partners are often accomplished synchronously in the sense that the partner process who sends a message to another partner process may wait for a response from the latter before proceeding with its execution. In certain scenarios, it might happen that the response is deleted due to a transitive effect of the first deletion. We will discuss these transitivity issues in Section 5.Change pattern REPLACE modifies the structure and elements of a given fragment in a process model. This pattern is particularly useful when the redesign of the entire process or a part of it becomes necessary; e.g. to optimize the flow between the activities; e.g., in the book trip example from Fig. 1, one might want to replace fragment PAR(Airline_notification_failure, TravelAgency_notification_failure)by changing this parallel branching into a choice CHC(Airline_notification_failure, TravelAgency_notification_failure). In the following, we refer to the change scenario from Fig. 9to illustrate the most relevant steps towards the propagation of the resulting changes. Given a fragmentF∈πpto be replaced by a new fragmentF′, change propagation can be accomplished as follows:1.Isolated or propagating changes: We first need to determine whether the fragment replacement constitutes a local change or needs to be propagated to other partners as well. For this purpose, we check whetherForF′contain any interaction activities. In this case, a propagation becomes necessary to maintain the compatibility between the partner processes. When replacing a fragment by another one, new interaction activities may be added, existing ones be removed, or the sequencing between interaction activities be changed. Accordingly, the partners directly affected by the fragment replacement are those interacting with p in the scope of bothFandF′(i.e., p1, p2 and p3 in the scenario from Fig. 9).Private-to-Public effects: To identify the effects of a fragment replacement on the public model lpof p, we first abstract fragmentsFandF′with respect to interaction activities. Then, we identify the corresponding elements to be replaced in lpusing the private-to-public mapping function ψ; i.e.F1=ψ○abstrinteraction(F)andF2=ψ○abstrinteraction(F′). The initial replace request is then transformed into aREPLACElp(F1,F2)operation that, in turn, needs to be propagated since it affects the interactions with other partners (cf. Steps 2–4 in Fig. 9).Public-to-Public effects: To determine the change effects on the public models of the other partners, we do the following:•When replacingF1byF2(cf. Step 5 in Fig. 9), three scenarios are possible: (i) a partner involved in the original fragmentF1is no longer present in the new fragmentF2(i.e., the interaction with this partner is deleted), (ii) a partner involved inF2was not present inF1(i.e., a new interaction activity is added), and (iii) a partner is present in both fragmentsF1andF2, but with different structure. Note that for one and the same replacement, we may have to deal with various scenarios of which each is related to a particular partner. Accordingly, we abstract both the new and the old fragmentsF1andF2with respect to each partner involved in the change. Accordingly, the REPLACE pattern is translated into a concatenationΔof change patterns to be propagated to the concerned partners.(i) Deletion scenario: If a partnerp′interacts with partner p in the context of the original fragmentF1and is not engaged in any interaction with p in the new fragmentF2, we delete the respective interaction activities from the public model ofp′(cf. Step 6a in Fig. 9). The deletion scenario is handled similarly as described in Section 4.2. (ii) Insertion scenario: If a particular partnerp′has no interactions with p in the context of old fragmentF1, but interacts with p in the new fragmentF2, we must insert the new interactions in the public model ofp′(cf. Steps 6b–8b in Fig. 9). The insertion scenario is propagated similarly as described in Section 4.1.(iii) Replacement scenario: The last scenario we consider is as follows: both fragmentsF1andF2involve interactions with partnerp′, but with different structure. The latter means that the control flow dependencies between the interactions have changed and, therefore, the public model ofp′shall be updated to preserve compatibility between all public models (cf. Steps 6c–7c in Fig. 9). For example, in the change scenario from Fig. 9 and in comparison withF1,F2keeps the same interaction activities with partner p1 for sending and receiving the messages m andm′, but with different structure; i.e., message m is not always sent due to the exclusive choice. Consequently, the public model of p1 should be updated and, in turn, the private model of p1 be adapted to the latter if needed. Formally, givenF1andF2, we apply an abstraction with respect to each partner involved in the change and compare both results. Ifabstrp′(F1)=abstrp′(F2)holds, no propagation top′is needed since the interactions withp′remain invariant. Otherwise, a propagation is needed and the current interactions inlp′must be changed to ensure compatibility with the new fragmentF2.When propagating the changes top′, first of all, we need to fetch the matching elements ofF1inlp′. In general, the interactions between p andp′in the scope of the old fragmentF1∈lpdo not always have the same structure or distribution inlp′(but the same behavior instead). This is due to the applied refactorings as well as the different interactionsp′has with the other partners; i.e., two interaction activities, which are directly connected in sequence in lp, are not necessarily directly connected in sequence inlp′, but could be separated by an interaction activity not involving p instead. The same holds for an interaction activity surrounded by a parallel branch (i.e., AND) inlp′, which could be refactored to a sequence in lp.Consider Fig. 9. If we look atF1′andF2′as the abstractions ofF1andF2in respect to p1, matching activities ofF1′=Seq(ψ(S(m,p1)),ψ(R(m′,p1)))∈lpareR(m,p)andS(m′,p)∈lp1. Note that these are separated by another interaction activity referring to p2. To integrate the change we must transformF2′, using the public-to-public mappingFp1=φ(F2′), and merge it with the smallest fragment containingR(m,p)andS(m′,p)∈lp1(i.e., the gray box inlp1in Fig. 9).In general, we must consider the smallest fragment containing all interaction activities ofF1′inlp′. Then, we must merge it with the corresponding elements ofF2′. For this, we must adopt an algorithm that merges two process models or fragments. Note that merging process models has been widely studied in literature [22,23]. The key idea is to merge different (and overlapping) process models into a single model without restricting the behavior represented in the original models. Formally, if we consider γas a merge function, the problem can be solved by mergingFp1=φ(F2′)withαlp1(φ(F1′)). It is noteworthy that such a merge might result in different scenarios among which the corresponding partner should chose the most appropriate one.This section discusses the change propagation approach and highlights the main steps that follow the public-to-public change propagation. Note that the following steps are outside the focus of this paper, but can be considered as complementary to our work.Negotiation: Computing change effects on the public models of the partners is automatic, relying on the presented algorithms. As shown in Fig. 6, after this step, a negotiation phase is required to approve or reject the intended changes. In general, such a negotiation cannot be fully automated, but requires an agreement among the partners. In particular, negotiations may involve human actors, e.g., through phone, e-mail, or meetings. Various approaches [60,59] exist that have dealt with negotiations in the context of process choreographies (e.g., based on service level agreements). Finally, note that negotiations might result in a redefinition of the initial change.Public-to-private propagation: The propagation of a process change to the partners׳ public models might require adaptations of their private models as well. In general, these adaptations cannot be determined by the partner that initiated the change. Accordingly, once all partners involved in the change have agreed on the public changes, each of them must determine the required changes of its private model. In particular, the new private model must be consistent with the changed public model. Note that changes of the partners׳ private processes, in turn, might lead to new changes that need to be propagated to other partners (i.e., transitivity). Since a change initiator must not access the private process of other partners, the partners affected by the change themselves are responsible for adapting their private processes to the requested change. In turn, this might lead to cascading effects or even the multiple involvement of a partner during change propagation.Change implementation: After all public and private changes are determined and agreed on, the soundness of the corresponding models is checked, the changes are implemented, and the public, private and choreography models are updated.In [35], a multitude of composite change operations are described of which not all are considered in this paper. In general, most change operations can be realized using the basic DELETE and INSERT operations; e.g., REPLACE can be considered as a combination of a DELETE followed by an INSERT. However, change propagation complexity varies significantly. Worst case, for example, the complexity of directly propagating a REPLACE is equal to the one of a DELETE followed by an INSERT. Indeed, the REPLACE operation refers to a fragment instead of a single node. Accordingly, replacing a fragment by a new one not means that all nodes of the old fragment are changed. Taking the nodes that remain unchanged into account significantly improves the propagation process and reduces the number of operations to be propagated. Regarding the REPLACE algorithm (cf. Algorithm 2), the three possible scenarios (i.e., deletion, insertion and replacement) are solely generated for parts that have changed. By contrast, unchanged parts do not require any propagation. However, a DELETE followed by an INSERT will first delete those parts, which entails a propagation to concerned partners, and then re-insert the same parts (entailing another propagation).This section presents a non-exhaustive list of use cases demonstrating the transitivity effects of the DELETE change pattern and the solutions to cope with them. Note that this is a semantic issue that cannot be resolved based on the propagation algorithms presented so far, which solely focus on structural issues. As example consider a scenario with three partners p1, p2 and p3. Assume that p1 invokes p2 and p2 invokes p3. The latter returns the intermediary result to p2, which then applies data transformations before sending the final result to p1. If now p1 decides to delete its interaction with p2, one must further delete the subsequent interaction between p2 and p3, which is solely used to deliver the final result. If a partner deletes an interaction, semantically, this means he is unable to afford this service anymore or he does not need the data anymore. Then, the challenge is to determine whether an interaction has transitive effects on other interactions, and if yes, to identify and resolve these transitive effects.Case 1. Partner p is the final consumer of a data element, and it launches an interaction that requires a response. Accordingly, p contains related interaction activities send and receive. Thereby, send is used to request the data from another partner, whereas the corresponding receive is used to receive the response to this request from another partner.•Case 1.1 p deletes the send/receive interaction activities; i.e., it does not need the data anymore (since p is the final consumer). Accordingly, we deletesend¯andreceive¯. In case all subsequent interactions with other partners are solely used to deliver this data, these interactions are deleted as well (e.g. supply chain scenarios). Of course, it is also possible that only a subset of the subsequent interactions are used to deliver this data. These interactions are then deleted only if they do not have any other role in the choreography; i.e., they are not required to calculate any other data (cf. Scenario 1 in Fig. 10). If they play another role in the choreography, in turn, the subsequent interactions are kept (cf. Scenario 2 in Fig. 10).Assume that there are two concurrent requests from partners A and B to partner C. Further assume that C is involved in subsequent interactions and then replies to A and B. If A deletes its interaction with C, we must not delete the subsequent interactions of C since they are still required to reply to B.Case 1.2 p solely deletes the send pattern. We distinguish two scenarios:(i)Another partner starts the communication instead of p. Accordingly, we just update the correspondingsend¯with the new partner.p is not responsible anymore for triggering the other partner to deliver the response; i.e., the latter is provided automatically or under certain constraints. Hence, we delete the correspondingsend¯(cf. Scenario 3 in Fig. 10).Case 1.3 p solely deletes the receive pattern. This means either p does not need the data anymore or the latter is transferred to another partner. In the first case, we just delete the correspondingreceive¯and look for other interactions correlated with this response (used solely for delivering the response, cf. Scenario 4 in Fig. 10). In the second case, we update the correspondingreceive¯with the new partner.Case 2. Partner p corresponds to the final consumer of the data, but is not responsible for launching the first interaction; i.e., p has only the receive. If p deletes the receive (i.e., p does not need the data anymore), we delete the correspondingreceive¯as well as all subsequent interactions that are solely used to deliver this data. All interactions participating in the delivery of this data, but having another role in the choreography, are kept.Case 3. Partner p is the starting point, responsible for starting an interaction that results in a response to another partner; i.e., p has the send. Either (i) another partner is responsible for starting this interaction; then, we update thesend¯with the new partner, or (ii) the interaction starts automatically or under other constraints on the target partner; then we delete the correspondingsend¯. Subsequent interactions are not deleted since we still need the final data to be delivered to the final consumer.Case 4. Partner p is an intermediary partner, and has correlated interaction activities receive and send. p receives a request and starts a subsequent interaction necessary for delivering the final response to the requester.•Case 4.1 Partner p deletes both the send and the receive interaction activities and is unable to provide the data anymore. However, still the final response to the requestor is needed. In this case, two choices exist: (i) Looking for another partner that can take over the task of p to deliver this response. Then, we update the subsequent interactions as well as the ones of the root partner (i.e., the partner that invoked p and the one to whom p shall send the result) with this new partner. (ii) Deletingsend¯andreceive¯as well as all subsequent interactions solely used in the context of this intermediary data, and looking for another partner or set of partners that can provide this data. Then, we update the interactions with the root partners or p. As example consider Scenario 5 in Fig. 10. If Partner3 is able to accomplish the data transformation (d=f(d1)) of Partner2, the interactions of Partner1 with Partner2, which serve to deliver data d, are replaced by new ones with Partner3.Case 4.2 If p solely deletes the send interaction activity, another partner is responsible for starting this intermediary interaction or the subsequent interactions start automatically or under other constraints. In the first case, we update the correspondingreceive¯with the new partner, otherwise we just delete it.Case 4.3 If p solely deletes the receive pattern, this means that p cannot take over the tasks necessary to deliver the final data. (i) If other operations are necessary to deliver the final data, we look for another partner that can accomplish the same tasks. (ii) If not, we update theSend¯to link it directly with the root partner (cf. Scenario 6 in Fig. 10).Conclusion. We presented a non-exhaustive list of possible scenarios of transitivity when dealing with change propagation. Clearly, transitivity is a semantic issue and requires a data model defining the relationships between the exchanged data objects (e.g., an ontology). Due to privacy issues, in addition, not all data correlations are always known, and therefore calculating the transitivity effects remains problematic and cannot be fully automated. Several proposals exist to predict the transitive effects in process choreographies based on prediction metrics (e.g. social graphs) [10].This section discusses soundness issues of a process choreography in the context of change propagation. In particular, we check whether the compatibility and consistency properties of the collaborating business partners are kept. Accordingly, we assume that the initial public models of the collaborative processes are compatible with each other and that each private model is consistent with its corresponding public model. We further assume well-behavedness of the change operation in terms of structure and semantics. Recently, several proposals were made on checking the soundness of choreographies in terms of compatibility and consistency [15,24–28].Before discussing the compatibility and consistency of the process choreography in the context of change propagation, first of all, we introduce useful properties. Thereby, Property 1 states that for each node of the public model of a partner p, there should be a matching element in the corresponding private model of p, but not vice versa. Furthermore, Property 2 expresses that for each node of the public model of a partner p, there should be a matching node in a different public model of another partner. Note that this is a necessary, but not yet sufficient condition for ensuring compatibility between public models. Finally, Property 3 states that for each node in a public model, there should be a matching node in the choreography model. In particular, for each interaction in the choreography model, there should be exactly two matching interaction activities in the public models. Formally:Property1∀l_node∈lp,∃p_node∈πpwithψ(l_node)=p_node.∀l_node∈lpwithtype(l_node)=InteractionActivity:∃p′≠p:∃l_node′∈lp′with type(l_node′)=InteractionActivity∧φ(l_node)=l_node′.∀l_node∈lp:∃c_node∈Gsuch thatξ(l_node)=c_node.abstrp′(F)∈Lp⟹abstrp′(F)¯∈abstrp(Lp′). The complement of the abstraction of a fragmentF∈Lpfrom the perspective of a participantp′is a fragment of the abstraction ofLp′according to p.The proof of this lemma can be based on the following compatibility properties of choreographies. (c.f. [15]).•Ifa∈Lpcorresponds to an activity that interacts with partnerp′, the following holds:∃b∈Lp′withb=a¯.If ai,aj∈Lpare two activities interacting with the same partnerp′andβ(ai,aj)is a function returning the minimal precedence relation (i.e., control flow path) between aiand aj[21], the following property (also denoted as bi-simulation property [15,18]) holds:∃bi,bj∈Lp′withbi=ai¯,bj=aj¯∧β(ai,aj)=β(bi,bj)□In our context, consistency means that the implementation of a business process (i.e., a private model) is consistent with its observable behavior (i.e., public model). This ensures that implementations of private processes satisfy the interaction constraints defined in the public models [15]. In our change propagation approach, the public model is defined as an abstraction of the private model by deleting all model elements not related to any interaction (e.g., Property 1). Accordingly, an insertion, deletion or replacement of a fragment in a private model needs to be transformed into an insertion, deletion or replacement of the fragment abstraction in the public model (if required). Since any abstraction preserves the consistency between the original and abstracted model (cf. [29,30]), the propagation from private-to-public does not affect consistency. Regarding deletion or replacement scenarios, refactorings may be applied. In turn, this eliminates unnecessary synchronization elements (e.g. a parallel branching between an activity and an empty branch is reduced to a sequence), but does not affect the consistency between the original and abstracted model. Change propagation might also result in the insertion, replacement or deletion of a fragment from a public model of a partner target. If the change is accepted by the latter, the change requester cannot check for the consistency between the public and private model of that partner since the private model of the latter is not visible. Our approach assumes that any partner affected by the change should update his private model locally if he accepts the change request. In turn, this update must be consistent with the new version of his public model.Compatibility is a soundness criteria that checks whether the interacting partners are able to communicate with each other in a proper way (e.g., no deadlocks or livelocks will occur). In this context, [15] distinguishes between structural and behavioral compatibility:Structural compatibility: It requires that for every message that may be sent, the corresponding partner is able to receive it. In turn, for every message that can be received, the corresponding partner must be able to send a respective message. Regarding our propagation mechanism, structural compatibility is always preserved. Depending on the change operation type, for each affected partner we add, update, or remove the complement of what has been changed in the process of the change initiator. In particular, for each interaction activity send in one process partner source, we insert or delete the corresponding receive interaction activity with the expected attributes (e.g. message) in the process of the partner target (i.e., affected by the change) and vice versa (cf. Properties 2 and 3, and Lemma 1).Behavioral compatibility. It considers behavioral dependencies (i.e., control flow) between message exchanges, i.e, it deals with the ordering of the partners׳ interactions. For example, a Receive encapsulated by a Sequence in one partner process should not be linked to a Send encapsulated by a Choice in the process of a different partner. Indeed, this might lead to a deadlock in case the path containing the Send in the Choice is not executed during runtime.Assume that(δ,πp)is the change operation to be applied to process model πpand(δ,Lp)corresponds to the inferred change to be applied to the public model of p. Further, letΔbe the set of changes inferred from(δ,Lp) to be propagated to its directly affected partners. For each affected partnerpi,(δi,Li)represents the inferred change operation to be propagated to its public model; i.e.,Δ=∧i=1‥n(δi,Li), where n corresponds to the number of affected partners. Note that the number of inferred changes is finite since we only consider propagations to direct partners. In turn, changes that might have structural effects on other partners (due to transitive relations) are propagated to them through their direct partners recursively.If(δ,Lp)is invariant (i.e., it does not affect the public model of p), consistency and compatibility are preserved over the collaborative partners. In addition, since both processes and changed fragments are structured, consistency and compatibility relations can be reduced to those existing between the fragments affected by the change.•The INSERT pattern augments the process models of the partners affected by the change with new activities and gateways respectively. Further, it does not affect the structural or behavioral dependencies (i.e., control flow) between the existing activities. However, some direct precedence relations between activities may be transformed into transitive ones (due to the insertion of new activities and gateways). The propagation of a change operation of type INSERT results solely in change operations of type INSERT in the public models of the affected partners. According to a particular partner, the insertion is done with respect to the direct and transitive dependencies with the activities of the same partner. As explained in Section 4, ifFcorresponds to the fragment to be inserted inLp,abstri(F)¯is the fragment to be inserted inLi. Note that the latter shows the same behavior (i.e., control flow) asabstri(F). In turn, the insertion position is computed based on the transitive preset and postset ofFiwith respect to partner i. Note that this preserves the order of the fragments and ensures their behavioral compatibility after propagating the INSERT operation. This propagation might result in a merge of the fragment to be inserted with an existing fragment as described in Algorithm 3. In particular, if the partner affected by the change interacts with different partners in the scope of the calculated insertion positions (i.e., there exist others interactions activities between the identified positions pred and succ), the fragment to be inserted between these two positions must be merged with the existing interaction activities in between. Accordingly, we assume that merge functiongamma:(F,F′)→F″preserves the behavior ofFandF′in the resultF″of the merge.The DELETE operation reduces the process models of the partners affected by the change. This reduction is accomplished in a symmetric way on both sides; i.e., p and the partners affected. The deletion of an activity on one side results in the deletion of the correspondinga¯on the other. Structural and behavioral compatibilities are kept. However, other issues emerge, e.g., an activity might wait for data that will never arrive or send a message that might not be consumed. The solution we proposed in Section 5 deals with typical use cases where the correlated interactions are updated or deleted accordingly. Note that this neither affects structural nor behavioral compatibility of the propagation.The propagation of the REPLACE operation results in three scenarios: insert, delete, or merge. Assume that the merge function γ is correct and idempotent, preserving the behavior of the merged fragments. We considerFiandFi′as the fragments to be merged. Then, the behavior ofFiis reflected by the merge resultγ(Fi,Fi′)(cf. Lemma 1).The consistency between the public and private models of the partners affected by the change will be checked if negotiations succeed. Each of these partners must then adapt its private model to the change of its public model. Using consistency rules, each partner can check locally whether or not its private model is consistent with its public model. More details about consistency checking and the validation of choreographies can be found in [5,2].This section outlines the architecture of our change propagation framework for process choreographies and presents the prototypical implementation of the C3Pro Editor as one of its core components.Our architecture must provide functions for defining and executing process choreographies. Further, it must allow specifying, performing and propagating changes. To meet these requirements, we propose a layered architecture as depicted in Fig. 11. It consists of three layers: Process Definition, Process Change, and Process Execution.The main change propagation functions are realized by the Process Change layer. TheC3ProEditor is one of the core components of this layer that realizes the change propagation algorithms presented in Section 4. Other functionalities provided by existing tools are delegated (e.g. process modeling and execution); i.e., although we focus on the functionalities of the Process Change layer, we communicate with the other two layers as well.In the Process Definition layer, process designers use existing modeling tools (e.g., Signavio or jBPM) to create process as well as choreography models. The latter are serialized as XML or JSON files and serve as input for the Process Change layer. In turn, the latter layer defines all components related to change propagation in choreographies. Most prominently, the Change Management Service implements Algorithms 3–2 as well as the internal representation (IR) of private, public and choreography models. The functions of the other components from the Process Change layer are follows:•Versioning capabilities are provided that allow undoing as well as redoing changes.Dynamic adaptation is enabled to deal with the migration of running process instances.Model verification is supported to verify the soundness of the models resulting after a change.Negotiation becomes necessary if a change is not acceptable for a partner. This component deals with strategies applicable if a negotiation is required (cf. Fig. 6).All functions provided by the Process Change layer are exposed as a RESTful service, which allows for a unified access from any client able to communicate via HTTP. The Change Management Service can be accessed with theC3ProEditor serving as the connector to the Process Definition layer. TheC3ProEditor provides functions for importing and visualizing choreography models. Moreover, changes may be applied to the models and required change propagations to partners be performed, allowing for the simulation of change propagation. Altogether, theC3ProEditor serves as the front end for all components defined in the Process Change layer.The Change Management Service serves as a pluggable middleware based on which process engines can be integrated. In particular, this integration allows these engines to access all components of the Process Change layer. This implies that after a successful change propagation, which includes negotiation and soundness checks (cf. Fig. 6), the updated choreography models are transformed into an executable form being directly passed to the process engine for enactment (Process Execution layer). In other words, from the perspective of the Process Change layer, the Process Execution layer serves as an execution platform for the updated models. The process execution engine we have chosen is the Cloud Process Execution Engine (CPEE).In the following, all occurrences of nodes refer to PNode (i.e., activities and control nodes) from Definition 3. We implemented theC3ProEditor as the first prototypical client realizing the Change Management Service. In particular, this client component takes the role of a simulation environment for manually stepping through the change propagation process (cf. Fig. 6), which allows testing and verifying change scenarios. Altogether, theC3ProEditor supports the visualization of1.private, public and choreography models,affected partners׳ nodes and fragments depending on the change type (i.e., INSERT, DELETE or REPLACE), andthe models resulting after the application of the calculated changes.A multitude of process modeling tools exist. For this reason, we delegate the basic modeling functions to these tools. In our case, we have used Signavio [14]. We export the created models to BPMN 2.0 XML format. In turn, the latter is directly supported by our change propagation library for importing models. Once imported, models can be visualized and all changes be performed with theC3ProEditor. The latter is accomplished by propagating the changes to each affected partners. TheC3ProEditor not only visualizes process models before and after a change, it also displays auxiliary information such as the affected partners׳ nodes and fragments. We utilize the jBPT44https://code.google.com/p/jbpt/library for handling the transformation of models (private, public and choreography) to RPST.We realized the Change Management Service as a Java Library (JAR), which enables any language running on top of the Java Virtual Machine (JVM) to access the underlying public classes and static functions. This allowed us to develop theC3ProEditor in a rapid fashion, still treating the Change Management library as a service. A frequently changing API would have hindered the concurrent development of the service and the editor. After finalizing the API and identifying the required functionalities, we implemented the REST infrastructure for the Change Management Service theC3ProEditor consumes.We chose Clojure as programming language that is amendable for rapid prototyping and iterative development. Further, it has a rich Read Eval Print Loop (REPL) environment. Its default runtime platform is JVM, enabling seamless interoperability with the Change Management service. Clojure follows a functional programming style and provides concurrent functionalities; the latter are important for GUI application development. Finally, it allows changing the behavior of a running program without restarting it and hence reducing development efforts significantly.Figs. 12 and 13depict screenshots of theC3ProEditor. The Project Explorer on the left-hand side shows the current choreography model as well as the public models of all partners participating in the collaboration. Double clicking on any one of these items will display the corresponding model as a graph in the Graph Panel. In turn, the Graph Panel visualizes the selected graph as expected. Left-clicking on a node in the displayed graph will bring up its detailed information in the Detail Panel and show the related nodes in the Related Nodes Panel. The related node depends on the currently selected one. For each send message, the associated receive message is found and displayed, and vice versa. If an interaction activity (i.e., a node of the choreography model) is selected, the actual send and receive messages are picked from the appropriate public models and displayed in the Related Nodes Panel. If gateways (i.e., ControlNode of Definition 3) are selected, the smallest fragment (see Definition 9) that surrounds the selected gateway is displayed in the Related Nodes Panel.Change operations are shown to the user by right-clicking on a node within the Graph Panel as well as on the left side below the Project Explorer (as buttons). When clicking one of the provided operations, a dialog window pops up prompting the user to specify the change. In the scenario depicted in Fig. 12, the user is asked to load the fragment for the INSERT operation. Afterwards, theC3ProEditor applies the change and triggers the change propagation process required. Fig. 13 shows the screen after applying an INSERT operation. Furthermore, the Graph Panel allows for the display of a process model in terms of an RPST. Finally, the Change Log shows the output during the processing of a change propagation.As we were unable to find publically available choreography models that can serve as the basis for our simulation, we opted to use the trip booking example (cf. Figs. 1–3). We used the Signavio Process Editor to model both the choreography models and the partner-specific public models of the choreography. Note that it was ensured that all models are structurally as well as behaviorally sound. Further on, we ensured that the process models are block-structured, which, in turn, allowed for their easy transformation into corresponding RPST representations. In case unstructured models shall be imported, the techniques described in [18] can be applied to transform most of these models into structured ones.Models are exported as XML files and then imported as initial data set into theC3ProEditor. In total, 17,068 change operations of type INSERT, DELETE, and REPLACE were created and tested on the prototype.

@&#CONCLUSIONS@&#
