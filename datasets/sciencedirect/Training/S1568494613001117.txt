@&#MAIN-TITLE@&#
An immunoglobulin-based artificial immune system for solving the hybrid flow shop problem

@&#HIGHLIGHTS@&#
This paper addresses a hybrid flow shop with minimizing makespan.An immunoglobulin-based artificial immune system (IAIS) is proposed.IAIS is better fit the natural immune system and easy to understand.A new somatic recombination and a new hypermutation are proposed in IAIS.Computational results show that IAIS is very competitive.

@&#KEYPHRASES@&#
Artificial immune system,Hybrid flow shop scheduling,Scheduling,Makespan,

@&#ABSTRACT@&#
We consider the n-job, k-stage problem in a hybrid flow shop (HFS) with the objective of minimizing the maximum completion time, or makespan, which is an NP-hard problem. An immunoglobulin-based artificial immune system algorithm, called IAIS algorithm, is developed to search for the best sequence. IAIS, which is better fit the natural immune system, improves the existing AIS by the process before/after encounter with antigens. Before encounter with antigens, a new method of somatic recombination is presented; after encounter with antigens, an isotype switching is proposed. The isotype switching is a new approach in artificial immune system, and its purpose is to produce antibodies with the same protection but different function to defense the antigen. To verify IAIS, comparisons with the existing immune-based algorithms and other non-immune-based algorithms are made. Computational results show that IAIS is very competitive for the hybrid flow shop scheduling problem.

@&#INTRODUCTION@&#
In a hybrid flow shop (HFS), machines are arranged into s stages in series. In each stage k, k=1, 2, …, s, there are mkidentical parallel machines. Job j, j=1, 2, …, n, has processing times at each stage (p1,j, p2,j, …, ps,j) and has to be processed on any one machine at each stage. Each machine can process only one job at a time and preemption is not allowed. We consider the HFS problem with the objective of minimizing the maximum completion time, or makespan. The problem has been proved to be NP-hard by Gupta [1] in a two-stage environment even in the case when there is more than one machine at a stage.The application of hybrid flow shop (HFS) problem was first proposed by Salvador [2]. He recognized the problem in the polymer, chemical, process, and petrochemical industries. In specific, assembly line in which more than one product may be manufactured and each work station has multiple machines is a common application of the HFS problem. Also, the situation where parallel machines are added at one or more stages of a flow shop to ease the pressure on bottleneck facilities or to increase the production capacities can be viewed as a HFS application.Many different approaches have been proposed to solve the HFS problem [3]. One of the approaches mostly used for the HFS problem is the branch and bound approach, such as Arthanari and Ramamurthy [4], Brah and Hunsucker [5], Riane et al. [6], Moursli and Pochet [7], and Carlier and Néron [8]. The branch and bound approaches are suitable for small and median-sized problems, but they are time consuming when the size is large. Hence, heuristics and metaheuristics have been applied to find near optimal solutions in acceptable computational time.Gupta [1], Gupta and Tunç [9], and Gupta et al. [10] developed several heuristics for a two-stage HFS to minimize the makespan and other objectives. Gupta and Tunc [11] developed four heuristics for a two-stage HFS with separable setup and removal times to minimize the makespan. Lin and Liao [12] presented a case study of two-stage HFS in a label manufacturing company to minimize the total weighted maximal tardiness. Also, Heydari and Fakhrzad [13] proposed a heuristic for HFS to minimize the sum of the earliness and tardiness costs.Metaheuristics have become a popular approach to solve the HFS problem in recent years. Janiak et al. [14] applied simulated annealing (SA) and tabu search (TS) to solve the HFS problem with a cost related objective. Genetic algorithm (GA) was applied by many authors for solving HFS with the objective of minimizing the makespan [15–18]. It is worth mentioning that the benchmark problems generated by Carlier and Néron [8] were used as test problems by many metaheuristic algorithms, such as artificial immune system (AIS) in Ref. [19,20], genetic algorithm (GA) in Ref. [15], and ant colony optimization (ACO) in Ref. [21,22].Recently, AIS algorithms have attracted special attention in the scheduling problem especially in flow shop scheduling. Alisantoso et al. [23] considered a flexible PCB flow shop scheduling problem by using an immune algorithm. Khoo and Situmdrang [24] dealt with the design of an assembly system for modular products by using an approach based on the principles of natural immune systems. Kumar et al. [25] used an AIS to tackle a continuous flow shop problem with total flow times as the principal criterion. Zandieh et al. [26] used an AIS to solve hybrid flow shop scheduling problems with sequence-dependent setup times. Tavakkoli-Moghaddam et al. [27] considered a no-wait flow shop scheduling problem with a new hybrid multi-objective algorithm based on a biological immune system. For the job shop scheduling problem, Khilwani et al. [28] designed a clonal algorithm to solve various numerical and combinatorial real-world optimization problems, including job shop and other scheduling problems. An AIS algorithm for solving the minimum makespan problem of job shop scheduling was proposed by Ge et al. [29]. An AIS based on integrated approach was also proposed by Bagheri et al. [30] for solving a flexible job shop scheduling problem.In this paper, we will present an immunoglobulin-based AIS (IAIS) algorithm, which is better fit the natural immune system and improves the existing AIS by isotype switching. The natural immune system is complex, but only clonal selection and affinity maturation are considered in other AISs. The proposed IAIS algorithm is inspired by somatic recombination and isotype switching of immunoglobulin in the natural immune system. The antibodies are organized differently from other genes by somatic recombination to create more antibodies. In addition, isotype switching is used to produce antibodies with the same protection but different function to defense the antigen. The process of isotype switching strengthens the antibody's ability to defense antigen. The IAIS will be tested on the benchmark problems of Carlier and Néron [8]. However, the benchmark problems are not difficult, so we will propose new set of benchmark problems.The remainder of this paper is organized as follows. In the next section, the natural immune system is introduced. In Section 3, the IAIS algorithm is developed to search for the near or optimal sequence. Computational results for comparison of IAIS with other metaheuristic algorithms are provided in Section 4. Finally, conclusions and future research directions are given in Section 5.To develop a new artificial immune system for a HFS problem, the natural immune system based on the book by Parham [31] needs to be studied. Animals use the immune system to defend their bodies from invasion by other organisms. Antibodies are produced by B cells of the immune system in response to infection. Their function is to bind pathogens when pathogens are encountered in the body. The molecules to which antibodies bind are called antigens. When antigens and antibodies have complementary shapes, antigens can be identified and then be destroyed by the immune system. The process can be corresponded to the objective function of our proposed problem. After binding, the antibody disables the pathogens so that the pathogens are destroyed easily by the immune system.It is noted that antibody is the secreted form of immunoglobulin different from general gene. The function of immunoglobulin is very important in the natural immune system because immunoglobulin expressed on the B cell is a cell receptor of antigen which can identify and then destroy pathogens. The developing process of immunoglobulin generation can be separated into two parts, before encounter with antigen and after encounter with antigen (see Fig. 1).Before encounter with antigen, the number of different antibodies that can be produced by human body seems to be limitless. Thus, the immunoglobulin genes are organized differently from other genes by somatic recombination.Somatic recombination produces diversity in the antigen-binding sites of immunoglobulin. Each antibody is formulated by the genes which are sequenced as a string. To form a string, a single gene of each type is brought together and then the partial genes of antibody are cut and spliced randomly by somatic recombination during the development of B cells.After encounter with antigen, the huge amount of IgM will be generated to defense the antigen. When the pure IgM faces an antigen, the sequence of IgM's gene is changed by somatic hypermutation as follows.Somatic hypermutation gives rise to B cells bearing mutant immunoglobulin molecules on their surface. The first pure antibody produced after an encounter with antigen is IgM. The function of IgM is to identify the antigen because IgM is a pure antibody with lower ability to bind antigen and it tries to become stronger by somatic hypermutation. The mutations occur at the sequence of the gene in each IgM, which is more than a million times greater than other mutations for a gene.Then, isotype switching is proposed in pure antibody of IgM in order to make the pure antibody more powerful. The process from IgM to one of three isotypes of immunoglobulins (IgG, IgA, and IgE) is called isotype switching. The functional effect of isotype switching is to produce new antibodies with the same protection but different function. In the natural immune system, a B cell can have several different immunoglobulins after several times of isotype switching. After somatic hypermutation, IgM can get higher affinity but it is still hard to catch the antigen. Some antigens hide in a special part where IgM can find them but cannot destroy them. Due to this limitation, isotype switching is used in the natural immune system.IgG is smaller and more flexible than IgM, and thereby it is easier to access antigen in the spaces of damaged and infected tissues. The function of IgA is to transport and diffuse into extra vascular. IgA is the major antibody in gastrointestinal surface and it can penetrate the blood. No isotype of immunoglobulins can defend the antigen in the extra vascular except IgA. IgE is an immunoglobulin with the function of sensitization of mast cell which can identify and destroy the antigen.The bone marrow pushes out billions of B cells into the peripheral circulation in a day. Those B cells are stored in a repertoire where there is a limited space for the B cells. Unless B cells encounter the specific antigen, B cells are dead within a period. Thus, B cells repertoire is never static, and newly generated antibodies are continually being tested against the antigen infection.Affinity is a force between antigen and antibody. The better the general fit between the interacting surfaces of antigen and antibody, the higher the affinity is. After somatic hypermutation, some of mutant antibodies with higher affinities may be produced. This phenomenon is called affinity maturation.According to the process of natural immune response, an immunoglobulin based artificial immune system algorithm is proposed in the next section.In this section, the structure of the proposed immunoglobulin-based AIS algorithm (IAIS) is presented. The basic idea of IAIS comes from the natural immune system where the objective is to disable the antigens quickly and effectively. Evolution of IAIS is based on the somatic recombination and affinity maturation of the natural immune system. The proposed algorithm is summarized below:Create a population of A antibodies (A is the parameter of antibody population size):For each generation do:For each antibody do:Somatic recombination;Calculate the objective function (affinity) of the antibody;Somatic hypermutation:Decode the new string;If the objective function (new)<the objective function (old)thenantibody=new stringelseIsotype switchingDecode the new string;If the objective function (new)<the objective function (old)thenantibody=new stringelseantibody=antibody;Eliminate antibodies except the best antibody in the populationGenerate the new antibodies and replace with the eliminated ones;While stopping criterion=false.The stopping criteria can be based on: a lower bound, the number of generations, the limited CPU time, or the number of consecutive iterations with no improvement for the best solution. In this paper, the lower bound and the limited CPU time are used as the stopping criteria because a lower bound is a value which is guaranteed less than or equal to the optimal solution. If a solution by IAIS reaches the lower bound, the solution must be optimal. The details of IAIS are presented as follows.We use the methods of encoding, decoding, and affinity calculation the same as in Engin and Döyen [19]. Each possible schedule is represented by a string with n jobs. The string is accepted as an antibody of the proposed AIS algorithm. Each antibody has a makespan value calculated by decoding a string that refers to the affinity value of that antibody. Affinity value of each schedule is calculated by the affinity function as defined below:(1)Affinity(z)=1makspan(z)where z is the considered antibody. From the equation, a lower makespan value possesses a higher affinity value.In somatic recombination of the natural immune system, a single gene of each type is brought together to form a string of immunoglobulin and then the partial genes of antibody are cut and spliced randomly. In IAIS, a number B of n jobs are randomly selected in each antibody and the sequence of antibody with the best objective function in the current generation is used to be a standard string. A standard string can be defined as forming an immunoglobulin and then, those selected jobs in the antibody should follow the sequence of the standard string to rearrange its sequence. An example of somatic recombination is presented in Fig. 2, where there are 5 jobs in a HFS problem. Job 4 in position 3 is randomly selected as a immunoglobulin in the current antibody while Job 4 of standard string is in position 2. Thus, Job 4 is cut in position 3 and spliced in position 2 in the new antibody.IgM is the first antibody after encounter with antigen. The first produced antibody always has lower affinity compared to other isotypes. The main function of IgM is to find the possible position of antigen and identify the antigen. Thus, the inverse mutation is used here because it can search a broader area. For a sequence s, let i and j be randomly selected two positions in the sequence. A neighbor of s is obtained by inversing the sequence of jobs between i and j positions. It is noted that it is not allowed to be mutated if |i−j|<2.There are four isotype immunoglobulins, IgM, IgG, IgE, and IgA. Each isotype has a different function. If the makespan of a new string in IgM is larger than that of the old one, three isotype immunoglobulins, IgG, IgE, and IgA are randomly selected to be the next mutated method.The property of IgG in natural immune system is smaller and more flexible than IgM, and thereby it is easier to access antigen in the spaces of damaged and infected tissues. The pair-wise mutation is used because it can find the antibody's neighborhood quickly and deeply. For a sequence s, let i and j be randomly selected two positions in the sequence. A neighbor of s is obtained by swapping these two jobs.The function of IgA is to penetrate the blood and protect other areas where IgG cannot reach. The insertion mutation is used because it can find remote neighborhood of current sequence. For a sequence s, let i and j be randomly selected a job and a position in the sequence. A neighbor of s is obtained by inserting the job i to the position j.The function of IgE is to identify and destroy the antigen. Both the pair-wise and insertion mutations are used here because the property of pair-wise is to identify the local optimal solution and then the insertion is used to avoid falling into the local optimum. For a sequence s, let i and j be randomly selected two positions in the sequence. A new sequence s′ is obtained by swapping i and j. Then, let i′ and j′ be randomly selected a job and a position in the sequence. A neighbor of s′ is obtained by inserting the job i to the position j.In the IAIS algorithm, an antibody of IgM will repeat R times to become one of the three isotypes of immunoglobulins. Then one of the R antibodies with the highest affinity will be compared with the original affinity of IgM. If the original affinity is lower than the new one, the new antibody will be recorded in the repertoire.In the early steps of our algorithm, it is more possible to find a better sequence by employing the inverse mutation because the algorithm is still far away from good solutions and the large mutation (i.e., inverse mutation) may cause to find better job sequences. In the later steps, it is more efficient to make relatively small mutations, such as the pair-wise (IgG), interchange (IgA), and both (IgE) mutation methods.According to the limited space of repertoire, the antibodies are deleted except the best antibody of the current generation. The new antibodies are generated randomly and are replaced with the deleted one.Both IAIS and AIS of Engin and Döyen [19] are evolutionary and biologically immune-based algorithms. There is no difference between IAIS and AIS in antibody and affinity function. However, their evolutionary search procedures differ from each other and the details follow.The first difference is the structure. The structure of AIS is clonal selection and hypermutation, which are the process after encounter with antigen. In IAIS, three main steps, somatic recombination, somatic hypermutation, and isotype switching, are proposed. Second, the affinity maturation of AIS is a two-phased mutation procedure. The antibody is generated by executing an inverse mutation (i.e., identify the antigen) followed by a pair-wise mutation (i.e., bind the antigen). In fact, several kinds of methods to bind the antigen are used not only in somatic hypermutation but also in isotype switching of the immune system. Therefore, IAIS also considers hypermutation and isotype switching processes in the natural immune system to bind the antigen. To sum up, although IAIS has the similar immune based structure as AIS, IAIS is more related to the natural immune system than AIS.In this section, we present the results of a series of computational experiments conducted to verify the performance of the proposed IAIS algorithm. The algorithms were programmed in C++ and run on an Intel Core 2, 1.83GHz, 2.0 GB RAM.As mentioned earlier, Carlier and Néron's benchmark problems [8] have been solved by several researchers using different methods, such as artificial immune system (AIS) by Engin and Döyen [19], quantum-inspired immune algorithm (QIA) by Niu et al. [20], genetic algorithm (GA) by Besbes et al. [16], ant colony optimization (ACO) by Alaykyran et al. [21], and Khalouli et al. [22].The machine configuration (or machine layout) has an important effect in solving the problem. There are four machine configurations, a, b, c, and d, which represent the type of bottleneck stage. For example, the type “a” represents a 33133 HFS configuration, so the notation “jXXc5aX” denotes that there are 5 stages and the numbers of machines in the stages are 3, 3, 1, 3, 3, respectively. In a and b type problems, each stage has 3 machines except a stage with only one bottleneck machine. The c and d type problems have 2 and 3 machines in one of the stages, respectively. The solutions found by those algorithms in Ref. [16,19,20,22] are used for comparison.It is noted that there are two different objective function calculations among the existing algorithms. The first calculation, used by Alaykyran et al. [21], is to consider two decisions in the solution construction: the operations assignment to machines and the operations sequencing on machines. For the other algorithms in Ref. [16,19,20,22], the list scheduling is used in the first stage, where each job is assigned to the earliest available machine based on the sequence of antibody. In the following stages, the job with the earliest completion time is first assigned to the earliest available machine. Then the remaining jobs are assigned by the same method as above successively. The list scheduling is used for our IAIS algorithm.Preliminary tests were conducted to find the good parameter settings: A=10, B=4, and R=10. In the formal experiments, the run time was limited to 1600s or until the lower bound (LB) in Ref. [8] was reached. If the LB was not found within the time limit, the search was stopped and the best solution was accepted as the solution. The performance of the algorithms was calculated by the percentage deviation between the solution and the lower bound as follows:(2)%deviation=bestCmax−LBLBEach of the problems was run ten times to obtain the best Cmax and the average CPU time for IAIS. For other algorithms, we obtained the computational results from their original papers. It is noted that AIS by Engin and Döyen [19] and GA by Besbes et al. [16] also limited their run time to 1600s and the best Cmax from ten replications was accepted as the solution. QIA in Ref. [20] and ACO in Ref. [22] were run a fixed number of iterations and the best Cmax from ten replications were recorded. With regard to the computational environment, AIS by Engin and Döyen in Ref. [19] was coded in Excel Macros (Visual Basic Applications for Excel) and run on an Intel P4, 1.7GHz, 256MB RAM, GA by Besbes et al. [16] was coded in C++ and run on an Intel P4, 3GHz, 512MB RAM, ACO in Ref. [22] did not provide the information, and QIA in Ref. [20] was coded in MATLAB and run on a Pentium Dual, 1.6GHz. The computational results are summarized in Tables 1 and 2, where columns Cmax and CPU represent the makespan and the average computational time in seconds.The computational results for the easy problem sets are provided on the website at http://web.ntust.edu.tw/~ie/index.html. IAIS, AIS, and GA algorithms can reach optimum for all easy problems while ACO and QIA can only solve 50 and 29 of the 53 problems, respectively. It is noted that the optimal solutions for six problems of j10c10c are obtained by our total enumeration of all possible schedules.In Table 1, IAIS is evaluated with other two immune system based algorithms, i.e., AIS and QIA. For the hard problems, IAIS can solve 16 of the 24 problems (66.7%) with the smallest average percentage deviation among the algorithms. In Table 2, IAIS is compared with other two different algorithms, GA and ACO. For the hard problems (24 problems), IAIS reaches LB in 16 problems (66.7%), while GA and AIS reach LB in 15 and 14 problems (62.5% and 58.3%). The deviation value of IAIS (3.02%) is smaller than those of GA and ACO (3.07% and 4.51%). Thus, IAIS and AIS perform better than ACO and GA on average.As to the required CPU time, Pan et al. [32] provided a compared method which is also used in this paper. For example, AIS by Engin and Döyen in [19] ran on an Intel P4, 1.7GHz and IAIS ran on an Intel Core 2, 1.83GHz, so a correction factor of 1.7/1.83=0.93 was obtained. The computational time by employing the correction factor for problem j10c5a2 by AIS is 1×0.93=0.93s, which is substantially larger than 0.02s of IAIS. After using the correction factor for GA and AIS, IAIS takes less computational time than GA and AIS except a hard problem (j10c5d5). For the computational time, we can thus conclude that IAIS outperforms all the immune system based algorithms and other existing algorithms in solving the benchmark problems.The performance of all algorithms is summarized in Table 3, where the column “% solved” denotes percentage of the optimally solved problems, and “% deviation” denotes the average percentage deviation values for easy and hard problems.To summarize, the algorithms have average deviations as follows: 2.05% of IAIS from 77 problems, 2.03% of GA from 77 problems, 1.47% of QIA from 41 problems, 2.06% of AIS from 77 problems, and 2.82% of ACO from 77 problems. Since IAIS is not significant better than AIS on the benchmark problems, new benchmark problems are proposed in the next subsection.For the HFS benchmark problems, both IAIS and AIS can obtain the optimal solution for most instances with less computational time than other existing algorithms in the literature. However, the original benchmark problems are not difficult, so new benchmark problems are proposed in this paper to make a meaningful comparison.The new benchmark problems were generated with n=25, 50, 100, 250, 500, s=5, 10, and type=e, f, g, h, where n, s, and type represent the number of jobs, the number of stages, and the other parameters. The parameters for the four types of problems are given in Table 4. The new benchmark problems can be downloaded from http://web.ntust.edu.tw/~ie/index.html.Preliminary tests are conducted to find good parameter settings for IAIS: A=20,B=n/2, and R=10. The parameters for AIS are the same as the parameter settings of problem j25s5e: A=13 and B=0.75. Each of the problems is run ten times to obtain the solution and the run time is limited to 100 second. The percentage deviation (PD) is used to evaluate the gap between IAIS and AIS. The formulation of PD is computed as follows:(3)PD=100×CmaxH−CmaxbestCmaxbestwhereCmaxHis the average makespan obtained by the ten replications of respective algorithm andCmaxbestis the minimum average makespan acquired by the two algorithms.The computational results for all the problem sets are provided on the website at http://web.ntust.edu.tw/~ie/index.html. As an illustration, we give the computational results for the problem set with n=100, s=5 in Table 5. The performance of the two algorithms is summarized in Table 6. It can be observed from Table 6 that the average PD of IAIS (PDIAIS) is 0.00 and the average PDAISis 20.5 with a maximum of 42.38. The PD of AIS does not vary significantly for different number of stages. Figs. 3 and 4depict the PD of AIS from IAIS in the four types of problems with 5 and 10 stages, respectively. It can be seen from the figures that AIS has smaller gap from IAIS in the problems of types e and f than of types g and h, which are harder problems. We can thus conclude that IAIS performs better than AIS.As a formal comparison, a hypothesis test is performed to compare IAIS with AIS. This study uses Minitab software [33] to conduct a Mann–Whitney test [34], a nonparametric test, in which the null hypothesis H0 assumes that μIAIS≥μAIS, and the alternative hypothesis H1 assumes that μIAIS<μAISwith 0.05 significance level. It can be observed from Table 5 that the proposed IAIS is statistically significantly better than the compared AIS on the new benchmark problems.To evaluate the robustness of the algorithms, Fig. 5depicts the changes of average standard deviations for the two algorithms. It can be seen that IAIS has a much smaller standard deviation than AIS, and the average standard deviations of both algorithms are increased as n is increased. The average standard deviations of IAIS are 7.3 and 13.9 for the 5-stage and 10-stage problems respectively, while they are 30.05 and 40.65 for AIS. Thus, IAIS is quite robust for the HFS problem.In this paper, we have examined a hybrid flow shop problem with the objective of minimizing the makespan, which is an NP-hard problem. An immunoglobulin- based AIS algorithm (IAIS) has been developed to solve the problem. The developed IAIS algorithm is better fit the natural immune system than other immune-based algorithms. The advantage of IAIS is easy to understand and has a useful feature, isotype switching. In a general AIS algorithm, the search area is limited by clonal selection and then hypermutation is used to find a good solution. IAIS has three different mutation methods in isotype switching, where different combinations of the three mutation methods can search different solutions. The irregular search of isotype switching avoids falling into local optimum. To evaluate the performance of the IAIS algorithm, it has been tested on the well-known benchmark problems by Carlier and Néron's [8]. Computational results have shown that the proposed IAIS algorithm outperforms the other algorithms except AIS. For a further comparison between IAIS and AIS, new harder problems have been generated. Extensive experiments with different size problems have shown that the IAIS algorithm can efficiently yield better solutions than the AIS algorithm.However, the IAIS algorithm has a weak point. As any local search based algorithms, the convergent issue is always a big challenge. The computational time will be raised as the problem size is increased. In the future research, it is worthwhile to develop new ways of updating the speed of the IAIS algorithm. We may exploit the effectiveness of IAIS to other scheduling problems, such as single machine, parallel machines and flow shop with various constraints and objectives. Two changes may be made in somatic hypermutation and isotype switching of IAIS to further improve the algorithm; the easy mutation methods used may be replaced with other mutation methods, and the random selection can be changed by a dynamic environment while the algorithm is running.

@&#CONCLUSIONS@&#
