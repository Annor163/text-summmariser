@&#MAIN-TITLE@&#
Pull-based recommendations in mobile environments

@&#HIGHLIGHTS@&#
We have designed a framework to support mobile context-aware recommendations.We have described in detail the pull-based recommendation module.We have performed an extensive study of the state of the art.We have performed an experimental evaluation that compares different paradigms.The proposed architecture is generic, extensible, and adaptable to the requirements.

@&#KEYPHRASES@&#
Context-awareness,Recommendation systems,Mobile computing,

@&#ABSTRACT@&#
In the field of Context-Aware Recommendation Systems (CARS), only static contextual information is usually considered. However, the dynamic contextual information would very helpful in mobile computing scenarios. Despite this interest, the design and implementation of flexible and generic frameworks to support an easy development of context-aware mobile recommendation systems have been relatively unexplored. In this paper, we describe a framework that facilitates the development of CARS for mobile environments. We mainly focus on the development of the elements needed to support pull-based recommendations and the experimental evaluation of the proposed system.

@&#INTRODUCTION@&#
Recommendation systems [1–3] have become an important research area since their emergence in the last decade of the 20th century. Netflix, MovieLens, Amazon, YouTube, Yahoo, Tripadvisor, Last.fm and IMDb are examples of popular recommendation applications that currently play an important role in the Internet.In general, a recommendation system is an application that, using certain techniques and algorithms, is able to suggest relevant items to users (e.g., movies, songs, books, jokes, applications, websites, travel destinations, e-learning material, and even friends in social networks). It tries to adapt its proposals to each user in a personalized way, based on his/her preferences and current interests. These recommendations can be seen as a suggestion about items that are considered of potential interest to a particular user. For example, in a scenario of books the recommendations would be books that are expected to be relevant to the user (and so they should be read before others), in a scenario of travel destinations the recommendations would be places that according to the user preferences will be more attractive for the user, in the context of a digital newspaper the recommendations would be the news that the user could find interesting, in the context of movies the recommendations would be movies that the user would probably like, etc.Traditional recommendation systems ignore the context when providing relevant items to the user. However, the context should play a key role when providing recommendations. Thus, the relevance of an item depends on the context, which notably involves spatio-temporal criteria (e.g., see [4]) but may also include other contextual factors. Moreover, the context of a user in a mobile computing scenario is highly dynamic (e.g., the location of the user usually changes constantly). Therefore, recommendation algorithms should be able to effectively and efficiently exploit the dynamic context of the user in order to offer him/her suitable recommendations.Our current work is focused on solving the following scientific problem: how could we facilitate the development of Context-Aware Recommendation Systems (CARS) in mobile environments, to provide users with relevant recommendations? It is motivated by the lack of generic CARS frameworks that consider aspects related to mobile users and mobile computing. So, the goal of our research is to contribute to bridge the gap not only between recommendation systems and context-aware computing, but also between CARS and mobile computing.In this paper, we describe a framework that facilitates the development of context-aware recommendation systems for mobile users, focusing particularly on pull-based recommendations. The rest of the paper is organized as follows. Section 2 describes the technological context of this work, emphasizing the role of context-aware recommendation systems and mobility, as well as presenting a motivating scenario where a context-aware mobile recommendation framework like the one proposed in this paper would be useful. In Section 3, we overview the context-aware mobile recommendation framework proposed. In Section 4 we focus on the process of pull-based recommendation, which is the main module that we have analyzed and studied in detail in this work. In Section 5, we describe an experimental evaluation that we have performed and the results obtained. In Section 6, we review the related work. Finally, we present our conclusions and point out some directions for future work in Section 7.In this section, we provide an overview of the technological context of our research. First, we introduce some basic ideas about recommendation systems. Then, we focus on context-aware recommendation systems. Afterwards, we consider the introduction of mobility aspects in the recommendations. Finally, we illustrate the interest of mobile context-aware recommendation systems with an example scenario. The goal of this section is to provide background knowledge, rather than the state of the art of research in the area, which is described in Section 6.Depending on how the recommendations are obtained, classical Recommendation Systems (RS) can be classified into the following categories [5]:•Collaborative filtering: the user receives recommendations of items that people with similar tastes and preferences liked in the past.Content-based recommendation: the user receives recommendations of items similar to the ones that the user preferred in the past.Hybrid recommendation approaches: these approaches combine collaborative filtering and content-based recommendation.Many studies have been performed in the area of recommendation systems. Despite this, the researcher community still continues to develop new approaches, as many interesting problems remain unsolved (e.g., how to obtain suitable recommendations in the absence of previous information about the user, how to ensure enough variability in the items recommended, how to combine and exploit information from other sources such as social networks, etc.). The development of recommendation systems is supported by increasingly-important motivations, especially in the area of businesses (e.g., the need to better understand what the user needs, increase the sales of diverse items, improve the user satisfaction and the user fidelity, etc.) [1].Most RS operate in a two-dimensional (2D) User×Item space. However, considering only information about the users and items is not enough in applications such as the recommendation of vacation packages. In this case it is important to not only determine which items should be recommended, but also when these recommendations should be provided and how to combine them in a ranked list. Moreover, traditional collaborative filtering techniques generally take into account all the collected ratings of the items to generate the recommendation models; these techniques assume that the context is homogeneous, but actually a user can assign different ratings to the same item in diverse contexts, as the relevance and interest of a specific item for a user may depend on his/her current context. Therefore, additional contextual information should be considered in the recommendation process.We agree with the context definition provided in [6], which considers the context as “any information that can be used to characterize the situation of an entity”, where an entity could be “a person, place, or object that is considered relevant to the interaction between a user and an application, including the user and applications themselves”. Other definitions of context have been introduced in the literature related to the context-aware computing field (e.g., [7]). Examples of elements defining the context could be the location, time, weather, mood, activity, and companion of the user. There are certain types of context elements that, according to the circumstances, could be more important than others; for example, if it is raining a person could prefer to stay at home watching a movie rather than to go to run (i.e., the weather element in this case is more important than others).With advances in the fields of ubiquitous and mobile computing, the lack of analysis of contextual information in recommendation systems has been strongly criticized. So, researchers and developers had mainly focused on solving classic problems of recommendation systems, such as the cold start problem, spam vulnerability, high dimensionality, and many others. Recently, researchers working on recommendation systems have recognized the need to investigate them in domains where the contextual information is particularly relevant, such as in the case of mobile computing scenarios.The integration of recommendation systems and context-aware computing has given rise to the so-called Context-Aware Recommendation System (CARS). The meaning of context-aware was defined in [6] by indicating that “a system is context-aware if it uses context to provide relevant information and/or services to the user, where relevancy depends on the user's task”.A pioneer proposal in the field of context-aware recommendation systems is [8,9]. In order to improve the recommendations based on contextual information, the authors of that work extend the classical 2D paradigm to a multidimensional recommendation model (MD model) that provides recommendations based on multiple dimensions: User×Item×Context. They introduced three different context-aware recommendation paradigms, which use the contextual information in the recommendation process:•Pre-filtering, where the contextual information is used to filter the data set before applying traditional recommendation algorithms.Post-filtering, where the contextual information is considered only in the final step of the process. So, contextual information is initially ignored and the ratings are predicted using any conventional 2D recommendation system, taking all the input data available (potential items to recommend) into account. Afterwards, the resulting set of recommendations is adjusted (contextualized) for each user by using contextual information.Contextual modeling, where the contextual information is used directly in the modeling technique.So, the pre-filtering and post-filtering methods consider the context as an additional filtering step that can be applied to any traditional recommendation algorithm, either to restrict its input (pre-filtering) or its output (post-filtering). On the other hand, contextual modeling recommendation systems imply a radically different approach, as the contextual information directly affects the generation of the recommendation models.In Section 6.1 we describe some relevant works performed in the field of CARS. However, we would like to emphasize that, despite the existing efforts, the design of flexible and generic architectures and frameworks to support an easy development of CARS has been relatively unexplored.The widespread availability of mobile devices, such as smartphones and portable computers, implies that the relevance of mobile computing scenarios is nowadays undeniable. This, in turn, demands new approaches for the development of recommendation systems that can handle and effectively exploit the data available in those environments. Thus, a recommendation system in a mobile computing scenario should rapidly obtain contextual information of the user, by using multiple sensors [10,11], accessing resources available in the Internet, etc.Some context-aware mobile applications have already been developed, but they focus mostly on specific domains (e.g., restaurants, museums, gas stations, supermarkets, foods, etc.) [12–16]. Section 6.2 provides an in-depth study of existing approaches for mobile CARS. Despite these efforts, more research is needed to enable the potential definition of flexible and generic frameworks to support an easy development of mobile CARS.This section describes a sample scenario to illustrate the interest of a context-aware mobile recommendation architecture. The scenario shows some of the main benefits provided by the architecture that we propose in this paper, as well as the interest of having a flexible and global CARS framework for mobile users. We follow a story-like style to describe the motivating scenario, which consists of two parts: shopping (see Section 2.4.1), which is illustrated in Fig. 1, and leisure after shopping (see Section 2.4.2).Throughout the description of the scenario, we assume the existence of an application MOcCARSin (MObile Context-Aware Recommendation System), which can be installed in mid-range smartphones. This application recommends (proactively or through explicit queries) products of interest to the user, considering an enriched user profile built based on opinions issued in the past about products in different contexts as well as exploiting additional contextual information obtained from the environment (via different types of sensors).The example provided in the rest of this section illustrates the benefits of a context-aware mobile recommendation framework to provide useful recommendations in a variety of scenarios. Several mobile computing applications for different scenarios could be developed based on the generic framework proposed. Although the fictitious application MOcCARSin named in the example still does not exist, it shows the ultimate goals pursued in our research.Alice gets up at 7:30 am. It is Saturday and raining. She needs to buy some food for the week, but she does not know exactly what she should buy and where she could go. So, Alice decides to use MOcCARSin in order to receive recommendations of supermarkets where she can go, given her current circumstances. First, she introduces the keyword “food” as the query. Automatically, MOcCARSin enriches this input with additional contextual information that is relevant in her context, such as the hour and day of the week, the weather conditions, her current location, and even information about the persons that are with Alice at the moment. MOcCARSin infers that Alice is probably interested in buying food, as her potential desire to have lunch or dinner at that time of the day is considered unlikely; taking breakfast outside does not seem a plausible option either because Alice's coffee machine broadcasted a “coffee ready” message a few minutes ago (by using M2M, or Machine to Machine, communications). So, MOcCARSin asks Alice “Do you need to buy food?” and she confirms.Then, MOcCARSin evaluates the different context parameters and Alice's preferences to suggest her a place where she can buy food. It knows that Alice prefers medium-price supermarkets rather than more expensive high-quality malls, small stores, or gourmet food stores specialized in specific types of products. However, in this case the closest supermarket is quite far, so going by foot there is not a good option given that it is raining. Moreover, Alice does not have a car, the public transportation system is not working yet at this time, and Alice's brother (who could drive her to the supermarket) is not with her at the moment. So, MOcCARSin considers interesting to include a small food store, located a few blocks from her home, in the list of suggestions provided. Alice finally selects a supermarket, and so MOcCARSin suggests her to take a taxi or wait until 9:00 when the bus service starts. Alice decides to take a taxi, and therefore MOcCARSin recommends her several taxi companies (ranked based on ratings from other users), continuously showing on a map the up-to-date locations of taxis nearby along with contact information of the corresponding taxi companies.Once in the supermarket, MOcCARSin automatically suggests products that she usually buys, products whose stock in her fridge is decreasing (this information was provided by her fridge before leaving home), as well as other products that she has never purchased but she might like. For each product suggested, MOcCARSin provides optional information such as its name, price, and appropriate routes to reach the supermarket's section where the product is located. If Alice selects a set of products at the same time, then MOcCARSin is able to suggest Alice a route that optimizes the retrieval of all those products. As the supermarket may include several floors, MOcCARSin exploits a hierarchical indoor map to obtain the appropriate walking directions, including (if necessary) taking the stairs or an elevator. Information about products is obtained from a web service provided by the supermarket, as well as from other customers that may disseminate and share dynamically (through a mobile peer-to-peer network) information about specific offers that they have seen. Moreover, Alice has accepted to share information about her current shopping cart with the supermarket, which the marketing department exploits to offer her customized offers and related products (e.g., since Alice has bought strawberries, she can be offered whipped cream at a special price).By using NFC (Near Field Communication), MOcCARSin is able to provide Alice with information about products that she is currently observing, as the supermarket has deployed an appropriate mechanism to query this information (such as RFID –Radio Frequency IDentification– tags). For example, MOcCARSin can identify product features including its ingredients or caloric content, its price, and its expiry date. Alice is in a gluten-free diet, and so MOcCARSin warns her if she tries to pick up products that contain gluten. It also prevents Alice from choosing specific products whose expiry date is too close in time, taking into account her consumer habits (e.g., Alice may leave products in the fridge for a long time).When Alice considers that the shopping is finished, MOcCARSin alerts Alice that she is just three euros below the threshold that would entitle her to a free delivery at home. As she does not have a car, she decides to buy also a couple of chewing gum packets and ask for home delivery during the afternoon.After leaving the supermarket, the weather has improved considerably. Alice starts walking home and she receives a recommendation to have lunch in a restaurant located nearby. It is a good time to eat and she is hungry. Besides, the restaurant offers Chinese food, which is Alice's preferred meal. So, she decides to accept the recommendation. MOcCARSin suggests Alice to ask Bob, Alice's best friend, to join her, as he also loves Chinese food. Alice contacts Bob and he accepts, but he is not nearby, so he takes his own car to go there. Bob types “parking car” in his MOcCARSin application along with the address of the restaurant, to try to find available parking spaces near the restaurant. MOcCARSin collects and offers him information about available parking spaces that may be relevant (obtained from repositories with information about parking lots and garages, data collected from parking sensors, etc.). Some of the private parking spots suggested support booking and electronic payment, which Bob finds convenient.In the meanwhile, Alice decides to buy a present for Bob. He loves books, so she asks for appropriate book recommendations. As Bob is sharing with Alice information about his preferences and the books that he has already read, the MOcCARSin application in Alice's device uses those data to suggest Alice an appropriate book for Bob.At the restaurant, Bob invites Alice to go to the cinema after lunch. Alice accepts, but she has the responsibility to choose the movie. By simply introducing the keywords “cinema movies”, MOcCARSin is able to provide recommendations about interesting movies being shown in cinemas in the vicinity. User preferences related to the price, type of cinema (preferred size, audio and video capabilities offered, comfort and additional services, etc.), and movie genres, are automatically analyzed during the recommendation process. For example, MOcCARSin excludes 3D movies, as they usually give Alice a headache. Moreover, as Alice shares many interests with her friends, she trusts particularly the opinions (ratings) provided by people in her social network, which is also taken into account by MOcCARSin when assessing the reliability and relevance of the available ratings.In our preliminary work [17], we proposed basic ideas regarding the design of a context-aware mobile recommendation architecture, which facilitates the creation of CARS for mobile computing environments. In this section, we provide an overview of the proposed framework and some fundamental ideas regarding the management of contextual information.The proposed framework (see Fig. 2) accommodates several traditional recommendation algorithms, such as collaborative filtering based on users/items, Singular Value Decomposition (SVD), and content-based filtering, as well as combinations of traditional recommendation algorithms. In addition, it supports different context-aware recommendation paradigms (pre-filtering, post-filtering, and contextual modeling), based on adaptations of traditional (i.e., non-contextual) algorithms adapted to mobile environments. The architecture designed is composed of the following layers:•View layer. It reflects the main components of the Graphical User Interface (GUI).Logic layer. It contains the main modules of the system, such as a sentiment analyzer, a sensing engine, a user reliability analyzer, a user profile and context manager, a push-based recommendation module, a pull-based recommendation module, a rating reliability analyzer, a repository manager, and a data sharing manager.Data layer. It provides access to data relevant for context-aware recommendations in mobile environments.As can be seen in the figure, this architecture comprises a number of modules. For instance, the User Profile and Context Manager is responsible for managing (inserting, modifying, and removing) information about the user profile and context. The information from this module is stored in a local database through the module Repository Manager, which allows the access to a local database storing those data, offering an object-relational mapping. The proposed architecture reflects an ambitious goal with many challenges, which have to be tackled gradually. In this contribution, we mainly focus on the development of some of the modules of the logic layer, with a special emphasis on the Pull-Based Recommendation module. Thus, the detailed design of some elements of the architecture is considered to be out of the scope of this paper, for example:•The sentiment analyzer is able to interpret an opinion in natural language (e.g., an opinion expressed using free text) and determine if the opinion is positive, negative or neutral, to assign it a numeric and/or qualitative rating automatically. In our current work, we assume that the user will always express his/her preferences by using numeric ratings (e.g., using a scale between 1 and 5, or between 1 and 10, etc.).The rating reliability analyzer module protects against profile injection attacks (attacks that try to artificially increase or decrease the relevance of some items by injecting fake ratings). This module will be implemented by applying different attack detection methods [18], and its filtered output will be used to update the corresponding local knowledge base by using the Repository Manager. Moreover, we plan to perform a reliability analysis to assign more confidence to the information provided by the user's friends [19].Finally, the philosophy of storing information in the knowledge base locally will be extended to also allow access to external knowledge bases, as well as to support sharing data with other users in a Peer to Peer (P2P) way. To achieve this, we plan to implement a Data Sharing Manager module.Currently, one of the biggest problems in the field of CARS is how to obtain the contextual information. In many cases, this information is obtained explicitly based on questions asked to the user by the system. For example, the system could provide the user a template to fill context fields by using free text or selecting an option from a drop-down menu. However, this is inconvenient for users, which may be too lazy to fill all the fields or carefully answer all the questions provided, leading in the end to an incomplete or inaccurate identification of the context of the user. So, the use of unobtrusive techniques able to infer the context without the user intervention (e.g., [20–23]), by using several sources (e.g., sensors, geospatial information services, social networks, web services, etc.), is desired. Observing the behavior of users and using data mining techniques, for example to learn user preferences and user needs, could also be beneficial (e.g., see [24,25]).In our framework we implemented the Sensing Engine module to exploit implicitly the information from sensors. Dynamic context values, such as the transport way, mobility (e.g., sensed by accelerometers), temperature (e.g., sensed by temperature sensors), and time of the day (e.g., sensed by optical sensors), as well as the location (e.g., sensed by GPS) of the current user or item may be captured from sensors of the mobile devices. Thus, today's mobile devices (e.g., smart phones) come equipped with a large number of sensors, which would be useful to obtain contextual information of the user or item environment (e.g., timer, humidity, ambient noise, compass, gyroscope, camera, etc.) [10,26]. Moreover, a supporting infrastructure of sensors may be in place (e.g., to obtain temperature information from sensors deployed in a specified area).We have performed an in-depth study of the state of the art of mobile context-aware recommendation systems (see Section 6 and particularly Table 7). Based on this study and also on the contextual model presented in [27], we have identified a set of relevant context dimensions and their possible values:•User context: transport way (walking, bicycle, car, public), mobility (stopped, moving), weekday (week, weekend), mood (happy, sad, active, lazy), companion (alone, friends, family, girlfriend, children).POI (Point of Interest) context: price ($, $$, $$$, $$$$, free). Obviously, the higher the number of dollar signs used the higher the price.Environment context: season (spring, summer, autumn, winter), temperature (warm, hot, cold), time of the day (morning, night, afternoon), and weather (cloudy, snowing, sunny, rainy).System context: mode (off, on, flight), network (adequate, excellent, poor), and battery level (low, medium, high).This analysis was important in supporting our goal of designing an architecture in a flexible and generic way, to enable its adaptation to any domain.In this work, we focus mainly on the description and evaluation of the Pull-Based Recommendation module. This module provides explicit (or reactive) recommendations, obtained as an answer to a query explicitly submitted by the user and evaluated by the system as a continuous query [28].Fig. 3shows a high-level view of this process. First, the user introduces the item type (as the query) and context constraints (hard and/or soft constraints can be considered, as explained later) in the GUI. Afterwards, the user might (optionally) specify hints regarding the importance of the different context criteria that should be taken into account during the recommendation process. Finally, a certain context-aware recommendation paradigm (pre-filtering, post-filtering, or contextual modeling) is applied to obtain appropriate recommendations for the current user. The type of paradigm executed depends of the choice of the system developer and/or the type of items to recommend. As the context will continuously change (e.g., imagine a scenario where both the user and the items to recommend move, such as a taxi recommendation scenario), the recommendation system must automatically update the contextual information (context of the user and context of the items) and evaluate the query in a continuous way. This continuous revaluation process will be performed until the user decides to cancel the query (i.e., when he/she is not interested in recommendations about that type of item anymore).Algorithm 1 shows the pull-based recommendation process in more detail. It receives as input: the contextual information of the current user, which is obtained from mobile sensors and/or the user himself/herself; the kind of items required; optionally a maximum number of items k to recommend; the minimum score required for two contexts to be considered similar (called the similarity threshold); and the time interval between two consecutive recomputations of the recommendation (the refreshment period). The sub-algorithm contextAwareMobileRecommendationParadigm(), can be implemented following any context-aware recommendation paradigm: pre-filtering, post-filtering, and contextual modeling; the details of these paradigms are provided later in this section. Such a sub-algorithm contextAwareMobileRecommendationParadigm() is executed with the required refreshment frequency until the query is explicitly canceled by the user. For this purpose, the values of the dynamic context variables are updated in each refreshment.Both the pre-filtering and the post-filtering paradigms require determining the similarity between contexts, as the recommendation model will need to identify past votes/ratings (from the same user or from other users) that have a context similar to the current context of the user. In this section, we first describe the representation of contexts using context variables and then introduce a context similarity metric.Algorithm 1Pull-based recommendation algorithmWhen comparing two contexts, the different context variables composing them have to be compared. In principle, all the context variables can be considered as equally important; so, we could assume that each context variable has a weight that is obtained by dividing one between the number of context variables. However, there are circumstances where some variables are more important than others, which should be considered during the recommendation process. Hence, for each domain (i.e., type of items) the system by default considers a higher importance weight to the context variables that are usually considered most relevant and a value of zero for those that are irrelevant in that domain. Moreover, the user can optionally modify his/her context criteria, by adjusting one or all the weights of the variables (e.g., see an example in Section 4.2.1). For example, the user could consider some context variables as irrelevant, assigning them a weight of zero. Alternatively, he/she could highlight the importance of some context variables over others, assigning them higher weights. If the user modifies only one or a few weights, then the values of the remaining weights will be automatically adjusted (to keep their desired relative importance and still ensure that the sum of all the weights is equal to one). These weights are considered during the recommendation process.ExampleLet us suppose that a restaurant recommendation system considers that the variables more relevant in that domain are: companion, weekday, transport way, mobility, time of the day, mood, temperature, weather, and price. For these variables, the system automatically assigns default relevance weights that are assumed to be generally suitable for that type of items, ensuring that the sum of all weights is 1 (see Table 1). However, the user U1 considers that the variables relevant to him/her are: transport way, companion, price, time of the day, and weather; hence, he/she modifies all the initial weights. On the other hand, the user U2 considers that the most important context variables are others (transport way, price, and time of the day), and so decides to assign other weights.Context variables whose weights are different from zero represent soft constraints, as they embed preferences of the user regarding the impact of the different context variables. Moreover, the user could also formulate hard constraints, which are specific conditions on the values of certain context variables that need to be satisfied (e.g., the price of an item should be below a certain threshold, the item should not be located further than a certain distance, etc.).In Algorithm 2, we present the strategy used to calculate the similarity between context variable vectors Cx(i.e., the context of the current user) and Cy(i.e., the context of another user or the context of an item), by using Eq. (1). As shown in the equation, the similarity between contexts is computed based on the similarity between the values for each of the context variables (e.g., transport way, mobility, weekday, mood, companion, price, season, temperature, time of day, or weather). Specifically, the similarity sim(cx, cy) computed between each pair of valuescxiandcyi(of the context variable i of the contexts cxand cy) is multiplied by the relevance weight wicorresponding to that context variable. If the overall similarity is greater than a certain similarity threshold, then the contexts Cxand Cyare considered to be similar. The proposed equation is analogous to the one used in [29]. However, in that work only the similarity between the context of a current user (Cx) and an item context (Cphoto) was considered, whereas we consider also the possibility to compare two user contexts.(1)similarityCxCy=∑i=1nsimcxicyi∗wiTo determine the similaritysimcxicyibetween the values of a context variable i in two contexts, we consider the following specific cases:•If the values of the same context variable in the two contexts are identical (i.e.,cxi=cyi), then their similarity is 1. For example, in Table 2cx3=cy3, cx5=cy5, and cx7=cy7, for the context variables weekday, companion, and season, respectively.If cxiand cyiare considered to be completely different, then their similarity is 0. According to the example in Table 2, the context variables transport way, mobility, mood, price and time of day are examples of this (e.g., cx1≠cy1, cx2≠cy2, cx4≠cy4, cx6≠cy6, and cx9≠cy9).Finally, if the values of the context variable i are not exactly the same but have a close semantic relationship (areRelated() in Algorithm 2), then the similarity takes some value between 0 and 1 (e.g., 0.5). This value (softSimilarity() in Algorithm 2) has been defined and stored previously and it represents a way to explicitly encode soft distances between possible values of a variable. For example, for the context variable temperature the distance between “hot” and “warm” is smaller than the distance between “hot” and “cold”, and regarding the weather the distance between “cloudy” and “rain” is smaller than the distance between “rain” and “sunny”. Another example can be illustrated by the context variable weather in Table 2, where the values clear sky and sunny are considered to be semantically close.In many cases, it may happen that a complete description of a context is not available. In other words, we could have context variables that have an unknown or null value. Directly applying the method described above to compare sparse context vectors may lead to similarity scores that are not appropriate. To deal with missing information, we have included in Algorithm 2 the method compareVariablesWithMissingInfo(), which can consider several strategies:•Regarding the comparison between an unknown value of a context variable with another value, we could assume minimum similarity (i.e., a value of 0, which corresponds to the pessimistic assumption that the real value missing would be different from the other one), maximum similarity (i.e., a value of 1, which corresponds to the optimistic assumption that if we knew the value missing this would be equal to the other one), or neutral/medium similarity (e.g., a value of 0.5).For instance, in Table 3one of the values of the context variable mobility (cz2) is unknown and the other one has the value moving (cw2). An optimistic comparison implies considering that the other user was also moving (maximum similarity), whereas a pessimistic comparison leads to the assumption that the other user was probably in a static location. A more neutral approach leads to consider a similarity of 0.5 as an average of the similarity values computed for the two other cases (1 and 0, respectively). Similarly, in Table 3 one of the values for the context variable companion is unknown (cw5) and the other one has the value alone (cz5), so a similar reasoning can be applied.If the two values of a context variable i are both unknown, two strategies are possible. On the one hand, we can decide to ignore the comparison between the two unknowns, which means that the context variable i is not taken into account. On the other hand, it is also possible to perform the comparison between the two unknowns anyway, by applying one of the strategies mentioned above (that is, assume minimum similarity, consider maximum similarity, or estimate neutral/medium similarity).As an example, in Table 3, for the context variable transport way the values for both users are unknown. So, we can ignore that context variable. Alternatively, we can assume that they were actually using the same transportation means (maximum similarity), using a different one (minimum similarity), or using a similar one (medium similarity). Using a medium similarity can also be interpreted from a statistical perspective: in this case, it is equally likely that the values match or do not match, so an overall average similarity can be considered.With the pre-filtering paradigm (see Algorithm 3), first a context update is performed (i.e., the information regarding the context of the user is updated, by using sensors or explicit cues provided by the user). Then, a context analysis takes place to provide contextualized data by determining the similarity between the current context of the user Ccuand other user context profiles Cupincluded in past ratings, based on the use of Algorithm 2. The contextualized data is then provided as an input to a traditional recommendation algorithm. So, we could say that with this process we remove irrelevant raw data (i.e., data that are not related to the current context of the user) and that the data selected as relevant (smart data) are used to build the recommendation model. Finally, a maximum of k items are recommended to the current user.Algorithm 3Prefiltering paradigmThe post-filtering paradigm (see Algorithm 4) is similar to the pre-filtering paradigm, but inverting the order of the steps. First, it applies a traditional recommendation model to obtain candidate items and later contextualized candidate items are provided to the current user. Moreover, the post-filtering algorithm considers hard constraints to filter out items that do not satisfy them. Notice that the pre-filtering algorithm proposed (presented in Section 4.3) does not check hard constraints to filter the items that will be used to learn the model; although hard constraints could also be considered in the pre-filtering, that would decrease considerably the amount of items used for training the model.Algorithm 4Postfiltering paradigmTo obtain these contextualized items, both hard constraints and soft constraints could be applied. The application of hard constraints represents a strict requirement regarding the fulfillment of certain conditions, and therefore only the items that match all the hard constraints of the current user will be recommended (see Algorithm 5); as an example, filtering the candidate items according to specific location-dependent constraints [30] could be considered (e.g., filtering the items based on their distance from the user). The application of soft constraints implies a traditional comparison between the context of the user and the context of each candidate item (see Algorithm 6).Algorithm 5Filtering with hard constraintsFinally, in the contextual modeling paradigm (see Algorithm 7) the contextual information is used directly in the recommendation model, as context variables are simply considered as features in the feature vectors compared. Specifically, in our prototype we use a Naïve Bayes classifier [31], which is a probabilistic classifier based on Bayes' theorem.In the contextual modeling paradigm, the classifier learns a model for each user profile. The model is stored in a knowledge base, which contains several instances (one for each user). Each instance is composed by the following features or attributes: the context variables (of nominal type) and the item's rating for those contexts (numeric type). The decision class (nominal type) are the ratings (e.g., values in a scale between 1 and 5). For a new instance (context variables of the current user and the possible item to recommend) the classifier predicts a rating. The ratings predicted for the different candidate items are sorted (in descending order of rating) and the first k items with a predicted rating higher than a specific recommendation threshold (e.g., the items with a rating predicted of at least 4) are provided to the current user.Algorithm 6Filtering with soft constraintsAnother variant for this paradigm would be to consider as the decision class the labels like or dislike, by partitioning the possible rating values in these two categories (e.g., the ratings 1, 2 and 3 could belong to the dislike class – i.e., items that should not be recommended – and the ratings 4 and 5 to the like class – i.e., items that should be recommended –). In this case, the algorithm would recommend the k items with the highest probability to belong to the class like.We have developed a prototype of our framework using the Java programming language (Java 1.7), focusing so far particularly on the design of the pull-based approach. We have used the Weka11http://www.cs.waikato.ac.nz/ml/weka/.data mining toolkit as well as the machine learning library Mahout.22https://mahout.apache.org/.Both Weka and Mahout offer implementations for various data mining algorithms; specifically, we have used the Naïve Bayes classification algorithm provided by Weka and the recommendation algorithms offered by Mahout (in particular, the SVD algorithm). In this section, we present the experimental evaluation that we have performed. All the experiments were conducted on a computer with an Intel Core i5-2320 processor with 3GHz and 16GB of RAM, running Windows 7.In the following, we first describe the dataset that we have used, its adaptation for our experimental evaluation, the experiments performed, and the results obtained.A very important problem to evaluate mobile CARS is the lack of available datasets that contain information about the context of the user when he/she provided a specific rating. It would be interesting to have some reliable high-dimensional dataset (e.g., like the well-known Movielens33http://grouplens.org/datasets/movielens/.), but enriched with precise and complete contextual information. Unfortunately, the current situation is quite different:•Most papers in the field of context-aware mobile recommendation systems have been evaluated with own data collected from real users (e.g., see [15,29,13,32–37]). For example, in [35], to evaluate a context-aware mobile music recommendation system, the authors firstly considered the publicly available CAL500 dataset, which incorporates ratings along with some usage annotations (such as whether the user was driving or sleeping). However, those annotations only partially covered the evaluation needs of the authors, and so they decided to build a new dataset with songs crawled from Grooveshark44http://grooveshark.com.and YouTube55http://www.youtube.com.and using humans to annotate them.There are some context-aware datasets available in the Internet that contain contextual information (e.g., see http://students.depaul.edu/ yzheng8/DataSets.html), in domains such as foods and restaurants [12,38,39], movies [8], hotels and travel [40–43], and music [44]. There is also a Yelp's Academic Dataset,66http://www.yelp.com/academic_dataset.which includes ratings provided by real users to score local businesses (e.g., in [45] the authors enhanced these data by simulating the context). Another interesting dataset is the ConcertTweets dataset77http://people.stern.nyu.edu/padamopo/data/.[46], which contains concert ratings combined with spatio-temporal contextual dimensions and data of social networks.So, an important current problem in this area is the lack of a good-quality large dataset with enough information on ratings and contexts for (quantitative and qualitative) evaluation purposes of the context-aware mobile recommendations-based paradigms and applications developed by the research community.Of the few datasets available, the one most suited to our problem, and therefore the one that we decided to use, was the collected data from an Android Mobile Application called South Tyrol Suggests (STS).88https://play.google.com/store/apps/details?id=it.unibz.sts.android.The STS application provides context-aware suggestions for accommodations, attractions, events, and restaurants in South Tyrol. Specifically, the dataset available at http://students.depaul.edu/ yzheng8/datasets/Data_STS.zip contains 2534 ratings (on a scale of 1 to 5), provided by 325 users in different contexts, of approximately 249 POIs [42,43]. Contexts in the dataset are composed by 14 context dimensions:•User context (8 variables): transport way (walking, bicycle, car, public), weekday (weekday, weekend), mood (happy, sad, active, lazy), companion (alone, friends, family, girlfriend, children), time available (half day, one day, more than one day), knowledge of the surroundings (new to area, returning visitor, citizen), travel goal (visiting friends, business, religion, health care, social event, education, landscape, fun, sport), and distance to the item (far away, nearby).POI context (2 variables): budget (budget traveler, price for quality, high spender, free) and crowdedness (crowded, not crowded, empty).Environment context (4 variables): season (spring, summer, autumn, winter), temperature (burning, hot, warm, cool, cold, freezing), time of the day (morning, noon, afternoon, evening, night), and weather (clear sky, sunny, cloudy, rainy, thunderstorm, snowing).The values of context variables related to the environment were automatically collected, whereas the values about the context of the items and the user context were manually obtained (the application requested the user to explicitly fill appropriate values for those variables when submitting his/her rating), with the exception of the context variable weekday, which was automatically computed. From now on, we will consider 13 of the previous 14 context variables, as the distance between the user and the item will be translated into a geographic location for the item, as explained in Section 5.3.Although the dataset chosen is the most appropriate one that we have been able to find, it is subject to important limitations. A notable problem is that it is pretty sparse in terms of the availability of ratings and contexts. Fig. 4illustrates the low percentage of information available for each context variable in the full dataset, which emphasizes the interest of techniques that capture contextual information automatically without the intervention of the user (see Section 3.2). As shown in the figure, the context variable for which there is more information available is the “temperature” variable (a value of temperature is provided in about 15.6% of the ratings), whereas the variable with more missing values is the “transport way” (specified only for 3.2% of the ratings). The percentages shown in the figure are really low, which means that in most cases the real value of a specific context variable potentially affecting a rating is not available.This sparseness of contextual information is further analyzed in Fig. 5, which indicates, for each rating, the number of context variables that have a value. As the figure shows, only a maximum of 5 context variables are provided for some ratings and most ratings have only 1 context variable defined (or none). For 23.64% of the ratings in the dataset only one context variable has a defined value and 38.44% of the ratings have no context variable defined.The ratings available are not uniformly distributed over the different users either: for some users there are very few ratings available and for others we have comparatively a high number of ratings. So, there is an average of 8 ratings per user, but some users have provided many ratings (a single user provided 175 ratings) and some users provided only 1 rating.As a reasonable decision could be to consider only the users for which a significant number of ratings is available, we analyzed the contextual information for the three users with more ratings in the dataset: user 1, user 7, and user 24, who have 175, 96, and 123 ratings, respectively; to determine an appropriate number of users to select, we applied the clustering algorithm k-means for different values of k. Fig. 6shows, for those three users, the number of ratings with no contextual information, the number of ratings with some contextual information, and the number of contexts guaranteed to be different.99Notice that two contexts that have the values of all the defined context variables equal are not guaranteed to be different from each other (neither equal) if they also contain some undefined values.Just by coincidence, these three users voted exactly the same items (numbered from 1 to 8 in the figure). Each division/portion of each bar in the figure marks a value in the Y-axis. For example, the figure shows that for user 1 and item 1: the item was rated by the user 43 times; of those, 13 ratings completely lacked contextual information and 30 ratings had some contextual information (i.e., at least 1 context variable had a defined value); moreover, it also shows that, from the ratings with some contextual information, only 23 contexts are guaranteed to be different. It should be noted that in some cases the portion corresponding to the number of ratings with some contextual information is hardly appreciable (e.g., for item 5 of user 1, for item 6 of user 7, etc.) because that number matches the number of contexts guaranteed to be different. The figure shows that the sparseness of contextual information also holds in the case of the users for whom a higher amount of information is available. Notice that the number of ratings of each user is in general smaller than the number of items that he/she rated. This is because there are users that have rated the same POI several times even in potentially-identical contexts (i.e., identical contexts if we ignore context variables with undefined values).As the location is an important context parameter, that is not available in the dataset, we decided to adapt the original dataset by including a new context variable to represent the location (location of the user in the case of a user context, location of an item in the case of an item context). For this purpose, we completed randomly the values of the context variables “distance to the item” and “transport way”. Firstly, we generated randomly the location values (latitude and longitude) of the 249 POIs, assuming that they are bounded by an area of 3km2 (i.e., the density of POIs is about 83 per km2). Then, we simulated the locations of the users in a certain context by taking into account several user profiles (see Table 4) – each user is assumed to belong to one of those profiles –, the values of the context variable “transport way” (as there are missing values for this context variable in the dataset, we generated the missing values randomly), and the locations of the POIs generated previously.As an example, according to Table 4, if a user with a “lazy profile” is driving in his/her car, then he/she will consider as far those POIs that are at a distance exceeding 1km. Now, let us imagine that we have a rating provided by this user for a certain item and that the user indicated that the item was “near”. In order to simulate a plausible location of the user when he/she provided that rating, we proceed as follows: 1) we generate randomly a location within a scenario of 4km2 (slightly higher than the area of 3km2 where the items are positioned, in order to simulate the potential absence of items, but not of users, near the borders of the scenario); 2) we compute the distance between the location of the user and the POI; and 3) if the distance is smaller than 1km (the maximum radius for that user profile and transportation means), then that location is valid for the user at the time of voting and can be kept, and otherwise we get back to step 1.As we are generating some data randomly to complete the dataset, it is important to ensure that this artificial addition does not modify any substantial aspect of the dataset. For that purpose, we computed the Pearson correlation coefficient to determine the relationship between the ratings provided by the users and the distance to the corresponding POIs. We obtained a Pearson coefficient of 0.18 (very slight positive correlation) for the original values in the dataset, which indicates that the user does not generally penalize ratings for items that are far. For the simulated data, we obtained a coefficient of −0.01 (near independency, which is consistent with the fact that the missing data were generated randomly). In both cases, there is a very weak correlation. Therefore, the modifications to the dataset do not affect the real correspondence between the ratings and the distances between the users and the items rated. In Fig. 7we show the distribution of ratings for each real distance indication (item near the user or far from the user) and we can see that there is a high percentage of high ratings (rating values of 4 and 5) for both of those two distance indications, not only for nearby items.In our experimental evaluation, we have used the classical metrics of Mean Absolute Error (MAE), precision, recall, and F-measure. We determined the MAE (see Eq. (2)), by computing the absolute differences between the predicted ratingsr^iand the real ratings (ri), averaged over the number of ratings available.(2)MAE=1n∑i=1nr^i−riwhereas the MAE is a measure of the absolute numeric error in the estimation of the votes, the precision, recall and F-measure indicate the performance of the recommendation algorithm regarding the items recommended and not recommended. Thus, the precision (see Eq. (3)) reflects the capability to recommend only useful items (avoiding the irrelevant ones), while the recall (see Eq. (4)) represents the coverage of useful items that the recommendation model can obtain (avoiding missing relevant items). Finally, as a combined metric we use the F1-measure, which is defined as the harmonic mean of the precision and recall. The F1-measure is a particular case of F-measure (see Eq. (5)) for the particular case of a value of β=1. Notice that the meaning of the values TP, FP, and FN, used in the formulas of precision and recall is explained below, in relation to the concept of confusion matrix.(3)precision=TPTP+FP(4)recall=TPTP+FN(5)Fβ=1+β2∗precision∗recallβ2∗precision+recallTo illustrate the performance of the system in terms of precision and recall, it is useful to use a confusion matrix (or contingency table), as shown in Table 5. This table represents the four possibilities that can arise regarding a recommendation decision. The diagonal numbers TP (True Positives) and TN (True Negatives) count the correct decisions: recommend an item when it should be recommended and do not recommend an item when it should not be recommended, respectively. On the other hand, FP (False Positives) and FN (False Negatives), represent incorrect decisions: recommend an item when it should not be recommended and do not recommend an item when it should be recommended, respectively.In order to evaluate the performance of the context-aware recommendation paradigms included in the framework, we compared the pre-filtering, post-filtering, contextual modeling, and traditional recommendations. The experiments were realized with the dataset STS described in Section 5.1 and analyzed in Section 5.2, after performing the slight adaptations indicating in Section 5.3. Our experiments include a training phase and a testing phase. Hence, we decided to divide 70% of the data for training and 30% for testing. The training set represents information available about the user profiles (previous ratings already provided by the users) whereas with the testing set we simulate items that have not been rated yet (the system will try to predict the right recommendations for those items).Firstly, we compare the traditional algorithm of collaborating filtering (non-contextual) with the context-aware paradigms of pre-filtering, post-filtering, and contextual modeling. Due to the limited information available in the dataset, we decided to use the recommendation algorithm based on SVD (provided by Mahout). The SVD recommendation model allows a better handling of the problem of cold start, by capturing indirect relationships between users and items (i.e., it is able to relate several users even when they have not rated items in common). For the contextual modeling, we use the Naïve Bayes Classifier (implemented in Weka).In the pre-filtering and post-filtering paradigms, the similarity threshold was set at 0.5 and the similarity was calculated by using Eq. (1). In the pre-filtering paradigm, for the computation of context similarities by Algorithm 2, we apply for compareVariablesWithMissingInfo() the strategy that ignores context variables with unknown information and assumes a maximum similarity of 1 when a variable has a value and the other does not. We made this optimistic decision because the information of context vectors is very poor (there is a high sparseness in the representation of contexts, as explained in Section 5.2), and otherwise we would filter out too many contexts.In the post-filtering paradigm, we implemented the filteringWithSoftConstraints() algorithm called in Algorithm 4 by penalizing the predicted rating for the case of items that are far from the user, by measuring by how much the distance of what is considered near is exceeded (according to the user profile and his/her transportation means, as shown in Table 4). For this purpose, we verified if the rating predicted is greater than or equal to the recommendation threshold (set to 3). If so, we penalize the predicted rating by using Algorithm 8.Algorithm 8Post-filtering: penalization of the rating predicted based on the distance

@&#CONCLUSIONS@&#
In this paper, we have described a framework that facilitates the development of context-aware recommendation systems for mobile users. Specifically, the main contributions of this work are:•We have presented a recommendation architecture that is generic, extensible, and adaptable to the requirements of specific types of recommendations. As it has been shown in the extensive study of the state of the art, most related proposals are solutions to specified problems in certain domains. Despite those efforts, the emergence of flexible and generic frameworks to support an easy development of mobile CARS has been relatively unexplored.We have described in detail the design of the pull-based recommendation module, which accommodates the pre-filtering, post-filtering, and contextual modeling paradigms.We have performed an experimental evaluation that compares the different paradigms. A major difficulty for the experimental evaluation is the difficulty to find a suitable dataset that incorporates contextual information. Even with the limitations of the dataset chosen, which we have analyzed in detail, up to the authors' knowledge this is one of the first studies that performs an experimental evaluation of context-aware recommendation strategies for mobile environments which is not merely qualitative (i.e., simply based on user opinions about the expected or perceived benefits) but quantitative, based on data.The possibility to bridge the gap between CARS and mobile computing is still emerging and the framework described in this paper represents a vision that has to be tackled gradually. As future work, we plan to continue the development of the proposed architecture, with a special emphasis on the design of the techniques needed to facilitate recommendations and data sharing in mobile peer-to-peer environments, as well as on the design of the push-based recommendation module. Regarding the evaluation, we would like also to explore other alternatives (e.g., gamification with real users, through the development of a videogame with recommendation testing purposes).