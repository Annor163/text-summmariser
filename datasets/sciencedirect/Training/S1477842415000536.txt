@&#MAIN-TITLE@&#
Bounded seas

@&#HIGHLIGHTS@&#
Traditional island grammars are difficult to define and are not flexible enough.Bounded seas — a new technique of island parsing — are composable, robust, reusable and easy to define.Bounded seas are specified using our extension of parsing expression grammars.Parsers utilizing bounded seas require less effort to define and provide both good precision and performance in the two performed case studies.

@&#KEYPHRASES@&#
Semi-parsing,Island parsing,Parsing expression grammars,

@&#ABSTRACT@&#
Imprecise manipulation of source code (semi-parsing) is useful for tasks such as robust parsing, error recovery, lexical analysis, and rapid development of parsers for data extraction. An island grammar precisely defines only a subset of a language syntax (islands), while the rest of the syntax (water) is defined imprecisely.Usually water is defined as the negation of islands. Albeit simple, such a definition of water is naïve and impedes composition of islands. When developing an island grammar, sooner or later a language engineer has to create water tailored to each individual island. Such an approach is fragile, because water can change with any change of a grammar. It is time-consuming, because water is defined manually by an engineer and not automatically. Finally, an island surrounded by water cannot be reused because water has to be defined for every grammar individually.In this paper we propose a new technique of island parsing — bounded seas. Bounded seas are composable, robust, reusable and easy to use because island-specific water is created automatically. Our work focuses on applications of island parsing to data extraction from source code. We have integrated bounded seas into a parser combinator framework as a demonstration of their composability and reusability.

@&#INTRODUCTION@&#
Island grammars [1] offer a way to parse input without complete knowledge of the target grammar. They are especially useful for extracting selected information from source files, reverse engineering and similar applications. The approach assumes that only a subset of the language syntax is known or of interest (the islands), while the rest of the syntax is undefined (the water). During parsing, any unrecognized input (water) is skipped until an island is found.A common misconception is that water should consume everything until some island is detected. Rules for such water are easy to define, but they cause composability problems. Consider a parser where local variables are defined as islands within a method body. Now suppose a method declaring no local variables is followed by one that does. In this case the water might consume the end of the first method as well as the start of the second method until a variable declaration is found. The method variables from the second method will then be improperly assigned to the first one.In practice, language engineers define many small islands to guide the parsing process. However it is difficult to define such islands in a robust way so that they function correctly in multiple contexts. As a consequence they are neither reusable nor composable.To prevent our variable declaring island from skipping to another method, we have to make its water stop at most at the end of a method. In general, we have to analyze and update each particular island׳s water, depending on its context. Yet island-specific water is fragile, hard to define and it is not reusable. It is fragile, because it requires re-evaluation by a language engineer after any change in a grammar. It is hard to define, because it requires the engineer׳s time for detailed analysis of a grammar. It is not reusable, because island-specific water depends on rules following the island, thus it is tailored to the context in which the island is used — it is not general.In this paper we propose a new technique for island parsing: bounded seas[2]. Bounded seas are composable, reusable, robust and easy to use. The key idea of bounded seas is that specialized water is defined for each particular island (depending on the context of the island) so that an island can be embedded into any rule. To achieve such composability, water is not allowed to consume any input that would be consumed by a following rule.To prevent fragility and to improve reusability, we compute water automatically, without user interaction. To prove feasibility, we integrate bounded seas into Petit Parser [3], a PEG-based [4] (see Appendix A) parser combinator [5] framework.In addition to our previous work [2] we evaluate the usability of bounded seas in two case studies, we present a performance study, and we provide more details about the implementation. The contributions of the paper are:•the definition of bounded seas, a composable, reusable, robust and easy method of island parsing;a formalization of bounded seas for PEGs;an implementation of bounded seas in a PEG-based parser combinator framework; andcase studies of semi-parsing of Java and Ruby using bounded seas.Structure: Section 2 motivates this work by presenting the limitations of island grammars with an example. Section 3 presents our solution to overcoming these limitations by introducing bounded seas. Section 4 introduces a sea operator for PEGs, which creates a bounded sea from an arbitrary PEG expression. Section 5 presents our implementation of bounded seas in PetitParser. Section 6 discusses the applicability of bounded seas to GLL parsers, design decisions and some limitations of bounded seas. Section 7 analyzes how well bounded seas perform compare to other island parsers. Section 8 analyzes usability of bounded seas for context-sensitive grammars, particularly for indentation-sensitive grammars. Section 9 surveys other semi-parsing techniques and highlights similarities and differences between them and bounded seas. Finally, Section 10 concludes this paper with a summary of the contributions.Let us consider the source code in Listing 1 written in some proprietary object-oriented language. We don׳t have a grammar specification for the code, because the parser was written using ad hoc techniques, and we do not have access to its implementation. Let us suppose that our task is to extract class and method names. Classes may be contained within other classes and we need to keep track of which class each method belongs to.Listing 1Source code of the Shapeclass in a proprietary language.To extract a flat list of method names, we could use regular expressions. We need, however, to keep track of the nesting of classes and methods within classes. Regular expressions are only capable of keeping track of finite state, so are formally too weak to analyze our input. To deal with nested structures, we need at least a context-free parser.Modern implementations of regular expression frameworks can parse more than regular languages (e.g., using recursive patterns22http://perldoc.perl.org/perlre.html). Such powerful frameworks can handle our rather simple task. However regular expressions are not meant to specify complex grammars since they tend to be hard to maintain when the complexity of the grammar grows.To write a parser, we need a grammar. Because the grammar can easily consist of a hundred rules (e.g.,≈80for Python,≈180for Java) and since we are only interested in specific parts of the grammar, we define an island grammar as a PEG (see Appendix A) with fewer than ten rules as in Listing 2. We initially assume that each class body contains just one method.33We use an almost standard PEG formalism for grammar definitions (see Appendix A). A terminal is quoted ‘terminal’, a non-terminal is not quoted nonterminal, a sequence is a concatenation of expressions, prioritized choice is marked as /, repetition as *, a not-predicate as!, and . stands for any character.Since we are interested in extracting method names, we define the method rule as an island inside of the methodWater rule which surrounds it with water. The methodWater rule is defined imprecisely: water skips everything until the string “method” is found.We also define the block rule, which consumes an open curly brace and then skips everything until the closing curly brace is found.Listing 2Our first island grammar.The methodWater rule in the grammar in Listing 2 uses a naïve definition of water. It will work as long as we do not complicate the grammar.Suppose that in order to allow multiple classes in a single file we modify the start rule to allow repetition (start←class⁎). Parsing the input in Listing 3 should fail because Shape does not contain a method. The result, however, no matter whether we use PEG or CFG, is only one class — Shape (instead of Shape and Circle) — with a method getDiameter, which is wrong. We see that our water is too greedy here, trying to find a method at any cost and ignoring the ‘endclass’ and the Circle definition.Listing 3Source code of Shape and Circle classes.Things do not get better when we allow multiple repetitions of methodWater within classBody (classBody←methodWater⁎). The parser will stay confused, and, depending on the technology (CFG, PEG), the result will be either ambiguous (CFG) or incorrect (PEG).The language engineer has to use either (a) disambiguation rules and filters [6,7] to filter out unwanted results of CFGs; or (b) predicates to prevent the incorrect decisions of CFGs and PEGs. Since predicates are applicable for both technologies (CFGs and PEGs), we focus on this approach.To make the methodWater rule composable we must make it possible for it to be embedded into optional (?) or repetition (+, *) rules. We consequently define the grammar as in Listing 4. This new definition can properly parse multiple classes in a file with an arbitrary number of methods in a class. We achieve composability by forbidding the water to go beyond the ‘endclass’ keyword and by forbidding the water to consume any method definition.Listing 4Complete and final island grammar.One can see that the syntactic predicates in the methodWater are more complicated. They have been inferred from the rest of the grammar by analyzing which tokens can appear after the method island. In case we decide to allow for nested classes, i.e., if we extend the rule classBody to:we have to revise the predicates of methodWater to add!‘class’, and we have to find the proper predicates for the classWater rule.The limitations of defining methodWater and classWater by hand illustrate the general problems of semi-parsing [8,9] with island grammars:1.Water rules are hard to define correctly because they require the entire grammar to be analyzed.The definition of water is fragile because predicates need to be re-evaluated after any change in a grammar.Finally, the water rules are tailored just for a specific grammar and cannot be reused in another grammar with different rules.We have shown that water must be tailored both to the island within the water and to the surroundings of the water (e.g., methodWater in Listing 4). In this paper, we define a bounded sea to be an island surrounded by context-aware water.To automate the definition of bounded seas we introduce a new operator for building tolerant grammars: the sea operator. We use the notation~island~to create sea from island, which can be a terminal or non-terminal. Instead of having to produce complex definitions of sea, a language engineer can use the sea operator which will do the hard work. Listing 5 shows how the grammar of Listing 4 can be defined using the sea operator.Listing 5Island Grammar from Listing 4 rewritten with the sea operator.A rule defined with the sea operator (e.g.,~method~) maintains the composability property of the advanced grammar since by applying the sea operator we search for the island in a restricted scope. Moreover, such a rule is reusable, robust, and simple to define.Bounded seas are based on two ideas:1.Water never consumes any input from the right context of the bounded sea, i.e., any input that can appear after the bounded sea. This is very different from the water of “traditional” island grammars, where water is not guaranteed to not consume a part of a valid input (cf. Section 2.2.1). The water of bounded seas is unambiguous, thus improving composability.Everything is fully automated. The sea is created using the sea operator~island~. Once the sea is placed in the grammar, the grammar is analyzed and appropriate water is created without user interaction. This way the sea can be placed in any grammar. In case the grammar is changed, the water is recomputed automatically. Automatic water computation eases grammar definition, and ensures robustness and reusability of rules.Bounded seas can be integrated into a parser combinator framework, a highly modular framework for building a parser from other composable parsers [10]. The fact that a bounded sea can be implemented as a parser combinator demonstrates its composability and flexibility.Ideally water should never consume any input that can appear after a bounded sea, i.e., it should never consume an input from its right context. We will call the right context the boundary of a sea. The right context of the sea consists of the inputs accepted by parsing expressions that appearafter the island. In the case ofA←~‘a’~(B/C), the right context of~‘a’~is any input accepted either by B or by C.Being aware of the boundary, a tolerant parser can search for methods in a class without the risk that other classes will interfere. Bounded seas would correctly parse the input in Listing 3 because water of a method sea would not be allowed to consume endclass, which is a boundary of the methodSea.The island-specific water has to stop in two cases: first, when an island is reached; second, when a boundary is reached. If a boundary is reached before an island is found, the sea fails. The fact that sea can fail implies that sea can be embedded into optional or repetition expressions without ambiguous results. For example, we can define the superclass specification as an optional island:If superclassSpec is not present for the particular class, it will simply fail upon reaching classBody instead of searching for superclassSpec further and further. The same holds for repetitions.This rule will consume only methods until it reaches “endclass” in the input string, since endclass is in the boundary of~method~, so methods in another class cannot be inadvertently consumed.We first define bounded seas generally, and subsequently provide a PEG-specific definition.Definition 1Bounded seaA bounded sea consists of a sequence of three parsing phases:1.Before-water: Consume input until an island or the right context appears. Fail the whole sea if we hit the right context. Continue if we hit an island.Island: Consume an island.After-water: Consume input until the right context is reached.In order to preserve the unambiguity of water in bounded seas, they need to be context-sensitive. A bounded sea recognizes different substrings of an input depending on what surrounds the sea. There are two cases where context-sensitivity emerges:1.A bounded sea recognizes different input depending on what immediately follows the sea.A bounded sea recognizes different input depending on what immediately precedes the sea.Let us demonstrate context sensitivity of bounded seas using rules from Listing 6 and two inputs,“‥a‥b‥”and“‥a‥c‥”. On its own, A recognizes any input with ‘a’ and B recognizes any input with ‘b’ (see rows 1–4 in Table 1), because they are not bounded by anything.Listing 6Rules for demonstrating context-sensitive behavior.However, when the two islands are not alone, their boundary can differ, depending on the context. The right context of A is ‘b’ in R3, and the right context of A is ‘c’ in R4. Therefore A consumes different substrings of input depending whether it is called from R3 or R4 (see rows 5–8 in Table 1).A more complex case of context-sensitivity, which we call the overlapping sea problem, arises when one sea is immediately followed by another. Consider, for example, rule R5, where the sea A has as its right context B, which is also a sea. Note that the before-water of B should consume anything up to its island ‘b’ or its own right context, including the island of its preceding seaA. Now, the before-water of A should consume anything up to either its island ‘a’ or its right context B. But the very search for the right context will now consume the island we are looking for, since B׳s before-water will consume‘a’!We must therefore take special care to avoid a “shipwreck” in the case of overlapping seas by disabling the before-water of the second sea. Therefore B recognizes“‥a‥b‥”when called from R2 and“b‥”when called from R5 (see rows 3 and 9 in Table 1). For the detailed example of the~a~~b~sequence, see B.3.Starting from the standard definition of PEGs (see Appendix A), we now show how to add the sea operator to PEGs while avoiding the overlapping sea problem. To define the sea operator, we first need the following two abstractions:1.The water operatorconsumes uninteresting input. Water (≈) is a new PEG prefix operator that takes as its argument an expression that specifies when the water ends. We discuss this in detail in Section 4.1.The NEXT functionapproximates the boundary of a sea. Intuitively, NEXT(e) returns the set of expressions44The NEXT function is modeled after FOLLOW sets from parsing theory, except that instead of returning a set of tokens, it returns a set of parsers.that can appear directly after a particular expression e. The details of the NEXT function are given in Section 4.2.Given the definitions of ≈ and NEXT, we define the sea operator as follows:~e~is a sequence expressionwherenexti∈NEXT(e)fori=1‥nandn=|NEXT(e)|.That is, the before-water consumes everything up to the island or the boundary, and the after-water consumes everything up to the boundary.The purpose of a water expression is to consume uninteresting input. Water consumes input until it encounters the expression specified in its argument (i.e., the boundary). We must, however, take care to avoid the overlapping sea problem.If two seas overlap (one sea is followed by another),the right boundary of the first sea starts with the second sea. Yet it should only start with the island of the second sea as illustrated in Section 3.3. In order to do so, the second sea has to simply disable its before-water.We detect overlapping seas as follows: if sea s2 is invoked from the water of another sea s1, it means that the water of s1 is testing for its boundary s2 and thus s2 has to disable its before-water. To distinguish between nested seas (e.g.,‘~x’~island~‘x’~) and overlapping seas (e.g.,~‘x’~~‘y’~), we test the position where this sea was invoked. In case of nested seas the positions differ, and in case of overlapping seas they are the same.Definition 3Extended semantics of PEGsIn order to detect overlapping seas and to compute the NEXT set, we extend the original semantics of a PEGG={N,T,R,es}(see Definition 8 in Appendix A) with a stack of invoked expressions and their positions. For standard PEG operators there is no change except that an explicit stack S is maintained. We define a relation⇒from tuples of the form(x,S)to the output o, wherex∈T⁎is an input string to be recognized, S is a stack of tuples(e,p), where e is a parsing expression andp≥0is a position, ando∈T⁎∪{f}indicates the result of a recognition attempt. The distinguished symbolf∉Tindicates failure. Function len(x) returns the length of an input x. Function(e,p):Sdenotes a stack with tuple (e,p) on the top and stack S below. S is initialized with the pair(es,0).We define⇒inductively as follows (without any semantic changes for standard PEG operators)55Note that in these rules p is implicitly defined as the current position in the input.:Empty:x∈T⁎(x,(ϵ,p):S)⇒ϵTerminal(successcase):a∈Tx∈T⁎(ax,(a,p):S)⇒aTerminal(failurecase):a≠b(a,ϵ,S)⇒f(bx,(a,p):S)⇒fNonterminal:A←e∈R(x,(e,p):S)⇒o(x,(A,p):S)⇒oSequence(successcase):(x1x2y,(e1,p):S)⇒x1(x2y,(e2,p+len(x1)):S)⇒x2(x1x2y,(e1e2,p):S)⇒x1x2Sequence(failurecase):(x,(e1,p):S)⇒f(x,(e1e2,p):S)⇒fSequence(failurecase2):(xy,(e1,p):S)⇒x(y,(e2,p+len(x)):S)⇒f(xy,(e1e2,p):S)⇒fAlternation(case1):(xy,(e1,p):S)⇒x(x,(e1/e2,p):S)⇒xAlternation(case2):(x,(e1,p):S)⇒f(x,(e2,p):S)⇒o(x,(e1/e2,p):S)⇒oRepetitions(repetitioncase):(x1x2y,(e,p):S)⇒x1(x2,(e⁎,p+len(x1)):S)⇒x2(x1x2y,(e⁎,p):S)⇒x1x2Repetitions(terminationcase):(x,(e,p):S)⇒f(x,(e⁎,p):S)⇒ϵNotpredicate(case1):(xy,(e,p):S)⇒x(xy,(!e,p):S)⇒fNotpredicate(case2):(xy,(e,p):S)⇒f(xy,(!e,p):S)⇒ϵA detailed example can be found in B.3.Definition 4Water operatorWith the extended semantics of PEGs we can define a prefix water operator≈. It searches for a boundary and consumes input until it reaches a boundary. If the water starts a boundary of another sea, it stops immediately. FunctionseasOverlap(S,p1)returns true if there is a pair(≈e,p2)on a stack S wherep1=p2and e is any parsing expression and returns false otherwise.x∈T⁎,y∈T⁎,z∈T⁎.Overlappingseas:seasOverlap(S,p)(x,(≈e,p):S)=ϵBoundaryfound:(yz,(e,p):S)⇒y(x″,(e,p+len(x′)):(≈e,p+len(x′)):S)⇒f∀x=x′x″x‴(xyz,(≈e,p):S)=xIn case of directly nested seas (e.g.,~~island~~) we obtain the same behavior as with~island~. The function seasOverlap returns true in case a sea is directly invoked from another sea without consuming any input. Applying the rule Overlapping seas from Definition 4, water of the inner sea is eliminated and the boundary is the same for the both seas. Therefore~~island~~is equivalent to~island~.Any input that can appear after the sea forms a boundary of a sea. The NEXT function returns a set of expressions that can appear directly after a particular expression.Consider the grammar in the example from Listing 7. The code rule is defined in such a way that it accepts an arbitrary number of class and structure islands in the beginning (classes and structures can be in any order) and there is a main method at the end. Intuitively, another class island, a structure island or a main method can appear after a class island.The NEXT set approximates the boundary. Its expressions recognize prefixes of the boundary and not necessarily the whole boundary. The reason for using NEXT is the limited backtracking ability of PEGs. PEGs are not capable of taking globally correct decisions because they are not able to revert choices that have already been taken.66See for example: http://www.webcitation.org/6YrGmNAi7.Listing 7Definition of code that consists of classes and structures followed by main method.For practical reasons, elements of NEXT cannot accept an empty string. For example,an optional expression is not a suitable approximation of a boundary, because it succeeds for any input. Consider a simple expression~e~‘a’?‘b’. The ‘a’? can appear after the ‘island’ but ‘b’ as well if ‘a’ fails. Therefore NEXT has to return ‘a’? ‘b’ , not just ’a’?.We will use abstract simulation[4] in order to recognize an expression that accepts an empty string.Definition 5Abstract simulationWe define a relation⇀consisting of pairs (e,o), where e is an expression ando∈{0,1,f}. Ife⇀0, then e can succeed on some input while consuming no input. Ife⇀1, then e can succeed on some input while consuming at least one terminal. Ife⇀f, then e may fail on some input. We will use variable s to represent a ⇀ outcome of either 0 or 1. We will define the simulation relation ⇀ as follows:1.ϵ⇀0.t⇀1,t∈T.t⇀f,t∈T.A⇀oife⇀oandA←eis a rule of the grammar G.e1e2⇀0ife1⇀0ande2⇀0.e1e2⇀1ife1⇀1ande2⇀s.e1e2⇀1ife1⇀sande2⇀1.e1e2⇀fife1⇀fe1e2⇀fife1⇀sande2⇀f.(a)e1/e2⇀0ife1⇀0(b)e1/e2⇀1ife1⇀1e1/e2⇀oife1⇀fande2⇀o.e⁎⇀1ife⇀1e⁎⇀0ife⇀f!e⇀fife⇀s!e⇀0ife⇀fBecause this relation does not depend on the input string, and there are a finite number of expressions in a grammar, we can compute this relation over any grammar [4]. An example of abstract simulation can be found in Appendix B.1.Definition 6NEXTLet S be a stack of (expression, position) pairs representing positions and invoked parsing expressions, where▵¯(S)pops an element from the stack S returning a stackS′without the top element,sn,sn−1, …s2,s1are expressions on the stack S (top of the stack is to the left, bottom to the right), $$is a special symbol signaling end of input, andE1×E2is a product of two sets of parsing expressions, E1 and E2, such thatE1×E2={eiej|ei∈E1,ej∈E2}, we define NEXT(S) as a set of expressions such that:•ifsn=e1andsn−1=e1e2ande2/⇀0thenNEXT(S)={e2}ifsn=e1andsn−1=e1e2ande2⇀0thenNEXT(S)={e2}×NEXT(▵¯(S))ifsn=e1andsn−1=e1e2thenNEXT(S)={e2}ifsn=e2andsn−1=e1e2thenNEXT(S)=NEXT(▵¯(S))ifsn=e1orsn=e2andsn−1=e1/e2thenNEXT(S)=NEXT(▵¯(S))ifsn=eandsn−1=e⁎thenNEXT(S)=e∪NEXT(▵¯(S))ifsn=eandsn−1=!ethenNEXT(S)={}ifsn=e∈NthenNEXT(S)=NEXT(▵¯(S))if n=0 (stack is empty) thenNEXT(S)={$$}An example of NEXT computation can be found in Appendix B.2.

@&#CONCLUSIONS@&#
