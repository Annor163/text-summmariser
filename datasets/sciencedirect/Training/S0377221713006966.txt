@&#MAIN-TITLE@&#
Optimal relay node placement in delay constrained wireless sensor network design

@&#HIGHLIGHTS@&#
Examined the relay node placement problem in delay-constrained wireless sensor networks.Devised a branch-and-cut based algorithm to solve problem optimally in the projection space.Established node cut inequalities as the facet defining inequalities for the projection polytope.The projection algorithm substantially outperforms the column generation approach to find a lower-bound.Proposed a new Lagrangian relaxation based heuristic.

@&#KEYPHRASES@&#
Relay node placement,Cutting plane/facet,Polyhedral theory,Projection,Branch and cut,Lagrangian-relaxation,

@&#ABSTRACT@&#
The Delay Constrained Relay Node Placement Problem (DCRNPP) frequently arises in the Wireless Sensor Network (WSN) design. In WSN, Sensor Nodes are placed across a target geographical region to detect relevant signals. These signals are communicated to a central location, known as the Base Station, for further processing. The DCRNPP aims to place the minimum number of additional Relay Nodes at a subset of Candidate Relay Node locations in such a manner that signals from various Sensor Nodes can be communicated to the Base Station within a pre-specified delay bound. In this paper, we study the structure of the projection polyhedron of the problem and develop valid inequalities in form of the node-cut inequalities. We also derive conditions under which these inequalities are facet defining for the projection polyhedron. We formulate a branch-and-cut algorithm, based upon the projection formulation, to solve DCRNPP optimally. A Lagrangian relaxation based heuristic is used to generate a good initial solution for the problem that is used as an initial incumbent solution in the branch-and-cut approach. Computational results are reported on several randomly generated instances to demonstrate the efficacy of the proposed algorithm.

@&#INTRODUCTION@&#
A Wireless Sensor Network (WSN) consists of spatially distributed Sensor Nodes (SNs) to monitor physical or environmental conditions, such as temperature, pressure, motion or pollutants. These SNs transmit the sensed data through wireless communication to a Base Station (BS) (Clare, Pottie, & Agre, 1999). SNs may be placed inside the event to be monitored or in the proximity of the same. These features ensure a wide range of applications for WSN in varied areas, e.g. health-care, military operations, and environmental monitoring. WSN may be deployed in a vast geographical area (e.g. oceans, forests) in order to detect critical events such as forest-fire, tsunami, and floods. Using WSN, doctors can remotely monitor physiological condition of their patients. WSNs can be an essential part of military operations with their ability to perform key strategic tasks, e.g. battlefield surveillance, reconnaissance of rival armies etc. (cf. Akyildiz, Su, & Sankarasubramaniam, 2002).Transmission radius of SNs (the range beyond which they cannot transmit the signals) is typically several tens of meters. Due to the limited transmission radius and the vastness of target geographical region, usually a multi-hop wireless communication, using some additional Relay Nodes (RNs), is required to facilitate end-to-end communication between SNs and the BS. As the cost of RNs ranges from tens to hundreds of dollars, minimizing the number of additional RNs without compromising the quality of signals is an important aspect of the WSN design.Objective of the Delay-Constrained Relay Node Placement Problem (DCRNPP) is to design a multi-hop wireless mesh network with minimum number of additional RNs in order to facilitate wireless-communication between each of the SN and the BS. The placement of RNs should ensure that the delay on the paths between BS and the SNs is restricted within a pre-specified delay bound. DCRNPP studied in this paper is motivated by an important class of WSN, where locations of the Candidate Relay Nodes (CRNs) are known a priori. For example, in forest fire detection, a set of sites where the CRNs can be placed may be known beforehand. In brief, the key features of DCRNPP, studied in this paper, are the following.•The locations of SNs and CRNs are known beforehand.Transmission radius of the SN/RN allows only certain links to be permitted in the graph.The objective is to obtain a sub-graph with minimum number of CRNs selected that connects all SNs to BS.Placement of RNs must ensure that there exists at least one path from each SN to the BS, for which the cumulative delay does not exceed a pre-specified delay bound Δ.The version of DCRNPP, with relaxation of the delay constraint, known as the Relay Node Placement Problem (RNPP) is broadly related to the Steiner tree problem (STP) in graphs (Gondran & Minoux, 1984). Classical STP is a NP-Hard problem and is extensively studied by various researchers (Robins & Zelikovsky, 2005; Karpensiki & Zelikovsky, 1993; Arora, 1998; Chopra & Rao, 1994a; Chopra & Rao, 1994b).The Prize collecting Steiner tree Problem (PCSP) (or the Node weighted Steiner tree Problem, NSP), where node weights along with edge weights are specified, can be considered as a generalization of both STP and RNPP (Duin & Volgenant, 1987; Segev, 1987). Approximation algorithms for PCSP are proposed by various researchers (Klein & Ravi, 1995; Demaine & Hajiaghayi, 2009; Remy & Steger, 2009; Canuto, Resende, & Ribeiro, 2001; Klau et al., 2004). Fischetti (1991) studied the facial structure of a generalization of PCSP, known as the Steiner arborescence (or directed Steiner tree) problem, and pointed out that the PCSP can be transformed into it. Engevall, Lundgren, and Värbrand (1998) proposed another ILP formulation for the PCSP, based on the shortest spanning tree problem formulation, which was introduced originally by Beasley (1989) for the Steiner tree problem. A cutting plane algorithm for the PCSP based on generalized sub-tour elimination constraints was proposed by Lucena and Resende (2004).The RNPP was studied as The Steiner Tree Problem with Minimum Number of Steiner Points and Bounded Edge Length (STP-MSPBEL) by Lin and Xue (1999). They showed the problem to be NP-complete and proposed a polynomial time 5-approximation algorithm for the problem. Cheng, Du, Wang, and Xu (2008) studied the same problem and proposed a 3-approximation and a 2.5-approximation algorithm. Voss (1999) studied the STP with hop constraints. The problem was shown to be NP-hard and a minimal spanning tree based heuristic was proposed to obtain a good feasible solution. Kim, Bang, and Choo (2006) studied the delay and delay variation constrained multicasting STP. The problem is similar to the one studied by Voss, with a delay constraint instead of the hop constraint, and a constraint on delay variation between two sources. They proposed a polynomial time heuristic algorithm for the problem. Costa, Cordeau, and Laporte (2008) studied the STP with revenue, budget, and hop constraints. They proposed a greedy heuristic for generating initial solution. The initial solution was improved by the destroy and repair or the tabu search algorithm. Gouveia, Paias, and Sharma (2008) studied rooted distance-constrained minimum spanning tree problem, and proposed a path based formulation. They presented a column generation scheme and a Lagrangian relaxation based approach combined with sub-gradient optimization procedure to solve the problem. Misra, Hong, Xue, and Tang (2008) studied the constrained relay placement problem for connectivity and survivability, and proposed an approximation algorithm for the same. Their model took into account the transmission radius as the edge length bound. Bhattacharya and Kumar (2010) studied DCRNPP and showed the problem to be NP-Hard. They presented a local search based greedy heuristic to provide an approximate solution for the problem.Another class of problem closely related to the RNPP is the Network Design Problem with Relays (NDPR). The NDPR is defined on an undirected graph G=(V,E,K), where V and E are the vertex and edge sets, respectively. Set K={o(k)∈V,d(k)∈V} is a set of communication pairs or commodities. Here, o(k) and d(k) denote the origin and destination of kth commodity, respectively. A cost cijis associated with each edge (i,j)∈E and a fixed cost fi, of installing a relay at vertex i, is associated with each vertex i∈V. The objective of NDPR is to select a subset E′⊆E and a subset V′⊆V in such a way that the total cost of network (edge cost and the relay installation cost) is minimized, and there exists a path linking the origin o(k) and destination d(k) for each commodity k∈K in which the length between any two consecutive nodes does not exceed a preset upper bound. Cabral, Erkut, Laporte, and Patterson (2007) developed a lower bound procedure and several heuristics for NDPR. They compared these algorithms on several randomly generated test instances. Li, Aneja, and Huo (2011) developed a Branch-and-Price algorithm for directed version of NDPR, using an arc-path formulation. Konak (2012) presented a new formulation for NDPR based on set covering constraints. Using the new formulation, he proposed a Genetic Algorithm based heuristic to solve NDPR.To the best of our knowledge, there is no algorithm in the literature that solves DCRNPP optimally. Apart from developing a branch and cut based exact algorithm to solve DCRNPP, this paper also examines the polyhedron structure of the problem and proposes a projection formulation for DCRNPP. With the help of computational experiments on several randomly generated test instances, we demonstrate that the proposed algorithm based upon projection formulation is able to optimally solve problem instances of size up to 50 SNs and 200 CRNs, within reasonable CPU time.The paper is organized as follows. In Section 2, we describe a mathematical formulation for DCRNPP that involves an exponentially large number of path variables. Since not all the columns in this formulation are known explicitly, a column generation approach is presented in Section 3. The column generation approach solves the LP relaxation of the path-based formulation to compute a valid lower bound for the optimal solution. In Section 4, we describe a projection formulation for the problem, which involves variables corresponding to CRNs only. We identify a set of valid inequalities for the projection formulation, known as the node cut inequalities. These inequalities are facet defining for the projection polyhedron under certain mild conditions. In Section 5, we present two separation algorithms to generate violated node cut inequalities for the projection formulation. A heuristic to generate a good feasible solution, which is used as an initial incumbent in the branch and cut algorithm, is discussed in Section 6. In Section 7, we discuss the implementation details for the branch and cut algorithm that is used to solve DCRNPP optimally. Computational results on various randomly generated test instances are reported in Section 8. In Section 9, we summarize this work and identify possible areas for future research.In this section, we describe a path-based formulation for the DCRNPP. The problem is defined on an undirected graph G=(V,E). The SN set T={1,2,…,m}, CRN set R={1,2,…,n} and the BS (node 0) constitute the node set of the graph i.e. V=T∪R∪{0}. The edge set in the graph is defined as E={(i∈V,j∈V): lij⩽r}, where lijis the Euclidian distance, between node i and node j, bounded by the transmission radius r. A non-negative delay dijis associated with each edge (i,j)∈E and may be defined as some function of the Euclidean distances lij. We define the set of neighbors for each node i∈V, asNi={j∈V:(i,j)∈E}.The set Pkis defined as set of all paths between BS and the SN k∈T. Set P(=⋃k∈TPk) contains all paths between BS and all SNs. The set Pk,Δ(⊆Pk) is defined as set of all paths between the BS and SN k∈T within the delay bound Δ. Set PΔconsists of all delay-constrained paths between the BS and all SNs, i.e. PΔ=⋃k∈TPk,Δ.Following variables are used in the problem-formulation:•For each CRN j∈R, binary variable yjindicates whether a RN is placed at CRN location j or not.For each path p∈Pk,Δ, binary variable xpindicates whether path p is available between the BS and the SN k or not.For any path p∈Pk,Δ, the set of CRNs and the set of edges on the path are defined as Rpand Ep, respectively. We define coefficientajpas 1 if j∈Rpand 0 otherwise. The DCRNPP can be formulated as the following integer program:(1)F1:Minimize∑j∈Ryj(2)subjectto∑p∈Pk,Δajpxp⩽yj,∀k∈T,∀j∈R(3)∑p∈Pk,Δxp⩾1,∀k∈T(4)xp∈{0,1},∀p∈Pk,Δ(5)yj∈{0,1},∀j∈RThe objective function (1) aims to place RNs at minimum number of CRN locations. Constraints (2) state that a path is available only if all the CRNs on that path are selected. Constraints (3) are the connectivity constraints for each SN, and ensure that there is at least one delay-constrained path available between each SN and the BS.The formulation F1 has an exponentially large number of path variables. This naturally suggests the use of column generation approach, well known as being effective for problems with excessively many columns (Gilmore & Gomory, 1961; Savelsbergh, 1997; Desaulniers, Dumas, Solomon, & Soumis, 2005). Since column generation is well documented in the literature, we briefly introduce the master problem and corresponding pricing subproblem in this section.As the number of columns in formulation (F1) can be very large, the columns are progressively introduced into master problem. Let LF1 be the linear relaxation of F1, i.e. the problem without integrality constraints for variables xpand yj. The restricted LP relaxation RLF1 is initiated with small arbitrary set of paths P′(⊂PΔ), and then further columns are iteratively added to the restricted formulation. The dual variables associated with the optimal solution of RLF1 are used to define a pricing subproblem that computes paths between the BS and the SNs with a negative reduced cost, if any. These paths are then added to the current RLF1 to obtain next RLF1, which is solved again to obtain new dual variables. This iterative procedure is repeated until no more paths with a negative reduced cost can be found. At this point, the optimal solution for LF1 has been obtained. This solution provides a lower bound on the optimal solution of DCRNPP.Initialization of RLF1:Since the initial set of columns in RLF1 is required to ensure feasibility, RLF1 can be initialized with columns that correspond to the set of minimum delay paths between each of the SN and the BS. The minimum delay path between a SN and the BS can be computed by finding the shortest path between them, while the edge length is defined as delay on the corresponding edge.Let z∗ be the optimal solution for RLF1, andλjkand μkbe the values of dual variables corresponding to constraints (2) and (3), respectively. Then z∗ is the optimal solution of LF1 if there does not exist any path with negative reduced cost between the BS and any of the SNs. The pricing subproblem aims to find a delay-constrained shortest path with most negative reduced cost. The subproblem can be formulated as the following integer program:(6)SP:Minimizec¯p=mink∈T∑j∈Rpλjk-μksubjecttop∈PΔIn order to speed up the process, at each iteration we identify more than one columns with negative reduced cost instead of adding only one column with most negative reduced cost. We identify a delay-constrained shortest path between each SN and the BS with the most negative reduced cost. The pricing subproblem SP can be decomposed into m subproblems (SP(k)) (one for each k∈T). The subproblem is defined as:(7)SP(k):Minimizec¯p,k=∑j∈Rpλjk-μksubjecttop∈Pk,ΔSP(k) may be considered as the Delay Constrained Shortest Path Problem (DCSPP), where edge length for each edge (i,j)∈E is defined as:cij=λik+λjk2withλ0k=λkk=0The DCSPP is known to be a NP-Hard problem (Dror, 1994). There are no known polynomial-time or pseudo-polynomial-time algorithms to solve this problem. Dynamic programming is a good candidate approach to solve the DCSPP. However, the dimensionality of the associated state-space is a major issue that affects the run-time performance of dynamic programming approach.In our implementation, we have used a well-known dynamic programming based algorithm to solve DCSPP. The dynamic programming based algorithm assumes that the delay associated with each edge is an integer value. The assumption helps in establishing states for dynamic programming in form of (i,τ) for each i∈V and for τ=0, 1,…, Δ. We define f(i,τ) as the length of the shortest path between BS and node i∈S∪T with delay at most τ. The values f(i,τ) can be computed using the following recursion:(8)f(i,τ)=minj∈Ni;dji⩽τ(cji+f(j,τ-dji))(9)f(0,τ)=0;∀τ=0,1,…,ΔA node labeling method by (Desrochers, 1988) along with an improvement suggested by Gouveia et al. (2008), to reduce the number of state variables is employed to solve DCSPP using dynamic programming based algorithm.The column generation procedure is initialized with the set of minimum delay paths between BS and all the SNs. The restricted master problem RLF1 is solved to optimality. The dual variables, obtained from RLF1, are used to construct the pricing subproblem. The subproblem SP (k) for each k∈T is solved using the dynamic programming based algorithm. Columns with negative reduced cost are added to RLF1. If no columns with a negative reduced cost can be found, then an optimal solution for LF1 is obtained and no further iterations are required. The flowchart of the column generation algorithm is presented in Fig. 1.In the previous section, we presented a column generation approach to find a lower bound for DCRNPP. As we shall demonstrate later with the help of computational experiments, the column generation approach is computationally inefficient due to various reasons, some of which are as follows:•The pricing subproblem (DCSPP) is solved using a dynamic programming algorithm. The dynamic programming based algorithm has a burdensome dimensionality aspect and can be unacceptably slow in practice [Car08].Often, many iterations are required to prove optimality, while the optimal value of RLF1 does not change significantly from one iteration to another [Nab10]. This leads to a significant increase in the computation time.The path-based formulation (F1) has an exponentially large number of variables and solving an integer program (in order to obtain the optimal solution for DCRNPP) with these many variables is practically unviable.To overcome these issues pertaining to the column generation technique, in this section we present an alternate formulation for DCRNPP. The new formulation eliminates path variables from F1. Before presenting this formulation, we discuss the concept of node cuts in a graph. These node cuts correspond to the node cut inequalities for DCRNPP that provide the structure of the projection formulation.A node cut (γ⊆R) is a set of CRNs, deletion of which disconnects all feasible paths between the BS and a SN k∈T (Moss & Rabani, 2007). In other words, at least one CRN from a node cut must be selected to ensure connectivity between BS and SN k. A minimal node cut is the smallest possible node cut, i.e. a node cut is minimal if none of its subset is a node cut. LetΓ¯be the set of all node cuts in a graph, a minimal node cutγ∈Γ¯satisfies the following property:(10)γ⧹{j}∉Γ¯;∀j∈γA singleton node cut is a node cut with single element in it, i.e. ∣γ∣=1. A node cut inequality is defined as:(11)∑j∈γyj⩾1,where γ∈Γ is a minimal node cut and Γ is the set of all minimal node cuts. Node cut inequalities ensure that at least one CRN from each minimal node cut is selected in a feasible solution.Theorem 1Node cut inequalities(11)are valid for DCRNPP.From the definition of minimal node cuts, the proof of the theorem is straightforward. If all CRNs from a minimal node cut are deleted, the induced graph is disconnected. Hence, every feasible solution of DCRNPP must have at least one CRN selected from each node cut γ∈Γk.□LetHbe the set of all feasible solutions (x,y) to the path based formulation F1, and letHc=Conv(H), where Conv (S) is the convex hull of a set S. LetT={y∈Bn|∃x∋(x,y)∈H}andTc=Conv(T). In other words,Tcis the projection ofHcin the subspace of binary variables yj. We show that the node cut inequalities correctly describe the projection polyhedronTc, i.e.Tc=y∈Bn|∑j∈γyj⩾1∀γ∈Γ.Theorem 2PolyhedronTcdescribed by node cut inequalities(11)is a valid projection for the polyhedronHcin the space of y -variables.In order to prove this theorem, we need to prove the following statements:I.All integer solutions(x,y)∈Hsatisfy constraints (11).If for an integral vectory∈Bn,∄x∋(x,y)∈Hcthen y does not satisfy constraints (11).Theorem 1 establishes (11) as valid inequalities forH, hence all feasible solutions(x,y)∈Hnaturally satisfy constraints (11) and thus statement I is proved.In order to prove statement II, consider a binary solution vectory¯0∈Bnsuch that∄x¯0∋(x¯0,y¯0)∈Hc, whiley¯0satisfies the node cut inequalities (11). However, since there are no feasible solutions using the selected CRNs (CRNs for whichy¯j0=1) it implies that there are no delay-constrained paths between BS and at least one of the SNs with respect to the solution vectory¯0. Let k∗∈T be one such SN for which there are no delay-constrained paths. Surely,∀p∈Pk∗,Δ∃jp∈Rpsuch thaty¯jp0=0(if∃p′∈Pk∗,Δsuch that∀j∈Rp,y¯j0=1then path p′ is a feasible path between the BS and the SN k∗ using the selected CRNs). The setγ¯=⋃p∈Pk∗,Δ{jp}is a valid node cut with∑j∈γ¯y¯j0=0. A minimal node cutγˆ⊆γ¯, can be found with∑j∈γˆy¯j0=0violating one of the node cut inequalities (11). This contradicts the assumption that binary vectory¯0satisfies all node cut inequalities. Hence, for an integral vectory∈Bn, if∄x∋(x,y)∈Hcthen y does not satisfy constraints (11).□PolytopeTcis full dimensional if and only if there are no singleton node cuts for any of the SN k∈T.Let’s assume that there exists a singleton node cut for any k∈T, in the form ofjk∗. Consequently, anyy∈Tccannot haveyjk∗=0, because then there are no paths between the BS and the SN k. Hence, if the stated condition is not satisfied, anyy∈Tcmust haveyjk∗=1, and thereforeTccannot be full dimensional.To show that the stated condition is sufficient, let’s create following n vectors for each CRN j0∈R:yjj0=0,ifj=j01,OtherwiseIf the stated condition is satisfied, clearly these vectors, and the y-vector with all 1’s (that corresponds to all CRNs selected) provide n+1 affinely independent integer solutions inTc.□Theorem 3 established the necessary and sufficient conditions for full dimensionality of polyhedronTc. We assume from now on that the polyhedronTcis full dimensional. In this sub-section, we will discuss the conditions under which the node cut inequalities (11) are facet defining for the projection polyhedronTc.Theorem 4A node cut inequality(11), with respect to a minimal node cut γ, is facet defining forTc, if and only if ∀j∈R⧹γ,∃j∗∈γ such that γ∪{j}⧹{j∗} is not a node cut.LetFbe the face of polytopeTcdefined by the node cut inequality (11), i.e.F=y|y∈Tc;∑j∈γyj=1. For inequality (11) to be facet defining, we need to demonstrate thatdim(F)=dim(Tc)-1. SinceTcis full dimensional, clearlydim(Tc)=n. In order to prove the sufficiency of the mentioned condition, we need to construct n affinely independent feasible solution vectors that satisfy inequality (11) as equality.We define the following q vector for each CRN t∈γ, where q=∣γ∣:yˆjt=0ifj∈γ⧹{t}1OtherwiseSince γ is a minimal node cut, none of its subset can be a node cut. Set γ⧹{t} is clearly not a node cut as it is a subset of minimal node cut γ. As all CRNs are selected inyˆjtexcept the CRNs in γ⧹ {t} (which is not a node cut),yˆjt,∀t∈γis a feasible solution vector for DCRNPP. Vectorsyˆjtalso satisfy node cut inequality (11) as equality.Now let’s define the following n−q vectors for each t′∈R⧹γ:yˆjt′=0ifj∈{t′}∪γ⧹{t∗}1Otherwisewhere t∗∈γ is such that γ∪{t′}⧹{t∗}∉Γ. Note that if the condition of the theorem is satisfied, there exists such a t∗ for every t′∈R⧹γ. Since the set γ∪{t′}⧹{t∗} is not a node cut and all CRNs except the nodes in γ∪{t′}⧹ {t∗} are selected as the part of given solution vector, clearly eachyˆjt′∀t′∈R⧹γis a feasible solution for DCRNPP and also satisfies inequality (11) as equality.Now consider the following n×n matrixN=(yˆ1,…,yˆq|yˆq+1,…,yˆn). Matrix N can be partitioned and viewed as:We want to show that n vectors of N are affinely independent. That is any multiplier vector λ such that Nλ=0, eTλ=0 implies that λ=0, where eTis the row vector of all 1’s of appropriate size. Let’s consider Ni, as row i>q of N. It has a zero in position i and all other elements are one. Thus, Miλ=0 and eTλ=0 imply λi=0. Thus λi=0∀ i>q. This coupled with the fact that q×q sub-matrix is an identity matrix results in λi=0∀i⩽q. Hence, n columns of N are affinely independent. In this way, we can construct n affinely independent feasible solution vectors that satisfy inequality (11) as equality. This proves the sufficiency conditiondim(F)=dim(Tc)-1.To show the necessity of these conditions, let N be a square matrix of some n affinely independent feasible vectors y1,…, ynthat satisfy (11) as equality. Let the top q rows correspond to CRNs in node cut γ. Clearly, y1,…, yndoes not contain the 0 -vector, and hence these n vectors are also linearly independent. Now let’s consider the sub-matrix N′ consisting of only top q rows of N. There exist some q columns of N′ that are linearly independent, and condition of the theorem is satisfied.□As node cut inequalities correctly describe the polyhedronTcand are also facet defining for the projection polyhedron under certain mild conditions, these inequalities can be used to formulate DCRNPP. Using node cut inequalities, we propose the following formulation for DCRNPP:(12)F2:Minimize∑j∈Ryjsubjectto∑j∈γyj⩾1∀γ∈Γyj∈{0,1},∀j∈RComparing formulations F1 and F2, we observe that the path variables are excluded from the projection formulation (F2). However, there are an exponentially large number of constraints in the form of node cut inequalities in the projection formulation. In the next section, we discuss separation algorithms to generate the violated node cuts in a graph for a given DCRNPP solution.In this section, we present separation algorithms to generate violated node cuts. We define the master problem (LF2) as LP-relaxation of the projection formulation F2. Given a fractional solution α of LF2, a node cutγ¯is said to be violated by α if∑j∈γ¯αj<1. The separation algorithms discussed in this section find such violated node cut for any suboptimal solution of LF2.We discuss two different separation algorithms in this section. The first separation algorithm is used to generate node cuts for the unconstrained problem. These unconstrained node cuts ensure backbone connectivity in the graph, i.e. it ensures that each of the SNs is connected to the BS even if there is no delay-constraint. The second separation algorithm finds node cuts in delay-constrained graph. These node cuts make sure that BS and all SNs are connected within the pre-specified delay bound Δ.For the unconstrained version, the violated node cuts can be found by transforming the node-weighted graph into an edge weighted graph and then finding the minimum weight edge cut using the standard max flow algorithms. Interested readers may find more details on polynomial time algorithms for max flow problem in (Ahuja, Magnanti, & Orlin, 1993). Violated node cuts, in a delay-constrained graph, are found using the algorithm discussed in detail in Section 5.2.Finding a node cut violated by the current solution of LF2 is equivalent to finding a minimum weight (s−t) cut in a graph with node capacities. An approach to convert a node-weighted graph into an edge-weighted graph is discussed in (Lawler, 1976). Let α be the LF2 solution. We expand the graph by replacing each CRN j by two nodes an in-node j′ and an out-node j″. Capacity assigned to arc (j′,j″) is αj. Each arc (i,j)∈A, is replaced with two arcs (i″,j′) and (j″,i′) of infinite capacity in the expanded graph. We note that k′=k″=k; ∀ k∈T∪{0}. The minimum weight s−t cut between the BS and SN k can be found using a polynomial time maximum flow algorithm e.g. shortest augmenting path algorithm (Ahuja & Orlin, 1991) or preflow push algorithm (Goldberg & Tarjan, 1986). In our implementation, we have used the Highest Label Preflow Push algorithm, which has a complexity ofO|V|2|E|(Cheriyan & Maheswari, 1989).The violated node cuts for a SN k∈T in a delay-constrained graph are found with the greedy heuristic ConstNodeCut (k,Δ) described in Fig. 2. The heuristic iteratively finds minimum delay paths between BS and SN k, and then deletes a CRN with minimum αjvalue on this path. Let’s define θ(0,k) as the cumulative delay on the minimum delay path between the BS and SN k. LetRpk∗andEpk∗be the set of CRNs and the set of edges, respectively, on the minimum delay path. The algorithm selects a CRNj∗∈Rpk∗such thatαj∗⩽αj∀j∈Rpk∗. CRN j∗ is then deleted from graph and inserted into an empty set S. Algorithm again finds the minimum delay path in the reduced graph induced by vertex set V′=V⧹S. This iterative procedure is continued until set S correspond to a node cut for the graph, i.e. there are no paths between the SN k and the BS within delay bound Δ in the graph induced by V⧹S. Once a node cut S is found, a minimal node cut can be found within set S by removing unnecessary CRNs from S (procedure MinimalNodeCut (S,k,Δ) to find a minimal node cut in a node cut is detailed in Fig. 3).Algorithm ConstNodeCut (k,Δ) is a heuristic approach for any fractional solution of the master problem. However, it behaves as an exact algorithm if the DCRNPP solution is integral.Theorem 5The heuristic ConstNodeCut (k,Δ) always finds a violated node cut for an infeasible integral solution.For an integral solutionα0, a violated node cutγ¯satisfies the condition that∑j∈γ¯αj0=0. Asα0is an infeasible solution, ∃k∗∈T such that there is no feasible path between the BS and SN k∗. Therefore,∃jp∈Rp∀p∈Pk∗,Δsuch thatαjp0=0. Since heuristic ConstNodeCut (k,Δ) seeks a CRN with leastαj0value on delay-constrained paths, it will be able to construct a violated node cut S by identifying these CRNs withαj0=0. Clearly, the heuristic will always find a violated node cut (with weight 0) for an infeasible integral solution.□In this section, we describe a Lagrangian relaxation based heuristic to generate a good feasible solution for DCRNPP. This solution is used as the initial incumbent for the branch and bound tree search.First, we discuss a Lagrangian relaxation based approach to find the constrained shortest path. The DCSPP can be formulated as:(13)DCSPP(k):Minimize∑(i,j)∈Eplijzij(14)subjectto∑(i,j)∈Epdijzij⩽Δ(15)zij=xp;∀(i,j)∈Ep(16)∑p∈Pkxp=1Here lijis the edge length, and dijis the delay associated with edge (i,j)∈A. Binary variable zijindicates whether or not edge (i,j)∈E is selected in the delay constrained shortest path, and binary decision variable xpindicates whether p∈Pkis selected as the delay constrained shortest path. Now consider the Lagrangian problem derived by associating non-negative multipliers λ to constraint (14) and dualizing it in the usual Lagrangian way:(17)SPP(k,λ):Minimizezλ=∑(i,j)∈Ep(lij-λdij)zij(18)zij=xp;∀(i,j)∈Ep(19)∑p∈Pkxp=1The formulation SPP (k,λ) is a simple shortest path problem. Based upon this Lagrangian relaxation, we describe the heuristic ConstSPTLag(k,Δ) to solve DCSPP between BS and SN k in Fig. 4. The algorithm is based upon the binary section search (Burden & Faires, 1985), and attempts to find the smallest Lagrangian multiplier (λ∗), for which the shortest path with respect to the dualized cost vector {(lij−λ∗dij): (i,j)∈A} satisfies the delay bound. Procedure MaxLagBoundfinds the upper bound (λmax) for the Binary section search and then the search is performed in the interval [0,λmax].For generating a heuristic solution for DCRNPP, we use the algorithm LagHeuristic(Δ) described in Fig. 5. An overview of the algorithm is as follows. The algorithm starts with empty lists Q and L. To begin with, algorithm finds the delay constrained shortest path ψ(0,k) for each SN k∈T with edge length defined as lij=1 ∀(i,j)∈A (DCSPP is solved using the Lagrangian relaxation approach discussed above). Further, we defineRpk∗ΔandEpk∗Δas the set of CRNs and the set of edges, respectively, on the delay constrained shortest path. CRNs on the delay constrained path to the node k∗∈T (where ψ(0,k∗)⩽ψ(0,k), ∀k∈T) are added to the empty list Q and are declared as free nodes. SN k∗ is added to list L. All edges between a pair of free nodes are now assigned edge length 0 and edges between free nodes and other nodes have edge length 0.5. In the following iterations, the shortest path is computed between the BS and all SNs in T⧹L, and more free nodes are added to list Q from the path ψ(0,k∗) as described above. Iterations are continued until all the SNs are added to the list L i.e. ∣L∣=m. The set of free nodes Q constitutes a heuristic solution for DCRNPP.

@&#CONCLUSIONS@&#
