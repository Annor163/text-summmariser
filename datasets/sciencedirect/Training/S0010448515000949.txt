@&#MAIN-TITLE@&#
Isogeometric segmentation: Construction of auxiliary curves

@&#HIGHLIGHTS@&#
A method is proposed for splitting a trimmed surface into two with a curve.The curve is required to have specified endpoints and tangents at the endpoints.The splitting is central to an algorithm for isogeometric segmentation of 3D models.The curve optimizes a penalty function that measures the quality of the shapes.We study regularity properties and methods for computing the penalty function.

@&#KEYPHRASES@&#
Isogeometric segmentation,Isogeometric analysis,Trimmed surface splitting problem,Domain splitting problem,

@&#ABSTRACT@&#
In the context of segmenting a boundary represented solid into topological hexahedra suitable for isogeometric analysis, it is often necessary to split an existing face by constructing auxiliary curves. We consider solids represented as a collection of trimmed spline surfaces, and design a curve which can split the domain of a trimmed surface into two pieces satisfying the following criteria: the curve must not intersect the boundary of the original domain, it must not intersect itself, the two resulting pieces should have good shape, and the endpoints and the tangents of the curve at the endpoints must be equal to specified values.

@&#INTRODUCTION@&#
Motivated by the problem of segmenting a solid into pieces suitable for isogeometric analysis (see  [1]), we develop a method for segmenting a trimmed surface by constructing a cutting curve. We consider a boundary represented solid to be a collection of trimmed NURBS surfaces, together with incidence information. A trimmed surface consists of (i) a tensor product NURBS map[0,1]2→R3defining the master surface; (ii) a trimmed domain, a subset of[0,1]2which itself is represented by a collection of NURBS curves defining its boundary. The surface itself is the image of the restriction of the master spline to the trimmed domain.In  [2,3] we initiated the development of a method for isogeometric segmentation, that is, the segmentation of a contractible boundary represented solid into boundary represented topological hexahedra (sufficiently smooth images of cubes). In order to be suitable for isogeometric analysis, the number of topological hexahedra in the segmentation should be small and it should be possible to convert each of them into a volumetric spline with no singularities and ideally not too much distortion. (Conversion of boundary represented topological hexahedra into volumetric splines can be done, using, for example, the method of  [4].) The idea of the method of  [2,3] is as follows:•Search the edge graph of the solid (the graph formed by the edges shared by trimmed surfaces) for a cutting loop: a closed curve in the boundary of the solid which can be used as the boundary of a surface that splits the solid into two simpler solids (see Fig. 3). If multiple cutting loops are found, choose the best one according to a combination of combinatorial and geometric criteria.By recursively splitting the solid into simpler pieces, we end up with a collection of base solids (topological hexahedra, tetrahedra and prisms) which have predefined segmentations into topological hexahedra.Our problem is to split a planar domain in two, using a spline curve with the following properties: (i) end points and tangents are specified, (ii) the curve is reasonably regular, and (iii) the curve cuts a simply connected domain into two pieces with good shape.An example, of somewhat exaggerated difficulty, is given in Fig. 1. A domain is shown together with the required tangent vectors at the endpoints. A curve is shown which splits the domain into two pieces and meets the endpoints in the specified directions.For a complicated domain, it may be easy to split the domain into 2 or more pieces with simple cuts that ignore the endpoint requirements. For example, the snake in Fig. 1 might be cut into any number of pieces with straight or nearly straight lines transversal to the snake’s body. Alternatively, the domain might be approximated by a quad mesh. These approaches are more appropriate than ours for segmenting a 2D object without restrictions. However, in order to realize the cutting loop that is central to the 3D segmentation algorithm outlined above, we must construct a curve that meets the specified end points with specified tangents.The basic idea of our procedure is as follows. We define a cost function on the space of curves, which consists of a measurement of how close the curve comes to intersecting the domain, how close it comes to intersecting itself and a regularity term. An initial curve is found for this optimization problem by first finding a piecewise linear curve inside the domain satisfying the endpoint conditions, refining it and using the vertices as control points for a degree 2 B-spline.It is important that the resulting curves are non-self-intersecting. In this sense, our problem is related to the problem of self-intersection elimination in curves and surfaces, studied in  [5–7]. Also related is the problem of threading a spline through a 2D or 3D channel  [8].Several other approaches to the solution are possible. We might treat the problem as a path planning problem with obstacles (for overviews of this large topic in robotic control, see for example  [9] and  [10, Part IV]). Path planning using curves of piecewise constant curvature is studied in  [11,12] among other papers. Curves with continuous piecewise linear curvature were proposed in  [13] for interpolating between postures, and used in  [14] to produce a local path planner (these are not polynomial splines). Path planning with B-splines is studied in e.g.,  [15–18]. Our problem differs from path planning problems in several ways. The constructed curve must have endpoints on the boundary of the domain, and elsewhere must not intersect the boundary. The curve cuts the domain into two pieces, and it is the shape of these pieces that is important. Path planning methods are not designed to produce a well shaped splitting of the domain. Many path planning methods seek a curve in a configuration space. Our curves do not represent the trajectory of a rigid body. Also, simplicity of the resulting B-spline curve (in terms of the degree and number of knots) is important.We considered the following approach to splitting the domain: map the domain to a convex shape (say, a circle) using mean value coordinates (MVC) or harmonic functions. It is easy to produce a B-spline curve connecting points on the boundary, and, by sampling the curve and using a predictor–corrector method, we can construct its preimage in the original domain. This approach is plausible but in our experience, several difficulties arise from this approach: (i) the outcome is a sampled curve, and a fitting step must be included to convert the samples into a B-spline. It is difficult to tell how many samples are needed to ensure that the fitted B-spline stays within the domain; (ii) using the boundary element method to compute MVC or harmonic functions is numerically challenging near the boundary of the domain; (iii) the quality of the result is dependent on how the curve is chosen in the convex domain, and it is not clear how to make a good choice.Another approach we considered is to fit a spline curve to a polygonal path which is found using a pathfinding method that stays away from the domain boundary∂Ωas follows: draw a line segment beginning at one of the end points in the initial specified direction, and ending at the first intersection pointythat the line has with∂Ω. This divides the domain into two pieces. Discard the piece which does not contain the other endpoint. The first half of the line segment is included in the polygonal path, the midpoint of the line segment is set as the new starting point, and a new initial direction is chosen which is parallel to the tangent direction of∂Ωaty. Repeat the procedure until there is a line segment directly to the remaining endpoint. This procedure produces a curve fairly quickly but in certain scenarios can result in unnecessarily thin shapes as shown in Fig. 2.In Section  2 we give precise statements of our assumptions and goals and describe our construction method. Section  3 describes our method for constructing an initial curve. In Section  4 we formulate the optimization problem which we use to find a suitable splitting curve, and outline our strategy for solving the optimization problem. Section  5 provides examples of varying difficulty, and in Section  6 we summarize how our work fits in to the isogeometric segmentation problem and describe the outlook and future work. Appendices A and B prove regularity properties of the penalty functions, and in Appendix C we provide a method for efficiently computing them.For context, we briefly outline the strategy described in  [2,3] for segmenting a solid. For our purposes, a solid is represented by a collection of trimmed surfaces, together with incidence information. We assume that the solid is contractible and that the edges form a simple, 3-vertex-connected edge graph. The edges of the graph are incidences between two faces. An auxiliary edge can be constructed between any two vertices that are on the same face but not on the same edge. A cutting loop is a cycle consisting of existing edges and auxiliary edges. The cutting loop can be used to split the edge graph into two, and the cutting loop is valid if it can be used as the boundary of a surface which splits the solid into two pieces, each satisfying the original assumptions. A valid cutting loop always exists, with the provision that under some circumstances, additional auxiliary vertices may need to be added to the graph. Repeatedly splitting the solid into two simpler pieces using cutting loops, we eventually arrive at a collection of base solids which have predefined segmentations into topological hexahedra. Examples of a single step of the solid segmentation method are shown inFigs. 2 and 3. In each of these examples, two existing edges and two newly created auxiliary edges are used to form a cutting loop.There are geometric conditions on the validity of a cutting loop which place constraints on the sequence of edges. Once these constraints are known, the search for a good cutting loop becomes a combinatorial problem. However, once the loop is chosen, each auxiliary edge needs to be realized geometrically. In other words, for each auxiliary edge in the cutting loop, we need to solve the following problem.Problem 1Trimmed Surface Splitting ProblemFind a spline curve of the trimmed domain, so that the trimmed surface is split into two new trimmed surfaces with reasonably good shapes.Due to the geometric conditions for a valid cutting loop, a solution to the trimmed surface splitting problem must be able to handle specified tangent directions at the endpoints.We now focus on the domain splitting problem, the part of the trimmed surface splitting problem that does not take consideration of the way the surface is embedded.Consider a simply connected domainΩ⊂R2with connected interior. We restrict our consideration to the case where the boundary∂ΩofΩis formed by spline curves  [20]. Suppose two pointsAandBon the boundary ofΩare given, along with two nonzero vectorsαandβthat point fromAandBto the domain interior respectively. Without losing generality, we assume that the boundary∂Ωconsists of two spline curvesb(v)andb˜(v),v∈[0,1], so thatb(0)≡b˜(0)≡A,b(1)≡b˜(1)≡B. The notations are illustrated in Fig. 4.Additionally, we narrow our consideration to the situation specified by the following assumptions.(A-1)The two curvesb(v)andb˜(v)have non-vanishing tangents at their end points.DomainΩhas non-zero interior angles atAandB; the prescribed velocity directionαis not tangent to any of the boundary curves atA; likewise,βis not tangent to any of the boundary curves atB.Throughout the remainder of the paper, we shall often associate discussions with the curveb(v)while referring tob˜(v)as a similar case. Assume that the curveb(v)is of the formb(v)=∑j=1nbjNj(v), whereNjare B-splines of degreeqand associated with an open knot vectorV={0,…,0=v1,v2,…,vn−1,vn=1,…,1}(the first knot and the last knot are repeatedq+1times), andbj∈R2are associated control points.Consider a spline curvec(u)of the form(1)c(u)=∑i=1mciMi(u),whereMiare B-splines of a degreepand associated with an open knot vector(2)U={0,…,0=u1,u2,…,um−1,um=1,…,1}(again, the first and the last knots are repeatedp+1times), andci∈R2are control points. The following definition will facilitate our discussions in the remainder of the paper.Definition 1A continuous spline curvec(u),u∈[0,1], is said to be a splitting curve of the domainΩif it satisfies the following conditions.(C-1)The curvecstarts atAtangentially toαand ends atBtangentially toβ. That is,(3)c(0)=A,c(1)=B,det[c′(0),α]=0,det[c′(1),β]=0.We divide this condition into the following 3 sub-conditions.(i)cis simple over[0,1], i.e.,c(u)≠c(v)for allu≠v.c+′(u)≠0for0≤u<1, andc−′(u)≠0for all0<u≤1.For all0<u<1andβ>0,c+′(u)≠−βc−′(u).The curvec(u)is contained in the interior of the domainΩexcept its two end points. That is,{c(u),0<u<1}⊂int(Ω).It immediately follows from the definition that a splitting curve of a simply connected domain decomposes the domain into two new simply connected domains.We can now state our domain splitting problem, which differs from the trimmed surface splitting problem by not considering the embedding inR3.Problem 2Domain Splitting ProblemFind a splitting spline curvec(u),u∈[0,1], of the domainΩsuch that it has few control points and it splitsΩinto two new simply connected domains with reasonably good shapes.In Problems 1 and 2, a curve with “good shape” would stay far away from intersecting itself or the domain boundary, and would also be quite regular. Thus the measurement of the quality of shape is based on a combination of penalty functions, which we define in Section  4.We solve this problem using the algorithm outlined in the next section.Consider the domainΩand the domain splitting problem stated in Section  2.2. Our algorithm for numerically solving this problem is outlined below.Curve initialization. First, we construct a splitting piecewise-linear curveγ(u)ofΩ, i.e., a curve that fulfils Conditions (C1-3). Additionally, it is useful to require the curve to satisfy that (a tighter condition than Condition (C2)): the distance from any one point on the curve to a point on the domain boundary is bounded from below by a given tolerance, except at the two ending segments where the curve meets the domain boundary. The splitting curve is not yet required to satisfy the geometric criterion that it should subdivideΩinto two new domains with good shapes. The purpose of this step is to provide an initial curve, that is a splitting curve, to more sophisticated procedures in the later step of the algorithm. This step is detailed in Section  3.Curve optimization. Based on the splitting piecewise-linear curve obtained from the last step, we construct a splitting spline curve of higher polynomial degree using a two-stage optimization strategy as follows.•Stage 1: find a splitting piecewise-linear curve that minimizes a penalty function which approaches infinity when the curve tends to violate Conditions (C2-3). We use a suitable refinement of the piecewise-linear curveγ(u)obtained in the last step as the initial curve for the optimization.Stage 2: find a splitting spline curve of degreep≥2that minimizes the mentioned penalty function. A sufficiently refined spline fitting to the curve obtained from Stage 1 is used as the initial curve for the optimization.We note that the optimization of Stage 1 is less expensive than that of Stage 2 as the spline curve under optimization is only of degree 1. Stage 1 helps to provide a good feasible initial solution for the optimization of Stage 2. That is, Stage 1 can result in a curve that is closer to a local minimum than a spline fitting to the initial curve from Step 1. The precise description of this step shall be presented in Section  4. The algorithm outline is illustrated in Fig. 5.We describe our method for constructing a splitting piecewise linear path of the domainΩ. We construct a polygonPinterior toΩand use a Delaunay triangulation and Dijkstra’s algorithm to produce a path.A polygon is computed such that it is contained inΩ, containsAandBand its interior containsA+tαandB+tβfor all sufficiently smallt.(i) Find all the corners and inflection points of∂Ω, and break it up into segments of three types: where the curvature is positive, zero, or negative. Segments of∂Ωwhere the curvature is zero can be copied directly intoP. Segments where the curvature is positive can be discretized as follows: evaluate the segment of the curve at uniformly spaced parameters, and construct a polygonal path between the resulting points. Segments where the curvature is negative can be discretized as follows: evaluate the curve segment and its derivatives at uniformly spaced parameters, then construct a polygonal path such that the path’s endpoints and tangents coincide with the curve segment’s endpoints and tangents, and the path is tangent to the curve at the evaluated points.(ii) RefinePas necessary. Refining in the positively or negatively curved segments simply involves adding more parameter values and recomputing the polygons. The segments with zero curvature do not need to be refined. There are two ways in which refinement can be necessary. The segments containingAorBmay need to be refined, to ensure that the polygon angles aroundAandBcontain the directionsαandβ; refinement may also be required to eliminate self-intersection ofP. If two segments ofPintersect each other, they are both refined. As the boundary∂Ωdoes not intersect itself, a sufficiently (locally) refined polygonPwill not have intersecting non-neighboring edges.Once the polygonPis constructed, we compute a triangulation (we use a constrained Delaunay triangulation). A graphGis formed, whose vertices are (i) midpoints of the edges of the Delaunay triangulation that are not edges ofP; and (ii) the pointsA1=A+t12αandB1=B+t22β, wheret1andt2are chosen small enough thatA1andB1are inside the domain.Two vertices of the graphGhave an edge between them if the line segment between them does not intersect the polygonP. Note that there always exists an edge between two nodes which are in the same triangle of the triangulation. Since∂Ωhas no self-intersections, there must be a sequence of triangles in the triangulation, starting from the triangle containingA1and ending with the triangle containingB1, such that each consecutive pair of triangles in the path shares an edge. Therefore, there must exist a path inGfromA1toB1.Assign to each edge ofGa cost equal to its Euclidean length. Dijkstra’s algorithm (see for example  [10, Section 2.2.2]) finds a path of minimal total cost between two vertices inG, where the total cost of a path is the sum of the costs of all edges in that path. Thus, Dijkstra’s algorithm produces a path of minimal total length fromA1toB1inG. (Before applying Dijkstra’s algorithm, we can remove those edges fromGwhich are too close to the domain boundary and do not containA1orB1. This improves the initial state for the next step of the algorithm, but may in rare circumstances prevent the existence of a path.)The line segments fromAtoA1and fromB1toBare added to form a path fromAtoB. If necessary, self-intersections of the resulting path are eliminated by cutting off the loops. The path is treated as a linear spline with evenly spaced knot points. The initial curve constructed in this way satisfies the condition (C1-3).A splitting spline curve can be obtained as a sufficiently refined spline fitting of a splitting piecewise-linear curve produced by the approach discussed in Section  3. However, the two new domains split from the original domainΩby such a spline curve may not have good shapes. See, for example, Fig. 6. This section will propose an optimization framework which helps to find a splitting spline curve such that the two corresponding split domains have relatively good shapes. The optimization is based on minimization of a penalty function that tends to infinity when the curve tends to violate Conditions (C2-3).We note that using penalty functions is a fundamental method for numerically solving constrained optimization in general  [21], or for particular applications such as for solving discrete HJB equations  [22].In order to represent the constructions of the penalty functions, we shall address each of the treatments of Conditions (C3) and (C2) separately, and formulate the optimization problem afterward.Throughout the remainder of the paper, if there is a continuous functionf(u,v)that has a finite or infinite limit at some point(u0,v0)when(u,v)tends to(u0,v0), we will writef(u0,v0)to mean the limit of the function at the point(u0,v0).In order to treat Condition (C3), we consider the inverse of the squared distance between two pointsc(u)andb(v):(4)Ib(u,v)=1‖c(u)−b(v)‖2,where‖⋅‖denotes the Euclidean norm inR2. The function can be viewed as a penalty function as it penalizes the curvec(u)from intersecting the boundary curveb(v)from the point of view of minimization. This is the curve-to-boundary penalty function. However, because of Condition (C1), the functionIb(u,v)is unbounded in any neighborhood of one of the two corner points(0,0)and(1,1)of the unit square. As a result, the function is not Riemann integrable over the unit square. Even in the sense of improper integrals, the integral of the function over the unit square does not converge either, see Lemma 1(ii). By the following theorem, it is possible to construct a multiplier functionrb(u,v)so that the new functionrb(u,v)Ib(u,v)is Riemann integrable over the unit square and it preserves penalizing properties of the original function.Theorem 1Consider the two spline curvesc(u),0≤u≤1, andb(v),0≤v≤1defined in Section   2.2, withc(0)=b(0)andc(1)=b(1). Assume that1.p≥1,q≥1, recalling thatpandqare spline degrees ofc(u)andb(v)respectively;c+′(0)≠0andc−′(1)≠0.c+′(0)≠β0b+′(0)andc−′(1)≠β1′b−′(1)for allβ0>0andβ1>0.ifc(u)intersectsb(v)only atu=0andu=1, thenÎbis Riemann integrable over the unit square;ÎbequalsCIb, for someC>0, everywhere in[0,1]2except in[u1,u2]×[v1,v2]∪[un−1,un]×[vn−1,vn](whereu1,…,unare the knots ofcandv1,…,vnare the knots ofb);ifc(u)intersectsb(v)at a third point(u∗,v∗), i.e.,0<u∗<1, then∬[0,1]2Îb(u,v)dudv=+∞.We present the proof for the theorem in Appendix A. The multiplier function has the following form(6)rb=w0α0f0+wτατ1[0,1]2+w1α1f1,whereα0,ατ, andα1are some positive constants;w0,wτ, andw1are piecewise rational functions given by (A.9) that only depend on the knot vectorsUandV;f0andf1are polynomials given by (A.5) that are quadratic functions of the coordinates of the control points ofc(u). The function1[0,1]2is the constant 1 function on the domain. The construction depends on the curves having at least one internal knot.Similar to the treatment of Condition (C3) discussed above, we consider the following penalty function which is related to the inverse of the squared distance between two pointsc(u)andc(v)of the splitting curve:(7)J(u,v)=(u−v)2‖c(u)−c(v)‖2.We refer to this function as a curve-to-itself penalty function. It turns out that it is much easier to handle this function compared to the curve-to-boundary penalty function. This will be shown by the following theorem.Theorem 2Letc(u),0≤u≤1, be a spline curve of degreep≥1and associated with a knot vectorUgiven by   (2). Assume thatcfulfils Condition  (C-2). Then we have the following conclusions.(i)J(u,v)is continuous over[0,1]2if and only ifcis differentiable over[0,1].J(u,v)is Riemann integrable over[0,1]2(even ifcis not differentiable).Ifcviolates Condition  (C-2)/(i)  or  (C-2)/(ii), and all zeros ofc′are isolated, then∬[0,1]2J(u,v)dudv=+∞.The proof is provided in Appendix B.The uses of the penalty functions can be summarized in the following optimization formulation.(8a)minimizec1,…,cmωeωe0∫01‖r″(u)‖2du+∬[0,1]2(ωbÎb(u,v)+ωbÎb˜(u,v)+ωcJ(u,v))dudv(8b)such thatc(0)=A,c(1)=B(8c)det[c′(0),α]=0,det[c′(1),β]=0(8d){c(u),0<u<1}⊂int(Ω).The first term in (8a) is related to one of the standard regularity conditions for a curve. The curver(u)is chosen as follows: ifp>1,r(u)≡c(u); ifp=1,r(u)is a quadratic spline curve with a uniform and open knot vector where its control points are inherited from those ofc(u). The indirect imposition of regularization oncwhenp=1is related to the two-stage optimization introduced in Section  2.3. This is to make Stage 1 capable of providing a better initial solution to Stage 2.In Eqs. (8),ωeis the weighting parameter associated with the regularity term. We useωe0>0as a reference value forωe. In this work, we defineωe0asmax(ε,∫01‖r0″(u)‖2)whereε=10−6, andr0is the initial value ofrin the optimization. The coefficientωbis the weighting for the penalty function of the curve to the boundary, andωcis the weighting for the penalty function of the curve to itself. The linear constraints (8b) and (8c) are to make sure the resulting curve satisfies Condition (C1).We note that if the domain boundary consists of more than two spline curves, the extension is straightforward (as long as the domain is still simply connected), as several spline curves can be converted into a single spline curve. However, in order to lessen the effect of the discrepancy between the speed of different parametrized boundary curves, we use a weighted average where we weight the integral with respect to each boundary curve according to its length. More sophisticated approaches can be employed, such as reparameterizing the combined single curve into a unit-speed curve, however we observe that the averaging according to curve lengths can produce sufficiently satisfactory results in practice.Numerical approaches for solving the optimization problem (8) shall be addressed in Section  5.1. Our approach to computing the penalty functions depends on methods presented in Appendix C.We apply standard nonlinear optimization methods to compute a B-spline curve of degree 2 or more solving Eq. (8). It is necessary to find a feasible solution to use as an initial point. Our approach is to choose as an initial control polygon a solution of Eq. (8) among a space of linear B-splines.Our approach to solving Eq. (8) can be summarized as follows:•Use a pathfinding algorithm to choose a knot vector and initial curve for the first optimization stage (Section  3).First optimization stage: solve Eq. (8) in the space of linear splines with the given knot vector.Second optimization stage: solve Eq. (8) in the space of splines with desired degree and the given knot vector. To choose the initial spline, we treat the solution of the previous optimization stage as a control polygon. To ensure that the initial spline satisfies the conditions, we detect polynomial pieces of the spline where the conditions fail, and refine those pieces by adding control points along the corresponding segments of the control polygon.The requirement that the initial curve for the first stage is a splitting curve ensures the stability of the optimization. Since this initial curve has uniformly spaced knots, the result forp=1should be a control polygon with edges of approximately equal length. This enables the spline approximation withp=2in the second stage to have speed that is not far from uniform.In order to solve the optimization problem (8), we have used the following numerical optimization approaches.•Gradient descent. We use a backtracking inexact line-search (see  [21, Chapter 3]) where, in addition to the Armijo condition, we check if a point is visible. This approach works stably but is rather slow.Broyden–Fletcher–Goldfarb–Shanno (BFGS)-based quasi-Newton method. (See  [21, Chapter 8].) This method often has faster convergence. Again, apart from checking if a point satisfies the Wolfe condition, we have to check the feasibility of the point.For the examples below, we use Gauss quadrature to compute the penalty functions. In each dimension we use 10 Gaussian points distributed along each knot interval. In this way we obtain high accuracy so that the quadrature error does not influence the resulting curves. We have not studied whether it suffices to use less Gaussian points. The values of the B-spline basis functions at the Gaussian points are precomputed to reduce the computation time.In order to make the optimization problem (8) invariant to scaling, the following coefficients have to be defined: (i) the coefficient for the curve-to-boundary penalty function, (ii) the coefficient for the curve-to-itself penalty function, and (iii) the reference energy for the regularity term. Thanks to the way the penalty functions are defined, varying the coefficients has a predictable effect on every shape. This is demonstrated in Figs. 7 and 8where we show that varying the coefficient for the curve-to-boundary penalty affects the distance of the curve to the boundary in a similar way in 4 different examples. We also find out that the weighting parameters (30, 0.1, 1) can produce good results.In Fig. 9, we show other examples of the maze-shaped domains. This, in turn, shows the robustness of our approach.In order to demonstrate the current work’s connection to the segmentation problem, we show in Fig. 10a decomposition of a mechanical part into topological hexahedra. The mechanical part and the cutting loops used for the segmentations are intentionally made complicated so that the example can best show the connection and the robustness of our approach.The results of this paper form an important step in the segmentation of a boundary represented solid into topological hexahedra. The segmentation procedure described in  [2,3] requires the construction of auxiliary edges which are used as part of a cutting loop to segment a solid into two pieces. Geometric conditions on the valid cutting loops can dictate boundary conditions for the new auxiliary edges. This paper provides a construction of edges which can split a face into two pieces while satisfying these boundary conditions. The method has been demonstrated to work even on quite complicated domains. In Fig. 2 we show how our method can help to avoid badly shaped topological hexahedra in a segmentation by comparing the result of our method against an older approach we used.Our method focuses on splitting the (2D) domain of a (3D) trimmed surface. Since a trimmed surface is defined by its domain and an embedding, a splitting of the 2D domain implies a splitting of the 3D surface. As a result, no more constraints are required to ensure that the generated curve lies within the surface. However, for highly distorted surfaces, the distortion could be taken into account in the penalty function to improve the resulting curves. We have not considered this yet.Once a cutting loop has been chosen and its auxiliary edges have been constructed, the next step is the construction of a cutting surface having the given loop as its boundary. This problem can be seen as a higher dimensional version of the problem studied in this paper, and, besides being more computationally expensive, comes with additional difficulties including the choice of an appropriate trimmed domain for the surface. The cutting surface problem is the topic of ongoing work.

@&#CONCLUSIONS@&#
