@&#MAIN-TITLE@&#
Declarative rewriting through circular nonterminal attributes

@&#HIGHLIGHTS@&#
A definition of circular NTAs, together with an evaluation algorithm.The introduction of the notion of computed children in an AST.Mappings between circular NTAs and rewrites, showing they are equivalent.An evaluation of the presented algorithm.

@&#KEYPHRASES@&#
Attribute grammars,Reference attributes,Higher-order,Rewriting,

@&#ABSTRACT@&#
Reference attribute grammars (RAGs) provide a practical declarative means to implement programming language compilers and other tools. RAGs have previously been extended to support nonterminal attributes (also known as higher-order attributes), circular attributes, and context-dependent declarative rewrites of the abstract syntax tree. In this previous work, interdependencies between these extensions are not considered. In this article, we investigate how these extensions can interact, and still be well defined. We introduce a generalized evaluation algorithm that can handle grammars where circular attributes and rewrites are interdependent. To this end, we introduce circular nonterminal attributes, and show how RAG rewrites are equivalent to such attributes.

@&#INTRODUCTION@&#
Reference attribute grammars (RAGs) [1] provide a practical declarative means to implement programming language compilers and other tools. Examples include a full Java compiler [2,3], as well as extensions to aspect-oriented, context-oriented and feature-oriented programming languages [4–6]. RAGs are an extension of Knuth׳s attribute grammars (AGs) [7], and support attributes whose values are references to remote nodes in the abstract syntax tree (AST). Reference attributes allow graphs to be computed declaratively from the AST, which is useful for a variety of purposes in a compiler, for example, the computation of inheritance graphs, control-flow graphs, etc.Over the years, RAGs have been subject to a multitude of extensions. For instance, they have previously been extended to support higher-order attributes[8,2], from here on referred to as nonterminal attributes (NTAs). NTAs allow new nonterminals, i.e., new pieces of syntax tree, to be defined declaratively as attributes, which is useful for reifying implicit structures, for instantiating macro-like constructs, etc. Another extension to RAGs is circular attributes[9–11], that may depend (transitively) on themselves, and which can be computed by fixed-point iteration. Such attributes are useful, for instance, in data-flow analysis [12]. A third RAG extension is attribute-dependent rewrites[13], defining in-place transformations in the AST. This is useful, for example, to normalize or desugar an AST, and in name resolution, where general name nodes computed by a parser can be replaced by more specialized name nodes, e.g., class names or field names [14]. In this previous work, the extensions are considered in isolation, and possible interactions and dependencies between them have not been considered.In this article, we introduce the notion of circular NTAs, and show that such attributes are equivalent to RAG rewrites. In mapping rewrites to circular NTAs we introduce the notion of computed children, which provides a compelling way to explain what RAGs with rewrites mean: An ordinary RAG is a function from an initial AST to an attributed initial AST; A RAG with NTAs is a function from an initial AST to an extended AST that is attributed; A RAG with rewrites is a function from an initial AST to a computed AST that is attributed. An extended AST is here an AST that is the same as the initial AST, but has additional nodes. In contrast, a computed AST does, in principle, not need to share more than the root with the initial AST.While circular NTAs are equivalent to rewrites, the rewrite syntax is still preferable in a practical system. We introduce a new algorithm for evaluating rewrites that is based on translating them to circular NTAs. This algorithm is general and automatically handles interactions with ordinary circular attributes. The old rewrite algorithm is more complex and would have needed to be further extended to support interactions with ordinary circular attributes.We have implemented the new algorithm for two small programming languages, and compared it to the JastAdd system [15], which is a metacompilation system based on RAGs, and which supports nonterminal attributes, circular attributes and rewrites. To evaluate the new algorithm, we have performed a number of experiments, comparing it to the JastAdd rewrite algorithm, indicating that the new algorithm gives acceptable performance on rewrite-intense test programs and sometimes better performance on more realistic programs. The contributions of this article are as follows:•A definition of circular NTAs, together with an evaluation algorithm.The introduction of the notion of computed children in an AST.Mappings between circular NTAs and rewrites, showing they are equivalent.An evaluation of the presented algorithm.The rest of this article is structured as follows: Section 2 walks through the preliminaries of this article, describing different attribute grammar mechanisms. Section 3 gives a motivating example, explaining how circular attributes and rewrites are similar, and how they can interact. Section 4 presents the new notion of circular NTAs, and an evaluation algorithm for them. Section 5 shows that circular NTAs and rewrites are equivalent, by presenting mappings between them. Section 6 evaluates the new algorithm experimentally. Section 7 discusses related work and Section 8 concludes the article.This article is an extended and revised version of our paper published at SLE 2013 [16]. In addition to revisions throughout the article, we include an improved motivating example, an extended background section with a new improved running example, and extensions of the evaluation and of comparison to related work.Attribute grammars (AGs), introduced by Knuth [7], provide a means to compute context-sensitive information for context-free grammars. The information is defined by an equation system over a set of variables called attributes, where the attributes and equations are associated with the nonterminals and productions of the grammar. An attribute is defined by an equation (on the left-hand side), using an expression over other attributes (on the right-hand side). This expression is called the semantic function of the attribute. Each attribute and equation belongs to a specific node that we call its host.In this section, we describe AGs and different extensions of them; reference attributes, circular attributes, nonterminal attributes, and rewrites. For the examples, we use the syntax and the algorithms provided by the JastAdd system [15].11JastAdd syntax is based on Java. We use a slightly simplified syntax here, avoiding getters and many parentheses.An attribute grammar is an extension of a concrete or an abstract grammar. Reference attribute grammars use an EBNF abstract grammar that is formulated as an object-oriented model. Instead of nonterminals and productions, types and subtypes are used. As an example, consider the following abstract grammar for statements and expressions:Stmt and Exp correspond to nonterminals, but are here modeled as abstract types. IfStmt, Assign, and Compound correspond to productions, but are here modeled as subtypes of Stmt. Children can be named. For example, IfStmt has a child cond of type Exp, a child thenpart of type Stmt, and an optional child elsepart of type Stmt (optional indicated by square brackets). The<id:String>is a terminal named id of type String. Lists of children are indicated by the Kleene star, as ins:Stmt⁎.The object-oriented abstract grammar is not restricted to the two levels of types that nonterminals and productions correspond to. For example, it is possible to define a subtype SpecialAssign as follows:The type SpecialAssign will inherit all children of its supertype Assign, similar to in object-oriented programming.AGs, as introduced by Knuth, support synthesized and inherited attributes. A synthesized attribute hosted by a node n is defined by an equation also hosted by n, while an inherited attribute is defined by an equation hosted by the parent of n. An equation can access the attributes of its host node, as well as the attributes of children of the host node. This way, synthesized attributes can be used for propagating information upwards in an AST, whereas inherited attributes can be used for propagating information downwards.Fig. 1shows a simple example of a JastAdd attribute grammar with synthesized and inherited attributes. The grammar defines a node type Root with two children, first and second of the abstract type A. This type A has two subtypes B and C, where B has a token id of type String. A token is seen as an intrinsic attribute, i.e., an attribute whose value is defined during the AST construction, rather than by an equation. The grammar defines an inherited attribute startPos and a synthesized attribute endPos for A nodes, along with equations defining the values of the attributes. An equation has the formHostType.child.inheritedattribute=expfor an inherited attribute, orHostType.synthesizedattribute=expfor a synthesized attribute. For both equations, the right-hand-side expressionexpis evaluated in the context of HostType. For example, on line 10, an equation hosted by Root defines its second A׳s startPos to be equal to its first A׳s endPos. The AST, with attribute instances and their values, is illustrated to the right in the figure.A simple and powerful way to compute the value of an attribute instance a0 is to locate its defining equation and evaluate its right-hand side expression, recursively evaluating any attribute instancesa1...anused when evaluating the expression [17]. The attribute a0 is said to depend ona1⋯an. Note that these dependencies are dynamic: the dependencies themselves may depend on the values of attributes. For example, in an equationa=b?c:d, an instance of a will depend on b and on either c or d, depending on the value of b.This dynamic evaluation technique is used in the JastAdd system. It is called demand evaluation, since only those attributes whose values are demanded are actually evaluated. The attribute values can be cached (memoized) after evaluation, so that a second demand for an attribute value will return the value immediately, rather than evaluating the equation again. This results in optimal evaluation in that each attribute is evaluated at most once. Despite being so simple, the technique is very powerful and can handle many extensions to Knuth׳s attribute grammars, including reference attributes and nonterminal attributes, and it can be extended to support circular attributes and rewrites.Reference AGs (RAGs), introduced by Hedin [1], extend AGs with attributes that have references to other AST nodes as values, so-called reference attributes. The right-hand side of an equation may de-reference such attributes to access other attributes in remote AST nodes. Reference attributes can be used to superimpose graph structures on top of the AST, for example, to link variable use nodes to declaration nodes. They allow for concise solutions to, for instance, name and type analysis for object-oriented languages [14,2].Fig. 2shows an example of an attribute grammar with reference attributes, which we will use as a running example for the rest of this article. The language is a tiny fragment of an object-oriented language where a program consists of a list of class declarations (line 1). A class declaration, D, has a name, and can optionally have a superclass, sup (line 2). The superclass is modeled by a class use node, U which also has a name (line 3). A class use is bound to the appropriate declaration through a synthesized reference attribute, decl (line 5). The value of the decl attribute is defined by using an inherited attribute lookup, taking the class name as an argument (line 6). The lookup attribute is defined by an equation in the program root, whose right-hand side searches through the class declarations and returns the one with the appropriate name, or null if there is no such declaration (lines 7–14). The example illustrates three additional features in JastAdd:•The lookup attribute is parameterized. While an ordinary (non-parameterized) attribute corresponds to a nullary function (i.e., it takes no arguments), a parameterized attribute corresponds to a function with one or more arguments. (The AST and the position of the hosting node are implicit arguments to these functions.) An ordinary attribute thus has a single value, whereas a parameterized attribute has one value for each possible combination of arguments. Note that due to demand evaluation, only the values actually demanded for a particular AST will need to be computed.For practical reasons, JastAdd allows the right-hand side of an equation to be written as a method body that returns a value, instead of as an expression. This is fine as long as the body is pure, i.e., it does not result in any visible side-effects. There are techniques for inferring purity in object-oriented languages [18], but this is currently not implemented in the JastAdd system.The equation for an inherited attribute applies not only to the specified child, D, but to its complete subtree, for all nodes that declare the attribute. This way, the equation holds for the lookup attribute of the U node, and no so-called copy attributes are needed to propagate the value down to the U node. We say that the value is broadcast throughout the subtree [15]. Note that an equation for an inherited attribute applies only to the nodes in the subtree that actually declare the attribute. Therefore, it is only the U node in Fig. 2 that has a lookup attribute. The D nodes do not declare the lookup attribute.Note that the reference attributes superimpose a graph structure on top of the AST. Together with the child edges, cyclic graphs can be formed, but this does not imply that the attribute dependencies are cyclic. This is illustrated in Fig. 3where classes A and B are defined as subclasses of each other, resulting in a cyclic graph. The dependencies for computing the attributes are nevertheless acyclic, and the demand-driven recursive evaluation algorithm works directly for both reference and parameterized attributes. In this particular case, the cyclic graph was used for representing an ill-formed program (corresponding to a compile-time error), but there are many examples of when cyclic graphs are useful in well-formed programs, for example, to represent control flow graphs or recursive data types.Higher-order AGs, introduced by Vogt et al. [8], extend AGs with nonterminal attributes (NTAs), i.e., attributes for which the equation right-hand side uses tree constructors to compute a fresh sub-AST, rooted by a given nonterminal. An NTA is both a child and an attribute at the same time, and may itself have attributes, hence the term higher-order.The NTAs thus extend the initial AST (that was typically built by a parser) with additional nodes, and we refer to the resulting AST as the extended AST.While an ordinary (non-NTA) AG can be viewed as a function from an initial AST to an attributed initial AST, an AG with NTAs can be viewed as a function from an initial AST to an attributed extended AST.NTAs thus make it possible to let the attribution decide parts of the AST structure, which otherwise would be decided entirely during the construction of the initial AST. NTAs can, for example, be used to de-sugar language constructs by constructing an alternative representation of a part of the AST. Like any attribute, an NTA is hosted by a node type of the grammar and each node of that type will host its own instance of the NTA.Unlike other attributes, the value of an NTA is in itself attributable, and inherited attributes are evaluated in the context of the node hosting the NTA. That is, the hosting node becomes the parent of the NTA, and must provide equations defining the inherited attributes of the NTA. Because of broadcasting, there is often already a suitable equation further up in the AST, and if not, the host can provide an appropriate equation, overriding any broadcasting equation higher up in the AST. The demand-driven recursive evaluation algorithm works directly for NTAs.Fig. 4shows a simple example of an NTA used for reifying undefined class declarations. A D node, undef, is added to the program root using an NTA, and is used instead of null by the lookup equation. This way, uses of undefined class names will be bound to the undef node, as illustrated in the figure.Circular attributes, that depend (transitively) on themselves, are useful for describing many problems, for example, dataflow [9,12]. Circular attributes are well-defined as the least fixed-point solution to their equations, if their semantic functions are monotonic and yield values over a lattice of bounded height [19,9]. Farrow describes how an evaluator can compute a fixed-point by successive approximation of attribute values [9], as shown in Fig. 5. The algorithm solves the equationX=F(X)by starting from the bottom value (⊥) and then iterating until a fixed-point is reached. That is,X=⊥∪F(⊥)∪F(F(⊥))∪⋯Fl(⊥)⋯untilFl(⊥)=Fl+1(⊥), where ∪is monotonic on the domain and co-domain of F.To support circular attributes in RAGs, the recursive demand-driven evaluation is extended to do fixed-point iteration, as described by Magnusson and Hedin [11] and shown in Fig. 6. When the value of a circular attribute instance is demanded, there are three different cases: Case 1 covers the case when the attribute instance is accessed from “outside”, i.e., from an attribute not involved in any cyclic evaluation. This part of the algorithm contains the loop that drives the fixed-point iteration. Cases 2 and 3 cover cases when a circular attribute is accessed from “inside”, i.e., when a circular evaluation is already ongoing. Case 2 computes the next value in the iteration for the attribute. Case 3 covers the case when the computation of the next value is already ongoing, in which case the function immediately returns the current value. A global flag, IN_CIRCLE, keeps track of if any cyclic evaluation is ongoing. Fig. 7illustrates the evaluation stack for the example used in Fig. 6. The right arrows (→) in Fig. 7 indicate that a value was updated and that the global variable change became true. For each evaluation round, one or more arrows at some stage starts a new round. For example, in the third round there is an arrow at the second stage and this causes a fourth iteration.Fig. 8shows a simple example of how to define a circular attribute in JastAdd. The attribute onCycle computes whether a class declaration is on a cyclic class hierarchy or not. For this attribute, the boolean values are regarded as being on a simple lattice with true at the bottom and false at the top.Rewritable RAGs, introduced by Ekman and Hedin [13], extend RAGs with attribute-dependent declarative transformations of the AST, called rewrites. Rewrite rules are defined on node types and define a node replacement, possibly conditionally. Both the computation of the new node and the conditions may depend on attribute values.An example use of rewrites is in name resolution [14]: the general name access nodes created by a parser can be replaced by more specific nodes, like field accesses or local variable accesses, depending on attribute values.Rewrites are declarative in that a finally rewritten AST has no applicable rewrite rules, i.e., all the rewrite conditions will be false. To compute this final AST, the rewrite rules are applied repeatedly until no more rules are applicable. This is in essence a fixed-point computation, and it is required that the rewrite rules are written in such a way that this computation terminates and is confluent, i.e., the order of applying any set of applicable rewrite rules is irrelevant. Since rewrite rules depend on attribute values, and attribute values depend on children that might need to be rewritten, the attribute evaluator intertwines rewriting with attribute evaluation, until no applicable rewrites remain.Fig. 9shows an example, where a new node type (WD) is introduced, representing a well-formed class declaration. A rewrite rule replaces an ordinary class declaration by a WD node if it is not already replaced (specialized) and if it is not on a cyclic class hierarchy (onCycle).A RAG with rewrites can be viewed as a function from an initial AST to an attributed rewritten AST. The rewritten AST has the same root node as the initial AST, but can otherwise in principle be completely different from the initial AST. In practice, however, rewrites are used for rather small adaptations of the AST, like the specialization in Fig. 9.Like RAG attributes, rewrites are evaluated on demand, and with the use of a recursive evaluation strategy. When a node is accessed for the first time (through its parent), the rewrite rules for the node are applied repeatedly until there are no more applicable rewrites, i.e., the node is in its final state. Thus, the client accessing the child never sees the initial or any intermediate states, but only the final state of the node in the rewritten AST. The root node itself is not allowed to have any rewrite rules. Initially, the root of the AST is final, and as the AST is traversed, this final region is expanded from parent to child. For instance, after building the initial AST in Fig. 9, suppose we access first the root node, and then its child. The child will then be rewritten, and a reference to the final WD node is returned.The evaluation of rewrites, shown as the child access method ASTNode.GetChild in Fig. 10,22ASTNode is a supertype of all node types.starts with a check of the current state of the child to be accessed. If the child is null, if it is already in the final state, or if it has no rewrite rules, its current value is returned immediately without any further evaluation. Alternatively, the rewrite evaluation continues. Beyond this initial part, the ASTNode.GetChild method handles two cases: Case 1 covers the case when the node is accessed for the first time, in which case a loop is entered which drives the evaluation of the rewrite. Case 2 covers the case when the node is already in the process of being rewritten, but accessed again, in which case the current value is returned.Case 1 contains a driver loop, similar to the first case for circular attributes in Fig. 6. A difference is that each rewritten node is driven by its own driver loop, which is kept track of using the boolean field InCircle in the node. Another difference is that the change check is not done by comparing values, but instead using a boolean flag that is set in the beginning of each iteration (Change), and reset (to NoChange) by the RewriteTo method, in case no when clause applies. These flags are pushed on a stack (stack), so that nested rewrites of different nodes each have their own flag.Attributes are evaluated during rewriting in order to compute the guarding rewrite conditions and to compute the resulting tree of a rewrite. It may thus happen that a particular attribute is evaluated using attributes of nodes that are not yet final. In this case, the attribute value is not cached (memoized), since that value might become inconsistent at a later point in time, when the AST has been rewritten. If the attribute is accessed again at a later time, it will be reevaluated, since there is no cached value, again possibly aborting its caching. To keep track of if an attribute can be cached or not, requires additional bookkeeping not shown in Fig. 10, see [13] for details.In the previous section, we walked through the evaluation of attribute grammars with focus on two extensions: circular attributes and rewrites. The evaluation mechanisms of these extensions are similar; both use a loop to drive the evaluation until there is no change, both base their evaluation on some initial value, and both mechanisms may create intermediate values on their way to a final value. That is, if a circular attribute is accessed, entering Case 2 or Case 3, a potentially intermediate value is returned, and the same goes for rewrites, entering Case 2. The presented evaluation mechanisms handle circular attributes and rewrites in isolation from each other, i.e., assuming there are no interdependencies between them.As an example of such an interdependency, consider the grammar specified in Fig. 11. Here, a class use, U, is rewritten to a specialized node type, CircU, if it is in the extends clause of the same class declaration, D, that it refers to, e.g.,In this example, the U node is a child of a D node. The rewrite rule uses the attribute extendsD of the D node, which in turn is dependent on the rewrite since it accesses the child through u. Thus, there is a circular dependency between the attribute extendsD and the child u, as shown in the figure. The figure also shows that the value of u depends on itself, since a node is rewritten until no more rewrite rules for it apply. The values in the figure are the expected final values, that is, we expect the attribute to receive the value true, and the child to be rewritten to a node of type CircU.In just using the algorithms from Section 2, the interdependencies are not accounted for, and if the evaluation starts with the extendsD attribute, the final value of the child becomes U rather than CircU, i.e., the rewrite terminates too soon. Fig. 12illustrates the evaluation stack for the example, showing how the initial access of the circular attribute enters circular Case 1, and how the first child access enters rewrite Case 1. In both these cases, a loop is started to drive the evaluation. The first iteration of the rewrite driver loop results in an access of the circular attribute, and this access becomes the second access of the circular attribute. At this point, the circular attribute is already driving its own evaluation (Case 1), hence it enters Case 3 and returns its current value. This current value is the bottom value of the circular attribute (false), and with this value the when clause of the rewrite becomes false. With only false when clauses, NoChange is pushed on to the rewrite stack (stack), causing the rewrite evaluation to terminate.Interdependencies, like the above, can either be disallowed or handled. Using the global evaluation state (in_circle, stack) presented in Section 2, a runtime exception can be thrown if a circular attribute instance uses a rewrite, or vice versa.In this paper, we instead present a generalization, based on a unification of the two mechanisms. We do this by introducing the notion of circular NTAs (Section 4), of which rewrites can be seen as a special form (Section 5). This unification allows us to account for interdependencies, while using a simpler algorithm with fewer conceptual entities. It also allows us to cache more attribute values during rewrites (i.e., during the evaluation of circular NTAs), resulting in better performance.In this section, we introduce circular NTAs (CNTAs), and show how these can be used to compute the attribute values described in Section 3.As for ordinary circular attributes, we require that circular NTAs take their values from a lattice of bounded height, that the semantic function is monotonic, and that a bottom value is provided as the starting point of the fixed-point iteration. Consider the following circular NTA:Here, the HostType node is an implicit argument of the semantic function, and via this node, other attributes can be accessed from within the semantic function. The semantic function should be side-effect free, and return a fresh subtree rooted by a node of type ReturnType.The value of a circular NTA is an AST value, an unattributed subtree defined as follows:Definition 1An AST value v is either null, or an AST node, where an AST node is a tuple<Type,Tokens,Children>, where Type is an AST node type, Tokens is a list of zero or more tokens, and Children is a list of zero or more AST values. Two AST values are equal if they are both null, or if their types, tokens and children are equal.Additionally, an AST node has a reference to its parent, unless it is a root node. However, the parent reference is not seen as part of the value, but instead as a computed value that refers back to the node of which it is a child, i.e., satisfying the following child–parent invariant:n.child(i).parent==n. As an NTA is seen as a child of its host node, the host node will be its parent. The attributes of an NTA are not seen as part of its value, as they are computed values, depending on the context of the NTA.There are many ways in which the AST values can be viewed as on a lattice of bounded height. One simple way is to consider all values with the same type to be incomparable, and to order the types. In a circular evaluation, an AST value can then be replaced by another AST value of a higher type, but not by an AST value of the same type. Another way would be to consider AST values with the same type as comparable, and to place an ordering on the children, for example, based on the types of the children. Since the number of types is bounded in any given RAG, this allows lattices of bounded height to be defined.

@&#CONCLUSIONS@&#
We have investigated the interplay between circular attributes and rewrites, and introduced a generalized evaluation algorithm that can handle grammars with interdependent circular attributes and rewrites. To this end, we have introduced circular NTAs, and shown how rewrites can be mapped to these attributes. The mapping uses the notion of computed children which provides a compelling explanation of attribute grammars with rewrites, namely as a complex function from an initial AST to a computed AST with attributes.To evaluate the new algorithm, we have implemented it for two small languages, and run evaluations both using artificial generated programs and more realistic programs projected from well-known Java programs to one of the small languages.Our results show that the new algorithm, while being more general, can reduce the number of attribute computations. In our experiments, we found that the computations may be reduced but the over head of the algorithm may cause it to not reduce execution time. For a full compiler like the JastAdd extensible Java compiler, there may be a gain with the new algorithm when not relying on hand-tuned caching, provided the algorithm implementation is optimized to correlate better with the number of computations. To investigate this, we plan to extend the JastAdd metacompiler with an automatic mapping from rewrites to the circular NTA implementation and further investigate possible optimization of the algorithm.