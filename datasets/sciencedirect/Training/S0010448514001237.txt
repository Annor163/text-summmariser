@&#MAIN-TITLE@&#
Interactive rendering of NURBS surfaces

@&#HIGHLIGHTS@&#
RPNS, a new pipeline for the efficient rendering of NURBS surfaces, is presented.It is based on a non-recursive evaluation of a NURBS surface’s basis function on GPU.Different GPU implementations of RPNS are proposed on DirectX11.A comparison with an approach based on NURBS–Bézier conversion on CPU is carried out.RPNS achieves real-time frame rates even when the models are interactively deformed.

@&#KEYPHRASES@&#
NURBS surface,Rendering pipeline,Interactive rendering,

@&#ABSTRACT@&#
NURBS (Non-uniform rational B-splines) surfaces are one of the most useful primitives employed for high quality modeling in CAD/CAM tools and graphics software. Since direct evaluation of NURBS surfaces on the GPU is a highly complex task, the usual approach for rendering NURBS is to perform the conversion into Bézier surfaces on the CPU, and then evaluate and tessellate them on the GPU. In this paper we present a new proposal for rendering NURBS surfaces directly on the GPU in order to achieve interactive and real-time rendering. Our proposal, Rendering Pipeline for NURBS Surfaces (RPNS), is based on a new primitive KSQuad that uses a regular and flexible processing of NURBS surfaces, while maintaining their main geometric properties to achieve real-time rendering. RPNS performs an efficient adaptive discretization to fine tune the density of primitives needed to avoid cracks and holes in the final image, applying an efficient non-recursive evaluation of the basis function on the GPU. An implementation of RPNS using current GPUs is presented, achieving real-time rendering rates of complex parametric models. Our experimental tests show a performance several orders of magnitude higher than traditional approximations based on NURBS to Bézier conversion.

@&#INTRODUCTION@&#
NURBS (Non-uniform rationalB-splines) surfaces  [1] have been widely employed in CAD/CAM tools and graphics applications due to their capabilities for modeling complex geometries. In addition to the high quality of NURBS models, another advantage of the NURBS representations is the compactness of the description and, in consequence, the low storage and transmission requirements. Furthermore, graphic designers can produce models and animations in a simpler and faster way because they have to control fewer points than for triangle meshes. On the other hand, NURBS are easily scalable representations, so a surface can be converted into a triangle mesh with few triangles or with many triangles according to the required level of detail (LOD).In order to render NURBS surfaces on the current GPUs, these surfaces are commonly decomposed into a series of Bézier patches by the well-known technique called knot refinement  [1], since they cannot be directly rendered by the GPU, as we will prove. Such an approach using Bézier surfaces suffers from long preprocessing time as well as the potential introduction of artifacts, especially at the surface boundaries  [2]. Besides, since the complete decomposition into a set of Bézier patches needs to be executed every frame for each NURBS surface with this approach, interactive rendering rates are not possible when a NURBS surface is continuously deforming or transforming  [3,4]. Therefore, Bézier surfaces are not a good replacement for NURBS surfaces in fields such as modeling, virtual reality or animation.In the literature, recent proposals achieve real-time rendering by tessellating parametric surfaces directly on the GPU  [5–8]. In these proposals the rendering process is performed per patch  [5,7] or per set of patches according to the required level of detail  [6]. In this approach the computational cost increases with the number of patches due to the amount of synchronous calls between CPU and GPU.  [8] renders pixel-accurate Bézier surfaces using the tessellation unit of modern GPUs. Since the tessellation units added to the current GPUs do not provide a high enough level of tessellation to generate continuous surfaces with no holes from a NURBS surface. Another tessellation approach is presented in  [9] where the tessellation of bi-cubic Bézier surfaces is performed following a GPGPU strategy (General-Purpose Computation on GPU) using CUDA.A different approach to tessellate parametric surfaces is the dicing of these surfaces on micropolygons, small quadrilaterals each less than one pixel in size. The starting point of this approach is the Reyes rendering system  [10], based on the development of a new and different pipeline. Although, Reyes rendering performance is far from meeting real-time requirements, different characteristics of this pipeline have been ported to GPUs  [11]. Other proposals based on the modification of the GPU pipeline to implement micropolygon rendering are found in  [12].All these proposals above cannot handle deforming NURBS surfaces interactively, due to the high computational cost of the transformation of a NURBS surface to Bézier patches has to be performed repeatedly in every frame as the surface is deforming.In  [13] non-uniformB-splines surfaces are tessellated on the CPU and then evaluated on the GPU to obtain positions and normal vectors. This alternative needs to use multiple fragment programs for the different surface degrees. In  [14,4] a rendering of NURBS surfaces was proposed for GPUs which only operate on existing data, since this approach is prior to the introduction of the geometry shader  [15], the first shader that allowed the generation and destruction of geometry data on the GPU. In that approach, the CPU creates a set of grids that indicates the evaluation points for the different levels of detail, and these data are sent to the GPU and stored as textures. A fragment program computes the basis functions with a “ping–pong” technique which alternates between two textures. That is,p×qpasses are needed for a NURBS surface of degree(p,q); for example, a bi-cubic surface point is evaluated in 16 passes. A second step multiplies these basis function values by the control points to get the surface point evaluation. Then, the resulting data are reduced in order to calculate the positions using a different fragment program. Finally, the connectivity of the points is generated on the CPU using the grid computed according to a selected level of detail. Therefore, these approaches perform a previous tessellation on the CPU.In this paper we present RPNS, Rendering pipeline for NURBS Surface, a novel solution for the direct evaluation of NURBS surfaces on the GPU without any previous decomposition to Bézier surfaces. The objective is the efficient and interactive rendering of each surface so that the final image has no cracks or holes, neither inside each surface nor between neighboring surfaces, making it possible to exploit the parallelism of the GPU to perform common operations such as sketching on surfaces or interactive rendering of deforming surfaces  [16,17]. A new primitive, KSQuad, based on the regions defined by the projection on the parametric cell delimited by the different knot spans is proposed. This primitive does not need a preprocessing stage and intrinsically maintains the main geometric properties of NURBS surfaces, such as local support and strong convex hull.In short, by means of the KSQuad primitive RPNS exploits the main features of NURBS surfaces to accomplish its real time evaluation and direct display, rivaling in quality and performance with approaches based on the REYES pipeline. Moreover, whereas other similar approaches really compute the basis functions previously on the CPU  [4], RPNS goes one step forward and evaluates in real-time the whole NURBS equation in the GPU without any precomputation on the CPU. To test our proposal, and although this paper mainly focuses on algorithmic improvements to the rendering pipeline, rather than an optimized implementation, we have implemented it to measure its performance on current GPUs, achieving interactive and real-time rendering.The rest of the paper is organized as follows: Section  2 presents KSQuad, the primitive our pipeline is based on, Section  3 introduces RPNS and Section  4 describes its implementation in DirectX11. Finally, Section  5 shows the experimental results obtained in our tests and the main conclusions are highlighted in Section  6.In this section, we present a new primitive called KSQuad that allows a regular, flexible, efficient and interactive rendering of NURBS surfaces.A NURBS surface is obtained as the tensor product of two NURBS curves, parametric curves that are a generalization of Bézier curves and are defined by its degree, a set of weighted control points, and a knot vector. Thus, using two independent parametersuandv, the NURBS surface of degree(p,q), respectively in both parametric directions, is given by the equation:S(u,v)=∑i=0n∑j=0mNi,p(u)Nj,q(v)wi,jBi,j∑i=0n∑j=0mNi,p(u)Nj,q(v)wi,j,0≤u,v≤1whereBi,jare the control points,wi,jare the weights,n+1andm+1are the number of control points inuandvparametric directions, respectively, andNi,pandNj,qare the nonrationalB-spline basis function defined on two knot vectors ofr=p+n+1ands=q+m+1elements, respectively:U=[0,…,0︸p+1,xp+1,…,xr−p−1,1,…,1︸p+1]V=[0,…,0︸q+1,yq+1,…,ys−q−1,1,…,1︸q+1].The basis functionNi,pof degreepis defined for the parametric directionuas(1)Ni,p(u)=u−xixi+p−xiNi,p−1(u)+xi+p+1−uxi+p+1−xi+1Ni+1,p−1(u)withNi,0(u)={1ifxi≤u<xi+10otherwise .Analogously, the basis functionNj,pof degreeqis defined for the parametric directionv.The knot vectors are non-decreasing sequences of real numbers that make a partition on the parametric domain. This partition defines the relation between different ranges of the parametric coordinates, known as knot spans or knot intervals, with the control points. Since basis functions are non-zero only in part of the domain, the functionsNi,p−1andNi+1,p−1, used for the computation ofNi,p, are non-zero forpknot spans, overlapping forp−1knot spans.A NURBS surface can be seen as a grid of cells in parametric space delimited by the different knot spans, with each cell containing a part of the surface computed with the non-zero basis functions in that interval. Thus, we have focused on that idea to propose a suitable input primitive that does not require a previous transformation as the seed of RPNS. This new primitive, Knot Span Quad (KSQuad), represents a half-open interval of the parametric domain,[xi,xi+1)×[yj,yj+1), with non-zero length, and maintains the information ofq×pneighboring knot spans, allowing an efficient evaluation of the NURBS surface in this interval without any recursive computation, which makes it suitable for GPU implementation. It is important to emphasize that our proposal does not decompose the NURBS surface in any moment. Each position of the surface is directly evaluated on the NURBS surface.AKSQuadi,jof degreeqandpis defined likeKSQuadi,j={xi,xi+1,yj,yj+1︷knot span,Bi−p,j−q,…,Bi,j︸control points,wi−p,j−q,…,wi,j︷weights}beingxi≠xi+1andyj≠yj+1.EachKSQuadi,jcontrols a subset of the parametric domain, defined by the rectangle parametric sub-domain with corners(xk,yl),k∈{i,i+1},l∈{j,j+1}, as illustrated in Fig. 1.A KSQuad preserves the many desirable geometric properties presented in NURBS curves and surfaces (properties that can be found in  [1]), such as:•Strong convex hull: a NURBS surface is contained in the convex hull of its control points. Moreover, if(u,v)is in the parametric rectangle defined by the knot spans[xi,xi+1)×[yj,yj+1), thenS(u,v)is in the convex hull defined by the control pointsBi−p,j−q,…,Bi,j. This property assumes that all the weights in the NURBS surfaces are positive values, and it allows us to propose efficient culling methods on RPNS.Local support:Ni,p(u)⋅Nj,q(v)=0if(u,v)is outside the rectangle[xi,xi+p+1)×[yj,yj+q+1). Therefore, the influence of an individual control point over the surface is delimited to this parametric interval for each parametric direction. This feature is really interesting in our context, since it makes it possible both to reduce the computational cost of basis functions and to improve data locality. The latter is achieved as only(p+1)×(q+1)control points are used to evaluate every point in a given KSQuad, avoiding unnecessary accesses to the whole NURBS surface. Furthermore, the exploitation of the spatial coherence makes it possible that the data calculated for a given point into a cell may be reused for the rest of the points in the same cell. This saves both memory accesses and computations.The number of KSQuad primitives generated for each surface is variable, but limited to(r−2p)×(s−2q):whererandsare the number of knots for each parametric direction, respectively.The main advantages of our KSQuad-based proposals when compared with the traditional decomposition of NURBS into rational Bézier patches are highlighted in this section.NURBS surfaces are commonly decomposed into a series of rational Bézier patches by the well-known technique called knot refinement  [1], since a NURBS surface can be divided into sections each one corresponding with a knot span in the knot vector. Each section can be mathematically represented as a rational Bézier surface maintaining the original shape. Each knot with multiplicity lower than the degree in each parametric direction has to be replicated in the knot vector until it appearsp-times. The knot insertion algorithm inserts one into, then adds and adjust control points to yield a new description for the same curve or surface. The insertion of each new point depends on the value of the new knot added. Then, the algorithm moves the other control points near the new one to preserve the shape of the surface. Therefore, such an approach using Bézier surfaces suffers from long preprocessing times as well as the introduction of artifacts, especially at the surface boundaries. The resulting rational Bézier surfaces are defined by(2)S(u,v)=∑i=0p∑j=0qJi,p(u)Jj,q(v)wi,jBi,j∑i=0p∑j=0qJi,p(u)Jj,q(v)wi,jbeingBi,jthe control points,wi,jscalar weights andJi,pthepthdegree Bernstein functions.Fig. 2depicts a cubic NURBS curve (Fig. 2(a)) and the decomposition into piecewise Bézier segments (Fig. 2(b)). The Bézier control points of the segments are obtained by insetting each interior knot until it has multiplicityp. In this exampleB0=B0′andB6=B12′, the rest of control points of four Bézier surfaces are inserted or modified in the procedure of conversion.Next, we analyze the two main advantages of the KSQuad primitive over the use of Bézier surfaces: first, the smaller memory requirements, and second, the possibility of achieving interactive deformable NURBS. Table 1shows the main data of the models used in our experimental tests, such as the number of NURBS surfaces and KSQuads of each model, #NS, #KS (these data were obtained according to  [1]). Additionally, this table also makes clear the low memory footprint of our proposal. Thus, beingNURBS#CPthe number of control point of all the NURBS surfaces in the model,Bezier#CPthe number of control points of all the Bézier surfaces once applied a decomposition, andNURBS#MandBezier#Mthe memory requirements for each case in kBytes, respectively; the last column shows how using Bézier decomposition requires significantly more control points and more memory. In the worst case, ten times more memory is used to render the model Killeroo with Bézier surfaces than by using the KSQuad primitive. In short, the memory requirements of our approach are significantly lower than the memory consumed by the naive approach of decomposing the NURBS surfaces into Bézier surfaces.Regarding the possibility of obtaining interactive deformable surfaces, let us remember that NURBS properties are not projected in the new Bézier surfaces resulting from a NURBS-to-Bézier decomposition. For example, when the control points are moved, the level of continuity at the knots can change (increase or decrease). That is, any change in one Bézier point can reduce the continuity fromC1toC0on the edge between surfaces. Moreover, in a Bézier-based modeling process the user is restricted to sketching on tangent planes instead of directly dealing with the NURBS surface, resulting in a lack of flexibility and good response feedback.Our approach achieves interactive deformable NURBS surfaces, maintaining the local support property. Modifications in the shape due to changes ofBi,jorwi,jmeans that the KSQuads affected,{KSQuadi,j,…,KSQuadi+p+1,j+q+1}, access to these new values. For example, let us consider the example of Fig. 2(b), the modification ofB4′implies the modification ofB2′in order to achieve the same continuity inB3′. However, using KSQuads we get a more compact representation of the surface and the modification of a particular control pointB2in Fig. 2(b) only affect the surface regionS(u)withu∈[x2,x2+3+1).The traditional approach to the interactive rendering of deforming NURBS is outlined in Fig. 3(a). The transformation of NURBS surfaces into Bézier surfaces is carried out in the CPU, and these are eventually rendered by the GPU. No additional CPU–GPU data transfer is needed if the surfaces are not modified. However, if interactive deforming operations were applied, new conversions and transfers are required. Our approach (see Fig. 3(b)) needs a unique CPU–GPU communication during a preprocessing stage.The architecture of the rendering pipeline can usually be divided into three conceptual stages: application, geometry and rasterizer. In the application stage the geometry to be rendered is generated by a software application. This results in a stream of primitives that are processed by the geometry stage, that computes what, how and where the things are drawn. Finally, the rasterizer stage renders an image; that is, sets the color for the pixels covered by the different objects in the scene.In this section, our Rendering Pipeline for NURBS Surfaces (RPNS) is described. As it was commented in the previous section, RPNS adds a new primitive, KSQuad, to the input stream of the geometry stage. Furthermore, an intermediate stage, sampler, between the geometry and the rasterizer stages is added, as depicted in Fig. 4. In this stage an adaptive sampling of the KSQuad primitives is performed according to the point of view, the geometric characteristics of the surface and the boundary edges between surfaces. Precisely, the geometry stage precedes the sampling stage in RPNS to use all this data to guide the sampling process, that is carried out by evaluating the KSQuad primitives with no approximation at all. This sampling results in a set of sampled points or dice that we have named KSDice and that makes it possible to render the surface without cracks or holes.The number of KSDice depends on the evaluation of each KSQuad in the geometry stage. Each KSDie consists of a sampled point and additional information such as the parametric size of the die and the degree of the corresponding surface, and it does not save any explicit connectivity information, analogously to the concept of surfels  [18] in the field of point rendering. KSDie is a primitive that can be finally projected to a unique pixel or to a set of pixels.Finally, a new explicit and non-recursive method for the evaluation of the basis function has been developed with the aim of obtaining an efficient GPU implementation. Basis function evaluation is usually one of the main bottlenecks of NURBS evaluation, since these functions have a recursive formulation and they are re-evaluated for each parametric position. Our evaluation strategy is deeply analyzed in Section  3.2.The main purpose of RPNS is the adaptive sampling of KSQuad to obtain the appropriate number of KSDice (samples) that provides a quality render with no holes, yet increasing the performance. As a matter of fact, the use of KSQuad as the input primitive to be sampled already favors this adaptive behavior, since it allows a better exploitation of the local geometric features of the surface. Therefore, it solves an important problem in current GPUs, that cannot obtain enough samples for adequately covering the whole surface by directly using the NURBS surface as the input primitive of the pipeline. Thus, for example, supposing the tessellation of a NURBS surface in triangles, it is better to select a tessellation factor per KSQuad than compute a tessellation considering the whole NURBS surface. This is shown in Fig. 5, where a model, Killeroo, is first rendered using surfaces as input primitives, after applying the maximum tessellation level implemented in current GPUs (Fig. 5(a)), and then KSQuads (Fig. 5(b)). As can be observed, the quality of the final image is much better with KSQuads, even though the number of triangles being used is significantly less: 12016.05 vs. 385.56 K. Fig. 5(a) contains numerous artifacts, such as cracks, holes and creases, since it does not have enough triangles to follow the curvature of the surface. Thus, thirty times more primitives are evaluated but a lower quality rendered model is obtained.A KSDie obtained from a KSQuad is defined asKSDie={(xk,yl),δx,δy,Sp,q,f}where(xk,yl)is the starting parametric coordinate of the range covered by the KSDie, so(xi,yj)≤{(xk,yl),(xk+δx,yl+δy)}<(xi+1,yj+1),Sp,qis a set of indices that provide access to the surface’s data, andfis a 4-bit tag that indicates which edges of the KSDie are boundary edges with another surface.The key to get good performance with RPNS is the number of KSDice that are sampled and rendered. An adaptive sampling that focuses on the geometric features of a surface and the number of pixels to be rendered can provide an important boost in performance with no reduction in image quality. We propose an adaptive sampling procedure that is based on this set of tests:Local area average.The number of pixels in screen space that are covered by a KSQuad from a specific point of view is evaluated. Then, a sampling factorτis chosen and applied in parametric space to get the appropriate number of KSDie primitives from the projected KSQuad, considering a maximum pixel-size for each KSDie ofμ:(3)dist(p(S(xk,yl))−p(S(xm,yn)))/τ<μ,∀k,m∈{i,i+1}andk<m∀l,n∈{j,j+1}andl<nwherep()means a screen space projection, so the distance between the projected corners of the KSQuad is computed.This test measures the difference between the evaluation of the NURBS surface at a point and the position where that point will be rendered if the KSDie is not further subdivided. Therefore, the maximum deviation between the KSDice to be renderedS(u,v)and the ideal projection of the NURBS surfaceS′(u,v)is computed, which provides a measure about the accuracy of the linear approximation applied, that is(4)maxabs(p(S(u,v))−p(S′(u,v)))<ϵ,∀(u,v)∈[xk,yl)×[xk+δx,yl+δy).Since each KSQuad is independently processed in the pipeline, it is necessary to apply a higher sampling in the boundary edges between adjacent NURBS surfaces to prevent discontinuities, especially if there is notG1continuity in the boundary between the two surfaces. This is usually the case when different tessellation factors are applied in these surfaces. In this respect, our first approach was to introduce a test that evaluates whether a KSQuad is in a boundary edge with an adjacent NURBS surface and, if so, forces a higher sampling in the corresponding boundary regions. The information about the boundary edges of a KSQuad is coded in the fieldfduring the creation of the KSQuad in the application stage of the pipeline. Then, to avoid cracks and holes, a boundary edge{S(xk,yl),S(xk+δx,yl+δy)}is oversampled according to:(5)maxabs(p(S(xk,yl))−p(S(xk+δx,yl+δy)))<η.An example is depicted in Fig. 6(b): thick lines mark the boundary edges between surfaces in Fig. 6(a) and Fig. 6(b) shows how the boundary regions have a higher sampling.A better solution to deal with possible discontinuities but avoiding over-tessellation is our second approach to this test, depicted in Fig. 6(c). This new implementation is based on the idea of friend surfaces, which means that two adjacent surfaces are friends if they areG1according to the necessary and sufficient conditions ofG1continuity  [19] between two adjacent NURBS surfaces with arbitrary degree and generally structured knots. In order to guarantee this friend condition, data defining the boundary surfaces (control points, weights and knot span) is analyzed in a preprocessing stage on the CPU but one time only, for subsequent rendering processing. This results in a boundary region test that only applies a higher sampling in the boundary edges of a KSQuad when it is really needed, as can be observed in Fig. 6(c).These tests measure the improvement achieved in image quality with each new KSDie inserted by the sampler stage. As other similar proposals  [12], our tests work with a series of thresholds that must be precomputed for each surface in order to reach the required quality level.Another relevant contribution in this work is a novel approach to the computation of the basis functions of a NURBS surface based on a non-recursive strategy, called stair strategy.Stair strategy provides a straightforward, efficient and general procedure with a simple control flow that makes it suitable to be implemented on current GPUs. Nowadays, NURBS surfaces evaluation on the GPU is usually based on the de Boor algorithm  [4]. Thus, evaluating thepth-degreeB-splines basis function requires the evaluation of theB-spline basis function of orderp−1. In  [4] theB-spline basis function of orderp−1is stored as a texture on the GPU and this intermediate result is used as input for evaluating thepth-degreeB-spline basis function. In  [2,20] several approaches are presented to improve the performance on CPU of the computationally expensive de Boor recursion algorithm by avoiding the recursion. Our stair strategy follows a similar strategy focused on the GPU.The basis function of a NURBS can be calculated in each parametric point by applying the Cox–de Boor recursive expression shown in Eq. (1). As it was commented in Section  2, the local support property of a NURBS surface is preserved in the KSQuad primitive, which means that at mostp+1of theNi,pfunctions are non-zero within a given knot span[xi,xi+1), namely the functions{Ni−p,p,…,Ni,p}. Table 2shows the non-zero basis functions in theith knot span forp=5. Hence, the only non-zeropth-degree functions on this knot span are{Ni−5,5,Ni−4,5,Ni−3,5,Ni−2,5,Ni−1,5,Ni,5}.Our proposal is based on the non-recursive reformulation of theNi−k,pfunctions, replacing the recursion that can be represented by a truncated triangular table  [1] with a simple expression of additions and multiplications. Thus, the triangular table can be represented like a rectangle table with size(p−k)×k. Whereas Cox–de Boor isO(N2)in the basis functions evaluation, the proposed method isO(N)due to the sums for each of the basis functions. Fig. 7shows the rectangle tables forNi−2,5(Fig. 7(a)) and forNi−3,5(Fig. 7(b)). The basis functionsNi−k,pwithk={0,…,p}can only be formulated according to some of theNi,candNi−d,dwithc={1,…,p−k}andd={1,…,k}, that is, a total ofpbasis functions. We designate the basis functionsNi,cas column functions andNi−d,das diagonal functions. Our strategy allows a simple and efficient computation of the column and diagonal basis functions by simply applying the following expressions:Ni,c=(u−xi)c∏l=1c(xi+l−xi)Ni−d,d=(xi+1−u)d∏l=1d(xi+1−xi−l+1).Therefore, the basis functionsNi−k,pwithk={1,…,p−1}are formulated according top−kcolumn functionsNi,candkdiagonal functionsNi−d,d, withc={1,…,k}andd={1,…,p−k}:Ni−k,p=∑j=0k−1(u−xi−k+j)p−k(xi+k−1+j−u)j∏l=1p−k+j(xi+l−xi−k+j)Ni−k+j,k−j+∑j=0p−k−1(xi+p−k+1−j−u)k(u−xi−k)j∏l=0k−1+j(xi+p−k+1−j−xi−l)Ni,p−k−j.The denominator terms are constant for each KSQuad and are computed only once for each shader invocation:Aj=1∏l=1p−k+j(xi+l−xi−k)Bj=1∏l=0k−1+j(xi+p−k+1−j−xi−l).Finally, the ending non-recursive expression for a basis function is:Ni−k,p=∑j=0k−1(u−xi−k+j)p−k(xi+p−1+j−u)jAjNi−k+j,k−j+∑j=0p−k−1(xi+p−k+1+j−u)k(u−xi−k)jBjNi,p−k−j.The Geometry Shader (GS) introduced with DirectX10 was the first stage in the graphics pipeline capable of generating new primitives on the GPU. Although this programmable stage exploits data locality and allows an efficient tessellation on the GPU, it is highly limited by the number of output primitives that can be created for each input primitive, since the maximum size of its output stream is 1024 bytes per invocation.The main limitations of the GS were solved by the introduction of a new configurable stage in DirectX11: the Tessellator. This stage can create up to 64 samples per edge, but needs two additional programmable stages in the rendering pipeline: Hull Shader (HS) and Domain Shader (DS). The HS is called once for each input primitive in the pipeline, KSQuad in our implementation, and this is the stage in charge of configuring the Tessellator. Culling can also be performed in this stage.The new primitives generated by the tessellator are sent to the DS, so this stage is called once for each KSDie in our implementation. The DS receives both the parametric positions created by the tessellator and the KSQuad data directly from the HS. The four corners of each KSDie,S(xk,yl),S(xk+δx,yl),S(xk,yl+δy), andS(xk+δx,yl+δy), are efficiently evaluated in the DS by taking advantage of access locality and avoiding redundant computations. Let us emphasize that like Reyes vertex shading, RPNS also allows the user to specify an arbitrary shading rate. In Reyes, shading rate is expressed in samples per pixel meanwhile we specify samples per KSDie in RPNS, with a value of 4.0 in our implementation. A more efficient RPNS implementation would adaptively choose the shading rate per KSDie, but that objective is beyond the scope of this paper.The output from the DS is sent to the GS, where two triangles are generated for each KSDie due to the triangle-oriented graphics pipeline of current GPUs. Furthermore, to optimize the rendering of NURBS surfaces in RPNS we propose a backface and view frustum culling in the GS, called Exact Visible Set (EVS). This culling stage has a high impact on the overall performance, since it achieves an important reduction in the number of KSDice to get rasterized.Although DirectX11 introduces a patch primitive to deal with parametric surfaces, this primitive is only suitable to work with simple and regular surfaces such as bi-cubic Bézier surfaces, where only the positions of the control points need to be stored and the number of control points can be deduced from the surface degree. Due to the inherent complexity of the NURBS surfaces, we need to define a storage layout in texture memory more complex than the one available through the patch primitive. As shown in Fig. 8, our proposal uses two indirection levels to access all the data required to work with a KSQuad primitive: firstly, an access to the Info KSQuad Table, which contains indices to the NURBS surface data needed for each KSQuad, and then the access to the surface data using those indices. Both the Info KSQuad Table and the rest of the surface data (knot spans, weights and control points) are stored in texture memory. Although this arrangement needs a double memory access, it saves an important number of CPU–GPU transfers. Other alternatives could be easily implemented, such as sending all the required data for each KSQuad via the vertex buffer.Every KSQuad primitive that enters in the pipeline has enough information to access to the Info KSQuad Table and fetch all the needed data from texture memory to completely evaluate the KSQuad. The access to all this information is needed in the HS and DS stages (see Fig. 8), that correspond to the input of the Geometry and Sampler stages in RPNS, as shown in Fig. 4.We have implemented and tested three different alternatives to map RPNS on DirectX11, one exploiting the GS capability of generating new geometry, and the other two that use the HS, Tessellator and DS stages to overcome the GS limitations. One of these two proposals implements a non-uniform version of RPNS that focuses on minimizing the number of generated primitives, whereas the other one obtains a uniform result.GS-based RPNS.Our first proposal for the implementation of RPNS on the DirectX pipeline focuses on the GS stage. Thus, even though KSQuads evaluation in the GS makes it possible to reuse part of the computations, the bounds in the maximum number of KSDice that can be generated for each input KSQuad make it impossible to achieve high quality renders. This proposal is not shown in the section of results.This implementation uses the HS, Tessellator and DS stages to map the stages in RPNS. The work in HS is done with a KSQuad granularity, fetching the necessary information from texture memory. This stage applies the local average area test and, optionally, a previous culling. This test is used to set the subdivision factor in the tessellator that guarantees a maximum size (in pixels) for the KSDice to be generated (Eq. (3)). All this work corresponds with the geometry stage of RPNS.Once the KSDice are created by the tessellator, they are sent to the DS. Thus, the DS is called once for each (still empty) KSDie. In this stage, each KSDie is evaluated in the NURBS surface using the stair strategy described in Section  3.2. This stage together with the tessellator correspond with the sampler stage of RPNS.This implementation of RPNS follows the same structure than the previous one, but with the addition of a GS stage that implements the adaptability in the sampler stage of RPNS  [21]. In this case, the HS previously sets the tessellator to create a fewer number of KSDice. The output from the DS is sent to the GS, where the linear approximation and the boundary region test are used to guide the subdivision level applied to each KSDie. Thus, the linear approximation test (Eq. (4)) assures that a higher subdivision level is applied to non-flat regions. Besides, the boundary region test (Eq. (5)) detects the regions of KSQuads that are boundaries to other surfaces and applies the highest subdivision factor to prevent cracks between adjacent surfaces.

@&#CONCLUSIONS@&#
In this work a proposal of a new pipeline for the efficient rendering of NURBS surfaces, RPNS, is presented. Our pipeline is based on a new primitive, KSQuad, that provides a regular and flexible management of NURBS surfaces but maintaining their main geometric properties. This primitive allows an efficient rendering of the NURBS surface in all its parametric knot spans, what is especially suitable to achieve high performance GPU implementations.RPNS performs an efficient adaptive discretization of KSQuads into KSDice, that allows us to fine tune the density of primitives needed to avoid cracks and holes in the final image, in addition it applies an efficient non-recursive evaluation of the basis function of a NURBS surface on the GPU. Different GPU implementations of RPNS are proposed on DirectX11, exploiting the programmable and configurable stages of current graphics hardware to achieve interactive and real-time rendering rates of complex parametric models. Our experimental tests show that RPNS is several orders of magnitude faster than traditional approximations based on NURBS to Bézier conversion when considering the interactive handling of rendered models.To optimize the rendering of NURBS surfaces in RPNS as well as a proof of the versatility of the KSQuad primitive, we will include backface and view frustum culling in future work. Finally, let us emphasize that results show that our method is more efficient than the existing methods.