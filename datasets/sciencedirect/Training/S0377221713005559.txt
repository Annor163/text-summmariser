@&#MAIN-TITLE@&#
Breakout local search for the Steiner tree problem with revenue, budget and hop constraints

@&#HIGHLIGHTS@&#
STPRBH is a generalization of the conventional Steiner tree problem.We propose a heuristic algorithm based on the Breakout Local Search (BLS).The proposed heuristic is assessed on 240 well known benchmark instances.BLS finds improved results for 49 out of the 56 most challenging instances.

@&#KEYPHRASES@&#
Steiner tree problems,Network design,Constrained combinatorial optimization,Heuristic search,Adaptive perturbation,

@&#ABSTRACT@&#
The Steiner tree problem (STP) is one of the most popular combinatorial optimization problems with various practical applications. In this paper, we propose a Breakout Local Search (BLS) algorithm for an important generalization of the STP: the Steiner tree problem with revenue, budget and hop constraints (STPRBH), which consists of determining a subtree of a given undirected graph which maximizes the collected revenues, subject to both budget and hop constraints. Starting from a probabilistically constructed initial solution, BLS uses a Neighborhood Search (NS) procedure based on several specifically designed move operators for local optimization, and employs an adaptive diversification strategy to escape from local optima. The diversification mechanism is implemented by adaptive perturbations, guided by dedicated information of discovered high-quality solutions. Computational results based on 240 benchmarks show that BLS produces competitive results with respect to several previous approaches. For the 56 most challenging instances with unknown optimal results, BLS succeeds in improving 49 and matching one best known results within reasonable time. For the 184 instances which have been solved to optimality, BLS can also match 167 optimal results.

@&#INTRODUCTION@&#
Many problems in network designing, e.g., electricity, telecommunication, heating, transportation, should determine a least cost tree spanning all or some of the vertices of a given graph (Avella, Villacci, & Sforza, 2005; Voß, 2006). These problems usually can be modeled as the Steiner tree problem (STP) or the minimum spanning tree problem (MSTP), which are generally formulated as follows: given a graph G=(V,E) with vertex set V={1,…,n} which is partitioned into two sets: a set of terminal vertices and a set of Steiner vertices, and edge set E={(i,j): i,j∈V,i≠j} where each edge (i,j)∈E has an associated cost cij⩾0. In some cases, a specified vertex is chosen as the root vertex. The STP consists of determining a subtree spanning all terminal vertices (including the root vertex) and possibly some Steiner vertices, so as to minimize the total cost of the obtained tree. As a special variant of the STP, for the MSTP, all vertices are terminal which should be included in any feasible solution. Unlike the MSTP that can be solved to optimality within polynomial time (Prim, 1957), the STP has proven to be NP-hard (Garey, Graham, & Johnson, 1977).In this paper, we study an important variant of the STP: the Steiner tree problem with revenue, budget and hop constraints (denoted by STPRBH, as formulated in Costa, Cordeau, & Laporte, 2009). In this problem, in addition to the costs cij⩾0 associated with each edge (i,j)∈E, there is also a revenue ri⩾0 associated with each vertex i∈V. The problem consists of determining a rooted (without loss of generality, vertex 1 is fixed as the root) subtree of graph G, so as to maximize the collected revenues, while guaranteeing that the total cost of the solution does not exceed a given budget B (budget constraint), and the number of edges from the root to any vertex in the solution subtree does not exceed an upper bound equal to h (hop constraint). As a generalization of both the STPP (STP with profits, see Johnson, Minkoff, & Phillips, 2000; Costa, Cordeau, & Laporte, 2006; Haouari, Layeb, & Sherali, 2013) and the STPH (STP with hop constraints, see Voβ, 1999; Akgün, 2011), the STPRBH is theoretically important and can be used to model many real-life problems, e.g., local access and telecommunication networks, heating or water supply systems, transportation planning, etc., in which the collected revenues should be maximized, while the available budget is limited and the reliability of the system should be guaranteed. For the STPRBH, researchers have developed various solution approaches. Respectively, Costa, Cordeau, and Laporte (2008) proposed several fast heuristics, including a greedy algorithm, a destroy-and-repair algorithm and a tabu search (TS) algorithm. Computational results for instances with up to 500 vertices and 12,500 edges were reported. In addition to the heuristics, several exact algorithms have also been proposed, including branch-and-cut (Costa et al., 2009), branch-and-price (Sinnl, 2011). Note that all the existing exact algorithms can only solve instances with up to 500 vertices and 625 edges to optimality, for larger instances, no result has been reported by any exact algorithm.In this paper, we are interested in the STPRBH and propose a heuristic algorithm based on the Breakout Local Search (BLS) for this problem. BLS follows the general Iterated Local Search scheme (Lourenco, Martin, & Stützle, 2003) and alternates between a neighborhood search phase and a perturbation phase. BLS has recently shown its effectiveness for solving several combinatorial optimization problems, such as sum coloring (Benlic & Hao, 2012), maximum clique (Benlic & Hao, 2013a), quadratic assignment (Benlic & Hao, 2013b), and max-cut (Benlic & Hao, 2013c). For the STPRBH, the proposed BLS algorithm integrates a probabilistic constructive procedure to generate its initial solution, a Neighborhood Search (NS) procedure based on three specifically designed move operators to discover local optima, and an adaptive perturbation strategy to continually move from one local optimum to another one, by varying its perturbations depending on the search status. As a supplementary technique, a number of high-quality solutions are stored in a solutions pool, in order to provide useful information for local optimization and perturbations. Computational results based on a set of 240 STPRBH instances, including 56 the most challenging instances with unknown optimal solutions, demonstrate the effectiveness of the proposed BLS algorithm. In particular, it succeeds in improving 49 and matching one best known results out of these 56 unsolved instances.The rest of this paper is organized as follows: After giving some preliminary definitions in Section 2, Section 3 describes the details of the proposed BLS approach. Computational results are provided in Section 4, and Section 5 concludes this paper.In this section, we provide some preliminary definitions which are useful for a precise description of the proposed algorithm.Definition 1A budget and hop constrained Steiner tree (BHS-tree) is a rooted subtree of graph G meeting both the budget and hop constraints. A BHS-tree is also called a feasible solution of the problem.Given a BHS-tree T, a feasible candidate path with respect to T is a path originating at a vertex i∈v(T) (v(T) denotes the set containing all the vertices belonging to solution T) and connecting to an uncollected profitable vertex j (j∉v(T), rj>0), such that even after inserting this path to T, the obtained solution is still a BHS-tree, i.e., satisfying both the budget and hop constraints.A saturated BHS-tree is a BHS-tree for which no feasible candidate path exists. Otherwise, the BHS-tree is an unsaturated (or partial) BHS-tree. Contrary to a saturated BHS-tree, an unsaturated (or partial) BHS-tree can be further extended by adding some feasible candidate path without violating the budget and hop constraints.The constrained search space Ω is composed of all possible BHS-trees (including saturated ones or unsaturated ones). The saturated constrained search spaceΩ¯is composed of all possible saturated BHS-trees which is clearly a subspace of Ω.As detailed below, our BLS algorithm restricts its search within the saturated constrained search spaceΩ¯. By doing so, the search process focuses always on the reduced zones composed of the most promising candidate solutions.In this paper, we present for the first time a Breakout Local Search (BLS) approach for solving the STPRBH, just as outlined in Algorithm 1, whose key components are presented in the following subsections.Algorithm 1Breakout Local Search BLS(G,B,h) for the STPRBHRequire: Graph G(V,E), budget limit B, hops limit h, jump magnitude L∈[Lmin,Lmax], high-quality (elite) solution pool HSPEnsure: The best solution found meeting both the budget and hop constraints1: /∗ Initialization phase ∗/2: HSP←InitHSP()/∗ Initialize HSP, see Section 3.3.2 ∗/3: T←InitSolution(G,B,h)/∗ Construct an initial solution, see Section 3.2 ∗/4: T←NS(T)/∗ Optimize T by neighborhood search, see Section 3.3 ∗/5: Tbest←T6: L←Lmin7: /∗ Main search procedure which is iterated until the stop condition is met ∗/8: while The stop condition is not met do9: /∗ Perturb T with L and HSP (Section 3.4) and then improve it (Section 3.3) ∗/10:T′←Perturb(T,HSP,L)11:T∗←NS(T’)12: /∗ Update the best solution Tbestfound so far if needed ∗/13:ifT∗ is better than Tbest(see Section 3.3.1) then14:Tbest←T∗15:end if16: /∗ Determine the jump magnitude L adaptively, detailed in Section 3.4 ∗/17:ifT∗ is too close to T (defined in Section 3.4) then18:L←Min(L+1,Lmax)19:else20:L←Max(L−1,Lmin)21:end if22: /∗ Update T, which serves as the starting point of a new round of search ∗/23:T←T∗24: end while25: returnTbestOur BLS algorithm operates within the saturated constrained search spaceΩ¯(Section 2). The main idea of the approach for the STPRBH can be described as follows: starting from a saturated BHS-tree probabilistically constructed by the dedicated probabilistic constructive procedure (see Algorithm 1, line 3 and Section 3.2), BLS applies a Neighborhood Search (NS) procedure to reach a local optimum at first (line 4, see Section 3.3). After local optimization, BLS then attempts to continually move from one local optimum to another by employing varying perturbations, depending on the state of the search. For this purpose, an adaptive perturbation mechanism is developed, which is guided by some dedicated information of a number of recorded high quality solutions stored in the HSP (line 2 and line 10, see Sections 3.3.2 and 3.4). Each time the incumbent solution is perturbed, the NS procedure is called again to improve it to a new local optimum (line 11). If the NS procedure reaches a local optimum not far enough from the original one, BLS then perturbs it more strongly, otherwise, BLS switches to weaker perturbations subsequently (lines 16–21). This process is repeated until (1) the upper bound of the collected revenues in Eq. (2) (see Section 3.2.2) is reached (meaning that an optimal solution is obtained), or (2) the best found solution cannot be further improved after visiting M new local optima (M is a parameter), or (3) the allowed computation time is consumed.The performance of the BLS algorithm relies on several key factors. First, the initialization procedure should be able to generate different solutions of reasonable quality, which serve as the restarting points of independent runs of BLS. Second, the neighborhood structure is also a key component because different neighborhoods lead to different search trajectories, thus solutions of different qualities. Third, we should control the jump magnitude, denoted by L, which determines the perturbation intensity applied to the current solution. In our case, this corresponds to decide how many paths to delete when perturbing the incumbent solution. Indeed, if L is too small, the search usually returns to the original local optimum, leading to search stagnation. Otherwise, if L is too large, the perturbation is reduced to random restarting. Finally, it is important to consider the perturbation type, e.g., directed perturbation or random perturbation. Unlike conventional pure random perturbations, we additionally employ a directed perturbation operator with the aid of selected high quality solutions, which provides useful information to guide the search towards good solutions. The components of the proposed BLS algorithm for the STPRBH are described below.To represent the candidate solutions of the problem in a convenient way, we adopt a compact representation using a one-dimensional vector T={ti,i∈V} which is explained as follows. Precisely, according to the constraints of the STPRBH, each feasible solution is a rooted tree with fixed root vertex 1. Therefore, for each vertex i belonging to a feasible solution T (except the root vertex), we can identify and record its parent vertex ti. Specifically, the elements of T={ti,i∈V} are defined such that ti= the parent vertex of vertex i if i∈v(T)⧹1; Otherwise ti=Null.Consequently, each feasible solution is uniquely identified by a vector T={ti,i∈V}. Inversely, given a vector T={ti,i∈V} corresponding to a feasible solution, it is easy to reconstruct the corresponding solution.Like any meta-heuristic based algorithm, BLS requires an initial solution to start its search. Moreover, given its stochastic nature, multiple runs of BLS from different initial solutions are typically applied to find the best possible solutions for a problem instance. To generate an initial solution, we use the criteria developed by Costa et al. (2008) for identifying, evaluating and selecting feasible candidate paths for insertion and devise a probabilistic constructive procedure in order to be able to obtain different initial solutions for multiple runs of the procedure. Starting from an empty solution containing only the root vertex, the constructive procedure identifies all the feasible candidate paths with respect to the incumbent solution at first and evaluates their priorities subsequently. Then, it probabilistically selects a candidate path to insert to the incumbent solution, according to its priority. This process is repeated until no feasible candidate path exists, meaning that a saturated BHS-tree satisfying both the budget and hop constraints is obtained, which would serve as the starting point of our BLS algorithm.Before presenting the criteria for identifying, evaluating and selecting a candidate path, we should solve the hop constrained shortest path problem at first, i.e., the problem of determining a shortest path between two vertices containing at most h edges. This problem can be solved efficiently by dynamic programming (Lawler, 1976): let L(i,j,l) represent the cost of the shortest path between vertex i and vertex j, containing at most l edges, then:(1)L(i,i,0)=0,i∈V,L(i,j,0)=∞,i,j∈V,j≠i,L(i,j,l)=min{L(i,j,l-1),mink|(k,j)∈E{L(i,k,l-1)+ckj},i,j∈V,l⩾1}.Note that in Costa et al. (2008), each time a new path is inserted, the costs of all the edges belonging to the incumbent solution are reset to 0 and the hop constrained shortest path algorithm is run again to re-calculate all the possible L(1,j,l), l⩽h. Contrary to this, with our BLS algorithm, we apply a preprocessing step to calculate and store all the possible L(i,j,l), i,j∈V,rj>0, 1⩽l⩽h which are then used directly during the search process, instead of re-calculating them repeatedly. This technique allows the algorithm to save computation time. In the following subsections, whenever reporting the computation time of BLS, this preprocessing time is always included.After calculating all the possible L(1,j,h), we can recognize all the vertices reachable within h hops, i.e., L(1,j,h)<∞. Then, we get an upper bound Rubof the collected revenues as follows:(2)Rub=∑L(1,j,h)<∞rj.Clearly, if the collected revenues reaches the upper bound Rub, then the incumbent solution corresponds to an optimal solution and the search process stops. This rule is indeed used as one of the termination criteria of the proposed BLS algorithm.At each step of constructing a saturated BHS-tree, we use the following criterion to dynamically identify all the feasible candidate paths. Specifically, for each profitable vertex j uncollected by the incumbent partial BHS-tree T (rj>0 and j∉v(T)), let L(i,j,h−hi) denote the cost of the hop-constrained shortest path between vertex j and a vertex i∈v(T), containing at most h−hiedges, hibeing the number of edges between vertex i and the root vertex. We use min{L(i,j,h−hi), i∈v(T)} to denote the cost of the hop-constrained shortest path between vertex j and the partial BHS-tree T. Consequently, ifmin{L(i,j,h-hi),i∈v(T)}⩽B-∑(m,n)∈e(T)cmn(e(T) is the set containing all the edges of T, and∑(m,n)∈e(T)cmnrepresents the total cost consumed by T), it corresponds to a feasible candidate path connecting vertex j. Otherwise, no feasible candidate path connecting vertex j exists.At each step of initial solution construction, there may be more than one feasible candidate paths available. In Costa et al. (2008), the ratiorj3L(1,j,h)which considers both the objective and the constraint is used to evaluate the priority of each candidate path connecting an uncollected profitable vertexj∉v(T). In this work, we use instead the ratiorj3min{L(i,j,h-hi),i∈v(T)}for this evaluation. Given two paths, the path with a higher ratio is considered to be of more priority than the other one. Additionally, due to the reasons described in Section 3.2.1, this criterion is essentially equivalent to the one developed in Costa et al. (2008).After identifying all feasible candidate paths, we should decide which path to insert to the incumbent solution. In order to be able to start the search from different starting points, we introduce the following randomized selection rule:(1)If no feasible candidate path is available, stop the constructive procedure and return the incumbent solution (which is already a saturated BHS-tree) as the initial solution.If there is only one feasible candidate path available, select and insert it into the incumbent solution.If there are m (m>1) feasible candidate paths available, select the path with the ith (2⩽i⩽m) highest priority with probability (1−θ)i−1θ, θ∈(0,1], and select the path with the highest priority with probability1-∑i=2m(1-θ)i-1θ=θ+(1-θ)m, so as to guarantee that the accumulated probability is equal to 1.The above probabilistic criterion has two interesting features. First, each feasible candidate path has the opportunity to be selected and inserted. Consequently the probabilistic constructive procedure is theoretically able to cover the whole solution space. Second, the probability that a feasible candidate path is selected is proportional to its priority. As such, the constructed initial solutions tend to be of good quality.In addition, because of the hop-constraints, cycles may occur after inserting a new path. In this case, we destroy cycles by inspecting vertices with two incoming edges and eliminating the first inserted edge, as suggested in Costa et al. (2008).Finally, in the above-described probabilistic constructive procedure, if we let θ=1.0, it is reduced to the greedy algorithm (Costa et al., 2008). However, after a series of preliminary experiments (detailed in Section 4.2, Fig. 2), we find that the generalizations with small values of θ (i.e., θ<0.5) generally perform better than large ones (i.e., θ>0.5), especially than the choice of the greedy algorithm (i.e., θ=1.0), which unexceptionally selects the candidate path with the highest priority.From an initial solution constructed above, our BLS algorithm improves it to a local optimum by using a specifically designed Neighborhood Search (NS) procedure, which iteratively replaces the incumbent solution with the best improving solution of its neighborhood, until such a solution does not exist. The proposed NS procedure is detailed in the following subsections.To identify the best neighboring solution of the incumbent solution T within the neighborhood N(T) (see next subsection), BLS uses the objective value (i.e., the collected revenues) as the main evaluation criterion. Thus given two solutions, the one collecting a higher revenue is better than the one collecting a lower revenue. If both solutions collect the same amount of revenue, the solution with a lower cost is naturally considered to be the better one. Given this evaluation rule, BLS identifies at each iteration the best improving solution among all the candidate neighboring solutions in N(T) and moves to this selected solution.The neighborhood structure is the key component of any neighborhood-based search method. We design three dedicated move operators for the SPTRBH denoted by Move_k(i1,…,ik), 1⩽k⩽3 for generating neighboring solutions. As a preliminary, we first introduce two basic operators: Delete(i), Insert() as follows.Delete(i): delete the path connecting leaf vertex i from the incumbent solution. Note that for path deletion, we just delete the edges between vertex i and the first met branch vertex or profitable vertex, while maintaining the left edges between vertex i and the root vertex (e.g., Fig. 1, a→b→c, see below for more comments).Insert(): iteratively insert one path (excluding the recently deleted ones) connecting some profitable vertex to the incumbent solution, according to the criteria described in Section 3.2, until the incumbent solution becomes a saturated BHS-tree, i.e., no feasible candidate path can be further inserted. Note that zero or several paths may be inserted by Insert() (as shown in Fig. 1, c→d).With these two basic operators, three move operators for generating neighboring solutions, i.e., Move_k(i1,…,ik), 1⩽k⩽ 3, are implemented as follows.(3)Move_1(i1)=Delete(i1)+Insert(),Move_2(i1,i2)=Delete(i1)+Delete(i2)+Insert(),Move_3(i1,i2,i3)=Delete(i1)+Delete(i2)+Delete(i3)+Insert().where i1, i2, i3∈lv(T), lv(T) is the set containing all the leaf vertices of the incumbent solution T.With these move operators, the generated neighboring solutions are denoted by T⊕Move_k(i1,…,ik). Note that different k corresponds to different neighboring solutions.For example, Fig. 1 illustrates the process for generating a neighboring solution by Move_2(8,7), where the profitable vertices with ri>0 are drawn in box (i.e., vertices 1, 3, 4, 7, 8, 9, 11, 13, 14), and the others are drawn in circle (i.e., vertices 2, 5, 6, 10, 12). As shown in Fig. 1, from the original solution a, the path connecting leaf vertex 8 is deleted at first to get solution b. Then the path connecting leaf vertex 7 is deleted to get solution c. Finally, three new paths connecting profitable vertices 11, 13, 14 are inserted into c to obtain a neighboring solution d of the original solution a, i.e., d←a⊕Move_2(8,7).Given that vertex 6 is a branch vertex that has two branches, when deleting the path connecting leaf vertex 8 from a, we only delete edge (6,8) from a, instead of deleting all the edges between vertex 8 and the root. Similarly, because vertex 4 is a profitable vertex with r4>0, when deleting the path connecting leaf vertex 7, we only delete edges (4,6) and (6,7) from b.Clearly, if ∣lv(T)∣=m, there areCmk=m!k!(m-k)!possible neighboring solutions with move operator Move_k(i1,…,ik). Therefore, if we consider all the possible neighboring solutions, the neighborhood N(T) contains O(m3) neighboring solutions. Although larger neighborhoods generally lead to better local optimal solution, more computation time is also needed. For the trade-off between solution quality and efficiency, in this work, we try to reduce the neighborhood N(T) to contain O(m) solutions selected from all the O(m3) possible candidate ones by the following steps.(1)Let N(T,k), 1⩽k⩽3 denote the sub-neighborhood associated with operator Move_k(i1,…,ik). Then, initialize N(T,1) to contain all the m possible neighboring solutions generated by Move_1(i1), and initialize N(T,2), N(T,3) to be ∅.As a preliminary, try to construct and fill a high-quality (or elite) solution pool HSP as follows. For each individual, call the probabilistic constructive procedure described in Section 3.2 to construct an initial solution, and then iteratively replace the incumbent solution with the best improving neighboring solution of its smallest sub-neighborhood N(T,1), until no improving solution exists in N(T,1). Independently repeat this process Q times to obtain Q local optima, i.e., T1,…, TQ, then calculate their average collected revenues and retain the ones collecting no less revenues than the average value. These selected solutions are considered as high-quality solutions and stored into the HSP.For each vertex i, calculate the probability pithat vertex i belongs to the solutions stored in the HSP, i.e.,(4)pi=∑Ta∈HSPyia|HSP|.whereyiaindicates whether vertex i belongs to solutions Ta∈HSP or not. Ifi∈v(Ta),yia=1, otherwise,yia=0.Apply a probabilistic deletion operator, denoted by ProbDel(k), to probabilistically delete k paths connecting k leaf vertices from the incumbent solution T, with the aid of the HSP (as detailed in Algorithm 2). Note that in Algorithm 2, each time one path connecting a leaf vertex is deleted, some branch vertex may become a new leaf vertex. The path connecting this new leaf vertex should also be considered when deciding the next path to delete.For each k, 2⩽k⩽3, generate ∣lv(T)∣=m neighboring solutions and add them into sub-neighborhood N(T,k) as follows: for each leaf vertex i∈lv(T), delete the path connecting vertex i at first, and then execute the probabilistic deletion operator ProbDel(k−1) to probabilistically delete k−1 paths. After that, execute the basic operator Insert() to insert as many feasible candidate paths (excluding the recently deleted ones) as possible into the incumbent solution, to obtain a saturated BHS-tree, i.e.,(5)N(T,k)={T+Delete(i)+ProbDel(k-1)+Insert(),i∈lv(T)},2⩽k⩽3.Let N(T) be the union set of all the above three sub-neighborhoods, i.e.,(6)N(T)←N(T,1)∪N(T,2)∪N(T,3).ProbDel(k) for probabilistically deleting k paths from the incumbent solution TRequire: Solution T, elite solution pool HSP, number of paths to delete kEnsure: Solution after deleting k paths1: for each vertex ido2: Calculate the probability pithat vertex i belongs to the solutions stored in the HSP, according to Eq. (4)3: end for4: l←05: whilel<k and leaf vertex i∈lv(T), pi<1 exists do6:Deleted←false7:whileDeleted=falsedo8: Randomly select a path connecting some leaf vertex i∈lv(T), pi<19: /∗ Delete the path connecting leaf vertex i with probability 1−pi∗/10:ifGetRandomNum(100)>100×pithen11:T←Delete(i)12:Deleted←true13:end if14:end while15:l←l+116: end while17: returnTThe neighborhood N(T) defined in Eq. (6) will be used as the final neighborhood of the NS procedure. The following properties of this neighborhood are worth mentioning. First, each sub-neighborhood N(T,k), 1⩽k⩽3 contains m neighboring solutions, hence the final neighborhood N(T) contains 3m neighboring solutions, instead of the original O(m3) possible ones. Second, N(T,k1)⋂N(T,k2)=∅, k1≠k2, it means that any neighboring solution belongs to only one sub-neighborhood. Third, for each leaf vertex i∈lv(T), at least one neighboring solution corresponding to deleting the path connecting vertex i belongs to each sub-neighborhood N(T,k), 1⩽k⩽3. This feature could be helpful to reinforce the diversity of the solutions of the neighborhood. Fourth, the higher the probability piof leaf vertex i, the larger its probability to be retained while generating neighboring solutions. We utilize this mechanism to select O(m) promising neighboring solutions among all the O(m3) candidates. Finally, every neighboring solution is unexceptionally a saturated BHS-tree, thus the search is restricted within the saturated constrained search spaceΩ¯.In addition, to verify the impact of the neighborhood structure, we tested two other different neighborhoods, i.e., N(T,1) and N(T,1)∪N(T,2) respectively, and compared their performances with the neighborhood defined by Eq. (6). Experiments showed that BLS with Eq. (6) yielded statistically much better results (in terms of solution quality) than these two compared variants, though some more (remaining reasonable) computational time is needed. To ensure that BLS finds high quality solutions, we adopt Eq. (6) as the final neighborhood.Based on the above described neighborhood and the way to identify the best improving neighboring solution, the NS procedure starts from a given initial saturated BHS-tree T, and iteratively replaces T with the best improving neighboring solution of its neighborhood N(T). This process continues until no such solution exists in the neighborhood. At this point, a local optimum is reached. To continue its search, our BLS procedure applies a dedicated perturbation mechanism for escaping from the incumbent local optimum, according to the procedure detailed below.The purpose of the perturbation mechanism is to allow BLS to escape from the current local optimum in order to discover other local optima of better quality. For this, we employ as follows an adaptive perturbation mechanism which varies the perturbation intensity, depending on the search status.Precisely, each time the search reaches a local optimum T, we perturb it to obtain a new solution. The perturbation consists in deleting L (initialized to Lmin) paths from T and inserting subsequently as many feasible candidate paths as possible into the incumbent solution. From this perturbed solution, we call the NS procedure to reach another local optimal solution T∗. If the new solution T∗ is too close to T (see below for the exact definition), we increase the jump magnitude L by 1, unless L=Lmax; otherwise, we decrease L by 1, unless L=Lmin. This process is repeated, until the stop condition is met.To assess if two solutions Taand Tbare close or not, we calculate their Hamming distance D(Ta,Tb), based on which we further define the average distance between the solutions of the high-quality solutions pool HSP (Section 3.3.2, step 2), denoted by AvgDis(HSP), as follows:(7)AvgDis(HSP)=∑Ta,Tb∈HSP,a<bD(Ta,Tb)12×|HSP|×(|HSP|-1).Based on this, T∗ is considered to be too close to T if D(T,T∗)<α×AvgDis(HSP). Parameter α would be further discussed in Section 4.2.In addition to the jump magnitude L, BLS also considers the type of perturbations. In this work, we develop a directed perturbation operator, with the aid of the HSP. The basic idea is that the vertices which frequently occur in high-quality solutions are more likely to belong to the global optimal solution. Therefore, when we perturb the incumbent solution, it would be wise to retain these specific vertices with a larger probability, and retain the others with a smaller probability. Specifically, let T be the current local optimal solution, we perturb T by the following three steps, with a given jump magnitude L.•For each vertex i∈v(T), calculate the probability pithat vertex i belongs to the solutions stored in the HSP, according to Eq. (4).Call Algorithm 2 to probabilistically delete L paths, unless no leaf vertex with pi<1 exists.Execute the basic operator Insert() (Section 3.3.2) to insert as many feasible candidate paths (excluding the paths deleted in above step) as possible into the incumbent solution, until no path can be further inserted.This perturbation procedure has the following features. First, the incumbent solution is perturbed in an adaptive way, controlled by the jump magnitude L, i.e., the larger the magnitude L, the stronger the perturbation. Second, the perturbation attempts to reconstruct a new incumbent solution in a biased mode, guided by some dedicated information from the high-quality solutions in the HSP. Finally, the new solution never violates the budget and hop constraints and is always a saturated BHS-tree, hence no repair is required and the search always operates within the saturated constrained search spaceΩ¯.

@&#CONCLUSIONS@&#
