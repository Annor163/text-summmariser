@&#MAIN-TITLE@&#
Computation of components’ interfaces in highly complex assemblies

@&#HIGHLIGHTS@&#
Computation of interfaces between components in complex CAD assemblies.GPU ray-casting technique for efficient processing of large assemblies.Accurate NURBS geometry of the interfaces, stored in standard STEP file.

@&#KEYPHRASES@&#
Interface,Imprint,Assembly,CAD/CAM,

@&#ABSTRACT@&#
The preparation of CAD models from complex assemblies for simulation purposes is a very time-consuming and tedious process, since many tasks such as meshing and idealization are still completed manually. Herein, the detection and extraction of geometric interfaces between components of the assembly is of central importance not only for the simulation objectives but also for all necessary shape transformations such as idealizations or detail removals. It is a repetitive task in particular when complex assemblies have to be dealt with. This paper proposes a method to rapidly and fully automatically generate a precise geometric description of interfaces in generic B-Rep CAD models. The approach combines an efficient GPU ray-casting technique commonly used in computer graphics with a graph-based curve extraction algorithm. Not only is it able to detect a large number of interfaces efficiently, it also provides an accurate Nurbs geometry of the interfaces, that can be stored in a plain STEP file (Iso 10303-1:1994 (1994))  [16] for further downstream treatment. We demonstrate our approach on examples from aeronautics and automotive industry.

@&#INTRODUCTION@&#
The widespread use of CAD software in industries over decades has led to common representations of products as assemblies, also designated as digital mock ups (DMUs). The extensive use of CAD has led to increasingly complex DMUs, ranging from tens of components for simple products to thousands of components for a car to hundreds of thousands of components for an aircraft. More recently, commercial software platforms have expanded to cover the product lifecycle, addressing, among various steps, the design stage and the numerical behavior simulations using CAE software. While finite element (FE) analyses of single components have been under focus for a long time and are still requiring new developments  [1], companies are now heading toward behavior simulations at the assembly level  [2]. Indeed, the design of complex products containing numerous components remains tedious since many tasks require a large amount of user interaction that can be only conducted by experts. First, generating FE models at rather large assembly level, i.e. incorporating tens of components, requires the simplification and/or idealization of component shapes, consistently with the simulation objectives, e.g. replacing volume sub domains by either planar surfaces or lines when their mechanical behavior resembles a plate’s or a beam’s one, respectively. In addition to the modeling of each component individually, mechanical simulation requires to model the interfaces between components  [3,4,2]. While the kinematic simulation of assemblies only requires knowledge about the type and spatial position of the contact surfaces, stress computations using FE simulations require the precise modeling of the imprint of one component on each other within each interface. Given two partially overlapping surfaces, imprinting consists of the process of inserting curves and vertices in each surface such that they share a topologically well defined interface.While the automatic meshing of components based on their B-Rep representations is available in CAE software, remeshing components to conform to their interfaces may involve man-months of engineering. Similar observations can be transposed to other stages of the product lifecycle like assembly simulations using virtual reality techniques  [5,6] where component interfaces appear again as prominent elements. More generally, components’ geometric interfaces appear as key entities to process assemblies efficiently. However, these interfaces are not readily available in DMUs and specific geometry processing is needed to obtain them  [3,4,6,5].In this paper we propose a method to rapidly detect and produce the B-Rep model of the imprint of each component onto each of its neighboring components as illustrated in Fig. 1. We do not assume any prior knowledge on the interfaces, we are given only the CAD B-Rep model of the assembly, and from this we detect and reconstruct the B-Rep of the interfaces.Based on our study of the current state-of-the-art regarding how interfaces are dealt with in CAD/CAM academic literature and industrial software (see Section  2 for details), we can make the following observations. First, most of the previous work does not incorporate a precise description of components’ geometric interfaces. Furthermore, no standard is effectively implemented in industrial CAD/CAM software that can export geometric interfaces to other ones. When it comes to large assemblies, this lack of detailed description of geometric interfaces becomes a real challenge. Low level interactive operators enabling the surface trimming of components’ boundaries become too tedious for a practical computation of imprint faces  [3,4,7]. To scale up this approach to highly complex assemblies, new and more automated approaches are necessary. Highly complex assemblies are subject to multiple downstream processes with their own objectives in focus and their own tools. In such cases, it is essential to have the ability to handle standard CAD/CAM models and still be able to use the precise description of geometric interfaces between assembly components. We also observe that high level geometrical operators that are used to generate geometric interfaces, such as geometric offset computation, imprint generation  [4,7] and CSG-type operators  [3], do not scale well to complex assemblies in terms of time and robustness.Based on these observations, we propose an approach that takes as input any standard CAD/CAM assembly model and automates the generation of geometric interfaces between components. Our approach can detect and accurately describe the geometry of interfaces while scaling up well to highly complex assemblies. Our main contributions are:•A novel method to compute interface imprints in B-Rep models, using ray-casting and a series of post-processing steps, to produce upgraded B-Rep models which include the imprints of the interfaces in the components.The efficient implementation of the most computationally intensive parts of the method on the Graphics Processing Unit (GPU), allowing the process of thousands of B-Rep faces within minutes.The remainder of this paper is structured as follows. Section  2 analyzes related works. Section  3 presents our method. In Section  4, the implementation on a GPU is described. Results on real-world industrial CAD/CAM assemblies are presented in Section  5. We finally conclude and sketch future work in Section  6.Let us first define vocabulary. The components of an assembly, as modeled within current CAD systems, are facetted solid models represented as B-Rep NURBS. An interface in CAD modeling is defined as the imprint of one component onto the other. It is a contact surface which may be composed of planar, cylindrical, conical, spherical, ruled surface or general free-form surface parts.Approaches to functional design  [8–11] contribute to the setting of relationships between functional parameters of a product and its 3D CAD model. However, generating these relationships requires designers’ interactions to locate mating surfaces between components, which becomes too tedious for highly complex assemblies  [12]. Additionally, even if B-Rep faces of components are identified as functional surfaces (i.e. component interfaces), the common surface, or imprint, of each component onto the other is not available.Interfaces have typically been modeled using geometric constraints, such as mating surfaces or coaxiality, in functional design  [13], virtual assembly simulations  [6] or in standard CAD modules. While sufficient to enforce the relative positioning of the components, these constraints neither define the imprints between these (see Fig. 1), nor do they necessarily identify all the contact surfaces. Indeed, when an engineer selects two surfaces as input of a mating constraint, e.g.S11andS21in Fig. 3, the other contacts implementing the kinematical interface, such asS11andS22in the same figure, are not identified as contacts. The same issue arises in coaxiality constraints, creating ambiguous configurations that require specific treatments  [6].Although feature-based modeling can provide component boundary decompositions that can meet the requirements to correctly identify the mating surfaces  [14,15], it is a prescriptive approach because it requires user input. Therefore, the user’s assignment of features becomes error prone, especially when processing large assemblies. Also, it has to be pointed out that features cannot be propagated through model exchange between industrial software because most of them rely on STEP API 203 or 214  [16] that do not incorporate feature description. When processing assemblies for FE simulations in an industrial context, model exchange between CAD and CAE is often necessary, hence reducing the interest of feature-based models.Some CAD software propose operators to compute geometric interfaces. In CATIA V5, this operation is applied to a facetted representation of the B-Rep NURBS model of the components. As a result, the approximation taking place is not defining precisely the geometric interface and this operator cannot robustly distinguish contact from clearance configurations. In SolidWorks, geometric interfaces defining contacts can be visualized but cannot be converted to imprints. To the best of our knowledge, there is no industrial CAD software that produces accurate geometric interfaces with operators that scale up robustly to process highly complex assemblies. Additionally, if these softwares can position components using geometric constraints, the consistency of the corresponding equation system is still an issue  [17]. This is critical since positioning components, even in a rather small assembly like the hydraulic pump of Fig. 13 with 46 components, can lead to a large number of constraints, i.e. more than two hundreds of geometric constraints are necessary for the hydraulic pump. Therefore, aircraft and automotive companies favor the storage of large assemblies with components located at their absolute positions. Consequently, there is no geometric relationship between assembly components.Some approaches have been proposed to identify geometric interfaces between components. Chouadria  [3] used a facetted representation of components. Because the facetted representation is the input model, telling contacts from clearances becomes inherently difficult since there is no reference to an underlying B-Rep NURBS geometry. In  [4], the authors introduce an approach of tolerant imprinting using a tolerance greater than that of the underlying geometric modeler used to split edges and faces of each component. All the boundary transformations are performed using tolerant projection and split/cut operators of a volume modeler. This results in difficulties to scale up to highly complex assemblies. As mentioned by the authors, their approach strongly relies on the behavior of the operators of the volume modeler, which is not generic.Contact has also been extensively studied in Computer Graphics, to detect and react to collisions  [18]. It is typically modeled as distance constraints within pairs of low-level geometric primitives such as vertices, edges, polygons, spheres, and boxes. Recent methods leverage the power GPUs to discretize the boundaries of the intersection volumes between arbitrarily complex polyhedra [19,20]. None of these approaches accurately compute the contact surface between tangent objects.The above analysis shows that current approaches in functional design, feature-based modeling, geometric constraints and industrial practices are not able to produce the precise geometric interfaces between assembly components in a robust and scalable manner able to process highly complex assemblies.Our approach is based on the following assumptions:(A1)The imprint is a 2-manifold surface with boundaries.Every point on a boundary of an interface belongs to the boundary curve of at least one component.An overview of our method is shown in Fig. 2. Given two components (Fig. 2(a)), we shoot short rays from the facet boundaries and detect nearby intersections (Fig. 2(b)). These are clustered to represent the boundary curves of the imprint (Fig. 2(c)). We compute the connectivity of the curves (Fig. 2(d)) to detect cycles, which define the imprint faces (Fig. 2(e)).We shoot short rays only from the discretized boundaries of the surfaces to compute the boundaries of the imprint, consistently with assumption (A2). The rays are created on a per-face basis and casted in the direction of the normal to the surface. The rays are generated for all components B-Rep faces along their boundary curves by sampling the B-spline curves uniformly at the precision of the CAD model. Thus, from a boundary shared by two B-Rep faces of the same component, rays are casted in two directions.We compute pairs of closed points(P,Q)wherePas the origin of the ray belongs to a boundary curve of some component’s face, andQbelongs either to the interior of another component’s face, or to its boundary curve. The latter corresponds to the frequent case where two faces in different components share a section of the same boundary curve, see for example the three plates in Fig. 9(a).For the sake of clarity, the technical details of the GPU implementation of ray casting is presented in Section  4. For the time being it is sufficient to know that the GPU provides pairs of points(P,Q′)wherePis the origin of the ray andQ′is a point, close toP, lying on a discretization of the components. This discretization consists of edges for the boundary curves, and triangles for the B-Rep faces.•In caseQ′belongs to an edge, we need to compute the corresponding pointQon the boundary curve segment. To this end we linearly interpolate the parameter values of the end-points of the edge using the position ofQ′in the edge, as illustrated in Fig. 4. Since the parameterization may be distant from chord-length, we check that the distance betweenPandQis smaller than a thresholdε. If not we reject the pair(P,Q)and proceed to the next ray. If yes, we store the position Q, its parameter value and the index of the boundary curve it belongs to.In caseQ′belongs to the interior of a triangle, we do not need the exact intersection point with the B-Rep face the triangle belongs to, we only need to store the index of this B-Rep face.Output of the ray-casting part is finally a set of points lying on the boundary of the interfaces. In Sections  3.3 and 3.4 we will present our method for reconstructing the geometry of all interfaces from this set of points.In order to describe our method for reconstructing the interfaces from the points collected at their boundary, we choose the following notations.LetIbe an interface between B-Rep face A of one component and B-Rep face B of another component. LetCiA,CjBdenote the boundary curves of the faces A and B as given from the input B-Rep models. The B-Rep model also provides for each face an ordering of these curves and a parametric representation with coherent orientation for each curve such that the curves{CiA}iform one or more closed oriented boundary curves. See for example the blue face in Fig. 6(a) which is composed of 11 curvesCiA.Using ray casting as explained in the previous section, we have collected points along the boundary ofI. These points correspond to rays that were launched from the boundaries of face A (resp. B) and that have intersected face B (resp. A) either at its boundary or in its interior. Let us denote these pointsPkAin case the ray has been launched from A, andPlBotherwise. The collected points belong either to the boundary of one face (see blue and purple points in Fig. 6(b)) or to both faces (see green points in Fig. 6(b)).For eachPkA, the ray-casting process described in the previous section gives us the following information:⋅PkA⟵(i,s)if the ray intersects the interior of B, orPkA⟵(i,s,j,t)if the ray intersects the boundary of B,Similarly, for eachPlBwe know:•PlB⟵(j,t)if the ray intersects the interior of A, orPlB⟵(j,t,i,s)if the ray intersects the boundary of A,The first step of our interface reconstruction method consists of grouping together and ordering the pointsPkAof face A so that each group describes a section of curve. Therefore, for each curveCiAwith a non-empty set of points associated to it, the pointsPkAare sorted by increasing value of their parameters. Then, whenever the distance between two successive points is larger than a thresholdε′, a new group is created. This may happen when two or more separate sections of the same curveCiAbelong to the interface boundary, e.g. see the two left-most boundary curves of face B in Fig. 6(a).Theoretically, a new group should be created as soon as one ray did not intersect the other face. Nevertheless, in order to account for numerical inaccuracies due to the initial sampling of rays along the boundary curves, we use a distance thresholdε′larger than the distance given by the initial sampling. In practice, we chooseε′to be 5 times larger than the distance in the initial sampling.The same procedure is applied to group adjacent pointsPlBin face B. Figs. 2(c), 7(c) and 8(c) show the group of points on three examples.The min and max parameter values of points in each group determine a section of a face boundary curve, which also bounds the interface. Thus each group of adjacent points may also be considered as a section of the interface boundary curve. But vice-versa, the interface boundary is composed only of a subset of the previously computed groups of points. There may be redundancy due to the fact that groups of points are partly overlapping when the points belong to the boundary of both faces. See green points in Fig. 6(b) or the circular hole in Fig. 8(c). These points generate in fact two groups, i.e. two curve sections for the same piece of boundary, one for face A and another for face B.First, redundancy is reduced by making the following observation. When both faces share a common section of boundary curve, it may be the case that one group of points in face A is completely included in another group of points in B. In that case we remove it, since the other group of points already includes this piece of interface boundary. In order to select among all groups of points complete subset of groups of points representing all boundaries of the same interface, we introduce a graph-based approach.A directed graph is defined as follows. All nodes in this graph are the groups of adjacent points. Two types of arcs are established in this graph:•Arcs between nodes in the same face. When two nodes correspond to adjacent sections of boundary curves of the same face, then an arc is established between the nodes, in the direction corresponding to the orientation of the curves. This information can be recovered from the B-Rep model of the face.Arcs between nodes in different faces. LetPkAbe the point with max parameter in a nodeNin face A. IfPkAcorresponds to a ray intersecting the boundary of B, then we know(i,s,j,t)wheretis the parameter of the closest point ofPkAinCjB. We then search for the unique nodeÑin face B, for whichtlies between the min and the max parameter of this node. An arc is established betweenNandÑ.An example of such a graph is shown in Fig. 7(d). It corresponds to the two components shown in Fig. 7(a) and (b). There are 12 nodes in this example. The nodes are colored according to the component from which the rays were casted to detect the intersection points. 4 nodes belong to the lower component in Fig. 7, and 8 nodes to the upper component. 8 arcs join nodes in different faces, and 4 arcs join nodes in the same face. Note that the two red nodes at the bottom correspond to different sections of the same boundary curve of the red component. In this example there is no redundancy, two nodes corresponds to sections of boundary curves that intersect in a single point. As a result the graph is a cycle.In general, the graph has at least one strongly connected component11In graph theory, a directed graph is said to be strongly connected, iff for every pair of nodesu,v, a directed path exists fromutovand fromvtou[21].corresponding to the outer boundary of the interface. Furthermore, additional strongly connected components appear for each hole (interior boundary) in the interface. Since a section of the interface’s boundary curve may belong to both faces, the connected components are not always cycles, as shown in Fig. 8(d). In all cases, a cycle can be extracted from any strongly connected component, since strongly connected directed graphs are cyclic. Once the graph is built, each interface boundary can be extracted as a cycle. We extract a cycle from each strongly connected component using the Algorithm 1. In this algorithm, priority is given to a successor node belonging to the same face as the first node. As a result, for the circular hole in the example of Fig. 8, this algorithm extracts cycles with all nodes belonging to the same face, e.g. two red of two yellow nodes.The interface boundaries are now extracted from the graph as cycles. Each node represents a curve section parameterized either in the B-Rep face A or the B-Rep face B. The last step of our reconstruction method consists of computing a B-Rep model of the interface surface. It is in fact a trimmed surface of both A and B. The interface can thus be parameterized either in the parameter domain of face A or B. If we choose the parameter domain of A, then each section of the boundary interface in B must be reparameterized in the parameter domain of A. This reparameterization is implemented using the OpenCascade library. In our implementation we choose to parameterize the interface using the parameter domain of the face which supports the largest number of nodes in the graph, in order to reduce the number of reparameterizations. For each node in the cycle, we store the parameterization directly in the B-Rep model if the corresponding curve section is defined in the chosen parameter domain, otherwise we reparameterize if it is defined in the parameter domain of the other face. Using this procedure, the outer boundary of the interface as well as all inner boundaries are entirely encoded in the B-Rep model, with the required orientation. If necessary, this model can be stored in a plain STEP file for downstream treatment in other systems.

@&#CONCLUSIONS@&#
