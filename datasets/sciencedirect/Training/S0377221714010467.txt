@&#MAIN-TITLE@&#
Inverse chromatic number problems in interval and permutation graphs

@&#HIGHLIGHTS@&#
highlightsWe define the inverse chromatic number problem in interval and permutation graphs.We provide some motivating models to illustrate the potential of this new topic.Inverse booking problem is strongly NP-hard and n-approximable.Inverse track assignment problem is polynomially solvable.The computational complexity is investigated for many variants.

@&#KEYPHRASES@&#
Inverse combinatorial optimization,Graph coloring,Interval graphs,Permutation graphs,

@&#ABSTRACT@&#
Given a graph G and a positive integer K, the inverse chromatic number problem consists in modifying the graph as little as possible so that it admits a chromatic number not greater than K. In this paper, we focus on the inverse chromatic number problem for certain classes of graphs. First, we discuss diverse possible versions and then focus on two application frameworks which motivate this problem in interval and permutation graphs: the inverse booking problem and the inverse track assignment problem. The inverse booking problem is closely related to some previously known scheduling problems; we propose new hardness results and polynomial cases. The inverse track assignment problem motivates our study of the inverse chromatic number problem in permutation graphs; we show how to solve in polynomial time a generalization of the problem with a bounded number of colors.

@&#INTRODUCTION@&#
In inverse combinatorial optimization, the goal is traditionally to modify as little as possible a given combinatorial optimization problem instance so as to make a fixed solution optimal in the modified instance. To this end, an instance Π of the combinatorial problem is associated with a parameter system w—most often a weight system—to be modified. Given such an instance Π(w) and a feasible solution X0, the inverse problem IΠ is defined (Ahuja and Orlin, 2001) as the problem to perturb the parameter system from w to w′ such that X0 becomes an optimal solution of the instance Π(w′), and the deviation ||w − w′|| is minimum under a fixed norm.Since Burton and Toint (1992) first investigated the inverse shortest path problem in the early 1990s, inverse combinatorial optimization has attracted the attention of the operations research community. It has been extensively studied for a variety of optimization problems. Many interesting results from both theoretical and practical points of view have been achieved (see, e.g., Ahuja and Orlin, 2001; Burkard, Pleschiutschnig, and Zhang, 2004; Liu and Ubhaya, 1997; Yang, Zhang, and Ma, 1997; Zhang and Cai, 1998; Zhang, Yang, and Cai, 1999). Many studies illustrate both the relevance of inverse combinatorial problems in operations research and the extent of theoretical interest in this family of difficult problems.Some interesting variants have been considered (Chung and Demange, 2008; Chung and Demange, 2012; Demange and Monnot, 2010). {0, 1}-inverse problems involve parameter systems with (0, 1) components in which the structure of an instance rather than just its weight system can change. For example, changing a vertex/edge weight from 1 to 0 is equivalent to deleting the related vertex/edge from the graph. Another variant, called the inverse number problem, specifies a target solution value instead of a solution. The goal is then to find, with minimum modification, a new instance with an optimal value not worse than the fixed target value.In this paper we discuss an inverse framework for minimum vertex coloring which ranks among the most popular combinatorial optimization problems in operations research. Given a graph G, one associates colors with vertices such that every two vertices linked by an edge differ in color. The objective is to minimize the number of colors. The optimal value is called the chromatic number of G, denoted by χ(G). Graph coloring has many applications in various domains, particularly in scheduling (see, e.g., Demange, Ekim, and de Werra, 2009; Demange, Ekim, Ries, and Tanasescu, 2015; de Werra, 1996; Yáñez and rez, 2003). Tasks with pairwise incompatibilities are given such that any set of pairwise compatible tasks can be performed during a time slot. The aim is to execute all tasks in the fewest time slots. Tasks are associated with vertices and incompatibilities with edges in the incompatibility graph, and all tasks performed within a time slot correspond to a color class.In the inverse case, fixing a solution (a fixed vertex coloring) appears to be less natural than fixing a target chromatic number for most graph coloring applications. As a consequence, the related inverse number problem (inverse chromatic number problem) seems more natural. In this paper, we introduce the inverse chromatic number problem, describe typical situations in applications that motivate use of this framework, and present computational complexity results. We also identify some known operations research problems that can be illustrated as inverse chromatic number models.The paper is organized as follows. In Section 2, we formulate the problem, compare it with similar optimization problems, and discuss the notion of inverse model. In Section 3, we describe an operations research problem called the inverse booking problem that relates to the inverse chromatic number problem in interval graphs and we present some hardness and approximation results. Some polynomially solvable cases are proposed in Section 4. In Section 5, we describe the inverse track assignment problem that relates to the inverse chromatic number problem for permutation graphs. We briefly discuss the tractability of this problem and that of one generalization. Finally, in Section 6, some suggestions for further study are discussed.The inverse chromatic number problem can be formally defined as follows: given a graph G and a positive integer K, the graph should be modified as little as possible in such a way that the chromatic number of the resulting graph becomes K or less. An instance of the decision version is (G, K, M), where M is a non negative number. The related question is whether there is a modification of at most M such that the modified graph has a chromatic number of at most K.In the inverse model, we specify how to modify the instance as well as how to measure the deviation. Different inverse models for the same problem obviously produce different inverse problems. Weight systems are most often modified (see, e.g., Ahuja and Orlin, 2001; Burton and Toint, 1992; Demange and Monnot, 2010). This inverse model is obviously not relevant to the usual graph coloring problems, which involve no weight system.For graph coloring, various types of graph modifications may be considered. Some examples of inverse models are discussed below. In addition, any kind of norm may be used to measure the deviation. Many studies in this domain have shown that the choice of norm drastically influences the results. Cost functions that are not norms could also be considered. The only condition is that the minimum value of the deviation measure must correspond to the unchanged instance. In this paper, we mainly restrict our focus to the L1 norm11The L1 norm is defined by∥x∥1=∑i=1n|xi|for a vector x of dimension n., unless otherwise specified. Other norms, in particular the L∞ norm22The L∞ norm is defined by ||x||∞ = max {|x1|, …, |xn|} for a vector x of dimension n., may be considered in future studies. When restricting to a specific class of graphs, one should take care that it is stable under the considered modification.At first glance, vertex deletion is one of the most natural models for the inverse chromatic number problem. Revisiting the previously mentioned scheduling application of minimum graph coloring, it consists in removing a minimum number of tasks such that the remaining tasks can be performed in K time slots. Then, the removed tasks can be externalized, with additional costs. This problem is equivalent to the maximum K-colorable subgraph problem which has been well studied. Given a graph G, the vertices not belonging to a maximum K-colorable subgraph of G are exactly the vertices to be deleted from G. Since the maximum K-colorable subgraph problem is polynomially solvable for comparability graphs, co-comparability graphs (Frank, 1980; Greene, 1976; Greene and Kleitman, 1976), and for split graphs if K is fixed (Yannakakis and Gavril, 1987), we obtain the following result:Proposition 1(1)The inverse chromatic number problem with vertex deletion can be solved in polynomial time for comparability graphs and co-comparability graphs, and the same holds for split graphs if K is a fixed integer.The inverse chromatic number problem with vertex deletion is NP-hard for split graphs if K is not fixed.The polynomial tractability of the inverse chromatic number problem for permutation and interval graphs immediately follows:Corollary 2The inverse chromatic number problem with vertex deletion is polynomially solvable for permutation and interval graphs.The inverse chromatic number problem with edge deletion consists in minimizing the number of conflicting edges (edges with both extremities of the same color) for a fixed number of colors. Conflicting edges must be removed in the inverse chromatic number problem with edge deletion. This problem is used in several studies using heuristic approaches to graph coloring (see, e.g., Galiniera and Hertz, 2006; Hertz and de Werra, 1990; Marmion, Blot, Jourdan, and Dhaenens, 2013).Both vertex- and edge-deletion models are particular cases of the so called vertex and edge deletion problems studied in Yannakakis (1978). From the computational point of view, these problems were shown to be very hard, even in very restrictive graph classes. We describe below alternative inverse models. In contrast to the previous examples, these models cannot be immediately described as usual graph optimization problems. The framework of inverse optimization is better suited for this purpose.Given a base set X and a familyFof parts of X,Fis the vertex set of the related intersection graph, with edges between two vertices if the related parts intersect each other. For such a graph, any modification strategy on the subsets of the base set brings a modification strategy on the graph. We present two illustrating examples below.Two well-known applications of graph coloring in some intersection graph classes are frequency allocation in telecommunication networks (see, e.g., Eisenblätter, Grötsche, and Koster, 2002) and wavelength assignment in optical networks (see, e.g., Zang, Jue, and Mukherjee, 2000). In the former problem, transmitters/receiver units are spread over a region. A frequency must be assigned to each unit, taking into account that the total number of frequencies is limited and that interferences may occur if the same frequency is assigned to close transmitters. In the most basic model, frequencies are integer numbers, and each transmitter is associated with a disk centered at the location of the unit with a radius representing its signal power. Then, two units corresponding to intersecting disks must be assigned different frequencies to avoid interference for a receptor located in the intersection. The resulting interference graph is the intersection graph of these disks, called a disk graph, and the problem is exactly the minimum coloring problem in this class. In the latter application, one is given an optical network (represented by a host graph) and a collection of paths, each linking two nodes in the network. Each path must be associated with a wavelength such that two paths with the same wavelength cannot share a common edge. Thus, assigning wavelengths to paths is a coloring problem in the edge-intersection graph of the paths: each path is a vertex, and two vertices are linked by an edge if the related paths have at least one edge in common.These two applications induce natural situations that can be described in terms of the inverse chromatic number problem. For the frequency allocation problem, suppose that the network of transmitters/receiver units requires more frequencies than are available. The signal power of some units may then be limited so as to avoid interference and make frequency allocation possible. However, this reduction in signal power should not affect regional coverage. Thus, a natural inverse model arises for which the radius system must be modified with an additional constraint on the coverage area. Using the L1-norm, the total power reduction is the primary objective, while using the L∞-norm minimizes the number of units with reduced signal power.For the wavelength assignment problem, if the number of different wavelengths is limited and no assignment is feasible, then modification of the routing of requests (paths) may be necessary in order to make it feasible. In the inverse model, the paths must be modified and the difference between two paths measured. For instance, using the Hamming distance allows us to minimize the number of links to be changed.In this paper, we examine interval graphs, one of the simplest classes of intersection graphs. We present in Section 3 an application of the minimum inverse chromatic number problem with these graphs.There are many other situations involving graph classes defined from a discrete structure like the set system for intersection graphs. Any method of modifying this structure induces an inverse model on the resulting graph. Permutation graphs, or the more general class of overlap graphs (see, e.g., Golumbic, 1980), provide an interesting example that we will consider in Section 5. These graphs can be defined from an interval system, as detailed in Section 5. Permutation graphs can be defined equally well from a permutation or a sequence of numbers. We present a motivating application that corresponds to a natural inverse model.For most graph coloring problems, the aim is to compute the chromatic number of a given graph. however, several problems have been considered with the aim of defining or modifying the graph so as to guarantee some properties of the chromatic number. The inverse chromatic number problem clearly belongs in this class. Another problem of this type is the so-called minimum selective coloring problem (Demange et al., 2015; Demange, Monnot, Petrica, and Ries, 2014). An instance of this problem is a graph whose vertex set is partitioned into p clusters, and the objective is to select one vertex per cluster so as to minimize the chromatic number of the subgraph induced by the selected vertices. In the decision version, the question is whether it is possible to select one vertex per cluster such that the induced subgraph has a chromatic number no more than k, for a fixed k. A weighted version can be defined by associating a cost with each vertex. The aim is to find a k-colorable graph of minimum cost with one vertex per cluster.In some cases, the inverse chromatic number problem can be reduced to a weighted selective graph coloring problem. Consider, for example, an inverse model based on some intersection graphs, as described above, with a modification strategy for each set of the original set system. For each vertex v of the intersection graph corresponding to a set Xv, we add all vertices associated with all possibilities of modifications for Xv. For instance, in the previously described model involving disk graphs, each possible radius of the disk associated with v will correspond to a new vertex. We draw an edge between two vertices if the related sets intersect. Then we consider as a cluster all vertices defined from v and associate each of them with a corresponding weight. Then, modifying the original graph can be accomplished by selecting one vertex per cluster in the new graph. The drawback of this method is that it requires enumerating all modifications of the original graph. Consequently, any inverse chromatic number problem may be transformed into a huge instance of weighted minimum selective coloring, even an infinite one. This reduction will be illustrated in Proposition 10(Section 3).Note that similar reductions could be established for many modification strategies, but not for all strategies, for instance, the edge deletion model.In Demange et al. (2015), the minimum selective coloring problem is motivated by several applications in various domains including wavelength assignment, frequency allocations, berth allocation, and scheduling. The two examples of the application of the minimum chromatic number problem described above (disk graphs and edge intersection graphs of paths) are inspired by applications of minimum selective coloring. Most applications of minimum selective coloring have variants using the inverse chromatic number formulation.A second close problem is the notion of blockers for the chromatic number introduced in Bazgan, Bentz, Picouleau, and Ries (2015). Given a graph and two integers d, ℓ, the problem is to decide whether it is possible to remove ℓ edges such that the chromatic number decreases by at least d. This problem is close to the inverse chromatic number problem within the edge deletion model. The only difference is that the aim is to decrease the chromatic number by a fixed value d instead of fixing a target chromatic number. These problems are equivalent in any graph classes for which minimum graph coloring is polynomial. For instance, the problem is polynomially solvable in split graphs and in complements of bipartite graphs if d is a fixed constant, and NP-hard in complements of bipartite graphs if d is not fixed Bazgan et al. (2015). We deduce immediately:Proposition 3The inverse chromatic number problem with edge deletion is NP-hard in complements of bipartite graphs and polynomially solvable in both complements of bipartite graphs and split graphs under the additional condition that |K − χ(G)| is bounded by a constant.The decision version of the minimum graph coloring problem (K-colorability) polynomially Karp reduces to the decision version of the inverse chromatic number problem. From an instance (G, K) of the former problem (G is a graph and K a number), one can construct an equivalent instance (G, K, M = 0) of the latter: the vertex coloring instance admits a chromatic number of at most K if and only if no modification is needed in the related instance of the inverse problem. Clearly, this reduction holds for any type of transformation and for any deviation measure satisfying the following two conditions: the measure has nonnegative values and is null if and only if nothing is changed in the instance. This is obviously the case in particular for any norm. Consequently, no matter how an instance is modified or measured, the inverse chromatic number problem is NP-hard in any class of graphs for which the graph coloring problem is NP-hard.Revisiting the examples described for the intersection graph, we note that graph coloring is known to be NP-hard in disk graphs, even if all radii are equal to 1 (Gräf, Stumpf, and Weißenfels, 1998). This is also true in edge intersection graphs of paths even if the host graph is a tree (Golumbic and Jamison, 1985). Both results hold even if the intersection model is given, which is natural in most applications involving these intersection graph classes. As a consequence, the related inverse models correspond to hard inverse chromatic number problems. The same holds in overlap graphs. However, graph coloring is well known to be polynomial in interval and permutation graphs. For these two cases, the status of the inverse chromatic number problem in terms of hardness cannot be so easily deduced. This issue will be addressed in Sections 3 and 5.We consider a set of intervals I1 = [a1, b1[, …, In= [an, bn[ of length p1, …, pn, each representing a reservation request for a resource33Depending on the underlying context, resources can include, for instance, machines, processors, rooms in a hotel booking system, etc.between two dates aiand bi, i ∈ {1, …, n}. It is assumed that there are more than K reservations overlapping at a single time slot, while only K identical resources are available. The task is then to rearrange the given intervals by translating some of them so that:(i)all intervals can be legally assigned to K identical parallel lines with no intersection between the intervals assigned to the same line, andthe translation cost under the L1 norm—the total discrepancy between the original and the new interval position vectors—is minimum.We call this problem the inverse booking problem, denoted by IBookK. When interval translations are allowed only to the right-hand side, the problem is denoted by IBookK, →. In addition, when interval lengths are restricted (e.g., unitary intervals (pi= 1) or equal length intervals (pi= p)), we use the following notation:IBookK,pi=1,IBookK,pi=1,→,IBookK,pi=p,andIBookK,pi=p,→. The case with K = 1 is denoted by IBookK = 1 with similar notations for all other versions.By definition, the inverse booking problem is a special case of the inverse chromatic number problem in interval graphs with specific modification rules (shifting intervals). The K parallel lines associated with resources represent the K different colors that are allowed in the graph coloring formulation.Inverse booking problems are closely related to job scheduling problems. This gives a new insight into this well-known class of scheduling problems. For K = 1, IBookK = 1 can be seen as a special case of the so-called total discrepancy problem (Garey, Tarjan, and Wilfong, 1988), which is a single machine job scheduling problem with tardiness and earliness costs. An interval Ii= [ai, bi[ corresponds to a non-preemptive job Jiwith a processing time p(Ji) = bi− ai= pi, a due date d(Ji) = bi, and a completion timec(Ji)=bi′. Translation of an interval to the right-hand side corresponds to tardinessTi=bi′−biof the job, and translation to the left-hand side means its earlinessEi=ai−ai′. So, using common scheduling notations, IBookK = 1 can be denoted by 1||∑i(Ei+ Ti). This problem was studied by Garey et al. (1988) and its complexity was recently revisited in Wan and Yuan (2013).Proposition 4(1)(Wan and Yuan (2013)) 1||∑i(Ei+ Ti) (thus, IBookK = 1) is NP-hard in the strong sense.(Garey et al. (1988)) 1||min maxi(Ei+ Ti) is polynomially solvable.The second item in Proposition 4 deals with the inverse booking problem under the L∞ norm and will be useful in what follows. In addition, IBookK = 1, → is equivalent to the minimum tardiness scheduling problem, denoted by 1|ri|∑iTi, for non-preemptive jobs with arbitrary release dates. Indeed, the left endpoint aiof each interval Iican be seen as the release date riof the job Ji: translations are permitted only to the right-hand side, meaning that no job can be started before its release date. For this problem, the following result is known (Kan, 1976):Proposition 5Kan, 19761|ri|∑iTi(thus, IBookK = 1, →) is strongly NP-hard.For any bounded integer K, IBookKand IBookK, → respectively correspond to the multiprocessor scheduling problem with tardiness and earliness costs, K||∑i(Ei+ Ti), and the problem with release dates and tardiness costs, K|ri|∑iTi.IBookK = 1 can also be viewed as the unweighted version of the so-called single machine just-in-time scheduling problem with earliness and tardiness costs, denoted by 1||∑i(ηiEi+ μiTi). In Müller-Hannemann and Sonnikow (2009), it is shown that no approximation ratio of the form O(cn) for a constant c can be guaranteed for this problem unlessP=NP. As the weights play a crucial role in the proof, the approximation behavior of the unweighted case is left as an open question. In what follows, we answer this question by showing that IBookK = 1 and IBookK = 1, → are both n-approximable, but not n1 − ɛ-approximable for any ɛ > 0.Proposition 6IBookK = 1 and IBookK = 1, → are n-approximable.This is an easy consequence of Proposition 4, which stated that IBookK = 1 under the L∞-norm can be solved in polynomial time. Since we have |v|∞ ≤ |v|1 ≤ n|v|∞ for every vector v of dimension n, we conclude that IBookK = 1 is n-approximable. The same result can be obtained for IBookK = 1, →.□A natural question is whether this approximation ratio of n can be improved. We provide a negative answer in Theorem 7. This result corroborates the NP-completeness results in the strong sense for IBookK = 1 (Wan and Yuan, 2013) and IBookK = 1, → (Kan, 1976), as mentioned in Corollary 8.Theorem 7Suppose that all interval lengths are bounded by a polynomial function.(1)There is no polynomial time approximation algorithm for IBookK = 1 or for IBookK = 1, → guaranteeing an approximation ratio of O(n1 − ε), ε > 0, unless P = NP.The same result holds even if the interval graph corresponding to the initial set of intervals is bipartite.44Even in the case where two machines are enough to process all jobs, the single machine scheduling problem is still difficult, and cannot be approximated within a ratio of O(n1 − ε), ε > 0.We use a polynomial-time reduction from 3-Partition. An instance of 3-Partition is given by a boundB∈N+and a finite set X = {x1, …, x3m} of 3m elements, each of sizes(xi)=di∈N+for i ∈ {1, …, 3m} such that B/4 < di< B/2 and∑i=13mdi=mB. A 3-partition instance is said to be positive if the xis can be partitioned into m disjoint groups of three elements, each summing exactly to B. We assume that the dis and B are bounded by a polynomial function. Under this assumption, 3-Partition is still NP-complete since 3-Partition is strongly NP-complete (Garey and Johnson, 1979).For the conciseness of the proof, we first consider IBookK = 1, the proof for IBookK = 1, → being very similar.1. Let us fix two constants, c and ε > 0, and show that the considered problem cannot be approximated within a ratio of cn1 − ε. We assume that some interval lengths are given as rational numbers. Given an instance of 3-Partition with dis and B, we construct an instance of IBookK = 1 as follows (see Fig. 1).The instance is made up of m + 1 interval blocks, L0, L1, …, Lm, and 3m intervals, I1, …, I3m.•Each of the interval blocks Lj, j ∈ {0, 1, …, m}, consists of T = 3Q(m)m2B contiguous intervals,Lij=[lij,rij[,i ∈ {1, …, T}, of equal length. Q(m) is a fixed polynomial function to be defined later.The first and last interval blocks L0 and Lmare of total length T = 3Q(m)m2B, i.e., each interval belonging to L0 or Lmhas a length of 1, while the total length of the other blocks L1, …, Lm − 1 equals B, i.e., each of L1, …, Lm − 1 consists of T contiguous intervals of length13Q(m)m2.The m + 1 blocks L0, L1, …, Lmare distributed along a horizontal line in this order with a space of length B between every two consecutive interval blocks. We set the right endpoint of L0 to 0:rT0=0. Each interval block can be written as follows:•for i ∈ {1, …, T},Li0=[−3Q(m)m2B+(i−1),−3Q(m)m2B+i[,for j ∈ {1, …, m − 1} and i ∈ {1, …, T},Lij=[(2j−1)B+i−13Q(m)m2,(2j−1)B+i3Q(m)m2[,for i ∈ {1, …, T},Lim=[(2m−1)B+(i−1),(2m−1)B+i[.The 3m elements of the 3-Partition instance are represented by 3m intervals Ii= [ − di, 0[, i ∈ {1, …, 3m}, of length di.Since B is bounded by a polynomial function, the total number N of intervals clearly satisfies N ≤ P(m)Q(m) for a fixed polynomial function P. We then choose Q > c1/εP(1 − ε)/ε, implying cN1 − ε < Q(m).We will show that, in the case where the 3-partition instance admits a positive answer, we have β ≤ 3m2B, where β is the optimal value of the constructed IBookK = 1 instance. In the opposite case, we have β ≥ 3Q(m)m2B. We then conclude that no polynomial-time algorithm guarantees the ratio ρ(n), where n is the number of intervals.Let us first consider the case where a 3-partition exists for the original instance: the set X can be partitioned into m disjoint 3-sets X1, …, Xmsuch that for any j ∈ {1, …, m},∑x∈Xjs(x)=B. By renumbering the intervals Iis (i ∈ {1, …, 3m}), we may assume without loss of generality that for j ∈ {1, …, m}, three elements of Xjcorrespond to intervals I3j − 2, I3j − 1 and I3j, respectively. Let us denote byBj=[rTj−1,l1j[,j ∈ {1, …, m}, the space between Lj − 1 and Ljof length B. Each Bjcan be filled up with three intervals I3j − 2, I3j − 1 and I3jfor any j ∈ {1, …, m}. Translating I3j − 2, I3j − 1 and I3jto the right-hand side at least by (2j − 2)B and at most by (2j − 1)B yields a feasible solution for IBookK = 1 of a value not greater than 3m2B. Hence, we have β ≤ 3m2B.Suppose now that there is no 3-partition for X. In this case, the 3m intervals Iis cannot all be inserted within the spaces Bjs. In order to have all the intervals stand in line, at least one of the following two actions should be conducted: (i) shifting some Iis either to the left-hand side of L0 or to the right-hand side of Lm, and (ii) widening some Bjs at least by 1 (sincedi∈Nfor i ∈ {1, …, 3m}). Since the interval blocks L0 and Lmare of total length T = 3Q(m)m2B, action (i) yields a cost of (at least) 3Q(m)m2B. To widen some Bjs, one needs to shift some block Lj, j ∈ {0, …, m}, at least by a distance of 1 to the left- or right-hand side. Since each interval block is composed of T = 3Q(m)m2B small intervals, such an action yields a cost of at least 3Q(m)m2B. Hence, we have β ≥ 3Q(m)m2B.Assume that there is a polynomial-time approximation algorithm for IBookK = 1 which guarantees the approximation ratio ρ(n) ≤ cn1 − ε for any ε > 0, where c is a constant and n is the number of intervals of the instance. In case of a 3-partition (β ≤ 3m2B), this algorithm delivers a solution for the IBookK = 1 instance with N intervals of value λ ≤ 3m2Bρ(N) ≤ 3cN1 − εm2B < 3Q(m)m2B (recall that cN1 − ε < Q(m)). In the opposite case where no 3-partition exists, the algorithm returns a solution of value λ ≥ β ≥ 3Q(m)m2B. This implies the existence of a polynomial-time algorithm which solves 3-Partition, contradicting the strong NP-completeness of 3-Partition.2. In the previous construction, the related interval graph (see Fig. 1) is (3m + 1)-colorable. Based on the same structure, we construct a 2-colorable instance of IBookK = 1 by repositioning the 3m intervals Ii= [ai, bi[, 1 ≤ i ≤ 3m, in such a way that bi + 1 = ai, i ∈ {1, …, 3m − 1} and b1 = 0. We assume without loss of generality that d1 ≤ d2 ≤ ⋅⋅⋅ ≤ d3m, where di= bi− aifor i ∈ {1, …, 3m}.Taking into account these changes,55In comparison with the previous construction, intervals Iis are shifted to the left-hand side byD=d1+(d1+d2)+⋯+(d1+⋯+d3m−1)=(3m−1)d1+(3m−2)d2+⋯+2d3m−2+d3m−1≤32m2B.we assume that each of the interval blocks L1, …, Lm − 1 consists of 5Q(m)m2B intervals of length15Q(m)m2,and that block Lmconsists of 5Q(m)m2B intervals of length 1. To ensure that no interval Ii, 1 ≤ i ≤ 3m will be shifted to the left-hand side of the block L0, we increase the total length of L0 to 8Q(m)m2B. As in the previous case, the polynomial function Q is chosen so that the number N of intervals satisfies cN1 − ε < Q(m). If there is a polynomial-time approximation algorithm for IBookK = 1, guaranteeing the ratio O(n1 − ε), ε > 0, then it would deliver a solution of value λ < 5Q(m)m2B for the case where a 3-partition exists (β ≤ 3m2B + X0 ≤ 5m2B) and a solution of value λ ≥ 5Q(m)m2B for the opposite case. Such an algorithm would solve 3-Partition, which is impossible unless P=NP. Hence, IBookK = 1 with the bipartite constraint cannot be approximated within the ratio of O(n1 − ε), ε > 0.Recall that some interval lengths are defined as rational numbers. By multiplying all interval lengths by the same number (e.g., 3Q(m)m2 and 5Q(m)m2 for Proofs (1) and (2), respectively), we can easily obtain an instance with integer data. The value of each solution should also be multiplied by this common value.Finally, an instance of IBookK = 1, → can be constructed in a similar way (but in this case, L0 can be replaced by a single unit interval). The same arguments hold for this case, which concludes the proof of the theorem.□The strong NP-hardness of 1||∑i(Ei+ Ti) (IBookK = 1) (Wan and Yuan, 2013) and of 1|ri|∑iTi(IBookK = 1, →) (Kan, 1976) can be obtained as a direct corollary:Corollary 8For every K ≥ 1, IBookKand IBookK, → are strongly NP-hard.In the proof of Theorem 7, we show that the 3-partition problem with dis and B bounded by a polynomial function polynomially reduces to IBookK = 1 and IBookK = 1, →. In addition, all numbers involved in the constructed instances of IBookK = 1 and IBookK = 1, → are bounded by a polynomial function. This implies that both problems are NP-hard in a strong sense. Obviously, this result also holds for any fixed value of K ≥ 1.□As a natural extension, we investigate the particular case of IBookK, → where there is only a constant number of different interval lengths. For brevity, the proof for the following proposition is given in Appendix A.Proposition 9If all interval lengths belong to the set {1, 2, 5, 7, 9, L, L + 3, 8L + 5}, whereL∈Nis a polynomial function depending on n, then IBookK, → is NP-hard.Previously, we pointed out the equivalence between inverse booking problems and scheduling problems. Indeed, IBookK = 1 is equivalent to the total discrepancy problem K = 1||∑i(Ei+ Ti), and IBookK ≥ 1, → is equivalent to the multiprocessor scheduling problem with release dates, K|ri|∑iTi. These equivalences lead to some polynomial results for the inverse booking problem and its variants. In particular, if job processing times are all equal, then the problem K = 1|pi= p|∑i(Ei+ Ti) (hence,IBookK=1,pi=p) can be solved in polynomial time (Garey et al., 1988), even with rational value starting dates (Verma and Dessouky, 1998).In addition, Baptiste (2000) showed that when all job processing times are equal, K|pi= p, ri|∑iTi(and henceIBookK→,pi=p) can be solved in polynomial time for any fixed K ≥ 1. The related complexity is (O(|V|3K + 2), which was improved in Brucker and Kravchenko (2005) using a linear programming approach. Moreover, if all processing times are equal to 1, it is well known that a common flow approach can be applied for K|pi= 1, ri|∑iTi(see, e.g., Baptiste and Brucker, 2004), even in a weighted case or one with more general objectives that can be expressed as the sum of non-decreasing functions of completion times. A similar approach can be taken for K|pi= 1, ri|∑i(Ei+ Ti), and thus forIBookK,pi=1(see Brucker, 1995). These results are now very familiar. Explicit proof is provided in Proposition 10, which allows us to evaluate the related complexity. Note that even a weighted version of the results with specific translation costs (not considered here) can be obtained by the same method.For the rest of this section, we restrict our investigation to intervals of length 1. Thus, an interval system is entirely defined by a position vectorI0=(a1,…,an),each component ai, i ∈ {1, …, n} denoting the left endpoint of the ith interval. Without loss of generality, we assume that a1 ≤ ⋅⋅⋅ ≤ ai≤ ⋅⋅⋅ ≤ an.Proposition 10See Baptiste and Brucker, 2004; Brucker, 1995If interval lengths are all equal to 1 and their endpoints have integer values, then for any K,IBookK,pi=1andIBookK,pi=1,→can be solved in time O(n4log n). Equivalently, this holds for K|pi= 1|∑i(Ei+ Ti) and K|pi= 1, ri|∑iTi.We sketch the proof using a very classical method. We denote byK={1,…,K}the set of K lines. Without loss of generality, we can assume K < n since, in the opposite case, the optimal value of the instance is zero. Consider a setIof n intervals Ii= [ai, ai+ 1[, i ∈ {1, …, n}, such thatai∈Z,i ∈ {1, …, n}, and a1 ≤ ⋅⋅⋅ ≤ ai≤ ⋅⋅⋅ ≤ an. Let (a1, …, an) be the related position vector. Every optimal solution(a1*,…,an*)forIBookK,pi=1satisfiesai*∈Z,i ∈ {1, …, n}. A feasible solution with integer endpoints can be defined by specifying a state(i, q, k) for every interval i ∈ {1, …, n}, whereq∈Zandk∈K. The state (i, q, k) indicates that the ith interval Iiis translated by distanceq∈Zand is assigned to the kth line fork∈K.Note that in any optimal solution, no interval is translated by more than⌈n2K⌉. Indeed, suppose that an interval Ii= [ai, ai+ 1[ is translated by distanceD∈Z. Then, excluding Ii, there are 2D − 1 intervals [xi, xi+ 1[ with xi∈ {ai− D + 1, …, ai+ D − 1} on each of the K lines; otherwise one can obtain a better solution by translating Ii= [ai, ai+ 1[ by distance D′ < D. So, the total number n of intervals is at least K(2D − 1) + 1, which implies thatD≤⌈n2K⌉. Consequently, we can restrict ourselves to the set of statesS=I×{−⌈n2K⌉,…,⌈n2K⌉}×K.So, for every intervalIi∈I,we denote byAi={ai+q,q∈{−⌈n2K⌉,…,⌈n2K⌉}}the set of all possible left endpoints of Iiafter translation. LetA=⋃i∈{1,…,n}Ai. We construct an edge-weighted bipartite graphB˜=(I∪(A×K),E˜B)with complete connections between IiandAi×K. There is a one-to-one correspondence between edges inE˜Band all possible states inS. As K ≤ n,|S|=|E˜B|=O(n2). We then define an edge-weight function, assigning the weight |q| to the edge associated with state (i, q, k). This corresponds to the translation cost of the related interval.Then, the problemIBookK,pi=1reduces to the computation of a minimum weight matching of size n inB˜,which can be solved by the Hungarian method in time O(|V|(|E| + |V|log |V|)), where |V| is the number of vertices and |E| is the number of edges in the bipartite graph (Schrijver, 2003). SinceB˜has at most O(n2) vertices and O(n2) edges,IBookK,pi=1can be solved in time O(n4log n). For the case where translations are only allowed to the right-hand side, we restrict the allowable translation distance q to the values in{0,…,⌊nK⌋},obtaining the same result forIBookK,pi=1,→.□As the main focus of this section, we provide a polynomial case that generalizes the cases mentioned earlier. We show that the problem IBookK, → with a fixed number ℓ of different interval lengths p1, …, pℓ that are all bounded by a polynomial function can be solved in polynomial time for a fixed number K of lines. To our knowledge, this polynomial case is heretofore unknown. The main difference from the hard case stated in Proposition 9 is that the number of lines (machines) is bounded.We consider p1, …, pℓ to be the possible values of interval lengths, all being bounded by a polynomial function with respect to the number n of intervals. For any j ∈ {1, …, ℓ}, let njbe the number of intervals of length pj. We then haven=∑j=1ℓnj. For any j ∈ {1, …, ℓ} and i ∈ {1, …, nj}, letaijbe the initial left endpoint of intervalIijof length pj, and we denote by(aij)i∈{1,…,nj},j∈{1,…,ℓ}the initial position vector. We assume thata1j≤⋯≤aij≤⋯≤anjjfor every j ∈ {1, …, ℓ}. We suppose that all entriesaij,i∈{1,…,nj},j∈{1,…,ℓ},and lengths pj, j ∈ {1, …, ℓ} are integers. Without loss of generality, we assume that for any j ∈ {1, …, ℓ} and i ∈ {1, …, nj},aij∈N,pj∈N,andmini,jaij=0.Similarly, we denote by(fij)j∈{1,…,ℓ},i∈{1,…,nj}any position vector associated with a feasible solution for the given instance. By definition of the problem IBookK, →, we havefij≥aijfor every j ∈ {1, …, ℓ} and i ∈ {1, …, nj}.Definition 1A feasible position vector(fij)j∈{1,…,ℓ},i∈{1,…,nj}is said to be monotonous iff1j≤⋯≤fij≤⋯≤fnjjfor every j ∈ {1, …, ℓ} and i ∈ {1, …, nj}.Note that for any non-monotonous feasible solution, if for a given j0 ∈ {1, …, ℓ} we haveai1j0≤ai2j0andfi1j0>fi2j0,then definingf˜i1j0=fi2j0,f˜i2j0=fi1j0,andf˜ij=fijfor all other (i, j) ≠ (i1, j0), (i2, j0), we get a new feasible solution of better value. So we have:Lemma 11If there exists an optimal solution for IBookK, →, then there is a monotonous optimal solution.In addition, we can assume the following restrictions on position vectors.Lemma 12Without loss of generality, we can restrict ourselves to position vectors satisfying, for every j ∈ {1, …, ℓ} and i ∈ {1, …, nj},fij∈{aij,aij+1,…,aij+(n−1)L},where n is the total number of intervals and L is the maximum interval length.Consider indeed a feasible position vector(fij)j∈{1,…,ℓ},i∈{1,…,nj}withfi0j0>ai0j0+(n−1)Lfor some i0 and j0 (the intervalIi0j0is translated by more than (n − 1)L). Suppose thatIi0j0is assigned to line k. Denote by A the set of all intervalsIstallocated to line k and such thatfst≥ai0j0,(s,t)≠(i0,j0). It would be less costly to insertIi0j0on line k at the first available position after shifting all intervals in A bypj0≤L. More precisely, denote byb=max{fij+pj|Iijassigned to line k andfij<ai0j0}the largest right-hand point of intervals assigned to line k and positioned beforeai0j0. We then definef˜i0j0=max(ai0j0,b); for everyIst∈A,f˜st=fst+pj0and for all other intervalsIij,we posef˜ij=fij. The new position vectorf˜is feasible and less costly than f.□As an immediate consequence, one can assume that the distance between two consecutiveaijs is no more than (n − 1)L. If this is not the case, then the instance can be split into two independent sub-instances.A consequence of Lemma 12 is that ∀j ∈ {1, …, ℓ}, i ∈ {1, …, nj} we havefij≤n2L. Indeed, assuming that (i)mini,j(aij)=0,(ii) the distance between two consecutiveaijs is at most (n − 1)L and (iii)∀i,j,fij≤aij+(n−1)L,we getmaxi,jfij≤n(L+(n−1)L)=n2L.We then design a dynamic programming algorithm as follows. For kj≤ nj, qr∈ {0, …, (n2 + 1)L} and tr∈ {1, …, ℓ}, with j ∈ {1, …, ℓ} and r ∈ {1, …, K}, we denote by S(k1, …, kℓ, q1, …, qK, t1, …, tK) the set of all (partial) solutions where, for every j ∈ {1, …, ℓ}, the kjintervalsIij,i∈{1,…,kj}of length pjare monotonously positioned on K lines, and the right-most interval assigned to line r ∈ {1, …, K} ends at qrand has lengthptr.We denote by S(k1, …, kℓ, q1, …, qK, t1, …, tK) the state of the interval system such that the first kj≤ njintervals of length pjare already positioned.If S(k1, …, kℓ, q1, …, qK, t1, …, tK) = ∅, then we set V(k1, …, kℓ, q1, …, qK, t1, …, tK) = +∞. With these notations, the optimal value of the considered instance is then:min(q1,…,qK,t1,…,tK)∈{0,…,n2L}K×{1,…,ℓ}KV(n1,…,nℓ,q1,…,qK,t1,…,tK)In the dynamic programming process, the induction is maid on∑j=1ℓkj. The main step is explained in Lemma 13.Let SN= {S(k1, …, kℓ, q1, …, qK, t1, … + tK)|k1 + …, kℓ ≤ N} be the set of states for which the total number of intervals already positioned is at most N. We have: |SN| ≤ Nℓ((n2 + 1)L)KℓK≤ O(LKnℓ + 2K) for fixed constants ℓ and K.Lemma 13Suppose thatV(k1′,…,kℓ′,q1′,…,qK′,t1′,…,tK′)is known for all(k1′,…,kℓ′)such thatk1′+…+kℓ′≤N,and for all(q1′,…,qK′,t1′,…,tK′). Then, Algorithm 1computes all values of V(k1, …, kℓ, q1, …, qK, t1, …, tK) for k1 + ⋅⋅⋅ + kℓ = N + 1. It runs in time O(n2L) if K and ℓ are fixed constants.Letr¯,1≤r¯≤Kbe the line such thatqr¯=max{q1,…,qK}. Algorithm 1 considers every possible state obtained from S(k1, …, kℓ, q1, …, qK, t1, …, tK) by removing the intervalIktr¯tr¯,and computes (see Line 3) the best solution value V(k1, …, kℓ, q1, …, qK, t1, …, tK). Regarding the complexity, Line 1 requires a constant time and Line 3 requires O(n2L) time if K and ℓ are fixed constants.□Using Lemma 13, an algorithm is immediately obtained that computes all values of V(k1, …, kℓ, q1, …, qK, t1, …, tK). For any given ℓ and K, the related complexity isO(∑N=1n|SN|n2L)=O(nℓ+2K+3L1+K). So, if ℓ and K are fixed constants and L is a polynomial function of n, then the related complexity is polynomial. This leads to the following theorem:Theorem 14BookK, → can be solved in polynomial time under the following conditions: all parameters have integer values, the number of different interval lengths and the number of parallel lines are fixed, and the maximum interval length is bounded by a polynomial function.Let us consider the following track assignment problem described in Brucker and Nordmann (1994): in a train depot, trains should be stored during the night on some tracks. Each track may contain several trains organized as a stack according to the First In Last Out rule: the train entering last on the track must leave first the next morning. So, on each track, trains must be stored in the order of their arrival time and in the reverse order of their departure time. Such an assignment is called legal. It is assumed that, at a given time (e.g., midnight), all trains are stored on tracks. This is called the midnight condition. The minimum track assignment problem consists in finding a legal assignment using the minimum number of parallel tracks.For an inverse version of this problem, suppose that there are n trains and K tracks. The arrival and departure times of each train are known. If no legal assignment exists, then the departure times must be modified as little as possible so that n trains with new departure times can be legally assigned to K tracks.One can represent each train on a two-dimensional lattice plan with the arrival times on the x-axis and the departure times in reverse order or the complements of the departure times with respect to a fixed time (e.g., 12 a.m. in Fig. 2) on the y-axis. An example schedule and the lattice representation are given in Table 1and Fig. 2, respectively.Given this schedule and its lattice representation, there is a legal assignment of n trains to K tracks if and only if the different points in the lattice representation can be partitioned into K non-decreasing subsequences. So, the inverse track assignment problem involves modifying as little as possible the values of y-coordinates so as to obtain at most K non-decreasing subsequences in the lattice representation.This problem can be represented using a permutation graph. A permutation graph (Golumbic, 1980) is usually constructed from a permutation, but it can also be constructed from a sequence (π = (π1, …, πn)) of numbers: each vertex corresponds to one number in the sequence, and two vertices corresponding to πiand πjare connected by an edge if i < j and πi> πj. Such a graph can be equivalently represented by a listL=(P1,…,Pn)of points, Pi= (xi, yi), with x-coordinate xiand y-coordinate yiin the two-dimensional plan.In this permutation graph representation, a stable set is a set of vertices inLthat are in non-decreasing order (vertices along a vertical or horizontal line are listed in non-decreasing order), while a clique is either a single vertex or vertices in decreasing order. The graph is K-colorable if and only if the setLcan be divided into at most K non-decreasing subsequences. Using this model, the inverse track assignment problem corresponds to a particular case of the inverse chromatic number problem in permutation graphs. The task consists in modifying the y-coordinates in a fixed lattice representation. By assuming that y-coordinates can only be decreased, one can define a variant of the inverse track assignment problem where train departures can only be delayed. Here, we use the L1-norm to measure a modification of the instance, but other norms can also be used. For the example corresponding to Table 1 and K = 2, an optimal modification is given in Fig. 3that corresponds to delaying the departure time of train T2 by 30 minutes and the departure time of train T4 by 15 minutes. The total cost is then 45 minutes.If the midnight condition is not assumed, then the problem becomes an inverse chromatic number problem in a larger class of graphs, called overlap graphs. Given n intervals associated with n trains, an overlap graph (Golumbic, 1980) is defined as follows: each vertex represents an interval during which the related train must be stored in the depot, and two vertices are joined by an edge if and only if the two corresponding intervals overlap, but they do not properly contain each other. If the midnight condition is satisfied (all intervals share a common point), then the resulting overlap graph is a permutation graph. The minimum k-colorability problem is known to be NP-complete in overlap graphs (Garey, Johnson, Miller, and Papadimitriou, 1980). As mentioned in Introduction, this implies that the related inverse chromatic number problem is NP-hard.Corollary 15The inverse track assignment problem without the midnight condition is NP-hard.Here, we consider a generalization of the inverse chromatic number problem called the inverse (p, k)-colorability problem, and denoted by ICOL(p, k). The case with p = 0 and k = K corresponds to the inverse track assignment problem. Given a permutation graph defined by a lattice representationL,the problem consists in modifying as little as possible the y-coordinates, fromLtoL′,in such a way thatL′can be partitioned into p decreasing subsequences and k non-decreasing subsequences. A single vertex can be considered as either a decreasing or non-increasing subsequence. Equivalently, the graphG[L′]associated withL′can be partitioned into p cliques and k stable sets (i.e., it admits a (p, k)-coloring).We propose a dynamic programming algorithm for solving ICOL(p, k). Given an instance defined by a listL=(P1,…,Pn),with Pi= (xi, yi), we denote by Y the set of y-coordinates. Without loss of generality we assume thatLis in non-decreasing lexicographic order: x1 ≤ ⋅⋅⋅, ≤xn, and if xi= xi + 1, 1 ≤ i < n, then yi + 1 ≥ yi. We then see that there is always an optimal solution with modified y-coordinates in Y.For any integer t ≤ n, letL[t]=(P1,…,Pt)(L=L[n]) and letL′[t]=(P1′,…,Pt′),withPi′=(xi,yi′)andyi′∈Ydenoting any modified list. We denote by Ci, i ∈ {1, …, p}, a decreasing subsequence ofL[t]and by Sj, j ∈ {1, …, k}, a non-decreasing subsequence ofL[t]. For any subsetτ⊂L[t]ofL[t],we denote by min (τ) and max (τ) the minimum and maximum y-coordinate of the elements in τ, respectively. In addition, by denotingL′[t]=⋃1≤i≤pCi∪⋃1≤j≤kSj,we mean thatL′[t]is covered by p decreasing subsequences C1, …, Cpand k non-decreasing subsequences S1, …, Sk. LetT={(Ap,Bk)=(a1,…,ap,b1,…,bk)∈Yp+k}be the set of vectors of dimension (p + k) with coordinates in Y. We have|T|=O(np+k). With any decompositionL′[t]=⋃1≤i≤pCi∪⋃1≤j≤kSjofL[t],we associate the vector(Ap,Bk)∈Tsuch that ∀i ∈ {1, …, p}, ai= min (Ci) and ∀j ∈ {1, …, k}, bj= max (Sj).For any integer t such that p + k ≤ t ≤ n, and any fixed vector(Ap,Bk)∈T,we consider the problem Pt(Ap, Bk), defined as follows:Pt(Ap,Bk){min∑1≤h≤t|yh−yh′|s.t.L′[t]=C1∪…∪Cp∪S1∪…∪Skai=min(Ci),∀i∈{1,…,p}bj=max(Sj),∀j∈{1,…,k}where yhis the y-coordinate of the hth element inL[t]andyh′is the y-coordinate of the hth element inL′[t]. Let v(Pt(Ap, Bk)) be the minimum value of Pt(Ap, Bk). For any i ∈ {1, …, p} and j ∈ {1, …, k}, let us define f(i) and g(j) as follows:f(i)=|yt+1−ai|+min{ui≥ai}v(Pt(a1,…,ai−1,ui,ai+1,…,ap,b1,…,bk))g(j)=|yt+1−bj|+min{vj≤bj}v(Pt(a1,…,ap,b1,…,bj−1,vj,bj+1,…,bk)).Then, for any fixed vector(Ap,Bk)∈T,the inductive relation between Pt(Ap, Bk) and Pt + 1(Ap, Bk) can be expressed as follows:v(Pt+1(Ap,Bk))=min{min1≤i≤pf(i),min1≤j≤kg(j)},v(Pt(Ap,Bk))=0ift≤p+k.Then, the optimal solution value of ICOL(p, k) is given byv(Pn)=min(Ap,Bk)∈Tv(Pn(Ap,Bk)).Let us evaluate the worst-case running time required to compute the optimum value v(Pn) for a listLof n vertices. The values of v(Pt(Ap, Bk)) are stored in a table of size O(np + k + 1) (n lines and|T|=O(np+k)columns). For any fixed integer t ≤ n and any fixed vector(Ap,Bk)∈T,the optimal solution of Pt + 1(Ap, Bk) is obtained from a solution ofPt(Ap′,Bk′),(Ap′,Bk′)∈T,computed at the previous step. For this, we merely need the minimum among f(i), 1 ≤ i ≤ p and g(j), 1 ≤ j ≤ k, which requires O(n2) running time (since (p + k) ≤ n). So, for any fixed integer t ≤ n, computing all the tth line requires O(np + k + 2) running time. Since the table contains n lines, the overall running time is bounded by O(np + k + 3).Proposition 16If p and k are constant, then ICOL(p, k) can be solved in polynomial time in permutation graphs.For p = 0, we get:Corollary 17For any constant K, the inverse track assignment problem on K tracks under the midnight condition can be solved in polynomial time.In this paper, we introduced an inverse version of minimum graph coloring called the inverse chromatic number problem. We focused on two particular cases in interval and permutation graphs. For both cases, we described possible application frameworks and proposed some complexity results. We selected these two examples for two main reasons:(1)Since the inverse chromatic number problem is as hard as the k-colorability problem, we first focused on classes of graphs where minimum coloring is polynomial. The results in interval graphs demonstrate that, even in this case, the inverse chromatic number problem may be intractable.These two examples illustrate inverse models that cannot directly be represented by usual graph problems. Instead of modifying the given graph, we modify the interval system or the lattice representation associated with the given graph so that the resulting graph has a chromatic number of K or less.The inverse booking problem proved to be closely related to well-known scheduling problems. We presented improved hardness results in approximation and with a fixed number of interval sizes. Moreover, their presentation as inverse problems makes some new specific cases and generalizations relevant. In future studies, modifications of the interval system may be considered in which the interval length can be reduced at minimal cost, or intervals can be split into a fixed number of segments.As mentioned in Section 2, the inverse booking problem examined here immediately suggests similar problems in other classes of intersection graphs like disk graphs, edge-intersection graphs of paths, and intersection graphs of rectangles (see, e.g., the berth allocation problem presented in Demange et al., 2015) or circular arc graphs (i.e., intersection graphs of arcs). Since these classes induce hard coloring problems (Garey et al., 1980; Golumbic and Jamison, 1985; Gräf et al., 1998; Lee and Leung, 1984), one may expect them to generate very hard versions of the inverse chromatic number problem.To our knowledge, the inverse track assignment problem is new to the literature. We proved its tractability in polynomial time, however, the complexity remains open if the number of tracks is part of the problem instance. Here also, many generalizations can be made. Instead of changing the lattice representation of the graph, the interval system in the equivalent interval representation may be changed. Some modifications can be represented with the inverse model proposed here, while others induce alternative inverse models. Our model already considers the case of overlap graphs. Here also, because the minimum coloring problem is hard in this class (Garey et al., 1980), the related inverse problem is expected to be much harder than in permutation graphs.The minimum inverse chromatic number problem may be studied in other classes of graphs using specific graph modification strategies. The inverse number problems may be considered for other combinatorial optimization problems.

@&#CONCLUSIONS@&#
