@&#MAIN-TITLE@&#
Qualitative analysis of gene regulatory networks by temporal logic

@&#HIGHLIGHTS@&#
We propose a novel qualitative method for analysing gene networks based on formal verification technique.Behaviours and properties of networks are described in temporal logic formulae.By checking satisfiability of the formula, we can analyse properties of the network.To improve the efficiency of analysis we developed the modular and approximate method.

@&#KEYPHRASES@&#
Systems biology,Gene regulatory networks,Temporal logic,Reactive system verification,

@&#ABSTRACT@&#
In this article we propose a novel formalism to model and analyse gene regulatory networks using a well-established formal verification technique. We model the possible behaviours of networks by logical formulae in linear temporal logic (LTL). By checking the satisfiability of LTL, it is possible to check whether some or all behaviours satisfy a given biological property, which is difficult in quantitative analyses such as the ordinary differential equation approach. Owing to the complexity of LTL satisfiability checking, analysis of large networks is generally intractable in this method. To mitigate this computational difficulty, we developed two methods. One is a modular checking method where we divide a network into subnetworks, check them individually, and then integrate them. The other is an approximate analysis method in which we specify behaviours in simpler formulae which compress or expand the possible behaviours of networks. In the approximate method, we focused on network motifs and presented approximate specifications for them. We confirmed by experiments that both methods improved the analysis of large networks.

@&#INTRODUCTION@&#
One of the difficulties in analysing biological systems is the incompleteness of quantitative biological information, which hinders the mathematical analysis based on traditional thermodynamics models. In this respect, qualitative methods based on formal verification techniques have gathered good attention and several methods have been proposed with several different formalisms [14,17,9,8,42].In this article, we present a new constraint-based method for modelling and analysing gene regulatory networks (or simply gene networks). This method is based on the paradigm of verification of reactive system specifications [35,49,24]. Reactive system specification stipulates how the system should or can behave over time. There are several properties of reactive system specifications to be verified such as satisfiability, strong satisfiability and realisability [37,1,35].We found that dynamic behaviours of gene networks can also be qualitatively characterised similarly to the case of reactive systems, under the suitable abstraction. In our method, behaviours are abstracted to transition systems. A state in a transition system represents a configuration (state of affair) of a gene network at a certain time point, such as the expression levels of each gene and whether each gene is expressed or not. A state can be seen as a set of such facts that are true at a certain time point. Thus a transition system represents how the state of a gene network changes over time. In other words, a transition system represents a dynamic behaviour of a gene network. A fact of a state can be mathematically represented as a proposition. Then the problem of modelling possible behaviours of a gene network is reduced to give a suitable specification using these propositions. The possible behaviours of a gene network are transition systems which satisfy the specification. We show that such specification can be systematically obtained from a gene network using linear temporal logic (LTL) [16]. This corresponds to give a constraint that the ‘correct’ behaviour of a gene network should satisfy. Expected biological properties such as reachability, stability, oscillation or any other temporal properties about the timing of gene expressions are also described in LTL. The problem of analysing a property of a gene network is reduced to check the satisfiability of these formulae. Our first contribution is this conceptual framework of modelling behaviours of gene regulatory networks as LTL formulae and analyse biological properties by LTL-satisfiability checking.The complexity of LTL-satisfiability checking is PSPACE-complete [44], and known algorithms have exponential time complexity with respect to the length of an input formula. The length of a formula specifying possible behaviours of a network is proportional to the size of the network in our method. Therefore, some methods are strongly desirable which eases this computational cost. As such methods, we develop two methods – a modular method and an approximate method. These are the second and the third contributions in this article.In modular analysis method, a network is divided into several subnetworks. Since each specification of subnetworks is much smaller than that of the entire network, computation of the possible behaviours of each subnetwork is much faster. Furthermore, we can abstract local propositions (only used in the subnetwork) from each subnetwork behaviours. Then we integrate the possible behaviours of the subnetworks to obtain the behaviours of the entire network.In approximate analysis method, we specify the set of possible behaviours of (sub)networks without using some local propositions. Such specifications are simpler than the original specifications but are generally not equivalent, that is to say, they are approximate specifications of networks. There are two kinds of approximation. One is under-approximation in which possible behaviours are compressed, and the other is over-approximation in which possible behaviours are expanded. They can be used instead of the original specifications to check network properties, that is, if the approximate specifications are satisfiable/unsatisfiable then so are the original ones. As a result, the correctness of approximate analysis is theoretically guaranteed.It is not trivial to find approximate specifications for any networks. Therefore we consider some ‘templates’ of gene networks and give approximate specifications for them. As templates of gene networks, we can use network motifs [3], since they are network patterns that occur in many gene regulatory networks. The motifs we study in this article are negative auto-regulation, coherent type 1 feed-forward loops, incoherent type 1 feed-forward loops, single-input modules and multi-output feed-forward loops.This article is organised as follows. Section 2 introduces the logical structure which describes abstract behaviours of gene regulatory networks. In Section 3, we show how networks are qualitatively modelled and analysed by the LTL satisfiability checking. Then we demonstrate our method by analysing a network of circadian clock and a network for mucus production in Pseudomonas aeruginosa. In Section 4, we introduce the modular analysis method and prove the correctness of it. We demonstrate our modular method using example networks and discuss the results. In Section 5, we present the approximate analysis method and introduce approximate specifications for network motifs. We discuss experimental results of the approximate method. Furthermore, the experimental result of the combination of the modular method and the approximate method is reported. In Section 6, we compare our method to other qualitative analysis methods of biological systems. The final section offers some conclusions and discusses future directions.This article is a revised and extended version of our conference papers: [29,28,27]. We revised the modelling method, presented the formal proofs of our methods and added new experiments.A gene is a certain segment of DNA which encodes proteins. Proteins play essential roles in living organisms. Suitable concentration of each protein must be maintained for each cell to function properly. Proteins are known to exist a certain period of time and are eventually degraded. To maintain suitable concentration, proteins are produced through the process of gene expression. In the process of gene expression, genes are transcribed into messenger RNAs (mRNAs) by RNA polymerase. Then the mRNAs are transferred to ribosomes. Finally the ribosomes translate the mRNAs to proteins according to genetic code. Gene expression is regulated by proteins called transcription factors. Transcription factors bind to promoter regions of genes which are located on upstream regions of the genes and promote or block the recruitment of RNA polymerase (Fig. 1). Thus transcription factors regulate gene expression by changing the rate of transcription. There are two types of regulation – activation and inhibition. Activation means that the transcription factor increases the rate of gene expression. Inhibition is the opposite of activation – it decreases the rate of gene expression. Since transcription factors are proteins, they are also coded by some genes. Thus if a gene whose product is a transcription factor of another gene is expressed, that gene regulates another gene. Some transcription factors work with other transcription factors or proteins called co-regulators to regulate gene expression. Such regulation relations among genes are graphically represented as gene regulatory networks (or gene networks). An example of a gene network is given in Fig. 2.In gene regulation, a regulator is often inefficient below a threshold concentration, and its effect rapidly increases above this threshold [47]. The sigmoid nature of gene regulation is shown in Fig. 4, where gene u activates v and inhibits w (Fig. 3). Each axis represents the concentration of products for each gene.Some important landmark concentration values for u are 1) the basal level,11A gene is not expressed or expressed at very low rate.2) the leveluvat which u begins to affect v, and 3) the leveluwat which u begins to affect w. In this case, whether genes are active or not can be specified by the expression levels of their regulator genes. If the concentration of u exceedsuvthen v is active (ON), and if the concentration of u exceedsuwthen w is not active (OFF). We exploit this switching view of genes to capture behaviours in transition systems.We now illustrate how we capture behaviours of gene regulatory networks as transition systems using a simple example network (Fig. 5) in which gene x activates gene y and gene y activates gene z.Let the threshold of x for y bexyand that of y for z beyz. We consider the behaviour depicted in Fig. 6and try to express it as a transition system. In this behaviour, x begins to be expressed at timet0; that is, the concentration of its products begins to increase. At timet1, the concentration of the products of x exceedsxy, which is the threshold for the activation of y. Thus y begins to be expressed att1. At timet2, x stops being expressed and the concentration of its products begins to decrease. At timet3, the concentration of products of x falls belowxyand y stops being expressed; that is, the concentration of y begins to decrease. After a while, x begins to be expressed again at timet4and y begins to be expressed att5. In this case, y crosses the activation threshold for z at timet6and z begins to be expressed. Att7, x stops being expressed and begins to decrease. Att8, x falls belowxyand y stops being expressed. Att9, y falls belowyzand z stops being expressed, after which x, y and z stay at their basal levels.We introduce some logical propositions to obtain a symbolic representation of behaviours of this network. Based on the above observation, we introduce propositions that represent whether genes are active or not (ON or OFF) and whether concentrations of products of genes exceed their threshold values. In this network, we introduce the propositionsonx,ony,onz,xyandyz. The meaning of each proposition is:•onx,ony,onz: whether gene x, y and z is active.xy: whether the concentration of the products of x exceeds the thresholdxy.yz: whether the concentration of the products of y exceeds the thresholdyz.Using these propositions, we discretise the above behaviour to the sequence of states (called transition system) shown in Fig. 7, wheres0,…,s10are states, edges represent state transitions that abstract the temporal evolution of the system, and the propositions below each state mean that they are true in that state.States0represents the interval[0,t0), states1represents the interval[t0,t1), …and states10represents[t9,∞).A single state transition can represent any length of time, since the actual duration of the transition (in real time) is immaterial22This property is called speed independence[39].in this abstraction. Therefore, the difference betweent2−t0andt7−t4, the durations of the input signal to x in Fig. 6, are not captured directly in the transition system of Fig. 7. Only the order of events is important.In this abstraction, the real values of thresholds are also irrelevant. Propositions such asxymerely represent the fact that the concentration of x is above the level at which x activates y.In our abstraction, we think that behaviours are identical if they have the same transition system. Such logical abstraction preserves essential qualitative features of the dynamics such as oscillation, steady states, multistationarity, and reachability for such states [18,19,32]. However, we cannot reason about quantitative properties, such as rate of production/degradation of products, real values of concentrations, real-time durations, stability of oscillation and so on.In this section, we show how to model and analyse behaviours of gene regulatory networks using LTL, based on the conceptualisation of gene network and its behaviours introduced in the previous section.First we introduce Linear Temporal Logic (LTL) as our modelling language. LTL is a suitable language for describing temporal evolution of systems and is used in software/hardware system verifications [12]. In LTL we can specify various temporal properties on linear time structures like Fig. 7. In what follows, we present a formal definition of LTL.First we introduce the time structure of LTL. If A is a finite set,Aωdenotes the set of all infinite sequences on A. The i-th element ofσ∈Aωis denoted byσ[i].Definition 1Let AP be a set of atomic propositions. A time structure on AP is a sequenceσ∈P(AP)ωwhereP(AP)is the powerset of AP.We next define the syntax of LTL formulae.Definition 2Let AP be a set of atomic propositions. Propositionp∈APis a formula of LTL. If ϕ and ψ are formulae, then¬ϕ,ϕ∧ψand ϕUψ are also formulae of LTL.The formal semantics are given below.Definition 3Let σ be a time structure and ϕ be a formula of LTL. We writeσ⊨ϕfor ‘ϕ is true in σ’. The satisfaction relation ⊨ is defined inductively as follows.σ⊨piffp∈σ[0]forp∈APσ⊨¬ϕiffσ⊭ϕσ⊨ϕ∧ψiffσ⊨ϕandσ⊨ψσ⊨ϕUψiff(∃i≥0)(σi⊨ψand∀j(0≤j<i)σj⊨ϕ)whereσi=σ[i]σ[i+1]…, the i-th suffix of σ.We introduce the following abbreviations:⊥≡p∧¬pfor somep∈AP,⊤≡¬⊥,ϕ∨ψ≡¬(¬ϕ∧¬ψ),ϕ→ψ≡¬ϕ∨ψ,ϕ↔ψ≡(ϕ→ψ)∧(ψ→ϕ),Fϕ≡⊤Uϕ,Gϕ≡¬F¬ϕ, andϕWψ≡(ϕUψ)∨Gϕ, where ϕ and ψ are LTL formulae.Intuitively, Fϕ means ‘ϕ holds at some future time’, Gϕ means ‘ϕ holds globally’ and ϕUψ means ‘ϕ continues to hold until ψ holds’. ϕWψ is the ‘weak until’ operator in that ψ may not hold, in that case ϕ must always hold.Finally we introduce the notion of satisfiability.Definition 4An LTL formula ϕ is satisfiable if there exists a time structure σ such thatσ⊨ϕ. We say that σ is a model of ϕ ifσ⊨ϕ.As we can see in Section 2, a behaviour of a gene regulatory network can be seen as a time structure on atomic propositions. Let AP be the set of atomic propositions for describing states of a given network. Formally, a behaviour of a given network is an element ofP(AP)ω. However, not all of the sequences inP(AP)ωare possible behaviours of a given network. For example, in the network of Fig. 5, y cannot be ON before x becomes ON if y totally depends on x. Thus, possible behaviours of a network corresponds to a subset ofP(AP)ω.We are interested in analysing whether a given network behaves as expected or not. To answer this, we need to characterise possible behaviours of a network. In quantitative analysis, behaviours are usually described as ordinary differential equations. We, however, characterise the possible behaviours of a network in LTL based on the logical conceptualisation of network behaviours. A formula which characterises possible behaviours of a network is considered as a constraint which the possible behaviours of a network should satisfy. Suppose formula ϕ is the behaviour description of a given network, then the set of models of ϕ,{σ|σ⊨ϕ}, are the possible behaviours of the network.Now the problem of checking whether the behaviours of a given network satisfy a biological property is formulated in terms of LTL. We specify the given biological property as an LTL formula ψ. The first type of analysis is to check whether there is a behaviour of the network which satisfies a given biological property ψ. This problem is reduced to checking the satisfiability of the formulaϕ∧ψ, since∃σ.σ⊨ϕandσ⊨ψ⇔∃σ.σ⊨ϕ∧ψ.This means that there exists a sequence σ which is a possible behaviour of the network (i.e. satisfies ϕ) and satisfies the biological property ψ. The second type of analysis is to check whether all possible behaviours of the network satisfy a given biological property ψ. This problem is reduced to checking the unsatisfiability ofϕ∧¬ψ, since∀σ.σ⊨ϕimpliesσ⊨ψ⇔∀σ.σ⊨ϕ→ψ⇔∀σ.σ⊨¬ϕ∨ψ⇔∀σ.σ⊭ϕ∧¬ψ.This means if a sequence σ is possible in the network, then it necessarily satisfies the given biological property ψ.The scheme for qualitative analysis of behaviours of a given network is summed up as follows:1.Specify a formula ϕ that characterises possible behaviours of the network.Specify a formula ψ that represents a biological property of interest.Check the satisfiability ofϕ∧ψor unsatisfiability ofϕ∧¬ψ.Then we have the questions: how do we specify such behaviour specifications ϕ and what are properties ψ? We answer these questions in the subsequent sections.We show how we specify a characterisation of the possible behaviours of a given network in LTL. As in Section 2, we use the following propositions to specify it:•onufor each gene u in a given network. We interpretonuas ‘gene u is active’.uvfor each regulation from u to v in a given network. We interpretuvas ‘gene u is expressed beyond the threshold to activate/inhibit v’.The idea of specifying possible behaviours of a network is based on the following qualitative principle:•Genes are ON when their activators are expressed over some threshold.Genes are OFF when their inhibitors are expressed over some threshold.If genes are ON, the concentrations of their products increase.If genes are OFF, the concentrations of their products decrease.Now we show how to specify the above principles in LTL.First we consider the simple case in which a gene is regulated by a single gene. For example, let gene v be regulated only by u. If the effect of u on v is positive, then v is turned ON when the concentration of u exceeds the thresholduv. We have two choices to describe this phenomenon in LTL. One isG(uv→onv)and the other isG(uv↔onv).The former allowsonvto be true whenuvis not, but the latter does not. The former specification takes hidden activators or external regulation for v into account. In this case we do not consider hidden negative regulation to v since if we consider it, the relationship ‘gene u activates v’ is lost. The choice of which one we use depends on the system, the situation or the assumption.On the other hand, if the effect of u on v is negative, this case is described as:G(uv→¬onv)Similarly we can chooseG(uv↔¬onv)for the same reason.Now we consider a gene that is regulated by multiple genes. In general, the multivariate regulation functions of organisms are unknown [3]. Thus we only describe the trivial facts. For example, we assume that genes u and v activate x, and gene w inhibits x (Fig. 8). Then we have the following facts:•If u and v exceeduxandvxrespectively, and w does not exceedwx, then x is ON. This is described as follows:G((ux∧vx∧¬wx)→onx).If u and v do not exceeduxandvxrespectively, and w exceedswx, then x is OFF. This is described as follows:G((¬ux∧¬vx∧wx)→¬onx).Note that if we take contrapositive of the second formula, we haveG(onx→(ux∨vx∨¬wx)).Thus when gene x is ON, it is possible that both gene u and v are not effective. This means we do not exclude the possibility of hidden positive regulation to gene x. If we are to exclude it, we add the clauseG(onx→(ux∨vx)).For the same reason if we exclude the possibility of hidden negative regulation to gene x, we add the clauseG(¬onx→wx).If we know more information about the multivariate regulation function of gene x, we can reflect such facts in LTL specification. For example, if we know that the positive effect of u and v on x is disjunctive, we haveG(((ux∨vx)∧¬wx)→onx)for the condition of when gene x is ON. Or, if we know that the negative regulation effect of w is dominant and overpowers other positive effects, we haveG(wx→¬onx)for the condition of when gene x is OFF.We can introduce multiple expression levels for a single regulation relation. For example, in the relation ‘gene w inhibits gene x’ in Fig. 8, we may introduce two expression levels:wx0andwx1(wx0<wx1). These two levels of gene w represent the difference of power of inhibition to gene x. The levelwx0is a low expression level above which gene x is OFF if both gene u and v are not effective. The levelwx1is high expression level of gene w above which the negative effect of w overpowers both gene u and v. This can be described as follows:G((¬ux∧¬vx∧wx0)→¬onx),G(wx1→¬onx).Of course we can introduce more expression levels for gene w to finely capture the multiple regulation.In gene regulation, some genes regulate not genes but the regulation effect itself. For example some gene's product intercepts another gene's product, which causes the inhibition of the latter gene's regulation effect. Let us consider a case where x inhibits y and z inhibits the regulation effect of x on y. In this case y is turned OFF when x affects y but z does not affect the regulation. To describe this, we introduce a thresholdzxabove which z inhibits the effect of x (Fig. 9). We can describe this as follows:G((xy∧¬zx)→¬ony).In this case,zxmay not be a fixed value but should rather be considered as a function that takes the concentration of x and returns the threshold of z. The propositionzxsimply says that z influences the regulation effect of x and the real value of the concentration of z does not matter.Before introducing the description of concentration changes of gene products, we need to specify the fixed total order of threshold values. Since the concentration changes are described as ‘if a gene is ON, the concentration level will reach at the next level’. To specify this, we need to articulate what is the ‘next’ level in LTL. Assume that u regulatesx1,x2,…,xmand the threshold values for them are in this ascending order. This order relation can be described in LTL as follows:⋀1≤i<mG(uxi+1→uxi).For example,G(ux2→ux1)means that if the current expression level is beyond the thresholdux2, it is also beyondux1sinceux1is lower thanux2. Note that the propositionsux1andux2are interpreted as gene u is expressed beyond the thresholdux1andux2, respectively.If gene u is ON the concentration of its product increases over time. To specify this principle in LTL, we have two kinds of specification – a strong one and a weak one – depending on the strictness of increase. In the strong specification, if a gene is indefinitely ON (i.e. it never becomes OFF), the expression level strictly increases (i.e. reaches to the next level). In the weak specification, although a gene is indefinitely ON, the expression level can increase or keep its current level.In what follows, we assume that gene u regulates genesx1,x2, …,xmand the threshold values for them are in this ascending order.First we introduce the strong specification:(1)G(onu→F(¬onu∨ux1)),(2)G((onu∧ux1)→(ux1U(¬onu∨ux2))),(3)G((onu∧ux2)→(ux2U(¬onu∨ux3))),⋮(4)G((onu∧uxm−1)→(uxm−1U(¬onu∨uxm))),(5)G((onu∧uxm)→(uxmW¬onu)).To see what the above formula says, suppose that u is ON and its concentration is betweenux2andux3. Recall that the propositionuximeans the concentration of u exceeds the thresholduxi. Thus the left-hand sides of (1)–(3) in the above formula hold. From the specification on the total order of thresholds, ifux2is true thenux1is also true. Accordingly, (1)–(3) may be summed up as that concentration of u is not less thanux2until u is turned OFF, otherwise it eventually exceedsux3. Behaviours that satisfy this constraint have a starting concentration of u betweenux2andux3, and in some future the concentration of u exceedsux3but until that time it remains aboveux2(Fig. 10(a)). The exception is that u is turned OFF before reachingux3, so that u does not exceedux3(Fig. 10(b)). Behaviours in which u falls belowux2while being ON are excluded. Moreover, u is not allowed to remain betweenux2andux3indefinitely although it is ON. We consider such behaviours to be incorrect in the strong specification. If the concentration of u is basal, only (1) applies. If u is aboveuxm, which is the greatest threshold, then all clauses apply but are absorbed into (5). As a consequence, the above formula says that the expression level of u does not decrease as long as u is ON and must increase (unless the expression level of u is greater thanuxm) if u is always ON.Next we introduce the weak specification:G(onu→F(¬onu∨ux1)),G((onu∧ux1)→(ux1W¬onu)),G((onu∧ux2)→(ux2W¬onu)),⋮G((onu∧uxm)→(uxmW¬onu)).The difference compared with the strong specification is that behaviours in which u keeps its concentration even if it is always ON are allowed; that is, the concentration does not have to increase strictly. This represents a situation where generation and degradation are in equilibrium.This is symmetric to the case when genes are ON. We again assume that gene u regulatesx1,x2,…,xmand the threshold values are in this ascending order. We also have both a strong specification and a weak one.The strong specification is as follows:G(¬onu→F(onu∨¬uxm)),G((¬onu∧¬uxm)→(¬uxmU(onu∨¬uxm−1))),G((¬onu∧¬uxm−1)→(¬uxm−1U(onu∨¬uxm−2))),⋮G((¬onu∧¬ux2)→(¬ux2U(onu∨¬ux1))),G((¬onu∧¬ux1)→(¬ux1Wonu)).The weak specification is as follows:G(¬onu→F(onu∨¬uxm)),G((¬onu∧¬uxm)→(¬uxmWonu)),G((¬onu∧¬uxm−1)→(¬uxm−1Wonu)),⋮G((¬onu∧¬ux1)→(¬ux1Wonu)).In the strong specification, it is not possible that u keeps its concentration when it is always OFF but is possible in the weak specification.We make a comment on our interpretation of ‘increasing’ and ‘decreasing’ of gene expression levels. Let us consider a behaviour such that gene x is expressed between a thresholdx1andx2and gene x is ON, then finally gene x reachesx2. Such behaviour is represented as a time structure…{onx,x1}{onx,x1,x2}…. The natural interpretation of this behaviour is that gene x is expressed during the transition from the state{onx,x1}to{onx,x1,x2}. Another interpretation seems to be possible: a gene x once goes down (remaining overx1) before reachingx2(Fig. 11(a)). We, however, choose the first natural interpretation. The latter behaviour is represented as a different behaviour as shown in Fig. 11(b). Note that the discrete behaviour in Fig. 11(b) does not violate the behaviour principles described so far. As a result, the sentence ‘gene x is increasing (ON)’ is interpreted as its first derivative is positive. Similarly, ‘gene x is decreasing (OFF)’ is interpreted as its first derivative is negative.What about stuttering, i.e. the same state occurs successively many times? For example, in the discrete behaviour of Fig. 11(b), we may have the same state ass110 times betweens0ands1. Such behaviour is possible and does not violate the behaviour principles since our LTL does not use next-time operator ‘X’ and is stutter-invariant [36].The behavioural specification for a given network is the conjunction of all clauses which are derived according to the behaviour principles introduced this section. Note that all clauses is enclosed in ‘G’ operator. SinceGφ∧Gψ↔G(φ∧ψ)is an axiom of LTL, we can bind up all clauses in one ‘G’ operator.Many biologically interesting properties can be described in temporal logic [10,4,17]. For example, the property ‘the system eventually reaches a state in which gene x is active but gene y is not active’ is a type of reachability described asF(onx∧¬ony). The property ‘the concentration of x is always above the thresholdxy’ is a type of stability described asGxy. Oscillation, where ‘some property ϕ is alternately true and false indefinitely’, is described asGFϕ∧GF¬ϕ. Conditional properties can also be specified. For example, ‘if gene x is always OFF then the property ϕ holds’ is described as(G¬onx)→ϕ. Furthermore, we can use any combination of the above.We do not need to confine ourselves to the above templates. We can use full LTL to specify properties of interest.To see how an actual gene network is analysed in our framework, we demonstrate our method by the synthetic circadian clock [15] depicted in Fig. 12.We introduce the set of propositions{ona,onb,onc,ab,bc,ca}. Using these propositions, the behaviour specification of this network is given as follows.G(ab↔¬onb)∧G(bc↔¬onc)∧G(ca↔¬ona)∧G(ona→F(ab∨¬ona))∧G(ona∧ab→(abW¬ona))∧G(¬ona→F(¬ab∨ona))∧G(¬ona∧¬ab→(¬abWona))∧⋯In this specification, we assume that each gene can be expressed autonomously if the inhibitor is not effective.For this network let us check the property ‘each gene oscillates’, which is written in LTL as:GFona∧GF¬ona∧GFonb∧GF¬onb∧GFonc∧GF¬onc.The analysis is performed by checking the satisfiability of the conjunction of the above formula. There are several tools for checking satisfiability of LTL (see [40]). We used T3-builder [5] to check LTL satisfiability and had the answer ‘Yes’. This means that the network can produce the behaviour in which all genes oscillates.Then we have a question. Can all genes be always OFF? Let us check the property:G(¬ona∧¬onb∧¬onc).Then the result was ‘No’. This means it is impossible that all genes are indefinitely OFF (i.e. it never becomes ON).Another example is the analysis of the mucus production system in the bacteria Pseudomonas aeruginosa. P. aeruginosa produces a heavy mucus (alginate) in the lungs of cystic fibrosis patients, causing respiration deficiency and being the major cause of mortality [21]. Bacteria isolated from the lungs of such patients can form stable mucus colonies, with a majority of these bacteria presenting a mutation. Hence it is natural to think that the mutation is the cause of the transition to the mucoid state. However, we show that wild-type bacteria have multistationarity where one stable state regularly produces mucus while the other does not; that is to say, the change from the non-mucoid state to the mucoid state can be epigenetic (a stable change of phenotype without mutation). This example is borrowed from [9,22].The gene regulatory network that controls mucus production has been elucidated [43,23] and is depicted in Fig. 13. In this figure, z represents alginate synthesis (i.e. mucus production), x activates mucus production, and y is an inhibitor of x.We introduce the set of propositions{onx,ony,onz,xx,xy,xz,yx}, where z is not a gene, butonzmeans that mucus is produced.Among the thresholds for concentrations of x, it has been shown thatxzis the highest [23]. Thus there are two possibilities for the order,xx<xy<xzorxy<xx<xz. We have two specifications depending on the order of the thresholds. The behaviour specification for the orderxx<xy<xzis given in Fig. 14, where we chose the strong specification.The properties that should be checked are as follows:•The bacteria regularly produces mucus:Gonz.The bacteria never produces mucus:G¬onz.We check whether each property, in conjunction with the behavioural specification, is satisfiable. The result of checking is that both properties are satisfiable in both threshold orderings. Therefore, it is possible that the wild-type bacteria have both mucoid and non-mucoid behaviour. This result motivates us to verify this hypothesis experimentally.In the above analysis we do not constrain the multivariate regulation function for x which merges the inputs from x and y. That is, when both x and y are effective, x has a choice of active or inactive. Now we assume that the negative effect from y is superior to the positive effect from x. In this case the bacteria may not become mucoid state sincexy<xz. We check this hypothesis. We modify the behavioural specification by replacing the clauseG((¬xx∧yx)→¬onx)in Fig. 14 withG(yx→¬onx). We check whether the modified behavioural specification with the propertyGonzis not satisfiable. This is actually the case for both orderings ofxxandxy. These results mean the hypothesis that wild-type P. aeruginosa may have a stable mucoid state is rebutted by the assumption that the negative effect of y overpowers the positive effect of x.According to the current biological knowledge, all wild-type P. aeruginosa strains have the genetic capacity to synthesise alginate but normally produce only very small amounts of this polymer. Mucoid phenotype is only observed in mutants, and the conversion to this phenotype from wild-type is not observed outside the human host [20] in which the bacteria are mutated. Our latter analysis coincides with these biological facts. Our analysis assumes that in the regulation function of gene x the negative effect of gene y overpowers the positive effect of gene x. If it is confirmed experimentally, our model clarifies why wild-type P. aeruginosa do not have mucoid phenotype.Analysis in our method is based on LTL satisfiability checking, which is a PSPACE-complete problem [44]. Therefore, the known algorithms are exponential in the size of an input formula. As we can see from Section 3.3, the length of a formula specifying possible behaviours of a network is proportional to the size of the network (the number of nodes and edges). Therefore, some techniques are strongly desirable which ease this computational cost. We develop two techniques for this purpose. The first is a modular analysis which is discussed in the next section, while the second is an approximate analysis which is discussed in Section 5.In this section we present a method for modular analysis of gene regulatory networks. A network is divided into several subnetworks, and the possible behaviours of the subnetworks are integrated to obtain behaviours of the whole network. By ignoring local propositions in the subnetworks, we reduce the dimension of the state space. Thus this method reduces the cost of the analysis of a gene network.We first present the mathematical preliminaries for LTL satisfiability checking.Definition 5Letσ,σ′∈P(A)ω. The expressionσ⊕σ′denotes the sequence(σ[0]∪σ′[0])(σ[1]∪σ′[1])(σ[2]∪σ′[2])….Definition 6Let ϕ be an LTL formula.Prop(ϕ)denotes the set of propositions occurring in ϕ.The next definition is of the Büchi automaton, which is a kind of ω-automata accepting infinite words.Definition 7A Büchi automaton is a quintuple 〈Q, Σ, δ,qI, F〉, where Q is a finite set of states, Σ is a finite alphabet,δ:Q×Σ→P(Q)is the state transition function,qI∈Qis the initial state, andF⊆Qis the set of accepting states. A run of a Büchi automaton on an infinite wordα=α[0]α[1]⋯∈Σωis an infinite sequenceρ=ρ[0]ρ[1]⋯∈Qω, such thatρ[0]=qIandρ[i+1]∈δ(ρ[i],α[i])for alli≥0. An infinite word α is accepted by the automaton if the run over α visits at least one state in F infinitely often. We denote the set of infinite words accepted by an automatonAbyL(A).It is known that Büchi automata are closed under intersection [48].Theorem 1Büchi automata are closed under intersection. Namely, for any Büchi automataAandB, it is possible to construct a Büchi automaton that acceptsL(A)∩L(B), where the alphabet sets ofAandBare the same.A time structure satisfying the LTL formula ϕ is an infinite word over the alphabetΣ=P(Prop(ϕ)). The next theorem [50] states that we can construct a Büchi automaton that exactly accepts the models of ϕ. In the following theorem,|ϕ|denotes the length of ϕ.Theorem 2VardiGiven an LTL formula ϕ, one can construct a Büchi automatonAϕ=〈Q,Σ,δ,qI,F〉such that|Q|is in2O(|ϕ|),Σ=P(Prop(ϕ))andL(Aϕ)={σ∈P(Prop(ϕ))ω|σ⊨ϕ}.Corollary 1An LTL formula ϕ is satisfiable if and only ifL(Aϕ)≠∅.This corollary says that the problem of LTL satisfiability checking is reduced to emptiness testing of a Büchi automaton.Suppose thatϕ=ϕ1∧⋯∧ϕn. The idea of modular method is to construct the automatonAϕby constructing the automataAϕ1,…,Aϕnindividually and intersecting them. First we introduce some terminology.Definition 8Let A and B be finite sets such thatA⊆Band suppose thatσ∈P(B)ω. The sequenceσ↓Adenotes(σ[0]∩A)(σ[1]∩A)⋯∈P(A)ω. LetL⊆P(B)ω. The setL↓Adenotes{σ↓A|σ∈L}, the restriction of L to A. LetM⊆P(A)ω. The setM¯B⊆P(B)ωdenotes the maximum set such thatM=M¯B↓A.Proposition 1M¯Balways exists.It is easily seen thatX=⋃σ∈M{σ⊕ρ|ρ∈P(B−A)ω}is the maximum set that satisfiesM=X↓A.  □Proposition 2LetA=〈Q,P(A),δ,qI,F〉be a Büchi automaton. For any finite setB⊇Athere exists a Büchi automaton that acceptsL(A)¯B.Replace the alphabet set inAbyP(B).  □Hereafter, we assume thatϕ=ϕ1∧⋯∧ϕnis an LTL formula. Moreover, we simply writeL(Aϕi)¯forL(Aϕi)¯Prop(ϕ).Proposition 3L(Aϕ)=L(Aϕ1)¯∩⋯∩L(Aϕn)¯.Letσ∈L(Aϕ). By Theorem 2, we haveσ⊨ϕ. Therefore,σ⊨ϕifori=1,…,n. From this, we haveσ↓P(Prop(ϕi))⊨ϕi, that is,σ↓P(Prop(ϕi))∈L(Aϕi)fori=1,…,n. By Definition 8, we haveσ∈L(Aϕi)¯fori=1,…,n. The converse of this argument also holds.  □Definition 9LP(ϕi)=Prop(ϕ)−⋃1≤j≤n,j≠iProp(ϕj)is the set of local propositions inϕi.Propositions that are not local to anyϕiare called global propositions.Definition 10LetAϕi=〈Q,Σ,δ,qI,F〉.Aϕi−denotes the Büchi automaton〈Q,Σ′,δ′,qI,F〉whereΣ′={s−LP(ϕi)|s∈Σ}andδ′(q,s′)=⋃l⊆LP(ϕi)δ(q,s′∪l).Intuitively,Aϕi−is obtained by ignoring local propositionsLP(ϕi)from the transition function. We need the following lemma for modular satisfiability checking.Lemma 1L(Aϕi−)={σ↓(Prop(ϕ)−LP(ϕi))|σ∈L(Aϕi)}fori=1,…,n.LetAϕi=〈Q,Σ,δ,qI,F〉andAϕi−=〈Q,Σ′,δ′,qI,F〉. Suppose thatρ∈L(Aϕi−)and thatq[0]q[1]q[2]…is an accepting run inAϕi−over ρ. By the definition of a run, we haveq[j+1]∈δ′(q[j],ρ[j])for allj≥0. Sinceq[0]q[1]q[2]…is also an accepting run inAϕi, there exists an infinite word σ on which it is the run; that is to say,q[j+1]∈δ(q[j],σ[j])for allj≥0. By the definition ofAϕi−, there existsσ′[j]⊆LP(ϕi)such thatσ[j]=ρ[j]∪σ′[j]for allj≥0. Thus we haveσ=ρ⊕σ′, i.e.σ↓(Prop(ϕ)−LP(ϕi))=ρ. The converse inclusion is trivial.  □Corollary 2L(Aϕi)¯=L(Aϕi−)¯.First we proveL(Aϕi)¯⊆L(Aϕi−)¯. Letσ∈L(Aϕi)¯. By the proof of Proposition 1, there existsσ′∈L(Aϕi)andρ∈P(Prop(ϕ)−Prop(ϕi))ωsuch thatσ=σ′⊕ρ. By the proof of Lemma 1, there existsσ″∈L(Aϕi−)andσ‴∈P(LP(ϕi))ωsuch thatσ′=σ″⊕σ‴. Thus we haveσ=σ″⊕(σ‴⊕ρ), whereσ‴⊕ρ∈P((Prop(ϕ)−Prop(ϕi))∪LP(ϕi))ω=P(Prop(ϕ)−(Prop(ϕi)−LP(ϕi)))ω. As a consequence, we haveσ″⊕(σ‴⊕ρ)=σ∈L(Aϕi−)¯. Now we prove the inverse inclusion. Letσ∈L(Aϕi−)¯. By the proof of Proposition 1, there existsσ′∈L(Aϕi−)andρ∈P(Prop(ϕ)−(Prop(ϕi)−LP(ϕi)))ωsuch thatσ=σ′⊕ρ. SinceProp(ϕ)−(Prop(ϕi)−LP(ϕi))=(Prop(ϕ)−Prop(ϕi))∪LP(ϕi), we haveρ=ρ′⊕ρ″for someρ′∈P(Prop(ϕ)−Prop(ϕi))ωandρ″∈P(LP(ϕi))ω. Thusσ=σ′⊕ρ=σ′⊕(ρ′⊕ρ″)=(σ′⊕ρ″)⊕ρ′. Here since we knowσ′=(σ′⊕ρ″)↓(Prop(ϕi)−LP(ϕi))∈L(Aϕi−), we haveσ′⊕ρ″∈L(Aϕi)by Lemma 1. Thus by applying Proposition 1, we have(σ′⊕ρ″)⊕ρ′=σ∈L(Aϕi)¯.  □The following theorem is the main result of this section.Theorem 3L(Aϕ)≠∅⇔L(Aϕ1−)¯∩⋯∩L(Aϕn−)¯≠∅.By Proposition 3, this claim is equivalent toL(Aϕ1)¯∩⋯∩L(Aϕn)¯≠∅⇔L(Aϕ1−)¯∩⋯∩L(Aϕn−)¯≠∅.This is the case since by Corollary 2, we haveL(Aϕi)¯=L(Aϕi−)¯fori=1,…,n.  □From this theorem, we have the following modular satisfiability checking method forϕ=ϕ1∧⋯∧ϕn.1.ConstructAϕifor each i.AbstractAϕitoAϕi−by deleting the local propositionsLP(ϕi).Intersect allAϕi−. This is done by using Proposition 2 and Theorem 1.Check non-emptiness of the intersected automaton.The more local propositions we have, the more we can abstract automataAϕi−, and thus the intersected automaton will be semantically simple and the cost of checking non-emptiness will be reduced. Thus the efficacy of modular checking depends on whether there are many local propositions. Note that this method, however, needs extra costs of intersecting automata whose complexity is linear in the product of the sizes of intersected automata.Our modular method can be compared to Aoshima et al.'s modular method [6,5]. They divide an LTL formula into several modules, compute constraints on global propositions of each module and replace them with those constraints. Their modular method is at LTL level. In our method, we compute Büchi automata for each module and simplify them, then compute a product of each automaton. So our modular method is at automaton level. Since computing constraints on global propositions of each module is not trivial, our modular method is more applicable.We apply the modular satisfiability checking of LTL to our framework of network analysis.Letϕ=ϕ1∧⋯∧ϕnbe a behavioural specification of a network and ψ be a biological property. We check whetherϕ∧ψis satisfiable orϕ∧¬ψis unsatisfiable. By Theorem 3,ϕ∧ψis satisfiable if and only ifL(Aϕ1−)¯∩⋯∩L(Aϕn−)¯∩L(Aψ)¯≠∅. Similarly,ϕ∧¬ψis unsatisfiable if and only ifL(Aϕ1−)¯∩⋯∩L(Aϕn−)¯∩L(A¬ψ)¯=∅.The problem is how to subdivide ϕ intoϕ1∧⋯∧ϕn. For the analysis of gene regulatory networks, behaviour specification of a network can be decomposed into the specifications for its subnetworks. Therefore, we can takeϕias a behavioural specification for each subnetwork. The local propositions forϕiare propositions concerning nodes and edges which are ‘confined’ to subnetworks, that is to say, nodes that are only connected by edges in the subnetwork. Subnetworks that contain many such local propositions represent a good division. Note that propositions contained in ψ are global propositions.In this section, we apply our modular method for three example networks and evaluate how the modular method improves the efficiency.First example is the artificial network depicted in Fig. 15. We subdivide this network into two subnetworks depicted in Figs. 16 and 17.For this network, we do not explicitly give a biological property ψ but assume that it consists of the propositionsona,onb,onz1,onz2andonz3, and consider a as the system input andb,z1,z2andz3as the system outputs. For each subnetwork we give behavioural specifications (Figs. 18, 19). We can see thatabis the local proposition in the specification for subnetwork 1 and thatxx,onx,xz1,xz2andxz3are the local propositions for subnetwork 2.Note that since gene x is on the boundary between subnetworks 1 and 2, we can choose which subnetwork specification includes the clauses about the regulation of x (from gene a and itself). If we include them in to the specification for subnetwork 1, propositionaxwill be a local proposition butonxandxxwill not be local propositions. Since we preferred to have more local propositions, we included the clauses into the specification for subnetwork 2.In Table 1, we show the size and number of propositions for each automaton and analysis time33The following computational environment was used: CPU Intel(R) Core(TM) i7-3820 3.60 GHz and 32 GB of RAM.(the sum of automaton construction time and emptiness testing time). Translations from LTL to Büchi automata44For technical reasons, we used generalised Büchi automata from which we can construct equivalent Büchi automata.and computing their intersections make use of our implementation based on Aoshima's algorithm [5].This example is rather small and has so few local propositions that we do not benefit from modular analysis. We could not compensate the extra cost of intersecting automata.Let us consider another example depicted in Fig. 20, involving malT gene expression in Escherichia coli taken from [2].As depicted in Fig. 20, we divide this network into subnetwork 1 to 4. We perform three modular analyses (Modular (A) to (C) in the table) depending on how we divide the network. We show the results in Table 2.Except Modular (C), modular analysis is better than direct analysis thanks to the improvement of emptiness testing time. This improvement is attributed to the reduction of the number of propositions. Note that the size of automaton is the same as the direct analysis, but the number of propositions are few. This shows how it becomes easier to check emptiness of automata if we have fewer propositions. Unfortunately Modular (C) is not so efficient. The reason is that the size of automaton with Modular (C) becomes larger than Direct thus the computation of the product automaton was not negligible. However, the empty testing time was about the same as the direct analysis although the size of the automaton is much larger. This indicates that the reduction of the number of proposition actually facilitates emptiness testing. This result shows that the number of division also affects the efficiency of modular analysis.Let us see another example shown in Fig. 21. This network is obtained from ReIN,55http://arabidopsis.med.ohio-state.edu/REIN/.which is a database of genes of Arabidopsis thaliana. We divide this network into four subnetworks, as numbered in Fig. 21. We perform two modular analyses depending on how we divide the network. The results are depicted in Table 3.Since the direct analysis does not take much time, the benefit we have from modular analysis is a bit small. Even though, if we compare the time of empty testing, the cost is considerably reduced. Modular analysis almost compensates the cost of computing product automata and file I/O.In modular analysis, we obtain the automatonAϕifrom each subnetwork specificationϕi, abstract (or simplify)Aϕiby ignoring local propositions, then intersect them to obtain the automaton of the entire network. We now try to simplify not the automata but the subnetwork specifications themselves by abstracting local propositions. Since we forget some propositions, we may not obtain formulae equivalent to the original ones, but may be able to find stronger or weaker ones. A stronger one is sufficient for checking satisfiability of the original one and a weaker one is sufficient for checking unsatisfiability. This means that the set of behaviours are compressed or expanded from the behaviours characterised by the original specifications. We call such formulae approximate behavioural specifications for subnetworks.What about biological properties? We do not consider approximation of biological properties by two reasons. First reason is that it is difficult to find approximate formulae for biological properties. Moreover, it is difficult to ensure that approximate formula correctly reflects the intended biological property. Second reason is that formulae which describe biological properties are not so large in general. Therefore we do not benefit from approximation of biological properties.First we introduce some formal terminology for approximate analysis of LTL satisfiability.Definition 11Let ϕ and ψ be LTL formulae such thatProp(ψ)⊆Prop(ϕ). We define the relation ⪯ between LTL formulae as follows:ψ⪯ϕ⇔L(Aψ)⊆L(Aϕ)↓Prop(ψ).We call ψ an under-approximation of ϕ.Definition 12Let ϕ and ψ be LTL formulae such thatProp(ψ)⊆Prop(ϕ). We define the relation ⊒ between LTL formulae as follows:ψ⊒ϕ⇔L(Aψ)⊇L(Aϕ)↓Prop(ψ).We call ψ an over-approximation of ϕ.Remark 1The relation ⪯ is the inverse relation of ⊒ whenProp(ψ)=Prop(ϕ). We have⊥⪯ϕand⊤⊒ϕfor any ϕ.The following theorems state thatψ⪯ϕmeans that ψ is simpler (i.e. having fewer propositions) and stronger than ϕ whileψ⊒ϕmeans that ψ is simpler and weaker than ϕ.Theorem 4Let ϕ and ψ be LTL formulae such thatψ⪯ϕ. If ψ is satisfiable then ϕ is satisfiable.Proof by contrapositive. Suppose that ϕ is not satisfiable. By Corollary 1,L(Aϕ)=∅. ThenL(Aϕ)↓Prop(ψ)=∅. By Definition 11, we haveL(Aψ)=∅, that is, ψ is not satisfiable.  □Theorem 5Let ϕ and ψ be LTL formulae such thatψ⊒ϕ. If ψ is not satisfiable then ϕ is not satisfiable.Proof by contrapositive. Suppose that ϕ is satisfiable. By Corollary 1,L(Aϕ)≠∅. Thus there existsσ∈L(Aϕ). By Definition 12, there existsρ∈L(Aψ)such thatσ↓Prop(ϕ)=ρ. ThusL(Aψ)≠∅; that is, ψ is satisfiable.  □Lemma 2The weak specification is an over-approximation of the strong specification.By definitions of strong specification and weak specification (Section 3.3).  □We now present the approximate analysis method. Letϕ=ϕ1∧⋯∧ϕnbe a behavioural specification and ψ be a biological property. When we check the satisfiability ofϕ∧ψ, we replaceϕibyψi, which does not contain local propositions, such thatψi⪯ϕi, and check the satisfiability ofψ1∧⋯∧ψn∧ψ. If this is satisfiable, thenϕ∧ψis also satisfiable by Theorem 4. When we check the unsatisfiability ofϕ∧¬ψ, we replaceϕibyψisuch thatψi⊒ϕi, and check the unsatisfiability ofψ1∧⋯∧ψn∧¬ψ. If this is unsatisfiable, thenϕ∧¬ψis also unsatisfiable by Theorem 5.Remark 2We can combine approximate analysis and modular analysis by checking the satisfiability of the approximate specification modularly.In general, it is non-trivial to find a ‘good’ approximation ψ for arbitrary ϕ even if ϕ is a behavioural specification for a subnetwork of a gene regulatory network. However, it is known that gene regulatory networks contain a small set of recurring regulation patterns, called network motifs [2,3]. If we have approximate specifications for such motifs, we can reuse them for analyses of any gene networks. Therefore, we focus on approximate specifications for network motifs.There are possibly many approximate specifications for network motifs. Since our problem is to analyse biological properties of gene networks, the approximation should be biologically meaningful. Otherwise the approximate method will produce a lot of false positives/negatives. To give biologically meaningful approximation, we focus on the biological functions of network motifs. Such functions are considered to be important or useful to many organisms and the network motifs will be used to realise their functions. We consider five motifs whose functions are well-studied [2,3]: negative auto-regulation, coherent type 1 feed-forward loops, incoherent type 1 feed-forward loops, single-input modules and multi-output feed-forward loops.When we consider under-approximation, we concentrate on specific behaviours amongst all possible behaviours. The functions of network motifs are suitable for such specific behaviours since they are likely to function that way in the organisms, or the analysis problem may be related to such functions. That means we exclude behaviours which do not conform to motif functions.As for over-approximation, we need to allow extra behaviours which is prohibited in the original specification. Thus extra behaviours may more or less violate the behaviour principles, e.g. ‘a gene can be ON nevertheless its inhibitor is ON’. If we allow too much of such behaviours, almost all biological properties will be satisfied and the approximate analysis will not be useful. The easiest way to obtain over-approximation is just to eliminate some clauses from the original specification. Such approximate specifications may not be biologically interpreted but is sometimes useful for approximate analysis. Note, however, that such approximation does not necessarily abstract local propositions unless we carefully choose clauses we eliminate. In contrast, under-approximations cannot be obtained in such a syntactic way. We need to devise suitable approximate specifications by hand.In the following, under-approximations are given for strong specifications and over-approximations are given for weak specifications.Theorem 6Under-approximations for strong specifications are also under-approximations for weak specifications, and over-approximations for weak specifications are also over-approximations for strong specifications.By Lemma 2.  □Negative auto-regulation is depicted in Fig. 22. This motif has the function of response acceleration [2,3]. In our abstraction, this function cannot be described since we cannot refer to an actual response time in LTL; that is, accelerated behaviours and non-accelerated behaviours cannot be distinguished. Therefore, we shall ignore negative auto-regulation in our analysis. For simplicity the approximate specification below is given under the assumption that there is one input and one output for x which are represented as the levelinxof input andxoutof x, respectively. However, this can be easily generalised to multiple inputs and outputs.First we show the strong specification for negative auto-regulation (weak one is obtained by replacing U-operator with W-operator):G((inx∧¬xx)→onx),G(¬inx→¬onx),G(onx→F(¬onx∨xout)),G((onx∧xout)→(xoutU(¬onx∨xx))),G((onx∧xx)→(xxW¬onx)),G(¬onx→F(onx∨¬xx)),G((¬onx∧¬xx)→(¬xxU(onx∨¬xout))),G((¬onx∧¬xout)→(¬xoutWonx)),G(xx→xout).We now present the following under-approximation for negative auto-regulation in which negative auto-regulation of x is ignored:G(inx↔onx),G(onx→F(xout∨¬onx)),G((onx∧xout)→(xoutW¬onx)),G(¬onx→F(¬xout∨onx)),G((¬onx∧¬xout)→(¬xoutWonx)).The abstracted local proposition isxx.An over-approximation for this network motif is given below:G(¬inx→¬onx),G(onx→F(¬onx∨xout)),G((onx∧xout)→(xoutW¬onx)),G((¬onx∧¬xout)→(¬xoutWonx))The abstracted local proposition isxx. This specification is obtained by eliminating clauses including propositionxxfrom the original weak specification. If we biologically interpret this specification, it allows extra behaviours such that gene x is OFF even if the input to x is coming, or gene x is expressed continually beyondxouteven if it is turned OFF.The coherent type 1 feed-forward loop (C1-FFL) is the pattern depicted in Fig. 23. There are two types of input function (AND/OR) for z that merge the influence of x and y[2,3]. For the AND function, C1-FFL shows a delay after stimulation by x, but no delay when the stimulation stops. For the OR function, the FFL has the opposite effect to the AND case; that is, it shows no delay after stimulation by x but shows a delay when the stimulation stops.We show the strong specification of this motif for AND version withxy<xz(the weak one can be obtained by replacing U-operator by W-operator):G(onx→F(¬onx∨xy)),G((onx∧xy)→(xyU(¬onx∨xz))),G((onx∧xz)→(xzW¬onx)),G(¬onx→F(onx∨¬xz)),G((¬onx∧¬xz)→(¬xzU(onx∨¬xy))),G((¬onx∧¬xy)→(¬xyWonx)),G(xz→xy),G(xy↔ony),G((ony∧¬yz)→F(¬ony∨yz)),G((ony∧yz)→(yzW¬ony)),G((¬ony∧yz)→F(ony∨¬yz)),G((¬ony∧¬yz)→(¬yzWony)),G((xz∧yz)↔onz).For under-approximation, we ignore y and consider them as simple regulations. Thus the difference between AND and OR does not occur in approximate formula. Although the original specifications for this motif depend on the orderings of the thresholdsxyandxz, we can present a single under-approximation as follows:G(onx→F(onz∨¬onx)),G((onx∧onz)→(onzW¬onx)),G(¬onx→F(¬onz∨onx)),G((¬onx∧¬onz)→(¬onzWonx)).The abstracted local propositions arexy,xz,yzandony.An over-approximation for AND version withxy<xzis given below:G(onx→F(ony∨¬onx)),G((onx∧ony)→(onyW¬onx)),G((onx∧xz)→(xzW¬onx)),G(¬onx→F(¬xz∨onx)),G((¬onx∧¬xz)→(¬xz∨onx)),G((¬onx∧¬ony)→(¬onyWonx)),G(xz→ony),G((ony∧¬yz)→F(¬ony∨yz)),G((ony∧yz)→(yzW¬ony)),G((¬ony∧yz)→F(ony∨¬yz)),G((¬ony∧¬yz)→(¬yzWony)),G((xz∧yz)↔onz).Note that we abstracted one propositionxy. In fact, this over-approximation satisfies both inclusions in the right hand side of Definition 12, which means the over-approximation does not accommodate any extra behaviour. The reason is that this ‘over’-approximation is obtained by substitutingxybyonyin the original weak specification. Due to the clauseG(xy↔ony), this approximation does not change the meaning of the formula.An over-approximation for the OR version can be obtained by just changing ∧-operator in the switching condition on gene z by ∨-operator.Incoherent type 1 feed-forward loop (I1-FFL) is a pattern depicted in Fig. 24. Assume that the threshold of x for z is lower than that of x for y. Since x activates z, if x becomes ON, z will be turned ON. Then, if gene x keeps being expressed, y eventually becomes ON. Since y inhibits z, z will become OFF afterwards. As a result, this motif generates pulse-like dynamics on z.The strong specification for this motif is as follows (the weak one can be obtained similarly as for the previous motifs):G(onx→F(¬onx∨xz)),G((onx∧xz)→(xzU(¬onx∨xy))),G((onx∧xy)→(xyW¬onx)),G(¬onx→F(onx∨¬xy)),G((¬onx∧¬xy)→(¬xyU(onx∨¬xz))),G((¬onx∧¬xz)→(¬xzWonx)),G(xy→xz),G(xy↔ony),G(ony→F(¬ony∨yz)),G((ony∧yz)→(yzW¬ony)),G(¬ony→F(ony∨¬yz)),G((¬ony∧¬yz)→(¬yzWony)),G((xz∧¬yz)↔onz).Focusing on the pulse-like dynamics, we have the following under-approximation:G((onx∧¬ony)→F(onz∨¬onx)),G((onx∧onz)→(onzUony)),G((onx∧ony)→((ony∧¬onz)W¬onx)),G(¬onx→(¬onz∧¬ony)).The abstracted local propositions arexy,xzandyz.An over-approximation for this motif is given below:G(onx→F(¬onx∨xz)),G((onx∧xz)→(xzW¬onx)),G((onx∧ony)→(onyW¬onx)),G(¬onx→F(onx∨¬ony)),G((¬onx∧¬ony)→(¬onyWonx)),G((¬onx∧¬xz)→(¬xzWonx)),G(ony→xz),G(ony→F(¬ony∨yz)),G((ony∧yz)→(yzW¬ony)),G(¬ony→F(ony∨¬yz)),G((¬ony∧¬yz)→(¬yzWony)),G((¬xz∧yz)↔onz).We abstracted propositionxy. Like the over-approximation for C1-FFL, this over-approximation in principle characterises the same behaviour set as the original weak specification. Thus this over-approximation can be seen as some kind of ‘optimisation’ of the weak specification for this motif.A single-input module is a pattern in which one regulator (called the master gene) regulates a group of target genes (Fig. 25). All regulations from the master gene are of the same type (positive or negative). We only consider the positive case but the negative case is similar.The function of this motif is a last-in first-out (LIFO) temporal order on expressions of target genes. Assume that the thresholds forz1,z2,…,znoccur in this ascending order. When the master regulator x is ON, the regulated genesz1,z2,…,znare turned ON in this order. When x is turned OFF, geneszn,zn−1,…z1are turned OFF in this order.For simplicity we setn=2in the following but generalisation is easy. The strong specification for this network motif is as follows (the weak one can be obtained similarly for other motifs):G(onx→F(¬onx∨xz1)),G((onx∧xz1)→(xz1U(¬onx∨xz2))),G((onx∧xz2)→(xz2W¬onx),G(¬onx→F(onx∨¬xz2)),G((¬onx∧¬xz2)→(¬xz2U(onx∨¬xz1))),G((¬onx∧¬xz1)→(¬xz1Wonx)),G(xz2→xz1),G(xz1↔onz1),G(xz2↔onz2).We present an under-approximation.G(onz2→onz1),G(onx→(onxUonz2)),G((onx∧onz1)→(onz1W¬onx)),G((onx∧onz2)→(onz2W¬onx)),G(¬onx→(¬onxU¬onz1)),G((¬onx∧¬onz2)→(¬onz2Wonx)),G((¬onx∧¬onz1)→(¬onz1Wonx)).The abstracted local propositions arexz1andxz2. Behaviours that satisfy this formula are such that once x is turned ON it remains ON until all target genes become active, and once x is turned OFF it remains OFF until all target genes become inactive. Therefore, behaviours such that x is turned OFF before all target genes become active or x is turned ON before all target genes become inactive are excluded from the possible behaviours obtained using the original specification.We now present an over-approximation:G(onz2→onz1),G((onx∧onz1)→(onz1W¬onx)),G((onx∧onz2)→(onz2W¬onx)),G((¬onx∧¬onz2)→(¬onz2Wonx)),G((¬onx∧¬onz1)→(¬onz1Wonx)).Propositionsxz1andxz2are ignored. This over-approximation says that the temporal order of activation and inactivation of target genes is preserved but some genes may not be activated when x is turned ON or inactivated when x is turned OFF. Such behaviours are also allowed in the weak specification but we can specify the same constraint without local propositions. Note, however, that this over-approximation allows extra behaviours. The example is that first gene x,z1andz2are ON then gene x is turned OFF but genez1and genez2are still ON.A multi-output feed-forward loop is a generalisation of a feed-forward loop with n target genes (Fig. 26). The function of this motif is interesting when each input function forziis OR and the threshold orders for x and y are inverted, that is,xz1<xz2<⋯<xznandyz1>yz2>⋯>yzn. Moreover, we assume that the thresholdxyis smaller than any ofxzis. In this case this motif can generate a first-in first-out (FIFO) temporal order on expression of target genes. The activation order isz1z2…znand the inactivation order is the opposite. This is because, when gene x becomes ON for sufficient time, gene y andz1toznwill become ON in this order due to the order of thresholdsxz1toxzn. Since gene x is expressed sufficiently long, we assume that gene y is expressed at the highest expression levelyz1. At this situation we turn gene x OFF. Then the expression level of gene x begins to decrease and finally will fall to a basal level. At this moment, genesz1toznare still ON since the level of gene y is highest for a while and activatesz1tozn. Since the activation effect of gene x to y disappears, the level of gene y begins to decrease and finally falls below the highest thresholdyz1and genez1is turned OFF (recall that the threshold order of gene y is the opposite of that of gene x). In this mannerz2toznwill be turned OFF in this order.We show the strong specification of this network motif (we setn=2but generalisation is easy):G(onx→F(¬onx∨xy)),G((onx∧xy)→(xyU(¬onx∨xz1))),G((onx∧xz1)→(xz1U(¬onx∨xz2))),G((onx∧xz2)→(xz2W¬onx)),G(¬onx→F(onx∨¬xz2)),G((¬onx∧¬xz2)→(¬xz2U(onx∨¬xz1))),G((¬onx∧¬xz1)→(¬xz1U(onx∨¬xy))),G((¬onx∧¬xy)→(¬xyWonx)),G(xz2→xz1),G(xz1→xy),G(xy↔ony),G(ony→F(¬ony∨yz2)),G((ony∧yz2)→(yz2U(¬ony∨yz1))),G((ony∧yz1)→(yz1W¬ony)),G(¬ony→F(ony∨¬yz1)),G((¬ony∧¬yz1)→(¬yz1U(ony∨¬xz2))),G((¬ony∧¬yz2)→(¬yz2Wony),G(yz1→yz2),G((xz1∨yz1)→onz1),G((¬xz1∧¬yz1)→¬onz1),G((xz2∨yz2)→onz2),G((¬xz2∧¬yz2)→¬onz2).Focusing on the property mentioned above we have the following under-approximation:G(onx→(onz2→onz1)),G(¬onx→(¬onz2→¬onz1)),G((onx→(onxUonz1))),G((onx∧onz1)→((onx∧onz1)U(onx∧onz2))),G((onx∧onz2)→(onz2W¬onx)),G(¬onx→(¬onxU¬onz1)),G((¬onx∧¬onz1)→((¬onx∧¬onz1)U(¬onx∧¬onz2))),G((¬onx∧¬onz2)→(¬onz2Wonx)).The abstracted local propositions arexy,xz1,xz2,ony,yz1andyz2. This formula says that when x is turned ON,z1andz2are activated in this order, and that when x is turned OFF,z1andz2are inactivated in the opposite order.An over-approximation is given as follows:G(((onx∨ony)∧onz1)→(onz1W(¬onx∨¬ony))),G(((onx∨ony)∧onz2)→(onz2W(¬onx∨¬ony))),G((¬onx∧¬ony∧¬onz1)→(¬onz1W(onx∨ony))),G((¬onx∧¬ony∧¬onz2)→(¬onz2W(onx∨ony))).This specification does not ensure that genez1andz2will be ON even if gene x or y are ON. However, if they become ON, they keep being ON as long as both gene x and y are ON. Similarly the fact that both gene x and y are OFF does not force genez1andz2to be OFF. However, once they are turned OFF, they keep being OFF as long as both gene x and y are OFF.We demonstrate the approximate analysis method developed thus far and compare it with the direct analysis method and modular analysis method developed in Section 4. The combination of the modular and approximate method is also experimented.We use the same examples as in the experiments of modular analysis (Section 4.4), including the results of direct and modular analysis in the tables for comparison.The first example is the network depicted in Fig. 15. There are two motifs in the network, one a negative auto-regulation and the other a single-input module. We show the results in Table 4. In the table, ‘D’ represents direct analysis, ‘M’ modular, ‘A’ approximate and ‘MA’ the combination of modular and approximate. Approximate analysis is performed for both under- and over-approximation. ‘S’ represents the number of states of the automaton, ‘E’ the number of edges of the automaton, ‘P’ the number of propositions and ‘T’ the total analysis time (second). ‘T(ET)’ represents the time of empty-testing of the automaton.The second example is the network in Escherichia coli involving the malT gene. We redraw this network in Fig. 27, emphasising network motifs. The numbers in the box and the triangle are the numbers of target genes in each motif. In this network we approximate two negative auto-regulations, one single-input module and one multi-output feed-forward loop. The results are shown in Table 5. The row ‘M’ is ‘Modular (B)’ in Table 2, which was the best among the divisions.The third example is the network from Arabidopsis thaliana depicted in Fig. 21. In this network, we can find a single-input module which has 18 target genes in the motif. There are some genes which have regulators other than the master gene. Thus we cannot use the approximate specification introduced above directly. Fortunately the modification is easy. We do not omit propositionsxyif y has a regulator other than the master gene x, and specify the conditions for activation and inhibition of y the same as the original ones. The results are shown in Table 6. The row ‘M’ is ‘Modular (A)’ in Table 3, which was the best among the divisions.In all cases, the cost of analysis is improved using approximate analysis, particularly for the larger networks. Compared to modular analysis, approximate analysis is much efficient since we do not have to intersect automata. The modular analysis, however, has a merit that we can apply it for any network which does not contain network motifs.Using both modular and approximate analysis is not more efficient than the approximate analysis in all the examples except for over-approximation in the second example. The reason is that the approximate specifications are not so large in these examples. Therefore the cost of intersecting automata is relatively high in these experiments. Note, however, that the time of emptiness testing is reduced by modular&approximate analysis compared to mere approximate analysis. If the network is large, we may benefit from the combination of modular analysis and approximate analysis.

@&#CONCLUSIONS@&#
