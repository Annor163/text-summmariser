@&#MAIN-TITLE@&#
A supervised approach to automatically extract a set of rules to support fall detection in an mHealth system

@&#HIGHLIGHTS@&#
A cheap and portable approach to detect fall detection in real time is proposed.Acceleration data are gathered by a wearable sensor and sent to a mobile device.A set of IF-THEN rules is automatically extracted from acceleration data.This set of rules can be used in our real-time mobile monitoring system.If occurrence of a fall is detected by a rule, an alarm is automatically produced.

@&#KEYPHRASES@&#
Fall recording,IF-THEN rules,Knowledge extraction,Real-time monitoring,mHealth system,

@&#ABSTRACT@&#
Automatic fall detection is a major issue in the health care of elderly people. In this task the ability to discriminate in real time between falls and normal daily activities is crucial. Several methods already exist to perform this task, but approaches able to provide explicit formalized knowledge and high classification accuracy have not yet been developed and would be highly desirable. To achieve this aim, this paper proposes an innovative and complete approach to fall detection based both on the automatic extraction of knowledge expressed as a set of IF-THEN rules from a database of fall recordings, and on its use in a mobile health monitoring system. Whenever a fall is detected by this latter, the system can take immediate actions, e.g. alerting medical personnel. Our method can easily overcome the limitations of other approaches to fall detection. In fact, thanks to the knowledge gathering, it overcomes both the difficulty faced by a human being dealing with many parameters and trying to find out which are the most suitable, and also the need to apply a laborious trial-and-error procedure to find the values of the related thresholds. In addition, in our approach the extracted knowledge is processed in real time by a reasoner embedded in a mobile device, without any need for connection to a remote server. This proposed approach has been compared against four other classifiers on a database of falls simulated by volunteers, and its discrimination ability has been shown to be higher with an average accuracy of 91.88%. We have also carried out a very preliminary experimental phase. The best set of rules found by using the previous database has allowed us to achieve satisfactory performance in these experiments as well. Namely, on these real-world falls the obtained results in terms of accuracy, sensitivity, and specificity are of about 92%, 86%, and 96%, respectively.

@&#INTRODUCTION@&#
E-health applications aimed at the health care of elderly people are very important in contemporary society, since this is an age group whose percentage within the general population is constantly increasing. Among the problems elderly people typically face, falls are a major issue in terms of their health care. In fact, data from the World Health Organization [1] reveal that about 28–35% of people aged 65 and over fall each year. Even worse, these figures increase to up to 32–42% for people aged 70 and over. These data also show that the fall frequency becomes higher as the age and frailty level grow. Given the constant increase in the average life expectation, a widespread prediction is that the total number of injuries caused by falls will double by 2030, unless preventive measures are studied and taken in the next future. This has huge costs in terms of both quality of life of the elderly patients who have fallen and the funding needed by public health systems. All of this makes automatic fall detection an important area for investigation.In recent years many approaches to fall detection have been introduced in the scientific literature. Extensive recent reviews of these different approaches can be found in [2,3]. These approaches can be broadly divided into four groups. The first group consists in the use of image processing techniques and consequent real-time image analysis as in e.g. [4], whereas the second makes reference to systems composed of ambient sensors, i.e. sensors embedded within the environment, see for example [5]. A third group is based on the use of wearable sensors such as e.g. tri-axial accelerometers and gyroscopes as in [6], whereas the fourth consists in the combined use of ambient sensors and wearable sensors, see for instance [7]. The third approach is often reported as offering several advantages, ranging from the possibility of monitoring people also in an outside environment, to low cost, and ease of use. Several recent papers in the literature [6,8–16] deal with the issue of fall detection by means of wearable devices. Quite often, methods based on this approach have also been shown to be capable of providing a higher accuracy.Consequently, in this paper, the remote monitoring of elderly people through wearable sensors is investigated, and a novel approach is presented, aimed at realizing in real time whether or not the elderly person has fallen. In the case of a fall, an alarm is immediately sent to the caregivers, an action which is very useful to facilitate the prompt provision of first aid.To carry out this task effectively, it is crucial to achieve an accurate discrimination of falls from normal daily activities which could be similar to falls, such as for example sitting down quickly, lying down on a bed, running, or jumping.In this paper we present a supervised approach to automatically extract a set of explicit IF-THEN rules to support fall detection through the use of a mobile real-time monitoring system [17]. This system has been developed by us at the iHealthLab of ICAR-CNR (http://ihealthlab.icar.cnr.it/) and contains a reasoner [18] able to process a set of explicit IF-THEN rules. To achieve this, we use our DEREx tool [19], based on Differential Evolution [20–22], that works on a database and automatically extracts a suitable set of IF-THEN rules.In the following section, Section 2, we report our approach to real-time fall detection, and comment on its novelty and advantages compared to the approaches presented in the existing literature related to fall detection. The rule extraction tool is described in Section 3. Details about the database and the way it was created are given in Section 4. Our experimental results are provided in Section 5, where the extracted knowledge is also shown. A comparison with four other classifiers is shown in Section 6 for accuracy, sensitivity and specificity, and a wide statistical analysis is carried out by using ANOVA and t-tests. A description of the mobile system architecture is reported in Section 7, where the account of a preliminary experimental phase and of the related results is also supplied. Finally our conclusions and ideas for future work are presented in Section 8.To execute the fall detection task we have designed a rule-based approach that we have embedded in a real-time monitoring system. In our monitoring system a dedicated layer, called the Decisional Layer, has to realize whether a relevant event concerning the patient's health, i.e. a fall, is taking place. To achieve this aim, this layer contains a reasoner that processes an explicit set of IF-THEN rules representing the knowledge needed to allow it to realize if and when one of these events is occurring. In most cases knowledge about a medical problem is available in the form of either guidelines, a gold standard or know-how formalized by experts, so IF-THEN rules are quite easy to formalize. Unfortunately, this is not the case for fall detection. Therefore, to enable our system to deal with fall detection efficiently, we ourselves had to create the necessary knowledge, as is the case for other researchers involved in fall detection. To achieve this, we extracted the knowledge from the available raw data arriving from an accelerometer. This was accomplished by working with a database containing fall recordings, and by applying a supervised learning technique. As a result, a set of explicit IF-THEN rules was obtained and added into the Decisional Layer of the system as our formalization of the fall detection task.In more detail, our approach is based on the three phases that are described below. The first phase is data gathering so as to acquire a database related to falls. Within this paper we have made use of a set of simulated falls. From this set we have extracted the database, described in detail in Section 4, in which each item consists in the values of 20 parameters and in the corresponding class, i.e. either a fall or a non-fall.The second phase is knowledge extraction, and takes place offline. A binary supervised classification is carried out for each database item, classifying the event as a fall or a non-fall. By doing so, the knowledge is automatically extracted from that database as an explicit set of IF-THEN rules containing both some parameters related to the falls and the values of the necessary thresholds. We accomplish this by means of our DEREx tool. It is worth pointing out that DEREx runs offline on any pc or laptop, rather than online on the mobile device. The output of DEREx, i.e. the best set of rules, is then added to our real-time mobile monitoring system, and this latter is loaded onto a mobile device.The third phase consists in patient monitoring and is carried out in real time. A wearable accelerometer sensor and a mobile device on which the real-time mobile monitoring system is running are given to a patient. The patient's acceleration data are recorded by the accelerometer and are sent to the patient's mobile device. This latter receives the raw acceleration data, elaborates them, and computes the values of the set of parameters that are contained in the set of rules. The reasoner module is then invoked: if the values of these parameters activate at least one of the rules describing the occurrence of a fall, the monitoring system becomes aware that such an event is taking place, and takes immediate action, such as e.g. sending an alert to medical personnel.Our approach contains two important novelties. The first novelty concerns the way the fall detection problem is faced compared to the existing literature. In fact, an examination of the recent state of the art shows that most of the existing works based on wireless sensors use thresholding techniques for automatic fall detection, as e.g. [7,10], whereas only a few papers make use of machine learning (ML) approaches as we do. As an example of this latter approach, [11] uses Naive Bayes and OneR and compares their performance on fall detection. An examination of these ML-based papers shows that none of these techniques is widely recognized by the scientific community as being more suitable than the others by the scientific community in the fall detection field.Moreover, another very interesting result from the examination of the recent literature is that the majority of the current sensor-based fall detection systems, such as e.g. [8,9,11], do not provide users with any explanation about their way of classifying, i.e., they are black boxes. As an example, in [8] a k-nearest neighbor algorithm is used to discriminate falls.Even those few papers that report on the use of rules for the fall detection task, e.g. [11–15], make reference to rules that are not automatically extracted by artificial intelligence tools. Rather, these rules are laboriously generated by experts who examine fall recordings, hypothesize the higher importance of some parameters with respect to others, and consequently write some rules containing only those parameters and the values of some related thresholds, which have to be hypothesized as well. As an example, in [15] a human-conceived rule says that “a fall event is detected when acceleration magnitude is greater than 3g and its peak is followed by a period, lasting at least 1200ms, characterized by the absence of peaks greater than the threshold”. These rules are then tested on the fall database, and, if their classification ability is not satisfactory, a new set of rules has to be proposed by the experts. Of course, this trial-and-error approach is tiresome, and has the negative consequence that only a very limited number of parameters and of their combinations can be suitably considered at the same time by a human mind. Due to this difficulty, most of the above referenced papers, such as e.g. [8,14,15], take the total accelerationγ=γx2+γy2+γz2only into account, where the current γivalue along axis i provides an instantaneous reading of the acceleration that the accelerometer is detecting on that axis. As a few further examples, in [15] the average acceleration magnitude variation, the free fall average acceleration magnitude, and the free fall interval only are accounted for, while the authors of [14] consider the three accelerations along the three axes and the resulting total acceleration only.The only recent paper in the literature taking a larger set of parameters into account is [16], yet the tool proposed there is a black box, and the authors do not extract any explicit knowledge from the database they create, so the users do not gain any insight about the way falls should be differentiated from daily activities.In contrast, the use of our method within the field of fall detection can easily overcome the limitations described above. In fact, in our approach we automatically gather explicit knowledge formalized as a set of IF-THEN rules, which is very user-friendly: it provides a clear explanation of the reasons for the detection of each fall thanks to the set of rules, so it expresses well the reasons for a given decision. This rule set contains just a small number of parameters automatically selected from among the many available, and contains the values for all the related thresholds as well. Therefore we overcome both the difficulty faced by a human being dealing with many parameters and trying to find out which are the most suitable, and also the need to apply a laborious trial-and-error procedure to find the values of the related thresholds. In our opinion this is an important advantage of our fall detector over other methods, such as e.g. [8,9,11]. Even those among the above listed papers that report on the use of rules for the fall detection task, e.g. [11–15] are very different from our approach, because in all these cases their rules are not automatically extracted.The second novelty, instead, concerns the use that is made of the knowledge extracted by DEREx. In fact, in the previous uses of DEREx, as for example that described in [19], it was merely used to extract rules offline. Here, instead, DEREX is a tile of a larger mosaic and the knowledge (rules) extracted by it is used in a mobile real-time monitoring system by adding it to the Knowledge Base Module in the Decisional Layer. This system is given to a patient, and, whenever a fall is detected by the reasoner, it can take immediate action, e.g. alerting medical personnel. Therefore, this paper proposes a complete approach to fall detection and also describes the main features of our mobile health system.In this paper we perform classification and rule extraction by using the DEREx tool we have specifically designed for these purposes. Its use here is suggested by the results achieved over a wide set of medical databases reported in [19], where DEREx obtained much better results than a wide set of classifiers.DEREx is based on Differential Evolution (DE) [20–22]. Each solution in DEREx represents a set of rules; each rule makes reference to a class, and in the set there should be at least one rule for each class. For each class more than one rule can be present. Each rule contains logical ANDs to connect its literals. For a given database, during evolution DEREx proposes many rule sets that compete on the basis of a measure of their quality.Our approach relies on supervised learning, namely a ten-fold cross-validation mechanism is used for the selection of the set of rules that maximizes the percentage of correctly classified items over unseen examples.DE is a stochastic algorithm designed to face multivariable optimization problems. Its way of representing possible solutions to a given problem consists in vectors of real numbers. Given a problem, DE works with a set, called population, of possible solutions, each of which is referred to as an individual. Each individual is actually a vector of real values. An objective function, often called the fitness function, expresses quantitatively how good a solution is in solving the specific problem faced.To face a multivariable optimization problem with a number of NG real parameters, DE starts by randomly generating an initial population. This is composed of a number of NPop individuals, each of which consists of an array of NG real values. Each individual in the initial population is initialized randomly: each of its fields is given a random real value in the admissible range for that field.Then, an iteration phase takes place that represents the generations in the natural evolution: when going from one generation to the next the population is modified through some transformations. Price and Storn [22] designed 10 different transformation schemes. The strategy denoted with rand-to-best/1/bin has been used for our experiments. In fact, in a preliminary activity aimed at facing a wide set of testbed medical databases all the ten known DE variants were used [19], and the experimental results showed that this strategy was the best on average over that set of databases.To create the generic i-th individual for the new population, rand-to-best/1/bin considers the i-th individual in the current population xi=(xi,1, xi,2, …, xi,NG), and two integer numbers r1 and r2 in [1,…, NPop] differing from each other and from i are randomly generated. Moreover, another integer number s in the range [1,NG] is randomly chosen. Then, a new trial individualxi′ is generated whose generic j-th component is:x′i,j=xi,j+F⋅(bestj−xi,j)+F⋅(xr1,j−xr2,j)provided that either a real number ρ randomly generated in [0.0, 1.0] is lower than a value CR (the crossover ratio, a parameter of the algorithm, ranging in [0.0, 1.0]), or the position j being modified is equal to s. If neither condition is true then a copy is carried out:x′i,j=xi,j. In the above equation xi,jis the value contained in the j-th component of xi, and so are xi,j′ for xi′, xr1,jfor xr1, xr2,jfor xr2, and bestjfor best, which is the best individual in the current population. The parameter F (the mutation factor or scale factor) is a real-valued positive constant.Next, a comparison takes place between this newly obtained trial individual xi′ and the i-th individual in the current population xi. The best between them is copied into the i-th position of the new population. This scheme is iterated until a maximum number of generations Gen is performed.Let us suppose that we are given a database divided into NC classes and that each database item has a number of features equal to NV plus the class. Also, let us denote with NR the maximum number of rules we would like to have in order to perform classification in that database. The description of the representation of a generic set of rules useful for classifying in that database can be easily understood if Fig. 1is looked at.The uppermost part of Fig. 1 says that each DE individual is a vector, containing real values, representing a set of NR classification rules written in sequence in the individual.The middle part of the figure shows that each rule is represented by a set of fields. Namely, each rule consists in a Rule_Active field, followed by a number of NVLiteral_Representation groups (one for each variable in the database), and finally by a Class field. In the rule the database variables are listed sequentially, meaning that the generic i-th Literal_Representation deals with the i-th variable of the database. Rule_Active states whether or not the rule should be considered during classification. This is decided by comparing the real value contained in this field against a real value Rule Threshold (RT), which is a parameter for our tool: if the former value is higher, then this rule is seen as active in the current individual and should be used in the classification process. This parameter has a strong influence on the number of the rules in each rule set. In fact, in general, the higher the value for RT, the lower the number of active rules in each rule set, and therefore also in the best rule set.Each Literal_Representation field encodes a zero-th order literal, i.e. a literal in which only one variable is contained and is compared with one or two real values by means of relation operators. As shown in the bottom part of Fig. 1, this Literal_Representation field consists of four sub-fields, each containing a real value, as is detailed in the next paragraphs.The first field is the Literal_Active field. Similarly to the Rule_Active field, this determines whether or not the literal is present in the rule. A real-valued parameter Literal Threshold (LT) is defined, and the literal considered is active if and only if the value in the field Literal_Active is higher than LT. This parameter has a strong influence on the shape of the achieved rules. In fact, similarly to RT, also for LT the higher its value the lower the number of literals that are active in each rule, and therefore the more compact each rule is in the best rule set.The second field is called the Literal_Type. It encodes the relation operator that compares the variable and the constant value(s). We have decided to consider the following seven operators:<, ≤, =, ≥, >, IN, OUT. The first five operators need one constant value, i.e. C1, whereas the latter two need two constant values C1and C2(C1≤C2). The operator IN checks if the value of the variable contained in the literal is within the numerical range bounded by C1and C2in their order of appearance in the individual. OUT, instead, checks if the value taken on by the variable in the literal is outside the range [C1−C2].The third and the fourth fields of the Literal_Representation field hold, respectively, the real values for the constants C1and C2. An automatic checking mechanism always guarantees that C1≤C2.Finally, the Class field contains the value of the class to which all the database items satisfying the rule are assigned.In the creation of the initial population each field of any individual is given a random real value in the admissible range for that field. For each field the admissible range is shown in Table 1. In it, upper limits for the Literal Type and Class are unreachable. For example, the Rule_active field can hold any value within [0.0, 1.0], e.g. 0.42, but it cannot contain 1.23 or −0.68, because these latter are outside the admissible range [0.0, 1.0].For each literal, its actual type is achieved by rounding the real value contained in the Literal Type field up to its ceiling value. As an example, a real value equal to 4.56 in that field should be rounded up to the ceiling(4.56)=5, so that the value codes for the fifth operator in their list. The order for the operators has been chosen as: IN, <, ≤, =, ≥, >, OUT, therefore that value represents a “≥” operator. The class to which the rule makes reference is achieved similarly, so a value equal to 1.42 in that field means that the rule refers to the class ceiling(1.42)=2.With this representation, each individual in DEREx is an array containing a number of NG real values, where NG=NR*(1+(4*NV)+1).It is important to notice here that the rule representation chosen allows you to deal directly with all the real-valued variables contained in the database. If, instead, integer-valued or binary variables should be handled, the algorithm works equally, because at the end of the execution an easy post-processing phase is carried out on the best set of rules found, with the aim of transforming the real constants contained in them into the most suitable corresponding integer or binary values. Moreover, this is true for nominal variables too, provided that a linear ordering exists for them, as for example in the case of a variable age={young, middle-aged, old}.Given an optimization problem, a fitness function Φ(i) should be designed to evaluate the quality of each possible solution i proposed by the DE in effectively solving that problem. The one we have used here for each individual i is the percentage of the correctly classified samples in the training set Tr, i.e., Φ(i)=(Nc/Ntr)*100.0, where Nc is the number of samples in Tr that are classified correctly when the set of rules encoded by the individual i is used, and Ntr is the total number of samples in Tr. Given this definition, Φ(i) can range within [0.0–100.0], and the classification is a maximization problem.Given a rule set encoded in an individual, some of the database items may be indeterminate with respect to that rule set, this having two different meanings. Firstly, we mean an item that satisfies at the same time the conditions of rules that assign it to two or more classes (‘yes-yes’ indeterminate). Secondly, we mean an item satisfying the conditions of no rule, so it cannot be assigned to any class (‘no-no’ indeterminate).During the training both types of indeterminate items are seen as classified incorrectly, whereas during the testing a recovery mechanism is applied, since the users want each sample in the testing set to be assigned to one class by the system.The recovery mechanism works as follows. If an item turns out to be a ‘yes-yes’ indeterminate, its distance from the frontier of each of the rules taking it is evaluated in the space of the database attributes. The highest such distance is found, and the item is considered as taken by the rule with the highest distance, so it is assigned to the class expressed in that rule. If, instead, the item is a ‘no-no’ indeterminate, its distance from the frontier of each of the rules is evaluated in the space of the database attributes, the rule with the lowest distance is found, and the item is assigned to the class expressed in that rule. For more details, readers are referred to [23].The database used here has been created starting from the dataset provided by Dr. S. Fudickar of the Department of Computer Science, University of Potsdam, Germany, during the development of a fall-detection simulator for accelerometers with in-hardware pre-processing [24].This data set contains 86 recordings with simulated falls performed by three people with ages between twenty and thirty, and nine recordings with normal activities such as sitting, walking, or dancing. The data were acquired by an ADXL 345 sensor (Fig. 2), and each series lasts between 5 and 30s. Each recording contains four tracks, i.e. the accelerations for the three axes, and the total acceleration.Starting from this set of four signals for each recording, we have extracted a database with the procedure based on the three steps described in the following sub-sections.At first sight, it might appear odd that our experiments are based on falls simulated by young people, whereas we wish to apply the results to elderly people. Yet, this is exactly the way all the experiments about fall detection are carried out all over the world: a group of young to middle-aged volunteers performs simulated falls, and based on the signals recorded a fall detection mechanism is implemented. Then, this mechanism is tested with elderly patients who wear it in their daily life activities. This is typically described in such papers as having been carried out in this way for “ethical reasons”, and is mainly due to two facts. Firstly, it would be ethically questionable to gather data from elderly patients by monitoring them in their daily activities waiting for them to fall. Secondly, even simulated falls may be very dangerous for elderly patients, because their bones are much more fragile and could get broken even in a controlled environment. This standard way of behaving in the fall detection field is well described in [2]. In that paper, there is a table listing 16 different recent papers about acceleration-based fall detectors using external accelerometers, and one column in that table reports on the age of the subjects involved in each of those studies. In all of those papers simulated falls are performed by young people in an age range from 20 to 40, whereas elderly people are involved in the experimental phase only by monitoring them in their everyday life activities. Moreover, another table in that paper lists seven recent papers that describe smartphone-based fall detectors. Also for these papers the same considerations can be drawn about the age of the simulated fall performers (they are young), whereas the systems will have to be used by elderly patients.Firstly, for each fall example, the start and the end times of the fall action have been annotated. Similarly, for each normal activity example, suitable start and end times have been chosen so that the delimited time span contains activities as similar as possible to falls, i.e. with highly varying signals.Secondly, we have processed raw acceleration data by means of windowing on each signal [25]. This technique is used to divide the sensor signal into smaller time segments, called windows, and each window will be a separate item for the database under construction. So, each portion of the signal selected in the previous step has been divided into windows of fixed length and with a fixed overlap size with previous and next windows [26]. We tried to find the values for those two parameters by means of a very preliminary and coarse tuning phase. In it we tried four different couples of values, i.e. (400, 200), (800, 400), (1200, 600), and (1600, 800), while keeping all the other parameters, i.e. those related to DEREx, unchanged at exactly the values reported at the beginning of Section 6. We chose those four couples because, given the sampling frequency of the acceleration parameters, i.e. 800Hz, we aimed to have windows with a size meaningful from the point of view of time. In fact, those four values for the window size correspond to a time span for each window equal to 0.5, 1, 1.5, and 2s, respectively. Among these four couples, we chose the one that allowed us to obtain the better classification results in terms of accuracy, sensitivity, and specificity. This couple turned out to be (800, 400). Therefore, throughout this paper the window size is kept equal to 800 samples and the overlap to 400 samples, which correspond to one second and half a second respectively. Fig. 3shows an example of a fall acceleration signal with a set of sliding windows.Thirdly, in each window we have computed some statistical values: for each of the four signals we have extracted:•the average value in the windowthe standard deviationthe highest valuethe lowest valuethe range width, i.e. the difference between the highest and lowest values.This results in a total of 20 parameters, that are shown in Table 2in their order of appearance in the database.Thus, we have obtained a database with a total of 249 items, 121 representing falls and 128 non-falls. Each item consists of 20 real values, one for each extracted attribute, plus the class, encoded as 1 for non-falls and 2 for falls.To extract knowledge from the database described above, we ran DEREx. Namely, to perform the classification task we carried out ten-fold cross-validation. This method has the advantage that the results are less dependent on the specific way the database is divided, so it is known in the literature [27] to be preferable to the classical division into two sets, i.e. a training set and a testing one. In ten-fold cross-validation the database is divided into exactly ten non-overlapping parts, called folds, and the classification algorithm is executed ten times. During the generic i-th execution, the i-th fold is kept as the testing set (10% of the database items), while the learning takes place on the remaining nine folds, i.e. on 90% of the database items. At the end of the ten executions, the classification results are averaged over the ten folds. The execution of DEREx over each of these folds yields a rule set. As is the case for any evolutionary algorithm, DEREx too is not deterministic: its execution and its results depend on an initial random seed. To get rid of this, we ran DEREx 25 times with 25 different random seeds. This leads to 10*25=250 supervised fold classification phases, and to an equal number of rule sets for our database. At the end, DEREx provided us with the “best set of rules” for our database, i.e. the specific rule set out of those 250 that has the highest accuracy over the testing set.To run the experiments, we set NPop=30, Gen=500, CR=0.3, F=0.7, RT=0.50, LT=0.90. Moreover, we chose NR=6, i.e. groups of at most six rules should be searched. No preliminary tuning phase for DEREx parameters was carried out to set those values.The rationale for the values of RT and, especially, LT is the following. Once the best set of rules is found, our real-time fall detection system does not compute online for each time window all of the 20 parameters. Rather, it computes just the parameters involved in the best set of rules found. If this set contains, say, 15 or even all the 20 parameters, this would imply a higher computational load due to a frequent computation of a large number of parameters. This would cause a higher battery consumption, with a consequent earlier battery discharge. Hence the choice of LT=0.90, which should yield a low number of literals in each rule.It should be remarked here that DEREx automatically performs feature selection among those present in the database and, at the same time, finds the most suitable relational operators (choosing from among <, ≤, =, ≥, >, IN a range, OUT a range) to be contained in the rules and also the most suitable values for the threshold constants in all the rule literals.The best set of rules found in the 25 runs contains 5 rules:IF (average_acceleration_total<1.152) AND (range_acceleration_y<2.601) THEN non_fallIF (average_acceleration_total≥1.153) THEN fallIF (standard_deviation_acceleration_y<1.602) AND (highest_acceleration_z≥1.655) THEN fallIF (average_acceleration_x≤0.049) AND (range_acceleration_x>4.654) THEN fallIF (highest_acceleration_x>10.006) THEN fallThese rules seem quite simple and easy to understand. In general, this is a very positive feature for a rule set in the medical domain, because complicated rules are difficult to understand and to evaluate for doctors, who consequently do not give their approval for a real testing phase on their patients. In general it can be noted that all the rules express concepts that a human could express as well based on her/his experience. The great advantage of our approach is that the threshold values are easily found here, whereas they would be very difficult to find for humans.Another very important remark is that, in total, the rules contain seven out of the 20 parameters, so the system has also automatically carried out the selection of the most relevant ones, and has realized that the remaining 13 are not strongly correlated to falls. This would be a difficult task even for an expert.Among the parameters considered, the group related to the average accelerations is the most frequently present (three times), followed by ranges and maximal values (two times each), and by the standard deviations (once). The minimal values, instead, do not appear in this best set of rules.The above set of rules has a discriminating ability reported in Table 3in terms of the typical medical-based metrics, i.e. accuracy, sensitivity, and specificity.For the sake of clarity, we report the definitions for the above parameters.Accuracy=100.0⋅(TP+TN)NSensitivity=100.0⋅TPTP+FNSpecificity=100.0⋅TNFP+TNwhere N is the total number of items considered, TP is the number of items labeled as “fall” and correctly classified, TN is the number of items labeled as “non-fall” and correctly classified, FP is the number of non-fall items incorrectly considered as a “fall”, and FN is the number of fall items events incorrectly seen as “non-fall”. Thus, we have taken the “fall” class as the positive one.It is worth recalling here that the sensitivity relates to the test's ability to identify positive results, i.e. falls, and the higher the number of false negatives the lower the sensitivity value. The specificity, instead, measures the ability of the classifier to identify negative results, i.e. non-falls, and for it too the higher the number of false positives the lower the specificity value. In both cases they range in our tests from a minimum of 0.0 (completely wrong classification ability) to a maximum of 100.00 (perfect classification ability with no errors at all).This set of rules classifies without any error on the Testing Set, meaning there are neither falls incorrectly classified as non-falls nor non-falls regarded as falls. Furthermore, it correctly classifies more than 92% of the instances in the Training Set, yielding a total percentage of correct classifications of instances in the whole database equal to 93%.Table 4shows the average values for the same metrics, achieved on the testing set over the 25 runs. Given the ten-fold cross-validation mechanism, this means that the reported values are averaged over 10*25=250 testing sets.The value for accuracy reported for DEREx in this table is lower than that in Table 3, because here Accuracy is averaged over the best rule sets found over each of the 10 folds in the 25 runs, whereas there the “best set of rules” is considered only. The average values are quite high, and variance is very low, which suggests independence of the results on the initial random seed.To evaluate the quality of the results in terms of the percentage of correct classifications, four other well-known classifiers were used to perform a comparison with DEREx. The Waikato Environment for Knowledge Analysis (WEKA) system release 3.4 [28] was used: it contains a large number of such techniques, based on different ideas. Among them, some of the most widely known and best performing were chosen, each with very different features. We chose a method based on Bayesian considerations, i.e. the Naïve Bayes (NB) [29], a second based on functions and networks, i.e. a Radial Basis Function network (RBF) [30], a third based on the extraction of rules, i.e. OneR [31], and a fourth based on the occurrence of feature intervals per class, called Voting Feature Interval (VFI) [32]. The impact of Naïve Bayes and OneR on fall detection was investigated in [11] too, which explains their choice here.It should be remarked here that DEREx is just a part of our real-time monitoring system, namely it has the duty of extracting an explicit set of IF-THEN rules that is then given as input to the rule-based reasoner contained in our system. This latter highlights that the reasoner can only work if an explicit set of IF-THEN rules is provided. Consequently, any other classification algorithm not able to provide explicit sets of rules is totally useless within this framework, even if it may have an excellent classification performance. Therefore, all other classifiers relying on Bayesian ideas, function-based, tree-based, and so on would not be meaningful in our system, and the main comparison here should be carried out with the other rule-based algorithm chosen, i.e. OneR. The other algorithms are reported just to provide a more complete picture about the DEREx performance.Similarly to DEREx, for all of the four classifiers no preliminary parameter tuning was carried out, and the parameter set used for each classifier is the one that is found as the default in WEKA. To compare fairly DEREx against these classifiers, their results had to be averaged over 25 runs as well. Actually, RBF, OneR, and VFI use a random starting seed to achieve different executions, therefore the 25 runs for them have been carried out by varying this initial value. Naive Bayes, instead, is not based on any random starting seed, but rather it is deterministic, so for this classifier just one run was performed.Also for these four classifiers 10-fold cross-validation was carried out in each run, by using the same procedure mentioned for DEREx.Table 5shows the results in terms of the average accuracy over those 25 values achieved, the related standard deviation, and the maximum and the minimum values among those 25. For each parameter in Table 5, the best value obtained by all the algorithms is reported in bold.The results in the table evidence that the average percentage of correct classifications provided by DEREX over the 25 runs is the highest, and so are the maximum and the minimum values achieved. Only for the standard deviation is RBF better, yet also in this case DEREx is very good, being the second best technique.A statistical analysis was carried out under Matlab to investigate whether the results from the five algorithms are different in a statistically meaningful way.Firstly, we used ANOVA, a collection of statistical models based on the analysis of variance. A one-way ANOVA analysis was applied with a level of significance α=0.05. This level represents the maximum allowable probability of incorrectly rejecting a given null hypothesis assessing statistical equivalence when this is true. In our case it is equal to 0.05, which means that if an equivalence hypothesis is true, there is a 5% probability of making a mistake in rejecting it, so a 95% probability of correctly accepting it.The complete ANOVA table for this test is reported in Table 6.The outcome of this ANOVA test is that the resulting P value is lower than 0.0001, so there is a statistically significant difference. The value of F is equal to 50.95.At this point, a complete set of unpaired t-tests was performed with a level of significance α=0.05 between each couple of the five algorithms.The complete results are reported in Table 7. In it, the generic cell (i,j) reports two pieces of information: a number representing the p-value for the t-test between algorithms i and j, and a letter expressing whether the means of these two algorithms are recognized as significantly different (Y) or not (N) by this t-test. Of course, just one test is performed between the generic algorithms i and j, so if the cell (i, j) contains information, the cell (j, i) is left empty. Moreover, no comparison is performed between an algorithm i and itself, consequently also the cells (i, i) are empty in this table.This table says there is a significant difference between DEREx and NB, RBF, and OneR. In all of these cases, since the average value for DEREx is higher, this latter is statistically better. No significant difference, instead, exists between DEREx and VFI.Table 8contains the comparison of the five algorithms in terms of the average values of sensitivity over the 25 runs, and of the related standard deviation as well. The highest average value and the lowest standard deviation are reported in bold.DEREx achieves by far the highest value of sensitivity, which means that it has a lower number of false negatives, i.e. falls that are erroneously seen as non-falls. This is very important for a system of this kind, as it is better able to generate alarms only when it is necessary, i.e. when falls take place. It also has the lowest standard deviation.The same statistical analysis shown above was performed for sensitivity too. Therefore, firstly a complete ANOVA test with α=0.05 was carried out on the data in Table 8 as well. The complete ANOVA table for this test is reported in Table 9.The outcome of this ANOVA test is that the resulting P value is lower than 0.0001, so there is a statistically significant difference. The value of F is equal to 86.39.Also here a complete set of unpaired t-tests was performed with a level of significance α=0.05 between each couple of the five algorithms.The complete results are reported in Table 10. The same cell description as for the corresponding Table 8 holds here.In this case this table says there is a significant difference between DEREx and any of the other four algorithms. In all of these cases, since the average value for DEREx is higher, this latter is statistically better.Finally, Table 11reports on the comparison of the five algorithms in terms of the average values of specificity over the 25 runs, and of the related standard deviation as well. Also in this table the highest average value and the lowest standard deviation are reported in bold.In this case RBF provides the highest value, whereas DEREx shows the lowest standard deviation in this case too.Also for specificity we performed the same statistical analysis shown above. Therefore, firstly a complete ANOVA test with α=0.05 was carried out on the data in Table 11 as well. The complete ANOVA table for this test is reported in Table 12.The outcome of this ANOVA test is that the resulting P value is lower than 0.0001, so there is a statistically significant difference. The value of F is equal to 127.70.Also here a complete set of unpaired t-tests was performed with a level of significance α=0.05 between each couple of the five algorithms.The complete results are reported in Table 13. The same cell description as for the corresponding Table 8 holds here.In this case this table says there is a significant difference between DEREx and NB, RBF, and VFI. In all of these cases, since the average value for DEREx is lower, this latter is statistically worse. The comparison against OneR, instead, reveals that no significant difference exists between them.Summarizing the results of the statistical tests, over accuracy DEREx and VFI are statistically equivalent, and are better than the other three algorithms. Over sensitivity, DEREx is statistically better than all the others. Over specificity, RBF is statistically better than all the others. The choice of one from among the five algorithms can be made by taking a closer look at the results. If we examine just the ANOVA test and the t-tests, we can say that DEREx is better once on its own and once at the same level, RBF is better once, and VFI is better once at the same level. Therefore, DEREx should be preferable. If, instead, we take into account the raw results in Tables 5, 8, and 11, we can see that over accuracy DEREx and VFI are too close to call, yet they both are better than RBF by about 2%. Over sensitivity DEREx is better than RBF by almost 10%, and better than VFI by almost 6%, whereas VFI is better than RBF by a bit more than 4%. Over specificity, finally, RBF is better than VFI by about 0.8%, and better than DEREX by a bit less than 6%, with DEREx being worse than VFI by about 5.2%. Therefore, DEREx is preferable, especially for its clear advantage in sensitivity that is the most delicate parameter in the fall detection, given the problem.This comparison makes us confident that the set of rules shown is capable of discriminating falls more accurately than the other four artificial intelligence tools can.Far more importantly, it should be pointed out that most of these other classifiers do not perform rule extraction, so they would be useless for the creation of the IF-THEN set of rules constituting the knowledge base that is necessary for the reasoner of our real-time monitoring system, even if they had a performance better than that of DEREx (which in fact is not the case).The only other classifier capable of extracting rules, i.e. OneR, has an average performance significantly worse than that offered by our tool, since there is a difference of about 3% in accuracy, of 4% in sensitivity, and of 0.4% in specificity. The above reported statistical tests have shown that DEREx is statistically better than OneR in accuracy and sensitivity, whereas they are equivalent in specificity. This superiority of DEREx could be due to the working mechanism of OneR, that can generate sets of rules all containing one attribute only (the same for all the rules), as opposed to the flexibility in the number of attributes that can be contained in each set of rules proposed by DEREx.Another very interesting fact can be observed if Tables 5, 8 and 11 are considered at the same time: for all the five algorithms, DEREx included, sensitivity is always lower than both accuracy and sensitivity. Given this, it can be concluded that this behavior does not depend on the specific algorithm used, but rather that this is a feature of the dataset itself.In the following we provide both software and hardware details about our developed mobile health monitoring system in which we have included the extracted knowledge in the form of IF-THEN rules to detect falls.The software architecture of our system has been designed as shown in Fig. 4, and is organized in three layers and modules to easily allow technological or functional changes, such as the introduction of new hardware, new software, or new applications.All the layers and modules are implemented for resource-limited mobile devices, such as PDAs and/or smartphones, by using the java language, but the system could easily be used also to build desktop applications, except for the user interfaces.The Data Layer provides user interfaces and mechanisms to manage sensor data and patient information that will be processed by the Decisional Layer. This layer collects information about the patient monitored, e.g. name, gender, age, etc., and also gathers data from some wearable medical devices, such as sensors for ECG, SpO2, temperature, and acceleration through a Bluetooth connection. There are also modules to compute further parameters: physiological values, such as Heart Rate or Heart Rate Variability; activity values, such as motion velocity and posture; and other parameters such as the average value in a temporal window or the standard deviation. Finally, the layer contains a module to store data in a European Data Format (EDF) [33] file, a standard format to exchange and store medical time series.The Decisional Layer is the “intelligent” core of the system and includes the rule engine described in [18]. Here, the values for the parameters computed by the modules in the Data Layer are elaborated by the rule engine based on the knowledge formalized by the set of IF-THEN production rules, so recognizing in real-time possible critical or dangerous situations and determining the actions of the Action Layer.Finally, the Action Layer executes the actions inferred by the Decisional Layer by implementing mechanisms to generate alarms and/or warning messages.In fact, the developed system is general-purpose, and can be used to deal with different health problems: depending on the specific problem faced, some sensors only will be needed, and the corresponding modules will be active. As an example, it has been effectively used to perform Obstructive Sleep Apnea real-time monitoring [34]. To deal with fall detection, just one wearable sensor can be used, in which an accelerometer is embedded. For this reason, the system has been developed and tested with the use of just one wearable wireless medical sensor, i.e. the Zephyr BioHarness BH3 (Fig. 5a), which is an advanced physiological monitoring device using Bluetooth technology.The monitor can be used with the BioHarness™ strap (Fig. 5b), a lightweight elasticated component incorporating Zephyr Smart Fabric ECG and Breathing Rate sensors.The BioHarness BH3 has a 3-axis accelerometer for monitoring the subject's posture and activity. The data are transmitted by Bluetooth, and can be monitored by using any suitably-configured mobile device with Bluetooth, such as a laptop, phone, or PDA. The data are transmitted and recorded simultaneously.The device permits the recovery of axis mapping information for the accelerometer. Any accelerometer axis can be mapped to any other axis as well as being inverted to allow the device to be used in a number of different orientations (e.g. worn on the front, on the side, upside down, etc.). This is very important as it allows us to utilize a fall database gathered with a different sensor to formalize the knowledge, without worrying about the orientation.A very interesting issue is that about sensor position. In fact, the data used for the simulations reported in this paper have been gathered by a sensor placed on the waist, whereas in our real-time fall detection system the sensor is placed on the chest. Therefore, the question may arise whether or not this difference in the position may yield a significant difference in the results. Actually, the problem of the optimal placement of wireless sensors on a human body is very important and has been recently discussed in [35,36,37].In [35] the optimal placement of sensors for everyday activities is considered. The tested sensor positions are: the chest, lower back, left foot, left hip, left thigh, and left wrist. In their conclusions the authors report: “Although the differences in classification accuracy between locations were found to be significant, they are in fact reasonably close and therefore the practical implications of this are marginal”. The numerical accuracy achieved by the hip and chest is 0.978 and 0.969 respectively.In [36] the fall detection problem is explicitly faced. The tested positions for the sensors are: the chest, waist, right ankle, and right thigh. The numerical accuracy for chest and hip are 52% and 48%, respectively, which become 51% and 51% if body posture recognition takes place as well. In their conclusions the authors state that: “In fall detection the waist accelerometer proved to have almost same performances as the chest accelerometer”.In [37] the discrimination of everyday activities is examined. The possible sensor positions are: the ear, chest, arm, wrist, waist, knee, and ankle. Depending on the different levels of the activity, some sensor positions appear to be more promising than others. For transitional activities, such as for example sitting (from standing) and lying down (also from standing), which are those most similar to falls, the most suitable positions have turned out to be the waist, chest, and knee.As a conclusion, in all of these studies both the chest and hip/waist are equally good for detecting everyday activities and falls too. Therefore, we are very confident that no significant difference will be found in our case too if the acceleration sensor is placed on the chest rather than on the waist.We have recently performed an initial experimental phase in which we have enrolled three middle-aged subjects (two male and one female, 40.33±5.03 years old, 70.33±10.59kg, 1.753±0.055m, right-handed) from the staff of our Laboratory. We attached the Zephyr BioHarness BH3 sensor to them, and equipped them with our system running on a smartphone provided with our rules, i.e. those shown in this paper. Then we asked them to perform both simulated falls and daily activities. Each subject was given detailed information about this experimental study and gave his/her informed consent before starting.The experimental protocol included six types of movements. Four of them belong to one of the following categories of falls: front, back, on the left and on the right, whereas the other 2 are types of normal daily activities, categorized as non-falls yet very similar to falls, i.e. jumping and quickly sitting on a chair.Each subject performed two simulated activities for each category of fall, and four simulated normal daily activities for each category of non-fall. A total of 16 activities was performed by each of the three subjects.To maximize the repeatability and reproducibility of the experiments and to reproduce as far as possible the real life actions, also avoiding the possibility of the subject becoming tired during the simulations, the protocol required that each subject could perform only five activities (between falls and normal activities) during one session. All experiments were conducted during the morning (from 10am until 12am), and a stop period of 2 days was provided between two successive sessions for the same subject. Of course, safety guard cushions were installed around the experimental space to prevent any fall injuries.The results obtained in terms of fall detection are shown in Table 14.The performance achieved in this experimental evaluation is good, although slightly worse than that obtained on the database described in Section 4 of this paper. Namely, a slight reduction in the performance has taken place here compared to that shown in Table 3, equal to 1.60%, 1.06%, and 3.38% for accuracy, sensitivity, and specificity, respectively.Of course, this is just a preliminary experiment “in the field”, and will be extended in the future through the use of a wider group of volunteers and a greater number of performed simulated falls and non-falls. In this way we will achieve a larger database created by using our wearable sensors, and will perform more tests to improve and to validate our approach. This latter will then be used for our future experiments with elderly patients.

@&#CONCLUSIONS@&#
Automatic fall detection is a major issue in the health care of elderly people. In this task the ability to differentiate in real time falls from normal daily activities is crucial. To achieve this aim, this paper has proposed an approach based on the automatic extraction of a set of IF-THEN rules. As a cross-effect, the most relevant parameters for fall assessment are automatically identified. This set, generated offline, is then exploited in the Decisional Layer of a real-time mobile monitoring system. The data gathered by a wearable acceleration sensor are processed in real time, the parameters found relevant to fall detection are computed, and, if the values of these parameters activate some of the rules describing falls, an alarm message is automatically produced. A comparison with four other well-known classifiers has been carried out on a database of falls simulated by volunteers, and the discrimination ability of the proposed approach has been shown to be higher.This set of rules should now be tested in a realistic situation. Therefore, it has been included in our mobile health monitoring system developed at iHealthLab, and experiments are being carried out with volunteers from ICAR staff. They have the task of wearing sensors of the system and of simulating both falls and daily activities that, due to their accelerometer-related features, could cause false positives.These tests aim at demonstrating the effectiveness of the rule-based approach followed. Very preliminary tests on just three people seem to confirm the quality of the approach. Preliminary numerical results coming from a wider set of volunteers will be provided in a future paper.