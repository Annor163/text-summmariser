@&#MAIN-TITLE@&#
A truck scheduling problem arising in intermodal container transportation

@&#HIGHLIGHTS@&#
We introduce the first modeling as full truckload pickup and delivery problem with time windows.Additionally to the routing, empty containers are assigned for freight transportation.The objective aims at minimizing the total truck operating time.The two-stage heuristic is currently the fastest and most efficient solution method.

@&#KEYPHRASES@&#
Logistics,Container transportation,Container repositioning,Pickup and delivery,Time windows,Heuristics,

@&#ABSTRACT@&#
We address a truck scheduling problem that arises in intermodal container transportation, where containers need to be transported between customers (shippers or receivers) and container terminals (rail or maritime) and vice versa. The transportation requests are handled by a trucking company which operates several depots and a fleet of homogeneous trucks that must be routed and scheduled to minimize the total truck operating time under hard time window constraints imposed by the customers and terminals. Empty containers are considered as transportation resources and are provided by the trucking company for freight transportation. The truck scheduling problem at hand is formulated as Full-Truckload Pickup and Delivery Problem with Time Windows (FTPDPTW) and is solved by a 2-stage heuristic solution approach. This solution method was specially designed for the truck scheduling problem but can be applied to other problems as well. We assess the quality of our solution approach on several computational experiments.

@&#INTRODUCTION@&#
Intermodal container transportation describes the movement of goods in standardized loading units (e.g., containers) by at least two transportation modes (rail, maritime, and road) in a single transport chain (Bontekoning et al., 2004; Macharis and Bontekoning, 2004). The change of transportation modes is performed at specially designed terminals by transferring the loading units without handling the freight itself. The route of intermodal transport is namely subdivided into the pre-, main-, and end-haulage, which denote the route segments from customer to terminal, terminal to terminal, and terminal to customer, respectively (refer to Fig. 1). The main-haulage generally implies the longest traveling distance and is carried out by rail or maritime, whereas the pre- and end-haulage are handled by trucks to enable house-to-house transports. The pre- and end-haulage is also referred to as drayage.Intermodal transportation has received an increased attention, e.g., by support programs introduced by the European Commission’s Directorate – General for Mobility and Transport, to divert freight transportation from road to rail and maritime in order to reduce road congestion and environmental pollution. However, despite of these efforts, the fraction of the overall freight transportation by rail is steadily declining, leveling off at around 10% in 2009, its lowest level since 1945 (European Commission, 2007, 2011; Boysen et al., 2010). To increase the attractiveness of intermodal container transportation, an efficient handling of the pre- and end-haulage will result, according to Morlok and Spasovic (1994) and Cheung et al. (2008), in a significant cost reduction.In this paper, we address a truck scheduling problem that arises in the pre- and end-haulage. A trucking company (also called carrier) handles transportation requests that involve container movements from customers (shippers or receivers) to terminals and vice versa. Associated with each request are hard time windows imposed by the customers and terminals for pickup and delivery. The transportation requests are carried out by a fleet of homogeneous trucks that must be routed and scheduled under these hard time window constraints. Moreover, containers are regarded as transportation resources and are provided to the customers for freight transportation. The latter results in the need of empty container repositioning which is additionally addressed in this setting. The carrier’s objective is to minimize the total traveling cost which is proportional to the total operating time of all trucks in use. The total operating time is thereby composed of the total traveling time and the waiting time at the terminal and customer locations (Imai et al., 2007; Caris and Janssens, 2009). Furthermore, we assume that the size of the truck fleet is fixed. A carrier typically invests in a moderate fleet size based on an estimate between highest and lowest demand (Imai et al., 2007). The demand forecast, however, is highly uncertain and in peak demands, the carrier either charters trucks (Imai et al., 2007) or subcontracts transportation requests to third party carriers (Wang et al., 2002). In either way, the assumption on the fixed fleet size is not very restrictive, since the truck fleet is either enlarged or the number of transportation requests is reduced, respectively.This outlined truck scheduling problem has been introduced and discussed by Zhang et al. (2010). The authors formulate the truck scheduling problem as asymmetric multiple Traveling Salesmen Problem with Time Windows (am-TSPTW) and solve it by a modified version of the window partitioning heuristic presented by Wang et al. (2002). A drawback of this solution method is the strong dependence of the solution quality and the computational time on the parameter settings of the time windows. We present a new formulation for the truck scheduling problem based on a Full-Truckload Pickup and Delivery Problem with Time Windows (FTPDPTW) and propose a 2-stage heuristic solution approach.The remainder of this paper is organized as follows. A detailed description of the truck scheduling problem is given in Section 2. For ease of exposition, we follow the presentation of the truck scheduling problem by Zhang et al. (2010) and apply to a large extend their notation and terminology. In Sections 3 and 4, we review the related literature and present a FTPDPTW and an am-TSPTW formulation for the truck scheduling problem, respectively. The 2-stage heuristic solution approach is addressed in Section 5. Finally, we assess the quality of our solution algorithm in a computational study and conclude our research in Sections 6 and 7, respectively.We address in this research a problem setting with multiple terminals and multiple depots, where the latter serve as truck parking space and empty container storage. We assume that the carrier knows all the transportation requests before the beginning of the time horizon. The considered transportation requests either originate from or end up at a terminal. To distinguish between these types of transportation requests the terminology inbound request and outbound request is used. An inbound request starts and an outbound request ends at a terminal. This classification is extended by differentiating between the container loading states, full and empty. Full requests denote the movement of fully-loaded containers and empty requests refer to the movement of empty containers. Hence, four types of transportation requests are considered: inbound full (IF), inbound empty (IE), outbound full (OF), and outbound empty (OE). An illustration of the different types of transportation requests is given in Fig. 2.The consideration of full and empty transportation requests is motivated as follows. Inbound/outbound full requests are induced by customers (shippers or receivers) and imply the movements of fully-loaded containers from terminals to customers and vice versa. Inbound/outbound empty requests, on the contrary, are initiated by the carrier and are due to empty container trade imbalances. To accommodate the demand of empty containers in an export-dominant region, empty containers have to be imported from import-dominant areas. Thus, empty containers are delivered by trucks to terminals that are located in import-dominant regions, are further transported by rail or maritime to terminals located in export-dominant regions, and are thereafter picked up by the carrier. Inbound/outbound empty transportation requests arise in the pre- and end-haulage of this described transportation scenario. In relation to inbound/outbound empty requests, terminals are also referred to as receiver/shipper terminals because in a broader sense they receive/deliver empty containers over the intermodal transportation network (refer to Fig. 2).Each transportation request defines an origin and/or destination, as well as further activities which are listed below in chronological order of their execution. The activities are categorized into origin (OA), destination (DA), fully-loaded container (FA), and empty container activities (EA).•Inbound Full Request (Origin: Terminal, Destination: Receiver customer):OA: The fully-loaded container is picked up by truck at the defined terminal.FA: The container is delivered to the specified receiver customer.DA: The container is dropped off and unpacked at the receiver customer and the remaining empty container is picked up.EA: The empty container is either delivered to a depot or to a shipper customer/terminal requiring an empty container for freight transportation.Inbound Empty Request (Origin: Receiver terminal, Destination: Unknown):OA: The empty container is picked up by truck at the defined terminal.EA: The container is either transported to a depot or to a shipper customer/terminal requiring an empty container for freight transportation.Outbound Full Request (Origin: Shipper customer, Destination: Terminal):EA: An empty container is delivered by truck either from a depot or from a receiver customer/terminal to the specified shipper customer.OA: The empty container is dropped off and packed with freight at the shipper customer and the fully-loaded container is picked up.FA: The fully-loaded container is transported to the defined terminal.DA: The container is dropped off at the terminal.Outbound Empty Request (Origin: Unknown, Destination: Shipper terminal):EA: An empty container is transported by truck either from a depot or from a receiver customer/terminal to the defined terminal.DA: The container is dropped off at the terminal.Observe that each transportation request induces empty container movements, i.e., empty container activities. This is due to the fact that the containers are provided for freight delivery and are repositioned after freight receiving. It is part of the optimization to decide where to deliver the empty containers released after inbound full/empty requests and where to pick up empty containers for outbound full/empty requests. A schematic representation of the different types of transportation requests and their corresponding feasible empty container movements are visualized in Fig. 3(a) and (b), respectively. Regarding to empty container movements, a receiver customer/terminal becomes an empty container supply customer/terminal while a shipper customer/terminal becomes an empty container demand customer/terminal.As mentioned earlier, transportation requests need to respect side constraints that are time related. Each customer (shipper or receiver) and each terminal imposes hard time window constraints on the transportation requests to denote the time interval in which the origin (OA) and destination activities (DA) have to start. As a consequence, inbound/outbound full transportation requests have to fulfill two time windows and inbound/outbound empty transportation requests only one time window. Moreover, service times are defined for the origin (OA) and destination activities (DA) of each transportation request.Summing up, the truck scheduling problem evaluates in which order and by which truck the transportation requests are carried out in order to minimize the total truck operating time under hard time window constraints. Additionally, it is determined, where to deliver the empty containers available after inbound full/empty requests and where to pick up the empty containers required for outbound full/empty requests. Furthermore, the truck scheduling problem is based on the following assumptions: The tours of the operating trucks start and end at a predefined and an arbitrary depot, respectively. Each truck serves a single container at a time and all transported containers and trucks are homogeneous. The transportation requests are directly processed, i.e., without any interruptions. The traveling time between any two locations is known in advance and given as a constant. Depots are expected to have a sufficient number of empty containers available and enough space to store empty containers and to park trucks.The truck scheduling problem at hand is formulated as FTPDPTW. The FTPDPTW belongs to the class of Pickup and Delivery Problems (PDPs) in which goods, commodities, and/or people are transported between origins and destinations. The literature on PDPs is quite extensive. Savelsbergh and Sol (1995), Berbeglia et al. (2007), Parragh et al. (2008a), and Parragh et al. (2008b) provide detailed surveys of the recent literature, as well as classification schemes. We follow Berbeglia et al. (2007) by differentiating between one-to-one, one-to-many-to-one, and many-to-many PDPs. The most frequently encountered PDPs are the ones with a one-to-one structure where, e.g., each commodity has a defined pickup and delivery location. Problems of this type arise, among others, in courier and door-to-door transportations (refer, e.g., to Cordeau and Laporte (2003)). The Full-Truckload Pickup and Delivery Problem (FTPDP) with a one-to-one correspondence is a special case since it can be transformed into an asymmetric Traveling Salesman Problem (aTSP) for a single vehicle and into an asymmetric multiple Traveling Salesman Problem (am-TSP) for multiple vehicles (Savelsbergh and Sol, 1995). In problems with a one-to-many-to-one relationship, commodities are initially available at, e.g., the depot and are delivered to delivery customers, whereas the commodities that are picked up at pickup customers are destined to the depot. Real-world applications arise, e.g., in the delivery of beverages and the collection of empty bottles (refer, e.g., to Gendreau et al. (1999)). In PDPs with a many-to-many dependency, the supply (demand) of any pickup (delivery) customer can be accommodated by any other delivery (pickup) customer.The truck scheduling problem at hand combines PDPs with a one-to-one and many-to-many structure. Each inbound/outbound full request defines a pickup and a delivery location and has thus a one-to-one dependency. An inbound/outbound empty request, however, has a many-to-many relationship. We handle the inbound/outbound full requests indirectly by modeling parts of the truck scheduling problem as an am-TSPTW. The entire truck scheduling problem is, however, formulated as FTPDPTW with a many-to-many relationship. We propose a solution method for this problem class. This method was specially designed for the truck scheduling problem arising in the context of intermodal container transportation but can be applied to other problems as well.The literature on PDPs with a many-to-many relationship is rather limited and mainly considers real-valued capacity and real-valued supply/demand of the vehicles and the customers, respectively. If the PDP with a many-to-many structure is restricted explicitly to a single vehicle, it is denoted as Pickup and Delivery Traveling Salesman Problem (PDTSP). Furthermore, if the PDTSP considers only a single commodity type, it is referred to as 1-PDTSP. Chalasani and Motwani (1999) address a special case of the 1-PDTSP by considering unit supply/demand of the customers and finite vehicle capacity. The authors call this problem Q-delivery TSP (Q denotes the vehicle capacity). They propose a 9.5-approximation algorithm forQ∈R+and a 2-approximation algorithm for Q=1 and Q=∞. Anily and Bramel (1999) present a (7−3/Q)-approximation algorithm for the same problem withQ∈R+and refer to it as Capacitated Traveling Salesman Problem with Pickups and Deliveries. Hernández-Pérez and Salazar-González (2004a) develop a branch-and-cut algorithm using Benders cuts to optimally solve instances of the 1-PDTSP. The authors consider real-valued supply/demand and finite vehicle capacity. Wang and Lim (2006) propose polynomial time algorithms for the 1-PDTSP with unit supply/demand on a path and a tree graph topology. Hernández-Pérez and Salazar-González (2004b) suggest two heuristics for the 1-PDTSP. One heuristic is based on a nearest neighbor and a 2-opt/3-opt approach and the other applies the branch-and-cut algorithm presented in Hernández-Pérez and Salazar-González (2004a) on restricted feasible sets. Moreover, Martinovic et al. (2008) solve instances of the 1-PDTSP by an iterative modified simulated annealing (SA) algorithm, Hernández-Pérez et al. (2009) by a hybrid GRASP/VND heuristic, Zhao et al. (2009) by a genetic algorithm, and Hosny and Mumford (2010) by a VNS/SA approach. The PDTSP with multiple commodities, unit supply/demand, and unit vehicle capacity has been addressed by Anily and Hassin (1992). The authors propose a 2.5-approximation algorithm for this so-called Swapping Problem (SP). Anily et al. (1999) consider the SP on a line and propose an exact, polynomial time algorithm. Gendreau et al. (submitted for publication) consider the 1-PDTSP with a full-truckload and refer to it as 1-FTPDTSP. They formulate the problem as an integer linear and an integer non-linear programming problem that simultaneously solves a routing and an assignment problem. Exact solution approaches based on the classical and the generalized Benders decomposition are presented to optimally solve the linear and the non-linear model, respectively. To our knowledge, no algorithm has been proposed for PDPs with a many-to-many relationship and with time window constraints.Nonetheless, several additional papers have been published that consider variants of the truck scheduling problem in the context of intermodal container transportation. The following research, however, neglects the repositioning of equipments (e.g., empty containers or trailers). Imai et al. (2007) address a truck routing problem with a full container load that involves the transportation of containers from and to a single intermodal terminal. The authors call this problem Vehicle Routing Problem with Full Containers (VRPFC). In the classification of Berbeglia et al. (2007), the VRPFC may be regarded as FTPDP with a one-to-many-to-one relationship. The problem is solved by a subgradient heuristic based on a Lagrangian relaxation. Caris and Janssens (2009) extend the VRPFC by imposing time windows on the customer locations and on the depot. An initial solution is obtained by a two-phase insertion method and is improved by a local search heuristic. The same authors propose a deterministic annealing algorithm for the identical problem in Caris and Janssens (2010). Jula et al. (2005) consider a truck scheduling problem where time constraints are imposed on the terminals and on the customer locations. Furthermore, social constraints are included which enforce the truck company to respect the shift hours of each driver. The authors formulate the truck scheduling problem as am-TSPTW by combining pickup and delivery locations. They propose an exact two-phase solution algorithm based on dynamic programming and two heuristics, a hybrid genetic algorithm and an insertion method. Namboothiri and Erera (2008) study the scheduling of a truck fleet that provide container pickup and delivery service to a single port with an appointment-based access control system. The access control system divides the operating hours of a terminal in equidistant time slots; during each time slot, the number of truck accesses of a truck company to the terminal are restricted by an upper bound. The authors determine in a first phase of their solution algorithm the maximum set of transportation requests that can be served. In a second phase, they solve a truck scheduling problem by a heuristic based on column generation. Cheung et al. (2008) address a truck scheduling problem that involves cross-border issues, i.e., the problem has to respect regulatory policies which govern the cross-border activities. The authors use an attribute-decision model to formalize the problem and implement an adaptive labeling algorithm.Truck routing and scheduling problems in intermodal transport that integrate the repositioning of equipments to facilitate fully-loaded requests have been addressed in the following research. Coslovich et al. (2006) consider a truck routing problem which minimizes routing costs, resource assignment costs, and container repositioning costs. An integrated programming model is presented and solved with means of Lagrangian relaxation by decomposing the problem into three smaller subproblems in dependency of the different cost components. Another related problem is the Multi-Resource Routing Problem (MRRP) with well-defined and flexible tasks. A well-defined task specifies the origin and destination of a truck movement, whereas a flexible task either defines the origin or the destination, but not both. Smilowitz (2006) address the MRRP with well-defined and flexible tasks where loaded and empty trailers are transshipped between terminals, shippers, receivers, and a depot. For each flexible task, Smilowitz (2006) restricts the set of potential origins/destinations to those that lie within a prespecified radius (constant for all flexible tasks). All possible occurrences of a flexible task are considered in the proposed set partitioning model formulation. The model is then solved by a branch-and-bound framework that embeds column generation. Francis et al. (2007) improve this solution approach by introducing individual radii for the flexible tasks and suggest a new solution method that uses randomized route generation. Ileri et al. (2006) consider a truck scheduling problem that involves the movement of loaded and empty trailers between shippers, receivers, rail ramps, and depots with a heterogeneous truck fleet. The problem is formulated as a set partitioning model and is solved by a column generation-based approach. Zhang et al. (2009) investigate a truck scheduling problem that handles fully-loaded and empty transportation requests between shippers, receivers, a single terminal, and multiple depots. Time windows are defined at the terminal and at the customer locations. The problem is formulated as am-TSPTW with multiple depots and is solved by a reactive tabu search algorithm (Battiti and Tecchiolli (1994)). This problem setting is extended by Zhang et al. (2010) to multiple terminals, is formulated as am-TSPTW with multiple depots, and is solved by a modified window-partitioning heuristic presented by Wang et al. (2002). Wang et al. (2002) propose a solution method for the am-TSPTW based on a time window discretization. At each iteration, the authors solve an over-constrained and an under-constrained integer programming problem. A feasible solution and a lower bound are provided by the over- and under-constrained problem, respectively. Compared to Zhang et al. (2010), Braekers et al. (2012) address a similar truck scheduling problem. Here, the truck does not have to wait at the receiver customer until the freight is unloaded and may leave to carry out another request. The empty container that is released at the receiver customer may be picked up by any truck. Braekers et al. (2012) propose two model formulations, a sequential and an integrated approach, both based on an am-TSPTW formulation. For both formulations, they propose a single- and a two-phase deterministic annealing algorithm. Finally, Zhang et al. (2011) address the truck scheduling problem for a single terminal and a single depot, where the latter has a restricted number of empty containers. They develop a reactive tabu search heuristic to solve this problem.To model the truck scheduling problem as FTPDPTW with a many-to-many dependency, the introduced transportation requests are reclassified into pickup and delivery requests. This distinction is made in dependency of the requests’ supply and demand of empty containers. After an inbound full/empty request has been processed an empty container is released. Hence, in terms of the FTPDPTW formulation, inbound full/empty requests are considered as (empty container) pickup requests. Outbound full/empty requests, on the contrary, require an empty container to carry out the transportation and are thus regarded as (empty container) delivery requests. Since depots may provide and receive empty containers, depots are considered as both, pickup and delivery.The following notation is used to describe the FTPDPTW model formulation. Let D≔{D1, … , Dm} denote the set of depots and B≔{B1, … , Br} the set of terminals. The initial number of trucks located at depot j∈D is defined by Kjand the location of depot j∈D is given by parameter Hj. Let R≔{R1, … , Rn} represent the set of transportation requests. The type of each transportation request i∈R is given by parameter Mi∈{‘IF’, ‘IE’, ‘OF’, ‘OE’}. Without loss of generality, let us assume thatR1,…,Rn1denote inbound full/empty requests andRn1+1,…,Rnoutbound full/empty requests. The origin location of each request i∈R is denoted by Oiand the destination location by Pi. Due to the fact that inbound empty requests solely define an origin location, the unknown destination location is initially set to the origin, to ease the formulation (Pi≔Oi). Analogously, the undefined origin location of each outbound empty request is set to the destination location (Oi≔Pi). The time windows and service times at the origin and destination points of each transportation request i∈R are given by[aOi,bOi]and[aPi,bPi]andtOiandtPi, respectively. We denote the union of the inbound full/empty requests by pickup requestsRP≔{i∈R|Mi∈{‘IF’,‘IE’}}≔{R1,…,Rn1}and the union of the outbound full/empty requests by delivery requestsRD≔{i∈R|Mi∈{‘OF’,‘OE’}}≔{Rn1+1,…,Rn}. Based on the property that each depot is assumed to have a sufficient number of empty containers available and enough space to store empty containers, a depot can be considered as pickup and as delivery depot. Thus, we define for each depot Dj∈D (j=1, …, m) a pickup depot setDjP:=Dj1P,…,DjKDjPcontainingKDjdepot duplicates and a delivery depot setDjD:=Dj1D,…,Dj|RP|Dcontaining ∣RP∣ depot duplicates. It is further explained in Section 4.1.2, why multiple depot duplicates are required. The location Hkof each pickup depotk∈DjPand each delivery depotk∈DjDis equivalent to the locationHDjof the underlying depot Dj∈D. Let the union of the sets of pickup depots be denoted byDP≔⋃j=1mDjPand the union of the sets of delivery depots byDD≔⋃j=1mDjD. Moreover, the union of the sets of pickup requests and pickup depots is represented by the set of pickup requests/depotsR^P≔RP∪DPand the union of the sets of delivery requests and delivery depots by the set of delivery requests/depotsR^D≔RD∪DD. The traveling time between any two locations is given by functiont:(•,•)→R+and the time to pick up or drop off a container is given by parameter t. A summary of notation is presented in Table 1.In the following, we present two formulations for the truck scheduling problem, a FTPDPTW formulation and an am-TSPTW formulation. The latter was introduced by Zhang et al. (2010).The FTPDPTW model can be defined on a directed graph G=(V, A) where V represents the vertex set and A the arc set. V consists of the depot set D, the set of pickup requests/depotsR^P, and the set of delivery requests/depotsR^D. Motivated by a graph visualization presented by Asbach et al. (2009), an illustration of digraph G is depicted in Fig. 4and a detailed description of the vertex set and the arc set is given in Sections 4.1.1 and 4.1.2, respectively.Due to the assumption that the transportation requests are carried out without interruption, each pickup and each delivery request i∈RP∪RDcan be represented by a single vertex, i.e., a vertex represents the origin, fully-loaded, and destination activities. It is thereby required to merge the time windows defined at the origin and destination locations to a combined time window, denoted by [ai, bi]. To ensure that the activities of inbound/outbound full requests start at the destination location in time interval[aPi,bPi], the service at the origin has to begin at the latest at timebPi-tOi-t(Oi,Pi). Moreover, since it is assumed that a truck has to wait, if it arrives at the destination location before timeaPi, waiting time is reduced by starting the activities at the origin after timeaPi-tOi-t(Oi,Pi). The combined time window [ai, bi] of each pickup and delivery request i∈RP∪RDis formally defined as follows (refer, e.g., to Zhang et al., 2010):(1)ai≔min{max{aOi,aPi-tOi-t(Oi,Pi)},bOi}ifMi∈{‘IF’,‘OF’}aOiifMi=‘IE’aPiifMi=‘OE’(2)bi≔min{bOi,bPi-tOi-t(Oi,Pi)}ifMi∈{‘IF’,‘OF’}bOiifMi=‘IE’bPiifMi=‘OE’It is further required to combine the origin and destination service times of each pickup and delivery request i∈RP∪RDto a combined service time, denoted by τi. The combined service time τiis determined by service timestOiandtPiand by a possible waiting timeaPi-bOi, induced by the origin and destination time windows,[aOi,bOi]and[aPi,bPi], respectively. A formal definition of τiis given below (refer, e.g., to Zhang et al., 2010):(3)τi≔max{aPi-bOi,tOi+t(Oi,Pi)}+tPiifMi∈{‘IF’,‘OF’}tOi=tifMi=‘IE’tPi=tifMi=‘OE’We furthermore include a vertex for each depot, as well as for each pickup and delivery depot. The combined service time τjis set to t for each pickup and delivery depot j∈DP∪DD, since an empty container is picked up at a pickup depot and is dropped off at a delivery depot. Moreover, the combined time window [aj, bj] is set to [−∞, ∞]. Note that service times and time windows are not defined for the depots.An arc (i, j)∈A in G illustrates a possible truck movement from vertex i∈V to vertex j∈V with two possible loading states: unloaded and loaded with an empty container. Arcs (i, j)∈A from pickup to delivery requests/depots, i.e.,i∈R^P,j∈R^D, symbolize loaded truck moves whereas all the other arcs denote unloaded moves.Arcs and arc weights are reported in Table 2and are visualized in Fig. 4. The arc weight, denoted by Tij, incorporates the truck traveling time that is required to get from the (destination) location of vertex i∈V to the (origin) location of vertex j∈V. Arcs that correspond to infeasible truck movements have arc weight ∞, are further referred to as infeasible arcs, and are listed below. Note that infeasible arcs are not visualized in Fig. 4.•Pickup and delivery requests have to respect precedence constraints, i.e., arcs among pickup requests/depots and among delivery requests/depots are infeasible.Arcs between pickup and delivery depots are infeasible.Arcs (i, j) and (j, i) between pickup requests/depotsi∈R^Pand delivery requests/depotsj∈R^Dare infeasible, if the corresponding time windows [ai, bi] and [aj, bj] are in conflict, i.e., arcs are infeasible, if ai+Tij+τi−bj⩾0 for arc (i, j) and if aj+Tji+τj−bi⩾0 for the reverse arc (j, i).Now, feasible truck moves correspond to paths in G starting from the depots, visiting each pickup and delivery request exactly once and each pickup and delivery depot maximal once, and returning to the depots. Multiple depot duplicates are required to synthesize that Kjtrucks may start at depot j∈D and that each truck has the possibility to return to any depot. Note that the paths in G have an alternating structure that alternate between pickup and delivery requests/depots.The following mixed integer programming problem is based on graph G and formalizes the truck scheduling problem. We associate with each arc (i, j)∈A a binary decision variable xij∈{0, 1} to indicate whether (xij=1) or not (xij=0) the arc is traversed by a truck. Moreover, we define for each pickup and delivery request/depoti∈R^P∪R^Da time variablezi∈Rto identify the time when the first activity starts. Note that time variables are not defined for the depots, since they can be determined indirectly (refer to Eq. (4)).(4)min∑i∈R^D∑j∈D(zi+Tij+τi)·xij-∑i∈D∑j∈R^P(zj-Tij)·xij(5)s.t.∑j∈R^Pxij⩽Ki∀i∈D(6)∑j∈R^Dxij=1∀i∈RP(7)∑i∈R^Pxij=1∀j∈RD(8)∑j∈D∪R^Dxji-∑j∈R^Dxij=0∀i∈R^P(9)∑j∈R^Pxji-∑j∈D∪R^Pxij=0∀i∈R^D(10)ai⩽zi⩽bi∀i∈R^P∪R^D(11)zi+Tij+τi-zj⩽(1-xij)·Mij∀i,j∈R^P∪R^D,i≠j(12)xij∈{0,1}∀(i,j)∈A(13)zi∈R∀i∈R^P∪R^DIn objective function (4) the total operating time of all trucks in use is to be minimized. The total operating time is determined by subtracting the sum of the start times from the sum of the end times. The start and end times refer to the times when a truck leaves the initial depot and returns to the end depot, respectively. Constraints (5) enforce that no more than the predefined number of trucks leave the initial depots. Equalities (6) and (7) ensure that each pickup/delivery request is visited exactly once, respectively. Flow conservation is enforced by constraints (8) and (9). Expressions (10) ensure that the time windows are respected. Constraints (11) connect variables x and z by enforcing a time increase of zj(compared to zi), if xij=1. Parameters Mijin constraints (11) can be defined as a big number or can be replaced by max{bi+Tij+τi−aj,0} for eachi,j∈R^P∪R^Dand i≠j. Finally, constraints (12) and (13) define the domains of the decision variables.Zhang et al. (2010) model the truck scheduling problem as am-TSPTW. This formulation is later used in the second stage of our solution approach. The graph that corresponds to the am-TSPTPW formulation is denoted by G′=(V′, A′) and includes – in analogy to the FTPDPTW formulation – a vertex for each depot, for each pickup request (i.e., inbound full/empty request), and each delivery request (i.e., outbound full/empty request). Hence, V′ consists of the depot set D, the set of pickup requests RP, and the set of delivery requests RD. In contrast to the FTPDPTW model, the pickup and delivery depots are removed from the vertex set and arcs among pickup requests and among delivery requests are included in the arc set A′. Here, the arc weight, denoted byTij′, incorporates the information that if, e.g., two pickup requests are visited sequentially by a truck, a depot has to be visited on the way from the destination location of the first pickup request to the origin location of the second pickup request. The depot with the minimum traveling distance is chosen. Thus, the traveling timeTij′between two pickup requests, i,j∈RP, i≠j, is determined by mink∈D{t(Pi, Hk)+t(Hk, Oj)}+t. Observe that the time t to drop off a container at a depot has to be included in the arc weight. An overview of all arcs and arc weights are presented in Table 3. A graph visualization of G′ is depict in Fig. 5. The model formulation is presented in-depth in Zhang et al. (2010).The considered truck scheduling problem is a generalization of the am-TSPTW, which is known to be NP-hard. Since the truck scheduling problem includes the am-TSPTW as a special case, we can follow that the truck scheduling problem is NP-hard as well. In order to solve problem instances of real-world size, a 2-stage heuristic solution approach has been developed. In the first stage of the algorithm, an initial solution is constructed and which is further improved by an ejection chain heuristic in a second stage.The construction heuristic determines a feasible solution to the truck scheduling problem and is carried out in four phases: In the first phase, pickup and delivery requests/depots are paired in order to determine empty container pickup and delivery locations for outbound full/empty and inbound full/empty requests, respectively. These constructed pairs are clustered to sequences and are assigned to trucks in a second phase. In the third and forth phase, start and end depots, as well as start and end times are assigned to those sequences.The FTPDPTW model formulation is based on the idea that the transportation requests are classified into pickup and delivery requests in dependency of their supply and demand of empty containers. After a pickup request has been conducted, an empty container is released at the destination location and is either transported to a delivery depot or to the origin location of a delivery request. Thus, each pickup request has to be followed by a delivery request/depot. Similarly, each delivery request requires an empty container at the origin location and either receives an empty container from a pickup depot or a pickup request, i.e., a pickup request/depot has to precede a delivery request. This empty container assignment problem is solved in the first phase of the heuristic by constructing pickup and delivery pairings such that each pickup and each delivery request is paired exactly once and each pairing is feasible related to the time windows. The objective aims at minimizing the sum of the traveling and the waiting time between pairs of pickup and delivery requests/depots. Two possible pickup and delivery pairings are illustrated on an example in Fig. 6. Observe that depots can be paired more than once.In mathematical terms, the following integer program is solved in the first stage of the heuristic. The binary decision variable yij∈{0, 1} denotes whether (yij=1) or not (yij=0) pickup request/depoti∈R^Pprecedes delivery request/depotj∈R^D.(14)min∑i∈R^P∑j∈R^D(Tij+max{(aj-bi-Tij-τi),0})·yij(15)s.t.∑j∈R^Dyij=1∀i∈RP(16)∑i∈R^Pyij=1∀j∈RD(17)yij·(ai+Tij+τi-bj)⩽0∀i∈RP,j∈RD(18)yij∈{0,1}∀i∈R^P,j∈R^DObjective function (14) minimizes the sum of the traveling and the waiting time. Equalities (15) and (16) ensure that each pickup and delivery request is assigned exactly once, respectively. The feasibility of the assignments in relation to the time windows is enforced by constraints (17). Expressions (18) specify the domains of the variables.This integer programming problem can be considered as a classical assignment problem (refer, e.g., to Burkard et al. (2009)) with additional constraints (17). Constraints (17) can be treated implicitly, i.e., can be discarded from the subproblem, by setting the values of the variables yijequal to 0, if ai+Tij+τi−bj>0. Problem (14), (15), (16) and (18) results in a classical assignment problem which can be solved to optimality in polynomial time, e.g., by the Hungarian method (Kuhn, 1955).Letyij∗,i∈R^P,j∈R^D, denote an optimal solution to (14)–(18) and letC≔(i,j)|yij∗=1,i∈R^P,j∈R^Ddenote the associated set of pickup and delivery pairs. For further calculation, we define for each pickup and delivery pair k≔(i, j)∈C (also denoted by pd-pair) a new service time τkand time window [ak, bk]. The determination of the time windows and service times is similar to the ones presented in Eqs. (1)–(3), respectively. Refer to Eq. (19)–(21) for a formal definition. For each pickup and delivery pair, we furthermore define a start Ok≔Oiand an end Pk≔Pjlocation.(19)ak≔min{max{ai,aj-Tij-τi},bi}ifi∈RP,j∈RDaiifi∈RP,j∈DDaj-Tij-τiifi∈DP,j∈RD(20)bk≔min{bi,bj-Tij-τi}ifi∈RP,j∈RDbiifi∈RP,j∈DDbj-Tij-τiifi∈DP,j∈RD(21)τk≔max{aj-bi,Tij+τi}+τjifi∈RP,j∈RDTij+τi+τjifi∈RP,j∈DDTij+τi+τjifi∈DP,j∈RDIn the second phase, pd-pairs are clustered to sequences. We propose two strategies, a terminal dependent and a terminal independent strategy.Terminal Dependent: By definition, each considered pd-pair k∈C either defines a terminal as origin Ok∈B, as destination Pk∈B, or even as both, origin and destination Ok, Pk∈B. The terminal dependent strategy prioritizes sequences of two pd-pairs (k, l)∈C×C that share the same terminal Bi∈B as destination Pkand origin Ol, i.e., Pk=Ol=Bi, and thus eliminate traveling time. Hence, solely the waiting time between pd-pairs is considered for sequencing.In detail, the terminal dependent strategy performs as follows: Sequences of pd-pairs are successively constructed for a specific terminal Bi∈B (i=1, … , r) by choosing a pd-pair sequence (k∗, l∗)∈C×C for fixed i, that•defines terminal Bias destination locationPk∗and origin locationOl∗for pd-pair k∗ and pd-pair l∗, respectively,Pk∗=Ol∗=Biis feasible in terms of the time windows[ak∗,bk∗]and[al∗,bl∗],ak∗+τk∗-bl∗⩽0minimizes waiting time over the set of pd-pair sequences (k, l)∈C×C with Pk=Ol=Biand ak+τk−bl⩽0,(k∗,l∗)=argmin{(k,l)∈C×C|ak+τk-bl⩽0∧Pk=Ol=Bi}{al-bk-τk}.If a pd-pair sequence λ≔(k∗, l∗) has been obtained by the pre-described procedure for a specific terminal Bi(i=1, …, r), time window [aλ, bλ], service time τλ, origin Oλ, and destination Dλare defined according to Eq. (19)–(21). Moreover, pd-pair sequence λ is added and pd-pairs k∗ and l∗ are removed from C. This described procedure is sequentially conducted for different terminals. A formal description of this approach is given next.AlgorithmSequencing pd-pairs, terminal dependent1.Initialization: Initial solution C. Set i=1.2.Iteration:(a)Determine (k∗, l∗)∈C×C:(k∗,l∗)=argmin{(k,l)∈C×C|ak+τk-bl⩽0∧Pk=Ol=Bi}{al-bk-τk}.i.If there is no such (k∗, l∗): If i<∣B∣, set i=i+1, else set i=1 and go to (2a).ii.Otherwise, construct new pair λ≔(k∗, l∗) and define time window [aλ, bλ], service time τλ, start location Oλ, and end location Pλaccording to Eqs. (19)–(21). SetC=C⧹{k∗,l∗}and C=C∪{λ}. Go to (2a).3.Termination: The algorithm terminates, if no sequencing of pd-pairs has been accomplished for ∣B∣ iterations.Terminal independent: If the terminal dependent strategy terminates and the number of pd-pair sequences ∣C∣ is still greater than the number of trucks, we apply the terminal independent strategy. This algorithm is similar to the terminal dependent version with the only difference that pd-pair sequences are constructed independent of their defined origin and destination location. Sequencing is conducted by selecting two elements (k∗, l∗)∈C×C which are feasible in terms of the defined time windows and which minimize the traveling time between them. Since arcs are not defined between delivery and pickup depots, pd-pair sequences (k, l)∈C with delivery depot as destination Pk∈DDand pickup depot as origin location Ol∈DPare not considered for sequencing. A detailed description of the algorithm is presented below.AlgorithmSequencing pd-pairs, terminal independent1.Initialization: Initial solution C.2.Iteration:(a)Determine (k∗, l∗)∈C×C:(k∗,l∗)≔argmin{(k,l)∈C×C|ak+t(Pk,Ol)+τk-bl⩽0∧(Pk∈RD∨Ol∈RP)}{t(Pk,Ol)}i.If there is no such (k∗, l∗): Stop, no feasible solution is constructed.ii.Otherwise, construct new pair λ≔(k∗, l∗) and define time window [aλ, bλ], service time τλ, start location Oλ, and end location Pλaccording to Eqs. (19)–(21). SetC=C⧹{k∗,l∗}and C=C∪{λ}. Go to (2a).3.Termination: The algorithm terminates, if|C|⩽∑j∈DKj.After the pd-pair sequences have been generated, it has to be ensured that each sequence starts and ends at a depot. To ease the formulation, we further refer to a pd-pair sequence k∈C as an alternating sequence of pickup and delivery requests/depots, k=(k1, …, kn(k)) withkj∈R^P, if j odd andkj∈R^D, if j even.Start Depot Assignment: A start depot is assigned to each sequence k∈C, denoted by k0, by solving a classical assignment problem. A new binary decision variable wjk∈{0,1} is introduced, indicating whether (wjk=1) or not (wjk=0) depot j∈D is assigned to sequence k∈C.(22)min∑j∈D∑k∈CwjkTjk1(23)s.t.∑k∈Cwjk⩽Kj∀j∈D(24)∑j∈Dwjk=1∀k∈C(25)wjk∈{0,1}∀j∈D,k∈CHere, the objective function (22) minimizes the total sum over the traveling times defined between depots and the first elements of the sequences. Constraints (23) ensure that the number of assigned depots respects the initial number of trucks. Constraints (24) enforce that exactly one depot is assigned to each sequence.Once again, this subproblem can be transformed into a classical assignment problem and can be solved to optimality, e.g., by the Hungarian method. Letwjk∗,j∈D,k∈Cdenote an optimal solution to Eqs. (22)–(25). The start depot, k0, of each sequence k∈C is then set to(26)k0≔∑j∈Dwjk∗j∀k∈CEnd depot assignment: An end depot, denoted by kn(k)+1, is assigned to each sequence k∈C by choosing the nearest depot to the last element kn(k) in the sequence:(27)kn(k)+1≔argminj∈D{Tkn(k)j}∀k∈CAfter assigning start and end depots to a sequence k∈C, we refer to a sequence as a route.We propose an exact and a heuristic approach to assign start and end times to a route k∈C in order to evaluate the route’s operating time.Exact approach: The following linear subproblem is solved by the simplex algorithm (Dantzig, 1963) to determine the optimal start and end times for each route k∈C. We introduce variablevki∈Rwhich denotes the time when the first activity starts at request/depot kiof route k∈C. The problem of assigning start and end times can mathematically be formulated as:(28)min(vkn(k)+Tkn(k)kn(k)+1+τkn(k)-(vk1-Tk0k1))(29)s.t.aki⩽vki⩽bkii=1,…,n(k)(30)vki+Tkiki+1+τki-vki+1⩽0i=1,…,n(k)-1(31)vki∈Ri=1,…,n(k)The objective function (28) aims at minimizing the truck operating time of route k∈C by subtracting start time from end time. Constraints (29) ensure that the time windows are respected and expressions (30) enforce a time increase along the route.Heuristic approach: In order to assign approximate start and end times to routes, we fix the end time and recursively determine the start time by successively assigning visiting times to the intermediate requests/depots. We introduce a new decision variablevˆki∈{0,1}which denotes the time when the first activity starts at request/depot kiofroute k∈C. We choose the last pickup/delivery request in the sequence k∈C and denote it by kl. Recall that kn(k) may denote a delivery depot with time window [−∞, ∞]. We setvˆklequal to the latest defined start timebklof the corresponding time window[akl,bkl]. Thereafter, we determine the value ofvˆkl-1for predecessor request/depot kl−1 by taking the minimum over the latest defined start timebkl-1and timevˆkl-Tkl-1kl-τkl-1. The values of the remaining intermediate requests are determined accordingly. The following recursion formally describes the approximate assignment of start and end times to route k∈C:(32)vˆkl≔bkl(33)vˆki≔min{bki,vˆki+1-Tkiki+1-τki}i=l-1,…,1The approximate value of the route’s operating time is determined by(34)vˆkl+∑i=ln(k)(Tkiki+1+τki)-(vˆk1-Tk0k1)The obtained initial solution C is further improved by an ejection chain heuristic (refer, e.g., to Pesch and Glover, 1997). Compared to classical neighborhood based heuristics (e.g., hill climbing, tabu search), ejection chain procedures allow multiple neighborhood changes in one iteration. In the first stage of our solution approach, we choose empty container pickup and delivery locations for inbound full/empty and outbound full/empty requests. In order to allow modifications on these initially determined empty container assignments, we will change the representation of our solution C. We base the new representation on the am-TSPTW formulation presented by Zhang et al. (2010). The am-TSPTW representation is useful when applying a neighborhood based improvement heuristic. Since several depots are assumed to be located in the local area, the depot with the minimum distance between, e.g., two pickup requests or two delivery requests depends on the requests’ sequence. Changing the sequence of the routes by appropriate neighborhood operators for our FTPDPTW representation, cannot guarantee that, e.g., the closest delivery depot is chosen between two pickup requests. Thus, the representation of our initial solution C needs to be adjusted. From this point on, a routek=(k0,k1,…,kn′(k),kn′(k)+1)∈Cis represented by a sequence of a start depot k0∈D, a number of transportation requests kj∈R, j=1, …, n′(k), and an end depotkn′(k)+1∈D. The pickup and delivery depots are removed from the sequence and the traveling timesTij′are defined according to Table 3.We propose three neighborhood search operators for the ejection chain procedure: single point insertion (SPI), tail exchange (TE), and depot exchange (DE) operator. In the single point insertion, a request is selected from a route and is inserted into another one. The tail exchange and depot exchange operator perform a swap on the tails and on the start depots of two routes, respectively. A general description of the different neighborhood constructions is presented next; choose one of the three operators (2a, 2b, or 2c) to get the corresponding neighborhood description.AlgorithmNeighborhood Operators1.Initialization: Initial solution C,neighborhoodN(SPI)≔N(TE)≔N(DE)≔∅2.Iteration: For each sequence (k, l)∈C×C withk=(k0,…,kn′(k)+1)andl=(l0,…,ln′(l)+1)(if k and l are non-tabu):(a)Single point insertion:For all ki, i=1, …, n′(k), and all lj, j=1, …, n′(l):i.Select kifrom route k and insert it before ljin route l.ii.Construct two new routesk¯andl¯:•k¯=(k0,…,ki-1,ki+1,…,kn′(k)+1)•l¯=(l0,…,lj-1,ki,lj,…,ln′(l)+1)iii.Call (3) and (4) fork¯andl¯.(b)Tail exchange operator:For all ki, i=1, …, n′(k), and all lj, j={1, …, n′(l)}:i.Exchange the tails starting from kiand lj.ii.Construct two new routesk¯andl¯:•k¯=(k0,…,ki-1,lj,…,ln′(l)+1)•l¯=(l0,…,lj-1,ki,…,kn′(k)+1)iii.Call (3) and (4) fork¯andl¯.(c)Depot exchange operator:i.Exchange the start depots k0 and l0.ii.Construct two new routesk¯andl¯:•k¯=(l0,…,kn′(k)+1)•l¯=(k0,…,ln′(l)+1)iii.Call (3) and (4) fork¯andl¯.3.Feasibility: Check the feasibility of the generated sequencesk¯andl¯in terms of the time window constraints.4.Neighborhood solution: Ifk¯andl¯are feasible, assign start and end times tok¯andl¯, and define a new solutionC′=(C⧹{k,l})∪{k¯,l¯}(neighboring solution) and add it to the corresponding neighborhood N(SPI)=N(SPI)∪C′, N(TE)=N(TE) ∪C′, or N(DE)=N(DE)∪C′.We control the neighborhood search for a specific neighborhood operator by an ejection chain procedure: We start off with a feasible initial (incumbent) solution C, copy the solution to an interim solution, and set all routes as non-tabu. In each iteration of the ejection chain algorithm, a sequence of at most|C|2neighborhood moves (a move denotes the transfer from one solution to a neighboring solution) is determined. A sequence of moves is evaluated as follows: We apply a move to the interim solution which minimizes the objective function value and set the corresponding routes tabu. We repeat this procedure until all routes are marked tabu or until no feasible move is found.By performing a move to the interim solution, it is not guaranteed that the value of the objective function is improved. Thus, we determine in each iteration of the ejection chain procedure a subsequence of moves, which decreases the objective function value most. If such a subsequence exists, it is applied to the incumbent solution and the next iteration is performed by setting all routes as non-tabu and by choosing the incumbent solution as start solution. If no such subsequence exists, the algorithm will stop. An illustration of the ejection chain procedure is given in Fig. 7and is based on the algorithm visualization presented in Boysen et al. (2012).Based on one of the three neighborhoods, the ejection chain procedure can be formally defined as follows:AlgorithmEjection Chain1.Initialization: Initial (incumbent) solution C.2.Iteration: Find a sequence of at most|C|2moves: Copy the incumbent solution to an interim solution. Denote all routes of the interim solution as non-tabu. Set p≔0.(a)Among all moves of non-tabu routes of the interim solution, find one, which minimizes the objective function. Perform this move to the interim solution and mark the corresponding routes k and l as tabu. Set p≔p+1.(b)Repeat (2a) to the interim solution until all routes are marked tabu or until no feasible move is found.(c)Determinep∈{0,…,|C|2}such that the interim’s objective is minimized after performing the first p moves.3.Improving the solution: If p>0, perform the first p moves to the incumbent solution and go to step (2). If p=0, then stop and return the current (incumbent) solution.We sequentially call the described ejection chain procedure for the three different neighborhood operators until no improvement is achieved on the objective function value. In the course of the neighborhood search, we determine the start and end times of the routes heuristically. The exact approach is applied to the final solution. We conclude this section with an algorithmic summary of our 2-stage heuristic.Algorithm2-Stage HeuristicStage 1: Route construction heuristic1.Phase: Pairing pickup and delivery requests/depots2.Phase: Sequencing pickup and delivery pairs•Sequencing pd-pairs, terminal dependent•Sequencing pd-pairs, terminal independent3.Phase: Assignment of start and end depots to sequences4.Phase: Assignment of start and end times to routesStage 2: Route improvement heuristicIn a classical intermodal setting, the truck scheduling problem is solved at the beginning of the day for the known transportation requests (Wang et al., 2002). However, due to traffic jams, delays, and new transportation requests that come available, the problem has to be re-optimized several times (Imai et al., 2007). According to Jula et al. (2005), truck routing and scheduling in current practice is conducted by a dispatcher which decides mainly based on experience and without any optimization tools. The dispatcher typically assigns one or at most two transportation requests to a single driver based on the driver’s availability and skills. Two containers are assigned only if the delivery location of the first is relatively close to the pickup location of the second.There is one benchmark set available for the truck scheduling problem which has been presented by Zhang et al. (2010). These instances are randomly generated – in analogy to data from practice – and each instance provides information on the following attributes: number of depots, number of terminals, number of customers (shippers and receivers), number of inbound/outbound full and inbound/outbound empty requests, and origin and destination time window widths. The considered benchmark set consists of 20 instances; each instance defines 5 depots, 3 terminals, and 75 transportation requests (40 IF, 30 OF, and 5 IE). The time window widths vary from 1 to 4h. The locations of the depots, terminals and customers are generated uniformly by choosing random pairs in the time plane [0min, 180min]×[0min, 180min]. The traveling time between any two locations is defined by their Euclidean distance. The time to pick up or drop off a container is set to 5min and the pack- and unpack times are chosen uniformly in the interval [5min, 60min]. The earliest start time of the origin time window is selected uniformly in the range [0min, 240min] and the latest start time is defined in dependency of the chosen time window width. The destination time window is constructed accordingly by respecting the origin time window and the traveling time between origin and destination. The number of trucks are the same as in Zhang et al. (2010). The authors change the fleet size based on the test instances; the fleet size ranges from 50 to 56 trucks.Zhang et al. (2010) model the truck scheduling problem as am-TSPTW with a non-linear objective function (i.e., non-linear mixed integer programming problem) and propose a heuristic method based on the window partitioning approach (WPB method) presented by Wang et al. (2002). The basic idea of their solution method is to approximate the non-linear mixed integer programming problem by an integer programming problem by partitioning the time windows of the transportation requests and by fixing time variables. The graph formulation presented in Fig. 5 is extended by including multiple vertices for each transportation request, one vertex for each time window partition. In order to obtain a feasible solution and a lower bound on the objective function value, the WPB method solves an over- and an under-constrained integer programming problem, respectively. The solution quality, as well as the computational time are based on the time window partition, i.e., the number of vertices included in the graph formulation. Refer to Zhang et al. (2010) for a thorough description.All presented methods (i.e., 2-stage heuristic, WPB method) were implemented in Java 2 and were run on an Intel Pentium Core 2 Duo, 2.2GHz PC, with 4GB system memory. We have implemented two versions of the 2-stage heuristic: 2-stage heuristic with terminal dependent and terminal independent strategy (TDS & TIS) and 2-stage heuristic solely with terminal independent strategy (TIS). The terminal dependent strategy is developed specially for the truck scheduling problem, whereas the terminal independent strategy is suited for the application to other problems as well. To measure the performance of the two variants, we compare the objective function values and the computational times with the ones obtained by the WPB method on the benchmark instances of Zhang et al. (2010). The results, objective function values (“Obj.”) and CPU times in seconds (“CPU”), are listed in Table 4for each heuristic together with the lower bounds (“LB”). The lower bounds are obtained by solving under-constrained programing problems as in Zhang et al. (2010). We use the same numbering system as Zhang et al. (2010) and the same time discretization, i.e., around 800 vertices, for the WPB method. We solve the over- and under-constrained integer programming problems by CPLEX 12.2 Concert Technology. Note that the reported CPU times of the 2-stage heuristic consider stage 1 and stage 2. The CPU times of the WPB method include modeling and solution times, pre-processing times induced by the time discretization are excluded.We first compare the algorithmic performance of the two implementations of the 2-stage heuristic. It can be seen from the data in Table 4, that the 2-stage heuristic (TDS & TIS) outperforms the 2-stage heuristic (TIS) in terms of the solution quality. The computational times of both methods are similar. However, the 2-stage heuristic (TIS) obtains better results for instances 6, 13, 15, 18, and 23. Due to the short runtime of both methods, an alternative solution approach could combine the 2-stage heuristic (TDS & TIS) with the 2-stage heuristic (TIS). In this combination, both methods are conducted and the best solution is selected. For the data in Table 4, this would result in a total objective function value of 299,794 with a total runtime of 159.74 s.Since the 2-stage heuristic (TDS & TIS) is the best performing one of both implementations, we will concentrate our further analysis on this variant and refer to it simply as 2-stage heuristic. To solve all of the 20 instances, the 2-stage heuristic requires around 16% of the total computational time of the WPB method. The objective function values of both methods are almost equal. The 2-stage heuristic obtains better results for instances 7, 8, 9, 11, 12, 13, 14, 16, and 21. We can conclude that the 2-stage heuristic determines good quality solutions in a very short time for the given benchmark set. This is a very promising result as the algorithm can be used to tackle instances of bigger size in the number of transportation requests.In a second series of tests, we vary the number of vertices in the WPB method. To achieve similar computational times, we change the time discretization and reduce the number of vertices to around 300. The results in Table 4 show that the 2-stage heuristic determines better objective function values for 19 out of 20 instances (except for instance 10). The WPB method fails to determine a feasible solution for instance 11 (indicated by table entry “∗”). Furthermore, in order to obtain similar objective function values for instances 7, 8, 9, 11, 12, 13, 14, 16, and 21, we gradually increase the number of vertices (up to around 1100). For 8 out of 9 instances, the algorithm either runs out of memory (indicated by table entry “–”) or the change in the objective function value is insignificantly small such that the solution quality of the 2-stage heuristic is not reached. Only the objective function value of instance 16 reduces below the determined value of the 2-stage heuristic. By further increasing the number of vertices to around 1200, the algorithm runs out of memory on all instances.A further drawback of the WPB method is the strong dependence of the solution quality and the computational time on the parameter settings of the time window widths (refer to Zhang et al. (2010) for a detailed study). It is shown in Table 5that for a fixed number of vertices, the quality of the solution decreases as the time window width increases. In order to improve the solution quality, the number of vertices has to be incremented, leading to an increase in the computational time. To test the performance of the 2-stage heuristic and the WPB method on instances with larger time window width, we extend the computational study of Zhang et al. (2010). We consider the same test set with time window widths of up to 10, 11, and 12h. The performance of the 2-stage heuristic is compared to the performance of the WPB method for approximately 800, 900, and 1000 vertices (Table 5). Note that the quality of the lower bounds, which are obtained by solving over-constrained linear programming problems with 1000 vertices, also depends on the time window widths.The results in Table 5 show that the 2-stage heuristic outperforms the WPB method for 800, 900, and 1000 vertices in terms of computational efficiency and solution quality. In comparison to the 2-stage heuristic, the WPB method achieves better results on only one instance (instance 24) and on two instances (instances 24 and 25) for 800/900 and 1000 vertices, respectively. The solution quality of the WPB method is improved by increasing the number of vertices. The price of improvement is the increase in the computational time. The number of vertices, however, can only be increased to around 1100 for all of the 20 instances, otherwise the algorithm runs out of memory. Thus, the solution quality of the 2-stage heuristic cannot be reached by the WPB method on large time window width, since the increase in the number of vertices is restricted. Summing up, we can follow that the proposed 2-stage heuristic outperforms the WPB method in terms of computational time on instances with large time windows. It is therefore a serious alternative to the WPB method for solving the truck scheduling problem.We end our computational study by reporting the solution performance (objective function values and CPU times in seconds) of the construction and the improvement heuristic for instances 4–38. The improvements in the objective function values range from around 4% to 30% and are listed in Table 6in the second last column. For some instances (e.g., 4, 12, 14, and 15), the improvement in the objective function value is greater compared to others. This is due to the empty container assignments, determined in the first stage of the algorithm. For these instances, the evaluated empty container assignments are not profitable in the global sense and are thus changed in the improvement heuristic.We furthermore include in the last column of Table 6 the relative amount of infeasible solutions (in percentage) which are generated in the course of the improvement heuristic. The neighborhood search operators (single point insertion, tail exchange, and depot exchange operator) in the ejection chain procedure change the structure of the routes. This restructuring may lead to routes that are infeasible due to time window violations. The results in Table 6 reveal that the amount of infeasible solutions decreases as the time window width increases. The number of infeasible solutions also affects the computational time of the improvement heuristic. Since it is time consuming to verify the route’s feasibility, the computational time increases as the amount of infeasible solution increases. Further observe that the computational times of the 2-stage heuristic presented in Tables 4 and 5 are equal to the sum of the corresponding computational times required by the construction and the improvement heuristic in Table 6.

@&#CONCLUSIONS@&#
