@&#MAIN-TITLE@&#
Analysis of OPC UA performances

@&#HIGHLIGHTS@&#
Analysis of overheads introduced by OPC UA in the client/server data exchangeResults point out that some OPC UA mechanisms strongly influence OPC UA performance.Guidelines about setting of critical OPC UA mechanisms are given in the paper.Current literature presents very few papers dealing with this subject.

@&#KEYPHRASES@&#
OPC,OPC UA,Performance evaluation,

@&#ABSTRACT@&#
OPC UA is the evolution of the well known OPC COM and XML specifications. OPC UA adopts a very complex software infrastructure to realise the communication among industrial applications; furthermore it features many mechanisms realising data exchanges, whose tuning depends on several parameters. The aim of this paper is to deal with the performance evaluation of OPC UA. The main data exchange mechanisms which may influence performance of the client/server communications will be pointed out; then, the analysis of the overhead they introduce will be presented and discussed. Finally, some guidelines about the setting of OPC UA mechanisms will be given on the basis of the results achieved.

@&#INTRODUCTION@&#
OPC Unified Architecture (OPC UA) is the current OPC Foundation's technology for secure, reliable and interoperable transport of raw data and pre-processed information from the shop floor into production planning systems [1].Definition of OPC specifications started more than fifteen years ago to simplify and to standardise data exchange between software applications in industrial environment. The rapid diffusion of the first version of OPC specifications was due to the choice of Microsoft's DCOM as the technological basis. However, exactly this point raised the majority of criticism regarding OPC; OPC technology was too focused on Microsoft, platform-dependent and not firewall-capable, and thus not suitable for use in cross-domain scenarios and for the Internet. When XML and Web Services technologies have become available, the OPC Foundation adopted them as an opportunity to eliminate the shortcomings of DCOM. Since 2003 the OPC XML Data Access (DA) specification has offered a first service-oriented architectural approach besides the “classic” DCOM-based OPC technology; this Web services-based concept enabled applications to communicate independently of the manufacturer and platform.Few years ago, the OPC Foundation has introduced the OPC UA standard which is based on a service-oriented, technology- and platform-independent approach, creating new and easy possibilities of communicating with Linux/Unix systems or embedded controls on other platforms and for implementing OPC connections over the Internet. The new possibilities of using OPC components on non-Windows platforms, embedding them in devices or implementing a standardised OPC communication across firewall boundaries allow speaking of a change of paradigms in OPC technology. OPC UA servers can be varied and scaled in their scope of functions, size, performance and the platforms they support. For embedded systems with limited memory capacities, slim OPC UA servers with a small set of UA services can be implemented; at the company level, in contrast, where memory resources are not that important, very powerful OPC UA servers can be used with the full functionality. OPC UA specifications now offer a security model, which wasn't available in the previous versions of OPC specifications; the OPC UA security governs the authentication of clients and servers and ensures data integrity, trustworthiness and authorisation within OPC communication relationships.All the features offered by OPC UA specifications are realised by introducing a complex software infrastructure made up by several layers each offering a particular set of functionalities; the organisation based on layers has the main advantage to allow interchangeability between their implementations, assuring technology-independence. Each of the layers of the OPC UA communication stack features many mechanisms realising data exchanges, whose tuning depends on several parameters. Both the intrinsic complexity of the stack implementation of OPC UA and the difficulties in the settings of the different data exchange mechanisms offered by OP CUA, may heavily impact on the overall performance of the data exchanges between industrial applications (e.g. latency, round-trip time, delays and so on).Current literature presents few papers dealing with the performance evaluation of OPC UA; most of them focus only on particular services and/or aspects of the OPC UA specification. For example in [2,3] performance evaluation is carried on considering only the security mechanisms and services provided by the OPC UA specifications. In [4,5] a lot of comparisons between OPC UA and previous specifications (COM- and XML-based) are available; although these comparisons are interesting, no useful information about the performances of the OPC UA alone can be achieved. In [6] some few results about the real measurements of delays introduced by OPC UA communication stack are shown; the results presented are very interesting but limited to few real scenarios and are not able to point out general considerations about OPC UA performances.The aim of this paper is to deal with the performance evaluation of OPC UA, pointing out all its main data exchange mechanisms which could influence the client/server communication in industrial environments. Furthermore, their impact on the overall performances will be presented and discussed. Finally, useful considerations about OPC UA performances are derived from the results presented; these considerations are aimed to help the OPC UA final user to choose the right data exchange mechanisms and to set the relevant parameters, in order to improve the OPC UA performance.Some of the analyses and results presented in this paper have been already published in proceedings of international conferences by one of the authors [7–9]; the content of this paper deeply deals with the performance evaluation of OPC UA, presenting other important results never published.The OPC UA specifications are currently made up by 11 parts [1,4]. The OPC UA architecture models OPC UA Client and Server as interacting partners.Client and Server applications use OPC UA Client and Server Application Programming Interface (API) to exchange data, respectively. OPC UA Client/Server API is an internal interface that isolates the Client/Server application code from an OPC UA Communication Stack. The OPC UA Communication Stack converts OPC UA Client/Server API calls into Messages and sends them through the underlying communication entity; on the other hand, each Message received from the underlying communication entity is delivered to the Client/Server application by the OPC UA Communication Stack.Implementation of the OPC UA Communication Stack is not linked to any specific technology; this allows OPC UA to be mapped to future technologies as necessary, without negating the basic design. Two data encodings are currently defined: XML/text and UA Binary. In addition, two transport mappings are available: UA TCP and SOAP Web Services over HTTP. Clients and Servers that support multiple transports and encodings will allow the end users to make decisions about trade-offs between performance and XML Web Service compatibility at the time of deployment, rather than having these trade-offs determined by the OPC vendor at the time of product definition.Fig. 1shows the OPC UA Client architecture; a Client Application uses the OPC UA Client API to send OPC UA Service and Publishing Requests to OPC UA Server, and to receive OPC UA Service Response and Notification from the OPC UA Server. The OPC UA Communication Stack converts OPC UA Client API calls into Messages and sends them through the underlying communication entity to the Server; the OPC UA Communication Stack also receives Response and Notification Messages from the underlying communication entity and delivers them to the Client application through the OPC UA Client API.Fig. 2shows the OPC UA Server architecture. The Server Application is the code that implements the function of the Server. Real objects are physical or software objects that are accessible by the OPC UA Server or that it maintains internally; examples include physical devices and diagnostic counters. Particular objects, called Nodes, are used by the OPC UA Server to represent real objects, their definitions and their References; the set of Nodes is called AddressSpace. Nodes are accessible by Clients using OPC UA Services (interfaces and methods). Fig. 2 shows the Nodes in the AddressSpace, the references between them (drawn by arcs connecting the Nodes) and their relationships with the real objects.Particular objects, called Monitored Items, can be created inside an OPC UA Server, as shown in Fig. 2; they are entities created by the OPC UA Client that monitor AddressSpace Nodes and their real-world counterparts, as described in Section 2.1. Monitor Items are created inside Subscriptions, shown in Fig. 2, which are the contexts of the data exchange between server and client, as described in Section 2.1.To promote interoperability of Clients and Servers, the OPC UA AddressSpace is structured hierarchically with the top levels the same for all Servers. OPC UA Servers may subset the AddressSpace into Views to simplify Client access.Like the OPC UA Client, the OPC UA Server uses the OPC UA Server API to send Response and Notification Messages to OPC UA Clients. The OPC UA Communication Stack receives Request Messages and Publish Requests from the OPC UA Client and delivers them to the OPC UA Server Application through the OPC UA Server API.The simplest way for a Client and Server to exchange data is using the Read and Write OPC UA services, which allow an OPC UA Client to read and write one or more attributes of Nodes, maintained into the AddressSpace of the OPC UA Server; like most other services, the Read and Write services are optimised for bulk read/write operations and not for reading/writing single values.A different and more sophisticated way to access data is based on Subscriptions and Monitored Items; this is the preferred method for clients needing cyclic updates of variable values. Subscriptions and Monitored Items are put on the top of a Session level, which is a logical connection between an OPC UA Client and an OPC UA Server created in the context of a Secure Channel, described in the Section 2.2.A Subscription is the context to exchange values on data changes, aggregates of data and events between the server and client; it requires a Session to transport the data to the client. Monitored Items can be created in a Subscription; they are entities in the OPC UA Server created by the OPC UA Client that monitor AddressSpace Nodes and their real-world counterparts. Three types of Monitored Items can be created. The first is used to subscribe for data changes of Variable Values; the second type of Monitored Item is used to subscribe for Events by defining an EventNotifier and a filter for the Event to be monitored. The third type of Monitored Item is used to subscribe for aggregated Values calculated based on current Variable Values in client-defined time intervals. Fig. 2 shows Monitored Items and Subscriptions; as can be seen each Monitored Item is related to Nodes into the AddressSpace and is bounded to a specific Subscription.All Monitored Items have common settings, among which there are the sampling interval and the Monitored Item queue size. The sampling interval defines the rate at which the server checks Variable Values for changes or defines the time the aggregate get calculated. The Monitored Item queues are used to hold a certain pre-defined number of data produced by the Monitored Items, until the Subscription publishes them, as explained in the following. Fig. 3shows a subscription containing the three kinds of Monitored Item described before; in the figure, the sampling intervals and the Monitored Item queues are shown.In order to explain the data exchange based on Subscriptions and Monitored Items, please refer to Fig. 3 seen before. The figure points out the Publish Interval, which is one of the Subscription settings; the Publish Interval defines when the server clears the Monitored Item queues and conveys their contents into a Notification to be sent to the Client. Notifications will be sent to the Client by issuing the Publish service, as explained in the following.Transmission of Notifications by OPC UA Server is triggered by Publish Requests sent by client. According to OPC UA specifications, a client must send a list of Publish Requests without expecting an immediate response; the server enqueues the Publish Requests until a Notification is ready for sending to the client (according to the Publish Interval, as said before). When this occurs, the Notification is sent back to the client through a Publish Request response. The Publish Request is not bound to a specific Subscription and can be used by the server for all the Subscriptions running in the same Session context. To make sure that all Subscriptions can send a notification message at the same time, the client should make sure that there are more outstanding Publish Requests than active Subscriptions.Fig. 4depicts the exchange of Publish Request and Response between OPC UA Client and Server; as it can be seen, data exchange is realised within a Session, previously opened by client and server. The Session may contain several Subscriptions; for each of them, Notifications produced on the basis of the Publish Interval are waiting to be transmitted. For each Publish Request sent by the OPC UA Client, exactly one Notification is transmitted; it may belong to one of the current Subscriptions inside the Session.OPC UA provides a security model, which includes security mechanisms allowing the authentication of Clients and Servers, the authentication of users, the integrity and confidentiality of their communications, and the verifiability of claims of functionality. Several parameters may be selected and may be set to personalise the security mechanisms to meet the security needs of a given installation. Furthermore, a minimum set of security Profiles that all OPC UA Servers support (even though they may not be used in all installations) has been defined.Security relies on a Secure Communication channel that is active for the duration of the application Session and ensures the integrity of all Messages that are exchanged.When a Session is established, the Client and Server applications negotiate a secure communications channel and exchange software Certificates that identify the Client and Server and the capabilities that they provide. Authority-generated software Certificates indicate the OPC UA Profiles that the applications implement and the OPC UA certification level reached for each Profile. Certificates issued by other organisations may also be exchanged during Session establishment.The Server further authenticates the user and authorises subsequent requests to access Objects in the Server. Authorisation mechanisms, such as access control lists, are not specified by the OPC UA specification; they are application or system-specific.OPC UA security allows to encrypt and sign Messages; encryption and signatures protect against disclosure of information and protect the integrity of Messages, respectively. OPC UA uses symmetric and asymmetric encryption to protect confidentiality as a security objective; asymmetric encryption is used for key agreement and symmetric encryption for securing all other messages sent between OPC UA applications. OPC UA uses symmetric and asymmetric signatures to address integrity as a security objective. The asymmetric signatures are used in the key agreement phase during the Secure Channel establishment; the symmetric signatures are applied to all other messages.It's very important to point out that OPC UA specification doesn't make mandatory the use of certificates, digital signatures and data encryption. It's care of the final user of the OPC UA to evaluate when the choice of one or more of the previous security mechanisms is more appropriate; choice must be taken on the basis of the best trade-off between security requirements and the overall performance of the system, which may be influenced by certain security mechanisms as pointed out in this paper.One of the main requirements for OPC UA is performance; OPC UA must scale from small embedded systems up to enterprise systems with different requirements regarding the speed and type of transferred data. In embedded systems, where smaller pieces of data must be transferred in short time intervals, the speed of the data transfer and minimal system load are the most important requirements. In enterprise systems, where structured data must be processed in a transaction- and event-based manner, the efficient handling of structured data is more important than the absolute speed of data transfer [4].OPC UA features a very complex architecture made up by a very huge number of mechanisms, each of which can be enabled/disabled and can be personalised by setting particular parameters; for example, the previous section pointed out the complexity of the Subscription/Monitored Items mechanisms and the amount of parameters that can be set inside them (e.g. sampling interval, queue size and Publish Interval). Choice of the values of the parameters featuring each mechanism present in OPC UA, is under the responsibility of the final OPC UA user during the system configuration; each choice must be taken aiming to fulfil the constraints of the industrial application and the relevant requirements in terms of performance of the system.For this reason, assessment of performance of OPC UA specifications seems very important in order to verify if and when the requirements of industrial applications are met by OPC UA architecture; furthermore, the impact of each mechanism of the OPC UA specifications (and the relevant values of parameters) on the overall performance of the system should be analysed very carefully. Results of this analysis may help the final user to evaluate if the choice of one of the foreseen mechanisms and the choice of the value for each of the relevant foreseen parameters are more appropriate to fulfil all the constraints and requirements of the industrial application.Due to the huge number of mechanisms in OPC UA specifications, it's clear that performance evaluation should be preceded by an analysis aimed to point out the mechanisms of the OPC UA specifications which, more than others, could influence the behaviour of industrial applications using OPC UA to exchange information. The aim of the following subsections is to point out the main features of the OPC UA specification candidate to influence the relevant performance.The main question about performance evaluation of security aspects of OPC UA specifications is whether the OPC UA security model is efficient in data transfer.OPC UA is used at different levels of the automation pyramid for different applications within the same environment. At the plant floor level, an OPC UA server may run in a controller providing data from field devices to OPC UA clients (e.g. HMIs, SCADA). On top of the plant floor at operation level, an OPC UA application may be a client collecting data from the server at the lower level, performing special calculations and generating alarms; an example is represented by an OPC UA client integrated in an ERP system, obtaining information about used devices in the plant floor (e.g. working hours) and creating a maintenance request.For each application involving OPC UA, the trade-off between security and performance must be reached; at the very top level, security might be more important than performance since the corporate network is connected to the Internet. At the very bottom level, performance could be more important than security when data has to be acquired in a very fast and efficient way in order to control a production process.Performance evaluation seems to play a very strategic role in order to reach the above-mentioned trade-off between performance and security. In particular, at least two different aspects of the security OPC UA model need to be investigated during performance evaluation.The first is related to the use of the certificates and their verification operated by local or remote Certification Authorities (CAs) while opening a secure channel. In e-commerce environment a waiting time of 5–10s until the Web server hosting a Web shop has validated the certificate of the customer, is very common and doesn't represent a very long time to purchase confirmation. However, 5–10s can be a very long time interval for industrial applications, especially for devices located at the field level of the automation pyramid (e.g. applications in chemical or pharmaceutical industries, where very short waiting time could lead to serious problem). It's clear that many sessions in industrial applications may be characterised by very long duration, as they remain open for long period of time; for example, an operator workplace supervising a special area of a power plant can be connected to a server for 10years without termination. Considering the data exchange inside sessions which remain open for very long periods, waiting times of tens of seconds to validate a certificate when the session is opened (at the start-up) are negligible. But, industrial applications are featured by a lot of applications which must be connected to a server for short period of time; furthermore these applications must access the server when needed without any delays. The most typical example of such applications are supervising and monitoring applications to manage faults or emergencies; these applications create a connection to the server to properly manage fault or emergency, only for the time period needed to resolve the problem. In those cases, any delay in the connection should be avoided.The other aspect of OPC UA security which seems very important to investigate is relevant to the impact of data encryption/decryption and the digital signature of each message exchanged between OPC UA Client and Server. As known, encryption allows to achieve confidentiality in the data exchange, but in many applications at field device level, confidentiality isn't a strong requirement; for this reason, an analysis of the overhead introduced by encryption during data transfer should be performed in order to highlight if and when data encryption may not be used (as it isn't mandatory according to the OPC UA specifications). The same considerations must be extended to the digital signatures foreseen in the OPC UA specifications (but not compulsory) and aimed to maintain integrity; also in this case a study of the overhead introduced by the signature of each message exchanged seems very important.As said, OPC UA may use the two different transport technologies: UA TCP and SOAP protocol; furthermore, both binary and XML encoding are currently available. Performance evaluation should take into account different transport protocols and encoding rules, comparing their impact on data exchange. In the paper, both UA TCP and SOAP transport protocols have been considered; due to the well-known performance of binary encoding, the XML encoding has not taken into account.Subscription is the mechanism able to deliver information produced in a cyclic fashion. The previous section pointed out that the subscription is based on several parameters; among them, the Publish Interval seems to play an important role in the overall performance. As said, this parameter determines the time instants at which the Monitored Item queues (containing values coming from changes of variable values or from aggregates of variable values or from events), are emptied and a Notification is prepared to be sent to the Client; the Notifications produced are then pulled by the Client issuing Publish Requests. It's clear that a small value of the Publish Interval allows the client to receive fresh values, as the Monitored Item queues are emptied very soon, but requires a large amount of Publish Requests to be sent (reducing the available bandwidth in the underlying communication entity). On the other hand, greater values of Publish Interval lead to Notifications containing huge number of data (i.e. variable values, aggregates and events), some of which may be obsolete for the client; in this case Client is compelled to send low numbers of Publish Request.On the basis of what said, the number of outstanding Publish Requests a client should maintain is another very critic parameter and could influence the overall performance of the system. Frequency of transmission of Publish Requests depends on the Publish Interval value, as said before, but it may be linked also to other events; for example, additional Publish Requests may be required if the latency of the network connection is very high. In any case, the number of outstanding Publish Requests maintained by each Client may strongly impact on the bandwidth utilisation, and could lead to bottlenecks in the client/server data exchange.OPC UA performance evaluation has been realised by the simulation of an ad-hoc model of the OPC UA client/server data exchange, instead of using a real implementation (based, for instance, on stacks and SDKs provided by the OPC Foundation). The main advantage offered by this choice is that the use of a model avoids the need to detail the internal mechanisms of the OPC UA specifications not directly involved in the aim of the performance evaluation, focusing only on certain mechanisms and their impact on performances. Furthermore, the use of a model allows achieving performance evaluation results not linked to a specific operating system, to a particular software development environment (i.e. to particular libraries) and to specific hardware architecture.The model of the OPC UA client/server data exchange has been realised inside OMNeT++ framework [10]; other frameworks have been used to support the OPC UA model: the OpenSSL [11] and the INET framework [12]. OpenSSL libraries have been used to realise the main security mechanisms foreseen by OPC UA specifications; in particular, the encryption and decryption mechanisms have been realised using the Basic128RSA15. The INET framework has been used to realise the Point-to-Point Internet Protocol (PPP) at data link layer, through which the Client and Server data exchange was realised.Fig. 5shows the OPC UA model made up by a Client and Server Application exchanging data through several layers and using PPP for the communication. The first layer under the Client or Server Application is the Data Access which offers the set of OPC UA Services used in the model for the data exchange; then a Serialisation level realises the encoding of data. If secure mechanisms are enabled, the Security level performs the operations of security through signature (Sign) or through signature and encryption (Sign&Encrypt). Finally, Transport layer realises the transport services SOAP and UA TCP.In more details, the main features implemented for each layer shown in Fig. 5, are:•DataAccess. It implements all the main OPC UA services involved in the data exchange between client and server taken into account in the paper: data exchanges based on read/write services and those based on the use of Subscriptions/Monitored Items. In particular, the read() method has been implemented in order to realise the OPC UA Read service (see [1] Part 4-Services) to read the attributes of the variables exposed by an OPC UA Server. The CreateSubscription(), CreateMonitoredItem(), and Publish() methods have been implemented in order to realise the OPC UA services CreateSubscription, CreateMonitoredItems and Publish (see [1] Part 4-Services); these services allow to realise the data exchange based on the use of Subscriptions.Serialisation. It has been assumed to realise only the UA Binary encoding for the data exchange. For this reason, this layer implements all the methods needed to apply this encoding to each messages exchanged.Security. This layer ensures the transmission of the message in a secure mode through signature (Sign) or through signature and encryption (Sign&Encrypt). The operations performed are responsible for additional delays since any frame to transmit is manipulated in order to include the information needed by the destination node for its decoding. Moreover, at the beginning of the first transmission the secured communication context has to be open, as shown in Fig. 6. The main methods implemented are: GetEndPoints(), OpenSecureChannel(), CloseSecureChannel(), CreateSession(), ActivateSession(), CloseSections(), and ValidateCertificate(). They realise the relevant OPC UA Services (see [1] Part 4-Services): GetEndpoints, OpenSecureChannel, CloseSecureChannel, CreateSession, ActivateSession and CloseSection; ValidateCertificate() realises all the procedures needed to validate the client and/or server security certificate through a local or remote certification authority. Verification of certificates by local and remote CAs has been modelled using real examples of CAs and deriving from them the average delays needed to perform verification; the values of these average delays have been used in the OPC UA model to represent the time spent for the verification of certificates by local or remote CAs, when requested during the simulation.Transport. This layer realises the transport services through UA TCP and SOAP/HTTP, used both in the OPC UA performance evaluation presented in the paper.The implementation of the OPC UA model shown in Fig. 5 has been realised through the coding of a software library in C++ which has been integrated within OMNET++ and INET frameworks. For each layer of the stack of Fig. 5, three main type of files have been coded: (1) .ned, (2) .h and (3) .cc; .ned files are used by OMNET++ to instantiate the layers of the stack for the simulation, while .h and .cc are respectively the interface and the implementation of the C++ class inside in which the functionalities of the stack layers are coded. The Client and Server Applications have been realised by coding the type of files (1), (2) and (3).The full model realised is available at [13], where detailed instructions are given in order to download, install and execute it.A great effort has been put to verify that the model behaved exactly as stated by the OPC UA specifications; this has been done executing all the methods implemented in the model realising OPC UA services, checking their behaviour inside the OMNeT++ framework (using the available tools), and verifying their full compliance with the OPC UA specifications.Once each method implemented in the model has been validated as explained before, validation has been performed also in terms of performances. As said in the Introduction, literature presents few works about OPC UA performance evaluation. Among them, the Intel study presented in [6] presents some interesting real measurements of OPC UA performance in terms of round-trip delay; considering OPC UA Client/Server applications, round-trip time may be defined as the total response time between the instant at which a request to access (read/write) one or a set variables is issued by a client and the instant at which this access is realised by the server. The same scenarios used for the round-trip time measurements presented in [6], have been implemented in our model and the relevant performance evaluation has been achieved through the simulation of the model, as explained in the next section. Table 1summarises the main results achieved, comparing the round-trip times when two different sizes of data blocks are transferred between client and server. As it can be seen, performances achieved by simulation of the OPC UA model are quite similar to that really measured inside the Intel study [6].

@&#CONCLUSIONS@&#
