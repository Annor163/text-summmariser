@&#MAIN-TITLE@&#
Longest common substrings with k mismatches

@&#HIGHLIGHTS@&#
Two new algorithms for the longest common substring with k mismatches problem.A practical solution for arbitrary k which uses constant space.A theoretical solution for one mismatch which runs in quasilinear time.

@&#KEYPHRASES@&#
Combinatorial problems,String algorithms,Hamming distance,Longest common substring,

@&#ABSTRACT@&#
The longest common substring with k-mismatches problem is to find, given two stringsS1andS2, a longest substringA1ofS1andA2ofS2such that the Hamming distance betweenA1andA2is ≤k. We introduce a practicalO(nm)time andO(1)space solution for this problem, where n and m are the lengths ofS1andS2, respectively. This algorithm can also be used to compute the matching statistics with k-mismatches ofS1andS2inO(nm)time andO(m)space. Moreover, we also present a theoretical solution for thek=1case which runs inO(nlog⁡m)time, assumingm≤n, and usesO(m)space, improving over the existingO(nm)time andO(m)space bound of Babenko and Starikovskaya [1].

@&#INTRODUCTION@&#
In this paper we study the longest common substring (or factor) with k-mismatches problem (k-LCF for short11We use the k-LCF abbreviation as LCS usually refers to the Longest Common Subsequence problem.) which consists in finding the longest common substring of two stringsS1andS2, while allowing for at most k mismatches, i.e., the Hamming distance between the two substrings is ≤k. This problem is a generalization of the Longest Common Substring problem [2–4] and is similar to the threshold all-against-all problem defined by Gusfield [2] and to the local alignment problem of biological sequence analysis. In the threshold all-against-all problem the goal is to find all the pairs of substrings ofS1andS2such that the corresponding edit distance is less than a given number d. The difference in the k-LCF problem is that the distance used is the Hamming distance rather than the edit distance, and that we are interested in the pairs of substrings of maximal length only. In the local alignment problem, which can be solved inO(|S1|⋅|S2|)time using the Smith–Waterman algorithm [5], the goal is to compute a pair of substrings ofS1andS2such that the corresponding similarity, according to a suitable scoring function, is maximum over all the pairs of substrings. In particular, if the scoring function is such that the score of a match is 1, the score of a mismatch is 0 and gaps are not allowed, a solution of the local alignment problem is comparable to one of the k-LCF problem, with the difference that there is no bound on the number of mismatches.Babenko and Starikovskaya [1] studied the case of 1 mismatch only and presented an algorithm for the 1-LCF problem which runs inO(|S1|⋅|S2|)time. A closely related problem is the one of computing the matching statistics with k mismatches. The matching statistics, introduced by Chang and Lawler [6] for the approximate string matching problem, is an array ms of|S2|integers such thatms[i]is the length of the longest substring ofS2that starts at position i and matches exactly some substring ofS1, fori=0,…,|S2|−1. A natural generalization is obtained by allowing the matching to be approximate, with respect to the Hamming distance. Recently, Leimeister and Morgenstern [7] presented a greedy heuristic for the computation of the matching statistics with k mismatches, which runs inO(|S1|⋅k⋅z)time, where z is the maximum number of occurrences inS2of a string of maximal length which occurs in bothS1andS2.In this paper we present two novel contributions. Our first result is an efficient algorithm for the k-LCF problem which runs in timeO(|S1|⋅|S2|)and only requires a constant amount of space. This algorithm can also be used to compute the matching statistics with k mismatches with no overhead in the time complexity, i.e., inO(|S1|⋅|S2|)time, and usingO(|S2|)space. Our second result is an algorithm for the 1-LCF problem, i.e., for thek=1case. We show how to solve this instance in a more time efficient manner by using results from Crochemore et al. [8] for finding the longest generalized repeat(s) with one block of k adjacent don't care symbols. Assuming|S2|≤|S1|, our algorithm takes timeO(|S1|log⁡|S2|), improving over the previous bound ofO(|S1|⋅|S2|).Let Σ be a finite alphabet of symbols and letΣ⁎be the set of strings over Σ. Given a stringS∈Σ⁎, we denote by|S|the length of S and byS[i]the i-th symbol of S, for0≤i<|S|. Given two strings S andS′,S′is a substring of S if there are indices0≤i≤j<|S|such thatS′=S[i]...S[j]. Ifi=0(j=|S|−1) thenS′is a prefix (suffix) of S. We denote byS[i..j]the substring of S starting at position i and ending at position j. Fori>jwe obtain the empty string ε. Finally, we denote bySr=S[|S|−1]S[|S|−2]…S[0]the reverse of the string S.The suffix treeT(S)of a string S is a rooted directed tree with|S′|leaves and edge labels over(Σ∪{$})⁎∖{ε}, where$∉ΣandS′=S$. Each internal node has at least two children and is such that the edge labels of the children have different first symbols. For each leaf i, the concatenation of the edge labels on the path from the root to leaf i is equal toS′[i..|S′|−1]. Assuming a constant size alphabet, the suffix tree can be built inO(|S|)time [2]. For any node u inT(S),depth(u)denotes the length of the string labeling the path from the root to u. For any pair of nodesu,vinT(S),LCA(u,v)denotes the lowest common ancestor of u and v, i.e., the deepest node inT(S)that is ancestor of both u and v. The suffix tree can be preprocessed inO(|S|)time so as to answer LCA queries in constant time [9]. We denote byB(S)the binary suffix tree obtained by replacing each node u inT(S)with out-degree at least 2 with a binary tree withd−1internal nodes (whose depth values are equal todepth(u)) andd−2internal edges, where the d leaves are the d children of u. The binary suffix tree can be built inO(|S|)time [8]. The generalized suffix treeT(S1,S2)of two stringsS1andS2is the suffix tree built overS′=S1$1S2$2, where$1,$2∉Σ, such that the leaves are numbered with a pair (s-index) and for each leaf(j,l)the concatenation of the edge labels on the path from the root to the leaf is equal toSj[l..|Sj|−1]$j. The index of a leaf(j,l)is the starting position ofSj[l..|Sj|−1]$jinS1$1S2$2. We use the notationB(S1,S2)to denote the binary generalized suffix tree ofS1andS2.LetS1andS2be two strings withn=|S1|,m=|S2|. W.l.o.g. we assume thatn≥m. Given an integer k, letϕ(i,j)be the length of the longest substring ofS1andS2ending at position i and j, respectively, such that the two substrings have Hamming distance at most k. Formally,ϕ(i,j)is equal to the largest integerl≤min⁡(i,j)+1such that|{0≤h≤l−1|S1[i−h]≠S2[j−h]}|≤k,for0≤i<n,0≤j<m. The longest common substring with k-mismatches problem consists in, given two stringsS1andS2and an integer k, finding the length of the longest substrings ofS1andS2with Hamming distance at most k, i.e.,maxi,j⁡ϕ(i,j).In this section we present a practical algorithm for the k-LCF problem. By definition,ϕ(i,j)is also the length of the longest suffixes ofS1[0..i]andS2[0..j]with Hamming distance at most k. Our algorithm computes all the valuesϕ(i,j)based on this alternative formulation. The idea is to iterate over the ϕ matrix diagonal-wise and compute, for a fixed(i,j)∈{(0,0),(0,1),…,(0,m−1)}∪{(1,0),(2,0),…,(n−1,0)}, the valuesϕ(i+p,j+p), for0≤p<min⁡(n−i,m−j), i.e., the diagonal starting at(i,j), inO(m)time. Let Q be an (empty) queue data structure ands=0, for a given pair(i,j). The algorithm iterates over p maintaining the invariant thatp−sis the length of the longest common suffix ofS1[i..i+p−1]andS2[j..j+p−1]up to k-mismatches, i.e.,p−s=ϕ(i+p−1,j+p−1), and that Q contains exactly the positions inS1of the mismatches betweenS1[i+s..i+p−1]andS2[j+s..j+p−1]with the order of elements in the queue matching their natural order.At the beginning the invariant holds since Q is empty,p−s=0andS1[i+s..i+p−1]=S2[j+s..j+p−1]=ε. Suppose that the invariant holds up to position p. IfS1[i+p]=S2[j+p]then the invariant trivially holds also forp+1withs′=sandQ′=Q. Otherwise, we have a mismatch betweenS1[i+p]andS2[j+p]. If|Q|<k, then the invariant also holds forp+1withs′=sandQ′equal to Q after anenqueue(Q,p)operation. Instead, if|Q|=k, the pair of suffixesS1[i+r..i+p]andS2[j+r..j+p], forr=s,…,min⁡Q, match withk+1mismatches andr=min⁡Q+1is the minimum position for which the corresponding suffixes match with k mismatches. Hence, in this case the invariant also holds forp+1withs′=min⁡Q+1andQ′equal to Q after a dequeue operation followed by anenqueue(Q,p)operation.The algorithm maintains the largest length found up to the current iteration and the starting positions of the corresponding substrings inS1andS2, such that the position inS1is minimal, in three integers ℓ,r1, andr2. Each timep−s>ℓit updates their values accordingly. The code of the algorithm is shown in Fig. 1. The time complexity of one iteration of the algorithm isO(1)if the queue operations take constant time, which yieldsO(m)time for a fixed i andO(nm)time in total. The space complexity isO(k), as the queue contains at most k elements at any iteration.For scanning one diagonal of ϕ, the algorithm needs time that is proportional to the length of the diagonal. This can be improved such that the time requirement becomes proportional to the number of mismatches along the diagonal, by using the well-known technique that performs LCA queries on the generalized suffix tree ofS1andS2to find, in constant time, how far the next mismatch is from the current one [10]. This gives an algorithm for the k-LCF problem that runs in time proportional to the number of pairs(i,j)such thatS1[i]≠S2[j].the algorithm can also be modified to useO(1)space at the price of a constant factor in the running time. We replace the queue with one integer q, encoding the number of mismatches (number of elements in the queue). The dequeue and enqueue operations then becomeq←q−1andq←q+1, respectively. The update of s requires the computation ofmin⁡Q+1, which, by definition, is equal to the smallest positions′>ssuch thatS1[i+s′−1]≠S2[j+s′−1]. To this end, we simply scanS1andS2from positioni+sandj+s, respectively, until we find a mismatch. As each symbol ofS1andS2is looked up at most twice, the time complexity does not change. In practice, using an explicit queue is preferable, as it allows one to avoid rescanning the already scanned parts of the strings.finally, we describe how to compute the matching statistics with k mismatches ofS2with respect toS1. The matching statistics with k mismatches ofS2w.r.t.S1is an arraymskof m integers such thatmsk[i]is the length of the longest prefix ofS2[i..m−1]that matches a substring ofS1with at most k mismatches, fori=0,…,m−1. Using the algorithm described above, the arraymskcan be computed inO(nm)time andO(m)space as follows: first, we initialize each slot ofmskto 0; then, we run our algorithm onS1randS2r, i.e., on the reverse of the stringsS1andS2, and for each computed cellϕ(i,j)we setmsk[m−1−j]=max⁡(msk[m−1−j],ϕ(i,j)). At the end of the procedure we thus havemsk[m−1−j]=maxi⁡ϕ(i,j), for0≤j<m. The correctness of this procedure follows by observing that i) a suffix ofSr[0..i]is the reverse of a prefix ofS[|S|−1−i..|S|−1], for any string S and0≤i<|S|, and ii)ϕ(i,j)is the length of the longest suffixes ofS1r[0..i]andS2r[0..j]with Hamming distance at most k. Hence,maxi⁡ϕ(i,j)is the length of the longest prefix ofS2[m−1−j..m−1]that matches a substring ofS1with at most k mismatches.Note that the ϕ matrix forS1andS2immediately gives a dual matching statistics, wheremsk[i]is defined as the length of the longest suffix ofS2[0..i]that matches a substring ofS1with a most k mismatches. In practical applications this alternative matching statistics could be equally good.In this section we describe an algorithm that solves the 1-LCF problem. We first introduce some necessary technical definitions. Given a string S, a pair of substrings((p1,q1),(p2,q2))of S is a repeated pair ifS[p1..q1]=S[p2..q2]. A repeated pair((p1,q1),(p2,q2))is left-maximal (right-maximal) ifS[p1−1]≠S[p2−1](S[q1+1]≠S[q2+1]). Given a string S, a repeat is a substring of S that corresponds to a repeated pair. A repeat w of S is left-maximal (right-maximal) if there exists a left-maximal (right-maximal) repeated pair((p1,q1),(p2,q2))such thatS[p1..q1]=S[p2..q2]=w. Let ⁎ be the don't care symbol, i.e., a symbol that matches any symbol of Σ. A k-repeat of S is a string of the formu⁎kvthat matches more than one substring of S, whereu,v∈Σ⁎andk>0. A longest k-repeat is a k-repeat of maximum length. A necessary condition for a k-repeatu⁎kvto be longest is that, for each pair((p1,q1),(p2,q2))of substrings matching the repeat,((p1,p1+|u|−1),(p2,p2+|u|−1))is a left-maximal repeated pair and((p1+|u|+k,q1),(p2+|u|+k,q2))is a right-maximal repeated pair.The idea is to reduce the 1-LCF problem to the one of computing the longest 1-repeats ofS¯=S1$1S2$2that occur in bothS1andS2, where$1,$2are two symbols not in Σ. Letℓ=maxi,j⁡ϕ(i,j)fork=1, and leti′,j′be such thatϕ(i′,j′)=ℓ. Consider the stringsA1=S1[i′−ℓ+1..i′]andA2=S2[j′−ℓ+1..j′]. It is not hard to see that the stringA1[0..p−1]⁎A1[p+1..ℓ−1]is a longest 1-repeat ofS¯that occurs in bothS1andS2, where eitherA1=A2and0≤p≤ℓ−1orA1≠A2and p is the position corresponding to the single mismatch betweenA1andA2.To this end, we use a modified version of the algorithm all-longest-k-repeats by Crochemore et al. to find the longest k-repeats of a string [8]. The idea is to run this algorithm on the stringS¯withk=1. With this input, the original algorithm reports all the longest 1-repeats ofS¯. To solve our problem we need to add the constraint that the 1-repeats must occur in bothS1andS2. As the longest such repeats can be shorter than the unconstrained longest 1-repeats ofS¯, the all-longest-k-repeats algorithm must be modified accordingly.The all-longest-k-repeats algorithm is structured in the following steps:1.build the suffix treeT(S)of S and compute the ordering no of the leaves induced by a depth-first visit; build the binary suffix treeB(Sr)ofSrand associate to each leaf u with index i a listAuequal to{no(i¯)}, ifi≥k, and to ∅ otherwise, wherei¯=|S|−i+k;γ←0foru∈B(Sr)in depth-first order with childrenu1andu2do(a)find-longest(Au1,Au2,depth(u)+k,γ)Au←merge(Au1,Au2)Letu,v,wbe leaves in the suffix tree of S with corresponding depth-first ordering of leaves no. Ifno(u)<no(v)<no(w)orno(w)<no(v)<no(u)thendepth(LCA(u,v))≥depth(LCA(u,w)).LetL(u)be the list containing the integeri¯for each leaf with index i in the subtree of node u ofB(Sr). The idea is to iterate over all the left-maximal repeats of S usingB(Sr)and for each pair(p1,p2)of indexes inL(u)of such a repeat u compute the right-maximal repeat starting at positionp1andp2using an LCA query onT(S). It turns out, by the above lemma, that, for a given indexp∈L(u), it is enough to check the pairs(p,q)and(p,r)where q and r are the indexes of the closest leaves to leaf p inT(S), with respect to the ordering no, such thatq,r∈L(u).Our modification consists in the following: we replaceT(S)with the generalized suffix tree ofS1andS2andB(Sr)with the binary generalized suffix tree ofS1randS2r. LetLj(u)be a list containing the integeri¯, for each leaf with s-index(j,l)and index i in the subtree of node u ofB(S1r,S2r), provided thatl≥k, forj=1,2. The conditionl≥kensures that the occurrence of u inSjending at position|Sj|−1−lcan be extended by k don't care symbols to the right, as otherwise there can be no k-repeat with left part equal to the reverse of u label matching a prefix ofSj[|Sj|−1−l−depth(u)+1..|Sj|−1]. Our goal is to iterate over pairs inL1(u)×L2(u)only by computing, for a given indexp∈L1(u), the indexes q and r of the closest leaves to leaf p inT(S1,S2), with respect to the ordering no, such thatq,r∈L2(u), and vice versa ifp∈L2(u). To accomplish this, it is enough to associate to each leaf u ofB(S1r,S2r)with s-index(j,l)and index i two lists,Au1andAu2: ifl<kthe lists are empty; otherwise, ifj=1thenAu1={no(i¯)}andAu2=∅, and vice versa ifj=2. Then, we change the operations in the second step of the algorithm as follows:(a)find-longest(Au11,Au22,depth(u)+k,γ)find-longest(Au12,Au21,depth(u)+k,γ)Au1←merge(Au11,Au21)Au2←merge(Au12,Au22)We now prove that the time complexity of steps a, b, c, and d isO(mlog⁡(n/m)), wherem=min⁡(|Au1|,|Au2|),n=max⁡(|Au1|,|Au2|), i.e., there is only a constant overhead compared to the original algorithm. Suppose w.l.o.g. thatm=|Au1|,n=|Au2|and letmi=|Au1i|andnj=|Au2j|, for1≤i,j≤2. Note thatm≥m1+m2andn≥n1+n2. Step a, b, c, or d takes i)O(milog⁡(nj/mi))=O(milog⁡(n/mi))time, ifmi≤nj; ii)O(njlog⁡(mi/nj))=O(njlog⁡(n/nj))time otherwise, wherenj≤mi. We show thatalog⁡(n/a)≤mlog⁡(n/m)for any1≤a≤m. This inequality can be written asf(m)−f(a)m−a≤log⁡nwheref(x)=xlog⁡x. We havef′(x)=log⁡xand, by the mean value theorem, there existsc∈(a,m)such thatf(m)−f(a)m−a=log⁡c≤log⁡m≤log⁡n.The total time complexity of our algorithm for the 1-LCF problem is thusO((n+m)log⁡(n+m)). Assumingm≤n, we can reduce it toO(nlog⁡m)by partitioningS1into overlapping substrings of length 2m such that the overlap between two consecutive substrings is of length m, and running the algorithm on each substring andS2. Formally, we run the algorithm onS1[m⋅i..min⁡(m⋅i+2m,n)−1]andS2and obtain a valueγi, for0≤i<⌈n/m⌉. Then,ℓ=maxi⁡γi. The time complexity of this algorithm isO((n/m)mlog⁡m)=O(nlog⁡m).

@&#CONCLUSIONS@&#
