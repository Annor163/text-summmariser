@&#MAIN-TITLE@&#
A filtration method for order-preserving matching

@&#HIGHLIGHTS@&#
We present a sublinear solution based on filtration for order-preserving matching.Any algorithm for exact string matching can be used as a filtering method.If the filtration algorithm is sublinear, the total method is sublinear on average.We show by practical experiments that the new solution is more efficient than earlier algorithms.

@&#KEYPHRASES@&#
Algorithms,Combinatorial problems,Order-preserving matching,String searching,

@&#ABSTRACT@&#
The problem of order-preserving matching has gained attention lately. The text and the pattern consist of numbers. The task is to find all the substrings in the text which have the same length and relative order as the pattern. The problem has applications in analysis of time series. We present a new sublinear solution based on filtration. Any algorithm for exact string matching can be used as a filtering method. If the filtration algorithm is sublinear, the total method is sublinear on average. We show by practical experiments that the new solution is more efficient than earlier algorithms.

@&#INTRODUCTION@&#
String matching [1] is a widely known problem in Computer Science. Given a text T of length n and a pattern P of length m, both being strings over a finite alphabet Σ, the task of string matching is to find all the occurrences of P in T. The problem of order-preserving matching [2–6] has gained attention lately. It considers strings of numbers. The task is to find all the substrings (also called factors) u in T which have the same relative order as P, and|u|=|P|. SupposeP=(10,22,15,30,20,18,27)andT=(22,85,79,24,42,27,62,40,32,47,69,55,25), then the relative order of P matches the substringu=(24,42,27,62,40,32,47)of T, see Fig. 1.Several online [7,5,3,4] and one offline solution [2] have been proposed for order-preserving matching. Kubica et al. [4] and Kim et al. [3] presented solutions based on the Knuth–Morris–Pratt algorithm (KMP) [8]. Later, Cho et al. [5,6] gave a sublinear solution based on the bad character heuristic of the Boyer–Moore algorithm [9]. Almost at the same time, Belazzougui et al. [7] derived an optimal sublinear solution. We will present a new practical solution based on filtration. We form a modified pattern and use an algorithm for exact string matching as a filtration method. Our approach is simpler and in practice more efficient than earlier solutions. We transform the original pattern P into a binary stringP′expressing increases (1), equalities (0), and decreases (0) between subsequent pattern positions. Then we search forP′in the analogously transformed textT′. For example,P′=101001corresponds toP=(10,22,15,30,20,18,27)andT′=100101001100to T above. Each occurrence is a match candidate which is verified following the numerical order of the positions of the original pattern P. Note that in this approach any algorithm for exact string matching can be used as a filtration method. If the filtration algorithm is sublinear and the text is transformed on line, the total method is sublinear on average.We made experiments with two sublinear string matching algorithms and two linear string matching algorithms as the filtering method. Our approach with sublinear filters was considerably faster than the algorithm by Cho et al. [5], which is the first sublinear solution of the problem.The paper is organized as follows. Section 2 describes the previous solutions for order-preserving matching, Section 3 presents our solution based on filtration, Section 4 analyses the new approach, Section 5 presents and discusses the results of practical experiments, and Section 6 concludes the article.In the first KMP approach presented by Kubica et al. [4], the fail function in the KMP algorithm is modified to compute the order-borders table. This can be achieved in linear time. The KMP algorithm is mutated such that it determines if the text contains substring with the same relative order as that of the pattern using the order-borders table. This computation can be done in linear time. Hence, the total time complexity of the method is linear.The second KMP approach by Kim et al. [3] is based on the prefix representation. The prefix representation is based on finding the rank of each number in the prefix. The time complexity of the method isO(nlog⁡m). This approach is further optimized using the nearest neighbor representation to overcome the overhead involved in computing the rank function. The time complexity of the improved version isO(n+mlog⁡m).The BMH approach by Cho et al. [5] is based on the bad character rule applied to q-grams, i.e. strings of q characters. A q-gram is treated as a single character in order to make shifts longer. In this way, a large amount of text can be skipped for long patterns, and the algorithm is sublinear on average. The standard version works inO(mn)in the worst case. Later, Cho et al. [6] introduced a linear version, which has been combined with KMP in order to guarantee linear behavior in the worst case.In Section 1 we gave an informal description of order-preserving matching. Let us define the problem formally.Two stringsu=u1u2⋯umandv=v1v2⋯vmof the same length over Σ are called order-isomorphic[3,4], writtenu≈v, ifui≤uj⇔vi≤vjfor1≤i,j≤m.In the order-preserving pattern matching problem, the task is to find all the substrings ofT=t1t2⋯tnwhich are order-isomorphic withP=p1p2⋯pm.Our solution for order-preserving matching consists of two phases: filtration and verification. First the text is transformed to a bit string which is filtered with some exact string matching algorithm. In the second phase the match candidates are verified using a checking routine.For filtration, the consecutive numbers in the patternP=p1p2⋯pmare compared pairwise in the preprocessing phase and the result is encoded as a modified patternP′=b1b2⋯bm−1of binary numbers:biis 1 ifpi<pi+1holds, otherwisebiis 0. In the search phase, some algorithm for exact string matching (let us call it A) is applied to filter out the text. When Algorithm A reads an alignment window of the original text, the text is encoded incrementally online in the same way as the pattern. Algorithm A is run as if the whole text would have been encoded. Because Algorithm A may recognize an occurrence ofP′which does not correspond to an actual match of P in T, each occurrence ofP′is only a match candidate which should be verified. It is clear that this filtration method cannot skip any occurrence of P in T.During preprocessing the pattern, the numbers of the patternP=p1p2⋯pmare sorted. The result is an auxiliary table r:pr[i]≤pr[j]holds for each pairi<jandpr[1]is the smallest number in P. In addition, we need a binary vector E representing the equalities:E[i]=1denotes thatpr[i]=pr[i+1]holds. The match candidates found by Algorithm A are traversed in accordance with the table r. If the candidate starts fromtjin T, the first comparison is done betweentj−1+r[1]andtj−1+r[2]. There is a mismatch whentj−1+r[i]>tj−1+r[i+1]or(tj−1+r[i]=tj−1+r[i+1]andE[i]=0)or(tj−1+r[i]<tj−1+r[i+1]andE[i]=1)is satisfied. The candidate is discarded when a mismatch is encountered. Verification is efficient because sorting is done only once during preprocessing.We use binary numbers in encoding. We also tried encoding of three numbers 0, 1, and 2 corresponding to ‘<’, ‘=’, and ‘>’, but the binary approach was faster in practice, because testing of one condition is faster than testing of two conditions. Also the frequency of nearby equalities is low in real data.

@&#CONCLUSIONS@&#
