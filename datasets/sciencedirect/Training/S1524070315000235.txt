@&#MAIN-TITLE@&#
Smooth convolution-based distance functions

@&#HIGHLIGHTS@&#
Smoothing a triangle mesh by constructing an implicit convolution-based surface.Both the convolution kernel and the implicitization of the mesh are linearized.The straight skeleton is used to linearize the mesh.The resulting distance function is globally C2 continuous.It can be explicitly analytically evaluated.

@&#KEYPHRASES@&#
Implicit surface,Convolution,Signed distance function,Straight skeleton,Analytical solution,

@&#ABSTRACT@&#
Smooth surface approximation is an important problem in many applications. We consider an implicit surface description which has many well known properties, such as being well suited to perform collision detection. We describe a method to smooth a triangle mesh by constructing an implicit convolution-based surface. Both the convolution kernel and the implicitization of the mesh are linearized. We employ the straight skeleton to linearize the latter. The resulting implicit function is globally C2 continuous, even for non-surface points, and can be explicitly analytically evaluated. This allows the function to be used in simulation systems requiring C2 continuity, for which we give an example from industrial simulation, in contrast to methods which only locally smooth the surface itself.

@&#INTRODUCTION@&#
In many applications smooth surface approximation of triangular networks is an important problem. Variational design [16] is a standard technique to solve these kinds of problems. Usually B-spline surfaces are targeted. Well known methods dealing with explicit surface representations, such as corner cutting, lead to B-spline patches or more generally subdivision surfaces [11]. Other methods employ fairing of the meshes while still keeping a mesh structure [13]. Another possible way to represent surfaces is as implicit functions. Implicit surfaces have proven to be a powerful tool in surface design [9,26,29]. When the surfaces represent the boundaries of solids, it is often important to efficiently determine the inside and outside of the solids. This can easily be achieved with implicit surfaces using a sign check [25].Our goal is to get a smooth approximation of the polygonal mesh while still being able to control the original mesh interpolating surface. Therefore we introduce a feature size parameter that controls the smoothing effect. Another constraint on our implicit representation, motivated by the application presented in Section 7, is being able to compute gradients and second derivatives and to perform collision detections (inside/outside checks) for non-surface points.We certainly could create smooth surfaces with rather good approximation quality using subdivision surfaces, but as we aim to use an implicit surface description, a global implicitization would require an expensive computation. The smoothing effect would also be local and would affect only a small neighborhood of the surface (cf. [21] Section 2.3).The main contribution of this paper therefore is presenting a convolution-based implicit surface definition for triangle meshes, whose underlying distance function is globally smooth even on non-surface points. We employ linearizations that allow the function to be computed analytically. The linear kernel used is not novel, but to our knowledge its use in this context is. Notable prior work are Bloomenthal’s convolution surfaces [8] and Colburn’s smoothing method [12]. Differences to our approach are detailed below.Whenever it aids visualization or discussion, figures show the equivalent 2-d representation of our method. Fully 3-d images are given where necessary, see also Section 6. We also concentrate on triangle meshes only, since polygon meshes can be converted to triangle meshes easily. Fig. 1shows the result of our method applied to a solid in 2-d. While the signed minimum distance function has cusps where it is not differentiable, our smoothed distance field is C2 everywhere. This cannot be achieved by only smoothing out the solid’s edges and then computing the signed minimum distance, as this would still lead to cusps not lying on the surface.This paper is structured as follows: in Section 2 we give a brief survey of implicit functions and describe a convolution-based smoothing approach. Our choice for a linearized kernel is described in detail in Section 3. In Section 4 we give a brief survey of the straight skeleton as described by Aichholzer et al. and use it to give an implicit surface definition. We discuss the approximation quality of the resulting surface in Section 5, give results of smoothed surfaces in Section 6, and present an application in Section 7.Implicit functions are widely used tools to describe surfaces and solids in geometric modeling. In the most general form, an implicit surface is the iso-surface of a potential field F for an iso-value T:(1)F(x)−T=0.Solids can be described as the interior of an implicit surface, i.e. all points x for whichF(x)−T≤0. CSG operations, such as union and intersection of different solids, can then be implemented easily as min  and max  operations.Convolution surfaces, as first described by Bloomenthal and Shoemake [8], are implicit surfaces based on skeleton primitives like lines and triangles. The resulting surfaces are a smooth blend of iso-potentials around the primitives, but do not approximate the original mesh in the way we intend. The convolution integrals for these surfaces are mostly computed by a numerical scheme. A different approach is Colburn’s method [12], who does corner smoothing by a numerical convolution of a solid’s characteristic function with a Gaussian function. Our method employs a linearization of the convolution kernel as well as an implicit description of the triangle-manifold. This allows us to exactly evaluate the implicit function without reverting to numerical methods, in contrast to the numerical integration needed for Colburn’s approach.Bloomenthal and Shoemake describe convolution surfaces as an extension of Blinn’s blobby model [7] for implicit surface design. They employ a convolution of a filter kernel over a skeleton to create a surface. The resulting surfaces resemble the skeleton, but surround it instead of approximating it. Fig. 2 schematically illustrates the conceptual difference between convolution surfaces on the one hand and the surfaces created by Colburn’s method and ours on the other hand. Bloomenthal’s convolution surfaces integrate over skeletons only, whereas we integrate over the complete domain of the implicit function. While both methods nicely round the corners of the square, convolution surfaces create an exterior and interior surface offsetted from the original skeleton. The innermost area has the same sign as the outside area. Thus, in our scenario convolution surfaces cannot simply be applied to a solid’s boundary, because, without further computation, they do not lead to a signed distance function to discriminate inside and outside.To apply a convolution-based smoothing, we first have to convert the explicitly given triangle mesh to an implicit representation. The straightforward way for implicitizing a given triangle mesh Δ is using the signed minimum Euclidean distance function(2)f(x)=sΔ(x)minp∈Δ∥x−p∥,where the sign functionsΔ(x)corresponds to x lying either inside or outside the solid. Partitioning the space like this turns out to be very useful. Only the sign of the distance function has to be evaluated to determine if a point lies inside or outside a volume enclosed by the surface. The zero level set of this function represents the surface. A characteristic function of the solid, effectively the same assΔ(x),would be even simpler but does not have gradients at all.The function f defined in Eq. 2 is C0 continuous. It can be described by the generalized Voronoi diagram of the triangle mesh. The Voronoi diagram partitions the domain of f into regions where it is linear (distance to a triangle plane) or square-root (distance to a triangle edge or corner). Thus, inside these regions, the function is smooth but not differentiable along the borders. The borders of these regions are made up of straight polygonal segments and conic surface patches.Our goal is now to smooth out those parts of the function where it is not differentiable. This inherently implies smoothing out the edges of the mesh. One way to achieve this is using a convolution and so increasing the smoothness. Convolution with an appropriate kernel K results in a smoother surfaceh=K☆fas:(3)h(x)=(K☆f)(x)=∫RdK(x−p)f(p)dp.The smoothness of the resulting function h is determined by both the kernel used and the implicit function f. We will therefore describe how to choose these to achieve C2 continuity while being able to compute the results analytically.Common choices for kernel functions K are the Gauss function combined with the L2 norm to obtain a radially symmetric kernel. The Gauss function can also be replaced by a cubic spline with compact support. An analysis of different kernel functions (in the context of convolution surfaces) is given by Sherstyuk [27]. For all kernels except for the Cauchy kernel, the resulting integrals over triangles are then numerically approximated. Recently, Jin et al. [20] gave analytical solutions for a quartic spline with compact support. They too are, however, using the skeleton approach of Bloomenthal integrating over triangles, whereas we give analytical solutions for integrals over tetrahedra.Using the generalized Voronoi diagram, we can partitionR3into regions Risuch that f is partitioned into functionsfi=f|Riwhich are linear or square-root. The convolution integral is then just the sum over the regions Ri:(4)h(x)=∑i=1n∫RiK(x−p)fi(p)dp.This allows us to express the integration in simpler terms than the piecewise global definition, but does not suffice to analytically evaluate the integral. Therefore, we employ a linearization of both the kernel K and implicit description of the mesh f in the following.We simplify the convolution integrals by linearizing both the filter kernel K and the underlying implicit distance function f. Using a C0 function f and a C0 convolution kernel K we obtain a C2 implicit surface. We base our kernel on the one-dimensional hat function:(5)k(x)=max(1−|x|,0)={1−|x|for|x|≤1,0otherwise.We could achieve even higher continuity by using a kernel of higher degree. For example, a cubic or quartic C1 kernel leads to a C3 surface but also has higher computational costs.The usual approach to create a multi-dimensional version of the kernel is to use the L2 norm of the vector as input. This creates a radially symmetric kernel with a spherical (or in the 2-d case circular) support.We want instead to use a kernel with cubic support to allow easier integration. Two possibilities to create a 3-dimensional convolution kernel are to use the maximum normK(x,y,z)=k(max(|x|,|y|,|z|))=min(k(x),k(y),k(z))or the productK(x,y,z)=k(x)k(y)k(z)of the 1-dimensional kernel values. The max-version is piecewise linear, its support can be split up into six pentahedral regions where it is linear. The tensor product version has the advantage of being separable. Its support is trilinear on cubic regions. Fig. 3shows the 2-d equivalents of these kernels for easier visualization. We use the tensor product kernel, although the same approach works for the max kernel. The first and second partial derivatives can be computed as a convolution with the corresponding derivatives of the kernel, where δ is the Dirac delta function:(6)k′(x)={−sign(x)for|x|≤1,0otherwise,k′′(x)=δ(x−1)−2δ(x)+δ(x+1).We trade ease of integration for isotropy by not using a radially symmetric kernel. The convolution has a certain anisotropy. That means it is not rotation invariant but depends on the coordinate system. Normally this is an undesirable feature, but it does not affect the result in a significant way. We will get back to this in Section 5.To control the approximation quality we scale the hat function given in Eq. 5 by a parameter r:(7)kr(x)=1rmax(1−|x|r,0).and its corresponding higher dimensional version Krof the kernel. It is obvious that the value h(x) for a point x is influenced only by those values of f that lie inside the kernel’s support. Thus, we can consider the parameter r as a feature size parameter which determines how large the smoothed out parts of the surface are.Given this kernel we get the following convolution equation:(8)h(x)=(Kr☆f)(x)=∫R3kr(x−s)kr(y−t)kr×(z−u)f(s,t,u)dsdtdu.Using the separability of the kernel, this can be split up into 8 integrals at the boundaries concerning its piecewise definition, such that in each dimension the kernel arguments lie in either[−r,0]or [0, r]. This gives linear terms for the 1-d kernel. Computing these integrals then depends on the definition of the function f. Using f as defined in Eq. 2 gives a function that is a piecewise square-root function. Splitting up the integrals on the definition regions of f is thus not feasible because the borders of the regions are complex. Therefore, we give a linearized definition of f in the next section.In this section we describe how to construct an implicit function f that allows us to exactly solve the convolution integrals. The Voronoi diagram of the minimum distance function as given in Eq. 2 contains conic segments. As it is difficult to find exact solutions for integrals over these regions, Eq. 2 is not very suitable for the given task. We could overcome this by linearly approximating the Voronoi diagram by a set of tetrahedra (triangles for 2 dimensions). The original mesh is still correctly represented independent of the chosen tesselation as long as we guarantee that the zero level set is identical to the original mesh. The smoothed surface, however, does depend on the chosen tesselation.An adaptive subdivision algorithm for approximating the generalized Voronoi diagram for triangles in three dimensions is given by Teichman and Teller [28]. This inevitably leads to a subdivision into many small cells for regions with high curvature. Rasterization-based approaches for two and three dimensions are given, for example, by Hoff et al. [17] as well as others. Numerical accuracy depends on the chosen resolution of the rasterization.We will instead construct a function not based on Eq. 2 to use as an implicit mesh description. The function should have the property that it is continuous and piecewise linear, where the linear pieces should have polygonal boundaries and correspond to the signed distances to the planes spanning the mesh triangles. We therefore need a partition of space that allows such a construction. For 2-dimensional space, this partition is provided by the straight skeleton, which we describe first before discussing the 3-dimensional generalization.The straight skeletonS(P)of a simple polygon P was introduced by Aichholzer et al. [1,2]. The skeleton structure is similar to a Voronoi diagram, but consists of straight line segments only (Fig. 4). The authors mention several other previous attempts to simplify the Voronoi diagram of straight line graphs, including Canny and Donald [10], and also that the straight skeleton itself has been used before in less general settings. The skeleton is identical to the Voronoi diagram for convex polygons. The situation is different for concave polygons, where the Voronoi diagram contains conic segments. The skeleton is defined by a wavefront propagation process where each edge of the polygon emits a wavefront traveling at constant speed orthogonal to the edge. This defines a family of offsetted polygons to P. At certain time points, called events, wavefronts meet and the topology of the offset polygon changes. The straight skeleton is then defined as the locus of the polygon vertices traced out by the wavefront propagation.The straight skeleton can be computed by the algorithm given in [2] in theoretical worst-case time O(n3log n) and a better average time for typical inputs. More complex and faster algorithms have been proposed in the literature. A detailed survey is given by Huber [18], who also gives an algorithm that runs in O(n2log n) worst case and O(nlog n) for most typical inputs [19].We use the straight skeleton to partition the plane into regions. Each faceF(e)corresponding to an edge e defines a region where our function f is linear:f|F(e)(x)=d(x,e),where d( ·, e) is the signed distance function to the line spanning edge e. This corresponds to the terrain as defined by Aichholzer and Aurenhammer [2], which maps each point to the time it is reached by the wavefront. We use a signed distance instead to distinguish the interior and exterior of the surface. The function f thus defined is continuous, piecewise linear, and has a slope of at most 1 in any direction.In the 3-dimensional case, we do not have line segments but polyhedral meshes. We have to compute a tetrahedral partition ofR3induced by these meshes. A 3-dimensional generalization of the straight skeleton is first described by Barequet et al. [5]. Further analysis of the 3-dimensional skeleton is given by Aurenhammer and Walzl [4]. The skeleton is no longer uniquely defined for certain inputs. A unique way to define the skeleton is given in [4], although for our use case any choice seems sufficient. The resulting skeleton is a polyhedral mesh. Fig. 5shows the skeleton of a T-shaped polyhedron (diagonals to subdivide quadrilaterals into triangles are not shown). Each triangle T of the input mesh is associated with a polyhedral faceF(T). We use these faces to partition space into regions analogous to the 2-dimensional case: we define the function f to be linear for each face asf|F(T)(x)=d(x,T),where d( ·, T) is the signed distance to the plane spanning triangle T. We can then use the convolution Eq. 8 to compute implicit C2 surfaces in 3 dimensions. See Section 6 for examples.The convolution integral is computed by summing up the integrals over the linear regions as in Eq. 4. This means clipping the cubic regions of the kernel’s support with the straight skeleton faces, tetrahedralizing the resulting volumes, and summing up the integrals over these tetrahedra.Only a small number of the regions resulting from the straight skeleton will actually intersect with our convolution kernel. Thus, it is important to employ a space partioning scheme to quickly find only relevant regions. In our implementation, a simple Octree–based approach was sufficient, although, more complex schemes like a cell tree [14] could be useful for complex scenarios. The faces of a straight skeleton may be concave (they are monotonous but not necessarily convex). We can subdivide these into convex polygons first to simplify further processing. Thus, we can use a fast and simple algorithm to clip a convex polyhedron with an axis-aligned cube.11For the 2-dimensional analog, this corresponds to the Sutherland-Hodgman algorithm.This again results in a convex polyhedron which is trivial to subdivide into tetrahedra.The computational cost of evaluating the smooth distance function can be divided into two parts. The computation of the tetrahedra has to be done only once, while integrating over tetrahedra intersecting the smoothing region has to be done for each distinct input position for which the function is evaluated. The first part is dominated by the straight skeleton computation, which Barequet et al. give as O(kn), where n is the input size and k the number of events that occur. The cost of the actual function evalution is dependent on the data and the size of the smoothing kernel. Let m be the the number of tetrahedra intersecting the kernel’s domain, then for a single tetrahedron it takes O(log n) time to find the tetrahedron in the space partitioning structure, while integrating over it is bounded by constant time, resulting in a total of O(mlog n) to integrate over all tetrahedra. Depending on the kernel size, m is usually much smaller than n.In this section, we discuss the quality of the surface approximations depending on the feature size parameter r. If we want to perform an inside/outside check of a point x for collision detection, it suffices to determine the sign of h(x). Thus, we aim to find a value vrdepending on r, such that for values |f(x)| > vrthe sign of h(x) is guaranteed to be the same as the sign of f(x).We note that, by construction of f using the straight skeleton22The same holds true for the min distance function of Eq. 2., the slope (where defined) of f in any direction is at most 1. Thus, we know that whenever |f(x)| has a value greater than half of the kernel’s diameter, all values in the kernel’s support have the same sign and, therefore, so does h(x). This means that a simple bound vrisvr=drfor a d-dimensional kernel.This simple bound vrcan, however, be further improved. We consider the pointwise absolute difference|h(x)−f(x)|between the original function f and the smoothed function h.(9)|h(x)−f(x)|=|∫RdKr(x−p)(f(p)−f(x))dp|.As noted above, the slope of f is at most 1, so that|f(p)−f(x)|≤∥p−x∥:|h(x)−f(x)|≤∫Rd|Kr(x−p)|∥x−p∥dp=∫RdKr(y)∥y∥dy.In the 2-dimensional case, this leads us to:|h(x)−f(x)|≤41r2∫0r∫0r(1−sr)(1−tr)s2+t2dsdt=4r∫01∫01(1−u)(1−v)u2+v2dudv=4(160(2+2+5ln(1+2)))r<0.5215r.This bound is tight: the inequality is reached in the limit for a regular n-gon centered around x. The graph of f, then, is an n-sided pyramid, which becomes a cone in the limit. For three dimensions we can get a similar bound of|h(x)−f(x)|<0.6618r,which is also tight.We can now reconsider the effect of anisotropy using the same approach. We rotate the kernel to study the extent to which the anisotropy affects the result and compare the smoothed surface to the version smoothed with the unrotated kernel.In a 2-dimensional setting, let Rαbe the 2 × 2 matrix rotating by α. LetKr*(x)=Kr(Rαx)be the rotated kernel andh*=Kr*☆fbe the corresponding smoothed function. We consider the difference|h(x)−h*(x)|forα=π4:|h(x)−h*(x)|=|∫R2(Kr(x−p)−Kr*(x−p))(f(p)−f(x))dp|≤∫R2|(Kr(y)−Kr*(y))|∥y∥dy<0.1036r.Fig. 6 shows that this bound is maximal forα=π4. This bound can, however, probably be improved. It is unlikely in practice that the sign of f changes to match the sign ofK−K*(see Fig. 6), so that some of the values cancel out instead of adding up, which leads to a smaller difference. A typical example with a much lower difference is given in the next section. Analogously for three dimensions, there is a rotation Matrix Rψ, θ, ϕthat maximizes the difference|h(x)−h*(x)|. We can thus compute a bound of|h(x)−h*(x)|<0.1626r.

@&#CONCLUSIONS@&#
