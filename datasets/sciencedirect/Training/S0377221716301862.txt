@&#MAIN-TITLE@&#
An adaptive large neighborhood search for the two-echelon multiple-trip vehicle routing problem with satellite synchronization

@&#HIGHLIGHTS@&#
We integrate multiple trips, time-windows and synchronization in the two-echelon vehicle routing problem.We propose an adaptive large neighborhood search with efficient heuristics to explore the solution space.Temporal precedence and synchronization constraints are efficiently handled.Existing instances were extended to constitute benchmarks for this problem.The methodology has been successfully applied to these instances.

@&#KEYPHRASES@&#
Routing,Two-echelon VRP,Synchronization,City logistics,Adaptive large neighborhood search,

@&#ABSTRACT@&#
The two-echelon vehicle routing problem (2E-VRP) consists in making deliveries to a set of customers using two distinct fleets of vehicles. First-level vehicles pick up requests at a distribution center and bring them to intermediate sites. At these locations, the requests are transferred to second-level vehicles, which deliver them. This paper addresses a variant of the 2E-VRP that integrates constraints arising in city logistics such as time window constraints, synchronization constraints, and multiple trips at the second level. The corresponding problem is called the two-echelon multiple-trip vehicle routing problem with satellite synchronization (2E-MTVRP-SS). We propose an adaptive large neighborhood search to solve this problem. Custom destruction and repair heuristics and an efficient feasibility check for moves have been designed and evaluated on modified benchmarks for the VRP with time windows.

@&#INTRODUCTION@&#
The two-echelon vehicle routing problem (2E-VRP) consists in routing freight from a central depot to customers through a set of intermediate sites. The depot is an intermodal logistics site called the distribution center (DC). It has some storage capacity, and it is where consolidation takes place. Intermediate sites, usually called satellites, have little or no storage capacity but are located closer to customers. Two fleets of vehicles are involved: first-level vehicles carry requests from the DC to the satellites, and second-level vehicles carry requests from the satellites to the customers. First-level vehicles are usually significantly larger than second-level vehicles.Over the last few years freight transportation in urban areas has received much attention (Cattaruzza, Absi, Feillet, & González-Feliu, 2015). Indeed, because of increasing traffic congestion, environmental issues, and low average truckloads, new policies (e.g., London Congestion Charges, Monaco UDC) and initiatives (Amsterdam City Cargo) have emerged to ban large trucks from city centers. This movement is known as city logistics and represents a move from independent direct shipping strategies toward integrated logistics systems. In this context, multi-echelon distribution systems and particularly two-tiered systems are often proposed as an alternative to current distribution systems (Crainic, Ricciardi, & Storchi, 2009).Several specific constraints arise in the urban context: time windows, multiple use of vehicles, and synchronization. Delivery hours are often restricted because of customer requirements or city regulations. Moreover, second-level vehicles are usually small in order to access every street, so even a full load does not represent an entire work-day. Finally, operating a satellite in a city is expensive, because of labor costs and high rents. More and more cities allow transporters to use dedicated or existing infrastructures (reserved parking spaces, bus depots) to unload (Crainic, Ricciardi, & Storchi, 2004). No storage capacity is normally available at these locations, thus requiring a synchronization of the two levels.The contribution of this paper is a solution methodology for a 2E-VRP that integrates constraints that have not yet been addressed in the literature: time windows, synchronization, and multiple trips. Similar problems have been discussed in Perboli, Tadei, and Vigo (2011) under the name two-echelon vehicle routing problem with satellite synchronization (2E-VRP-SS) and modeled in Crainic et al. (2009) under the name two-echelon, synchronized, scheduled, multidepot, multiple-tour, heterogeneous VRPTW (2SS-MDMT-VRPTW). However, to the best of our knowledge, no implementation has been reported.Related work includes models for city logistics, multi-echelon vehicle routing problems with multiple routes and transfer or synchronization constraints. A general model for city logistics systems is presented by Crainic et al. (2009), while Mancini focuses on multi-echelon systems (Mancini, 2013). The 2E-VRP was introduced by Perboli and Tadei (2010), who proposed a mathematical model. Since then several algorithms have been developed: math-based heuristics (Perboli & Tadei, 2010; Perboli et al., 2011), clustering-based heuristics (Crainic, Mancini, Perboli, & Tadei, 2008), GRASP (Crainic, Mancini, Perboli, & Tadei, 2011; 2013; Zeng, Xu, Xu, & Shao, 2014), adaptive large neighborhood search (ALNS) (Hemmelmayr, Cordeau, & Crainic, 2012), and a large neighborhood search combined with a local search (Breunig, Schmid, Hartl, & Vidal, 2015). Exact methods include (Jepsen, Spoorendonk, & Ropke, 2013; Roberti, 2012; Santos, Cunha, & Mateus, 2012; Santos, Mateus, & da Cunha, 2014). Crainic, Perboli, Mancini, and Tadei (2010) study the impact of satellite location on the cost of a 2E-VRP solution compared to that of a VRP. Cuda, Guastaroba, and Speranza (2014) recently published a survey on two-echelon routing problems. A similar problem is the two-echelon location routing problem (2E-LRP) (Nguyen, Prins, & Prodhon, 2012). Our problem also integrates some multiple-trip aspects (Taillard, Laporte, & Gendreau, 1996) that have been solved with tabu search (Nguyen, Crainic, & Toulouse, 2013), ALNS (Azi, Gendreau, & Potvin, 2014) and iterated local search (Cattaruzza, Absi, Feillet, & Vigo, 2014). Synchronization of multiple trips supplied by a single bus line as been studied in Masson et al. (2015) in a city logistics context. We refer to (Drexl, 2012) for a detailed survey of synchronization in vehicle routing problems and to (Cattaruzza et al., 2015) for a recent survey of vehicle routing problems in city logistics.The 2E-MTVRP-SS can be considered as a particular Pickup and Delivery Problem with Transfers (PDPT) which has been recently studied in (Masson, Lehuédé, & Péton, 2013a; 2013b; Qu & Bard, 2012). The major differences are that in the 2E-MTVRP-SS transfers are mandatory, routes should be designed for two types of vehicles which do not share the same network, and that two vehicles must be simultaneously present at a satellite during a transfer. In this paper, we extend the previous approaches to integrate those differences and we exploit the specificities of the 2E-MTVRP-SS  to propose a better exploration of the search space, as well as a more compact graph representation of temporal constraints.The remainder of this paper is organized as follows. Section 2 presents a formulation of the problem, and Sections 3 and 4 are devoted to the solution method with a special focus on efficiently solving the timing subproblem. Computational results are presented in Section 5, followed by the conclusion in Section 6.In this section we define the problem and discuss the synchronization model at satellites.We introduce the two-echelon multiple-trip vehicle routing problem with satellite synchronization (2E-MTVRP-SS). We consider a city distribution center (CDC), a set of satellites Vs, a set of requests R, and two homogeneous fleets of vehicles K1 and K2 of capacity Q1 and Q2, based at o1 and o2. Each request r is located at the CDC at the beginning of the time horizon and must be delivered within the time window [er, lr] to a customer denoted by dr(the set of customers is denoted by Vc). The quantity associated with r is qr. No direct shipping from the CDC is allowed. Second-level vehicles can perform multiple trips, which may start at different satellites. As second-level vehicles are small we assume that they are empty every time they arrive at a satellite, a similar assumption is made in Crainic et al. (2009). Satellites have no storage capacity, thus requiring an exact synchronization between the vehicles of the two levels.The 2E-MTVRP-SS is defined on a directed graphG=(V,A),which reflects the two-level system. The first level is defined byG1=(V1,A1)withV1={o1}∪{CDC}∪VsandA1={(o1,CDC)}∪{(CDC,i)|i∈Vs}∪{(i,j)|i,j∈Vs}∪{(i,o1)|i∈Vs}. The second level is defined byG2=(V2,A2)withV2={o2}∪Vc∪VsandA2={(o2,i)|i∈Vs}∪{(i,j)|i∈Vs,j∈Vc}∪{(i,j)|i,j∈Vc}∪{(i,j)|i∈Vc,j∈Vs}∪{(i,o2)|i∈Vc}. With each arc(i,j)∈A=A1∪A2is associated a travel time ti,jand a travel cost ci,j. Each node i has a known service duration si. Solving the 2E-MTVRP-SS involves finding |K1| first-level routes and |K2| second-level routes, and a schedule for them, such that the capacity and time-related constraints are satisfied.We define a transfer as the operation during which a first-level vehicle transfers one or more requests to a second-level vehicle at a satellite. Given the lack of storage capacity at the satellites, the two vehicles must be at the satellite at the same time. Thus, the first and second levels must be synchronized. In details, for a transfer to happen, the two vehicles:•May need time to get ready for the transfer (for example if the first-level vehicle has a lift gate to open).Should spend some time transferring the items.Should get ready to leave the satellite (for example the second-level vehicle may have to sort items).sR[t1,t2]: Preparation time for the first-level vehicle.sT[t2,t3]: Time in common for the vehicles of both levels. For a transfer to occur, the two vehicles should spend at least this time together at the satellite.sL[t3,t4]: Sorting time for the second-level vehicle.Fig. 1 illustrates the temporal aspects of a transfer. In this example, ift2>t1+sR,the first-level vehicle must wait. Conversely, ift2<t1+sRthe second-level vehicle must wait for the first-level vehicle. If the first-level vehicle transfers requests to several second-level vehicles, it cannot leave beforemaxi∈K2ti+sT. In this paper, we assume that sR, sT, and sLcan reasonably be considered independent of the transferred quantity, without inducing a significant imprecision. This simplifying hypothesis allow to integrate those times into the travel times from and to the satellites. Thus, we later consider that all the transfer-related periods (sR, sT, sL) are equal to zero. If a second-level vehicle returns several times to pick up requests from the same first-level vehicle at the same satellite, each visit corresponds to a different transfer.We present a mixed integer linear programming formulation for the 2E-MTVRP-SS. In the model, to represent the transfer of one request at one satellite, for each request r and satellite s, we create a node vs, rwhose associated demand is−qr,and we denote byVs˜={vi,r|vi∈Vs,r∈R}all the satellites. For each vehicle k, we create a start node okand an end nodeok′(O˜=∪kok,O′˜=∪kok′).The mathematical formulation is defined on a graphGmath=(Vmath,Amath). The first level isG1math=(V1math,A1math)withV1math=O1˜∪O1′˜∪Vs˜andA1math={(o,i)|o∈O1˜,i∈Vs˜}∪{(i,j)|i,j∈Vs˜}∪{(i,o′)|i∈Vs˜,o′∈O1′˜}∪O1×O1˜. The second level isG2math=(V2math,A2math)withV2math=O2˜∪O2′˜∪Vc∪Vs˜andA2math={(o,i)|o∈O2˜,i∈Vs˜}∪{(i,j)|i∈Vs˜,j∈Vc}∪{(i,j)|i,j∈Vc}∪{(i,j)|i∈Vc,j∈Vs˜}∪{(i,o′)|i∈Vc,o′∈O2′˜}∪O2×O2˜. We introduce the following variables:xi,jk={1ifvehiclektravelsfromnodeitonodej0otherwisehi=servicetimeatnodei×(pointintimewhenserviceatnodeistarts)ui=loadofthesecond-levelvehicleafterservingi.We introduce two constants: Mhcorresponds to the end of the planning horizon, and Muis the sum of all the ordered quantities.We use a classical approach in vehicle routing problems with time windows, which consists in lexicographically minimizing the fleet-size and the routing cost. The first objective is the number of first-level vehicles, the second objective is the number of second-level vehicles and the third objective is the sum of arc costs.(1)lex−min(∑k∈K1∑j∈Vs˜xok,j,∑k∈K2∑j∈Vs˜xok,j,∑k∈K1∑(i,j)∈A1mathci,j×xi,jk+∑k∈K2∑(i,j)∈A2mathci,j×xi,jk)(2)s.t.∑(ok,j)∈Aemathxok,jk=∑(j,ok′)∈Aemathxj,ok′k=1∀e∈{1,2},∀k∈Ke(3)∑(i,j)∈Aemathxi,jk=∑(j,i)∈Aemathxj,ik∀e∈{1,2},∀k∈Ke,∀i∈Vemath∖(Oe˜∪Oe′˜)(4)∑k∈K2∑(j,dr)∈A2mathxj,drk=1∀r∈R(5)∑k∈Ke∑j∈Vs,r∑(i,j)∈Aemathxi,jk=1∀e∈{1,2},∀r∈R(6)∑k∈K1∑i∈V1mathxi,vs,rk=∑k∈K2∑i∈V2mathxi,vs,rk∀v∈Vs,∀r∈R(7)∑v∈Vs,r∑(i,v)∈A2mathxi,vk=∑(j,dr)∈A2mathxj,drk∀r∈R,∀k∈K2(8)hj≥hi+si+ti,j−Mh×(1−∑k∈Kexi,jk)∀e∈{1,2},∀(i,j)∈Aemath(9)hok≥0∀k∈K(10)ei≤hi≤li∀i∈Vc(11)hok′≤Mh∀k∈K(12)∑r∈Rqr×∑j∈Vs,r∑(i,j)∈A1mathxi,jk≤Q1∀k∈K1(13)uj≥ui−qi−Mu×(1−∑k∈K2xi,jk)∀(i,j)∈A2math(14)uj≤Mu×(1−∑k∈K2∑i∈V2math∖Vs˜xi,jk)∀j∈Vs˜(15)0≤ui≤Q2∀i∈V2math(16)xi,jk∈{0,1}∀k∈K,(i,j)∈AmathThe objective function (1) lexicographically minimizes the fleet-size and the travel costs. Constraints (2) state that each vehicle must start and end its route at its base. Constraints (3) are flow conservation constraints. Constraints (4) ensure that each request is delivered. Constraints (5) ensure for each request that only one transfer node is used, and (6) ensure that it is visited by both a first and a second-level vehicle. Constraints (7) ensure for each request that the second-level vehicle that visits the transfer node is the one that delivers the request. Constraints (8) compute the travel time between two nodes if they are visited consecutively by the same vehicle, and constraints (9) handle the special case of bases for which there is no predecessor. Constraints (10) ensure that each request is delivered within its time window. Constraints (11) ensure that each vehicle has completed its route within the time horizon. Constraints (12) (resp. (15)) ensure for each first-level (second-level) vehicle that the load does not exceed the vehicle capacity. Constraints (13) ensure for each second-level vehicle that the load after visiting a node is equal to the load before plus (or minus) the quantity that has been loaded (unloaded). Constraints (14) ensure that each second-level vehicle is empty when arriving at a satellite.In this section we describe the destruction and repair methods used in our ALNS for the 2E-MTVRP-SS. ALNS was proposed by Ropke and Pisinger (2006) as an extension of the large neighborhood search introduced by Shaw (1998). The general principle of ALNS is described in Algorithm 1: it iteratively destroys and repairs the current solution using heuristics, which are selected based on their past successes. Destroying here means removing a number p of requests from the current solution (p is bounded by some parameters), while repairing means inserting unplanned requests in the solution. Note that a solution s may be incomplete, if a set of requestsLsremained unplanned. The size of this set is then penalized in the objective function. The solution obtained after the destroy and repair operations is accepted if it satisfies an acceptance criterion. As in Ropke and Pisinger (2006), we use a roulette-wheel mechanism as adaptive layer for the selection of destruction and repair methods, and a simulated annealing as acceptance criterion.Since its introduction, ALNS has been used to solve the 2E-VRP (Hemmelmayr et al., 2012) as well as many complex vehicle routing problems (Azi et al., 2014; Bortfeldt, Hahn, Männel, & Mönch, 2015; Kovacs, Parragh, Doerner, & Hartl, 2012; Masson et al., 2013a; 2014; Pisinger & Ropke, 2007).We refer to Ropke and Pisinger (2006) for a more detailed explanation of ALNS. In the following, we focus on the specific components of our method, namely the construction of the initial solution, and the destroy and repair methods.We design a two-phase constructive algorithm to obtain the initial solution. First, we design the second level routes using a best insertion algorithm for a multiple-trip multiple-depot problem. In this heuristic the possible insertion of a customer are all the insertions in existing trips and all insertions by creation of a new trip. Then we create the first-level routes to supply the satellites according to the second-level routing plan previously created.When partially destroying a solution we select a method and a number p of requests to remove. Unless stated otherwise, this method is reused until p is reached. Following (Azi et al., 2014), we use three levels of destruction methods: workday, route, and customer.The following operators are used for first and second-level vehicles.Random Vehicle Removal: we randomly remove a vehicle.Least Used Vehicle Removal: we remove the vehicle with the smallest load. For the second level, the total load of a vehicle is defined as the sum of the load of each trip.Random trip removal: we randomly remove a trip from the solution.First-level stop removal: we randomly remove a first-level stop from the solution. The trips that get their requests from this stop are removed.Trip related removal: this method is similar to that of (Azi et al., 2014). Trips are removed based on a proximity measure: we start by randomly selecting a trip and removing it. We then find the trip that contains the nearest customer to any customer in the trip just removed, and we remove that trip.Synchronization-based trip removal: intuitively, a good synchronization occurs when the vehicles involved arrive at approximately the same time. If a second-level vehicle arrives a long time before (or after) the first-level vehicle there will be a long waiting time; this should be avoided. This method removes the trip for which the time between the arrival of the second-level vehicle and the arrival of the first-level vehicle is maximum.Random customer removal: we randomly remove a customer.Worst removal: this operator is the same as in Ropke and Pisinger (2006). For each request we compute the difference in cost of the solution with and without this request. We then sort the requests from the largest to the smallest difference. And we remove the worst (largest difference) request. Some randomization is introduced to avoid repeatedly removing the same requests.Related removal heuristics: these methods aim to remove related requests. Let the relatedness of requests i and j be R(i, j). We use two distinct relatedness measures: distance and time. The distance measure is the distance between the delivery points of i and j. The time measure is the sum of the absolute gap between their start of service and the absolute gap between their latest delivery times. In both cases a lower R(i, j) value indicates a great degree of relatedness.We ran preliminary tests to compare these two measures with that of (Shaw, 1998), which groups time and distance into a single measure. The methods gives similar results, but we chose time and distance because they do not require parameter tuning.History-based removal: This is inspired by Masson et al. (2013a) and removes requests that seem poorly placed in the current solution with regard to the best-known solutions. For requests r and r′, letξr,r′be the number of solutions among the 50 best-known in which r′ is a direct successor of r. For each request, letδ−(r)(resp.δ+(r)be its direct predecessor (resp. successor). For request r and satellite s, let χs,rbe the number of solutions in which r is delivered via a transfer at s. For each request r, delivered in the current solution via a transfer at s, we define a score ϕ as follows:ϕr=ξδ−(r),r+ξr,δ+(r)+χs,r.Then we remove the p  requests with the lowest scores.In this section we describe the methods used to repair a solution. We first describe the three different ways to insert a given customer into a given second-level route that we use, and then we describe the repair methods.In the VRP, the insertion of a customer c into a partially built solution is fully described by giving the route and the position for the insertion. Thus, all possible insertions can be described by the unique set{(k,i):k∈Vehicles,0≤i≤|route(k)|+1}. Given the multiple-trip and two-echelon characteristics of the 2E-MTVRP-SS, we consider three distinct greedy ways of inserting a customer into a solution. We call them insertion operators and describe them below.Insertion into an existing trip: The customer is inserted into an existing trip.Insertion by creation of a new trip: A new trip is created for the customer. This new trip can be connected either to an existing stop or to a newly created stop of a first-level vehicle.Insertion by trip split: Before inserting c into trip t, we split t into two trips, t1 and t2. Trip t1 is still connected to the same first-level stop as t, but t2 is connected either to an existing stop or to a newly created stop of a first-level vehicle. This vehicle can be different from that involved in t1. Then c is inserted into one of the two resulting trips. Fig. 2 illustrates the use of a trip split operator.The insertion of a request corresponds to two decisions: one at the first level and one at the second level. Thus, the neighborhoods generated by the insertion operators are huge. For example, to test every possible insertion of a request r with the trip split operator, we have to test for each pair (insertion position, split position) in each trip of second-level vehicles, each existing stop of first-level vehicles, and each creation of a stop (i.e., each satellite at each position). To ensure a reasonable runtime, we have created restricted neighborhoods.For the trip split we have introduced two variants: existing stops and customer first. In the existing stops variant, we only try to connect t2 with an existing stop of a first-level vehicle. In the customer first variant, we first select the insertion position that leads to the smallest increase in the cost of the global solution. Then we select the best possible way to split t into feasible trips t1 and t2, trying both existing and newly created first-level stops.When we create a new first-level stop to be connected to a second-level trip, it is likely that the best choice for the satellite will be close to the second vehicle. At the beginning of our algorithm we sort the satellites in order of distance for every pair of customers. When creating a new trip connected to a new first-level stop, we consider only the s satellites closest to the pair (predecessor of the trip, first customer in the trip). This is used for the trip creation and the variants of the trip split operator.As shown in Section 5.3.3, using these restricted neighborhoods makes our algorithm about 2.3 times faster while maintaining the quality of the solution.All the unplanned requests are stored in a request bank.Best insertion: From the requests in the request bank, we insert the one with the cheapest insertion cost considering all possible insertion operators.K-Regret: For each request in the request bank, letδrirepresent the gap between the insertion of r at its best position in its best trip and the insertion at its best position in its ithbest trip. We select the request where∑i=2kδriis maximum. In other words, we maximize the sum of the differences of the cost of inserting request r into its best trip and its ithbest trip. To control the computational time, we use small values of k.Inserting a request r by moving a first-level vehicle to a new satellite generates a large increase in the routing cost compared to transferring the request at an existing transfer point. Thus, it is rare for repair methods to choose such insertions. However, subsequent insertions may benefit from a new transfer point, because the second-level vehicle may have a smaller distance to travel. Therefore, when an insertion operator creates a new stop, we consider the following biased cost:(17)Biasedcost=second-levelinsertioncost+first-levelinsertioncost×max(α,loadinsecond-leveltripsecond-levelvehiclecapacity).In this biased cost, we acknowledge that if there is some room in the second-level trip, then it is likely that we will later use it for a customer. For our instances, after some tuning, we have usedα=0.7for the trip creation operator andα=0for the trip split operator and its variants.For each actual insertion, the repair methods evaluate thousands of potential insertions in terms of profitability and feasibility. In this section we describe an efficient way to test if an insertion is feasible with respect to the temporal constraints. The method is an adaptation of the feasibility algorithm designed by Masson, Lehuédé, and Péton (2013b) for the PDPT, which was based on forward-time slacks (FTSs) (Savelsbergh, 1985). We introduce the idea behind FTSs in Section 4.1, give a way to model time constraints in Section 4.2, and describe the feasibility tests in Section 4.3. Throughout this section, we use the notation of Table 1.Inserting a request into a feasible route with an as early as possible schedule may postpone deliveries later in this route, potentially violating time windows. For a given insertion, we can check for this kind of violation by rescheduling the operations that follow the insertion. This test has a linear complexity in the size of the route. For the same test, (Savelsbergh, 1985) introduced an incremental constant-time algorithm. It is based on the computation of FTS variables that have to be maintained after each route modification. The FTSs can be calculated as follows: let u and v be two nodes in the same route, with v being delivered after u. For all vertices i in the route, let hibe the current service time at i, withe waiting time before the service, and lithe latest time for service at i. The total waiting time on the path (u,…,v) is(18)TWTψu,v=∑i∈ψδ+(u),vwi.The FTS at node u is(19)Fu=mini∈{u}∪Γ+(u){TWTψu,i+li−hi}An intuitive explanation of Eq. (19) is the following: for every successor i of u, the path (u,…,i) can be decomposed into a working time and an idle/waiting time. If u is postponed, first the idle time will be reduced and then the service at node v will be postponed. The maximum postponement of v such that the time window at i is not violated is the total waiting time between u and i plus the difference between the current start time at i and the end of its time window. This is true for every indirect successor of v, and thus for the minimum over all successors.A direct corollary of this result is that if the service at u is postponed by a value δ, then the new service timehv˜at v is(20)hv˜=hv+max(0,δ−TWTu,v).In contrast to the VRP, in problems with synchronization, a change in the schedule of one route may affect other routes, potentially making them infeasible with respect to time. For example, in the 2E-MTVRP-SS, if we insert a delivery into the trip of a second-level vehicle A, it may arrive later at its next transfer, thus delaying the first level-vehicle with which it is synchronized. The first-level vehicle will propagate this delay to second-level vehicles at its next transfer, and so on, eventually causing a time-window violation for a second-level vehicle B whose link with A was not obvious at first sight. This is known as the interdependence problem (Drexl, 2012), and we model it through a precedence graph.Given the routes in a solution of the 2E-MTVRP-SS, we can represent the time constraints as a directed acyclic graph, Gt. We refer to this as a precedence graph and build it as follows: for every operation except transfers, we create a node and add an arc to each of its direct successors in the given route. Each arc (u, v) has a weight that corresponds to tu, v. For a transfer we create three nodes: a transfer entrance node Te, a transfer exit node Txfor the first-level vehicle, and a pick-up node β for the second-level vehicle. We create three arcs (Te, Tx), (Te, β), (β, Tx) with weight 0. If the first-level vehicle transfers its load to several second-level vehicles, we create only one pair (Te, Tx). We assume that transfers to second-level vehicles can occur simultaneously. Fig. 3 illustrates this transformation.Gtcorresponds to a PERT chart. As mentioned in Cormen, Leiserson, Ronald, and Stein (2010) (p. 657), we can schedule tasks in such a diagram using a shortest-path algorithm, with linear complexity in the number of vertices. Furthermore, in an as-early-as-possible schedule, only the downstream operations have to be rescheduled after a change, thus reducing the number of modifications.With Gtwe can check if an insertion is feasible with respect to time by rescheduling the downstream operations. However, this is more time-consuming than in the VRP, because it is linear in the number of operations in the solution (versus the number of operations in a route in the VRP). Masson et al. (2013b) were faced with a similar problem for the PDPT. They introduced a directed acyclic graph to model their precedence constraints and extended the FTSs to obtain a constant-time feasibility check for the time constraints. We now present their main results and show how they can be applied to the 2E-MTVRP-SS.First, Masson et al. introduced the notion of slack time. This is a generalization of the total waiting time between two nodes:STu,v=minw∈Ωu,vTWTw.The FTS at node u becomes(21)Fu=mini∈{u}∪Γ+(u){STu,i+li−hi}.The intuitive explanation given for Eq. (19) also holds for Eq. (21), with slack times accounting for the fact that there may be several time paths between two vertices. Masson et al. proved the above result in their Proposition 2. Their proof does not rely on the particular structure of their precedence graph for the PDPT, so it is valid for any directed acyclic graph. In particular, this result (and the start-of-service result below) is valid for our precedence graph.Similarly to the VRP, if the start of service of node u is postponed by δ, the new service timeh˜of any successor v is(22)hv˜=hv+max(0,δ−STu,v).Note that in contrast to Masson et al., we recompute the FTSs using the Floyd–Warshall algorithm ((Cormen et al., 2010), p. 693), which is faster in our case than the suggested shortest path method.When evaluating an insertion of an unplanned request into a feasible solution, we need to ensure that the solution will remain feasible with respect to time after the insertion. With the insertion operators of Section 3.3.1, infeasibility can occur in two ways: the creation of a cycle of precedence constraints or the violation of a time window.Some insertion operators create new transfers, which may lead to infeasible precedence relations (see Fig. 4 for an illustration). We extend the method of (Masson et al., 2013b) for detecting cycles in constant time.Proposition 1Synchronizing a first-level stop T and a second-level trip (β→d1…dn) creates a cycle in the precedence graph if and only ifTe∈Γ+(β)orβ∈Γ+(Tx).⇒ With the synchronization, just two arcs are created (Te→ β) and (β → Tx). One of them is responsible for the cycle. If it is (Te→ β), then previouslyTe∈Γ+(β). If it is (β → Tx), then previouslyβ∈Γ+(Tx).⇐ IfTe∈Γ+(β),then sinceβ∈δ+(Te)by definition, a cycle is created. Ifβ∈Γ+(Tx),then sinceTx∈Γ+(β)by definition, a cycle is created.□Synchronizing a new first-level stop inserted after node i and a new second-level trip inserted after node j creates a cycle in Gt if and only ifi∈Γ+(j)orj∈Γ+(i).Provided we maintain a successor matrix, which can easily be computed together with the slack times, we can check in constant time if an insertion creates a cycle in Gt.It is easy to use FTSs to check the feasibility with respect to time windows of an insertion into an existing trip or an insertion by creation of a new trip. For an insertion into an existing trip, we check that the shift of the operations of the second-level vehicle right after the insertion is smaller than its FTSs. For an insertion by creation of a new trip, we check that the shift of the operations of the second-level vehicle right after the new delivery and the shift of the operations of the first-level vehicle right after the new transfer exit are smaller than their respective FTSs. The case of an insertion by trip split is more complex; it is illustrated in Fig. 5and the details are given in Algorithm 2. For all the insertion operators, with FTSs we get a constant-time feasibility check.We compare the runtime of the FTS extension and that of a check based on an incremental PERT: on average our algorithm is approximately 12 times faster with the former (see Section 5.3.2).In this section, we first describe the adaptation of some well-known VRPTW instances to the 2E-MTVRP-SS. Parameters configuration is discussed in Section 5.2. In Section 5.3 we show that our custom heuristics are efficient, and we present our results.Since the 2E-MTVRP-SS is a new problem, there are no instances for it. We adapt the well-known Solomon’s instances for the VRPTW (Solomon, 1987). We use a subset of these instances to tune our algorithm: the first two of every type, for a total of 12 tuning instances.The customer requests are unchanged. The depot (node 0) is the base of second-level vehicles; the first-level vehicles are based at the CDC.We adopt the following X/Y/M/N notation to describe the position of the CDC and the satellites. X and Y give the position of the CDC expressed as a percentage of the size of the map. M and N describe the number of rows (resp. columns) of a grid. We locate a satellite at each exterior intersection of the grid. Fig. 6illustrates a−50 / 50 / 3 / 3 configuration.According to (Crainic et al., 2010), the maximum benefit of the 2E-VRP compared to the VRP occurs when the CDC is external (outside the customer’s zone), thus saving travel from the depot to the customers and back, and when the satellites are between the CDC and the customers. The appropriate satellite number is between 7 and 10 for instances with between 100 and 200 customers. In all the benchmarks we use a 50 / 150 / 3 / 3 configuration.Because the CDC is situated farther from the customers than the depot, some orders may be impossible to deliver. We therefore add an offset δ to each time window, withδ=⌈tCDC,Depot⌉. Hence, a time window [ei, li] in a Solomon instance becomes[ei+δ,li+δ].According to Savelsbergh, the instances labeled with a 1 (R1, C1, RC1) have short scheduling horizons, whereas instances labeled with a 2 have long scheduling horizons. Thus, the former are more time-constrained, and the latter are more capacity-constrained. To preserve this idea we use the following ratios for first-level vehicles capacity/second-level vehicles capacity: 4/0.5 ratio for instances 1; 2/0.25 ratio for instances 2.As the number of vehicles is not fixed, our algorithm is used twice. In a first phase we try to minimize the number of vehicles used by minimizing first the number of first level vehicles and then the number of second level vehicles. In a second phase, given the fleet obtained in the first phase, we minimize the routing cost.In this section we discuss the parameters used in our algorithm.We use a sequential optimization scheme to reduce the number of vehicles. We start by reducing the number of first-level vehicles and then we reduce the number of second-level vehicles. When we find a feasible solution withn+1vehicles, we start looking for a feasible solution with n vehicles by calling the least-used-vehicle removal heuristic.LB1=⌈∑r∈Rdr/q1⌉is a lower bound on the number of first-level vehicles. If we reach it, we switch to the reduction of the number of second-level vehicles. Overall, we perform a maximum of 25,000 iterations with no more than 12,500 dedicated to the reduction of the first-level fleet. As (Ropke & Pisinger, 2006), we stop the search if 5 or more requests are unplanned and no improvement in the number of unplanned requests has been found in the last 2000 iterations.In the cost optimization phase we use the following parameters (w, c, σ1, σ2, σ3, r, ρmin, ρmax) = (0.05 percent, 0.99975 percent, 33 percent, 9 percent, 13 percent, 0.1 percent, 10 percent, 40 percent). The notation is that of (Ropke & Pisinger, 2006). We perform 25,000 iterations, since this gives a compromise between runtime and solution quality.For both the fleet optimization phase and the cost reduction phase, we use the following heuristics.Destruction heuristics: random vehicle removal, least-used-vehicle removal, random trip removal, first-level stop removal, trip-related removal, synchronization-based trip removal, random customer removal, worst removal, distance-related removal, time-related removal, history-based removal.Repair heuristics: best insertion, 3-regret, 4-regret, 5-regret. Each was used in three variants: without split, existing stops, and customer first (see Section 3.3.2).

@&#CONCLUSIONS@&#
