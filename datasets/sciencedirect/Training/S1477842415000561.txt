@&#MAIN-TITLE@&#
Practical domain-specific debuggers using the Moldable Debugger framework

@&#HIGHLIGHTS@&#
We identify and discuss requirements for developing domain-specific debuggers.We present the Moldable Debugger, a model for developing domain-specific debuggers.We give real-world examples showing the usage of the Moldable Debugger model.We discuss a prototype implementation of the Moldable Debugger model.We discuss three different approaches for implementing debugging operations.

@&#KEYPHRASES@&#
Debugging,Customization,Domain-specific tools,User interfaces,Programming environments,Smalltalk,

@&#ABSTRACT@&#
Understanding the run-time behavior of software systems can be a challenging activity. Debuggers are an essential category of tools used for this purpose as they give developers direct access to the running systems. Nevertheless, traditional debuggers rely on generic mechanisms to introspect and interact with the running systems, while developers reason about and formulate domain-specific questions using concepts and abstractions from their application domains. This mismatch creates an abstraction gap between the debugging needs and the debugging support leading to an inefficient and error-prone debugging effort, as developers need to recover concrete domain concepts using generic mechanisms. To reduce this gap, and increase the efficiency of the debugging process, we propose a framework for developing domain-specific debuggers, called the Moldable Debugger, that enables debugging at the level of the application domain. The Moldable Debuggeris adapted to a domain by creating and combining domain-specific debugging operations with domain-specific debugging views, and adapts itself to a domain by selecting, at run time, appropriate debugging operations and views. To ensure the proposed model has practical applicability (i.e., can be used in practice to build real debuggers), we discuss, from both a performance and usability point of view, three implementation strategies. We further motivate the need for domain-specific debugging, identify a set of key requirements and show how our approach improves debugging by adapting the debugger to several domains.

@&#INTRODUCTION@&#
Debugging is an integral activity of the software development process, consisting in localizing, understanding, and fixing software bugs, with the goal of making software systems behave as expected. Nevertheless, despite its importance, debugging is a laborious, costly and time-consuming activity. Together with testing, debugging can take a significant part of the effort required to ensure the correct functioning of a software system [1]. Using inadequate infrastructures for performing these activities can further increase this effort [2].Given the pervasiveness of debugging during software maintenance and evolution, numerous debugging techniques have been proposed (e.g.,remote debugging, omniscient debugging [3], post-mortem debugging [4,5], delta debugging [6] – to name a few), each with its own constraints and benefits. These techniques rely on a wide set of tools to locate, extract and analyze data about the run-time behavior of software systems.Among the multitude of debugging tools, debuggers are an essential category. If loggers [7] or profilers [8] record run-time data presented to developers post-mortem, debuggers enable developers to directly observe the run-time behavior of software and elicit run-time information [9,10]. In test-driven development the debugger is used as a development tool given that it provides direct access to the running system [11]. This makes the debugger a crucial tool in any programming environment. Nevertheless, there is an abstraction gap between the way in which developers reason about object-oriented applications, and the way in which they debug them.On the one hand, object-oriented applications use objects to capture and express a model of the application domain. Developers reason about and formulate questions using concepts and abstractions from that domain model. This fosters program comprehension as domain concepts play an important role in software development [12,13].On the other hand, classical debuggers focusing on generic stack-based operations, line breakpoints, and generic user interfaces do not allow developers to rely on domain concepts when debugging object-oriented applications. Furthermore, classical debuggers are less useful when the root of the cause of a bug is far away from its manifestation [14]. Raising the level of abstraction of a debugger by offering object-oriented debugging idioms [15] solves only part of the problem, as these debuggers cannot capture domain concepts constructed on top of object-oriented programming idioms. Other approaches raise the level of abstraction in different ways: back-in-time debugging, for example, allows one to inspect previous program states and step backwards in the control flow [16].Not offering a one-to-one mapping between developer questions and debugging support forces developers to refine their high-level questions into low-level ones and mentally piece together information from various sources. For example, when developing a parser, one common action is to step through the execution until parsing reaches a certain position in the input stream. However, as it has no knowledge of parsing and stream manipulation, a generic debugger requires developers to manipulate low-level concepts like message sends or variable accesses. This abstraction gap leads to an ineffective and error-prone effort [17].Creating a debugger that works at the level of abstraction of a given object-oriented application can eliminate the abstraction gap. This can be achieved by:•automatically generating a debugger based on a meta-model of the application;providing developers with a toolset for constructing debuggers for their application.Automatically generating a debugger requires a specification of the meta-model. The challenge for this approach is to have a meta-model at the right level of detail. Too many or too few details can lead to debuggers with the wrong sets of features. Enabling developers to construct debuggers can lead to debuggers that have only the necessary features. The challenge here is for the toolset to make it possible to create expressive and performant debuggers with low effort.The first approach has been applied successfully for language workbenches where the domain model of an application is expressed using external domain-specific languages that have a grammar definition [18–20], as well as in the case of domain-specific modeling languages that have an explicit specification of the meta-model [21]. Nevertheless, object-oriented programming already has a meta-model in terms of objects and their interactions: object-oriented applications provide an instantiation of the meta-model that expresses domain abstractions through concrete objects and object interactions [22]. To improve development and evolution, these object models take advantage of internal DSLs [23] (e.g.,APIs) instead of encoding domain concepts through external DSLs that require a grammar specification.One can provide an additional specification of an object model from which a debugger can be generated. Nevertheless, non-trivial object-oriented applications contain rich object models [24], which can introduce significant overhead in creating and maintaining an extra specification. One can also argue that important concepts from object-oriented applications should be encoded using external DSLs that have an explicit grammar (i.e.,meta-model). This, however, does not acknowledge that object-oriented programming already provides the meta-model. In this paper we investigate an alternative solution: we propose a framework for enabling developers to create domain-specific debuggers for their object-oriented applications directly on the existing object model.When looking at a debugger, there exist two main approaches to address, at the application level, the gap between the debugging needs and debugging support:•enable developers to create domain-specific debugging operations for stepping through the execution, setting breakpoints, checking invariants [25–27] and querying stack-related information [28–31];provide debuggers with domain-specific user interfaces that do not necessarily have a predefined content or a fixed layout [32].Each of these directions addresses individual debugging problems (i.e.,interacting with the runtime at the right level of abstraction and displaying data relevant for the application domain), however until now there does not exist one comprehensive approach to tackle the overall debugging puzzle. We propose an approach that incorporates both these directions in one coherent model. We start from the realization that the most basic feature of a debugger model is to enable the customization of all aspects, and we design a debugging model around this principle. We call our approach the Moldable Debugger.The Moldable Debuggerdecomposes a domain-specific debugger into a domain-specific extension and an activation predicate. The domain-specific extension customizes the user interface and the operations of the debugger, while the activation predicate captures the state of the running program in which that domain-specific extension is applicable. In a nutshell, the Moldable Debugger model allows developers to mold the functionality of the debugger to their own domains by creating domain-specific extensions. Then, at run time, the Moldable Debuggeradapts to the current domain by using activation predicates to select appropriate extensions.A domain-specific extension consists of (i) a set of domain-specific debugging operations and (ii) a domain-specific debugging view, both built on top of (iii) a debugging session. The debugging session abstracts the low-level details of a domain. Domain-specific operations reify debugging operations as objects that control the execution of a program by creating and combining debugging events. We model debugging events as objects that encapsulate a predicate over the state of the running program (e.g.,method call, attribute mutation) [33]. A domain-specific debugging view consists of a set of graphical widgets that offer debugging information. Each widget locates and loads, at run-time, relevant domain-specific operations using an annotation-based approach.To validate our model and show that it has practical applicability, we implemented it in Pharo [34], a modern Smalltalk environment and used it to create multiple real-world debuggers. The Moldable Debugger implementation is written in less than 2000 lines of code. We have instantiated it for several distinct domains and each time the implementation required between 200 and 600 lines of code. We consider that its small size makes it easy to understand, and makes the adaptation of the debugger to specific domains an affordable activity. We further explore three approaches for controlling the execution of the debugged program, approaches applicable depending on the particular aspects of the target domain.This paper extends our previous work [35] as follows: (i) we present a more in-depth description of the Moldable Debuggermodel, (ii) we introduce two new examples of domain-specific debuggers created using the Moldable Debuggermodel, (iii) we provide a thorough discussion of related work, and (iv) we discuss three approaches for implementing the Moldable Debuggermodel.The overall contributions of this paper are as follows:•Identifying and discussing requirements that an infrastructure for developing domain-specific debuggers should support.Discussing the Moldable Debugger, a model for creating and working with domain-specific debuggers that integrates domain-specific debugging operations with domain-specific user interfaces.Examples illustrating the advantages of the Moldable Debuggermodel over generic debuggers.A prototype implementation of the Moldable Debuggermodel together with a discussion of three different approaches for implementing domain-specific debugging operations.

@&#CONCLUSIONS@&#
Developers encounter domain-specific questions. Traditional debuggers relying on generic mechanisms, while universally applicable, are less suitable to handle domain-specific questions. The Moldable Debuggeraddresses this contradiction by allowing developers to create with little effort domain-specific debuggers that enable custom debugging actions through custom user interfaces. As a validation, we implemented the Moldable Debuggermodel and created six different debuggers in fewer than 600 lines of code each. Through these examples we show that the Moldable Debuggercan reduce the abstraction gap between the debugging needs and debugging support leading to a more efficient and less error-prone debugging effort.We further explored three approaches for implementing debugging actions. Performance can be impacted, but only when in the special debugging mode. For the regular debugging mode there is no penalty. Thus, our solution offers an opt-in possibility with no cost.Given the large costs associated with debugging activities, improving the workflow and reducing the cognitive load of debugging can have a significant practical impact. With our approach developers can create their own debuggers to address recurring problems. These custom debuggers come with a price as they have to be constructed by application or framework developers rather than by tool providers. Nevertheless, this can make considerable economical sense when working on a long-lived system. Furthermore, library developers can ship library-specific debuggers together with their product. This can have a practical impact due to the reuse of the library in many applications.