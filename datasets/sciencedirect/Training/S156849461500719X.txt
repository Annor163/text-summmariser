@&#MAIN-TITLE@&#
Two meta-heuristic algorithms for flexible flow shop scheduling problem with robotic transportation and release time

@&#HIGHLIGHTS@&#
Flexible flow shop scheduling problem with robotic transportation is presented.Minimization of maximum completion time of all parts is considered as objective function.A mixed integer linear programming model is proposed for the problem.Two meta-heuristic algorithm, GA and ACO, is presented.

@&#KEYPHRASES@&#
Flexible flow shop,Unrelated parallel machine,Robotic transportation,Eligible machine,Ant Colony Optimization,Genetic algorithm,

@&#ABSTRACT@&#
In this research, flexible flow shop scheduling with unrelated parallel machines at each stage are considered. The number of stages and machines vary at each stage and each machine can process specific operations. In other words, machines have eligibility and parts have different release times. In addition, the blocking restriction is considered for the problem. Parts should pass each stage and process on only one machine at each stage. In the proposed problem, transportation of parts, loading and unloading parts are done by robots and the objective function is finding an optimal sequence of processing parts and robots movements to minimize the makespan and finding the closest number to the optimal number of robots. The main contribution of this study is to present the mixed integer linear programming model for the problem which considers release times for parts in scheduling area, loading and unloading times of parts which transferred by robots. New methodologies are investigated for solving the proposed model. Ant Colony Optimization (ACO) with double pheromone and genetic algorithm (GA) are proposed. Finally, two meta-heuristic algorithms are compared to each other, computational results show that the GA performs better than ACO and the near optimal numbers of robots are determined.

@&#INTRODUCTION@&#
Due to the development of science and industry, the manufacturing sector tries to use automatic devices in processing, transportation, inspection and so on; they try to minimize production cost and makespan. Therefore, they need to design a plan to meet these goals. In many manufacture and assembly parts, many operations perform on parts, and machines placed in series. In many of these cases, these operations have to be done on all parts in the same processing sequence. Therefore, all parts should have the same path for processing. These sequences of machines are referred as flow shop (FS). Machines can be placed in parallel at each stage to facilitate the processing of parts and reduction of processing time; and parts have to be processed at each stage only on one of the machines, and these sequences of machines are referred as flexible flow shop (FFS). In fact, all machines may have not the ability to perform all activities. Therefore, unrelated parallel machine can be used at each stage. Unrelated machines may perform the same operations, but they generally require different processing times for the same operations. Inspection of resources can be performed by one or more robots in some automated manufacturing system. Cells involving robots for inspecting resources are termed as robotic cells (RCs).In this study, flexible flow shop is considered with unrelated parallel machines. Unloading, transferring and loading parts are performed by robots; and the objective of the problem is finding an optimal sequence of processing parts and robots movement for minimizing the makespan and finding the closest number to the optimal number of robots.There are several researches that studied multiple part-type production cells with transportation constraints. Gupta [1] proved that the two stage hybrid flow shop scheduling problem is NP-hard in a strong sense even if there is only one machine on first stage and two machines on the second stage. Kalczynski and Kamburowski [2] presented that a two-machine flow shop with release times and objective of minimizing the makespan is strongly NP-hard. They also presented a new heuristic with short worst-case running time. Engin et al. [3] studied the hybrid flow shop scheduling with multiprocessor task (HFSMT) problem for minimizing the makespan. They showed these kinds of problems are NP-hard and developed an efficient genetic algorithm to solve the problem. Marichelvam et al. [4] studied the multistage hybrid flow shop (HFS) scheduling problem and proved these kinds of problems are NP-hard. They developed cuckoo search (CS) meta-heuristic algorithm to minimize the makespan. They used the data from a leading furniture manufacturing company. Pan and Huang [5] considered no-wait job shop scheduling problems and the objective is minimizing the total completion time. They showed the problem is NP-hard and used a hybrid genetic algorithm to solve the problem. Knust [6] solved a special case of hybrid flow shop problem with automatic transportation, and showed that different samples with single transportation source are NP-hard. Soukhal et al. [7] investigated two machines flow shop scheduling problems with transportation. They proved that the mentioned problem with additional constraints, such as blocking, is also strongly NP-hard.Cheng et al. [8] considered the three-machine permutation flow shop scheduling problem with release times where the objective is to minimize makespan. The branch and bound algorithm proposed and combined an adaptive branching rule with a fuzzy search strategy to narrow the search tree and lead the search to an optimal solution as early as possible. Kashyrskikh et al. [9] considered the two-machine flow shop sequencing problem with arbitrary release times of jobs and the minimum makespan criterion. They showed this problem is NP-hard and studied the performance and running times. Behnamian and Fatemi Ghomi [10] developed a PSO–SA hybrid meta-heuristic for a new comprehensive regression model to time-series forecasting.Sangsawang et al. [11] studied the two-stage reentrant flexible flow shop (RFFS) with blocking constraint. The objective is minimizing the makespan. The hybridization of GA (HGA: hybrid genetic algorithm) with adaptive auto-tuning based on fuzzy logic controller and the hybridization of PSO (HPSO: hybrid particle swarm optimization) with Cauchy distribution were developed to solve the problem. Moslehi and Khorasanian [12] considered blocking flow shop scheduling problem to optimize the total completion time criterion. They presented two mixed binary integer programming models, one of them is based on the departure times of jobs from machines, and the other is based on the idle and blocking times of jobs. Guanlong et al. [13] proposed a discrete artificial bee colony algorithm for solving the blocking flow shop scheduling problem with total flow time criterion. Wang et al. [14] suggested a hybrid modified global-best harmony search (hmgHS) algorithm for solving the blocking permutation flow shop scheduling problem with the makespan criterion. Wang et al. [15] proposed a novel hybrid discrete differential evolution (HDDE) algorithm for solving blocking flow shop scheduling problems to minimize makespan and developed the efficiency of the whole algorithm. Grabowski and Pempera [16] developed a fast tabu search algorithm to minimize makespan in a flow shop problem with blocking. Pan et al. [17] presented a novel discrete differential evolution (DDE) algorithm for solving the no-wait flow shop scheduling problems with makespan and maximum tardiness criteria.Hurink and Knust [18] studied flow shop scheduling with transportation times and a single transportation source. Moreover, they assumed an unlimited buffer space between the machines and negligible empty moving times. Soukhal and Martineau [19] considered flow shop robotic cell scheduling problem with multiple parts and a single robot. They assumed that there are no buffers between the machines and proposed an integer linear programming model and a genetic algorithm to solve the problem. Carlier et al. [20] studied the same problem and presented several lower bounds and also proposed an exact branch and bound algorithm. Additionally, they proposed a two-phase genetic algorithm to solve the same problem in which the first phase solves blocking flow shop scheduling problem and the second phase determines the sequence of robot moves.Kharbeche et al. [21] proposed an exact branch and bound algorithm for the flow shop robotic cell scheduling problem where a single robot is considered. In addition they proposed a genetic algorithm to solve the large scale problems in shorter time. Moreover, Geismar et al. [22] considered robotic cells with parallel machines and multiple dual gripper robots. In contrast, they asserted that the assignment of processing stages to robots can have a significant effect on the potential throughput of a cell.Agnetis [23] and Agnetis and Pacciarelli [24] investigated the complexity of a no-wait flow shop problem in which one robot is used to move the parts from a machine to the next, as well as between the machines and the input/output devices.Lawler et al. [25] considered different scheduling problems of manufacturing systems and provided a survey for the investigated algorithms. Inna et al. [26] considered the problem with robotic cells with input and output machine buffers. The machines and buffers are served by one single gripper robot. The objective was to find a cyclic sequence of robot moves that minimizes the long-run average time to produce a part or, equivalently, maximizes throughput.Dawande et al. [27] focused on cyclic production and provided a survey on robotic cell scheduling problem. Batur et al. [28] considered the scheduling problem in two-machine robotic cells producing multiple parts. They proposed a two-stage heuristic to optimize the cycle time. Geismer et al. [29] considered the cyclic flow shop robotic cells with parallel machines and constant travel time. Geismer et al. [30] also considered the same problem with more robots. Elmi and Topaloglu [31] considered hybrid flow shop problem with robotic cells.Ruiz and Vazquez-Rodriguez [32] stated that the properties of graph representation in hybrid flow shop scheduling problem, implied by critical block theory can be used to speed up the search procedure.Low et al. [33] considered hybrid flow shop scheduling problem and consist unrelated alternative machines on the first stage and one machine on second stage. Kurz and Askin [34] considered flexible flow lines with sequence-dependent setup times. They also developed a random key genetic algorithm to effectively solve the problem. Hekmatfar et al. [35] considered a two-stage reentrant hybrid flow shop scheduling problem. The first stage is a reentrant shop which all jobs have the same routing over the machines of the shop and the same sequence is traversed several times to complete different levels of the jobs and in stage two, there is a station with m2 identical parallel machines. The objective function is to minimize the makespan of the system. A new hybrid genetic algorithm (HGA) is proposed for solving the problem.Researchers tend to consider more complex problems which exist in industrial environments and research on practical samples. Therefore, other constraints are considered. Nikzad and Rezaeian [36] considered two-stage scheduling problem in which the first stage consists several parallel machines in site I with different speeds in processing components and one machine in site II, and the second stage consists of two dedicated assembly lines, and the objective function is minimizing makespan. They developed a new mathematical model for the problem and solved the problem with a hybrid meta-heuristic method as a combination of simulated annealing (SA) and imperialist competitive algorithms (ICA). Abdollahpour and Rezaeian [37] investigated flow shop scheduling problem with intermediate buffer and permutation. Minimization of makespan is considered as the objective function. The problem solved with a hybrid artificial immune system and artificial immune system (AIS-IG). Li et al. [38] considered a three-stage flexible flow shop scheduling problem, where the jobs have the group constraint at the second stage and the three stages consist of unrelated parallel machines. The performance of 10 algorithms are compared in this study.Yang [39] considered a two-stage hybrid flow shop scheduling with dedicated machines at stage one and two machines in this stage and one machine in stage two. Yang empirically evaluated the heuristics, including an optimal algorithm for a special case. Lei [40] studied flow shop scheduling problem with two agents and its feasibility model is considered, in which the goal is to minimize the makespan of the first agent and the total tardiness of the second agent simultaneously under the given upper bounds. A simple variable neighborhood search (VNS) algorithm is proposed.Behnamian and Zandieh [41] considered hybrid flow shop scheduling problem to minimize earliness and quadratic tardiness. They considered each stage has at least one machine, and at least one stage has more than one machine. Also, jobs are independent and have no release times and jobs must be processed by at most one machine at each stage. Transportation between the stages is negligible and processors are available with no breakdowns. In addition, jobs are transferred to a buffer ahead of stage and the waiting time between two consecutive stages for each job is limited. They proposed mixed integer linear programming and solved the problem with Colonial Competitive Algorithm (CCA).In all surveys mentioned above, restrictions have been investigated separately. Therefore, some of these restrictions are considered together in this research which is more consistent with the manufacturing environment.This study is organized as follow. The definition of the problem and detailed description of the mathematical programming model for the flexible flow shop scheduling are given in Section 2. Proposed algorithms are presented in Section 3. The computational experiments are illustrated in Section 4. Finally, conclusion and future research are given in Section 5.In this section, definition, notation and basic properties for flexible flow shop problem with robotic transportation are presented.In this study a flexible flow shop system is considered which consists j parts and should be processed at s stages which are included Msunrelated parallel machines at each stage. Also r robots should be used for unloading, transferring and loading parts. J parts should visit each stage one time and processed by one of the eligible machines at each stage. There is no buffer between stages; therefore, j parts should be stayed on machines. At this situation, blocking occurs and j parts should wait until one of r robots unloaded, transferred and loaded parts.The problem can be presented as fallow:RFFsr(um1,...,umS)|rj,Mj,block|CmaxwhereRFFsrstands for “Robotic Flexible Flow Shop”, subscript s shows the number of processing stages, and the vector (um1, ..., umS) indicates the number of unrelated parallel machines at each stage. The subscript r denotes the number of robots. rjdenotes the release times of different parts, Mjshows the eligible machines for part j and block indicates that j parts should wait on previous stage until the eligible machines at next stage be free. The objective is minimizing the makespan.Each part has a release time which parts can be processed after this time. Each stage consists unrelated machines s∈S, Ms≥1; and each part should be processed at each stage by one of the eligible machines.Fig. 1illustrates a flexible flow shop system with robotic transportation. Rectangles present the stages and squares show the machines at each stage. The dashes between machines show the transportations (movement of robots, load and unload of parts). Arrows illustrate the processing sequence of parts and all parts should be processed at all stages.In this section, a MILP model is formulated for flexible flow shop problem with robotic transportation to minimize the makespan. The developed model is discussed in the following:•IndicesN: number of parts where, j: index of jobs j=1,2,…,NS: number of stages, included input and output stages where, s∈{1, 2, ..., S}Ms: number of eligible machines at stage s, input and output stages consist just one machine, m∈{1, 2, ..., Ms}R: number of robots where, r: index of robots, r∈{1, 2, ..., R}W: number of operations that the robots should do; these operations include unloading, transportation to the next stage and loading on a related machine at present stage, where f∈{1, 2, ..., W} and W=N(S−1).ParametersPj,s: processing time of part j at stage s. All parts have zero processing time at input and output stages,rj: release time of part jRs,m: processing speed of machine m at stage s. All machines have zero processing speed at input and output stagesEj,s: number of eligible machines which can process part j at stage s, m∈{1, 2, ..., Ej,s}Tj,s: transportation time of part j at stage sVj: speed of robots for loading, transportation and unloading part jVj,Ls,m,s′,m′: processing time of robots for unloading parts from machine m at stage s and loading on machine m′ at stage s′BM: a very large number, the traditional “Big M”Decision variablesYj,s,m=1ifmachinemprocessespartjatstages0otherwiseXj,j→,s=1ifpartjprocessedbeforepartj′atstages0otherwiseZj,s,f=1ifpartjatstagesisunloaded,transferredandloadedbyfthoperation0otherwiseRSr,f=1ifrobotrunloades,transfersandloadsfthoperation0otherwiseCj,s: the completion time of part j at stage s.Cmax: the time that all parts reach the output stage, makespan.Objective function and constraintsMinimize: CmaxS.T.(1)Cj,1≥rj∀j∈{1,2,...,N}(2)Cj,s+BM(2−(Yj,s,m+Yj,s−1,m′))≥Cj,s−1+Ls−1,m′,s,m×Vj+Tj,s−1+Pj,s×Rs,m∀j∈{1,2,...,N};s∈{1,2,...,S};m∈{1,2,...,Ej,s};m′∈{1,2,...,Ej,s−1}(3)∑m=1Ej,sYj,s,m=1∀j∈{1,2,...,N};s∈{1,2,...,S}(4)∑m=Ej,sMsYj,s,m=0∀j∈{1,2,...,N};s∈{1,2,...,S}(5)Cj,s−1+BM(3−(Yj,s,m+Yj′,s,m+Yj,s−1,m′−Xj,j′,s))≥Cj′,s+Ls−1,m′,s,m×Vj′+Tj′,s+Pj,s×Rs,m∀j,j′∈{1,2,...,N},j≠j′;s∈{2,...,S−1};m∈{1,2,...,Ej,s};m′∈{1,2,...,Ej′,s−1}(6)Cj,s−1+BM(3−(Yj,s,m+Yj′,s,m+Yj,s−1,m′−Xj,j',s))≥Cj′,s+Ls−1,m′,s,m×Vj′+Tj′,s+Pj,s×Rs,m∀j,j′∈{1,2,...,N},j≠j′;s∈{2,...,S−1};m∈{1,2,...,Ej,s};m′∈{1,2,...,Ej′,s−1}(7)∑f=1WZj,s,f=1∀j∈{1,2,...,N};s∈{1,2,...,S−1}(8)∑j=1N∑s=1SZj,s,f=1∀f∈{1,2,...,W}(9)∑f=1f'Zj,s,f(−BM(1−Zj,s−1,f′)≤0∀j∈{1,2,...,N};s∈{2,...,S−1};f′∈{1,2,...,W}(10)∑f=1f′Zj,s−1,f−BM(3−(Yj,s,m+Yj′,s,m+Zj′,s,f′−Xj,j′,s))≤0∀j,j′∈{1,2,...,N},j≠j′;s∈{2,...,S−1};m∈{1,2,...,Ej,s};f′∈{1,2,...,W}(11)∑f=1f′Zj′,s−1,f−BM(4−(Yj′,s,m+Yj,s,m+Zj,s,f′+Xj,j′,s))≤0∀j,j′∈{1,2,...,N},j≠j′;s∈{2,...,S−1};m∈{1,2,...,Ej,s};f′∈{1,2,...,W}(12)∑r=1RRSr,f=1∀f∈{1,2,...,W};(13)Cj,s+BM(7−(RSr,f+RSr,f′+Zj,s,f+Zj′,s′,f′+Yj,s,m+Yj′,s′,m′1+Yj′,s′+1,m′2))≥Cj′,s′+Ls′,m′1,s′+1,m′2×Vj′+Tj′,s′∀j,j′∈{1,2,...,N},j≠j′;s,s′∈{1,...,S−1};m∈{1,2,...,Ej,s};m′1∈{1,2,...,Ej′,s′};m′2∈{1,2,...,Ej′,s′+1};f,f′∈{1,2,...,W},f′<f;r∈{2,...,R}(14)Cmax+BM(1−Yj,S−1,m)≥Cj,S−1+LS−1,m,S,m×Vj+TPj,S−1∀j∈{1,2,…,N};m∈{1,2,…,Ej,S−1}Constraint (1) states that it is possible that all parts are not available in the beginning; and each part has a release time. Constraint (2) states that parts can be processed at a stage if they have been already processed at previous stage. Constraints (3) and (4) show that each part can be processed on just one of the eligible machines at each stage. Constrains (5) and (6) represent the processing sequence of parts on the same machine at each stage; and guarantee that two parts cannot be processed on one machine simultaneously. Constraints (7) and (8) ensure that each robot can transferred just one part at any time. Constraint (9) represents that each part can be transferred to the next stage if it has been already transferred to the pervious stage. Constraints (10) and (11) satisfy that the sequence of robots’ moves should be due to the sequence of processing parts on the same machine at each stage. These constraints guarantee that each part would be loaded on a machine after unloading the previous part from that stage. Constraint (12) shows that each transportation is performed by just one robot. Constrain (13) represents that two unloading and loading are not performed by one robot simultaneously. Finally, constraint (14) calculates the makespan; and represents that makespan is bigger than or equal to the completion time of all parts from last stage plus the unloading and transportation time.As shown in Fig. 2, a solution in this problem is a path of parts and robots movements in the sequence of machines or stages. According to this graphical solution and NP-hardness of the problem, meta-heuristic algorithms are required to solve real and large size problems. ACO and the graphical solution are very close to each other structurally. In other words, the movement of an ant can be represented a solution for this problem simply. On the other hand, ACO is a population based algorithm and another population based algorithm as GA is used for benchmark.In the following, the details of the proposed ACO and GA will be explained.Ant Colony Optimization has been proposed as a new meta-heuristic approach for solving hard combinatorial optimization problems. The solution mechanism of ACO meta-heuristic is based on the behavior of ants in a colony cooperating to find the shortest route to food source.The same analogy applies to find the good solutions for combinatorial optimization problems. An important and interesting attitude of ant colonies appears in their foraging behavior. In particular, ants are highly capable to find the shortest paths between food sources and their nest. While walking from food sources to the nest and vice versa, ants exploit a substance called pheromone on the ground. Ants can smell pheromone substance and when they want to choose their way, they tend to choose paths marked by stronger pheromone concentrations. The main innovation of this research is the usage of two types of pheromones or double pheromones in ACO.It has been shown experimentally that a colony of ant's behavior of trail to trace the pheromone concentration can find the shortest path [42].In the following, the details of implementation ACO will be explained for this problem.The flexible flow shop scheduling problem with robotic transportation consists the arrangement of j parts on m machines at each stage. The processing times of j parts on each machine at each stage are known in advance. This problem can be represented by a disjunctive graph. Fig. 2 shows the disjunctive graph representation for the problem made of four parts and maximum number of three machines at each stage. In the disjunctive graph, circles represent machines for each part. Conjunctive arrows show transportation of parts by first robot. Dash arrows indicate transportation of parts by second robot.The constraints that have to be enforced are described in the follow:•The stages that the parts are processed should be determined,The machine that processed each part at each stage should be defined based on the eligible machines at present stages.This kind of problem needs two types of pheromone, the pheromone trails for each part on each machine at each stage and another for robots. At the initialization step, both pheromone trails are equal to one. In this algorithm, pheromone trail τjsmnindicates the amount of pheromone between stage s and s+1 for part j and shows part j processed on machine m at stage s and machine n at stage s+1. Pheromone trail τjsrindicates the amount of pheromone for part j at stage s for robot r. Ants select parts, machines and robots based on initial pheromone randomly, since all of them have equal probability of selection.The probability of each path (transporting each part from stage s to stage s+1) should be calculated based on the pheromone trails. In the next iteration, ants choose paths based on these probabilities. Based on Eqs. (15) and (16), the probability of selecting each path for parts, machines and robots is calculated:(15)Pjsmnk=(τjsmn)α/∑n=1MsτjsmnMs=Ej,s0otherwise(16)Pjsrk=(τjsr)α/∑r=1NRobotτjsrforselectedpartj0otherwiseIn Eq. (15)τjsmnindicates the amount of pheromone for part j(j=1, 2, ..., N) between stages s and s+1 which is processed on machine m(m=1, 2, ..., Ej,s) at stage s and unloaded from present machine and loaded on machine n(n=1, 2, ..., Ej,s+1) at stage s+1. In Eq. (16)τjsrindicates the amount of pheromone for part j(j=1, 2, ..., N) at stage s for robot r and α is a parameter that allows to control the relative importance of pheromone trail (α>0).After all ants completed their schedules, the pheromone trails are modified. The pheromone trail level is updated as follows:(17)τjsmn=τjsmn+1Cj,sThe Eq. (17) has been used for updating τjsr. At next, evaporator and daemon operations are applied for controlling the convergence of algorithm. For daemon operation, the best solution that has been obtained so far, denoted by best, determined and then the pheromone trail of this solution updated as follow:(18)τjsmnbest=(1−ρ)τjsmnbest+1Cj,sAnd for evaporator operation, the amount of pheromone for other paths decreases. This reduction will be calculated as follow:(19)τjsmn=ρτjsmnwhere ρ is the pheromone evaporating parameter. Both evaporator and daemon operations are used for τjsr.The procedure is repeated until the maximum number of iteration is reached as a stopping criterion.Genetic algorithm, introduced by Holland [43], are adaptive method based on the genetic process of biological organisms and are widely used in many combinatorial optimization problems. In general, GA works by keeping a population of a fixed number (population size) of candidate individuals (chromosomes). To represent a solution, a suitable coding must be devised, which encodes a set of parameters (genes) and joins them together to form a string of values (i.e., chromosome). In each generation, a fitness function is used to evaluate the fitness value (related to the objective function of the problem) of each chromosome. Then, parents are randomly selected from the population. Next, crossover and mutation operators are usually used to combine parents’ chromosomes to generate better offspring. Then, the offspring are reinserted into the current population to form new population for next generation. The process is iterated until a specified stopping condition is reached.In the following, the details of implementation genetic algorithm will be explained for this problem.The initial population consists Popsizerandomly generated individuals. Here, Popsizeis the population size to be kept constant through the generation and its value will be determined by Taguchi.A feasible solution for this problem is a permutation of all the unloading operations of parts. Each unloading operation also includes transportation to the next stage and loading on a related machine at that stage. This kind of representation uses a permutation in which unloading operations are specified the sequence. The length of this representation is the total number of operations to be unloaded by the robots. Parts, machines and robots are selected randomly for each transportation. Thereupon, the operation sequence that will be unloaded by the robots is generated through the following algorithm.BeginGenerate a random permutation of W,f←1,RepeatAssign Part (j) to f=f till f+S−1 of generated permutation,f←f+S−1,Untilf==WTemp(Part(f))←0,f←1,RepeatTemp(Part(f))←Temp(Part(f))+1,Add Temp (Part (f)) in to Stage (f)Select machine m from eligible machine for Part (f) and Stage (f) randomly,Add machine m in to Machine (f),Select robot r randomly,Add robot r in to Robot (r),f←f+1,Untilf==w,Stop.After generating the solutions (initial solutions) through the encoding algorithm, the decoding algorithm is applied to evaluate its objective function value (makespan). As mentioned previously Pj,s, Rs,mand Ej,s, the input data, are required to evaluate the makespan for each solution and Cmax is the time that all parts have reached the output stage. Here some new terms are defined which are used in the decoding algorithm.Part: The part which processed at the fth position in the solution.Stage: The stage which the part at the fth position in the solution is processed.Machine: The machine which processes the part at the fth position in the solution.Robot: The robot which transfers the part at the fth position in the solution.Fig. 3illustrates the solution representation and the way to determining Stage at each position. Part shows which part should be processed and transferred, also when the process should be done. Stage shows parts’ stages. Machine shows the machines which process the parts and when the process should be performed. Robot shows which robot should be used. The presented example contains four parts and tow processing stages. Therefore, all parts have three transportations: First, from the input stage to the first processing stage, second, from the first processing stage to the second processing stage and finally from the second processing stage to the output stage.Fig. 3 shows an example which contains 4 parts, 3 stages and 2 robots. The first gen of chromosome illustrates that first part (Part1=1) should be unloaded at first transportation (F=1) and the second robot (Robot1=2) transferred this part from first eligible machine (Machine1=1) at first stage (Stage1=1) and transferred to second stage (Stage5=2) and loaded on second eligible machine (Machine5=2). For better perception, sixth gen of chromosome illustrates that fourth part (Part6=4) should be unloaded with sixth transportation (F=6) and second robot (Robot6=2) transferred the part from first eligible machine (Machine6=1) at second stage (Stage6=2) and transferred to the third stage (Stage10=3) and loaded on first eligible machine at stage three.The decoding process exploits the information provided by each chromosome to generate the solution and evaluate the fitness of each individual. The objective is minimizing makespan, so that the fitness of the chromosome is related to the objective function value.The fitness evaluation function for the chromosomes is linear-related to the makespan of the solution. Since solutions with lower values of the makespan should be searched, objective is used as fitness.A set of individuals from the current population is chosen in order to form the mating pool for the reproduction step during the selection phase. The aim of selection is to keep good individuals and eliminate the bad ones from one generation to another [44].Based on Eqs. (20) and (21), the probability of selecting each chromosome is calculated:(20)Ppos=Exp−β.ObjectiveposWorstObjectivepos=1,2,...,Popsize(21)P=posPpos∑i=1PopsizePipos=1,2,...,PopsizeThis means that the chromosome with lower objective has more chance to be selected than the chromosome with higher objectives.Once the chromosomes are selected for reproduction, the crossover and mutation operators are applied to produce the offspring. Crossover helps genetic algorithm to converge to the best individual.Crossover operators recombine the genes of two selected chromosomes to generate two new chromosomes which will be included in the next generation. It aims to take the best features of each parent and mix the remaining features in forming the offspring.The one-point crossover is applied to the genes of part sequences, machine and robot. It is explained as follows: a crossover point is generated randomly by uniform distribution at integer position k∈[2, n−1]. The substring from 1 to k of the first parent is copied into the first offspring, and then this new part sequences’ genes is completed with the remaining part indicator in the same order as they appear in the second parent and the same process will be done for machines and robots. Then based on part sequences, stages are calculated. The symmetric process is repeated for the part sequences, genes of machine and robot in second parent and the second offspring is generated. This process has been shown in Fig. 4. The probability of applying the crossover operator is determined by the crossover rate PC.Mutation is designed to let the GA searches a wider region of solution space, usually by introducing random genes or changing chromosomes. It helps to introduce variation into the individuals and helps GA to get away from local optimal. The swap operator is applied in this research for mutation. One chromosome will be selected randomly, then two genes will be selected randomly and the genes at their positions are swapped, and will be done this process for part sequences, machine and robot. In Fig. 5mutation operation has been shown. The probability of applying mutation operator is determined by the predefined mutation rate PM.Stopping criterion is one of the important decisions in the design of a genetic algorithm since it affects the performance of the algorithm. There are three criteria widely used in the literature: maximum number of generations, maximum CPU time, and no improvement of the best solution for a specified number of generations. The proposed GA stops running when the iteration reaches the predefined iteration number.After the selection, crossover and mutation operation, offspring are generated and their fitness are calculated. Offspring are inserted into the current population and the algorithm selects Popsizeof chromosome based on their fitness value from this population.In this section, the results of computational experiments are presented to evaluate performances of proposed GA and ACO. The sizes of problems are determined by varying the levels of three parameters, which are respectively the number of part types, the number of stages, and the number of robots. Three sizes of problems are considered for this flexible flow shop scheduling problem. These proposed algorithms have been coded in MATLAB and run on Intel Core i7 2.6GHz PC with 6GB memory.Parameters are generated randomly based on Elmi and Topaloglu's research [31]. Elmi and Topaloglu's research [31] has been used for validity of the model. Also, the results obtained by Lingo, ACO and GA are compared to each other for validity of the proposed model and algorithms. The proposed ACO and GA have been implemented 10 times for each size of problems.For each part, standard processing time, unloading, transferring and loading time at each stage are generated from the uniform distribution U [10,100], U [5,20], U [5,20], U [5,20], respectively. Unrelated machines at each stage operate at three levels of processing speed, which are, respectively 1, 2 and 3. The second and third speed level of machines are respectively twice and three times slower than the first level that operations perform in their standard processing times. The processing time of part on an eligible machine would be determined by multiplying the standard processing time by the speed level of the machine. Each part has a standard release time which is generated from the uniform distribution U[5,80].Lingo and Elmi and Topaloglu's research [31] are used for validity of the proposed model and algorithms. The data is based on Elmi and Topaloglu's research [31] and the obtained results are compared to each other and proposed algorithm in Elmi and Topaloglu's research. Elmi and Topaloglu did not consider release time, loading and unloading times in their research. Therefore, if the release time, loading and unloading times are set to zero in the proposed problem, the results should be the same as Elmi and Topaloglu's results. Validity and reliability of the proposed model and algorithms can be achieved by the obtained results. The results include makespan shown in Table 1. As Table 1 shows, the makespan value decreased in comparison with SA (proposed algorithm is Elmi and topaloglu's research). Also Table 1 shows that Lingo cannot solve the problem when the parts and stages increase. In addition, Lingo cannot solve the problem, when the size of problem increase.The percentages of reduction in average makespan (GAP) for GA and ACO compared to SA has been shown in Table 1. Thus, the application of the GA and ACO for the generated problems have reduced the makespan by GAP=4.01% on average. Consequently, the production rate of the system increases by (0.0401/(1−0.0401))×100=4.18%.The results include the mean of makespan and computational times are shown in Table 2for small-size problem. Based on Table 2, it is clear that the computational times increase when the number of stages increase for the same number of parts and when the number of stages are the same, increasing the number of parts increases the computational times. It also indicates that both algorithms have proper quality for solving problems with small-size. However, the computational times of ACO is more than the computational times of GA.ACO and GA are used for solving medium-size problems. Similar results can be noted from Table 3and appropriate mean of meakspan can be obtained by solving genetic algorithm.Table 4indicates that, ACO is not an appropriate algorithm for solving proposed problems in large-size; because it cannot produce an optimal solution, although it has high performance in small-size and medium size problems. Also, the mean of computational time increases greatly in ACO. So, GA is a proper algorithm than ACO for solving proposed problem. Therefore, GA can be stated as a key algorithm as compared to ACO. The effect of the robots number on the objective function will be discussed in next sections.Tables 5 and 6show the mean of makespan for 10 runs. As seen in Tables 5 and 6, the number of robots differs for each problem. The makespan values decrease as the number of robots increases. It can be observed that after a certain number of robots, the reduction in makespan values is relatively much smaller.Table 7determines the number of robots for different parts and stages. When the number of robots is greater than this number, robots idle times increase and also the costs of system increases without reducing the completion times of all parts. Therefore, these number of robots are the closest number to the optimal number of robots.The percentage of reduction in average makespan (GAP) for GA compared to ACO has been shown in Table 8(for the operative robots).(22)GAP=ACOmakespan−GAmakespanACOmakespan×100Table 8 shows that the application of the GA for the generated problems has reduced the makespan by GAP=18.18% on average. In other words, if the solution obtained by the GA is implemented in a real manufacturing system, a given production volume of this system is achieved within 18.18% lesser time as compared to ACO. Consequently, the production rate of the system increases by (0.1818/(1−0.1818))×100=22.2%.In addition, Fig. 6clarifies the effect of using different number of robots on the makespan and illustrates the reduction in makespan for each problem as the number of robots increases. Furthermore, GA is used for solving the problem. The points in this figure are the mean of makespan values when the number of robots differ. It can be seen that the makespan will not be further improved after a certain number of robots are used.

@&#CONCLUSIONS@&#
