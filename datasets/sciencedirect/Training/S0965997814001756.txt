@&#MAIN-TITLE@&#
Efficient methods to visualize finite element meshes

@&#HIGHLIGHTS@&#
Efficient visualization of large finite element meshes is described.The mesh editor is based on improved winged-edge data structure.Comparison with GiD, ParaView and VisIt is provided.

@&#KEYPHRASES@&#
FEM,Finite element mesh,Editor,Visualization,OpenGL,Mesh preprocessing,

@&#ABSTRACT@&#
This article describes implementation details of a graphical editor which is intended for efficient 3D visualization of finite element meshes. The purpose of this program is to prepare the input data for the finite element method – a widely known method for numerical solutions of scientific and engineering problems described by partial differential equations. Nowadays, increasing demand on accuracy of the calculation through the boom of parallel computing involves the use of finer and more detailed finite element meshes. However, the meshes with a very large number of elements and nodes cause problems with visualization in commonly used programs that are very slow, unresponsive and for some operations often unusable. Therefore, efficient data structures and algorithms were designed and implemented to enable fast work with very large finite element meshes.

@&#INTRODUCTION@&#
In the case of simple problems, in which the governing differential equations have constant coefficients and the problem domain has a simple shape (quadrilateral etc.), there is usually no difficulty to prescribe input properties and so it can be done during mesh generation. However, in real problems, the coefficients of the governing differential equation are functions depending on position and the area solved is of a complex shape. In these cases it is necessary to select groups of elements, nodes or edges of elements according to the task specification and to assign them some properties. The properties then describe given boundary conditions or values of coefficients in the differential equation. Choosing the individual entities in the raw output from the mesh generator (usually simple text file) is tedious, and thus impossible, for practical tasks, because the mesh contains hundreds of thousands of elements, nodes and edges. In these days, commonly used tools for mesh visualization have problems with large finite element meshes. They are unresponsive and not comfortable to use. The mesh editor, whose implementation is the topic of this article, allows fast visualization and manipulation with very large meshes while keeping memory consumption at low level.Visualization tool design is affected by the nature of the data to be visualized. If a point of interest is a structure of the mesh (e.g. to check, whether mesh generation turned out as expected), the tool should allow to view the mesh from different positions and angles and thus the program should implement the non-linear zoom and should be able to display the smallest details in the mesh. If the goal is to view computed results and map them to the mesh surface, it is suitable to show them in a well-arranged form, e.g. through a sufficiently distinctive color scale, and it is not desirable to be disturbed with an over-detailed image.While visualizing a 3D model, it is suitable and desirable to show only as many details as necessary to avoid the loss of important information about the model topology or the model geometry. Applications of mesh simplification are often used in computer games. In the scene with thousands of objects only those near the viewer are shown in a satisfactory detail and the others as degenerated. The visual perception of the scene is not affected due to the perspective projection. Each object is represented by a hierarchy of meshes with different resolutions. This hierarchy is either stored in the model or generated after a program is launched. A fine mesh is used when the object is near the observer. A coarser mesh is used when the mesh moves away. Unfortunately, this method can cause annoying flicker effect due to the frequent changes in the level of detail of each object. Moreover, if just one object dominates the scene, the method does not help.In this case progressive meshes could be used [1]. These dynamic data structures are used to represent mostly the complex triangular meshes. The mesh is dynamically transformed at runtime using iterative techniques. The pair of operations Edge collapse – Vertex split is usually used for this purpose. Edges that are outside the viewing frustum are covered with another face or are too far away from the observer are removed from the mesh representation. The operation is reversible, so the method is a lossless compression.However, the progressive mesh is not a proper method to be used in this project when the direct manipulation with mesh entities is needed. It is possible to admit some kind of simplification while postprocessing the results on the mesh. Then, the use of a method that progressively changes the level of detail is advisable.It is needed to have the model of the problem domain as a composition of individual entities, their geometry and topological connections, before a finite element mesh is generated. The model is described by its boundary and the problem domain must be discretized for further use. This process is called mesh generation [2,3]. The output of a mesh generator is a finite element mesh corresponding to the input domain. The elements are the basic components and there are several types of them. The frequently used tetrahedral elements consist of four triangular faces described by three edges with the edge is made of two nodes.It is sufficient to have only the list of nodes with their coordinates and the list of elements with references to their respective nodes for the mesh representation. Other entities (e.g. faces, edges) are usually omitted from the mesh generator output. However, the mesh editor has to handle them all, therefore, they must be created while loading the mesh. It is necessary to know all the kinds of the meshes that can be used as an input for the mesh editor implementation and especially for the design of the internal mesh representation. Meshes can be divided into several groups according to different criteria. The mesh classification is described in [1]. The most basic form of mesh classification is based upon the connectivity of the mesh: structured or unstructured.A structured mesh, also known as a grid, has a regular internal structure. Elements in the mesh are simply addressable due to the uniform distances between nodes. It restricts the element choices to quadrilateral in 2D or hexahedra in 3D. The regularity of the connectivity allows us to conserve space since neighborhood relationships are defined by the storage arrangement.An unstructured mesh is characterized by irregular connectivity. It allows for any possible element that a solver might be able to use. When compared to the structured meshes, the storage requirements for an unstructured mesh can be substantially larger since the neighborhood connectivity must be explicitly stored.Other mesh classification is based upon the dimension and the type of elements present. Depending upon the analysis type and solver requirements, meshes can be composed of one-, two- or three-dimensional elements. Homogenous meshes contain elements of the same type and dimension. Hybrid meshes are composed of elements of different type and/or dimension, e.g. tetrahedral mesh with 1D bars.Additional classification can be made upon whether the mesh is conformal or not. An intersection of any two elements is either by a face, an edge or a node in conformal mesh. A non-conformal mesh contains for instance two quadrilaterals sharing two edges or two quadrilaterals sharing only a half of one edge. Non-conformal meshes are usually created during distributed generation of meshes from sub-domains.The mesh editor that is the subject of this article works with all the above mentioned classes of meshes. Some problems can take place only during creation of the surface representation of non-conformal meshes. This issue is described in detail in Implementation section.Three-dimensional meshes can be replaced for the purpose of visualization with its surface representation. The elements (or parts of elements) that are hidden inside the volume of the mesh can be omitted. Visualization is much more efficient then. Most of the operations on entities, such as selection or setting of properties, can also be made on the mesh surface. The implementation of cuts through the volume is a problem. In order to show the entities on the cross-section, the surface representation must be regenerated each time. Making a cut is therefore a little more computationally intensive but it is outweighed by the fact that 2D surface representation is sufficient to handle any finite element mesh.Because of the fact that the surface of both two-dimensional and three-dimensional elements is formed by either a triangle or a quadrilateral to represent the whole mesh, it is sufficient to use these two shapes. The surface representation must also include edges and vertices which the faces are formed of. The one-dimensional elements will be dealt with separately. When considering the internal representation of a mesh it is necessary to take into account the memory requirements. It should be noted that “closed” 3D mesh (mesh without boundary elements) with homogenous structure and with n elements has approximately 6n edges, 10n faces and 5n tetrahedral elements.Most of the triangles and the edges will be inside the volume and can be therefore discarded after surface generation. The number of the surface entities is closely related to the geometrical shape of the domain. However, the number is significantly lower than the number of all entities for most meshes. The common operations on the mesh, e.g. to find neighboring faces, need complete topological data about the original mesh. The input file usually does not contain information about connections between elements. Therefore it must be determined while loading the mesh from the input file.The data structure called Winged edge is used to store this kind of information. It is a widely used data structure in, which was first proposed 30years ago [4], and has become a popular topic in computer graphics especially for modeling practice [5], or [6]. It describes explicitly the geometry and topology of faces and allows fast traversing between faces, edges and vertices on the surface through a structure similar to the linked list. Traditional winged-edge data structure is represented by edge table. Each entry in the edge table contains these references: start vertex and end vertex, left face and right face, the predecessor and successor edges when traversing its left face, and the predecessor and successor edges when traversing its right face. Clockwiseordering (viewing from outside of the polyhedron) is used for traverse. Note that if the direction of the edge is changed, all entries in the table must be changed accordingly. Also, if some faces of a solid have holes, the above form of winged-edge data structure does not work. To make it work, ordering of the edges must be changed or some auxiliary edges must be added to surface representation. All these changes are difficult to implement efficiently. And this type of winged-edge data structure cannot be used for non-conformal finite element meshes. The basic composition of the winged-edge data structure that describes polygon meshes is widely used in computer graphics. However, the increased memory requirements compared to representations like the simple list of vertices and elements is the disadvantage. Moreover, the winged edge structure is based on dynamically created objects and therefore fragmentation of the memory can occur.Fig. 1shows the adjusted data structure describing mesh surface based on traditional winged-edge schema, but eliminating some of its deficits. This structure is more suitable to use in finite element mesh scenario.

@&#CONCLUSIONS@&#
A program that can visualize and edit finite element meshes effectively was described and implemented. When compared to the existing tools, which are often unresponsive and slow to use, this implementation is fast and fluent even for very large data input. The presented tool works with all widely used types of meshes including the non-conformal meshes and the meshes composed of unconnected parts. Through the use of smart representation of the mesh surface, there was no need to use the advanced visualization techniques, such as the progressive mesh that on one hand enables faster rendering, but on the other hand makes the direct editing of the mesh entities more difficult or impossible with exceedingly increased memory consumption.The future work will include:•Adding a support for postprocessing the results of the finite element method on the mesh.Effectively postprocess very large data sets using the multigrid method for visualization purposes.