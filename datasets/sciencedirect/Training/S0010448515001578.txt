@&#MAIN-TITLE@&#
Robustness and efficiency of geometric programs: The Predicate Construction Kit (PCK)

@&#HIGHLIGHTS@&#
A system to automatically generate C++ code for robust predicates from their formulas.The predicates involved in the intersection between a Voronoi diagram and a tetrahedral solid.A companion open-source implementation (Predicate Construction Kit) in the GEOGRAM library.Experimental validation with several synthetic and real industrial datasets.

@&#KEYPHRASES@&#
Geometric predicates,Arbitrary precision,Symbolic perturbation,Expansion arithmetics,

@&#ABSTRACT@&#
In this article, I focus on the robustness of geometric programs (e.g., Delaunay triangulation, intersection between surfacic or volumetric meshes, Voronoi-based meshing …) w.r.t. numerical degeneracies. Some of these geometric programs require “exotic” predicates, not available in standard libraries (e.g., J.-R. Shewchuk’s implementation and CGAL). I propose a complete methodology and a sample Open Source implementation of a toolset (PCK: Predicate Construction Kit) that makes it reasonably easy to design geometric programs free of numerical errors. The C++ code of the predicates is automatically generated from its formula, written in a simple specification language. Robustness is obtained through a combination of arithmetic filters, expansion arithmetics and symbolic perturbation.As an example of my approach, I give the formulas and PCK source-code for the 4 predicates used to compute the intersection between a 3d Voronoi diagram and a tetrahedral mesh, as well as symbolic perturbations that provably escapes the corner cases. This allows to robustly compute the intersection between a Voronoi diagram and a triangle mesh, or the intersection between a Voronoi diagram and a tetrahedral mesh. Such an algorithm may have several applications, including surface and volume meshing based on Lloyd relaxation.

@&#INTRODUCTION@&#
In this article, I focus on the robustness of geometric programs w.r.t. numerical degeneracies, and propose a complete methodology implemented in a toolset to easily design geometric programs free of numerical problems.Some classical tasks in geometric modeling, including computing the Delaunay triangulation, computing the intersection between surfacic and/or volumetric meshes, and meshing using Voronoi diagrams are examples involving such geometric programs. Geometric programs take as an input a set of objects (points, lines, segments, triangles …) and return a combinatorial structure (e.g. a mesh) that inter-connects the elements of the input.Geometric predicates are central components of geometric algorithms. They are functions that take as input a small set of geometric objects and return a binary (or ternary, see below) answer. For instance, the orientation predicate in 2d indicates for a set of pointsp1,p2,p3whether the angle betweenp1,p2⃗andp1,p3⃗is a right turn or a left turn (or no turn at all ifp1,p2,p3are aligned, thus “ternary” answer). Typically, in C/C++, the 2d orientation predicate is implemented as a function:int orient2d(double* p1, double* p2, double* p3)that returns−1for a left turn,+1for a right turn and 0 if the three points are aligned. The result of this function is used by the geometric algorithm, typically to decide which pairs of points/triples of points should be connected by an edge/triangle in a mesh, in other words, the predicates determine all the “combinatorial decisions” taken by the algorithm.The mathematical definition of geometric predicates are most of the time quite simple, for instance, for the orient2d predicate mentioned above, this corresponds to the sign of the determinant of the two vectors. However, there are two major difficulties for implementing a geometric predicate:1.double precision does not suffice: When using standard floating point doubles, for some configurations, the answer given by the implementation will differ from the exact value. More importantly, it may differ inconsistently. For instance, the same predicate may assert thatp1is strictly abovep2, and thatp2is strictly abovep1! This clearly leads to erroneous combinatorics (inconsistent mesh);corner cases are tricky: There are configurations where the predicate answers 0. For instance, in the case of orient2d, this corresponds to three points that are aligned. If you use the predicate to compute the intersection between a polygon and a straight line, this corresponds to the configuration where a vertex of the polygon lies exactly on the straight line. While such configurations are reasonably easy to handle in 2d, this quickly becomes very complicated for 3d intersection problems.Two techniques have been developed to handle both difficulties:Arbitrary precision: To deal with the first issue, the idea is to replace standard double floating point computation with custom types  [1], that can represent numbers with arbitrary precision, using a dynamically allocated space (more on this below);Avoiding corner cases with ‘Simulation of Simplicity’: to deal with the second issue, a natural (naive) idea would be to “move the points a little bit” whenever a degeneracy is encountered. Unfortunately this naive idea does not work in general. Imagine that the same pointpis used several times as an argument of the predicate, for instanceP(p,q,r)andP(s,t,p), and imagine that the second configurationP(s,t,p)is degenerate, then, ifpis moved, in order to keep combinatorial decisions coherent, the information should be “back propagated in time” to the first invocation. A solution to this problem was introduced in  [2], that defines a globally consistent perturbation and applies it symbolically: Imagine that all the pointspifollow a set of trajectories, parameterized by timet, and starting from their actual positions. Then each pointpiis replaced with a functionpi(t)such thatpi(0)=pi(dashed arrows on the figure).Whenever a predicateP(p,q,r)returns 0 (such as the circled vertex when classified w.r.t. the solid line), the idea will be to replace the answer of the predicate with the (symbolically computed) limit:limt→0P(p(t),q(t),r(t)). In practice, to derive the implementation of a predicatePfrom its formula, this means choosing a perturbationpi(t)(typically an exponent oftthat depends oni), then computing the Taylor expansion ofP(p1(t),p2(t),p3(t))in function oft. The implementation tests all the terms of the Taylor expansions in increasing powers oft, and returns the sign of the first non-zero one. Note that the constant term corresponds to the unperturbed predicate.At first sight, this may seem a pretty convoluted/overly complicated way of handling these corner cases, but from a software design point of view, this has very interesting properties: most geometric programs depend on a very small number of predicates. For instance, a robust implementation of Delaunay triangulation only needs two predicates, orient() and in_sphere(), and an algorithm to compute mesh intersections will mostly depend on some forms of orient() (more on this below). If your predicates implement the Simulation of Simplicity, this means that they will never answer 0, in other words, corner cases are never encountered. This has a dramatic influence on the development of the geometric program: imagine an algorithm that computes the intersection between two volumetric meshes. There is a wide variety of degenerate configurations that can occur (vertex on a face, edge on a face, edge on an edge, coplanar faces …). Using the symbolically perturbed predicates, these configurations never occur. By simply replacing a couple of functions, all the corner cases “mathemagically” disappear! The price to pay is that since the algorithm behaves as if the point was not on the plane, the algorithm will generate zero-area/zero-volume elements (see results in Section  4), but they can be filtered-out by a post-processing phase, that is much easier to develop than the algorithm that handles all corner cases explicitly. More importantly, it also makes it much easier to check the correctness of the program.Efficiency/arithmetic filters At this point, to implement the predicate, one will derive its mathematical expression, compute the symbolic perturbation, and implement the formula for all the terms of the Taylor expansion with exact arithmetics (e.g.,  [1], described in the next section). However, exact arithmetics costs between10×and50×the time of standard floating point double precision arithmetics! For this reason, to improve performances, it is interesting to have a way of determining the answer in the “easy cases”, where we are sure that the result computed using double precision floating points is exact. In other words, this corresponds to configuration where we are sure that the sign of the computed floating point number is correct. Meyer and Pion introduced a method that computes bounds from the formula of the predicate  [3]. If the absolute value of the result is larger than the bound, then they prove that the sign is correct. In addition, the bounds can be dynamically adjusted to the input, thus making it even more efficient (with these dynamic bounds, a quick decision can be taken in a much larger number of cases).Summary: a predicate implementation depends on the following three components:1.an arithmetic filter:[3], that gives an answer in the “easy cases” where the exact answer can be determined using standard floating point arithmetics. This is the key to efficiency (obtaining correctness and robustness without paying the price for it!);exact arithmetics :[1], used when the filter could not determine the answer, this is the key to correctness and robustness;symbolic perturbation :[2], that “escape” the corner cases by (symbolically) considering the limit of a globally consistent perturbation applied to the input. This is the key to correctness, robustness and ease of implementation of the geometric program on top of the predicate.For Delaunay triangulation, predicates are well studied and understood, and several implementations are available, such as [4] and Shewchuk’s code  [1], that are widely used.However, some mesh generation algorithm that we develop, such as the flow simulator with adaptive gridding  [5,6], our adaptive meshing algorithms  [7,8], and our hex-dominant meshing algorithm  [9], require to compute the intersection between a 3D Voronoi diagram and a tetrahedral mesh. Robustness is a key issue, for instance our adaptive meshing algorithm optimizes a Voronoi mesh such that some facets of the Voronoi cells conform to the interfaces of a volumetric structural model (horizons and faults). In terms of mesh intersections, this means that we create degenerate configurations. Unfortunately, the predicates that we need are “exotic” and therefore not available in the standard packages.Exact predicates “without the agonizing pain”:11Tribute to Jonathan Shewchuk’s “Conjugate Gradient without the agonizing pain”.In the programming libraries mentioned above, the expertise on the three components often depend on a limited number of individuals (J. Shewchuk, S. Pion, O. Devillers …). Since we will need to implement a whole family of more general predicates, my goal is now to develop a methodology such that any practitioner of the field could create his own predicates. Concerning the first layer (filters), this goal is already reached by the FPG tool  [3]. Concerning the two other ones, some new programming tools are needed. In particular, we need an efficient and easy-to-use implementation of exact arithmetics.A first solution: exact arithmetics using dynamic integers: There are already several existing programming libraries that implement exact arithmetics. For instance, when considering integer arithmetics, it is possible to represent an integer of arbitrary precision by an array of integersa[0]…a[l−1]. Such an array represents the integerxgiven byx=∑i=0l232∗ia[i].Then, it is possible to implement algebraic operations(+,−,∗,/), in a way that is very similar to computing by hand (except that ‘digits’ are numbers between 0 and232−1instead of0,1,…,9). Some programming libraries, such as GMP  [10], provide efficient implementations of these integer-arithmetics operations, optimized from both an algorithmic point of view (Fourier transform for large numbers) and implementation point of view (assembly for some architectures). Once you have this implementation of arithmetic operations for integers of arbitrary length, it is possible to implement a floating point number as a couple of two (arbitrary length) integers, that represent the mantissa and the exponent. Arithmetic operations are then implemented, making sure that each significant bit is represented in the result, using dynamic allocation. This is the strategy taken by  [11], a widely used programming library. At this point, one may directly use MPFR to implement the predicates, however, this makes the software dependent on MPFR and GMP, that are quite difficult to install/compile on non-Unix platforms. Note that MPFR is a very general software library, that implements not only basic algebraic operations, but also transcendental functions, accurate control of the rounding modes,…. In our context, to implement the geometric predicates, we only need three algebraic operations(+,−,∗). Note also that in the end, we only need to evaluate the sign (positive, zero or negative) of the result. Is there a way of having a more “minimalist” implementation, easy to compile, and with only the functionality that we need?A minimalist solution: expansion arithmetics: We now take again a look at Shewchuck’s predicates[1], but this time, instead of taking the point of view of a user of the predicates, we need to understand the underlying principles, in order to be able to derive our owns predicates. Shewchuk’s predicates use a form of exact arithmetics that is different from the arbitrary-length integers mentioned in the previous paragraph. The idea is again to represent a number as a set of componentsx[0]…x[l−1], but this time each component is a floating point number, and the array represents the real number given byx=∑i=0lx[i].In addition, all the operations are specified to ensure an important property, that the sign ofxis completely determined by the size of the last component:Sign(x)=Sign(x[l−1]).In a nutshell, this property is enforced by ensuring that all the components are sorted by increasing exponents, and by ensuring that the exponents are sufficiently separated (or non-overlapping) so that the sumx[0]+⋯x[l−2]has a smaller magnitude than the least significant bit ofx[l−1]. An array of floating point numbers that satisfies this condition is referred to as a non-overlapping expansion. Shewchuk provides C implementations for the following operations:•two-sum(double,double)→(2)expansiongrow-expansion(double,(k)expansion)→(k+1)expansionexpansion-sum((k)expansion,(l)expansion)→(k+l)expansionscale-expansion(double,(k)expansion)→(2k)expansionStarting from these 4 functions as building blocs, I implemented expansion-product, by recursively calling scale-expansion and expansion-sum (a method referred to as distillation in Shewchuk’s article). This gives a class expansion with functions for the three algebraic operations(+,−,∗)and obtaining the sign at the end. To ensure that the code will remain efficient, even in a multithreaded environment, my expansion class allocates space on the stack instead of the heap, since there is (in most systems) a global lock on the heap, not well suited to multithreaded environments. In addition to the (low-level) expansion class, I implemented an (easier to use but less efficient) expansion_nt wrapper (expansion “number type”), that overloads the operators(+,−,∗). The resulting library is minimalist and compact (only a few hundred lines of C++ code, or 3000 lines if comments are counted). I experimented it on several OSes and architectures (PC Windows, PC Unix, Mac, Intel MIC 64-cores, Android phones with ARM v7 chips…). The C++ source code (BSD license) is available from the following address: http://gforge.inria.fr/geogram, together with a script that generate the C++ function of a predicate from its formula and its symbolic perturbation.I shall now explain how to use the Predicate Construction Kit to (robustly) compute the intersection between a 3D Voronoi diagram and a tetrahedral mesh. This is the key component to several 3D meshing algorithm that we are currently investigating, such as adaptive Voronoi meshing for flow simulation  [5,6], adaptive simplicial meshing  [7,8], and hex-dominant meshing  [9]. In the context of 3d modeling for oil and gas exploration, the degenerate configurations are encountered very often, due to both the geometry of the input (thin layers, onlaps, …) and the nature of the algorithms  [12].For instance, the algorithm in  [5,6] aims at generating a Voronoi diagram with cell facets that match some predefined interfaces (such as the boundaries between geological layers and geological faults), which will create degenerate configurations when computing the intersections between the cells and those interfaces. For this reason, in order to have a robust implementation of this software component, we have no other choice than carefully analyzing the predicates involved in the intersection algorithm, and developing a robust version of them. Before detailing the predicates, I shall present the general algorithm (next page) that computes the intersections:The algorithm works by propagating simultaneously over the tetrahedra and the power cells. It traverses all the couples(t,i)such that the tetrahedronthas a non-empty intersection with the power cell ofyi. (1) Propagation is initialized by starting from an arbitrary tetrahedrontand a pointyithat has a non-empty intersection between its power cell andt. I use the pointyithat minimizes its power distance‖yi−.‖2−wito one of the vertices oft. (2) A tetrahedrontand a Voronoi cellDelyican be both described as the intersection of half-spaces, as well as the intersectiont∩Delyi, computed using re-entrant clipping (each half-space is removed iteratively). I use two version of the algorithm, a non-robust one that uses floating point arithmetics, and a robust one. (3) Each intersectionP=t∩Voryiis passed back to client code (that does what it needed to do with it). The convexPis illustrated in the (2d) Fig. 1as the grayed area (in 3d,Pis a convex polyhedron). The algorithm then propagates to both neighboring tetrahedra and points (points are neighbors if they are connected with a Delaunay edge). (4) Each facet ofPgenerated by a Voronoi cell facet triggers propagation to a neighboring point. In the 2d example of the figure, this corresponds to edgese2ande3that trigger propagation to pointsyj1andyj2respectively. (5) Each portion of a facet oftthat remains inPtriggers a propagation to a neighboring tetrahedront′. In the 2d example of Fig. 1, this corresponds to edgese1ande4that trigger a propagation to trianglest2andt1respectively.This algorithm is parallelized, by partitioning the meshMintoM1,M2,…,Mnb_coresand by computing in each threadMthrd∩Del(Y).In the algorithm, the convex clipping operation (step 2) is the only moment where exact predicates are used. This operation takes as an input a tetrahedron and a Voronoi cell, and returns the intersection between them. It can be implemented in an iterative/reentrant manner: the Voronoi cell can be described as the intersection of half-spaces (the bisectors of the Delaunay edges). Each iteration will “chop-off” a half-space from the result. It means that the only needed predicate is a form of orient3d, that classifies a point with respect to a bisector. However, the setting is significantly more complicated, since starting from the second facet of the Voronoi cell, we need to classify points that were the result of previous intersections. This difficulty can be dealt with by replacing in each predicate the intersection points with their expression in function of the data (tetrahedral mesh vertices and Delaunay vertices). Depending on the involved points, several configurations can occur. Fortunately, the total number of configurations remains reasonably small (four configurations in 3d). The rest of this section introduces the relevant definitions, gives the general formula for all possible configurations in arbitrary dimension, together with the symbolic perturbations that allow degenerate configurations to escape. The formulas in our 3d setting are also given. The implementation of the predicates is freely available in PCK (http://gforge.inria.fr/geogram). The derivations are provided below for the interested reader.Warning–boring material ahead!The rest of this section may be skipped in a first reading.Definition 1The (additively) weighted distance (or power distance)dW(p,q)between a weighted point(p,w)and a pointqis defined bydW(p,q)=def‖p−q‖2−w.Definition 2The bisectorΠW(p0,p1)of the pair of weighted points(p0,w0),(p1,w1)is defined byΠW(p0,p1)=def{q|dW(p0,q)=dW(p1,q)}={q|‖p1−q‖2−‖p0−q‖2+w0−w1=0}={q|(p1−q+p0−q)t(p1−q−p0+q)+w0−w1=0}={q|‖p1−p0‖2−2(q−p0)t(p1−p0)+w0−w1=0}.Observation 1The intersectionqbetweendbisectorsΠw(p0,p1),…Πw(p0,pd)and ad-simplexΔ(q0,q1…qd)can be obtained in barycentric form asq=∑i=0dλiqi. The barycentric coordinates(λi)are given byΔ[λ0λ1⋮λd]=B′([l1⋮ld]+[−w1+w0⋮−wd+w0])+bwhereai,j1≤i≤d0≤j≤d=2(qj−p0)t(pi−p0);li1≤i≤d=‖pi−p0‖2Ad+1×d+1=;Δ=|A|;B=ΔA−1=().ProofThe intersectionqsatisfies:{∑i=0dλi=1;q=∑i=0dλiqi∀1≤i≤d,q∈ΠW(p0,pi)in matrix form, using the equation ofΠW(p0,pi)(   Definition 2):(1…12(q0−p0)t(p1−p0)…2(qd−p0)t(p1−p0)⋮⋮2(q0−p0)t(pd−p0)…2(qd−p0)t(pd−p0))[λ0⋮λd]=[1‖p1−p0‖2+w0−w1‖p2−p0‖2+w0−w2⋮‖pd−p0‖2+w0−wd]or with the notations above:(11…1a1,0a1,1a1,d⋮⋮ad,0ad,1ad,d)︸A[λ0λ1⋮λd]=[1l1⋮ld]+[0−w1+w0−w2+w0⋮−wd+w0]thus we have:Δ[λ0λ1⋮λd]=A−1︸B([1l1⋮ld]+[0−w1+w0⋮−wd+w0])=()=B′([l1⋮ld]+[−w1+w0⋮−wd+w0])+b.□Definition 3The predicatesside1(p0,p1,q)determines the position ofqrelative to the bisectorΠW(p0,p1):side1(p0,p1,q)returns{+1ifdW(q,p0)<dW(q,p1)0ifdW(q,p0)=dW(q,p1)−1ifdW(q,p0)>dW(q,p1).Using the definition ofdW(Definition 1),side1is given byside1(p0,p1,q)=defdw(p1,q)−dw(p0,q)=Sign(‖p1−p0‖2−2(q−p0)t(p1−p0)+w0−w1).Main Term and Simulation of Simplicity forside1(p0,p1,q)•Main term:Sign(l−a),wherea=2(q−p0)t(p1−p0)andl=‖p1−p0‖2Perturbation ofp0:+1Perturbation ofp1:−1Definition 4The predicatessided+1(p0,p1,…,pd+1,q0,q1,…,qd)determines the position ofq=ΠW(p0,p1)∩ΠW(p0,p2)…∩ΠW(p0,pd)∩Δ(q0,…,qd)relative toΠW(p0,pd+1):sided+1(p0,p1,…,pd+1,q0,q1,…,qd)=defside1(p0,pd+1,q)whereq=ΠW(p0,p1)∩ΠW(p0,p2)…∩ΠW(p0,pd)∩Δ(q0,…,qd).Main Term and Simulation of Simplicity forsided+1(p0,…,pd+1,q0,…,qd+1)•Main term:Sign(Δld+1−[ad+1,0…ad+1,d](B′[l1⋮ld]+b))×Sign(Δ)Perturbation ofp0:Sign(−∑i=0d∑j=1dbi,j′ad+1,i+Δ)×Sign(Δ)Perturbation ofpi;1≤i≤d:Sign(∑j=0d(ad+1,jbj,i′))×Sign(Δ)Perturbation ofpd+1:−1where{ai,j1≤i≤d+10≤j≤d=2(qj−p0)t(pi−p0)li1≤i≤d=‖pi−p0‖2;Ad+1×d+1=Δ=|A|;Bd+1×d+1=ΔA−1=()=().ProofTo obtain the expression ofsided+1, we inject the expressionΔ(q−p0)=∑i=0dΔλi(qi−p0)intoside1(p0,pd+1,Δq)×Sign(Δ):sided+1(p0,…,pd+1,q0,…,qd+1)=Sign(Δ‖pd+1−p0‖2︸=defld+1−∑i=0dΔλi2(qi−p0)t(pd+1−p0)︸=defad+1,i+Δ(w0−wd+1))×Sign(Δ)=Sign(Δld+1−∑i=0dΔλiad+1,i+Δ(w0−wd+1))×Sign(Δ)=Sign(Δld+1−[ad+1,0…ad+1,d](B′[l1−w1+w0⋮ld−wd+w0]+b)+Δ(w0−wd+1))×Sign(Δ).Each perturbation associated with eachpiis retrieved as the term that haswias a factor. □I now make a simple observation that proves the robustness of the perturbation, i.e. its ability to escape from any singular configuration:Observation 2There is always at least one term in the Taylor expansion ofsided+1()perturbed bywi=ϵithat is non-zero.ProofThe term associated withpd+1is−Sign(Δ)×Sign(Δ)=−1. □For surfacic meshing, we need the expression ofside1(pointqis directly given),side2(pointqis defined as the intersection between a bisector and a segment) andside3(pointqis defined as the intersection between two bisectors and a triangle). For volumetric meshing, in addition we need the expression ofside4(pointqis defined as the intersection between three bisectors and a tetrahedron).Definition 5The predicateside2(p0,p1,p2,q0,q1)determines the position ofq=ΠW(p0,p1)∩[q0,q1]relative toΠW(p0,p2):side2(p0,p1,p2,q0,q1)=side1(p0,p1,q)whereq=ΠW(p0,p1)∩[q0,q1]Main Term and Simulation of Simplicity forside2(p0,p1,p2,q0,q1)•Main term:Sign(Δl2−[a2,0a2,1][−l1+a1,1l1−a1,0])×Sign(Δ)Perturbation ofp0:Sign(Δ+a2,0−a2,1)×Sign(Δ)Perturbation ofp1:Sign(−a2,0+a2,1)×Sign(Δ)Perturbation ofp2:−1ProofThese expressions are obtained by specializing the definition ofsided+1(Definition 3) withd+1=2. TheAandBmatrices are then as follows:A=(11a1,0a1,1);B=(a1,1−1−a1,01);b=[a1,1−a1,0];B′=(−11).□Definition 6The predicateside3(p0,p1,p2,p3,q0,q1,q2)determines the position ofq=ΠW(p0,p1)∩ΠW(p0,p2)∩Δ(q0,q1,q2)relative toΠW(p0,p3):side3(p0,p1,p2,p3,q0,q1,q2)=side1(p0,p1,q)whereq=ΠW(p0,p1)∩ΠW(p0,p2)∩Δ(q0,q1,q2).Main Term and Simulation of Simplicity forside3(p0,p1,p2,p3,q0,q1,q2)•Main term:Sign(Δl3−[a3,0a3,1a3,2]Δ[λ0λ1λ2])×Sign(Δ)Perturbation ofp0:Sign(Δ−a3,0(b0,1′+b0,2′)−a3,1(b1,1′+b1,2′)−a3,2(b2,1′+b2,2′))×Sign(Δ)Perturbation ofp1:Sign(a3,0b0,1′+a3,1b1,1′+a3,2b2,1′)×Sign(Δ)Perturbation ofp2:Sign(a3,0b0,2′+a3,1b1,2′+a3,2b2,2′)×Sign(Δ)Perturbation ofp3: -1Definition 7The predicateside4(p0,p1,p2,p3,p4,q0,q1,q2,q3)determines the position ofq=ΠW(p0,p1)∩ΠW(p0,p2)∩ΠW(p0,p3)∩Δ(q0,q1,q2,q3)relative toΠW(p0,p4):side3(p0,p1,p2,p3,p4,q0,q1,q2,q3)=side1(p0,p1,q)whereq=ΠW(p0,p1)∩ΠW(p0,p2)∩ΠW(p0,p3)∩Δ(q0,q1,q2,q3).The expression of the main term and perturbations is not given here for keeping the length of the article reasonable. The reader may refer to the companion PCK (Predicate Construction Kit) sourcecode.Note that dimension 3 is a particular case (i.e. the dimension of the ambient space coincides with the dimension of the simplex). In this case, three bisectors in generic position are sufficient to determine a point in3d(the simplex is no-longer needed). Interestingly, computations are much simpler in that case. For this reason, we introduce the following version of the predicate:Definition 8The predicateside43d(p0,p1,p2,p3,p4)determines the position ofq=ΠW(p0,p1)∩ΠW(p0,p2)∩ΠW(p0,p3)relative toΠW(p0,p4):side33d(p0,p1,p2,p3,p4)=side1(p0,p1,q)whereq=ΠW(p0,p1)∩ΠW(p0,p2)∩ΠW(p0,p3)The predicateside43dis equivalent toinsphere. See  [2] for more details. Using similar derivations (based on Kramer’s formula for solving linear systems), we obtain the following:Main Term and Simulation of Simplicity forside43d(p0,p1,p2,p3,p4)•Main term:Sign(Δ)×Sign(|(p1−p0)t−‖p1−p0‖2(p2−p0)t−‖p2−p0‖2(p3−p0)t−‖p3−p0‖2(p4−p0)t−‖p4−p0‖2|)whereΔ=|(p1−p0)t(p2−p0)t(p3−p0)t|Perturbation forp0:Sign(Δ)×Sign(−|(p2−p0)t(p3−p0)t(p4−p0)t|+|(p1−p0)t(p3−p0)t(p4−p0)t|−|(p1−p0)t(p2−p0)t(p4−p0)t|)Perturbation forp1:Sign(Δ)×Sign(|(p2−p0)t(p3−p0)t(p4−p0)t|)Perturbation forp2:−Sign(Δ)×Sign(|(p1−p0)t(p3−p0)t(p4−p0)t|)Perturbation forp3:Sign(Δ)×Sign(|(p1−p0)t(p2−p0)t(p4−p0)t|)Perturbation forp4:−1To test the algorithm, I first tried very degenerate configurations, such as the two ones depicted in Figs. 2 and 3. In the 2D configuration shown in Fig. 2, the Voronoi diagram and the mesh coincide exactly, thus causing singularities everywhere. The symbolic perturbations successfully escape from these singularities (as predicted by Observation 2). The 3D configuration shown in Fig. 3 consists in computing the intersection between the Voronoi diagram of two parallel grids of points and a square equidistant to both grids of points (left), in such a way that many Voronoi facets fall exactly on the square (right).I experimented the algorithm in different application settings, comprising mesh generation with both Voronoi diagrams, Voronoi diagrams with anisotropy, Voronoi diagrams with theLpmetric (for hex-dominant mesh generation).Anisotropic mesh generation: Making the techniques robust to high anisotropy is very important for several simulation techniques, since it allows dramatically reducing the number of mesh elements while preserving the accuracy of the simulation. Fig. 4shows the first results obtained with an anisotropic Voronoi diagram. To my knowledge, this is the first time an Anisotropic Voronoi diagram can be computed in 3d. It uses the idea of replacing anisotropy with a higher-dimensional embedding  [13]. In this specific case, I used an explicit 6d embedding, designed to create the variation of anisotropy shown in the figure. To represent anisotropy, the method uses a fine 1503 grid embedded in 6d space, and the dimension-independent expression of the predicates.hex-dominant meshing: TheLp-CVT algorithm  [14] provides a possible means of generating hex-dominant meshes. However it creates degenerate configuration in the Delaunay triangulation, with many co-spherical vertices, leading to difficulties in the predicates. The symbolic perturbation successfully escapes the singularities (as proved in theory), resulting in an algorithm that is robust in both the surfacic case (Fig. 5) and the volumetric case (Fig. 6). The shown mechanical part is a “crash test” for the algorithm: in addition with the degeneracies caused by Voronoi vertices aligned on a hex grid, it introduces coplanar surfaces and corcircular vertices in the mesh, an interesting benchmark for the predicates.Optimal transport in 3d: Optimal Transport is an active research topic in mathematics  [15]. From a practical point of view, it is a promising way of designing new numerical solution mechanisms for some Partial Derivative Equations. Initially, Optimal Transport studies the following optimization problem, that tries to find the “cheapest” applicationTthat deforms a source measureμonto a target measureν(Monge’s problem):minT∫Ωc(x,T(x))dμsubject to:ν=T♯μwhereμandνare two probability measures onΩand wherec(x,y)is the “transport cost” (e.g.,‖y−x‖2inL2optimal transport) and where the constraintν=T♯μmeans thatT“preserves mass” (Tpushesμontoν). Kantorovich introduces a relaxation of the problem that restores its symmetry and that exhibits some regularity in the dual formulation, thus allowing to study existence and uniqueness, depending on the cost functionc(.,.). The value of the objective function is a distance between measures, called the Wasserstein measureW(μ,ν), that can be used to construct a metric space, thus providing means of interpolating between different measures.In the specific case whereμhas a densityu(i.e.,μ(B)=∫Bu(x)dx) andν=∑i=1kλiδy̱iis a sum of Dirac masses, Aurenhammer et al. remarked that the pre-image of the Dirac masses correspond to a power diagram [16]. The same result can be also directly obtained by specializing Optimal Transport theory (Kantorovich duality) to the semi-discrete case. Interestingly, the derivations of the proof in  [16] can be translated into an algorithm: the weightsW=(wi)1kof the power diagram that determines the optimal transport can be determined as the (unique) maximum of a concave functionf(W). However, the resulting algorithm has a slow speed of convergence. For this reason, Mérigot proposed an algorithm and experimented it in 2d  [17]. To be generalized to the 3d case, the method needs to robustly compute the intersection between a power diagram and a tetrahedral mesh. This can be implemented using my PCK system, as I did in  [18] (see Fig. 7).Compatibility with other programming libraries: The exact precision number type in my PCK system comes with two different APIs: the low-level one, that is most efficient, and the higher-level one, easier to use (but slower), that provides a “number type” expansion_nt with operator overloads (+,-,* and sign computation). We experimenting “grafting” it into CGAL. For standard datasets, difference of timings could not be distinguished, this is because arithmetic filters find the answer in most cases (in general, far less than 1 percent of the calls requires exact precision). To further analyze performance, we compared the performance of the Delaunay triangulation with a degenerate dataset,22with Andreas Fabri, during the 2015 CGAL meeting in Nancy.with many points located on a regular grid, that nearly triggers the exact precision all the time. With CGAL’s default arbitrary precision number type it takes 1.2 s, and with PCK it takes 1.6 s, therefore the price to pay for the additional flexibility of PCK seems to stay reasonable. Moreover, we can probably still gain performance by writing some template specializations that avoid converting between number types and that use the more efficient lower-level API of PCK.Conclusions: Computing the intersection between a 3d Voronoi diagram and a tetrahedral mesh requires some “exotic” predicates. They are not theoretically challenging, but their algebraic expression is quite involved. Transforming these predicates into a practical implementation required to develop some new unconventional software tools (and to use some existing ones). I made the PCK software tools presented here available under the BSD open-source license. The PCK code is fully documented, simple, portable and easy to compile. I think that the methodology presented here can be reused for a wider set of predicates. This leads to several suggestions for future work and open questions:•In its current state, the PCK code generation tool is a set of macros and scripts. It would be possible to write a cleaner (and more powerful) version completely in C++ (as an extension of FPG for instance);Is the code completely correct? It was extensively tested, but testing does not show the absence of bugs (it shows their presence, as it did several times in this specific case!). To gain better certification, is it possible to use formal proof assistant tools? Such tools, such as Coq/Gasper, can analyze numerical code and prove some properties. It is so easy to do errors in this kind of code, that my point of view is that every possible way of certification should be used (experimental, theoretical, automatic formal verification).

@&#CONCLUSIONS@&#
