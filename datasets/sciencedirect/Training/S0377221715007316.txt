@&#MAIN-TITLE@&#
Hybridizing variable neighborhood search with ant colony optimization for solving the single row facility layout problem

@&#HIGHLIGHTS@&#
We develop a hybrid algorithm, based on VNS and ACO.Edit distance measure is used to reduce the solution space.A novel approach for updating pheromone value is presented.New gain techniques are used to reduce the solution time.Extensive computational experiments prove the effectiveness of our approach.

@&#KEYPHRASES@&#
Metaheuristics,Ant colony optimization,Single row facility layout problem,Variable neighborhood search,Evolutionary computations,

@&#ABSTRACT@&#
In this paper, a hybrid algorithm based on variable neighborhood search and ant colony optimization is proposed to solve the single row facility layout problem. In the proposed algorithm, three neighborhood structures are utilized to enhance the exploitation ability. Meanwhile, new gain techniques are developed to reduce the mathematical calculations of the objective function values. Furthermore, ant colony optimization as the shaking step is used to avoid being stuck at the local optima. In addition, a novel pheromone updating rule has been proposed based on both the best and worst solutions of the ants. A reverse criterion based on edit distance measure is applied to help ants to converge to the best solution and reduce the solution space. Finally, numerical simulation is carried out based on the benchmark instances, and the comparisons with some existing algorithms demonstrate the effectiveness of the proposed algorithm.

@&#INTRODUCTION@&#
The single row facility layout problem (SRFLP) is a well-known NP-hard problem with wide engineering backgrounds (Beghin-Picavet & Hansen, 1982). Many practical problems can be formulated as the SRFLP, such as the arrangement of rooms in hospitals, the arrangement of departments in office buildings (Simmons, 1969), the arrangement of books on a shelf in a library, the assignment of disk cylinders to files in computer storage (Picard & Queyranne, 1981), and the arrangement of machines in flexible manufacturing systems (Heragu & Kusiak, 1988).The study of the SRFLP has significant importance both in academic and engineering fields. Early research on the SRFLP mainly focused on the exact solution methods, such as branch and bound algorithm (Simmons, 1969), integer programming (Amaral, 2006, 2008a; Heragu & Kusiak, 1991; Love & Wong, 1976), dynamic programming (Kouvelis & Chiang, 1996; Picard & Queyranne, 1981), cutting planes (Amaral, 2009), polyhedral approach with branch and cut (Amaral & Letchford, 2013), semidefinite programming (Anjos, Kennings, & Vannelli, 2005; Anjos & Vannelli, 2008; Anjos & Yen, 2009; Hungerländer & Rendl, 2013), etc. However, the computational effort and memory requirement are tremendous when using the exact solution methods, so that they are insufficient in solving the large sized instances. In recent years, many heuristic and meta-heuristic algorithms for solving the SRFLP have been proposed. These algorithms include simulated annealing (de Alvarenga & Negreiros-Gomes, 2000; Heragu & Alfa, 1992; Romero & Sánchez-Flores, 1990), tabu search (de Alvarenga & Negreiros-Gomes, 2000; Kothari & Ghosh, 2013b; Samarghandi & Eshghi, 2010), Lin–Kernighan (Kothari & Ghosh, 2013a), ant colony optimization (Solimanpur, Vrat, & Shankar, 2005), scatter search (Kothari & Ghosh, 2014a; Satheesh Kumar, Asokan, Kumanan, et al., 2008), particle swarm optimization (Samarghandi, Taabayan, & Jahantigh, 2010), path relinking (Kothari & Ghosh, 2012a) and genetic algorithm (Datta, Amaral, & Figueira, 2011; Kothari & Ghosh, 2014b; Ozcelik, 2012). More exhaustive surveys of the heuristic algorithms for the SRFLP can be found in Kothari and Ghosh (2012b).Variable neighborhood search (VNS) is a meta-heuristic, whose basic idea consists in a systematic change of neighborhoods combined with local search (Hansen, Mladenović, & Pérez, 2010). VNS has undergone many developments and been applied in numerous fields. In recent years, VNS approaches have received much attention to solve hard combinatorial optimization problems (Bilyk & Mönch, 2012). However, there is very few research work about VNS for solving the SRFLP. With the idea of VNS, Amaral applied a method called enhanced local search (ELS) to the SRFLP (Amaral, 2008b). In ELS, a number of local search procedures were utilized to exploit the potential search space. It is capable of escaping from the local optima. However, the best improvement 2-opt local search was used in ELS. The best improvement is very time consuming, especially as problem sizes increase.Ant colony optimization (ACO) is a recent meta-heuristic approach, which has been widely applied for solving different combinatorial optimization problems. Specifically, ant algorithms have been successfully implemented for solving SRFLP. Solimanpur, Vrat and Shankar developed an ant algorithm for the single row layout problem in flexible manufacturing systems (Solimanpur et al., 2005). Teo and Ponnambalam proposed a hybrid ACO/PSO heuristic to solve SRFLP (Teo & Ponnambalam, 2008). In these two literature, the applications of the ant algorithm can solve SRFLP in a short time. However, they used the local search with single neighborhood structure to improve the quality of solutions. It is easy to get trapped in an undesirable local optimum.To the best of our knowledge, there is almost no research work about an algorithm hybridizing VNS with ACO (VNSACO) for solving the SRFLP. In this paper, we take the characteristic of the SRFLP to propose an effective VNSACO for solving the SRFLP. The intensification of VNS and the diversification of ACO are combined to balance local exploitation and global exploration. To enhance the exploitation ability, three different neighborhood structures are changed in search. To speed up the local search, we apply first improvement to each neighborhood search instead of best improvement. To reduce the time complexity of calculations of the objective function values, new gain techniques are introduced. To avoid getting trapped in local optima, ACO is used as the shaking step.The remainder of the paper is organized as follows: In Section 2, the model of SRFLP is described. An algorithm hybridizing VNS with ACO for the SRFLP is proposed in Section 3. In Section 4, we report the results of our computational experiments on SRFLP benchmark instances and compare them with other algorithms in the literature. Finally we end the paper with some conclusions in Section 5.The single row facility layout problem (SRFLP) is a special case of facility location problems, which belongs to the class of NP-hard combinatorial optimization problems. Suppose there are n facilities to be arranged on a straight line, each facilityx∈F={1,…,n}has a positive integer length lx. An n × n matrixC=[cxy]is given, where cxyis the flow between facilities x and y. When the facilities are arranged in a permutationΠ={π1,…,πn}with zero clearances, the cost can be formulated as follows:(1)z(Π)=∑i=1n−1∑j=i+1ncπiπjdπiπj,wheredπiπj=lπi/2+∑i<k<jlπk+lπj/2is the distance between the centroid of facilities πiand πjin the arranged permutation Π. πiand πjdenote the facilities at the ith and jth positions in Π, respectively. For notational convenience, we use the notations i and j to represent πiand πj, respectively. The aim of SRFLP is to obtain an efficient permutation (solution) such that the cost (objective function value) is minimal.In this section, we propose a VNSACO algorithm for solving the SRFLP. First, we introduce ACO algorithm, state transition rule and pheromone updating rule. Then, we state the local search strategies for three neighborhood structures, and the gain techniques for each local search strategy. Finally, the framework of proposed VNSACO is presented.Ant colony optimization (ACO) was developed based on the nature of ants in seeking foods. During their movement, ants leave pheromone on the trail, and each of them chooses to follow a direction probabilistically based on the amount of pheromone on that trail. If the path is short, the pheromone trail is reinforced quickly. In this way, it is likely that the whole colony converges to the shortest path. The basic idea of ACO is that artificial ants search for good candidate solutions, guided by artificial pheromone. Artificial ants are stochastic solution construction procedures (Korytkowski, Rymaszewski, & Wiśniewski, 2013). The general algorithmic steps of the ACO can be shown in Algorithm 1.Ant chooses a track based on the state transition rule, which is a probability function. In the tth iteration, the probability of choosing facility j to locate at position i for ant k(k=1,2,…,m)is normally given by Eq. (2).(2)Pijk(t)={τijα(t)·ηijβ(t)∑h∈Hτihα(t)·ηihβ(t)ifj∈H0otherwise,where τijis the pheromone intensity on arrangement A(i, j), which locates facility j to position i. ηijis the heuristic information. α and β are parameters which determine the relative influence of the pheromone and heuristic information, respectively. H is the set of unallocated facilities, i.e. the facilities allowed to choose next.Once all of the ants have completed their solutions, the intensity of pheromone on all arrangements is updated by the global pheromone updating rule. The rule is given by the following relations:(3)τij(t+1)=(1−ρ)τij(t)+∑k=1mΔτijk(t),(4)Δτijk(t)={Q−2Q(z(Πk)−z(Πgb))z(Πtw)−z(Πgb)z(Πgb)≤z(Πk)≤z(Πgb)+z(Πtw)2Δτijgb(t)z(Πgb)+z(Πtw)2≤z(Πk)≤z(Πtw)andr<δ0otherwise,whereΔτijk(t)is the pheromone increment that deposited by ant k on A(i, j), andΔτijgb(t)is the pheromone increment that deposited by global best solution. z(Πgb), z(Πtw), z(Πk) denote the cost of the global best solution, the worst solution in that iteration, and ant k solution, respectively. 0 < ρ < 1 is the coefficient of pheromone evaporation, and Q is the maximum pheromone increment deposited by an ant in an iteration. r is a random number between (0, 1), and δ is a probability of updating pheromone increment by global best solution. To avoid from becoming too extreme to explore the solution during the run of the algorithm, the pheromone intensity τijis limited in [τmin, τmax].LetΠ′={πn,…,π1}be the reverse ofΠ={π1,…,πn}. Considering the symmetric characteristic of the SRFLP, permutation Π′ represents the same solution that Π does, while the permutations are different. Therefore, we should reverse one permutation to the other one as unified representation. Otherwise, they will make ants hard to converge to the best solution. We use the concept of edit distance measure to estimate whether a permutation need to be reversed, called reverse criterion. The edit distance between two strings is the minimum cost of transforming one string into the other via a sequence of character deletion, insertion, and replacement operations (Hermelin, Landau, Landau, & Weimanne, 2013). Each of these operations has cost. Given two stringsA=a1a2…aNandB=b1b2…bN,the edit distance between the pair of strings can be calculated by filling in an(N+1)×(N+1)table T, with T[i, j] storing the edit distance betweena1a2…aiandb1b2…bj. According to the formula in Hermelin et al. (2013), we assign a uniform cost of 1 for every operation. So the edit distance between two permutations in SRFLP can be formulated as follows :(5)T[i,j]=min{T[i−1,j]+1T[i,j−1]+1T[i−1,j−1]+{1,ifai≠bj0,ifai=bj.Initially we setT[0,0]=0,T[i,0]=i(i=1,2,…,N),T[0,j]=j(j=1,2,…,N). Then T[N, N] is the edit distance between two permutations. The following reverse criterion is used. When the edit distance between Πkand Πgbis more than⌈n2⌉,we reverse Πk. It helps ants to converge to the best solution and reduce the solution space from n! ton!2.Variable neighborhood search is a meta-heuristic for solving combinatorial optimization problems. Its basic idea is to change neighborhood to search for a better solution. Most often, for SRFLP the following three neighborhood structures are used: insertion-movement, interchange-movement, swap-movement.Due to the exhaustive neighborhood search, the best improvement is very time consuming. To the flow shop problem, the first improvement local search gives significantly better results than the best improvement, in the same amount of allowed computation time (Stüzle, 1998). Therefore, we apply first improvement to each neighborhood search instead of best improvement.Clearly, for a SRFLP instance of size n, O(n2) time will be required to calculate the objective function value by Eq. (1). To reduce the complexity of calculation, a gain technique will be used to each neighborhood search.In the insertion-movement neighborhood, a neighbor of a permutation is obtained by removing the facility at the pth position and inserting it to the qth position, p ≠ q. The description of the first improvement insertion-movement (FIITM) is presented in Algorithm 2. It starts by initializingn×(n−1)numbers of unchosen position pairs as follows: {(1, 2),…,(1, n), (2, 1), (2, 3),…,(2, n),…,(r, s)…,(n−1,n)},where r ≠ s. Then, a position pair is randomly chosen from the unchosen position pairs to obtain a insertion-movement neighbor, and the position pair is subsequently removed from the unchosen position pairs. It is repeated until an improvement solution is found or the number of unchosen position pairs is zero. If an improvement solution is found, the improvement flag isImproved is set to TRUE, otherwise it is set to FALSE. In the worst case, the number of insertion-movement isn×(n−1).To speed up the exploration, the objective function values of the neighbors can be calculated from the current solution by gain. Suppose that a neighbor Π* is obtained by moving the facility from the pth position and inserting it at the qth position in the permutation Π, where p < q. According to Fig. 1, it is possible to partition all facilities in the permutation Π to three distinct sets:Set S1:includes all facilities from position 1 to(p−1)in the permutation Π. The number of the facilities in S1 is denoted by N1, and the sum length of facilities in S1 is denoted by D1, i.e.,D1=∑i∈S1li.includes all facilities from position(p+1)to q in the permutation Π. The number of the facilities in S2 is denoted by N2, and the sum length of facilities in S2 is denoted by D2, i.e.,D2=∑i∈S2li.includes all facilities from position(q+1)to n in the permutation Π. The number of the facilities in S3 is denoted by N3, and the sum length of facilities in S3 is denoted by D3, i.e.,D3=∑i∈S3li.Based on the above classification, the objective function value can be rewritten as the sum of several partial costs:(6)z(Π)=∑i∈S1∑j∈S1,i<jcijdij+∑i∈S1cipdip+∑i∈S1∑j∈S2cijdij+∑i∈S1∑j∈S3cijdij+∑i∈S2cpidpi+∑i∈S3cpidpi+∑i∈S2∑j∈S2,i<jcijdij+∑i∈S2∑j∈S3cijdij+∑i∈S3∑j∈S3,i<jcijdij.Observing Fig. 1, we can find that the distances dijbetween facility pairs (i, j) in {i ∈ S1, j ∈ S1, i < j}, or {i ∈ S1, j ∈ S3}, or {i ∈ S2, j ∈ S2, i < j}, or {i ∈ S3, j ∈ S3, i < j} are not changed in the insertion-movement. So the partial costs∑i∈S1∑j∈S1,i<jcijdij,∑i∈S1∑j∈S3cijdij,∑i∈S2∑j∈S2,i<jcijdij,∑i∈S3∑j∈S3,i<jcijdijdo not need to be recalculated, when calculating the objective function value of Π*. For the other partial costs, based on Fig. 1, we have the following relations:(7)∑i∈S1cipdip*=∑i∈S1cip(dip+D2)=∑i∈S1cipdip+∑i∈S1cipD2.(8)∑i∈S1∑j∈S2cijdij*=∑i∈S1∑j∈S2cij(dij−lp)=∑i∈S1∑j∈S2cijdij−∑i∈S1∑j∈S2cijlp.(9)∑i∈S2cpidpi*=∑i∈S2cpi(D2+lp−dpi)=∑i∈S2cpidpi+∑i∈S2cpi(D2+lp−2dpi).(10)∑i∈S3cpidpi*=∑i∈S3cpi(dpi−D2)=∑i∈S3cpidpi−∑i∈S3cpiD2.(11)∑i∈S2∑j∈S3cijdij*=∑i∈S2∑j∈S3cij(dij+lp)=∑i∈S2∑j∈S3cijdij+∑i∈S2∑j∈S3cijlp.Using Eqs. (7)–(11), the objective function value of the neighbor Π* can be fast calculated by the following formula:(12)z(Π*)=z(Π)+∑i∈S1cipD2−∑i∈S1∑j∈S2cijlp+∑i∈S2cpi(D2+lp−2dpi)−∑i∈S3cpiD2+∑i∈S2∑j∈S3cijlpIf p > q, using the same method presented above, we can deduce the following result:(13)z(Π*)=z(Π)−∑i∈S1cipD2+∑i∈S1∑j∈S2cijlp−∑i∈S2cpi(D2+lp−2dpi)+∑i∈S3cpiD2−∑i∈S2∑j∈S3cijlpIt can be observed that the cost can be calculated inO(N1+N1N2+N2+N3+N2N3)time using Eq. (12) or Eq. (13).N1+N1N2+N2+N3+N2N3<n+N2(N1+N3)<n+N2(n−N2)=−(N2)2+nN2+n≤n24+n. Hence, in the insertion-movement, computing the cost of a neighbor requires less thanO(n24+n)time by our gain technique. The insertion-movement search is time consuming, but performs better than interchange-movement search and swap-movement search (Kothari & Ghosh, 2013a).In the interchange-movement neighborhood, a neighbor of a permutation is obtained by interchanging two facilities placed at the pth and the qth positions. The pseudo code of the first improvement interchange-movement (FIICM) is shown in Algorithm 3. It starts by initializing[(n−1)×n]/2numbers of unchosen position pairs as follows: {(1, 2),…,(1, n), (2, 3),…,(2, n),…,(r, s)…,(n−1,n)},where r < s. Then, a position pair is randomly chosen from the unchosen position pairs to obtain an interchange-movement neighbor, and the position pair is subsequently removed from the unchosen position pairs. It is repeated until an improvement solution is found or the number of unchosen position pairs is zero. If an improvement solution is found, the improvement flag isImproved is set to TRUE, otherwise it is set to FALSE. In the worst case, the number of interchange-movement is[(n−1)×n]/2.The gain technique can be also used to speed up the cost calculations in the interchange-movement neighborhood. The formula is slightly different from that in the insertion movement neighborhood. Suppose that a neighbor Π* is obtained by interchanging two facilities placed at the pth and the qth positions. According to Fig. 2, it is possible to partition all facilities in the permutation Π to three distinct sets:Set S1:includes all facilities from position 1 to(p−1)in the permutation Π. The number of the facilities in S1 is denoted by N1, and the sum length of facilities in S1 is denoted by D1, i.e.,D1=∑i∈S1li.includes all facilities from position(p+1)to(q−1)in the permutation Π. The number of the facilities in S2 is denoted by N2, and the sum length of facilities in S2 is denoted by D2, i.e.,D2=∑i∈S2li.includes all facilities from position(q+1)to n in the permutation Π. The number of the facilities in S3 is denoted by N3, and the sum length of facilities in S3 is denoted by D3, i.e.,D3=∑i∈S3li.Based on the above classification, the objective function value can be rewritten as the sum of several partial costs:(14)z(Π)=∑i∈S1∑j∈S1,i<jcijdij+∑i∈S1cipdip+∑i∈S1∑j∈S2cijdij+∑i∈S1ciqdiq+∑i∈S1∑j∈S3cijdij+∑i∈S2cpidpi+cpqdpq+∑i∈S3cpidpi+∑i∈S2∑j∈S2,i<jcijdij+∑i∈S2ciqdiq+∑i∈S2∑j∈S3cijdij+∑i∈S3cqidqi+∑i∈S3∑j∈S3,i<jcijdij.Observing Fig. 2, we can find that the distances dijbetween facility pairs (i, j) in {i ∈ S1, j ∈ S1, i < j}, or {i ∈ S1, j ∈ S3}, or {i ∈ S2, j ∈ S2, i < j}, or {i ∈ S3, j ∈ S3, i < j} are not changed in the interchange-movement. So partial costs∑i∈S1∑j∈S1,i<jcijdij,∑i∈S1∑j∈S3cijdij,∑i∈S2∑j∈S2,i<jcijdij,∑i∈S3∑j∈S3,i<jcijdijdo not need to be recalculated, when calculating the objective function value of Π*. The distance between facilities p and q is not changed too, therefore cpqdpqdoes not need to be recalculated. For the other partial costs, based on Fig. 2, we have the following relations:(15)∑i∈S1cipdip*=∑i∈S1cip(dip+lq+D2)=∑i∈S1cipdip+∑i∈S1cip(lq+D2).(16)∑i∈S1∑j∈S2cijdij*=∑i∈S1∑j∈S2cij(dij−lp+lq)=∑i∈S1∑j∈S2cijdij+∑i∈S1∑j∈S2cij(lq−lp).(17)∑i∈S1ciqdiq*=∑i∈S1ciq(diq−lp−D2)=∑i∈S1ciqdiq−∑i∈S1ciq(lp+D2).(18)∑i∈S2cpidpi*=∑i∈S2cpi(lp+D2−dpi)=∑i∈S2cpidpi+∑i∈S2cpi(lp+D2−2dpi).(19)∑i∈S3cpidpi*=∑i∈S3cpi(dpi−D2−lq)=∑i∈S3cpidpi−∑i∈S3cpi(D2+lq).(20)∑i∈S2ciqdiq*=∑i∈S2ciq(lq+D2−diq)=∑i∈S2ciqdiq+∑i∈S2ciq(lq+D2−2diq).(21)∑i∈S2∑j∈S3cijdij*=∑i∈S2∑j∈S3cij(dij−lq+lp)=∑i∈S2∑j∈S3cijdij+∑i∈S2∑j∈S3cij(lp−lq).(22)∑i∈S3cqidqi*=∑i∈S3cqi(dqi+D2+lp)=∑i∈S3cqidqi+∑i∈S3cqi(D2+lp).Using Eqs. (15)–(22), the objective function value of the neighbor Π* can be fast calculated by the following formula:(23)z(Π*)=z(Π)+∑i∈S1cip(lq+D2)+∑i∈S1∑j∈S2cij(lq−lp)−∑i∈S1ciq(lp+D2)+∑i∈S2cpi(lp+D2−2dpi)−∑i∈S3cpi(D2+lq)+∑i∈S2ciq(lq+D2−2diq)+∑i∈S2∑j∈S3cij(lp−lq)+∑i∈S3cqi(D2+lp)It can be observed that the cost of a neighbor in the interchange-movement can be calculated less thanO(n24+n)time using Eq. (23).In the swap-movement neighborhood, a neighbor of a permutation is obtained by swapping two neighboring facilities at position p and(p+1). The pseudo-code of first improvement swap-movement (FISM) is given in Algorithm 4. It starts by initializing(n−1)numbers of unchosen positions as follows:{1,…,n−1}. Then, a position is randomly chosen from the unchosen positions to obtain a swap-movement neighbor, and the position is subsequently removed from the unchosen positions. It is repeated until an improvement solution is found or the number of unchosen positions is zero. If an improvement solution is found, the improvement flag isImproved is set to TRUE, otherwise it is set to FALSE. In the worst case, the number of swap-movement is only(n−1).The swap-movement is a special case of the interchange-movement, where S2 is empty in Fig. 2. The objective function value the neighbor Π* can be calculated by the following formula:(24)z(Π*)=z(Π)+∑i∈S1ciplq−∑i∈S1ciqlp−∑i∈S3cpilq+∑i∈S3cqilp=z(Π)+∑i∈S1(ciplq−ciqlp)+∑i∈S3(cqilp−cpilq)=z(Π)+∑i=1p−1(ciplq−ciqlp)+∑i=q+1n(cqilp−cpilq).So in the swap movement, the cost of a neighbor can be calculated in O(n) time using Eq. (24). The quality of the solution obtained by swap-movement is relatively low. But the local search based on swap-movement in solving SRFLP is very fast.With the design above, the procedure of the VNSACO is illustrated in Algorithm 5. We start the algorithm from an initial population with m random permutations. The algorithm then performs iterations consisting of VNS and ACO until the maximum number of global iterations reached. In every iteration, each solution is improved by VNS. The quality of the solution is enhanced by changing three local search methods in the following sequential order: FISM, FIICM, FIITM. If no better solution is found by current local search method, the next local search method is used to continue the search. When a better solution is found by any local search method, we choose the better solution as current solution and restart VNS from FISM to FIITM. If all these three local search methods cannot improve the current solution, VNS for a permutation is end. When all permutations finish VNS, we record the global best solution and use ACO to shake the population. It diversifies the population, and guides to search new promising areas.In summary, local search strategy based on VNS is performed to obtain better solutions. In the stages of evolution, shaking procedure using ACO ensures the diversification of the search. The benefits of the ACO and VNS are combined to balance global exploration and local exploitation.Our algorithm was coded in Microsoft visual C++ and run on a notebook PC equipped with Intel Core i3-2350M 2.30 gigahertz CPU and 4 gigabyte RAM. Our computational study was conducted on 5 sets of widely used benchmark instances.Instance set 1 consists of seven instances collected from different sources. Instances LW5 and LW11 are from Love and Wong (1976), instances S8H, S10 and S11 are from Simmons (1969). For instances H20 and H30, the flow matrices are in Nugent, Vollman, and Ruml (1968) and the lengths of facilities can be obtained from Heragu and Kusiak (1991).Instance set 2 includes the Nugent instances of size n = 25 and n = 30 introduced by Anjos and Vannelli (2008) .Instance set 3 was introduced by Anjos et al. (2005). The 20 Anjos instances are divided to 4 subsets of five instances, each of size 60, 70, 75 and 80, respectively.Instance set 4 was first reported by Anjos and Yen (2009), including 20 sko instances. They are divided to 4 subsets of five instances, each of size 64, 72, 81, and 100.Instance set 5 was proposed by Amaral and Letchford (2013), including three Amaral instances of size 110.The values of parameters in our proposed VNSACO algorithm for SRFLP are presented in Table 1. They are chosen based on some preliminary tests. For the robustness of our method applicability, the parameter settings used here were identical in all experiments. In fact, the performance of our method could be improved even more if parameters were tuned to the specific set of instances.In order to evaluate the performance of the proposed VNSACO heuristic, we compare the results with two existing ACO-based algorithms, an ant algorithm proposed by Solimanpur et al. (2005) and a hybrid ACO/PSO heuristic proposed by Teo and Ponnambalam (2008). These two algorithms are the newest ACO-based algorithms we can find for SRFLP. Table 2shows the detailed results obtained by three algorithms. Columns 1 and 2 indicate the name of the instance and the size of facilities. Column ‘Best OFV’ indicates the best objective function value of each algorithm. Column ‘Time’ reports the CPU time computation required in seconds.Table 2 shows the proposed VNSACO is able to achieve the best solutions so far reported, except for instance H30. For instance H30, the best solution obtained by an ant algorithm (Solimanpur et al., 2005) is extremely low compared to the other methods. It may be a typo error (Teo & Ponnambalam, 2008). As seen in this table, the proposed VNSACO can obtain the best solution in a high speed, specially for the larger instances H20 and H30. With the problem size increased, the computation times of the compared algorithms increase more rapidly than ours. It is worth noting that if the number of ants m was set to the half of the size of the instance, the time will be much less within the same result. The time will be reduced to 0.00, 0.01, 0.02, 0.03, 0.02, 0.17 and 0.73 seconds in instances LW5, S8H, S10, S11, H20 and H30, respectively. Therefore, our algorithm VNSACO performs better than the previously known ACO-based algorithms.We then compared VNSACO with a VNS-based algorithm (ELS) proposed by Amaral (2008b) for SRFLP. For comparison, the same test instances used in Amaral (2008b) were adopted here. Computational tests were carried out with the instance set 2. Each instance was solved 10 times. In these 10 runs, we kept track of the best objective function value (Best OFV), average CPU time and the number of repeat with best solution (NRB). Computational results are given in Table 3. From Table 3, it can be observed that ELS got optimal solutions for 4 out of 10 instances in all 10 runs, and VNSACO got optimal solutions for all 10 instances in all 10 runs. This can be used to conclude that VNSACO obtained better results than ELS. The average CPU time value of VNSACO is much smaller than that of ELS. These mean that VNSACO has a better performance than ELS.We also compared VNSACO with other three metaheuristics recently published, i.e., hybrid genetic algorithm (HGA) proposed by Ozcelik (2012), tabu search using exhaustive insertion neighborhood (TSINSERT) proposed by Kothari and Ghosh (2013b) and an efficient genetic algorithm (GENALGO) proposed by Kothari and Ghosh (2014b). Since heuristic is stochastic, the consistency of the output should be also considered to evaluate the quality of solutions besides the best value. These three literature ran the corresponding algorithm several times, then reported the average OFV and the number of the replications in which the best solution was found. Moreover, HGA and GENALGO are competitive with other algorithms known in the literature on the quality of solutions and execution time, respectively. Different algorithms compared in this section were run at different computers. We apply scale factor (Mladenovic, Urosevic, Pérez-Brito, et al., 2010) to deal with this problem, according to the CPU speed data from http://www.cpubenchmark.net (Kothari & Ghosh, 2014b). Running times reported in the papers should be multiplied by the corresponding factor in Table 4. Due to the incomplete and nondeterministic nature of the metaheuristic, we ran the implementation 20 times for each instance and reported the results.We compared our best OFV with those obtained by HGA, TSINSERT and GENALGO for Anjos instances in Table 5. The instance name and the number of facilities are specified in columns 1 and 2, respectively. In column 3, the optimum value known in the literature for each instance is given. The last four columns report the best OFV for these instances obtained by four algorithms. The value marked in boldface indicates the previous best known solution. The superscript ‘a’ indicates the optimum value reported in Ozcelik (2012). The consistency of the results that four algorithms output during multiple runs on the Anjos instances set is shown in Table 6. Column ‘NRB’ (stands for number of repeat with best solution) is the number of runs in which the best solution is found. Column ‘Average OFV’ specifies the average objective function value for each instance. The value marked in boldface indicates the average OFV is the best, and the mark ‘*’ indicates the best solution is found in all runs. The comparison of average CPU time for each algorithm is shown in Table 7. The first two columns in the table present details about the instances, and the last four columns present average CPU times required by four algorithms. The last row of the table is simply the averages of the average CPU times reported in each column. The mark ‘–’ means that the experimental result is not reported.From Table 5, we see that all algorithms are able to find the optimal solution for all 20 Anjos instances. The results in Table 6 allow us to compare four algorithms in more detail. For VNSACO, there are 16 instances in which the optimal solution is found in all runs. Whereas, for TSINSERT and HGA there are 0 and 10 those instances, respectively. This means that our proposed algorithm encounters the best solution over all runs much more frequently than HGA and TSINSERT. Compared with HGA, VNSACO is able to obtain lower average OFV in 8 instances and higher average OFV in 2 instances. Compared with GENALGO, VNSACO is able to obtain lower average OFV in 18 instances and higher average OFV in zero instance. Thus, VNSACO has a higher chance of obtaining a solution close to the best in a particular run than HGA and GENALGO.As we see in Table 7, the average execution time of our proposed VNSACO (38.99 seconds) is less than those of HGA (77.65 seconds × 0.65 = 50.47 seconds), TSINSERT (18.82 seconds × 2.4 = 45.16 seconds) and GENALGO (21.52 seconds × 2.4 = 51.64 seconds). It is clear that VNSACO is faster than HGA, TSINSERT and GENALGO.In Table 8–10, we present the comparisons of best OFV, consistency of the results and average CPU time for sko instances, respectively. The structures of Table 8–10 are similar to those of Table 5–7, respectively. The superscripts ‘b’ and ‘c’ indicate the optimum value reported in Kothari and Ghosh (2014b, 2014a). Table 8 shows that both GENALGO and VNSACO found the optimal solution for 19 out of 20 sko instances, while TSINSERT found the optimal solution for 2 out of 20 sko instances. It means that VNSACO obtains better results than TSINSERT. For the five sko instances of size 100, the best solutions obtained by HGA are the same with VNSACO. As it can be seen from Table 9, in 16 out of 20 sko instances, algorithm VNSACO is able to obtain lower average OFV than GENALGO. The result shows that, compared with GENALGO, VNSACO is competitive in terms of average solution quality. As for the computation time, it can be seen from Table 10 that, on the average, the execution time of VNSACO (84.43 seconds) for all sko instances is less than the time of GENALGO (40.49 seconds × 2.4 = 97.17 seconds) and more than the time of TSINSERT (28.23 seconds × 2.4 = 67.75 seconds). The execution time of VNSACO is much less than HGA for each instance of size 100. Therefore, VNSACO is faster than GENALGO and HGA, and marginally slower than TSINSERT in this instances set.In Tables 11–13, we present the comparisons of best OFV, consistency of the results and average CPU time for Amaral instances, respectively. The structures of Tables 11–13 are similar to those of Tables 5–7, respectively. We can see from Table 11 that both HGA and VNSACO are able to output the best known solutions for all Amaral instances of size 110, while TSINSERT cannot find the optimal solution for these instances and GENALGO find the optimal solution for 1 out of 3 Amaral instances. Thus, VNSACO performs better solution quality than TSINSERT and GENALGO. In 2 of the 3 Amaral instances, the average OFV is lower for VNSACO than HGA (see Table 12). It is clear that the performance of VNSACO is slightly better than HGA. It can be seen from Table 13 that, the average execution time of VNSACO (330.32 seconds) for all Amaral instances is more less than those of HGA (4913.00 seconds × 0.65 = 3193.45 seconds), TSINSERT (9450.00 seconds × 2.4 = 22,680.00 seconds) and GENALGO (167.41 seconds × 2.4 = 401.78 seconds). Therefore, algorithm VNSACO is significantly faster than other algorithms.Based on results from our computational experiments, we conclude that the proposed algorithm VNSACO presented in this paper is competitive for solving large size SRFLP instances, especially for Amaral instances.

@&#CONCLUSIONS@&#
In this paper, we have presented a approach hybridizing variable neighborhood search with ant colony optimization for solving the single row facility layout problem. The intensification of VNS aims at searching for better solutions.The diversification of ACO is responsible for escaping from the current local optimum and moving towards new unexplored areas of the search space. In particular, the following enhancements and modifications are implemented:•new formulas for fast calculations of the objective function values in different neighborhoods;novel pheromone updating rule based on both the best and worst solutions of the ants;reverse criterion based on edit distance measure for helping the convergence and reducing the solution space;fast local search using first improvement in random search.The performance of the proposed algorithm has been tested on 60 well known benchmark instances with up to 110 facilities. Computational experiments have shown that the performance of VNSACO dominates the existing VNS-based and ACO-based algorithms for SRFLP. In terms of solution quality and execution time both, our VNSACO outperforms other state-of-the-art algorithms, including HGA and GENALGO which are competitive with other algorithms known in the literature on the quality of solutions and execution time, respectively. It is worth noting that the parameter settings used here were identical in all tests. The performance of this method could be improved even more if parameters were tuned to the specific set of instances.From our computational experiments it is clear that the VNSACO algorithm is competitive for solving SRFLP instances. From the findings in this paper, we expect the VNSACO to show great potential for other facility location problems or NP-hard combinatorial optimization problems.