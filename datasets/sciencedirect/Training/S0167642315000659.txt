@&#MAIN-TITLE@&#
Adaptability checking in complex systems

@&#HIGHLIGHTS@&#
Hierarchical model for multi-level adaptive systems.Relational characterisation of strong and weak adaptability.Adaptability checking is reduced to a CTL model checking problem.Application to the case study of ATVs motion control.

@&#KEYPHRASES@&#
Adaptive systems,State machine,Adaptability relations,Adaptability checking,S[B] model,

@&#ABSTRACT@&#
A hierarchical approach for modelling the adaptability features of complex systems is introduced. It is based on a structural level S, describing the adaptation dynamics of the system, and a behavioural level B accounting for the description of the admissible dynamics of the system. Moreover, a unified system, calledS[B], is defined by coupling S and B. The adaptation semantics is such that the S level imposes structural constraints on the B level, which has to adapt whenever it no longer can satisfy them. In this context, we introduce weak and strong adaptability, i.e. the ability of a system to adapt for some evolution paths or for all possible evolutions, respectively. We provide a relational characterisation for these two notions and we show that adaptability checking, i.e. deciding if a system is weakly or strongly adaptable, can be reduced to a CTL model checking problem. We apply the model and the theoretical results to the case study of a motion controller of autonomous transport vehicles.

@&#INTRODUCTION@&#
Self-adaptive systems are particular systems able to modify their own behaviour according to their current configuration and the perception of the environment in which they operate. They develop new strategies in order to fulfil an objective, properly respond to changes of the environmental conditions or, more generally, maintain desired conditions.From a broad viewpoint, self-adaptiveness is an intrinsic property of complex natural systems. Self-adaptation is a process driving both the evolution and the development of living organisms that adapt their features and change their phenotype in order to survive to the current habitat, to achieve higher levels of fitness and to appropriately react to external stimuli.Nowadays, software systems are increasingly resembling complex systems; this motivates the development of methods for enabling software self-adaptiveness. Similarly to natural systems, “Self-adaptive software evaluates its own behaviour and changes behaviour when the evaluation indicates that it is not accomplishing what the software is intended to do, or when better functionality or performance is possible”[35]. Self-adaptive software finds application in fields like autonomic computing, service-oriented architectures, pervasive service ecosystems, mobile networks, multi-agent systems, and ultra-large-scale software systems [25], characterised by distributed, autonomous, interacting, heterogeneous, conflicting and evolvable sub-systems.In this work, we develop a formal hierarchical model for self-adaptive systems, where two fundamental levels are defined: the behavioural level B, which describes the admissible dynamics of the system; and the structural level S, accounting for the invariant features of the system that regulate the behaviour of the system. More precisely, both levels are modelled as state machines, but each state of the S level is associated with a set of constraints, i.e. logical formulas over observable variables of the B level.An S state in the structural level represents a relatively persistent situation, a steady region for the B level, identified by the set of B states satisfying the constraints. Therefore S is a higher order structure whose states can be interpreted as sets of B states, and whose transitions can be viewed as mappings among sets of B states. The coupled model will be referred to asS[B], in order to highlight the two basic levels that compose the system.TheS[B]model is broadly inspired by a previous work of some of the authors, a spatial bio-inspired process algebra called Shape Calculus[3,4], where processes are characterised by a reactive behaviour B and by a shape S that imposes a set of geometrical constraints on their interactions and occupancy in the three-dimensional Euclidean space. Here, instead, the computational approach is shifted in a more general context, where S and B are coupled by a hierarchical relation defined on the structural constraints of the S level and the state space of the B level.The adaptation semantics can be briefly described as follows. Consider anS[B]system, let q be the current state of B and assume that it satisfies the constraints of the current S state. The adaptation is triggered whenever q cannot evolve because there is no next B state that satisfies the current S constraints. During adaptation, theS[B]system attempts to evolve towards a new B state that satisfies a new S state, chosen among the successors of the current one. In this phase B is no more constrained by S. Adaptation terminates successfully when B ends up in a state that fulfils the new global situation represented by one of the admissible S states.A first general introduction of theS[B]model was given in [38] and [39] by the authors. In this work, we provide several novelties and improvements, most of them devoted to the adaptability checking problem, i.e. the automatic checking of the adaptation capabilities of a givenS[B]system. In particular, we define the notion of weak adaptability, possessed by anS[B]system that is able to adapt along some of all its possible evolution paths. Strong adaptability requires that theS[B]system is able to adapt along all its possible evolution paths. We formulate the notions of weak and strong adaptability as relations between the states of B and S and also in logical form, as Computation Tree Logic (CTL) formulas over the given semantics of anS[B]system. Then, we formally prove the equivalence between the relational and the logical formulation of strong and weak adaptability (Theorems 1 and 2), showing that the adaptability checking problem can be reduced to a classical model checking problem. We also discuss the computational complexity of our approach. The effectiveness of theS[B]approach for self-adaptive systems is demonstrated using a case study in the context of adaptive software systems, a model for a motion controller of autonomous transport vehicles in a smart airport. The same case study is used for exemplifying the notions of weak and strong adaptability and the adaptability checking problem.The paper is organised as follows. Section 2 introduces the formalism and the syntax of theS[B]model. Section 3 illustrates the application of the model to the example of adaptive motion controller. In Section 4 we give the operational semantics of anS[B]system by means of a flattened transition system. In Section 5 we formalise the relations of weak and strong adaptation, which we equivalently characterise as CTL formulas in Section 6. Related works including adaptation features ofS[B], and conclusions are given in Section 7. Finally, proofs are presented in Appendix A.In theS[B]approach, a model encapsulates both the behavioural (B) and the structural (S) level of an adaptive system. The behavioural level is classically described as a finite state machine of the formB=(Q,q0,→B)where Q is a set of B states,q0initial B state and→Btransition relation. The structural level is modelled as a finite state machineS=(R,r0,O,→S,L)where R is a set of S states,r0is the initial S state,Ois an observation function,→Sis a transition relation and L is a state labelling function. The function L labels each S state with a formula representing a set of constraints over an observation of the B states. Therefore an S state r can be directly mapped to the set of B states satisfyingL(r). Through this mapping, S can be viewed as a second-order structureS=(R⊆2Q,r0,O,→S⊆R×R)where each S state r is identified with its corresponding set of B states. AnS[B]system is the result of coupling the two levels S and B through the observation functionOand an evaluation function[[⋅]], that maps each S state to the set of B states meeting the constraints.TheS[B]adaptation is achieved by switching from an S state to another S state where a different set of constraints holds. During adaptation the B machine is no more regulated by the structural level, except for an adaptation invariant, called adaptation invariant, that must be fulfilled by the system while adapting. The system adapts by following any trajectory that is present at the B level that does not violate the invariant condition, which can be used as a safety condition if some activities of the B level must be avoided during adaptation.In order to realise our notion ofS[B]adaptiveness, there must be some information flowing both from B to S and vice versa. In particular, the information from B to S is modelled here as a set of variablesA={a1,…,an}called observables of the S on the B level. The values of these variables must always be derivable from the information contained in the B states. This makes our approach black-box-oriented, that is to say, S has not the full knowledge of B, but only some derived information.In control-theoretic terms, as illustrated in Fig. 1, the adaptation model of anS[B]system can be viewed as a closed-loop system where B is the plant and S is the controller. Let q and r be the current states of B and S. B outputs the vector11With abuse of notation, we allow the Post operator to return an indexed vector of states instead of a set.B=Post(q)of the states reachable from q with a single transition, i.e. an elementqiof B is such thatq→Bqiand each state is unique:⋀i≠jqi≠qj. Since S can only observe some features of B states, the observerOwill provide S with a vector of observations made over the values of the variables characterising each state in B:o=∏iO(qi).S will check the observables provided by o with respect to its current state r. If its constraints are satisfied, S will remain in the same state andS[B]will proceed in steady mode. Otherwise, S will perform a transition to a new r state forcing theS[B]system to enter an adaptation mode. Here we assume that the updated r is computed with a function Check that takes the current S state and observations. The feedback loop closes with the selection of the eligible next states B outputted to B, i.e. those states that satisfy the current constraints of r or those that satisfy the current adaptation invariant. The set B is obtained by applying the evaluation function[[⋅]]to either the constraints of r or the invariant. In the adaptation mode the output is calculated using the whole B machine without constraints except the adaptation invariant, to make B free to explore the state space. In turn, B updates its current state q by selecting one of the eligible states provided in B. The concepts of observation functionOand evaluation function[[⋅]]are formalised in Definition 1 and Definition 2.The constraints characterising the states of an S level are expressed using formulas of a many-sorted first order logic. More precisely, the definition of an S level includes the definition of a many-sorted signature Σ containing some function symbols, some predicate symbols and some sortsD1,…,Dk. Σ-terms and Σ-formulas are constructed in the standard way [24]. In addition, a particular set of sorted variables, which we call observables, must be fixed. Such a set is of the formA={a1:Dj1,…,an:Djn}, whereji∈{1,…,k}for alli=1,…,n. Then, constraints can be expressed as Σ-formulas ψ such that the variables that occur free in ψ, denoted byfree(ψ), are a (possibly empty) subset of A. This set will be denoted byΨ(Σ,A)={ψ|ψis aΣ-formula∧free(ψ)⊆A}.We also impose that a particular structure M is fixed for the evaluation of Σ-formulas. M consists of k non-empty domainsM(D1),…,M(Dk), as carrier sets for sorts, together with interpretations for all function and predicate symbols of Σ. To obtain the full semantic evaluation of formulas inΨ(Σ,A)we will take the values for the free variables in A from an observation function.Definition 1Observation functionLetQbe the universe set of all states of machines possibly representing B levels. Let Σ be a many-sorted signature, letA={a1:Dj1,…,an:Djn}be a set of observables and let M be a structure for the evaluation of Σ-formulas. An observation functionOMΣ,Aon Σ, A and M is a partial functionOMΣ,A:Q↪(A→D)where (i)D=⋃i=1nM(Dji)and (ii) for any stateq∈Q, ifOMΣ,A(q)≠⊥thenOMΣ,A(q)(ai:Dji)∈M(Dji), for alli=1,…,n. For a lighter notation, we will useOinstead ofOMΣ,AwhenΣ,Aand M are clear from the context.Note that the use of the universe of states as domain makes the definition of the observation function independent from a particular state machine representing a behavioural level B. Note also that we do not require the observation function to be injective. This means that some different states can give the same values to the observables. In this case, the difference among the states is not visible to S through the observation, but it is internal to B.To complete the machinery for checking whether a set of constraints is satisfied or not, we define the satisfaction relation in the natural way.Definition 2Satisfaction relationLetOMΣ,Abe an observation function. A stateq∈Qsatisfies a formulaψ∈Ψ(Σ,A), writtenq⊨ψ, iffOMΣ,A(q)≠⊥and ψ is true, according to the standard semantics of many-sorted first order logic, with respect to the structure M and by substituting in ψ every occurrence of the free sorted variableai:DjiwithOMΣ,A(q)(ai:Dji).We also define an evaluation function[[⋅]]:Ψ(Σ,A)→2Qmapping a formulaψ∈Ψ(Σ,A)to the set of states[[ψ]]={q∈Q|q⊨ψ}, i.e. those satisfying ψ.A set of constraints is formally expressed by a formulaψ∈Ψ(Σ,A)that is the conjunction of all the formulas representing each constraint in the set. The set of constraints is satisfied if and only if the corresponding formula is true in the fixed structure M and observationOMΣ,A.Example 1Let us consider a set of observables and associated sorts:A={velocity:R,congestion:B}Consider also a signatureΣ={R,B,==,>,<,0,5}whereRandBare the sorts indicating the domains of real numbers and boolean, respectively; == is the equality predicate interpreted as the identity relation in each domain; > and < are the usual greater-than and less-than predicates overR; and the constants 0 and 5 are the real numbers 0 and 5. A possible formula ψ in the languageΨ(Σ,A)iscongestion⟹velocity<5∧¬congestion⟹velocity>0whose satisfaction depends on the particular values of the variables, which will be different in different states.In the context of Autonomous Transport Vehicles (see Section 3), this formula can be thought to represent a set of two constraints, one imposing that “in case of congestion, the velocity of the vehicle must be lower than 5” and the other that “in normal traffic conditions, the velocity must be greater than 0”.Let us now formally define the behavioural level B and the structural level S separately. Afterwards, theS[B]model is defined as the combination of the two.Definition 3Behavioural levelThe behavioural level of a system is a tupleB=(Q,q0,→B), where•Q⊆Qis a finite set of states andq0∈Qis the initial state; and→B⊆Q×Qis the transition relation.Definition 4Structural levelThe structural level of a system is a tupleS=(R,r0,OMΣ,A,→S,L), where•R is a finite set of states andr0∈Ris the initial state;OMΣ,Ais an observation function on a signature Σ, a set of observables A and a structure M;→S⊆R×Ψ(Σ,A)×Ris a finite transition relation, labelled with a formula called invariant; andL:R→Ψ(Σ,A)is a function labelling each state with a formula representing a set of constraints.Let us now give an intuition of the adaptation semantics. Let the current S state beriand supposeri→ψSrjfor somerj. Assume that the behaviour is in a steady state (i.e. not adapting)qiand thereforeqi⊨L(ri). If the B state can move, but all B transitionsqi→Bqjare such thatqj⊭L(ri), then the system can start adapting to the target S staterj. In this phase, the B level is no more constrained, but during adaptation the invariant ψ must be met. Adaptation ends when the behaviour reaches a stateqksuch thatqk⊨L(rj).We want to remark that the model supports the non-deterministic choice between adaptations, i.e. the system can adapt to every target staterjreachable with a transitionri→ψSrjfrom the currentristate. The non-determinism can be both external—that is different target states can be reached by satisfying different invariants—and internal—that is different target states can be reached satisfying the same invariant condition.Definition 5S[B]systemAnS[B]system is the combination of a behavioural levelB=(Q,q0,→B)and a structural levelS=(R,r0,OMΣ,A,→S,L)such that for allq∈Q,OMΣ,A(q)≠⊥. Moreover, in anyS[B]system the initial B state must satisfy the constraints of the initial S state, i.e.q0⊨L(r0).In this section, we illustrate the features of our approach by means of an example adapted from [29]: a model of a motion controller of Autonomous Transport Vehicles (ATVs) in a smart airport.ATVs are responsible for the transport of passengers between stopovers like passenger entrances, check-in desks, departure gates, and plane parking positions. In the airport there are two types of roads that the ATVs can use: main roads and secondary roads, the latter ones used during traffic peaks. ATVs can travel at different speed in any road, preferably not at the maximum speed on secondary roads, as they are narrower than the main ones. For simplicity, we model only the subcomponent of ATVs that controls the vehicle speed and the switching between main and secondary roads. TheS[B]approach will be used to specify and implement the adaptation features of this controller in case of traffic congestion or blockages.The behavioural level describes all the capabilities of the ATV controller, i.e. all the actions that the system is able to do in an unconstrained scenario. We suppose that each ATV controller has the possibility to perceive the current situation of traffic congestion or blockage by using a sensor or by communicating with a global monitoring systems of the airport. The ATV controller may, based on this perception, decide which action to execute.The usual way of abstractly specifying a behaviour of this kind is a two-phase cycle: in the first phase there is the perception of the global environment, only relatively to the current congestion situation; in the second phase, a local action can be executed, corresponding to change either the vehicle velocity or the road to drive.To formalise the behavioural level B we consider the following set of observable variables and associated sorts:•r:{M(main),S(secondary)}, the current road;v:{0(slow),1(medium),2(high)}, the current velocity of the vehicle;c:{true(congestion),false(no congestion)}, a boolean variable indicating the current knowledge of the ATV controller about the traffic congestion;p:{true(perception),false(no perception)}, a boolean variable indicating whether or not the ATV controller is currently perceiving the congestion situation, i.e. it is in the first phase of its cycle; anda:{true(action),false(no action)}, a boolean variable indicating whether or not the ATV controller is currently executing an action, i.e. it is in the second phase of its cycle.Fig. 2contains a schema representing the portion of the state machine, corresponding to the B level, starting from a generic state(r,v,c,0,0), i.e. a state in which the controller is at the beginning of one iteration of its cycle. The two outgoing transitions non-deterministically model the perception of the same congestion situation known at the last perception (state(r,v,c,1,0)) or of the new (negated) situation (state(r,v,¬c,1,0)). In any case, the system proceeds to the action phase (states(r,v,c,0,1)or(r,v,¬c,0,1)) where it can decide to change road or to change velocity ending up in an updated state, ready to start another perception–action iteration.The structural level can be used to give an abstract, constraint-based, specification of the possible ways (the various states in S) in which the system can function together with the admissible adaptations among them (the transitions in S). In this case study we show how to implement, as anS[B]system, a policy of the smart airport that requires the adaptation of the behaviours of the vehicles during their functioning. We assume that some of the ATVs in the airport are equipped with adaptability capabilities in order to implement, as an example, the following policy: “whenever there is congestion, the adaptive ATV will have to switch as soon as possible to a secondary road and to limit the velocity to the maximum value 1; on the contrary, whenever there is not congestion, the adaptive ATV will have to use a main road at any velocity”.This policy clearly identifies two modes of operations of the adaptive ATVs, which are activated by different environmental conditions:•a normal mode of operation, occurring when there is no traffic congestion and such that the main road is driven (r==M); anda fallback mode, occurring when congestion occurs; in this case the ATV has to be in the secondary road (r==S) and it cannot drive at the maximum velocity (v is either 0 or 1).The invariant conditions on the transitions betweenr0andr1are needed to avoid the perception of a value of c different from that of the mode to which the system is adapting to. For instance, when adapting fromr0tor1the target steady state is one in which there is congestion. During the adaptation we need to ensure that, whenever there is perception, only the value c can be perceived, ruling out the other possibility (due to non-determinism) of perceiving ¬c. This is expressed by the invariant(p∧c)∨¬pthat, in fact, corresponds to forcing theS[B]system to ignore possible changes in the environment during adaptation. Without these invariants (see Fig. 3(b)), the system could fall in a livelock during the adaptation phase, as it is shown in Section 5.1.Fig. 4shows the full B level where the blue box encloses the states satisfying the constraints ofr0, and the red box those satisfying the constraints ofr1.We give the operational semantics of anS[B]system as a transition system resulting from the flattening of the behavioural and the structural levels. We obtain a Labelled Transition System (LTS) over states of the form(q,r,ρ), where:•q∈Qandr∈Rare the active B state and S state, respectively; andρ keeps the target S state that must be reached during adaptation and the invariant that must be fulfilled during this phase. Therefore ρ is either empty (no adaptation is occurring), or a singleton{(ψ,r′)}, withψ∈Ψ(Σ,A)a formula andr′∈Ran S state.Consider anS[B]system. The corresponding flatS[B]system is the LTSF(S[B])=(F,f0,→r∪→r,ψ,r′)where•F=Q×R×({(ψ,r′)|∃r∈R.r→ψSr′}∪{∅})is the set of states;f0=(q0,r0,∅)is the initial state;→r⊆F×F, withr∈R, is a family of transition relations between non-adapting states, i.e., both satisfyingL(r);→r,ψ,r′⊆F×F, withr,r′∈Randψ∈Ψ(Σ,A), is a family of transition relations between adapting states, where the adaptation is determined by the S transitionr→ψSr′; andthe pairs in→rand in→r,ψ,r′are all and only those derivable using the rules in Table 1.Let us discuss the rules listed in Table 1 characterising the flattened transitional semantics:•Rule Steady describes the steady (i.e. non-adapting) behaviour of the system. If the system is not adapting and a B state q can perform a transition to aq′that satisfies the current constraintsL(r), then the flat system can perform a non-adapting transition→rof the form(q,r,∅)→r(q′,r,∅).Rule AdaptStart regulates the starting of an adaptation phase.Adaptation occurs when all of the next B states do not satisfy the current S state constraints—i.e.∀q″.(q→Bq″⟹q″⊭L(r))—and the B machine is not itself deadlocked (q→Bq′). In this case, for each S transitionr→ψSr′an adaptation towards the target stater′, under the invariant ψ, can start. The flat system performs an adapting transition→r,ψ,r′of the form(q,r,∅)→r,ψ,r′(q′,r,{(ψ,r′)}).Rule Adapt can be used only during an adaptation phase. It handles the case in which, after the current transition, the system keeps adapting because a steady configuration cannot be reached (∀q″.(q→Bq″⟹q″⊭L(r′))). In this situation, since the system still must adapt (q⊭L(r′)), if the B machine is not deadlocked and the invariant can still be satisfied (q→Bq′andq′⊨ψ), the rule allows a transition of the form(q,r,{(ψ,r′)})→r,ψ,r′(q′,r,{(ψ,r′)}). Note that during adaptation the behaviour is not regulated by the S states constraints. Note also that the semantics does not assure that a state where the target S state constraints hold is eventually reached. Two different formulations of such adaptability requirements are given in Section 5.Also rule AdaptEnd can only be applied during an adaptation phase and it handles the case in which, after the current transition, the adaptation must end because a steady configuration has been reached (q′⊨L(r′)). It allows a transition→r,ψ,r′from an adapting state(q,r,{(ψ,r′)})to the steady (non-adapting) state(q′,r′,∅).Rule AdaptStartEnd handles the special case in which an adaptation phase must start from a steady situation—∀q″.(q→Bq″⟹q″⊭L(r)—but then, after just one move of the B level, another steady region of the S level is reached (q′⊨L(r′)). In this case the invariant ψ associated to the S transition is ignored and the system goes directly into another steady state. Note that this rule is alternative to the rule AdaptStart in which the initial situation is the same, but the steady region is not reached after one B transition. The flat system performs an adapting transition→r,ψ,r′of the form(q,r,∅)→r,ψ,r′(q′,r,′∅).Therefore, a successful adaptation occurs when rules AdaptEnd or AdaptStartEnd can be applied, i.e. when a transition from an adapting to a steady state is fired.Let us now state some properties of the given flat semantics. In the following, given any transition relation → and any state s, by s→ and by s↛ we mean, as usual, that there exists a states′such thats→s′and that there exists no states′such thats→s′, respectively. Moreover, by→+we indicate a finite, non-empty, sequence of → steps; more formally, there existsn∈N,n>0such thats=s0→s1→⋯sn−1→sn. Finally, by→k,k≥0, we indicate k consecutive steps of the relation →:s=s0→s1→⋯sk−1→sk. Ifk=0, thens→0s′is equivalent to say that there is the empty sequence of steps s, and thuss′=s. This is always possible, even if the relation → is not reflexive.Proposition 1Properties of flat semanticsLetF(S[B])=(F,f0,→r∪→r,ψ,r′)be a flatS[B]system. All the following statements hold:(i)If a steady transition can be performed, then adaptation cannot start:If adaptation can start, then no steady transition is possible:During adaptation no steady transition is possible:The non-adapting and the adapting transition relations are disjoint:∀r,r′∈R,∀ψ∈Ψ(Σ,A).→r∩→r,ψ,r′=∅In case of a successful adaptation, the adaptation phase ends as soon as possible, i.e. as soon as the target steady state can be reached with a single transition.Given anyq∈Qandr∈R, then every infinite path π inF(S[B])starting in a state(q,r,∅)such thatq⊨L(r)is of one of the following kinds:(1)adaptation always succeeds; the path alternates between steady transitions and adaptation paths:π=(q=q0,r=r0,∅)(→r0)m0(→r0,ψ0,r1)n0⋯⋯(qi,ri,∅)(→ri)mi(→ri,ψi,ri+1)ni(qi+1,ri+1,∅)⋯such that for eachi≥0, eithermi=1∧ni=0(steady transition) ormi=0∧ni>0(adaptation path);adaptation lasts forever; the path has a prefix in which steady transitions and adaptation paths alternate, but then one adaptation path never stops:π=(q=q0,r=r0,∅)(→r0)m0(→r0,ψ0,r1)n0⋯⋯(qi,ri,∅)(→ri)mi(→ri,ψi,ri+1)ni(qi+1,ri+1,∅)⋯⋯(qk,rk,∅)→rk,ψk,rk+1(qk+1,rk,{ψk,rk+1})⋯(qk,rk,∅)→rk,ψk,rk+1(qk+2,rk,{ψk,rk+1})⋯(qk,rk,∅)→rk,ψk,rk+1⋯wherek≥0and for each i,0≤i<k, eithermi=1∧ni=0ormi=0∧ni>0.Letπ∈F(S[B])be an infinite path starting in a state(q,r,∅)such thatq⊨L(r). Then, in every position i of the path such thatπ[i]=(qi,ri,∅), it holdsqi⊨L(ri).See Appendix A.1  □In anS[B]system, deadlocks cannot be compatible with adaptability. Indeed, we see adaptability as the property for which a system continuously operates under stable, allowed modes (steady states), by possibly performing adaptation paths across modes.In the flat semantics deadlocks occurring at adapting states, e.g. when the adaptation invariant cannot be met, are clearly conflicting with the concept of adaptability. Instead, deadlocks at steady states are more subtle to interpret, since they may occur under two different conditions:•from the current state, any transition lead to a state violating the current constraints, and, at the same time, adaptation cannot start because none of the next B states meet any of the adaptation invariants and any of the target constraints. In other words, the flat semantics terminates even if the B level can proceed. Evidently, this violates adaptability.the B level cannot progress at all. We consider this situation as a bad deadlock state in the behavioural model. Conversely, every B state indicating a good termination should have the chance to progress and therefore must be modelled, as usual in this case, with an idling self-loop.We capture the requirement for which the flatS[B]must not terminate through theProgress(q,r)predicate:Progress(q,r)⇔(q,r,∅)→r∨(q,r,∅)→r,ψ,r′The flat semantics of the two systemsS0[B]andS1[B]implementing the ATV motion controller case study are depicted in Figs. 5 and 6, respectively.Notably, the same behavioural level B possesses different adaptation capabilities depending on the structure S that is considered. Indeed, inF(S0[B])every adaptation path leads to a target S state. On the other hand, inF(S1[B])always there exists an adaptation path leading to a target stable region, but it may contain cycles of adapting states, thus leading to possibly infinite adaptation paths.In other words, the behavioural level B is able to successfully adapt under the structural levelS0, for all possible adaptation paths. Recalling the definitions introduced in Section 1,S0[B]is strongly adaptable. Conversely, B is able to successfully adapt underS1only for some adaptation paths, i.e. the finite ones. Therefore,S1[B]is weakly adaptable. These two different kinds of adaptability are formalised in Section 5.The transitional semantics introduced in Section 4 does not guarantee that an adaptation phase can always start or that, once started, it always ends up in a state satisfying the constraints of the target S state. In this section we want to give some formal tools to analyse a given system w.r.t. these kind of properties. As a first step, we characterise two adaptability notions by means of two relations over the set of B states and the set of S states, namely a weak adaptation relationRwand a strong adaptation relationRs. Then, we characterise the same adaptability notions logically and we prove that they can be model checked by using proper formulae of a temporal logic.Informally, a state q of B is weakly adaptable to a state r of S if it satisfies the constraints imposed by r and some of its successors are either weakly adaptable to the same r or there is an adaptation phase of the flat system that, from q, reaches a stateq′that is weakly adaptable to another S stater′. In other words, we require that states satisfyingL(r)are in relation with r and that from “border” states, that is to say those that can start an adaptation phase for leaving r, there is always at least one way to safely reach another steady situation in another S stater′. As explained in Section 4.1, the Progress predicate is used to rule out steady configurations in a state of bad termination. We formally define this relation using a co-inductive style as it is usually done, for instance, for bisimulation relations.Definition 7Weak adaptationGiven anS[B]system, a binary relationR⊆Q×Ris a weak adaptation if and only if wheneverqRrwe have:(i)q⊨L(r)andProgress(q,r), andif(q,r,∅)→rthen there existsq′∈Qsuch that(q,r,∅)→r(q′,r,∅)andq′Rr, andif(q,r,∅)→r,ψ′,r″for someψ′∈Ψ(Σ,A)andr″∈Rthen there existq′∈Q,ψ∈Ψ(Σ,A)andr′∈Rsuch that(q,r,∅)→r,ψ,r′+(q′,r′,∅)andq′Rr′.At the level of the whole system, we say thatS[B]is weakly adaptable if the initial B stateq0is weakly adaptable to the initial S stater0.Proposition 2Union of weak adaptation relationsGiven anS[B]system, ifR1andR2are weak adaptation relations, thenR1∪R2is a weak adaptation relation.See Appendix A.2  □Definition 8Weak adaptabilityGiven anS[B]system, the union of all weak adaptation relations among the states Q and R ofS[B]is denoted byRwand is the weak adaptability relation ofS[B].Lemma 1Propagation of weak adaptation relationConsider anS[B]system and let q and r be such thatq|wr. Then there exists inF(S[B])an infinite pathπ=(q=q0,r=r0,∅)(→r0)m0(→r0,ψ0,r1)n0⋯⋯(qi,ri,∅)(→ri)mi(→ri,ψi,ri+1)ni(qi+1,ri+1,∅)⋯such that∀i≥0.qi|wri∧((mi=1∧ni=0)∨(mi=0∧ni>0)).See Appendix A.3  □Weak adaptability guarantees that there is always at least one way for a certain state of anS[B]system to adapt, that is to say to continue to evolve in a consistent way w.r.t. the structural constraints of the S level. A stronger property that could be useful to know about the adaptability of a system is what we call strong adaptability. A B state q is strongly adaptable to an S state r if it satisfies the constraints imposed by r and all its successorsq′are either strongly adaptable to the same r or they are always the starting point of a successful adaptation phase towards statesq″that are strongly adaptable to other S states. Again, bad deadlocks are excluded from the relations. This time we require that all the “border” states are safe doors to other steady situations, whatever path is taken from them.Definition 9Strong adaptationGiven anS[B]system, a binary relationR⊆Q×Ris a strong adaptation if and only if wheneverqRrwe have:(i)q⊨L(r)andProgress(q,r), andfor allq′∈Q, if(q,r,∅)→r(q′,r,∅)thenq′Rr, andall adaptation paths starting from(q,r,∅)are finite and end up in a state(q′,r′,∅)such thatq′Rr′.At the level of the whole system, we say that B is strongly adaptable to S if the initial B stateq0is strongly adaptable to the initial S stater0.Proposition 3Union of strong adaptation relationsGiven anS[B]system, ifR1andR2are strong adaptation relations, thenR1∪R2is a strong adaptation relation.As in the case of weak adaptation relations.  □Definition 10Strong adaptabilityGiven anS[B]system, the union of all strong adaptation relations among the states Q and R ofS[B]is denoted byRsand is the strong adaptability relation ofS[B].In the remainder of the paper we will alternatively say that anS[B]system is weakly (strongly) adaptable, in the sense that B is weakly (strongly) adaptable to S. It is straightforward to see that strong adaptability implies weak adaptability, since the strong version of the relation requires that every adaptation path reaches a target S state, while the weak version just requires that at least one adaptation path reaches a target S state.Proposition 4Strong adaptation implies weak adaptationConsider anS[B]system and let q and r be such thatq|sr. Then, it holdsq|wr.See Appendix A.4  □Given the flat semanticsF(S[B])=(F,f0,→r∪→r,ψ,r′)of anS[B]system, we will denote, in the following, the set of reachable states from a certain statef∈Fas the reflexive and transitive closurePost⁎(f)of the operatorPost(s)={s′∈F|(s,s′)∈→r∪→r,ψ,r′}.Lemma 2Propagation of strong adaptation relationConsider anS[B]system and let q and r be such thatq|sr. Then, every state(q′,r′,∅)∈Post⁎((q,r,∅))is such thatq′|sr′.See Appendix A.5  □The following proposition gives a precise candidate relation for checking if a system is strongly adaptable: such a candidate is determined by the steady states of the flat semantics that are reachable from the initial state.Proposition 5Construction of strong adaptation relationGiven anS[B]system, letF(S[B])=(F,f0,→r∪→r,ψ,r′)be its flat semantics. ThenS[B]is strongly adaptable if and only ifR={(q,r)∈Q×R|(q,r,∅)∈Post⁎(f0)}is a strong adaptation relation.See Appendix A.6  □In the following we will show that in the ATV motion controller case studyS0[B]is strongly adaptable (and thus also weakly adaptable) andS1[B]is weakly adaptable, but not strongly adaptable.In order to verify thatS0[B]is strongly adaptable, we need to prove thatq0|sr0, by finding a strong adaptation relationRs.t.(q0,r0)∈R. Note that inF(S0[B]), every state is reachable from the initial state(0,r0,∅). Therefore by Proposition 5, we consider the relationR={(q,r)|q∈Q,r∈R,(q,r,∅)∈F}, where F is the set of flat states ofF(S0[B]). It is easy to verify that∀(q,r)∈R.q⊨L(r); and thatProgress(q,r)holds for any of such states, because there are no deadlock states in the flat semantics. Therefore condition (i) of the definition of strong adaptation is always true and has not to be further checked. Clearly,(q0,r0)∈R. Finally, it can be shown that requirements (ii) and (iii) of Definition 9 hold for each element ofR.We show the proof for((M,0,0,0,0),r0)and((M,0,1,1,0),r0). The other pairs can be proved analogously.•((M,0,0,0,0),r0)(ii)((M,0,0,0,0),r0,∅)→r0((M,0,0,1,0),r0,∅)and((M,0,0,1,0),r0)∈R;((M,0,0,0,0),r0,∅)→r0((M,0,1,1,0),r0,∅)and((M,0,1,1,0),r0)∈R((M,0,1,1,0),r0)(ii)there is only one adaptation path from((M,0,1,1,0),r0,∅)leading to the flat state((S,0,1,0,0),r1,∅)(through the B state(M,0,1,0,1)), and((S,0,1,0,0),r1)∈R.On the other hand, we demonstrate thatS1[B]is weakly adaptable by finding a weak adaptation relationRs.t.(q0,r0)∈R. We take asRthe following relation:{((M,0,0,0,0),r0),((S,0,1,0,0),r1),((M,0,1,1,0),r0),((S,0,0,1,0),r1)}Similarly toS0[B],(q0,r0)∈Rand for all(q,r)∈R,q⊨L(r)andProgress(q,r)both holds. Thus, we need to check requirements (ii) and (iii) of Definition 7 to prove thatRis a weak adaptation relation.We observe that pairs((M,0,0,0,0),r0)and((S,0,1,0,0),r1)meet requirements (ii) and (iii), the latter being trivially verified since they do not admit adaptation transitions. Pairs((M,0,1,1,0),r0)and((S,0,0,1,0),r1)also comply with the weak adaptation definition, since they can both reach, in a finite number of adaptation steps, flat states that map to elements inR, i.e.((S,0,1,0,0),r1)and((M,0,0,0,0),r0), respectively.However, note that((S,0,1,0,0),r1)cannot be in any strong adaptation relation because, by the propagation property,((M,2,1,1,0),r0)would be in the relation and there are infinite adaptation paths starting from its corresponding flat state (see Fig. 6 and its caption). We conclude thatRis a weak and not strong adaptation relation.In this section we formulate the adaptability properties introduced in Section 5 in terms of formulae of a temporal logic that can be model checked [2,17].To this purpose we briefly recall the well-known Computation Tree Logic (CTL)[14,15], a branching-time logic whose semantics is defined in terms of paths along a Kripke structure [33]. Given a set AP of atomic propositions, a Kripke structure is a tuple(T,t0,→k,I)where T is a finite set of states,t0is the initial state,→κ⊆T×Tis a left-total transition relation andI:T→2APmaps each state to the set of atomic propositions that are true in that state. Given a statet∈T, a path π starting from t has the formπ:t=t0→κt1→κt2→κ⋯, where for alli=1,2,…,(ti−1,ti)∈→κ. Given a path π and an indexi>0, byπ[i]we denote the i-th state along the path π. The set of all paths starting from t is denoted byPaths(t). Note that, since the transition relation is required to be left-total, all runs are infinite. To model a deadlocked or terminated state in a Kripke structure the modeller must put a self-cycle on that state.The set of well-formed CTL formulae are given by the following grammar:ϕ::=true|p|¬ϕ|ϕ∧ϕ|AXϕ|EXϕ|A[ϕUϕ]|E[ϕUϕ]wherep∈APis an atomic proposition, logical operators are minimal (¬,∧) in order to generate all the usual ones, and temporal operators (X next, U until) quantify along paths and must be preceded by the universal path quantifier A or by the existential path quantifier E.Given a state t of the underlying Kripke structure, the satisfaction of a CTL formula ϕ in t, writtent⊨CTLϕ, is defined inductively as follows.t⊨CTLtruefor alltt⊨CTLpiffp∈I(t)t⊨CTL¬ϕifft⊭CTLϕt⊨CTLϕ1∧ϕ2ifft⊨CTLϕ1andt⊨CTLϕ2t⊨CTLAXϕiff∀π∈Paths(t).π[1]⊨CTLϕt⊨CTLEXϕiff∃π∈Paths(t):π[1]⊨CTLϕt⊨CTLA[ϕ1Uϕ2]iff∀π∈Paths(t).∃j≥0:(π[j]⊨CTLϕ2and∀0≤i<j.π[i]⊨CTLϕ1)t⊨CTLE[ϕ1Uϕ2]iff∃π∈Paths(t):∃j≥0:(π[j]⊨CTLϕ2and∀0≤i<j.π[i]⊨CTLϕ1)Other useful temporal operators like EFϕ (ϕ holds potentially), AFϕ (ϕ is inevitable), EGϕ (potentially always ϕ) and AGϕ (invariantly ϕ), are derived, as usual, as follows:EFϕ≡E[trueUϕ],AFϕ≡A[trueUϕ],EGϕ≡¬AF¬ϕandAGϕ≡¬EF¬ϕ.In the following we provide a Kripke structure derived from the flat semanticsF(S[B])and two CTL formulae characterising weak and strong adaptability.Definition 11Associated Kripke structureConsider anS[B]system and its associated flat semanticsF(S[B])=(F,f0,→r∪→r,ψ,r′). Its associated Kripke structure is defined asK(S[B])=(T,t0,→k,I)whereT=F,t0=f0,, I is defined w.r.t. the setAP={adapting,steady,progress}of atomic propositions as follows. For allt∈T:(i)adapting∈I(t)⇔t=(q,r,ρ)∧t→r,ψ,r′steady∈I(t)⇔t=(q,r,∅)∧(t→r∨t→r,ψ,r′)progress∈I(t)⇔t→r∨t→r,ψ,r′Note that the only structural difference betweenF(S[B])andK(S[B])are the self-loop transitions in→selfadded inK(S[B]). These are needed because the transition relation of the Kripke structure must be left-total, but indeed they allow us to keep the information that the states t such thatt→selftwhere originally deadlocked inF(S[B])(see discussion in Section 4.1). Then, the atomic proposition progress, by its definition (identical to the one given forProgress(q,r)at the end of Section 4.1), is not true in all and only those states ofK(S[B])that were originally deadlocked or bad terminated inF(S[B]). Moreover, we remark that in some states both adapting and steady propositions may hold at the same time. These are the already mentioned “border” states, i.e. those that are still in a steady situation, but will start adapting in the next transition. From these, the next state may be steady again (immediate adaptation) or only adapting (adaptation in more than one step).The formulae that we will check onK(S[B])are the following:•Weak adaptation: there is a path in which the progress condition continuously holds and, as soon as adaptation starts, there exists at least one path for which the system eventually ends the adaptation phase leading to a steady state.(6.1)EG((adapting⟹EFsteady)∧progress)Strong adaptation: for all paths, the progress condition always holds and whenever the system is in an adapting state, from there all paths eventually ends the adaptation phase leading to a steady state.(6.2)AG((adapting⟹AFsteady)∧progress)We remark that the same formulae could be expressed in the Action-based Computation Tree Logic (ACTL) [21] without the need of defining the atomic propositions. However, we decided to use CTL because we recognise that it is one of the mostly known and used temporal logic for model checking.Moreover, the expressive power given by CTL is adequate for the adaptability checking we introduced, in the sense that the same properties could not be expressed in the other mostly used logic, Linear Temporal Logic (LTL) [40]. In particular, the weak adaptability property requires the existential path quantification (EG, EF), which cannot be expressed in LTL, to render the invariability of the possibility of adaptation along one certain computation. Differently, the strong adaptability property could also be formulated in LTL as□((adapting⇒◇steady)∧progress).Theorem 1Weak adaptability checkingConsider anS[B]system. Given a B state q and an S state r such thatq⊨L(r), then q is weakly adaptable to r if and only if the weak adaptation CTL formula (Eq.(6.1)) is true inK(S[B])at state(q,r,∅). Formally, given a stateq∈[[L(r)]]q|wr⇔(q,r,∅)⊨CTLEG((adapting⟹EFsteady)∧progress)See Appendix A.7  □Corollary 1Consider anS[B]system. Then,S[B]is weakly adaptable if and only ift0⊨CTLEG((adapting⟹EFsteady)∧progress)wheret0is the initial state ofK(S[B]).The thesis follows easily from Definition 7 and from Theorem 1.  □Theorem 2Strong adaptability checkingConsider anS[B]system. Given a B state q and an S state r such thatq⊨L(r), then q is strongly adaptable to r if and only if the strong adaptation CTL formula (Eq.(6.2)) is true inK(S[B])at state(q,r,∅). Formally, given a stateq∈[[L(r)]]q|wr⇔(q,r,∅)⊨CTLAG((adapting⟹AFsteady)∧progress)See Appendix A.8  □Corollary 2Consider anS[B]system. Then,S[B]is strongly adaptable if and only ift0⊨CTLAG((adapting⟹AFsteady)∧progress)wheret0is the initial state ofK(S[B]).As in the weak case, the thesis follows easily from Definition 9 and from Theorem 2.  □Note that since we assume that the behavioural and the structural state machines are finite state, then the CTL adaptability properties can be model checked. This means that the defined notions of weak and strong adaptability are decidable and that the problem of adaptability checking can be reduced to a classical CTL model checking problem.CTL model checking has been widely investigated in the literature and relies on efficient tools like NuSMV [13]. The time computational complexity of the model checking problem for CTL isO((n+m)⋅|ψ|), where n is the number of states in the Kripke structure, m is the number of transitions and|ψ|is the length of the formula, i.e. the number of operators in its parse tree.The well-known problem in this area is the so-called state explosion problem, that is to say the high number of states (and thus transitions) that comes out from even relatively short descriptions of systems composed of concurrent interactive components. It is not in the scope of this work to discuss and refer the high research efforts that are currently going on in this area. A good starting point can be found in [2]. We will just give a brief estimation of the dimension of the state space given a certainS[B]system, which is the dominant complexity factor, considering that our formulae for the adaptability checking have constant length 4. The computational complexity of adaptability checking is thereforeO(n+m).Note that in our context the usual sources of state explosion (components, concurrency) are “hidden” inside the behavioural level B. This is because we want to work on the very basic model of computation of finite state machines and maintain a black-box view of the behavioural level from the structural level point of view. Thus, we take as the dominant dimension of the problem the “already exploded” number of states of the behavioural level. Then, we estimate what the definition of anS[B]model adds up to this explosion.Recall that the Kripke structure to model check isK(S[B]), derived from the flat semanticsF(S[B]). Depending on the dimension of S, the flat semantics could possibly lead to a transition system larger than the state space of the behavioural model B since the states are formally tuples inQ×R×({(ψ,r′)|∃r∈R.r→ψSr′}∪{∅}). The dimension n of the state space isO(|Q|⋅2|Q|⋅2|Q|), where|⋅|is set cardinality, based only on the number of states in the behavioural level and due to the higher order nature of S. However, considering the intended role of the structural level S, the number of S states is never exponential. This is because the different S states represent different modes of operations and, thus, usually stand for disjoint sets of B states. For this reason, a more realistic estimation of the state space dimension n should be expressed w.r.t. both B and S dimensions, yielding a number that isO(|Q|⋅|R|⋅|→S|).

@&#CONCLUSIONS@&#
