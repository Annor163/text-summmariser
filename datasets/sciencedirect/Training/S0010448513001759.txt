@&#MAIN-TITLE@&#
Robust cascading of operations on polyhedra

@&#HIGHLIGHTS@&#
Geometric rounding algorithm for cascaded operations on polyhedra.Algorithm rounds, perturbs, and restores validity.Output provably valid and close to input.Algorithm validated on packing three polyhedra into minimal box.

@&#KEYPHRASES@&#
Robust computational geometry,Geometric rounding,

@&#ABSTRACT@&#
We present a geometric rounding algorithm for robustly implementing cascaded operations on polyhedra where the output of each operation is an input to the next operation. The rounding algorithm reduces the bit-precision of the input and eliminates degeneracy. To do so, it rounds coordinates to floating point and randomly perturbs them, then prunes away invalid portions of the resulting polyhedron. We demonstrate the rounding algorithm on a packing algorithm with ten cascaded Minkowski sums and set operations.

@&#INTRODUCTION@&#
A sequence of operations is cascaded when the output of each operation is an input to the next operation. Cascaded operations on polyhedra are common in solid modeling. Designers create models via cascaded set operations, linear transformations, offsets, and sweeps. Algorithms that manipulate polyhedral models also use cascaded operations.A useful implementation of cascading should be robust. The output should have guaranteed accuracy for every input and the running time should be acceptable on real-world input. Prior work provides robust Boolean set operations [1], and Minkowski sums and sweeps  [2]. Robustly cascading these operations would benefit users of current computer-aided design algorithms and could facilitate the development of new algorithms.Algorithms for geometric operations are formulated in the real-RAM model where real arithmetic has unit cost. The control logic is expressed in terms of predicates: polynomials in the input parameters whose signs are interpreted as truth values. An example predicate is “pointcis left of lineabin the plane”. The first robustness problem is how to evaluate predicates efficiently. The second problem is how to handle degenerate predicates: ones that evaluate to zero, thereby creating special cases in the control logic.Cascading exacerbates the predicate evaluation problem by increasing bit complexity. Fig. 1shows an example involving polygonsPandQwith bit complexityp. The bit complexity of verticesbandcofP−Qis4pbecause they each depend on 4 input vertices from two intersecting line segments. The Minkowski sum of polyhedra withp-bit vertices contains12p-bit vertices. More generally, a cascade ofnplanar constructions of a line from two points and a point from two lines has exponential bit complexity inn[3]. Cascading can also create new degeneracies. In Fig. 1, verticesbandcare collinear withadbecause they are intersection points ofadwith other line segments.We present a geometric rounding algorithm for robust cascaded operations on polyhedra (Section  3). The input is a polyhedron with arbitrary bit-complexity. The output is a polyhedron that is close to the input and whose vertices are in general position and have bounded bit-complexity. We prevent bit complexity growth by rounding the vertex coordinates to floating point and remove degeneracy by perturbing the rounded vertices (Fig. 2(b)). If the modified polyhedron is invalid, e.g. intersects itself, we restore validity (Fig. 2(c)) and perturb the new vertices (highlighted in Fig. 2(c), (d)). Cascaded operations are implemented by geometrically rounding the output of each operation before providing it as input to the next operation. We demonstrate robust cascading on polyhedra by implementing a classic packing algorithm, which has ten cascaded Minkowski sums and set operations, and testing it on degenerate inputs, using a perturbation that is negligible in applications (Section  4).There are two main robustness methods. Exact computational geometry   [4] evaluates predicates exactly, using heuristics to decrease the evaluation time. The degenerate cases must be handled explicitly. In cascaded operations, predicate evaluation is slow because bit-complexity growth and output degeneracy defeat the heuristics. Controlled perturbation   [5] adds a random perturbation to each input parameter. The maximum perturbation size is chosen to ensure that predicates are non-degenerate and can be verified in floating point with high probability. In cascaded operations, a separate perturbation is required for each operation to remove degeneracy due to the previous operation. The perturbed polyhedra may be invalid, as illustrated in Fig. 2(b). Prior work does not address this challenge.Prior work on geometric rounding reduces bit complexity while maintaining validity, but allows a degenerate output. There are efficient algorithms for polygons  [6,3] and spline curves  [7] in the plane. Fortune’s  [8] algorithm for a polyhedron has output sizeO(n4)withnthe input size, which is impractical. Fortune [9] rounds a polyhedron using a representation that specifies the supporting planes of the faces and defines the vertices as transverse intersections of three supporting planes. The approach fails when vertices must be specified, as is common in solid modeling, and it excludes structures whose vertices are incident on more than three faces, such as Minkowski sums.We begin with an overview of our geometric rounding algorithm. The input is a polyhedral region with a closed manifold boundary, which we call a polyhedron for short. A polyhedron consists of disjoint cells each of which has an outer boundary and can also have inner boundaries. We represent a polyhedron as a set of closed triangle meshes, oriented so that the winding number from infinity of an interior point is 1 and of an exterior point is 0. We round and perturb the vertex coordinates to prevent bit-complexity growth and degeneracy. The modified input is invalid if it does not represent a polyhedron: either two triangles intersect or a winding number of a cell is neither 0 nor 1.Fig. 3illustrates on polygons: the modified input is invalid because three edges intersect, one cell has winding number 2, and another has winding number−1. Fig. 4illustrates on polyhedra: two pairs of modified triangles intersect and one cell has winding number−1.To compute a polyhedron that is close to the input, we construct the subdivision defined by the modified input, assign winding numbers to its cells, and take the union of the cells with positive winding number. This union corresponds to the volume covered by the modified interior. In Fig. 3(c), the union is two polygons. Although it is a well-defined polyhedral region, the union is invalid if it contains a non-manifold vertex: one that has a neighborhood that is not homeomorphic to a plane. A non-manifold vertex of a polyhedron is incident on multiple loops of adjacent triangles. We restore validity by subtracting tiny tetrahedra centered at these vertices. In Fig. 4, the highlighted vertex is incident on five triangles in the input (a) and on two triangle loops in the union (c), so subtracting a tetrahedron yields a valid polyhedron with two cells (d).The valid polyhedron can contain intersection vertices where (input or tetrahedron) edges intersect faces or where three faces intersect. These vertices need not be in general position. In Fig. 3(c), intersection verticesbandcare collinear with input edgead. We remove this degeneracy with a specialized perturbation that preserves validity.The winding number strategy was applied to plane-based polyhedra by Fortune [9]. Non-manifold vertices cannot occur in that representation because every vertex is incident on exactly three triangles.The geometric rounding algorithm appears in Fig. 5. The input is a polyhedronAof arbitrary bit complexity, and perturbation sizesδandδ2. Step 1 rounds the vertex coordinates ofAto floating point then adds a uniform perturbation in[−δ,δ]. Step 2 constructs the subdivision defined by the triangles ofA, identifies the vertices incident on triangles that separate cells of winding number 0 and 1, and returns the ones with multiple loops of such triangles. Step 3 constructs, and likewise rounds and perturbs byδ, equilateral tetrahedra with circumradius33δcentered at the non-manifold vertices. The union of these tetrahedra isB. Steps 4–5 compute the unionDof the positive winding number cells in the subdivision ofA∪B. The winding number of cellpwith respect to polyhedronXis written aswX(p). Step 6 triangulatesDto obtain a valid polyhedronR.Step 7 perturbs the intersection vertices ofR(created in Step 4) while keepingRvalid. For each vertexv, we selectv′uniformly in[−1,1]3. For each pair of triangless,t∈Rwith intersection vertices, we compute aλstsuch thatsandtare disjoint whenever each of their intersection verticesviis replaced byvi+λivi′with0<λi≤λst. We replace each intersection vertexvbyv+λv′withλthe smaller ofδ2and the minimumλstover the pairss,tthat containv.There are two cases for computingλst. Ifs=v1v2v3andt=w1w2w3are disjoint, letpandqbe a closest pair of points onsandt(Fig. 6(a)). The vectorn=q−pseparatessandt:n⋅(wj−vi)>0. LetS={vi,vi+kvi′}andT={wj,wj+kwj′}withka variable. We compute the maximumk,kmax, that satisfies the inequalitiesn⋅(tj−si)≥0forsi∈Sandtj∈T. For anyk<kmax,nseparates the convex hulls ofSandT, so it separates any perturbations ofsandtwhoseλvalues are bounded byk(Fig. 6(b)). We setλstto the largest power of0.5smaller thankmax. Ifsandtshare a vertex, sayv1, (Fig. 6(c)) we compute (below) a plane throughv1with normalnthat separates the interiors ofsandtand that maximizes the distance to the other vertices (Fig. 6(d)). We computeλstusingn⋅(vi−v1+k(vi′−v1′))≤0andn⋅(wj−v1+k(wj′−v1′))≥0.To compute the separating plane (described above) for triangles that sharev1, translate the origin tov1and rename the other vertices, so the triangles becomeoabandocdwithothe origin. A bisector ofU⊆{a,b}andV⊆{c,d}is a plane throughothat separatesUandVsuch that all elements ofU∪Vare equidistant from the plane. This distance is called the bisection distance. A normalnto the bisector isn=cforU=0̸andV={c},n=(c×d)×(c−d)forU=0̸andv={c,d},n=(a×c)×(a+c)forU={a}andV={c}, andn=(a+c)×(a+d)forU={a}andV={c,d}. A bisector is valid if it separates{a,b}from{c,d}and if no vertex in{a,b,c,d}−U∪Vis closer to it than the bisection distance. We enumerate theUandVcandidates and choose the valid bisector that maximizes the bisection distance.The computation ofλstcan encounter degeneracy because it uses the unperturbed intersection vertices. The cases are a vertex coplanar with a triangle, a vertex collinear with an edge, coplanar edges, and coplanar triangles. We detect these cases without numerical computation and handle them explicitly. For example, the distance formula is degenerate for coplanar edges becausenis the zero vector. One solution is a vertex of one edge that is closest to the other edge. Since we already compute this solution, we can ignore coplanar edges.Degeneracy is detected in Steps 4–6 of the algorithm. Each triangle ofA∪Bis assigned a unique id and each vertex is assigned the ids of its incident triangles. The vertex ids are transferred toCand its intersection vertices are assigned ids. When an edge intersects a triangle, the vertex is assigned the triangle id and the two ids of the triangles incident on the edge. When three triangles intersect, the vertex is assigned their ids. A face ofCis assigned the id of its generating triangle. When the face is triangulated, the triangles are assigned its id.We use the ids to identify the degenerate cases. Two triangles are coplanar if they have the same id. A vertex is coplanar with a triangle if the triangle id is one of the vertex ids. A vertex is collinear with an edge if it is coplanar with the two triangles incident on the edge and they are not coplanar. Two edges are coplanar if a vertex of one is collinear with the other or if an incident triangle of one is coplanar with an incident triangle of the other.

@&#CONCLUSIONS@&#
