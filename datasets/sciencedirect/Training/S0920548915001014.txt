@&#MAIN-TITLE@&#
Materialising a new architecture for a distributed MCU in the Cloud

@&#HIGHLIGHTS@&#
We propose a distributed architecture for video conferencing servers (MCUs).The MCU is divided into simple parts that broadcast streams, OneToManys.We describe and evaluate the new control architecture that allows distributed deployment.This solution provides improved scalability and deployment granularity.

@&#KEYPHRASES@&#
Cloud Computing,Video conferencing,Scalability,WebRTC,MCU,

@&#ABSTRACT@&#
New technologies are making videoconferencing more ubiquitous than ever. This imposes a big challenge for scaling software MCUs, the traditional videoconferencing servers. We propose, implement and test an architecture for a distributed MCU designed to be deployed in a Cloud Computing environment. The main design idea is to break monolithic MCUs into more simple parts: broadcasters. These broadcasters can be deployed independently on the fly. This achieves a higher deployment granularity and flexibility. We describe the control architecture that allows this distribution and prove the viability of the system with a fully developed implementation.

@&#INTRODUCTION@&#
Traditionally, video conferencing communications have been implemented in native applications or dedicated hardware devices. However, in the last few years and thanks to technologies such as Adobe Flash11http://get.adobe.com/es/flashplayer/.and HTML522http://dev.w3.org/html5/spec/.with its real-time communications standard WebRTC [1], these applications are moving towards the Web. That implies that any user with a PC, a smart phone or a tablet, a compatible Web browser and an Internet connection can use a videoconferencing service in order to communicate with others in real-time.This improved accessibility and ease of use encourages the presence of video conferencing systems in more Internet applications and services. Social networks, television applications and on-line video game platforms are rapidly adopting real-time communications. This trend also applies to business environments, where on-line meetings, long-distance interviews, call centres and conference streaming are increasingly adopted.This evolution towards the Web imposes new flexibility and scalability requirements to video conferencing infrastructures. Dedicated servers with fixed connections limits are becoming obsolete in a fast-paced Web environment where new popular sites are experiencing exponential growth in the number of concurrent users. At the same time, the surge in Cloud Computing systems has allowed developers to improve scalability on traditional services. Having more computing power on demand on a pay-per-use basis has set in motion a new ecosystem of new Web applications that react to the increasing traffic.The convergence of these developments has given rise to new types of systems that offer video conferencing as a Cloud service. By taking advantage of Cloud technologies, they can adapt to large variations in the number of users. This is particularly important in video conferencing between multiple participants. Here, communication usually occurs in virtual rooms, conceptual places on the Internet where users can communicate with others.Software multipoint control units (MCUs) are at the core of the server side of scalable video conferencing systems. MCUs have been used for years in these systems to address the signalling and real-time transport of user video and audio content. However, they can also support advanced functionality such as recording, video and audio transcoding, video composition and audio mixing. Nowadays, MCUs commonly serve many virtual rooms with multiple users in each of them. Hence, Cloud video conferencing services focus on solving the problem of adapting the number of MCUs to a varying number of users.In this paper we propose an architecture to achieve this scalability with very high flexibility and granularity. Scaling dynamically is a challenge in a traditional MCU. The machine in which the MCU is deployed imposes a limit that cannot be raised without interrupting the running sessions. Furthermore, the highest granularity that one can achieve is that of a video conferencing session: a session being the atomic unit of deployment in an MCU system.In conclusion, a video conferencing room has to be managed by a single MCU and it can never be split into different MCUs. This involves a very significant limitation in the deployment and the scalability of this type of system, a factor that can be improved in terms of efficiency in the management of the resources and costs.The solution we propose focuses on the most illustrative example, which is the scenario in which the MCU forwards each video and audio stream from every user to the rest of participants in the same room. The main task in this case is to copy every packet and send it to all participants. We have also defined the component that is responsible for carrying out this task within the MCU: the OneToMany processor. Our solution divides an MCU into multiple OneToMany components, one per audio and video stream that needs to be sent to the users. Moreover, we define the details we need to take into account for different layers of communication as well as general considerations to manage all the components in this system.This work is built on top of the ideas proposed in [2] the distributed OneToManys (dOTMs), an atomic software component that receives a media stream published by a user and multiplexes it to its subscribers. In a video conference room with multiple participants there will be a OneToMany (OTM) for each user publishing a stream. The OTMs are managed by a control layer and each one is totally independent of the others. Thus, OTMs that belong to users connected to the same virtual room can be distributed between different machines. An immediate advantage of this architecture is that when you need more resources to attend to the demand in a videoconferencing session, you can add a new machine on-the-fly.In the next section we extend the motivations introduced here and we analyse the requirements for achieving the goals of this research. In Section 3 we summarise the current work related to the problem. Then in Section 4 we present our solution by describing the architecture and its execution flow in a videoconferencing scenario. In Section 5 we show the implications of this architecture and, using a real open-source implementation of dOTMs (Licode33https://github.com/ging/licode.), we demonstrate that the new model does not negatively affect the performance of the communications. Finally, in Section 6 we show the main conclusions of this work and we introduce some lines of research for future work related to it.In this section we enunciate the problem this work aims to solve. In order to do that, we describe the scenario where the problem takes place, define the terms we will use throughout the paper and elaborate the problem description by providing an example on a real software MCU.Video conferencing with multiple participants has traditionally been provided by MCUs, as opposed to peer-to-peer solutions. The lack of availability of IP Multicast [3] for end-users impairs the use of p2p for multi-party real time communications as the number of participants dictates the upload bandwidth needed. In such cases, an MCU-based application level multicast is used. The centralised architecture means that there is a bottleneck on the server side but, on the other hand, clients save uploaded bandwidth as they do not have to replicate the streams they are publishing for each participant.A few years ago, videoconferencing systems were limited to native and desktop applications. But current new technologies also provide video conferencing on the Web browser. As Web applications are more easily accessible and impose fewer requirements in the devices, this enables a new and more dynamic way of communicating. However, it also imposes a great challenge for MCU deployments. The traditional dedicated and tightly scheduled infrastructures are not tailored to meet the fast changes in demand associated with Web applications. Cloud Computing, and its ability to provide resources on demand, has been widely used as a solution for scalability problems. Specifically when talking about video conferencing, the illusion of infinite computational power and bandwidth that the Cloud provides is very attractive for deploying resource demanding services. However, designing and deploying software in the Cloud is a challenge in itself.Several works have tried to take advantage of the capabilities the Cloud provides applied to video conferencing. In [4] the authors provide a general overview on video conferencing services in the Cloud. By designing the conference as service oriented architecture, the final consumer application is separated from the video conference provider. Conferencing services are offered on request in a similar way that infrastructure is offered in the Cloud. The authors in [5] present an implementation that adheres to some of these principles. While the general idea on how to adapt video conferencing systems to the Cloud is clear in these works, it is not specified how to react to the variations on demand or how to provide the resources for the video conferencing capabilities dynamically.On the other hand, since the term Cloud Computing was coined and its characteristics set out, there has been an abundance of studies on how to take different kinds of applications to the Cloud, taking advantage of its strengths and highlighting the risks. According to [6] the ability to scale quickly and efficiently is one of the top ten obstacles (and opportunities) for the growth of Cloud Computing and the applications that rely on it. Furthermore, the authors in [7] argue that cost and efficiency is one of the risks businesses have to take into account when transitioning to Cloud services. The authors in [8] emphasise the importance of taking into account the different requirements of the applications in terms of quality of experience (QoE) when adapting their Cloud deployment.To sum up, Cloud Computing can be a very powerful tool for creating scalable video conferencing services. However, to maximise its value (economic and otherwise), the Cloud deployment has to be carefully designed, implemented and adapted to the service in order to provide a successful experience with minimal cost.This paper proposes a way to improve the efficiency when it comes to deploying and providing resources for multiple participant video conferencing in Cloud systems.To illustrate this, we will focus on the scenario of a multi-party video conference where an arbitrary number of users sends and receives real time audio and video streams. A use case of this scenario is, for instance, a business meeting in which all participants share their audio and video. These participants will send all the traffic through an MCU in order to save upload bandwidth as explained before. In the following subsections we will provide the definitions that will be used throughout the paper and will further explain the scenario of the problem.The following terms will be used throughout this paper. These are illustrated in Fig. 1:•Participant: A device that takes part in a video conference. It can receive and send multimedia streams. Generally, it will represent the final users of the system.Room: A conceptual environment participants join to make their multimedia streams available and receive data from others. In general, we will say participants publish and subscribe to streams. The scope where these publications are visible is the room.MCU: A software device that hosts one or more rooms. It physically receives the media streams from the participants and is able to forward these streams to the others.While there are many ways of designing and implementing an MCU, such as those detailed by the authors in [9] or, more recently, in [10], in this paper we will focus on a pure forwarding MCU. That is, the MCU receives packets from each participant and forwards them to the rest, without performing any altering operations in the streams themselves such as composing or mixing. Only the essential operations for transmitting the media will be carried out.Furthermore, in the scope of this paper we will assume all the participants in a room subscribe to all the available media streams. This will maximise the amount of information (connections and bandwidth) the MCU has to process.In the aforementioned scenario, the MCU acts at three different levels:•Signalling: The MCU implements the required protocols that enable the negotiation needed to establish the direct communication with the participants.Media: The MCU is able to send and receive media streams using the video and audio codecs and protocols understood by the participants. These protocols are negotiated during the signalling phase.Control: The room concept is implemented in the MCU, allowing participants to publish and subscribe to media streams within that scope. This implies keeping a list of the participants in each room and being able to notify them when this list changes.In this scenario, the MCU is the minimum complete piece of software that can be deployed and run on a server-side node. Thus, it acts as the deployment unit when taken to a data centre or a Cloud provider. That is, we will get more video conferencing capacity by adding more MCU nodes to the system.The MCU is a process which is run on every server that we want to add to the server pool. As such, the number of participants that can be handled by an MCU is limited by the hardware it is installed on and the bandwidth available to it. We can deduce how being limited by the MCU as a unit will be a problem. For each participant in a room size N, the MCU receives 1 stream and forwards it (N−1) times. In total, there are (1+(N−1))∗N=N2 connections to the MCU at the same time. When the next participant comes, it publishes its stream so it is received by all the others (1+N), and it subscribes to the streams available (N connections) so we have 2N+1 new connections or (N+1)2. That is, the connections grow quadratically. The amount of processing power, memory and bandwidth needed is directly proportional to the number of active connections that an MCU is maintaining. Thus, the number of participants that an MCU can handle is much lower when they are arranged in big rooms.To show the implications of the number of connections on the overall load in the system, we have carried out tests on our open source WebRTC MCU, Licode. This experiment was carried out in a small instance in Amazon EC2,44http://aws.amazon.com/ec2/.roughly equivalent to 1GHz Intel Xeon family processor.We have reproduced the aforementioned scenario in a conference room where all participants subscribe to all the streams. The MCU optimises the quality of the streams by maximising the bandwidth used.The participants provided 3Mbps of traffic combining audio and video streams, for an ultra-high quality video conference. The result can be seen in Fig. 2As we can see, the increase in CPU is very significant for each participant that joins the session. While the MCU is only copying and forwarding packets, the high CPU load is explained by the use of SRTP [11]. Each packet has to be decrypted and encrypted again to be transmitted to each of the participants as every connection has its own encryption keys. This, combined with the very high bit-rate of the media, is very CPU intensive.These high CPU and bandwidth requirements for video conferencing applications make resource provisioning a key part in a successful Cloud deployment. One of the most popular approaches is to limit the number of people per room. In this case, we can estimate the resources needed for each room and plan the number of instances needed accordingly. This, however, is not optimal. If for any reason we need a room bigger than what was previously planned, we will be limited by the amount of connections the physical CPU and bandwidth can sustain, making this change impossible in some cases. On the other hand, provisioning hardware for rooms than are never fully filled can be a very significant amount of reserved but unused resources.

@&#CONCLUSIONS@&#
This paper presents an architecture designed to improve the scalability of videoconferencing systems deployed in public or private Clouds. To avoid the coarse granularity of a centralised MCU, our proposal divides it into more simple components that can be deployed in a distributed way. This distributed component can be deployed on the fly. This allows for a more efficient use of resources as the allocation of more processing power is more dynamic. However, this adds a noticeable amount of new management messages and components that could potentially affect the performance of the communications, such us the connection establishment time.To test the performance of the proposal in a real distributed scenario we have refurbished our own open source WebRTC MCU and adapted it to the new topology. We have measured its performance in two different experiments to show that distributed sessions improve the scalability over non-distributed MCUs and that the additional control and management do not significantly delay the establishment of the communication.This research opens up several lines for future work. First of all, the strategies to deploy these new atomic units that make up an MCU are out of the scope of this paper. Better deployment schemes could improve the performance of production systems by taking into account parameters such as the geographical distribution of the clients and the price of the different types of instances in public Cloud platforms.An aspect that also improves scalability in terms of performance and costs is the dynamic mobility of the OTMs between computers. If we have several servers that are not using all their resources, we can move the OTMs by merging them into one of the servers and shutting down the others. Finding a way of achieving the mobility in a transparent way to the users is also a new line of work.Another very interesting field is the ability to form distribution trees with OTMs that could even further improve the scalability of the system, which also has very interesting applications in real-time streaming of events.