@&#MAIN-TITLE@&#
Accessing complex patient data from Arden Syntax Medical Logic Modules

@&#HIGHLIGHTS@&#
We encountered a clinical demand to process complex data within Arden Syntax Medical Logic Modules.Mapping of complex data is not natively supported by the Arden Syntax standard.We investigated three different approaches to map complex data onto Arden Syntax data structures.The most promising approach is based on deserialization of XML data.Complex data structures foster population-based clinical decision support.

@&#KEYPHRASES@&#
Arden Syntax,Medical Logic Modules,Curly braces problem,Clinical decision support,Microbiology data,

@&#ABSTRACT@&#
ObjectiveArden Syntax is a standard for representing and sharing medical knowledge in form of independent modules and looks back on a history of 25 years. Its traditional field of application is the monitoring of clinical events such as generating an alert in case of occurrence of a critical laboratory result. Arden Syntax Medical Logic Modules must be able to retrieve patient data from the electronic medical record in order to enable automated decision making. For patient data with a simple structure, for instance a list of laboratory results, or, in a broader view, any patient data with a list or table structure, this mapping process is straightforward. Nevertheless, if patient data are of a complex nested structure the mapping process may become tedious. Two clinical requirements – to process complex microbiology data and to decrease the time between a critical laboratory event and its alerting by monitoring Health Level 7 (HL7) communication – have triggered the investigation of approaches for providing complex patient data from electronic medical records inside Arden Syntax Medical Logic Modules.Methods and materialsThe data mapping capabilities of current versions of the Arden Syntax standard as well as interfaces and data mapping capabilities of three different Arden Syntax environments have been analyzed. We found and implemented three different approaches to map a test sample of complex microbiology data for 22 patients and measured their execution times and memory usage. Based on one of these approaches, we mapped entire HL7 messages onto congruent Arden Syntax objects.ResultsWhile current versions of Arden Syntax support the mapping of list and table structures, complex data structures are so far unsupported. We identified three different approaches to map complex data from electronic patient records onto Arden Syntax variables; each of these approaches successfully mapped a test sample of complex microbiology data. The first approach was implemented in Arden Syntax itself, the second one inside the interface component of one of the investigated Arden Syntax environments. The third one was based on deserialization of Extended Markup Language (XML) data. Mean execution times of the approaches to map the test sample were 497ms, 382ms, and 84ms. Peak memory usage amounted to 3MB, 3MB, and 6MB.ConclusionThe most promising approach by far was to map arbitrary XML structures onto congruent complex data types of Arden Syntax through deserialization. This approach is generic insofar as a data mapper based on this approach can transform any patient data provided in appropriate XML format. Therefore it could help overcome a major obstacle for integrating clinical decision support functions into clinical information systems. Theoretically, the deserialization approach would even allow mapping entire patient records onto Arden Syntax objects in one single step. We recommend extending the Arden Syntax specification with an appropriate XML data format.

@&#INTRODUCTION@&#
Arden Syntax for Medical Logic Systems, maintained by the Health Level 7 organization (HL7), is a standard for encoding and sharing medical knowledge. In Arden Syntax, knowledge is contained in independent modules named Medical Logic Modules (MLMs). An MLM typically contains sufficient knowledge to make a single clinical decision. The inventors of Arden Syntax pursued two design targets: Sharing medical knowledge between institutions, and easy knowledge acquisition [1]. MLMs are evoked by clinical events, typically the storage of a data item into the patient record (data-driven evoking). MLMs are hierarchically structured into sections (categories) and subsections (slots). The behavior of an MLM is mostly determined by four slots. The EVOKE slot defines the events an MLM reacts to, like “storage_of_blood_glucose”. The DATA slot isolates those parts of an MLM that interact with the clinical information system, in particular the retrieval of patient data from the medical record. The LOGIC slot contains the actual institution-independent medical knowledge. The ACTION slot specifies the steps to be performed in case the LOGIC slot decides an action is required. Those four slots contain sequences of statements that resemble general purpose programming languages but are considered easier to write and understand for non-programmers [2]. The traditional field of application is the monitoring of clinical events [3]. An MLM could for example send an alert notification to a physician in case a new laboratory result exceeds a critical limit. Although the decision logic inside an MLM is usually simple, consisting of a few conditional statements (for a typical example see [4]), an MLM may nevertheless contain complex logic – without upper complexity limit – capable of processing complex data.Patient data must be mapped onto Arden Syntax data types in order to process them. The creators of Arden Syntax realized that due to the lack of standards both for electronic patient records and interfaces of storage systems [5], it would be at least tedious, if not impossible, to find a standard method for accessing patient data. Instead of an abstraction layer they provided a pair of curly braces to encapsulate any parameters for mapping data between an MLM and a clinical system. As the mapping process itself is potentially tedious and must be implemented by any institution for any system, this aspect of Arden Syntax is referred to as the “curly braces problem”. The Arden Syntax data type system was deliberately kept simple and corresponds to that of medical patient records (for a description of data types typically contained in medical records see [6]). Each primitive data type is a pair of a value and a timestamp (the latter termed “primary time” in Arden), since an observation like “blood glucose is 35mg/dL” is of limited use without information about the time when this value occurred. When retrieving patient data from a database query, timestamps inside the resulting data structure must be set according to those inside the patient record. Initially, ordered lists (collections of primitive types) were the only compound data type. Nesting of lists was not permitted; therefore it was not possible to natively represent patient data with a nested structure. For most MLMs with simple decision logic such as alerting functions these plain lists were absolutely sufficient. However, for more complex applications like processing clinical guidelines, plain lists proved to be insufficient [7,8]. Consequently, starting with version 2.5 of the standard, the limitation to plain lists was overcome by the introduction of objects to permit complex data structures. Objects in Arden Syntax must not be confused with those from object oriented programming languages since there are no methods and no inheritance concept. They only provide a way to group data items and access them by name with nesting permitted.Even though such object definitions opened up new possibilities for managing nested data structures by grouping we still identified barriers to easily assign complex data items, such as microbiology data, to Arden Syntax variables in previous implementation projects [9]. Complex data are any data with a structure beyond flat lists or tables. A list of glucose values is not complex and may easily be mapped onto the Arden Syntax list data type in a single step. A table containing all patients currently on the ward (e.g., with columns “patientname”, “casenumber”, “birthdate”, etc.) is also not complex and, in versions supporting the object data type, may easily be mapped onto an appropriate Arden Syntax data structure such as a list of table row objects. Microbiology data at our institution, however, are complex as they have a multi-level tree structure as displayed in Fig. 1. HL7 messages are usually complex. Entire patient records are complex, and their subparts may themselves be complex. In addition, data from external systems may be complex since MLMs are not necessarily limited to process data from the patient record only. Thus the objective of this paper was to illustrate the data mapping limitations of the current Arden Syntax versions, to present the results of our investigations towards mapping concepts for complex patient data structures, and finally to propose an extension of Arden Syntax based on one of these approaches. Additionally, we benchmarked the performance of the investigated approaches as speed is known to be of paramount importance for effective clinical decision support, and complex data may be of a large size.While the Arden Syntax specification leaves the actual database access to the particular institution, it nevertheless specifies the general behavior for reading patient data by means of two statements: READ (see specification [10], 11.2.1) for mapping patient data onto one or more lists of primitive types, and READ AS (see specification, 11.2.2) for mapping patient data onto a list of objects. The behavior of both statements is illustrated in Fig. 2, using an example result from a SQL database query containing laboratory results from a serum electrolyte analysis. Approach M1 maps each column onto a corresponding Arden Syntax list. The primary time of each list element is set according to the timestamp column. Within a typical MLM, a READ statement requests only a single parameter and therefore maps a single column of values from a database result set onto an Arden Syntax list. Mapping multiple columns onto a set of lists may render the code inside an MLM difficult to read since the knowledge engineer has to care for accessing correspondent elements by keeping track of their positions through index variables. Approach M2 (enabled by the introduction of the READ AS statement in Arden Syntax Version 2.5), introduced alongside the object statement, maps each table row onto an electrolytes object as defined by a previous object statement, and returns a list of such objects. Each object has three attributes (sodium, potassium, calcium) containing the particular values together with the particular timestamps as primary times. This approach allows to easily process multi-column database results in a comfortable way. Note that with both mapping approaches the column names of the database result are lost. In case of M1 because lists do not support names at all; in case of M2 because attribute names are extracted from the previous object declaration (“sod” becomes “sodium”, and so on).Between 2006 and 2012, a commercial patient data management system (PDMS) was implemented in 9 intensive care units (ICU) of the University Hospital Erlangen (UHER), a tertiary care hospital with 1400 beds [11]. Since this PDMS (Integrated Care Manager, ICM©, Dräger Medical, Lübeck, Germany) lacked features for clinical decision support, the UHER information technology department and the Erlangen Chair of Medical Informatics entered a development cooperation with Dräger in order to integrate a commercial Arden Syntax environment (ArdenSuite©, Medexter Healthcare, Vienna, Austria) into the PDMS [9]. The inherent limitations of the PDMS required the implementation of several workarounds. The PDMS does not yet provide direct database access for third party systems such as an external Arden Syntax engine. However, it provides an export interface to generate doctors’ letters and textual reports. We applied this interface to replicate patient data required by MLMs into a separate proxy database, which is entity-attribute-value (EAV) modeled (for a detailed explanation of this data model see [6]). Database access from MLMs to the proxy database was enabled by a self-written abstraction layer based on prepared statements. In addition, the PDMS lacks a trigger mechanism to notify the Arden Syntax engine about the storage of data items, which is an indispensable feature for data-driven MLM execution. Therefore, such a mechanism has been implemented in our proxy database. Processing of microbiology findings within MLMs required another workaround. These data are contained in HL7 messages sent by our laboratory information system, but our PDMS currently stores only extracted contents as plain text, thus inhibiting automatic processing by MLMs. Consequently, we duplicated the HL7 messages on our communication server so that they can be processed using a self-written parser which extracts the desired information and stores it as structured data inside our proxy database. As microbiology data are not sparse and have a regular structure, we chose to model them in a conventional database schema rather than in an EAV model. The basic structure of microbiology data at our institution is shown in Fig. 1. Each patient's microbiology data is a list of orders with their associated findings. Thus, attached to each order is a list of findings, a list of comments entered into the laboratory system, and a list of DRG coding recommendations relevant for billing.In this initial situation our investigation was prompted by new clinical demands. First, ICU clinicians wanted to generate multi-patient overviews with filtered or highlighted observations according to their clinical importance. As the PDMS does not natively support such flexible visualization features, clinicians required MLMs to process these structured microbiology data. Second, clinicians demanded immediate alerts about critical events. Up to now, alert messages are delayed for up to 10min due to the required data replication into the proxy database. To satisfy these demands, we searched for a reusable, generic approach to map arbitrary subsets of patient records, or even sets of whole patient records, onto a single Arden Syntax data structure, and for a way to map entire HL7 messages onto Arden Syntax objects in order to monitor time-critical laboratory results directly from the HL7 messaging stream on our communication server.Our study started with the specification of the intended mapping result, a list of microbiology objects represented by the Arden Syntax object data type introduced in version 2.5. Each object should contain a single patient's entire microbiology data, with the tree structure inside the patient record preserved. Subsequently we analyzed the interface components of three different Arden Syntax engines to compare approaches for handling the curly braces problem: The commercial system used in the clinical routine at UHER (ArdenSuite [12], supporting all versions of Arden Syntax), an open source system developed at the University of Braunschweig (Arden2ByteCode [13], supporting version 2.5), and a PHP: Hypertext Preprocessor (PHP) web application developed by one of the authors for research purposes (ARSEN/IC, supporting version 2.8).We identified three different basic approaches to map complex data by analyzing both the available application programming interface (API) documentation and the source code of the particular interface components, and implemented them using ARSEN/IC as this system provides both native support of mapping approach M2 and a built-in database abstraction layer. We created a database snapshot of microbiology data for all patients currently admitted to the largest of our ICUs as a data sample for testing the implementation. To validate the results of each mapping approach we wrote an MLM called structureprinter which creates a tree view (see Fig. 3) of any data structure it receives as the argument by recursive descent, using the comparison operators (see specification, 9.6) and the relevant object operators (see specification, 9.18.3 and 9.18.4). As an alternative application example, and to fulfil the clinical requirement of immediate alerting, we mapped entire HL7 messages onto Arden Syntax objects, using an approach provided by the commercial ArdenSuite as part of its “Arden Syntax Server Protocol”.Our first approach to map microbiology data onto Arden Syntax objects, named “Arden approach”, was to build the intended data structure from “inside” an MLM. We used a top-down approach based entirely on the mapping approach M2 described above. We defined a set of object data types (Fig. 4A) according to the basic tree structure of microbiology data (Fig. 1). The last attribute orders from data type casetype serves as an anchor for the orders sub-level, just as the last three attributes from data type ordertype (findings, comments, recoms) serve as anchors for the findings, comments, and recommendations sub-levels. We created the intended data structure by using nested loops as shown in Fig. 4B. Left-hand parameters inside the curly braces are the names of prepared statements. Right-hand parameters, marked with a prefixed dollar symbol, are MLM variables to be resolved and inserted into the prepared statements. We integrated the nested loops into a separate MLM that may be called by any other MLM requiring microbiology data.Our second approach was to perform data mapping from “outside” an MLM. This approach was basically the same as with the Arden approach, except that the code was not implemented in Arden Syntax but in the PHP programming language of the systems interface component. We used the particular API methods to create the intended data structure, i.e., the methods to create data types, add list elements and set attributes of objects, and thus termed it the “API approach”. Database access from within the interface component was performed using an open source database abstraction layer. As with the Arden approach described above, each sub-level was processed inside a nested loop.Our third approach, called the “deserialization approach”, was based on the proprietary Arden Syntax Server Protocol provided by ArdenSuite, specifying an Extensible Markup Language (XML) data format as displayed in Fig. 5. We transformed microbiology data to the XML-based data structure defined by this protocol, and called an MLM using this XML structure as the argument. As with the other approaches, we used the MLM structureprinter to verify the correctness of the mapping. To further investigate this approach, we integrated a data mapper into ARSEN/IC, allowing serialization [14] of any data structure to the XML-based Web Distributed Data Exchange (WDDX) format [15], and integrated another mapper which performs the same process backwards, i.e., deserializing WDDX to Arden Syntax data structures. We opted for WDDX because it is natively supported by PHP, and ARSEN/IC stores compiled MLMs in this format.We measured the execution speed by repeating each data mapping approach 1000 times on a server virtual machine (Windows 2008 server with 8GB main memory and 2 Intel Xeon X5675 processors), with each pass followed by a random delay within 1 to 3s. The benchmarks for all three approaches were performed in parallel to create a considerable server load. Patient data were retrieved from a database server within the local network. Additionally, we measured the peak memory usage of each approach. Our data sample for testing and benchmarking comprised 22 patients, with a total of 352 orders, 690 findings, 67 comments, and 91 recommendations.Finally, we utilized the Arden Syntax Server Protocol to map entire HL7 messages containing laboratory results onto Arden Syntax objects. We integrated a self-written Python program into our communication server, which transforms HL7 messages to appropriate XML structures consisting of nested objects. We tested several variations regarding the naming of objects and attributes, and decided to use an easy to understand convention. We used the names from the HL7 specification, i.e., “segment”, “field”, “component” and “subcomponent”, and attached consecutive numbers as suffixes. Therefore, a subcomponent inside a HL7 message, passed to an MLM as the argument, would be accessed with an expression likehl7message.segment5.field3.component1.subcomponent3.

@&#CONCLUSIONS@&#
