@&#MAIN-TITLE@&#
Minsum and minmax scheduling on a proportionate flowshop with common flow-allowance

@&#HIGHLIGHTS@&#
We study scheduling problems with common flow allowance on a proportionate flowshop.We solve both the minsum and the minmax versions.Both versions are extended to a setting of due-windows.Several unique structural properties of an optimal schedule are proved.All the problems are solved in polynomial time.

@&#KEYPHRASES@&#
Scheduling,Proportionate flowshop,Due-date assignment,Due-window assignment,Flow-allowance,

@&#ABSTRACT@&#
We study due-date assignment problems with common flow allowance on a proportionate flowshop. We focus on both minsum and minmax objectives. Both cases are extended to a setting of a due-window. The proposed solution procedures are shown to be significantly different from those of the single machine problems. All the problems studied here are solved in polynomial time: the minsum problems in O(n2) and the minmax problems in O(nlog n), where n is the number of jobs.

@&#INTRODUCTION@&#
The study of scheduling problems with due-date assignment became popular during the 80′s as a result of the growing interest in Just-In-Time (JIT) production philosophy. The goal was to ensure that jobs/products will be available exactly at their due-dates, in order to minimize both the earliness (mainly inventory) cost and the classical tardiness cost. In these models, jobs completed prior to or after their due-dates are penalized according to their earliness/tardiness values, whereas on-time jobs are not penalized. In recent years, many researchers focused on the study of due-windows, where a time interval is assumed, such that jobs completed within this interval are not penalized. We refer the reader to the survey papers on due-date assignment (Gordon, Proth, & Chu, 2002), and on due-window assignment (Janiak, Janiak, Krysial, & Kwiatkowski, 2015).Scheduling problems with common flow allowance is an important class of due-date assignment problems. In these problems, the job-dependent due-dates are determined as simple linear functions of the job processing times. In the most basic model (see e.g., Adamopoulos & Pappis, 1996a), the due-date of a given job is defined as the sum of its processing time and a job-independent constant (which is a decision variable). It is clear that a small value for this constant (leading to earlier due-dates) makes the supplier more attractive to customers, whereas a large value (reflecting late due-dates) increases flexibility for the scheduler. Hence a cost is incurred when increasing the flow-allowance constant. Due-date assignment based on common flow allowance is known to be the simplest method to determine job-dependent due-dates.In this paper we focus on due-date assignment problems with common flow allowance on a proportionate flowshop. This machine setting is a special case of the classical flowshop, where the job processing times are machine-independent. We refer the reader to Panwalkar, Smith and Koulamas (2013) for a recent detailed review of various models of scheduling problems on a proportionate flowshop. The optimal solutions of many scheduling problems on a proportionate flowshop were shown to be identical to those obtained for a single machine (see e.g. Pinedo, 2012). However, the proposed solution procedures introduced in this paper are shown to be significantly different from those known in the literature for the single machine case.We consider here both minsum and minmax objective functions. In minsum we minimize the total cost incurred by all the jobs, whereas in minmax, the value of the objective function is identical to that of the worst scheduled job, i.e., to the largest cost. Many researchers have studied minsum scheduling models with common flow allowance, after those of Adamopoulos and Pappis (1996a, 1996b). We provide a list of relevant papers (focusing on a minsum objective and a single machine setting) published in the last decade: Wang (2006), Shabtay and Steiner (2007), Mosheiov and Oron (2010), Wang and Wang (2010), Mor and Mosheiov (2012a) and Chen, Ji and Ge (2013). Problems combining a flow-allowance model and a minmax objective have hardly been studied. In fact, we are aware of two papers focusing on this combination: Mor and Mosheiov (2012b, 2012c), who studied this setting on a single machine and on parallel identical machines, respectively.While the single machine minsum model was shown to be solved by matching processing times to positional weights in O(nlog n) time (Adamopoulos & Pappis, 1996a), we show here that the extension to a setting of a proportionate flowshop requires a computational effort of O(n2). Recall that an optimal schedule for the single machine setting is V-shaped, i.e., consists of a set of jobs sequenced in a non-increasing order of processing times, followed by the remaining jobs sequenced in a non-decreasing order of processing times. We show that an optimal V-shaped schedule remains valid for proportionate flowshop. Thus, our proposed algorithm is based on the important structural property that there are no idle times on the last machine of the flowshop between consecutive jobs belonging to the set of jobs scheduled first. This subsequence is obtained by matching jobs to positional weights in a traditional manner, and the remaining jobs are scheduled to create a V-shape. Regarding the minmax problem, while the single machine minmax problem was shown to be solved (by assigning the largest job to the last position and identifying the relevant case) in O(n) time (Mor & Mosheiov, 2012b), the extension to a proportionate flowshop is shown here to be solved in O(nlog n), due to the required sorting procedure. The solution is based on the monotonicity of the costs, and consequently on the fact that the maximum cost is obtained by the first and the last scheduled jobs.Both the minsum and the minmax cases are extended to a setting of due-windows. In the extended models, the scheduler is penalized if either the due-window is delayed, and/or if it is larger. Both cases reflect a situation that the scheduler/producer becomes less attractive to customers. Hence, the model contains additional costs for delaying the window, and for increasing the window size (see e.g. Liman, Panwalkar, & Thongmee, 1998). The single machine minsum version was solved in Mosheiov and Oron (2010) in O(nlog n) time (again, by a matching procedure). The proposed algorithm for a proportionate flowshop is based on checking all relevant V-shaped sequences (as for the due-date case), and requires O(n2) time. The single machine minmax version was solved in Mor and Mosheiov (2012b) in O(n) time (by assigning the largest job to the last position). The proposed algorithm for a proportionate flowshop requires sorting and thus runs in O(nlog n) time. Note that the total running times do not increase when extending the setting from a due-date to the more general setting of a due-window, for both minsum and minmax.The paper is organized as follows. Section 2 contains the notation and the formulation. Section 3 provides the solution for the minsum due-date assignment problem, and Section 4 presents the extension to the setting of a due-window. In Section 5 we introduce the solution for the minmax due-date assignment problem, and Section 6 contains the extension to a due-window assignment.We study an n-job, m-machine proportionate flowshop problem. The processing time of job j on machine i is denoted bypij,i=1,…,m;j=1,…,n. Since the job processing times are machine-independent, in this settingpij=pj,i=1,…,m;j=1,…,n. LetP=∑j=1npj, andpmax=max{pj,j=1,…,n}denote sum of the processing times and the maximal job processing time, respectively. We focus on a due-date assignment problem, assuming a common flow-allowance q. Each job is assigned a different due-date, which is equal to the sum of its processing time and a job-independent constant:dj=pj+q,j=1,…,n.Note that the definition of (the decision variable) q is identical to its commonly used definition on a single machine.For a given job schedule,Cij,i=1,…,m,j=1,…,n,denotes the completion time of job j on machine i. The completion time of the last operation of job j (on machine m) is denoted byCj=Cmj,j=1,…,n.The starting time of the last operation of job j (on machine m) is denoted bySj,j=1,…,n.The earliness of job j is given byEj=max{0,dj−Cj}, and the tardiness of job j is given byTj=max{0,Cj−dj},j=1,…,n. Following Adamopoulos and Pappis (1996a), the objective function consists of three cost components: earliness cost (where the unit cost is denoted by α); tardiness cost (where the unit cost is denoted by β); and the flow-allowance cost (where the unit cost is denoted by γ). If a job is early, then its cost contribution isαEj+γq, whereas a tardy job has a cost ofβTj+γq. (Its actual cost ismax{αEj+γq,βTj+γq}.) It follows that the cost of job j isαEj+βTj+γq, and the objective (of a minsum type) is :(1)Z=∑j=1n(αEj+βTj+γq).The minmax objective (see Mor & Mosheiov, 2012b) is:(2)Z=max1≤j≤n{max{αEj+γq,βTj+γq}}.As mentioned, we further extend the problem to a setting of due-windows, where jobs completed within their window are not penalized. The due-window of jobj(j=1,…,n)is denoted by[dj(1),dj(2)](dj(1)≤dj(2)), wheredj(1)=pj+q(1),j=1,…,n,dj(2)=pj+q(2),j=1,…,n.q(1) and q(2) are decision variables, and q(1) ≤ q(2). Note that, while the due-windows are job-dependent, their size is identical for all jobs:q(2)−q(1). The new form of the objective function contains additional cost parameters: γ is the unit cost of delaying the window, and δ is the unit cost of increasing the window size (see e.g. Liman et al., 1998). The minsum objective function becomes:(3)Z=∑j=1n(αEj+βTj+γq(1)+δ(q(2)−q(1))).The minmax objective becomes:(4)Z=max1≤j≤n{max{αEj+γq(1)+δ(q(2)−q(1)),βTj+γq(1)+δ(q(2)−q(1))}}.(For convenience, the due-date assignment and the due-window assignment problems with a minsum objective are denoted Problem 1 and Problem 2, respectively. Similarly, the due-date assignment and the due-window assignment problems with a minmax objective are denoted Problem 3 and Problem 4, respectively.).We focus first on the case that γ ≥ β. In this trivial case, the tardiness cost is smaller than the flow-allowance cost, implying thatq=0is optimal. [Note that forq=0the cost component γq has a value of zero, and only the βTjcost is relevant since all the jobs (excluding the first which is completed on time) are tardy.] It is easily verified that the optimal job sequence is SPT (Shortest Processing Time first), and the optimal cost is given byβ∑j=1n(m+n−j−1)pj. Hence, we assume in the following that γ < β.We start by proving two properties which were shown to be valid for an optimal schedule in the case of a single machine (Adamopoulos & Pappis, 1996a). Specifically, for a given sequence, if a job is tardy then all its successors are tardy, and if a job is early, then all its predecessors are early. For convenience, we assume that the indices of the jobs are renumbered according to the job sequence. [In the following, Property 1.j,j=1,…,6denotes Property j of an optimal solution of Problem 1: due-date assignment and a minsum objective.].Property 1.1If a given job is tardy (not early), then its successor is tardy (not early):Cj≥dj⇒Cj+1≥dj+1,j=1,…,n−1.ProofRecall that the completion time of job j is the completion time of its last operation (on machine m):Cj=Cmj.It is sufficient to show that:(Cj+1−dj+1)−(Cj−dj)>0.((m−1)max1≤i≤j+1{pi}+∑i=1j+1pi−(pj+1+q))−((m−1)max1≤i≤j{pi}+∑i=1jpi−(pj+q))=(m−1)(max1≤i≤j+1{pj}−max1≤i≤j{pj})+pj≥0.□Property 1.2If a given job is early (not tardy), then its predecessor is early (not tardy):Cj≤dj⇒Cj−1≤dj−1,j=1,…,n−1.Proofit is sufficient to show that:(Cj−dj)−(Cj−1−dj−1)>0.((pj−1+q)−(m−1)max1≤i≤j−1{pi}−∑i=1j−1pi)−((pj+q)−(m−1)max1≤i≤j{pi}−∑i=1jpi)=(m−1)(max1≤i≤j{pj}−max1≤i≤j−1{pj})+pj−1≥0.□In the single machine case, it was shown that q is equal to the sum of processing times of a number of jobs (say k), i.e.,q=Ck. This property is not necessarily valid for the case of a proportionate flowshop. [Consider for example the following data:m=4,n=3,p={24,37,45},α=5,β=40,γ=23.It can be easily verified that the (only) optimal sequence is (1, 2, 3) withk=2,q*=135andZ*=12,070.The value of q* is not equal to any of the jobs completion times.] However, it can be shown that q* coincides with a job starting time on the last machine. [In the above example, q* is equal to the starting time of the job in the second position (which is larger than the completion time of the first scheduled job due to idle time between these jobs):q*=135=24+3*37=S2.].Property 1.3An optimal schedule exists in whichq=Skfor some k.ProofConsider an optimal schedule withSk−1<q<Skfor some k. Job k is now a tardy job sinceCk=Sk+pk>q+pk=dk, and following Property 1.1, all the succeeding jobs in positionsk+1,…,nare tardy. Since,dk−1=q+pk−1>Sk−1+pk−1=Ck−1, jobk−1is an early job, and following Property 1.2, all the preceding jobs, i.e. the jobs in positions1,…,k−2are early.We now check the impact of decreasing q by a small amount of Δ > 0 units of time. The change in the total cost (see (1)) is given by:ΔZ=Δ[−α(k−1)+β(n−(k−1))−nγ].Similarly, the change in the total cost as a function of increasing q by Δ units of time is given by−ΔZ.Since Z is a linear function of Δ, it reaches its minimal value either whenΔ=0(i.e.,q=Sk−1),orΔ=pk−1+(m−1)(max1≤j≤k{pj}−max1≤j≤k−1{pj}),i.e.q=Sk.□[It is clear that if there are no idle times between consecutive jobs on the last machine prior to job k, then q is also equal to the completion time of some job, similar to the single machine case.].From the above, we conclude that:Corollary 1If job k is on time (i.e.,q=Sk) all the preceding jobs (in positions1,…,k−1) are early, and all the succeeding jobs (in positionsk+1,…,n) are tardy.Next, we find the index of the on-time job (k), in a similar way to that of Adamopoulos and Pappis (1996a).Property 1.4The index of the on-time job is(5)k=⌈n(β−γ)α+β⌉.ProofFor an arbitrary sequence, ifq=Sk, the total cost is given by:Z=∑j=1n(αEj+βTj+γq)=∑j=1k−1αEj+∑j=k+1nβTj+nγq=∑j=1k−1α(dj−Cj)+∑j=k+1nβ(Cj−dj)+nγq=∑j=1k−1α(pj+q−Cj)+∑j=k+1nβ(Cj−pj−q)+nγq.By differentiating Z with respect to q and equating to zero, we get,∂Z∂q=∑j=1k−1α−∑j=k+1nβ+nγ=0.It follows that:(k−1)α−(n−k)β+nγ=0, leading to:k=n(β−γ)α+β+αα+βConsider now an arbitrary sequence withSk<q<Sk+1. As above, it is easy to verify that all the jobs in positions1,…,k(including job k) are early, and all the jobs in positionsk+1,…,nare tardy. The total cost is given by:Z=∑j=1kα(pj+q−Cj)+∑j=k+1nβ(Cj−pj−q)+nγq.Following the same procedure, we obtain∂Z∂q=∑j=1kα−∑j=k+1nβ+nγ=0,kα−(n−k)β+nγ=0,andk=n(β−γ)α+β.Sincen(β−γ)α+β≤k≤n(β−γ)α+β+αα+β, we conclude that,k=⌈n(β−γ)α+β⌉.□Note that since we assume here that β > γ, k is non-negative. If k obtains a value larger than n, clearly its actual value is n. Note also that based on Property 1.4, the number of early (tardy) jobs is identical to the number of early (tardy) jobs in the single machine case.Property 1.5An optimal schedule exists in which the early jobs are sequenced in LPT (Longest Processing Time first) order, and the tardy jobs are sequenced in SPT (Shortest Processing Time first) order.ProofBy a pair-wise interchange argument. We focus first on the early jobs. Consider an optimal schedule q1, where the early jobs are not LPT. Let x and y denote the first pair of consecutive jobs sequenced not according to LPT: job x is in position i, job y is in positioni+1, and py> px. Let Ej(q1) denote the earliness value of job j in schedule q1.Ex(q1)+Ey(q1)=dx−Cx+dy−Cy=[px+q−(∑j=1i−1pj+px+(m−1)max{max1≤j≤i−1{pj},px})]+[py+q−(∑j=1i−1pj+px+py+(m−1)max1≤j≤i+1{pj})].Let q2 denote the sequence obtained by replacing the positions of jobs x and y.Ey(q2)+Ex(q2)=dy−Cy+dx−Cx=[py+q−(∑j=1i−1pj+py+(m−1)max{max1≤j≤i−1{pj},py})]+[px+q−(∑j=1i−1pj+py+px+(m−1)max1≤j≤i+1{pj})].It follows that:Ex(q1)+Ey(q1)−(Ey(q2)+Ex(q2))=py−px+(m−1)[max{max1≤j≤i−1{pj},py}−max{max1≤j≤i−1{pj},px}]>0.Consider now an optimal schedule q1, where the tardy jobs are not SPT. As above, let x (in position i) and y (in position j) denote the first pair of consecutive jobs sequenced not according to SPT (py< px). Let Tj(q1) denote the tardiness value of job j in schedule q1.Tx(q1)+Ty(q1)=Cx−dx+Cy−dy=[(∑j=1i−1pj+px+(m−1)max{max1≤j≤i−1{pj},px})−(px+q)]+[(∑j=1i−1pj+px+py+(m−1)max1≤j≤i+1{pj})−(py+q)].After replacing the positions of jobs x and y we obtain:Ty(q2)+Tx(q2)=Cy−dy+Cx−dx=[(∑j=1i−1pj+py+(m−1)max{max1≤j≤i−1{pj},py})−(py+q)]+[(∑j=1i−1pj+py+px+(m−1)max1≤j≤i+1{pj})−(px+q)].It follows that:Tx(q1)+Ty(q1)−(Ty(q2)+Tx(q2))=px−py+(m−1)[max{max1≤j≤i−1{pj},px}−max{max1≤j≤i−1{pj},py}]>0.□In the next property we refer to positional weights. Now it seems convenient to define p[j] to be the processing time of the job assigned to positionj,j=1,…,n. Based on Property 1.5, the optimal sequence is V-shaped. Thus, for a given V-shaped sequence, let r denote the position of the last job in the sequence (r ≥ k), which is not larger than the processing time of the job assigned to position 1, i.e.,r=maxj≥k{j:p[j]≤p[1]}. [Clearly,p[r+1]>p[1].] It follows that the first r jobs are scheduled with no idle times between them on the last machine (since the first job is the largest). It is easy to verify that the following (larger) jobs in positionsr+1,…,n, are scheduled in SPT order with idle times between them. Given these observations, we introduce in the following "pseudo" positional weights (dependent on r). The positional weights of positions2,3,…,r(which are identical to those obtained for the single machine case) will be used in our proposed solution procedure. [We note that the positional weights for the single machine case given in Adamopoulos and Pappis (1996a) contain a minor mistake. We refer the reader to Appendix A for the correction.] Letwj,j=1,…,ndenote these positional weights. Then,Property 1.6For a given r, the positional weights are given by:(6)wj={α−β(m−1)(n−r)+nγm,j=1αj+nγ,j=2,…,k−1β(n−j),j=k,…,rβ(n−j)+β(m−1),j=r+1,…,nProofFrom the optimality of the V-shape, it is clear that r ≥ k. Since p[1] ≥ p[r], as mentioned, there is no idle time between the jobs in positions1,…,r. Thus,Z=α[∑j=1k−1jp[j]]+β[∑j=kr(n−j)p[j]]+β[∑j=r+1n(n−j)p[j]+(m−1)∑j=r+1n(p[j]−p[1])]+nγ[∑j=1k−1p[j]+(m−1)p[1]].Note that the first term reflects the earliness cost of the firstk−1jobs, the second term reflects the tardiness cost of the jobs in positionsk,k+1,…,r(scheduled with no idle times), the third term reflects the tardiness cost of the jobs scheduled in positionsr+1,…,n(scheduled with idle times between them), and the fourth term is the cost of the flow allowance.Z=[α∑j=1k−1jp[j]+β∑j=kn(n−j)p[j]+nγ∑j=1k−1p[j]]+[β(m−1)∑j=rn(p[j]−p[1])+nγ(m−1)p[1]].Thus, if wjis the positional weight of job j, we obtain:wj={α−β(m−1)(n−r)+nγm,j=1αj+nγ,j=2,…,k−1β(n−j),j=k,…,rβ(n−j)+β(m−1),j=r+1,…,n□By the definition of r and the V-shape property, the processing times of the jobs in positions2,3,…,r, are smaller (not larger) than that of the job in position 1, and the processing time of the job in position 1 is smaller (not larger) than that of the jobs in positionsr+1,…,n. It follows that for a given r value, the sequence is completely determined. First, the smallest jobs are scheduled in positions2,3,…,r. Note again that their positional weights (Property 1.6) are identical to the positional weights obtained (for these positions) for the single machine case. Then, the next largest job is assigned to position 1. Finally, the remaining jobs are assigned to the last positions.Thus, a solution algorithm starts with solving the single machine case (and as a result obtaining the values of k and the positional weights). Then we consider all r values:r=k,…,n. For a given r value, as explained above, the candidate sequence consists of: (i) a block of the smallest jobs in positions2,…,r(determined by weights obtained for the single machine problem); (ii) the next largest job is assigned to position 1; (iii) the remaining (largest) jobs are scheduled in a non-decreasing order in positionsr+1,…,n. The best of these (at most n) candidates is the optimal solution. A pseudo-code of the algorithm is the following:Theorem 1Algorithm 1solves the minsum due-date assignment case in O(n2) time.ProofOptimality is guaranteed since all candidates for optimality (i.e., the V-shaped sequences, see the above discussion) are covered. The initial solution of the single machine case (Step 1) requires O(nlog n) time. In Step 2, there are no more than n iterations, and the calculation of the cost of the sequence at each iteration is performed in O(n) time. Thus, the total running time is O(n2).□We refer the reader to Appendix B, for a numerical example (Example 1) demonstrating the use of Algorithm 1.The popular extension to a setting of due-windows reflects the commonly considered option of a time interval for delivery with no penalty. As mentioned, this job-dependent interval is denoted by[dj(1),dj(2)](dj(1)≤dj(2)), wheredj(1)=pj+q(1),anddj(2)=pj+q(2),j=1,…,n.[q(1) and q(2)( ≥ q(1)) are decision variables.]The objective function is minimum total earliness, tardiness, due-window starting time and size; see (3). The following properties of an optimal schedule are similar to those proved above for the due-date case, and are brought here with no proofs (which are similar to those provided above). We also refer the reader to Mosheiov and Oron (2010), for the proofs in the case of a single machine. [As above, Property 2.j denotes Property j of an optimal schedule of Problem 2: due-window assignment and a minsum criterion.]Property 2.1If a given job is tardy (not early), then its successor is tardy (not early):Cj≥dj(2)⇒Cj+1≥dj+1(2),j=1,…,n−1.Property 2.2If a given job is early (not tardy), then its predecessor is early (not tardy):Cj≤dj(1)⇒Cj−1≤dj−1(1),j=1,…,n−1.Property 2.3An optimal schedule exists in whichq(1)=Skfor some k, andq(2)=Slfor some l, l ≥ k.Property 2.4The indices of the jobs defined in Property 2.3. are:(7)k=⌈n(δ−γ)α⌉andl=⌈n(β−δ)β⌉.[Clearly, if either k or l obtain negative values, their actual value is zero. Similarly, if either k or l obtain values larger than n, their actual value is n. If we obtain a k-value larger than l, it follows thatk=l(the due-window is reduced to a due-date). We will focus here on the general case of a due-window of a positive size: 0 < k < l < n.].Property 2.5An optimal schedule exists in which the early jobs (processed prior to their due-window) are sequenced in LPT, and the tardy jobs (processed after their window) are sequenced in SPT.In order to calculate the positional weights, we follow the procedure described in Section 3. Here r denotes the position of the last job in the sequence (r ≥ l), which is not larger than the processing time of job assigned to position 1, i.e.,r=maxj≥l{j:p[j]≤p[1]}. [Again,p[r+1]>p[1].] As above, the first r jobs are scheduled with no idle times between them on the last machine, and the following jobs are scheduled in positionsr+1,…,nin SPT order (with idle times between them). The total cost is given by:Z=α[∑j=1k−1jp[j]]+β[∑j=lr(n−j)p[j]]+β[∑j=r+1n(n−j)p[j]+(m−1)∑j=r+1n(p[j]−p[1])]+nγ[∑j=1k−1p[j]+(m−1)p[1]]+nδ[∑j=kl−1p[j]].Thus, the “pseudo” positional weights (dependent on r) are the following:Property 2.6For a given r, the positional weights are given by:(8)wj={α−β(m−1)(n−r)+nγm,j=1αj+nγ,j=2,…,k−1nδj=k,…,l−1β(n−j),j=l,…,rβ(n−j)+β(m−1),j=r+1,…,nBased on all the properties we propose the following algorithm. We start with solving the single machine case (and as a result obtaining the values of k, l and the positional weights). Then we consider all r values:r=l,…,n. As above, for a given r value, the candidate sequence contains job r in position 1, a block of the smallest jobs in positions2,…,r(determined by the positional weights obtained for the single machine problem), and the remaining large jobs in SPT order in positionsr+1,…,n. The best of these candidates is clearly the optimal solution. A pseudo-code (which is similar to the one proposed for the case of due-date assignment) is the following:Theorem 2Algorithm 2solves the minsum due-window assignment case in O(n2) time.ProofAs above, optimality is guaranteed since all candidate V-shaped sequences are checked. After the solution of the single machine problem in Step 1 (requiring running time of O(nlog n)), Step 2 contains at most n iterations, and the effort per iteration is O(n) time. Thus, the total running time remains O(n2).□We refer the reader to Appendix B, for a numerical example (Example 2) demonstrating the use of Algorithm 2.There are two major differences between the minmax version studied in this section and the minsum version studied earlier. First, as many scheduling problems of a minmax type, it can be formulated as a linear program (LP), where a variable representing the cost is minimized, subject to a set of constraints guarantying that its value is not smaller than that of each individual job. Secondly, a different definition of q is more appropriate:dj=mpj+q,j=1,…,n, to reflect the extended waiting time,(m−1)pj, of the last operation of job j (on the last machine) if job j is scheduled first. As above, we assume that the jobs are renumbered according to their position in the sequence. It follows that the problem (for a given job sequence) can be formulated as the following LP:(9)minZs.t.Z≥αEk+γq=α(dk−Ck)+γq=α[(mpk+q)−(∑j=1kpj+(m−1)max1≤j≤k{pj})]+γq=(α+γ)q−α(∑j=1k−1pj+(m−1)(max1≤j≤k{pj}−pk)),k=1,…,n,(10)Z≥βTk+γq=β(Ck−dk)+γq=β[(∑j=1kpj+(m−1)max1≤j≤k{pj})−(mpk+q)]+γq=(γ−β)q+β(∑j=1k−1pj+(m−1)(max1≤j≤k{pj}−pk)),k=1,…,n,Z,q≥0.Note that the set of constraints (9) guarantees that the cost is at least as large as the earliness (plus flow allowance) cost of each job, and the set of constraints (10) guarantees that the cost is at least as large as the tardiness (plus flow allowance) cost of each job.An important property of an optimal schedule for the minmax single machine version (see Mor & Mosheiov, 2012b) refers to the monotonicity of the earliness and tardiness costs. Specifically, in a single machine setting it can be shown that for any given j, if job j is early, then the earliness cost of its predecessor is larger (not smaller), and if job j is tardy, its successor has a larger (not smaller) tardiness cost. It is easy to see (by simple counter examples) that these two properties are not valid any more in our proportionate flowshop setting. However, we prove in the following two weaker claims regarding the earliness of the first scheduled job. [In this Section, Property 3.j denotes Property j of an optimal schedule of Problem 3: due-date assignment and a minmax criterion.].Property 3.1The earliness of the job scheduled in the first position is equal to q.ProofE(1)=d1−C1=mp1+q−mp1=q.Property 3.2The job scheduled in the first position has the largest earliness cost, i.e.,E1≥Ek,k=2,…,n.ProofEk=(mpk+q)−(∑j=1kpj+(m−1)*max1≤j≤k{pj}),k=1,…,n.Ek=q−(m−1)(max1≤j≤k{pj}−p(k))−∑j=1k−1pj,k=1,…,n.We have to show that for any givenk(k=1,…,n):q≥q−(m−1)(max1≤j≤k{pj}−pk)−∑j=1k−1pj.This is true since pk≤ max 1 ≤ j ≤ k{pj} for any k value.□Given Property 3.2, the problem can be formulated as the following simpler LP, denoted by LP1:(11)minZs.t.Z≥αE1+γq=(α+γ)q,(12)Z≥βTk+γq=β[(∑j=1kp(j)+(m−1)*max1≤j≤k{p(j)})−(mp(k)+q)]+γq,k=1,…,n,Z,q≥0.Based on the above, we prove in the following a much stronger property:Property 3.3An optimal schedule exists which is SPT (Shortest Processing Time first).ProofAssume that an optimal schedule π1 is not SPT. Thus, let k and l denote the first pair of consecutive jobs sequenced not according to SPT: job k is in position (i), job l is in position(i+1), andmax1≤j≤i−1{pj}≤pl<pk. LetP(i−1)=∑j=1i−1pj.The cost contribution of jobs k and l in π1:Zπ1(k,l)=max{α[(mpk+q)−(P(i−1)+mpk)]+γq,α[(mpl+q)−(P(i−1)+pl+mpk)]+γq}=max{α[q−P(i−1)]+γq,α[q−(P(i−1)+p(l)+m(pk−pl))]+γq}.Obtain a schedule π2 by a standard pair-wise interchange of jobs k and l:Zπ2(k,l)=max{α[(mpl+q)−(P(i−1)+mpl)]+γq,α[(mpk+q)−(P(i−1)+pl+mpk)]+γq}=max{α[q−P(i−1)]+γq,α[q−(P(i−1)+pl)]+γq}.We prove thatZπ1(k,l)≥Zπ2(k,l)by showing thatα[q−P(i−1)]+γq≥max{α[q−P(i−1)]+γq,α[q−(P(i−1)+pl)]+γq}.The latter is true due to:(i)α[q−P(i−1)]+γq=α[q−P(i−1)]+γq;α[q−P(i−1)]+γq≥α[q−(P(i−1)+pl)]+γq(since, pl> 0).It follows that π2 is optimal as well, which completes the proof.□Based on Property 3.3, the following further simplification of LP1 is possible:minZs.t.Z≥(α+γ)q,Z≥(γ−β)q+β∑j=1k−1pj,k=1,…,n,Z,q≥0.Since the sequence of partial sums∑j=1k−1pj,k=1,…,n, is non-decreasing in k, the maximum value (and thus the dominant constraint) is obtained fork=n. Clearly,max1≤k≤n{∑j=1k−1pj}=∑j=1npj−pn. Note that since the jobs are sequenced in SPT order,∑j=1npj−pn=P−pmax.Thus, a further reduction is possible, and the final version of LP1 contains only two constraints:minZs.t.Z≥(α+γ)q,Z≥(γ−β)q+β(P−pmax),Z,q≥0.The optimal solution of LP1 depends on the relations between the tardiness unit cost and the unit cost of flow allowance. Specifically:Case 1: γ ≤ β.q* and Z* are obtained in the intersection of the constraints:(α+γ)q=(β−γ)q+β(P−pmax).Thus, the optimal values of the flow-allowance and the objective function are:(13)q*=β(P−pmax)α+β;(14)Z*=q*(α+γ).Case 2: γ > β.In this case it is clear thatq=0minimizes the right-hand-side of both constraints and all the jobs are tardy:(15)q*=0;(16)Z*=β(P−pmax).The final solution procedure is summarized below:Theorem 3Algorithm 3solves the minmax due-date assignment case in O(nlog n) time.ProofIt is clear that the optimal solution (SPT sequence and due-date assignment based either on Case 1 or on Case 2) is obtained by Algorithm 3. The total running time is O(nlog n) due to the initial sorting of the jobs.□We refer the reader to Appendix B, for a Numerical Example 3 demonstrating the use of Algorithm 3.Following Section 4, we extend the setting to a due-window, and denote the due-window of jobj(j=1,…,n)by[dj(1),dj(2)]. Following the definition of the due-date given in Section 5, we define here:dj(1)=mpj+q(1)anddj(2)=mpj+q(2),j=1,…,n,where q(1) and q(2) are decision variables, and q(1) ≤ q(2). Recall that the due-windows are job-dependent, but have identical size (q(2)−q(1)). The minmax objective function for this version is(17)Z=max1≤j≤n{max{αEj+γq(1)+δ(q(2)−q(1)),βTj+γq(1)+δ(q(2)−q(1))}}It follows that the linear program for the case of a due-window, denoted by LP2, is:(18)minZs.t.Z≥αEk+γq(1)+δ(q(2)−q(1))=α(dk(1)−Ck)+γq(1)+δ(q(2)−q(1))=α[(mpk+q(1))−(∑j=1kpj+(m−1)max1≤j≤k{pj})]+γq(1)+δ(q(2)−q(1))=(α+γ−δ)q(1)+δq(2)−α(∑j=1k−1pj+(m−1)(max1≤j≤k{pj}−pk)),k=1,…,n,(19)Z≥βTk+γq(1)+δ(q(2)−q(1))=β(Ck−dk(2))+γq(1)+δ(q(2)−q(1))=β[(∑j=1kpj+(m−1)max1≤j≤k{pj})−(mpk+q(2))]+γq(1)+δ(q(2)−q(1))=(γ−δ)q(1)+(δ−β)q(2)+β(∑j=1k−1pj+(m−1)(max1≤j≤k{pj}−pk)),k=1,…,n,q(2)≥q(1),Z,q(1),q(2)≥0.It can be easily shown that Properties 3.1 and 3.2 proved for the due-date case (Section 5) still hold for the case of a due-window. Moreover, a standard pair-wise interchange argument proves that Property 3.3 (the optimality of SPT, proved in Section 5) remains valid. Based on Properties 3.1, 3.2 and the optimality of SPT, we state in the following two slightly stronger properties, focusing on the cost contribution of the first and last scheduled jobs. [In the following, Property 4, j denotes property j of an optimal schedule of Problem 4: due-window assignment and a minmax criterion.] Property 4.1 follows immediately from Properties 3.1 and 3.2.Property 4.1The maximum (total) earliness cost (i.e.,αEk+γq(1)+δ(q(2)−q(1))) is obtained by the job assigned to the first position.Property 4.2The maximum (total) tardiness cost (i.e.,βTk+γq(1)+δ(q(2)−q(1))) is obtained by the job assigned to the last position.ProofFrom Property 3.3, it is clear thatmax1≤j≤k{pj}−pk=0,k=1,…n, implying that,Z≥βTn+γq(1)+δ(q(2)−q(1))=(γ−δ)q(1)+(δ−β)q(2)+β∑j=1n−1pj≥βTk+γq(1)+δ(q(2)−q(1))=(γ−δ)q(1)+(δ−β)q(2)+β∑j=1k−1pj,k=1,…,n.□Thus, linear program LP2 is reduced to the following program:(20)minZs.t.Z≥αE1+γq(1)+δ(q(2)−q(1))=(α+γ−δ)q(1)+δq(2),(21)Z≥βTn+γq(1)+δ(q(2)−q(1))=q(1)(γ−δ)+q(2)(δ−β)+β(P−pmax),q(2)≥q(1),Z,q(1),q(2)≥0.LP2 is similar to the linear program obtained for the single machine case (see Mor & Mosheiov, 2012b). Since the cost function is linear in both q(1) and q(2), in an optimal solution, these two variables get one of their extreme values. Thus, q1 gets either its smallest possible value (zero), or its maximum possible value (q(2)), and q(2) gets either its minimal value (q(1)or its maximum value (P−pmax). It follows that the optimal size of the due-window is either the maximum possible, (i.e.,P−pmax), or the minimum possible (i.e., zero, when the window is, in fact, reduced to a due-date). Specifically, we have the following options:Case 1 (maximum size):q(1)=0andq(2)=P−pmax.Substituting these values in constraints (20) and (21) leads to the following optimal cost value:Z=δq(2)=δ(P−pmax).Case 2 (reduction to a due-date):Subcase 2.1:q=q(1)=q(2)=0. (Minimal q value.)The resulting cost is:Z=β(P−pmax).Subcase 2.2:0<q=q(1)=q(2)<P−pmax.The intersection of constraints (20) and (21) leads to the following value:q=q(1)=q(2)=β(P−pmax)α+β.The resulting cost is:Z=(α+γ)q.Subcase 2.3:q=q(1)=q(2)=P−pmax. (Maximal q value.)The resulting cost is:Z=(α+γ)q.Given these four candidates for optimality, it is clear that there is no need to solve LP2. One should simply check all four cases and choose the due-window that produces minimum cost.Thus, the solution procedure for the case of a due-window is the following:Theorem 4Algorithm 4solves the minmax due-window assignment case in O(nlog n) time.ProofOptimality is guaranteed by the SPT job sequence and due-window assignment based on one of the four possible cases. Regarding the running time: Step 1 requires O(nlog n) time, and Step 2 is performed in constant time, implying a total running time is O(nlog n).□Again, we refer the reader to Appendix B, for a Numerical Example 4 demonstrating the use of Algorithm 4.

@&#CONCLUSIONS@&#
