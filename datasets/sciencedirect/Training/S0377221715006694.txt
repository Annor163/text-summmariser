@&#MAIN-TITLE@&#
Improved max-flow min-cut algorithms in a Circular Disk Failure Model with application to a road network

@&#HIGHLIGHTS@&#
We consider the max-flow and min-cut problems under the Circular Disk Failure Model.We improve the existing algorithms for these problems.We apply our algorithms to a road network in NewYork consisting of 264,346 nodes.

@&#KEYPHRASES@&#
Combinatorial optimization,Networks,Reliability,Graph theory,

@&#ABSTRACT@&#
In the evaluation of network reliability, the objectives are to model reliability of networks appropriately and to compute it in a realistic time. We can consider various models of reliability of networks, and Bienstock (1991) first introduced a geographical failure model where each failure is represented by a 2-dimensional region. In this model, we consider the situation that geographical networks such as road networks may be damaged by externally caused disasters, and such disasters may destroy several links of the networks simultaneously, rather than each link independently. Recently, Neumayer–Efrat–Modiano (2012) investigated the max-flow problem and the min-cut problem under the Circular Disk Failure Model, in which the shape of each failure is restricted to be a disk. Under this model, Kobayashi–Otsuki (2014) gave polynomial time algorithms to find optimal solutions of these two problems. In this paper, we improve the algorithms and evaluate their performance by computational experiments. Although our improvements work only when the max-flow value is equal to the min-cut value, this condition holds in almost all practical cases. Owing to the improvements, we can find in a realistic time optimal solutions of the max-flow problem and the min-cut problem in large networks under the Circular Disk Failure Model. As a realistic instance, we analyze reliability of a road network in NewYork consisting of 264,346 nodes.

@&#INTRODUCTION@&#
Recently, with the development of various networks such as road networks and the Internet, there is urgent need to evaluate reliability of large networks. In the evaluation of reliability, the crucial points are how to model reliability of networks appropriately and how to compute it in a realistic time. We can conceive various ways to formulate reliability of networks (see e.g. Habib, Tornatore, Dikbiyik, & Mukherjee, 2013), but a complicated formulation of reliability would make it hard to design an efficient algorithm for computing reliability.In most previous studies, connectivity of networks is regarded as one of the most significant factors of network reliability, where connectivity is defined as the minimum number of link-failures (or node-failures) that disconnect the network. Connectivity is a simple and natural model for reliability of networks, and an advantage of using connectivity is that we have efficient algorithms for computing it (see Schrijver, 2003). In particular, there are many studies on the problem of finding a minimum number of link-failures that disconnect two specified nodes s and t (which we call the min-cut problem) and its dual problem called the max-flow problem. It is known as the max-flow min-cut theorem (Ford & Fulkerson, 1956; Menger, 1927) that the optimal values of the min-cut problem and the max-flow problem are equal, and the proof of this theorem leads to algorithms for these two problems. Since then, many faster algorithms for the max-flow problem and the min-cut problem have been proposed (see Schrijver, 2003), and currently we can solve these problems for huge networks in a realistic time.In this paper, we consider variants of the max-flow problem and the min-cut problem, motivated by modeling geographical failures on geographical networks such as road networks. Geographical networks may be damaged by externally caused disasters like earthquakes or floods. Such disasters, occurring in specific geographical regions, may often destroy several links of the networks simultaneously, rather than each link independently. In 1991, Bienstock (1991) first introduced a geographical failure model where each failure is represented by a 2-dimensional region. Recently, various models which takes such region failures into consideration have been drawing a great deal of attention (Agarwal, Efrat, Ganjugunte, Hay, Sankararaman, & Zussman, 2013; Neumayer & Modiano, 2010; Neumayer, Zussman, Cohen, & Modiano, 2011; Saito, 2015; Sen, Murthy, & Banerjee, 2009; Trajanovski, Kuipers, & Mieghem, 2013). In particular, Neumayer, Efrat, and Modiano (2012) adopted the Circular Disk Failure Model for the max-flow problem and the min-cut problem, where each failure is represented by a disk with a predetermined size. This model can be regarded as a special case of Bienstock’s model, in which the shape of each failure is restricted to be a disk. Under that model, the min-cut problem is to find a minimum number of disk failures that disconnect two specified nodes s and t of the given planar graph G, and the max-flow problem is to find a maximum number of s-t paths such that no disk failure intersects a pair of these paths.Under the Circular Disk Failure Model, Neumayer et al. (2012) gave a polynomial time min-cut algorithm and Kobayashi and Otsuki (2014) gave a polynomial time max-flow algorithm. A faster and simpler min-cut algorithm was also given in Kobayashi and Otsuki (2014). However, as we can see in 9th DIMACS Implementation Challenge — Shortest Paths, many of real road networks consist of more than 100,000 nodes, which are too huge for the aforementioned algorithms to solve in a realistic time.In this paper, we improve the max-flow algorithm and the min-cut algorithm given in Kobayashi and Otsuki (2014), and evaluate the performance of these algorithms by computational experiments. Although our improvements work only when the max-flow value is equal to the min-cut value, this condition holds in almost all practical cases (see Section 2 for details). Owing to the improvements, now we can find in a realistic time optimal solutions of the max-flow problem and the min-cut problem under the Circular Disk Failure Model in huge networks consisting of more than 100,000 nodes. As a practical instance, we analyze reliability of a road network in NewYork (9th DIMACS Implementation Challenge — Shortest Paths) with 264,346 nodes. We can solve the problems in the network in about 30 seconds on a computer with Intel Core i7, 2.8 GigaHertz and 8 Gigabyte of memory, while it takes about 3 hours by the existing algorithms.The remainder of this paper is organized as follows. In Section 2, we give formal descriptions of the problems with some mathematical definitions. In Sections 3 and 4, we describe our improvements of the max-flow algorithm and the min-cut algorithm, respectively. In Section 5, we evaluate the performance of our algorithms and apply our algorithms to the road network in NewYork. Finally, in Section 6, we conclude this paper.LetG=(V,E)be a graph drawn in the plane with a node set V, a link set E, and two distinct nodes s, t ∈ V. Throughout this paper we assume that each link is drawn as a line segment, and a link is sometimes called an edge. Each region surrounded by links is called a face of G, where we note that the outer infinite region is also a face. Let rB be a hole radius, where each hole represents a failure of the network. We consider two disks of another radius rP whose centers are s and t, respectively. We call them protective disks and their radius rPprotective radius. DefineH(rB,rP)as the set of all disks of radius rB whose centers are not contained in the protective disks of radius rP. We call each element ofH(rB,rP)a hole in this paper. We shall think of each hole as a closed set, including its boundary.The geographical min-cut problem and the geographical max-flow problem introduced by Neumayer et al. (2012) are defined as below. Solutions of the problems represent connectivity of the graph between two nodes s and t under the Circular Disk Failure Model.Geographical Min-Cut by Circular Disasters (GMCCD)Input: a graphG=(V,E)drawn in the plane, two distinct nodes s and t, a hole radius rB, and a protection radius rP( > rB).Find: a minimum cardinality set of holes inH(rB,rP)that disconnect s from t.Geographical Max-Flow by Circular Disasters (GMFCD)Input: a graphG=(V,E)drawn in the plane, two distinct nodes s and t, a hole radius rB, and a protection radius rP( > rB).Find: a maximum cardinality set of s-t paths such that no hole inH(rB,rP)intersects a pair of these paths.It is pointed out in Kobayashi and Otsuki (2014) that most results for these problems can be extended to the case whereH(rB,rP)is replaced with a setHof convex shapes (holes) satisfying a certain property (see Concluding Remarks of Kobayashi and Otsuki (2014)). For example,Hcan be a set of disks of different sizes or a set of axis parallel squares. All the results in this paper can be extended to such cases, but, for simplicity, we focus on the case when each failure is inH(rB,rP).In what follows, we say that two s-t paths are hole-disjoint if there is no hole inH(rB,rP)that intersects both of them. Let MIN-CUT and MAX-FLOW denote the optimal values of the GMCCD and the GMFCD, respectively, and we call feasible solutions of the GMCCD and the GMFCD a hole cut and a hole-disjoint flow, respectively. The reason we introduce protective disks is that the GMCCD and the GMFCD will have trivial optimal solutions if a hole contains s or t. In terms of application, we can assume that s and t are well-protected so that no failure can occur nearby nodes s and t. Although it is impossible to protect a certain region completely in practical situations, we believe that the above problems are useful to evaluate the network reliability.Example 1Consider the graph as in Fig. 1. Small circles represent holes of radius rB and two large circles represent protective disks of radius rP. In the graph, we can easily see thatMAX-FLOW=1andMIN-CUT=2. The thick s-t path represents an optimal solution of the GMFCD, and two small circles represent an optimal solution of the GMCCD.This example is given in Neumayer et al. (2012) as an example to show thatMIN-CUT=MAX-FLOW,which is an analogy to Menger’s theorem, does not necessarily hold. Practically, however,MIN-CUT=MAX-FLOWholds in most cases. Indeed, it is claimed in Neumayer et al. (2012) that among 1000 randomly generated instances with 13 nodes,MIN-CUT=MAX-FLOWholds for 99 percent of the instances andMIN-CUT=MAX-FLOW+1holds for the remaining 1 percent. Later, it is proved in Kobayashi and Otsuki (2014) thatMAX-FLOW≤MIN-CUT≤MAX-FLOW+1holds for any instances.In this paper, we improve the existing polynomial time algorithms (Kobayashi & Otsuki, 2014) for the GMCCD and the GMFCD under the assumption thatMIN-CUT=MAX-FLOW. Although we need the extra assumption thatMIN-CUT=MAX-FLOWfor our improvements, this equality holds in almost all practical cases. Indeed,MIN-CUT=MAX-FLOWholds in a large practical network considered in Section 5, which motivates us to focus on the case meeting this assumption. Note that if this equality does not hold, then the proposed algorithm is the same as the one in Kobayashi and Otsuki (2014), which means that our algorithm can find an optimal solution correctly and conclude thatMIN-CUT=MAX-FLOW+1,although it requires much more running time.Here we introduce some mathematical definitions concerning the GMCCD and the GMFCD, following (Kobayashi & Otsuki, 2014). For any s-t path P, we think of P as being oriented from s to t, and denote byP−1the path oriented from t to s along s-t path P. For two s-t paths P′ and P′′ without crossings, let R(P′, P′′) denote the closed region encircled byP′·(P′′)−1in clockwise orientation, whereP′·(P′′)−1is the closed curve obtained by concatenating P′ and(P′′)−1. Let |R(P′, P′′)| be the number of faces of G contained in R(P′, P′′). For two s-t paths P′, P′′ without crossings, we call a pair (P′, P′′) clockwise hole-disjoint if for any holeH∈H(rB,rP),R(P′,P′′)−His connected. Note that if two s-t paths P′ and P′′ are hole-disjoint, (P′, P′′) is clockwise hole-disjoint, while the opposite is not always true. P′ and P′′ are hole-disjoint if and only if both pairs (P′, P′′) and (P′′, P′) are clockwise hole-disjoint.For a pair of edges e, e′ ∈ E, if there exists a holeH∈H(rB,rP)that intersects both edges, we take two pointswe,e′on e andwe′,eon e′ arbitrarily that are contained in hole H. Then, defineW:={we,e′,we′,e∣e,e′∈Econtainedinacommonhole}.Theoretically, |W| is obviously bounded by |E|2. In practical networks,|W|=O(|E|),that is,|W|=O(|V|),since there are only a small number of pairs that are close enough to be contained in a common hole inH(rB,rP).In this subsection, we review the algorithm for the GMFCD given by Kobayashi and Otsuki (2014). Algorithm 1 either finds pairwise hole-disjointk+1s-t paths or reports the non-existence of such s-t paths, under the assumption that we already have pairwise hole-disjoint k s-t paths.Lemma 1Kobayashi & Otsuki, 2014Suppose that we are given a graphG=(V,E)drawn in the plane, two distinct nodes s and t, a hole radius rB, and a protection radius rP( > rB). Moreover suppose that we have pairwise hole-disjoint k s-t pathsP1,⋯,Pk,and an s-t pathPk+1in R(Pk, P1) such that(Pk,Pk+1)is clockwise hole-disjoint. IfAlgorithm 1reports the non-existence of pairwise hole-disjoint k s-t paths, thenMAX-FLOW=k.An example of iterations in Algorithm 1 is shown in Fig. 2. Now, by using Algorithm 1 withk=1,2,⋯in order, an optimal solution of the GMFCD can be computed in polynomial time (see Algorithm 2).Theorem 2Kobayashi & Otsuki, 2014An optimal solution of the GMFCD can be computed in polynomial time.Lemma 1 implies that an optimal solution of the GMFCD can be computed by using Algorithm 1 withk=1,2,⋯in order at most |V| times (see Algorithm 2). For each k, the number of iterations in Algorithm 1 is at most |W|. Since each iteration runs in O(|W|) time, the total running time is O(k|W|2) (k ≔ MAX-FLOW), which is polynomial.□As pointed out in Kobayashi and Otsuki (2014), in most practical cases, the running time is O(|V|2) since k is small and|W|=O(|V|).We improve the max-flow algorithm (Algorithm 2) of Kobayashi and Otsuki (2014) in this subsection. As we reviewed in the previous subsection, the running time of the algorithm is O(|V|2) practically. The improvement does not change the theoretical computational time complexity; in other words, it still takes O(|V|2) time to solve the GMFCD in the worst case. Practically, however, the running time of the algorithm is decreased drastically in most cases, as we will see in Section 5.2.Recall that Algorithm 2 uses Algorithm 1 withk=1,2,⋯in order, where Algorithm 1 either finds pairwise hole-disjointk+1s-t paths or reports the non-existence of such s-t paths, under the assumption that we already have pairwise hole-disjoint k s-t pathsP1,⋯,Pk.Let k′ ≔ MAX-FLOW. The most time-consuming part of Algorithm 2 is Algorithm 1 withk=k′,which needs |W| iterations, whereas the total running time of Algorithm 1 withk=1,2,⋯,k′−1is much smaller since only a small number of iterations are necessary. Therefore, to improve the running time of Algorithm 2, we have to aim at improving Algorithm 1 withk=k′so that it needs a smaller number of iterations.Suppose that we have pairwise hole-disjoint k′ s-t pathsP1,⋯,Pk′. We note that it is sufficient to retain only k s-t pathsPl−k+1,⋯,Pl−1,Plin the lth iteration in Algorithm 1 withk=k′. Then, we show that ifPl+1=Pl−k+1holds in some k consecutive iterations indexed by l, it will hold in the following iterations (Theorem 3 below). For example, in Fig. 2,Pl+3=Plholds for l ≥ 4.This fact shows that ifPl+1=Pl−k+1holds in some k consecutive iterations in Algorithm 1, we can break iterations and terminate Algorithm 1 (see Algorithm 3).Theorem 3Algorithm 3, when used as a subroutine inAlgorithm 2in place ofAlgorithm 1, can find an optimal solution of the GMFCD.It is sufficient to show that if there exists an integer l such that•(Pl′,Pl′−k)is clockwise hole-disjoint, andPl′+1=Pl′−k+1forl′=l−k+1,l−k+3,⋯,lwhen Algorithm 1 is applied withk=MAX-FLOW,the above conditions also hold forl′=l+1,l+2,⋯,k+|W|+2.Consider the case ofl′=l+1. Since(Pl−k+1,Pl−2k+1)is clockwise hole-disjoint,Pl+1=Pl−k+1,andPl−k+1=Pl−2k+1,(Pl+1,Pl−k+1)is also clockwise hole-disjoint. FurthermorePl+2=Pl−k+2also holds sincePl−k+2=Pl−2k+2,Pl−k+3=Pl−2k+3,⋯,Pl+1=Pl−k+1.By applying this argument repeatedly,(Pl′,Pl′−k)is clockwise hole-disjoint andPl′+1=Pl′−k+1forl′=l+1,l+2,⋯,k+|W|+2.□The improvement that we gave in the previous subsection can reduce the running time of computing an optimal solution of the GMFCD only ifPl+1=Pl−k+1holds in some k consecutive iterations in Algorithm 3, wherek=MAX-FLOW. This naturally raises the question whether there always exists an integer l such thatPl′+1=Pl′−k+1forl′=l−k+1,⋯,lin Algorithm 3 withk=MAX-FLOW.The objective of this subsection is to show thatPl+1=Pl−k+2holds for sufficiently large l under the assumption thatMIN-CUT=MAX-FLOW. See Section 2 for the validity of this assumption. We mention that this question is for pure theoretical interest and that we can apply Algorithm 3 regardless of this issue.Theorem 4Suppose that we are given a graphG=(V,E)drawn in the plane, two distinct nodes s and t, a hole radius rB, and a protection radius rP( > rB). Moreover suppose thatMIN-CUT=MAX-FLOW. Then, even ifAlgorithm 3is modified so as not to stop after the iteration wherel=k+|W|+2and when the modified algorithm is applied withk=MAX-FLOW,there exists an integer l such thatPl′+1=Pl′−k+2forl′=l−k+1,⋯,l.SinceMIN-CUT=MAX-FLOW(=k),we can take a hole cut{H1,H2,⋯,Hk}of size k. By the definition of hole cuts, each ofP1,P2,⋯,Pkintersects at least one hole of{H1,H2,⋯,Hk}. Since k pathsP1,P2,⋯,Pkare pairwise hole-disjoint, no pairs of these paths intersect a single hole Hi. Therefore, each hole ofH1,H2,⋯,Hkintersects one path ofP1,P2,⋯,Pk,respectively. By changing the indices if necessary, suppose that path Piintersects hole Hifori=1,2,⋯,k. (see Fig. 3).For two s-t paths P′, P′′ that intersect a single hole H, we say “P′ is on the left side of P′′ with respect to H” if P′ and P′′ do not cross with each other, and two nodes s, t are disconnected inR(P′,P′′)−H. Then, fori=1,2,⋯,kand j ≥ 0, since pathPi+(j+1)kis inR(Pi+jk−1,Pi+jk)and bothPi+(j+1)kandPi+jkintersect hole Hi, pathPi+(j+1)kis on the left side of pathPi+jkwith respect to hole Hi(see Fig. 4).Fori=1,2,⋯,k,definegi(n):=∑j=1n−1|R(Pi+jk,Pi+(j−1)k)|.That is, gi(n) represents the total number of faces of G which sequence of pathsPi,Pi+k,⋯,Pi+(n−1)ktraverse starting from path Pi. IfPi+(n−1)kand Pido not cross each other,gi(n)=|R(Pi,Pi+(n−1)k)|≤|F(G)|holds, where F(G) is the face set of G. Even whenPi+(n−1)kand Picross each other, which happens indeed (see Fig. 4), they cross at most |Pi|( ≤ |V(G)|) times, and hencegi(n)≤|V(G)∥F(G)|holds for any n. Here we definef(n):=∑i=k+1n|R(Pi,Pi−k)|forn≥k+1. Then, sincef(n)=∑i=1kgi(n′)≤k|V(G)∥F(G)|forn=n′k,f(n) ≤ k|V(G)||F(G)| also holds for any n ≥ k.Since f is an integer-valued non-decreasing function, there exists an integer l such thatf(l′+1)=f(l′)forl′=l−k+1,⋯,l. That is,Pl′+1=Pl′−k+1holds forl′=l−k+1,⋯,l.□The above proof shows that Algorithm 3 terminates after at mostk2|V(G)∥F(G)|+1iterations. Since the bound is finite, a sort of “convergence property” of the hole-disjoint max-flow algorithm is ensured theoretically under the assumption thatMIN-CUT=MAX-FLOWholds. Practically, Algorithm 3 completes iterations after about 10–50 iterations in most cases, and hence the running time of the algorithm is decreased drastically in most cases (see Section 5.2).In this subsection we review the polynomial min-cut algorithm for the GMCCD given in Kobayashi and Otsuki (2014). The following theorem ensures that eitherMIN-CUT=MAX-FLOWorMIN-CUT=MAX-FLOW+1holds, which plays a significant role in the min-cut algorithm.Theorem 5Kobayashi & Otsuki, 2014Suppose that we are given a graphG=(V,E)drawn in the plane, two distinct nodes s and t, a hole radius rB, and a protection radius rP( > rB). Then,MAX-FLOW≤MIN-CUT≤MAX-FLOW+1.Moreover, we can compute a hole-cut whose size is at mostMAX-FLOW+1in polynomial time.This theorem implies that in order to find an optimal solution of the GMCCD, it is sufficient to check whether there exists a hole-cut of size MAX-FLOW or not. In what follows, fori=1,⋯,k,letFibe the set of all faces of G contained inR(Pi−1,Pi),where P0 ≔ Pk.Theorem 6Kobayashi & Otsuki, 2014An optimal solution of the GMCCD can be computed in polynomial time (by usingAlgorithm 4).Note that if we have a directed cycle inD=(F,A),which is defined in Algorithm 4, we can obtain a hole cut whose size is the same as the length of the directed cycle. The running time of Algorithm 4 is bounded by O(|V||W|), since the number of nodes and edges of the directed graphD=(F,A)is|F|=O(|V|)and|A|=O(|W|),respectively. Thus, in Line 3 of Algorithm 4, finding a minimum-length directed cycle takesO(|F1|(|F|+|A|))=O(|V∥W|)time. Practically, since|W|=O(|V|),the running time of Algorithm 4 is O(|V|2).We improve the min-cut algorithm (Algorithm 4) of Kobayashi and Otsuki (2014) for the GMCCD in this section. As we reviewed in the previous subsection, the running time of this min-cut algorithm is O(|V|2) practically. The improvement does not change the theoretical computational time complexity, in the same way as our Improvement for the GMFCD. Practically, however, the running time of the algorithm is decreased drastically in most cases, as we will see in Section 5.2.Let k ≔ MAX-FLOW. First, we note that we can obtain pairwise hole-disjoint k s-t pathsP1,⋯,Pksatisfying the following property, by using the improved max-flow algorithm (see Section 3.3).Property A: The first edges ofP1,⋯,Pk,which are incident to s, occur in this order clockwise at s, and fori=1,⋯,k,Piis the s-t path such that(Pi−1,Pi)is clockwise hole-disjoint andR(Pi−1,Pi)is minimized under this condition (P0 ≔ Pk).Here we use the following lemma, which we can show by applying the argument in the proof of Theorem 3 in Kobayashi and Otsuki (2014) to the case with Property A.Lemma 7Kobayashi & Otsuki, 2014Suppose that we are given a graphG=(V,E)drawn in the plane, two distinct nodes s and t, a hole radius rB, and a protection radius rP( > rB). Moreover suppose that there exist pairwise hole-disjoint k s-t pathsP1,⋯,Pkthat satisfy Property A. Then, there exists a closed curve C which does not intersect with itself, separates s and t, and is a concatenation ofJ1,L1,J2,L2,⋯,Jk,Lkin this order, where•forj=1,2,⋯,k,Jj is a curve contained in a facefj∈Fj,and face fj and path Pj share an edge of G in common, andforj=1,2,⋯,k,Lj is a line segment inR2that can be covered by a holeH∈H(rB,rP).By using the lemma, we obtain Algorithm 5.Theorem 8Suppose that we are given a graphG=(V,E)drawn in the plane, two distinct nodes s and t, a hole radius rB, and a protection radius rP( > rB). Moreover suppose that we have pairwise hole-disjoint k s-t pathsP1,⋯,Pkthat satisfy Property A. Then,Algorithm 5can find an optimal solution of the GMCCD.By Lemma 7, there exists a closed curve C which does not intersect with itself, separates s and t, and is a concatenation ofJ1,L1,J2,L2,⋯,Jk,Lkin this order, where•forj=1,2,⋯,k,Jjis a curve contained in a facefj∈Fj,and face fjand path Pjshare an edge of G in common, andforj=1,2,⋯,k,Ljis a line segment inR2that can be covered by a holeH∈H(rB,rP).Since each face fjshares a common edge with path Pj, the directed graph D′ in Algorithm 5, which is a subgraph of D, has a directed cycle of length k. Then, if a minimum-length directed cycle is found in D′, its length is k because D′ has no directed cycle whose length is less than k. We can find a minimum-length directed cycle of D′ by Algorithm 5, which completes the proof.□Although the improvement does not change the theoretical computational time complexity, practically the running time is decreased drastically in most cases. We note that in order to use Algorithm 5, it is necessary thatMIN-CUT=MAX-FLOW(=k) and we have pairwise hole-disjoint k s-t pathsP1,⋯,Pksatisfying Property A. In most cases,MIN-CUT=MAX-FLOWholds and we can find such s-t paths efficiently by using Algorithm 3.

@&#CONCLUSIONS@&#
