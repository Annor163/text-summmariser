@&#MAIN-TITLE@&#
A hybrid optimization approach to conformance testing of finite automata

@&#HIGHLIGHTS@&#
Presented is a hybrid approach to generate Unique Input–Output sequences.The proposed method combines effective hill climbing and heuristics.Comparative studies with four other heuristics are reported.The hybrid approach has been generalized to seed-driven hybrid architectures.

@&#KEYPHRASES@&#
Metaheuristic algorithms,Hybrid approach,Genetic Algorithm,Simulated Annealing,Finite state machine,State verification,

@&#ABSTRACT@&#
Unique Input–Output sequences (UIOs) are quite commonly used in conformance testing. Unfortunately finding UIOs of minimal length is an NP hard problem. This study presents a hybrid approach to generate UIOs automatically on a basis of the finite state machine (FSM) specification. The proposed hybrid approach harnesses the benefits of hill climbing (Greedy search) and heuristic algorithm. Hill climbing, which exploits domain knowledge, is capable of quickly generating good result however it may get stuck in local minimum. To overcome the problem we used a set of parameters called the seed, which allows the algorithm to generate different results for a different seed. The hill climbing generates solutions implied by the seed while the Genetic Algorithm is used as the seed generator. We compared the hybrid approach with Genetic Algorithm, Simulated Annealing, Greedy Algorithm, and Random Search. The experimental evaluation shows that the proposed hybrid approach outperforms other methods. More specifically, we showed that Genetic Algorithm and Simulated Annealing exhibit similar performance while both of them outperform Greedy Algorithm. Finally, we generalize the proposed hybrid approach to seed-driven hybrid architectures and elaborate on how it can be adopted to a broad range of optimization problems.finite state machineGenetic AlgorithmSimulated AnnealingUnique Input–OutputUnique Input–Output sequences

@&#INTRODUCTION@&#
Testing has become more complex in the recent years given a continuously growing size and complexity of modern systems. Conformance testing is applied to verify if a designed (implemented) automata meets a series of specified requirements. Conformance testing involves a model of the finite state machine, which captures the requirements of the system to be designed [1–3]. An implemented version of a finite state machine is treated as a black box and compared with its specification. To verify if the implemented machine complies with its requirements, we generate an input for the machine and observe the resulting outputs. With this regard, various testing methods were proposed, say U-method [4,5], W-method [5,6], T-method [5,7], and D-method [5,8]. Each of these methods comes with some advantages however there are some limitations. The T-method is unable to detect state fault [5]. The W-method generates the longest test sequences [9]. The D-method generates a distinguishing sequence, which may not exist for every machine [5,9]. In fact, only 17% of FSMs have a distinguishing sequence [9].In this study, we focus on the U-method because this method is able to detect state fault [5], produce the shortest test length [9]. Furthermore we are able to use the U-method when a distinguishing sequence does not exist for the given FSM. The U-method generates Unique Input–Output sequences (UIOs) of minimal length for each machine state to detect state fault and UIOs exists for each state on 99% of the FSM [9]. Let us recall that the Unique Input–Output (UIO) sequence is an input sequence, which once executed on the selected state produces a unique output. However generating the shortest Unique Input–Output sequences is an NP-hard problem [10] and because of this, various metaheuristic techniques may be applied. Such techniques like Genetic Algorithms [11,12], Simulated Annealing [13,14], 1+1 [15], Particle Swarm Optimization [16,17], Artificial Bee Colony [18,19] have been shown to be effective in solving NP-hard problems.The main objective of this study is to propose, analyze, and experiment with the hybrid approach to generate minimal UIO sequences and to quantify its effectiveness. The results obtained when using the proposed approach are compared with those produced by a generic version of the Genetic Algorithm, Simulated Annealing, Greedy Search, and Random Search. A detailed study is provided on how the approaches are affected by the topology and size of the finite state machine. We also show how these algorithms perform over time.In this paper, we propose a new hybrid approach called Genetic-Hill Climbing. We show that this approach leads to better results in comparison with those produced by some other techniques. The hybrid approach is composed of a hill climbing algorithm, which generates results based on knowledge about the problem and machine architecture. The hill climbing algorithm without any input parameters generates the same sequences every time. To improve the hill climbing we use a set of parameters, which guides the process of optimization. The set of parameters is referred to as a seed and the Genetic Algorithm is used as the seed generator.This paper is structured into seven sections. We begin with offering some background by looking at the current state of affair in the field of finite state machine conformance testing. Section “The proposed hybrid algorithm” gives details on the hybrid approach and generalizes the proposed approach to seed-driven hybrid architectures. In Section “Experiments”, a concise description of the testing environment and algorithm parameters selection is followed by the results of experiments and their detailed analysis. Following section provides a real-world case study. Finally, we draw the conclusions and identify future research direction.In this section, we present some prerequisites and present a current status on conformance testing of finite state machines.The finite state machine (finite automata) is an abstract model, which describes behavior of dynamic system based on a state transformation table. Finite state machines are in common usage. They are used for describing logical circuits [20], network protocols [21] and computer applications [3].Formally speaking, a State Machine is described in the form (I, O, S, Ss, f, g), where I: a finite non empty set of input objects; I={I1, I2, I3…, Ia}, O: a finite non empty set of output objects; O={O1, O2, O3…, Oo}, S: a finite non empty set of states; S={S1, S2, S3…, Sn}, a: a number of inputs in the fsm, o: a number of outputs in the fsm, n: a number of states in the fsm, f: a state transformation function; f:S×I→S, g: an output function; g:S×I→O, Ss: a start state; Ss∈S.There are two types of finite automata, namely Mealy machines [1] and Moore machines [2].In this paper, we consider Mealy machines because the machines of this type produce a lower number of states than the equivalent Moore machines. In the Mealy automata, each state has a list of actions, which may be executed. When being in a certain state and provided with a certain input, the machine moves to the next state (identified in the transformation table) and generate a certain output. An example of the finite Mealy state machine is shown in Fig. 1. For example, if we start from state S1 and run a sequence of actions ‘aa’, the machine moves to state S3 through state S2 and produce the output sequence ‘21’.Conformance testing of a finite state machine requires comparing the machine specification with its implementation. We encounter the following types of faults [5,10]:•Output faultState faultAn output error arises when the output coming from a test suite disagrees with the machine specification. Whereas a state error appears when after test execution the finite state machine is not in an expected state. The output error can be discovered easily by comparing an actual test output with an expected test output derived from the specification. The basic method for finite state machine testing is the Transition Tour (T-method) [5,7]. When applying the T-method, we move through each transition at least once and check the output. Finding the shortest sequence, which moves through all transitions is also known as The Chinese Postman Problem [22] and an effective solution for the problem exists [22]. However the T-method detects only the output error. The state error can be discovered after each transition test execution by checking if the machine is in a correct state. But this is not as easy as it looks. To check if a machine is in a proper state we need to run a special sequence, which verifies the state. There are three state verification methods:•U-method or unique input/output sequence (UIO) [4,5]D-method or distinguishing sequence (DS) [5,8]W-method or characterization set (W-set) [5,6]Let us briefly highlight the essence of these three methods.The method creates a sequence called the distinguishing sequence, which generates a different output for each state. For example, the distinguishing sequence ‘bb’ for the graph in Fig. 1 produces the following outputs:•For state S1 – 12For state S2 – 22For state S3 – 11The main disadvantage of the distinguishing sequences is that not every finite state machine posses a distinguishing sequence.The method creates a set of sequences called the characterization sets, which distinguish each state by outputs of the sequences. For example, the characterization set {‘aa’, ‘b’} for the graph shown in Fig. 1 gives rise to the following sets of outputs:•For state S1 – {21, 1}For state S2 – {11, 2}For state S3 – {11, 1}The main disadvantage of the characterization set is that it produces the longest test sequence as it requires running each sequence from the set on a tested state.The method produces a sequence called the Unique Input–Output sequence (UIO) for each state. The output produced by the machine is compared with the output recorded in an UIO sequence after the sequence is executed. If these results match then the machine is in the state for which the UIO has been created. Otherwise a state error in the machine has been found.Here are sample UIO sequences for the machine shown in Fig. 1:•For state S1 – aFor state S2 – bFor state S3 – baFor example, an execution of ‘b’ sequence for each state produces the following results:•For state S1 – ‘1’For state S2 – ‘2’For state S3 – ‘1’The execution of the ‘b’ sequence when the FSM is in state S2 gives the result ‘2’, while the execution of ‘b’ sequence when the FSM is in state S1 or S3 returns ‘1’. This means that ‘b’ is the UIO sequence and can be used to verify state S2 because the output from S2 does not repeat itself in the other states.D-method, W-method, and U-method test every transition once. In short, the methods are composed of the following steps:1.Go to tested transitionExercise that transitionRun a state verification sequenceCheck outputsHome to start sequenceRepeat steps 1–5 for the next transition.As mentioned earlier, we focus on generating UIO sequences (U-method) because this method generates the shortest test cases [5,9]. The U-method is used in testing network protocols [4] and sequential circuits [23,24]. Test case should be as short as possible. Shortest UIO sequences are generated to minimize test case length but finding the shortest UIOs is a NP-hard problem [10]. Metaheuristic optimization techniques such as Simulated Annealing, Genetic Algorithm, Particle Swarm Optimization and ‘1+1′ were used and demonstrated to be successful [15,25–27] in comparison with Random Search [28] regarded as a benchmark. In our previous study [27] we used the Particle Swarm Optimization technique, which also outperformed Random Search. A lot of research has been completed for the UIOs generation techniques but none of them guarantee finding the shortest UIOs in an acceptable time.We define a task of generating the shortest UIO sequences as a search problem by constructing and optimizing a fitness function, which combines the two essential optimization objectives. The first objective concerns the uniqueness of the sequence while the second one captures the length of the sequence. As expected, we penalize long sequences and favor unique ones. Descriptively, the fitness function is expressed in the following way:(1)fitness=size+uniquinesswhere size is the length of the sequence and uniquiness is a number of additional states for which the sequence produces the same output as for its target state. Finally, we use optimization techniques to minimize the fitness function.The required number of combinations to be checked in order to find the shortest UIO sequence is determined as:(2)∑i=1n−1aiWe use n−1 as an upper limit for sequence length because machines with the shortest UIO sequences of such length exists (see Fig. 2).In what follows, we briefly review some of the available optimization frameworksSimulated Annealing (SA) [13,14] is a certain heuristics for global optimization realized in the large search space. In most cases SA is not able to find the global optimum but the algorithm can localize good approximation of the best solution. The algorithm was used to construct the shortest UIO sequences [26]. In Ref. [26] the following algorithms were compared: SA with sharing technique, SA without sharing, GA with sharing and GA without sharing. The experimental result shows no significant difference between Simulated Annealing and Genetic Algorithm but both algorithms with sharing outperformed those without sharing.Genetic Algorithm [11,12] was used in the UIO sequences generation problem [25,26,29]. All these studies focused on the search for the shortest UIO sequences. Experimental result shows no significant difference between GA and SA [26]. The Genetic Algorithm, however, outperforms Random Search being regarded as a benchmark [25]. These experiments show also that GA results compared with those produced by the Random Search are superior when developing testing sequences for larger machines. Experiments in Ref. [25] were applied to a set of 11 real-world finite state machines and 21 randomly generated machines. The size of these randomly generated machines range from 4 states to 360 states but other parameters of the topology like a number of actions and outputs remain the same for every FSM.Greedy Search, referred to as hill climbing [30] is an algorithm, which makes the best available choice in each step. Greedy Search does not care about future possibilities of current move. It chooses solution, which in a specific moment is the best. For example, in the Traveling Salesman Problem, Greedy Search starts from a random location and then at each step chooses the closest city. This technique produces good results at the beginning of the search but in most cases the algorithm finds only a local optimum. The Simulated Annealing may works like Greedy Search if we set maximum temperature to be fixed. To the best of our knowledge, we have not seen any studies devoted to the use of the Greedy Search in the UIOs generation problem. However, the Greedy Search was applied to the automatic construction of test suites [31] and to the minimization of the existing one [32]. In the minimization of test suites problem, the Greedy Search selected the same or smaller test suite than other heuristicsAt each step, Random Search [28] generates a random solution. In many studies, Random Search is used as a benchmark when studying other optimization algorithms. Ultimately any sensible technique should outperform Random Search. Random Search was used as a benchmark to generate UIO sequences as reported in Refs. [15,25,27].The proposed hybrid approach (see Fig. 3) harnesses the benefits of hill climbing and the Genetic Algorithm.The hill climbing generates a good solution in no time at all because it uses additional information about the machine architecture and the UIOs generation problem. Unfortunately, the standalone hill climbing generates the same result in each run. To overcome the problem we used a set of parameters called the seed (Fig. 4), which allows the algorithm to generate different results for a different seed. The seed is a list of actions. The hill climbing generates solutions from actions implied by the seed only. The Genetic Algorithm encodes a seed in the chromosome carried by each individual in the population. We used the Genetic Algorithm as the seed generator and the Genetic Algorithm controls the hill climbing through the seed.We develop a fitness function, which focuses on the uniqueness of the sequence and punishes long sequences. Formally, the fitness function is described by the following expression:(3)fit=∑i=1n(uniquiness(Ui_,Si)+length(Ui_))where fit is the calculated fitness.Ui_is an UIO sqeuence for state Si. Functionuniquiness(Ui_,Si)calculates uniquiness of sequenceUi_for state Si. Functionlength(Ui_)calculates length of sequenceUi_.The fitness function expresses the sum of fitnesses for all generated sequences given the fact that we generate one sequence per state.Function uniquiness – returns an integer, which indicates how many times the result of the sequence is repeated when we run the sequence on every state of the machine. If the returned number is 0 then the sequence is uniqe. If the returned number is 1 then the sequence produces the same result on some other state. Function uniquiness returns numbers in range (0, n−1). Formally, the uniquiness is described in the following form:(4)Λx(x∈S∩x≠Si∩out(Si,Ui_)=out(x,Ui_)→fit+=1)whereout(Si,Ui_)is the output for the sequenceUi_which has been executed starting from state Si. Function length – returns an integer which is the length of the sequence. The returned number is in the range (0, n−1).Let us look at the following illustrative example. We consider the following sequences in the graph presented in Fig. 1:•For state S1 – bbbFor state S2 – abFor state S3 – aabFor the sequences above, we obtain the following values of the fitness function:•For state S1 – 0 for uniquiness and 3 for length.For state S2 – 1 for uniquiness and 2 for length.For state S3 – 1 for uniquiness and 3 for length.After summing up the partial results, the overall value of the fitness function is 10.First, we count each action-output pair (done similarly as discussed in Ref. [25]).In Fig. 1, we have the following number of pairs:•count[a, 1]–2count[a, 2]–1count[b, 1]–2count[b, 2]–1Secondly, we calculate iao factors as follows:(5)iao[Ii,Oi]=count[Ii,Oi]a×nwhere iao[Ii, Oi] is calculated iao factor for action Iiand output Oi. count[Ii, Oi] is a number of transformations, which for input Iigenerates output Oi.Proceeding with the example, see Fig. 1 we have:•iao[a, 1]=2/(3*2)=0.333iao[a, 2]=1/(3*2)=0.167iao[b, 1]=2/(3*2)=0.333iao[b, 2]=1/(3*2)=0.167The purpose of the iao factor is to scale the previously counted number of input–output pair to arrive at the number between <0;1>, which is applicable to a simplified fitness function calculation, as shown in the next section.The most outstanding feature of the simplified fitness function is that it offers much better performance in comparison with performance of the results produced when using the complete fitness function. It is worth noting that the simplified fitness exhibits a linear time complexity, while the full fitness is determined in a polynomial time. The hill climbing algorithm adds an action to a sequence in each step. When the action is added to the sequence then there is no need to recalculate simplified fitness but only one arithmetic operation is needed to update its value.It is not guaranteed that the sequence with the best simplified fitness value is the best in terms of the full fitness function. The simplified fitness function approximates the result produced by the complete fitness function and because of this approximation the fitness function is regarded as the simplified one.Formally, the simplified fitness function is calculated for each sequence as follows:(6)sfit=∏i=1liaoVi,Wiwhere sfit is the calculated simpified fitness. Viis the ith action from the sequence. Wiis an output from the machine for the ith action. l is a length of the sequence.The simplified fitness is not affected by actions, which are not available in the current state. If the action Viis unavailable in the current state then no transformation is executed, produced output is null and iao[I, null]=1.0.The simplified fitness returns a real number in range (0,1) and the hill climbing minimizes its value.As an example, we consider following sequences present in Fig. 1:•For state S1 – bbbFor state S2 – abFor state S3 – aabFor the sequences above we obtain the following values of the fitness function:•For state S1 – iao[b/1]*iao[b/2]*iao[b/2]=0.333*0.167*0.167For state S2 – iao[a/1]*iao[b/1]=0.333*0.333For state S3 – iao[a/1]*iao[a/1]*iao[b/1]=0.333*0.333*0.333It is worth noting that we calculate the simplified fitness for each state.The Genetic Algorithm [11,12] generates a population of individuals. Each individual carry a seed, which is used by the hill climbing to generate UIOs. While the Genetic Algorithm is described earlier we focus on the hill climbing algorithm. It must be noted that GA uses a non-simplified fitness function. The simplified fitness function is used only in hill climbing optimization phase since calculating fitness function in each step of hill climbing adds a significant computing overhead.The hill climbing algorithm receives a seed as the input parameter. The seed is an ordered set of actions, which is transformed to UIOs. A unique seed always generates the same solution but the unique solution can be obtained for many different seeds.The flow of processing realized by the hill climbing algorithm is presented below:1.Create an empty array of sequences –Ui_, where i=1, 2…n. The length of the array is equal to the number of states of the FSM as an UIO sequence is generated for each state.We carry out all actions from the seed in the loop. The action is added to a first sequenceUi_, which satisfies the following condition:(7)Λj=1ni≠j∩sfit_improv(Ui_,e)≥sfit_improv(Uj_,e)where e is an action from the seed.sfit_improv(Ui_,e)calculates the simplified fitness improvement after adding an action e to the end of the ith sequence.At the end, we form an UIO sequence for each state from the FSM.We have already calculated iao factors. Let us show how the hill climbing algorithm works step by step for the FSM shown in Fig. 1 and seed set as ‘abba’.1)At the beginning, we start with the three empty UIOs list, one sequence for each state. The initial simplified fitness value is 1.0 for each state so the fitness improvement is in the range from 0.0 to 1.0.We consider the first element ‘a’ from the seed and decide where to add the action.a)State S1: fitness improvement is 0.833State S2: fitness improvement is 0.667State S3: fitness improvement is 0.667We add the action to S1 because at this state one obtains the best result. We must remember that the FSM moves to state S2.We consider the second element ‘b’ from the seed and decide where to add the action.a)State S1: fitness improvement is 0.139State S2: fitness improvement is 0.833State S3: fitness improvement is 0.667We add the action to S2 because at this state one obtains the best result.We consider the next element ‘b’ from the seed.a)State S1: fitness improvement is 0.139State S2: fitness improvement is 0.139State S3: fitness improvement is 0.667We add the action to S3 because at this state one obtains the best result. We must remember that the FSM moves to state S1.We consider the next element ‘a’ from the seed.a)State S1: fitness improvement is 0.111State S2: fitness improvement is 0.111State S3: fitness improvement is 0.277We add the action to S3 because at this state one obtains the best result.Finally, we obtain three sequences: a, b, ba.a)S1: S1(a)→S2S2: S2(b)→S2S3: S3(ba)→S1→S2The hill climbing algorithm is effective because only one multiplication is needed to calculate the value of the simplified fitness function: we need to multiply a current simplified fitness and an appropriate iao factor.To adapt the hybrid approach to an another problem, the hill climbing algorithm must be replaced by an algorithm specialized in solving the problem. The one requirement is that, the hill climbing must be driven by a seed. Such adjustment to the knapsack problem [33] is presented in Fig. 5. The hill climbing should use knowledge about the knapsack problem but this is beyond the paper scope. It is also possible to use wide range of metaheuristic algorithms in the seed driven hybrid architecture. Generalized flowchart of the hybrid approach is presented in Fig. 6.

@&#CONCLUSIONS@&#
