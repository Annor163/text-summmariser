@&#MAIN-TITLE@&#
Direct repair of self-intersecting meshes

@&#HIGHLIGHTS@&#
An extremely fast mesh repairing algorithm with guaranteed topology is described.Repairing meshes with attributes becomes a trivial operation thanks to the direct approach employed.Exact constructions are used only when necessary and together with fixed precision arithmetics.

@&#KEYPHRASES@&#
Outer hull,Mesh repairing,Self-intersection,

@&#ABSTRACT@&#
A fast and exact algorithm to eliminate intersections from arbitrary triangle meshes is presented, without any strict requirement on the input. Differently from most recent approaches, our method does not rely on any intermediate representation of the solid. Conversely, we directly cut and stitch mesh parts along the intersections, which allows to easily inherit possible surface attributes such as colors and textures. We rely on standard floating point arithmetics whenever possible, while switching to exact arithmetics only when the available fixed precision is insufficient to guarantee the topological correctness of the result. Our experiments show that the number of these switches is extremely low in practice, and this makes our algorithm outperform all the state-of-the-art methods that provide a guarantee of success. We show how our method can be exploited to quickly extract the so-called outer hull even if the resulting model is non manifold by design and the single parts have boundaries, as long as the outer hull itself is unambiguously definable.

@&#INTRODUCTION@&#
Modern 3D modeling paradigms enable extremely flexible tools to design original shapes by composition and deformation of existing models [17,4]. Unfortunately, most of the times the designer has not a deep knowledge of the underlying mathematics and simply produces an original shape by cutting, bending and moving parts of 3D objects in space (e.g. Fig. 1(left)). The designer’s work terminates when the object looks as expected, but in most cases the so-constructed model has a number of self-intersections that make it unusable in important applications such as, e.g., 3D printing [13,37]. Furthermore, besides self-intersections, such compound models often contain other flaws such as open boundaries, degenerate elements and singularities that complicate the necessary repairing task. As observed in [3], each repairing algorithm has its own requirements on the input, and these requirements are not always met in practice. In particular, current solutions to convert self-intersecting meshes to valid polyhedra are either too slow and memory-intensive, or too restrictive in terms of both supported input and potential output (see Section 5.1.6 in [3]). As an example of supported input restriction, one may consider that many algorithms assume that the input has a manifold connectivity and has no surface holes. In most cases, these same algorithms can only produce manifold results, which means that a nonmanifold union of two manifold solids cannot be constructed. Tools to fill holes and convert a generic input to a combinatorial manifold exist [19], but in some cases performing such a preprocessing may become quite complicated, while in some other cases (e.g. when non-manifold configurations are designed on purpose [1]) such a conversion cannot be realized at all without corrupting the original design intent.Herewith we present a fast and exact algorithm to eliminate intersections from arbitrary triangle meshes, without any strict requirement on the input. Also, we show how our method can be exploited to extract the so-called outer hull even if the resulting model is non manifold by design and the single parts have boundaries. We argue that when a designer says that “the object looks as expected” he/she does not care of non-visible parts. Thus, our outer hull extraction can be considered as an effective repairing that does not introduce any visible shape distortion. Though some state-of-the-art methods could be exploited to resolve this problem, our algorithm represents the currently fastest solution thanks to a novel mixed use of finite precision and exact arithmetics.A mesh repairing algorithm can be based on either a local or a global approach [24,3]: in the former case, local operations are performed around each defect to correct it, whereas the remaining intact parts of the mesh are kept unaltered. Conversely, in the latter case the mesh is completely rebuilt starting from an intermediate representation. Thus, highly-detailed, feature-rich meshes with mainly isolated flaws should be fixed using local approaches to preserve as many details as possible, while highly corrupted or inconsistent meshes with multiple types of defects (e.g. polygon soups) would better be fixed through a global approach, especially if one needs a guarantee that the repair process succeeds. Global approaches typically are highly robust whereas local approaches are less invasive. A few approaches exist that try to couple guarantee of success and minimal invasiveness [28,29], but they cannot treat self-intersecting meshes. On the other hand, local algorithms that fix self-intersecting meshes exist, but they cannot treat a generically flawed input. The state of the art in self-intersection repairing can be subdivided in fragile, approximate and robust methods.Earliest approaches to calculate and remove mesh intersections were designed to compute boolean operations [25], and the fact that robustness issues may easily arise was already known [21]. Instead of handling all the possible particular cases, in [33] BSP trees are used as an intermediate representation, and an improved version of this approach has been proposed by [27]. However, instead of solving the robustness problem, algorithms of this kind can just detect too difficult situations and report a generic failure. Surprisingly, such a “fragile” approach is quite diffused in current commercial systems (e.g. Autodesk Maya [6] and 3ds Max [5]), and when the algorithm fails the user is simply allowed to undo the operation and tweak the model before retrying.Instead of trying to compute an exact solution using a fragile approach, another class of methods achieves robustness at the cost of providing an approximated solution. As observed in [9], tessellated CAD models produced by designers are typically made of many surface patches that should perfectly adhere along their boundaries. Due to diverse sources of approximation, however, these adjacency lines are often replaced by gaps or self-intersections. The solution proposed in [9,35] is to rebuild the mesh in a neighborhood of these defects through a local reconstruction. Clearly, this approach is less invasive than a global remeshing such as in [23], but the result provided is an approximation in any case. Furthermore, in [9] each single patch in the input is required to be free of self-intersections. A more general method is presented in [10], where an octree is used to completely resample the input, so that the result is guaranteed to be the boundary of a solid object which stays within a user-prescribed distance from the original mesh. When the input is a high resolution raw digitized mesh, self-intersections can be removed using [2] even if the mesh has degenerate facets, surface holes and singularities. Though being extremely robust and editing the mesh only locally, this method and all the others discussed in this subsection cannot produce exact solutions (i.e. exact outer hulls).The easiest way to implement algorithms which are both robust and exact is to rely on exact arithmetics or similar techniques. Exact geometric predicates may be used by algorithms to take decisions based on input floating point coordinates only, without the need to exactly represent any new point (e.g. computing planar Delaunay triangulations). Conversely, some algorithms take decisions based on points which are computed during the execution and are not part of the input. Robustness in this latter case can be achieved through exact constructions that allow to exactly represent such intermediate points. In most cases floating point arithmetics is sufficient to exactly evaluate a geometric predicate, while in few situations exact arithmetics is necessary. By identifying the conditions that make floating point arithmetics not reliable, Shewchuk [31] switches to exact arithmetics only when necessary, so that predicates can be evaluated without errors with just a little overhead when compared to their non-robust counterparts.Based on GNU Multi Precision arithmetic library (GMP), exact constructions are used to compute boolean operations of a pair of polyhedra in [30], whereas exact predicates only are necessary in [38] for the same task. GMP is also used for exact constructions in CGAL, where a conversion of the input into so-called Nef polyhedra enables robust boolean operations even if the input and/or the output are non regular sets [20]. Since the use of exact constructions makes these algorithms too slow, in [8] the BSP tree formalism introduced in [33] was made robust through fixed-precision techniques [16]. This algorithm was first improved in [12], where conversion to BSP trees occurs only around the intersections, and then in [36], where clever clipping operations allow to quickly convert the BSP to a mesh.The Cork open-source library (https://github.com/gilbo/cork) includes functions to compute boolean operations using fixed precision arithmetics and allows to effectively cut the mesh at its intersections. Unfortunately, this library does not provide any function to extract the outer hull and its design is not described in any publication [7].To summarize, when arbitrary meshes need to be considered and robustness is required, CGAL [20] still represents the state of the art, and the need to pass from an intermediate representation coupled with the use of exact constructions has an inevitable impact on the overall performances.In contrast, our approach is direct (i.e. it works directly on the mesh without intermediate representations) and relies on floating point arithmetics whenever possible, while switching to exact constructions only when ambiguities occur. This makes our algorithm extremely fast while guaranteeing a correct topology of the result. Furthermore, possible information attached to the original mesh can be easily maintained and inherited in the result (e.g. colors, textures, material information, etc.), while such an information transfer would be significantly more complicated for methods that switch between representations.The core of our algorithm is a module that converts a generic input mesh into a nonmanifold simplicial complex without intersections. After this first step, the outer hull extraction consists in selecting a subset of the triangles from the nonmanifold complex.Hereafter we make use of the formal terminology for simplicial complexes given in [18]. Thus, our input is a triangle mesh defined by (1) a pure two-dimensional abstract simplicial complex (with possibly nonmanifold connectivity) and (2) a set of vertex positions that uniquely identify its geometric realization. If such a mesh has no degenerate triangles and no self-intersections, then it is a valid Euclidean simplicial complex [15] (i.e. the intersection of any two non-disjoint triangles is either an edge or a vertex). Our first objective is to minimally edit the mesh to guarantee this latter characteristic without modifying the geometric realization.Note that the input is allowed to be made of several connected components, to have boundaries, to have intersections among multiple components and within each single component. In such a model the intersection can be defined as another complex made of zero-, one- and two-dimensional cells. Note that this complex is not necessarily pure and its top dimension is not necessarily two. In the remainder any simplex of such a complex will be called an “intersection element”. Thus, an intersection element can be a single isolated vertex (e.g. a pyramid tip touching a plane), a straight segment bounded by two endpoints (an edge), a convex polygon defined as the intersection of two coplanar triangles (a cell). Convex polygons can be unambiguously defined through their bounding segments, thus are not explicitly encoded in our method.

@&#CONCLUSIONS@&#
This paper has shown that arbitrarily intersecting meshes can be fixed using a very fast approach that mostly relies on floating point arithmetics, while switching to exact arithmetics only when major ambiguities occur. Our experiments have shown that these switches are extremely rare in practice, so that their influence in negligible on the overall computation time. Thus, our algorithm is orders of magnitude faster than existing methods based on exact constructions, but it is also slightly faster than other methods that use fixed precision while providing guarantees of success. Furthermore, besides the efficiency, the direct approach employed is particularly cheap in terms of memory consumption and makes it easy to inherit surface attributes on the resulting fixed model.We believe that there is still room for improvement in the triangle subdivision and geometric match steps. Instead of relying on these two successive phases, we think that a clever algorithm design may allow to compute the connectivity of the subdivided triangle based on the original coordinates only, without the need to use the pre-computed intersection points and to perform any projection. Succeeding in this would make the algorithm completely free of any exact computation model.