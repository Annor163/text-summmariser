@&#MAIN-TITLE@&#
Supporting comprehensible presentation of clone candidates through two-dimensional maximisation

@&#HIGHLIGHTS@&#
Based on the examination of our initial finding we introduce a revised algorithm to group clone pairs.The proposed technique is a two-dimensional maximisation to group clone pairs.The algorithm is broadly usable, language independent with weak constraints.We present the experiment used to evaluate the proposed algorithm.

@&#KEYPHRASES@&#
Code clones,Comprehensible result presentation,Grouping,Maximum clique,

@&#ABSTRACT@&#
Duplicated code detection has been an active research field for several decades. Although many algorithms have been proposed, only a few researches have focussed on the comprehensive presentation of the detected clones. During the evaluation of clone detectors developed by the authors, it was observed that the results of the clone detectors were hard to comprehend. Therefore, in this paper a broadly suitable grouping method with which clone pairs can be easily grouped together to provide a more compact result is presented. The grouping algorithm is examined and a more precise revised algorithm is proposed to present all of the candidates to the user.

@&#INTRODUCTION@&#
The existence of code clones – mostly the results of “copy&paste programming” – can make software more prone to bugs and inconsistencies during maintenance. Thus, programmers should at least be aware of the existing clones in the software. Considering legacy code, the manual identification of clones is a tough challenge for an IT team. Fortunately, clone detectors [1] come to the rescue.At the first sight the challenge of identifying code clones in software ends by the successful application of the duplicated code detectors, however, it is not always true. The benefit gained from the reported code clones greatly depends on whether the users are capable of exploiting the results. If the users are swamped with either irrelevant details or huge number of clones, they spend too much time on the analysis and it is likely that they oversee the most relevant and important clones, for instance, the code fragment duplicated several times.When we evaluated our duplicated code detectors using legacy code [2–4], we found ourself in a situation that analysing the result is almost as hard as elaborating a new algorithm. Our algorithms result clone pairs, and in the case of legacy code the population of the detected clone pairs was such enormously large that we could not grasp the result. Moreover, as more than half of the clone pairs shared code fragments with the others, we analysed nearly the same clone again and again. In conclusion, it turned out that presenting clones as pairs made the result hard to understand, even though the result is valuable and useful. We also noticed that grasping clone groups is much easier thanks to the compactness of the result. Yet, what can be done if the algorithms result in pairs?In paper [5] a general solution to this problem was proposed. Nevertheless, the solution is not perfect for all the goals. If the goal is to efficiently eliminate the code fragments having the utmost clones with the least effort, the algorithm proposed in this paper is said to be the best. (It is the dominant opinion of programmers participating in our experiment.) The algorithm presented in this paper revises the general solution [5]. It is a language independent grouping method that reveals all of the possible groups of clones that cannot be further extended – either by including more code to each clone member or by adding new clone members to existing groups. It is not a duplicated code detector, it works with the result of the detectors – set of clone pairs – to provide a comprehensible and easily usable result by refining, reorganising the clone pairs.Tools to support the detection of duplicated code fragments may differ in the used detection algorithm, the type/level of found clones, the presentation of the result, the targeted programming language, etc. These parameters are not fully orthogonal. The used detection algorithm can determine the presentation of code clones as well. For instance, when a suffix-tree based lexical approach is used the detection easily returns group of clones. Although, when a metric based pairwise comparison is used for detection, the result of the algorithm is usually pairs of clones. Returning hundreds of pairs makes the comprehension and processing of clones hard.In this paper we introduce a general algorithm to form groups from clone pairs resulted by any kind of detection algorithm. Our approach is language independent, it only requires an isClone relation (Section 2.1.2) that describes whether two entities can be considered as a clone.We have evaluated our approach in the context of the Erlang programming language and have used the tool called Clone IdentifiErl (Section 2.1.1). However, we would like to emphasise here that our approach does not restrict the programming language in which the clones were implemented and the detection algorithm used to retrieve the clone pairs.In this section we first introduce some clone detector tools in general (Section 2.1) and in terms of the presentation of clones as well (Section 2.2). Finally in Section 2.3 we provide the background of our work. We give an overview of our initial approach to form clone groups, which was presented in paper [5]. The main contribution of this paper is the grouping algorithm presented in Section 3 which is a refinement of this initial approach.Clone detection is an active field of research, a large number of prominent research have been successfully carried out. The paper [1] gives an overview of the clone detection processes in general, and also provides a description of clone detection techniques (textual, lexical, syntactic and semantic approaches) and tools. They evaluated the tools based on some predefined editing scenarios. This study aimed to help the users in selecting the appropriate tool for their needs.Another paper [6] focuses on the precision of six different tools that are using different techniques. They have been evaluated by the tools on C and Java programs.There are some clone detectors, such as CCFinder [7], that aim to implement efficient and scalable algorithms. Thus, they have been successfully applied on industrial-size software as well. CCFinder also offers transformation rules to remove and eliminate certain kinds of clone instances.Several clone detectors have been developed for the mainstream programming languages, while for functional programming languages only a few exist [8,9] adopting broadly usable, general duplicated code detector algorithms. That is a problem as nowadays there is a continuously increasing interest towards functional programming languages. Just consider that anonymous functions are available even in .NET and JAVA.Considering soft-real time, fault-tolerant, large-scale software with high availability a new star is rising – the Erlang programming language [10]. It drives the telecom industry (e.g. Ericsson), large betting portals (e.g. Bet365), inspired Microsoft to introduce the Orleans framework [11] and also frequently used in FP7 research projects (e.g. ParaPhrase [12], RELEASE [13]). Erlang is a dynamically typed, concurrent, distributed, functional programming language. The most important language elements are the functions that are built up from function clauses. Each function clause contains at least one expression (called a top-level expression) or a sequence of top-level expressions, which usually corresponds to the smallest code clone.Not surprisingly, a huge amount of legacy code exists written in Erlang, which likely contain code clones. Unfortunately, the difference between the functional and the object oriented paradigms is so significant that general algorithms cannot accommodate themselves and do not reveal all the clones in Erlang programs. To provide the complete visibility of the clones specialised algorithms [2–4] for Erlang were proposed in previous work by the authors. Our algorithms take into account the domain-specific knowledge of the language to improve their results. This knowledge is provided by RefactorErl [14,15] that is a source code analysis and transformation tool for Erlang.Clone IdentifiErl [2,3] is the outcome of our previous work, which plays an important role in this paper so we briefly describe it. It is an AST/metric-based clone detection algorithm, often mentioned as the matrix-based clone detection, since the set of candidates is represented in a matrix. The matrix is indexed with the top-level expressions of the analysed program. The elements of the matrix express the similarity between the expressions: m[i,j] is the result of the Dice–Sørensen metric [16] for the ith and the jth expression. Dice–Sørensen metric was chosen, because it has a linear computational cost, nevertheless, the metric can be seamlessly replaced with other string similarity metrics. During the initial clone detection the algorithm searches for different patterns along the diagonals of the matrix that describe the clone pairs. However, the result set contains lots of irrelevant clones – adding no value to the result. Therefore, a special filtering phase [3] is applied to the result to remove the irrelevant clone pairs. The result contains filtered clone pairs that are pairs of top-level expression sequences.The elements of the pairs are associated with each other by the isClone binary relation for that the following important properties hold:•The isClone relation is symmetric. Namely, if C1 and C2 form a clone, then C2 and C1 form a clone, too.The relation is not transitive that means that if(C1,C2)∈isCloneand(C2,C3)∈isClonethen the[C1,C2,C3]group can only be formed if(C1,C3)∈isClonealso holds.Let us provide an overview focussing on the structure of the clones detected. Roy et al. [1] observed that a clone detector can efficiently report the detected clones in exactly one structure – clones can be reported as either pairs or groups. Due to their specific representation, suffix tree based duplicated code detectors [17] determine and group clones in one-step. Randy et al. proposed an algorithm [18] that works on two levels (statement and block). On the block level, they determine groups of initial clones based on the similarity of their blocks by using maximal cliques.Although, if the representation of the algorithm does not aid to retrieve grouped clones, grouping the result is a further step. SeClone [19] supports automatic grouping on file-level type usage by using the Suffix Tree Clustering algorithm. Tairas et al. [20] use Latent Semantic Indexes (LSI) to group clone classes that are the result of a syntax-driven clone detection algorithm. In general, LSI uses singular value decomposition technique to identify relations between terms and concepts in unstructured text. The proposed approach exploits LSI to reveal relationships among clone classes that are not based on syntactical structures.Contrary to the grouping algorithms specialised for the result of a certain detector, we introduced a broadly usable, standalone grouping algorithm [5], and now we propose its revised version that is the main contribution of this paper. While the specialised algorithms enforce either the existence of strong constraints or the computation of extra properties, the only assumption of our algorithms for the accepted inputs is the isClone relation associating all the given pairs with each other. Only implying that if a code snippet is the clone of another code snippet then the another code snippet is the clone of the code snippet. Considering that these pairs are clone pairs this constraint is the possibly weakest constraint. Another important point is our methods do not discover new relations between the existing clone pairs. The basis of our algorithms is the already existing relationship between the clone pairs – the algorithms only reorganise the result set without introducing new elements.Regarding to the algorithm proposed in [5], the key observation is that representing the isClone relation between pairs using a graph provides a new view of the problem with already existing solution. What follows is the overview of applying the key idea in a nutshell.First, an undirected graphG=(N,E)containing no loops needs to be constructed as follows:∀n1∈N∃cp∈isClone∃n2∈N,n1≠n2:cp=(n1,n2)∨cp=(n2,n1)That is, all components of the pairs appear as nodes in G. Nodes are linked together if and only if they form a pair in the isClone relation.{n1,n2}∈E⟺(n1,n2)∈isClone∨(n2,n1)∈isCloneFirst observe that clones belonging to the same group form a clique of G. A clique is a complete sub-graph in an undirected graph. The number of elements forming a group needs to be maximised, because a compact view is desired. Thus, it is observed that special cliques need to be found, namely the maximal cliques. A maximal clique is a clique that cannot be extended by including one more adjacent node. The reason for the necessity of finding all maximal cliques becomes clearer, if we consider that a three-element size clique includes three different two-element size cliques. In this case, it means that a three-element size group contains three different two-element size groups. Based on these observations, it can be stated that this kind of grouping is analogous to another known mathematical problem that is about finding all maximal cliques[21] in a graph.Each maximal clique of G is equivalent to a clone group by considering the nodes of the clique. This method can be plugged after almost any algorithms to provide a more compact view of the results aiding in comprehending the results.This section contains the main contribution of the paper. It is introduced by the examination of the initial approach highlighting the scenario when the initial approach is not the perfect choice. Next, the revised approach is described in detail, which provides the expected result for the scenario.We have further analysed the result of the presented grouping method. Although it worked well on the metric based clone results, we missed some elements from the result. We describe this problem with an example.The units of the matrix-based clone detection algorithm (Section 2.1.1) are top-level expressions (TLE) of the analysed functions. Two TLE-s (i and j) are considered to be clones, if the result of the Dice–Sørensen metric is over a given threshold. If (i,j) form a clone and(i+1,j+1)form a clone as well, it is reasonable to present them as one two-unit long clone rather than two different one-unit long clone. Therefore, the matrix-based algorithm tries to maximise the length of the found clone candidates, thus it searches for certain patterns in the matrix to find several-unit long clones as well.Based on this, the input of the grouping algorithm is a set of maximised-length clone pairs. Therefore the result of the grouping contains only the maximal length clones. However, it is also possible that a clone group exists that has more element than the determined group, but the length of the clones in the group is not maximal. It is the case when a code fragment is included by different larger clones. We demonstrate the relevance of these clones with the example presented in Fig. 1.Three functions are presented. It is obvious that the functions starting on the 10th and on the 18th lines are the same. The function staring on line 26 is originated from the previous functions just two additional lines are added (line 27 and line 33). The result of the matrix-based clone detection is the following:(19…24,11…16),(28…32,19…23),(28…32,11…15). The elements of the pairs are the line number ranges of the source code selecting the detected clones.We present the graph and the result of the maximum clique algorithm in Fig. 2.The matrix-based detection tried to maximise the length of the clone, therefore the clone pair(19…23,11…15)is not presented in the result. Thus, the grouping method cannot find the group(19…24,11…16,28…32), which contains all the related members. Clone groups containing all the related members are called maximised sized clone groups. Maximal sized clone groups play a key role when the detected clones are planned to be eliminated. The reason beyond their value becomes obvious, if we consider that these clones are likely to be included by larger clone groups, so their elimination needs to precede the elimination of the related larger clones to get the most compact source code as the result of the clone elimination process.Based on this, we can conclude that not just the length of the clones is relevant, but also the size of the clone groups. So, we have to define a two-dimensional maximisation over the clone pairs.Hereinafter we propose the revised version of the grouping algorithm that is able to find all of the groups even in the case of detectors resulting in one-dimensionally maximised clones consisting of multiple units. Of course, considering one-unit long clone pairs as input, the revised version of the grouping algorithm is still capable of constructing the same clone groups as the initial approach results in.In this section we present the revised approach of the grouping algorithm which satisfies the two-dimensional maximisation criteria in the course of clones detected by Clone IdentifiErl. When the result of a clone detector needs to be grouped that shares the same properties as Clone IdentifiErl has, this approach is the perfect choice.To clarify the constraints need to be satisfied by all clone pairs, which are the input of this approach, we use an illustration. The study in Fig. 3shows an artificial clone pair denoted by C1 and C2. As the elements of the clone pairs are associated with each other by the isClone relation, we know that the C1 is the clone of C2 and C2 is the clone of C1. But, what can C1 and C2 actually be? That is what the right half of the figure illustrates. Since the approach is language independent, they may be 2 token series separately built up from 4 tokens, or 2 code blocks individually containing 4 statements or 2 sequences each of which consisting of 4 top-level expressions. Tokens, statements and top-level expressions are the so-called units – the basic blocks of the language in which the code snippets were implemented. There is one constraint, the counts of the units building up C1 and C2 need to be the same (i.e. each of C1 and C2 has 4 units). Focussing on the units of the clone pair, observe that each two units at the same place need to be the clones of each other. It can be said that a relation sharing the properties with the isClone relation (i.e. reflexivity and symmetry) associates the pairs of the units independently with each other. It implies that the clone pairs reported by clone detectors examining only semantic properties cannot be grouped by our approach, as clone pairs with different lengths may be the part of their results. While all the constraints are guaranteed, our approach is capable of working with clone pairs implemented in any programming language and detected by any clone detectors.Now we present our approach after the constraints got clarified. The algorithm accepts a set consisting of clone pairs as input and results in a set of clone groups. Members of clone pairs are not limited to be single syntactic units, even a valid sequence of units can form a member. (Note that the latter case occurs more often when code clones of real-life applications are considered.) A sequence of units are considered to be valid if and only if the units of the sequence appear in the same order as they can be found in the source code. If this criteria was not taken into account, false positive clone pairs would appear in the result. Units are uniquely identified by indices, which will be used to represent the clone pairs by the presented algorithm. An n-unit long clone pair (Un×2) is represented as a matrix containing two n dimensional vectors standing for the two members of the pair. The elements of the vectors are the indices, thus the algorithm works with matrices ofIn×2. The set containing all the matrices each of that corresponds to exactly one initial clone pair belonging to the given set as input will be further denoted by CP.If all the members were present in the result, all two dimensionally maximised clone groups would be detected by the initial approach. Thus, to detect not only the maximised length long but also the maximised sized clone groups, specific parts of clone pairs need to be extracted to recover the missing members of the maximised sized groups. (Refer to Section 3.1 for the reason behind the missing members.) Observe that the missing members represent code fragments that are included by separate clone groups. Note that these parts are still matrices but they contain less rows.Now, the underlying idea of the algorithm is being outlined. That is, the missing members of the incomplete groups need to be recovered and used to build the graph sharing the same properties as presented in the initial approach. From that graph all maximal cliques need to be collected. Now, the collected cliques do contain all two dimensionally maximised clone groups and perhaps their subgroups. In order to avoid overloading users with repetitive results, the groups get cleaned before the algorithm terminates. These ideas are going to be precisely discussed and formalised in more detail throughout the rest of this section. Moreover, a running example is presented to illustrate the main steps of the algorithm. In the course of the example the following four clone pairs got grouped:{((bcq)T(xyz)T),((bcq)T(efr)T),((ab)T(de)T),((def)T(wxy)T)}.Before the grouping algorithm takes place, the missing members need to be recovered. There is one very important property that will be exploited during this phase. Namely, all missing members are already present in the set of the clone pairs, but, unfortunately, in an improper form. In fact, these elements are included by the existing longer members of clone pairs. This implies that rules selecting exactly the proper elements that are targeted by the extraction need to be defined for the recovery process.Thus, let us investigate the objects targeted by the extraction. At first observe that only those members should be extracted with which at least one new clone pair can be formed. This guarantees that no isolated code fragment will exist among the recovered members.Next, consider that the input of the grouping phase is pairs the elements of which are clones of each other. Thus, it can be said that ‘for all pairs given as input holds the isClone relation’ is an invariant. To avoid isolated code fragments and false positive clones, any new pairs not satisfying the invariant or the isClone relation need not to be added to the output of the recovery phase.Let us investigate the isClone relation. Observe the fact that if any common continuous parts of two distinct clone pairs exist, a missing member of a to-be-created clone group can be extracted from the two clone pairs. Two clone pairs have a common continuous part if and only if two of the vectors forming the two pairs at least partially select the same non-empty range of indices. To formalise the property let us assume thatC1∈In×2andC2∈Im×2are the tested clone pairs. Note that the clones do not need to have the same amount of rows, meaning the case ofn≠mis valid. Let us define the set consisting of vectors by function cmns and denote the predicate testing the property by R and let us formalise them as follows:cmns(C1,C2)={C∈Id×1|0≤d<min(n,m):∃i,[i…i+d]⊆[1…n]∨[i…i+d]⊆[n+1…2n]:C=vec(C1)[{i…i+d},{1}]∧∃j,[j…j+d]⊆[1…m]∨[j…j+d]⊆[m+1…2m]:C=vec(C2)[{j…j+d},{1}]}.Observe that the equivalence of i and j is not requested. The reason that enables the non-equivalence is the symmetry property of the isClone relation.R(C1,C2)⟺|cmns(C1,C2)|>0.If predicate R holds for two clone pairs, it means that the clone pairs are related to each other. Namely, both the pairs represent different clones containing the same code fragment. This becomes obvious, if we study the following simplified example. Let us assume thatC1=((ab)T(cd)T),C2=((be)T(fg)T). In this casecmns(C1,C2)={(b)}⟹R(C1,C2)=↑. Meaning that both C1 and C2 represent separate clones including b.By using predicate R, the set of related clone pairs (further denoted by RCP) can be defined as follows:RCP={(CP1,CP2)|(CP1,CP2)∈CP×CP,CP1≠CP2,R(CP1,CP2)}.Regarding to our running example RCP contains all the possible combinations of any two clone pairs, because all the clone pairs are related to each other.Clone pairs have either no or even multiple common continuous part. If so, their maximised length long common continuous part is definite and assigned by function cmn⁎ to any two clone pairs as follows:cmn⁎(C1,C2)=⁎argmaxC∈cmns(C1,C2)dim(C).Let us highlight the meaning of the maximised length long common continuous part by our running example.cmn⁎(((bcq)T(xyz)T),((bcq)T(efr)T))=(bcq)T,cmn⁎(((bcq)T(xyz)T),((ab)T(de)T))=(b)T,cmn⁎(((bcq)T(xyz)T),((def)T(wxy)T))=(xy)T,cmn⁎(((bcq)T(efr)T),((ab)T(de)T))=(b)T,cmn⁎(((bcq)T(efr)T),((def)T(wxy)T))=(ef)Tcmn⁎(((ab)T(de)T),((def)T(wxy)T))=(de)T.Even thought the missing members (In×1) need to be recovered, the recovery phase generatesCP′.CP′is a set containing such clone pairs (In×2) that are called the sub-clones of the clone pairs given as input. A sub-clone is a clone, for which the isClone relation still holds, produced by deleting some rows of an initial clone pair. Actually, the isClone relation always holds for such sub-clones, because all the clone pairs belonging to isClone were constructed by joining some one-unit long clones for which the isClone relation had initially held. As an example, considerC=((abc)T(def)T)and all of its valid sub-clones listed as follows:S={((a)(d)),((b)(e)),((c)(f)),((ab)T(de)T),((bc)T(ef)T),((abc)T(def)T))}. By generating clone pairs instead of clone members, neither isolated code fragments nor false positive clones can be produced.The method of generating the proper elements ofCP′, all of which are sub-clones, is introduced.CP′={B′,D′|B′=B[{k,k+d−1},{1,2}],D′=D[{l,l+d−1},{1,2}](B,D)∈RCP,C⁎=cmn⁎(B,D),d=dim(C⁎):(C⁎=B[{k,k+d−1},{1}]∨C⁎=B[{k,k+d−1},{2}])∧(C⁎=D[{l,l+d−1},{1}]∨C⁎=D[{l,l+d−1},{2}])}.Note that if transitivity held for the pairs associated to each other by the isClone relation, one more clone pair could be immediately produced using the two clone pairs.Before closing this section, the generated elements ofCP′is presented separately for each clone pair of our running example, thusCP′is the union of the determined sets.CP(((bcq)T(xyz)T),((bcq)T(efr)T))′={((bcq)T(xyz)T),((bcq)T(efr)T)},CP(((bcq)T(xyz)T),((ab)T(de)T))′={((b)T(x)T),((b)T(e)T)},CP(((bcq)T(xyz)T),((def)T(wxy)T))′={((bc)T(xy)T),((ef)T(xy)T)},CP(((bcq)T(efr)T),((ab)T(de)T))′={((b)T(e)T)},CP(((bcq)T(efr)T),((def)T(wxy)T))′={((bc)T(ef)T),((ef)T(xy)T)},CP(((ab)T(de)T),((def)T(wxy)T))′={((ab)T(de)T),((de)T(wx)T)}.CP′={((bcq)T(xyz)T),((bcq)T(efr)T),((b)T(x)T),((b)T(e)T),((bc)T(xy)T),((ef)T(xy)T),((bc)T(ef)T),((ab)T(de)T),((de)T(wx)T)}.With CP andCP′, the proper graph can be constructed, from which all the clone groups can be gathered as follows. An undirected graph with no loops is constructed, which is similar to the graph presented in Section 2.3. There is one serious difference between the graphs of the two approaches. Namely, data used as the basis to determine both the nodes and the edges of the graphs are different. The initial approach directly works with the output of a duplicated clone detector, while the revised approach transforms and also extends the given input at first. Once the nodes and the edges building up the graph are determined, the same algorithm is applied to gather all proper maximal cliques as presented in the initial approach.The nodes of the graph are the elements of the set N, while the set of edges can be derived from the set E.N={C1,C2|(C1C2)∈CP∪CP′}.E={{C1,C2}|(C1C2)∈CP∪CP′}.Regarding to our running example, Fig. 4illustrates the constructed graph, while the set of nodes are presented from which the set of edges are trivial enough not to detail here.N={(bcq)T,(xyz)T,(efr)T,(b)T,(x)T,(e)T,(bc)T,(xy)T,(ef)T,(ab)T,(de)T,(wx)T,(def)T,(wxy)T}.Note again that all maximal cliques selecting at least two nodes are collected from the graph and further examined. Each collected clique determines a clone group by its nodes, from which a matrix representing the nodes of the clique as columns is constructed. Each column represents exactly one node in the clique, and each node corresponds to exactly one column in the matrix. Thus, a set of clone groups (denoted by CG) can be directly derived based on all the collected cliques.According to our running example, Fig. 5highlights the maximal cliques while the set CG is as follows:CG={((b)T(e)T),((bcq)T(efr)T),((bcq)T(xyz)T),((e)T(x)T),((ab)T(de)T),((de)T(wx)T),((def)T(wxy)T),((bc)T(xy)T(ef)T)}.CG contains all the clone groups that are two-dimensionally maximised, and unfortunately includes some unnecessary groups. These groups are the side-effects of the recovery phase. The members of these groups were extracted from clone pairs in the hope that they will be essential to complete an incomplete clone group. All these groups are considered unnecessary, because all of them are completely included by a clone group that either consists of more columns but less rows or is the exact copy of the covered group. Regardless of which case is the corresponding for a particular group, this group is the sub-clone group of the covering clone group. Thus, the existence of these sub-clone groups is completely useless, it just increases the cardinality of the result set making the comprehension of the result more harder. Therefore, it can be stated that the removal of these groups is a requirement.As the grouping approach assumes that the given set of clone pairs contain only such valid clone pairs that cannot be lengthen by extending either its beginning or its ending with some new units, any unnecessary groups appearing in the result is artificial and can only be the side-effect of the recovery phase. These groups will be referred as fake artificial groups in the rest of the section.To remove only the fake artificial groups from the result, these groups need to be typify at first. Thus, let us investigate the recovery phase to identify the places of which where the problem space, which is initially the set of clone pairs given as input, can be extended with artificial groups. It can be stated that all of the performed conversions between data types (for instance sequences of pairs into matrices with two columns or set of vectors into matrices and vice versa) are one-to-one mappings that preserve the number of the subjects. Next, observe that there is only one potential place remains considering the whole recovery phase. This is the place where the missing members are recovered – the construction of the setCP′. As the first attempt, we could consider all elements ofCP′fake artificial groups but this would be totally wrong. At first, observe that CP andCP′are likely to contain common elements. These elements are such clone pairs that are the result of extracting maximal length long sub-clones of two clone pairs associated to each other by the following relation. The relation is the sub-clone relation, to be more precise, a dedicated case of it. That occurs when one of the two clone pairs is completely included by the other clone pairs. At least one of the elements originating from such two clones was already present in the initial set of clone pairs given as input, thus it cannot be artificial. Thus, the set of artificial groups can be determined as follows:A=CP′⧹CP. However, considering that a code fragment can be included by multiple different clones, set A should contain only some members instead of complete groups. So, let define set A again.A={CP1′,CP2′|(CP1′CP2′)∈CP′}⧹{CP1,CP2|(CP1CP2)∈CP}.Next, observe that the reason of constructing the setCP′is to generate artificial members to gather all maximised sized groups, thus it is not likely that A equals to the set of fake artificial members (further denoted by F), but A includes F. Elements belonging toA⧹Fare such artificial members that were actually used to form a maximised sized group. As an example, consider(bc)T∈Ain the course of our running example.As clone pairs are given as input, there is no need for artificial members to form a clone pair. Thus, if an artificial member was really used to form a group, the group contains more than two members. This observation leads to the definition about which clone groups need to be removed from the final result. Let the set of to-be-removed groups be denoted by D and defined as follows.D={C|(C1C2)=C∈In×2C1∈A∨C2∈A}.Finally, let us define the result of the grouping phase containing all two-dimensionally maximised clone groups as the difference of CG and D:Result=CG⧹D.With respect to our running example, we determine the result of the grouping method as well.Result=CG⧹{((b)T(e)T),((e)T(x)T),((de)T(wx)T)}={((bcq)T(efr)T),((bcq)T(xyz)T),((ab)T(de)T),((def)T(wxy)T),((bc)T(xy)T(ef)T)}.

@&#CONCLUSIONS@&#
