@&#MAIN-TITLE@&#


@&#HIGHLIGHTS@&#
Domain-specific language for reactive systems with imperative programming notation.Hierarchical components for hierarchical abstraction of reactive control functions.Visual language presentation automatically generated from source code.Formal definition of the semantics in the form of labeled transition systems.

@&#KEYPHRASES@&#
Domain-specific languages,Automation control,Reactive programming,Component-based systems,

@&#ABSTRACT@&#
In this paper, we present Monaco – a domain-specific language for developing event-based, reactive process control programs – and its visual interactive programming environment. The main purpose of the language is to bring process control programming closer to domain experts. Important design goals have therefore been to keep the language concise and to allow programs to be written that reflect the perceptions of domain experts. Monaco is similar to Statecharts in its expressive power, but adopts an imperative notation. Moreover, Monaco uses a state-of-the-art component approach with interfaces and polymorphic implementations, and enforces strict hierarchical component architectures that support hierarchical abstraction of control functionality. We present the main design goals, the essential programming elements, the visual interactive programming environment, results from industrial case studies, and a formal definition of the semantics of the reactive behavior of Monaco programs in the form of labeled transition systems.

@&#INTRODUCTION@&#
The demand for languages and tools that support domain experts in implementing process control solutions is increasing [1–3]. In industrial automation, domain experts commonly extend and adapt their control solutions to fulfill the specific requirements at hand. They must intervene in safety-critical, highly dependable systems and are often expected to alter programs while the machine is in operation and to make these changes effective at run time using online-change capabilities. However, domain experts usually lack “deep” software engineering skills and expertise, requiring programming environments to provide extensive support, guidance, and supervision.Domain-specific languages (DSLs) [4] are a proven approach to bringing programming closer to application domains. They aim to present software in the notations of domain experts and allow a straightforward mapping of application concepts to software solutions. Many domain-specific languages and modeling approaches have emerged in the automation domain [5–8]. For example, domain-specific modeling systems for specifying control behavior in the form of function block diagrams[8–10] have been very successful and can be considered state-of-the-art. Specifying reactive behavior, however, has proved to be more challenging. In this context, the Statecharts formalism [11,12], and its derivatives (e.g. [13,14]) are widely used for expressing complex reactive system behavior, but these modeling approaches target software engineering experts rather than domain experts.Therefore, we have developed a new DSL called Monaco (Modular NOtation for Automation COntrol), the goal of which is to allow implementation of event-based, reactive process control programs in a concise and intuitive manner. The context of this work is a collaboration with Keba AG (www.keba.com), a medium-sized company developing and producing hardware and software platforms and solutions for industrial automation. In their practice, development of automation solutions is a multi-stage process involving various stakeholders at different stages of the automation process with varying levels of programming knowledge and capabilities:•Keba develops and produces a hardware and software platform with associated tool support.The hardware and software platforms enable Keba customers (mainly OEMs of manufacturing machines) to realize automation systems for their products. Employees of OEMs, however, are often domain experts with limited software engineering capabilities.OEMs also build customizable software systems and electronic control panels for use by machine operators who act as end user programmers.The Monaco language is specialized to a rather narrow subfield of the automation domain, that is, programming control sequence operations of manufacturing machines. This narrow domain includes all types of automated machines, but excludes bigger automation systems such as whole manufacturing plants. Within the numerous layers of automation systems Monaco is designed to address the layer of event-based control of machine operations between the lower-level continuous control and signal processing layer and the higher-level manufacturing execution layer.Monaco has been designed to allow the programming of sequences of control operations, to enable parallel activities, and to provide strong support for dealing with exceptions. In its expressive power, Monaco is therefore similar to Statecharts, but adopts an imperative notation similar to other languages in the domain [15]. Most importantly, however, Monaco's distinguishing feature is its hierarchical component approach, which allows building automation solutions in an arrangement of upper and subordinate components. Thus, it supports abstraction of reactive control behavior in several hierarchical layers and building reusable components. Hierarchical abstraction of control tasks results in simplifications that bring control programs closer to the perceptions of domain experts.This paper makes the following contributions:−It introduces Monaco as a novel programming language with a state-of-the-art component approach for programming reactive control systems. We show that its expressive power is similar to that of Statecharts. Monaco, additionally combines reactive system programming elements with an imperative programming notation and approved language concepts from structured programming.It shows that the Monaco language allows implementing control programs in a concise way. In particular, we show how the aligned language features of Monaco facilitate hierarchical abstraction of control functionality.We show that Monaco's small set of language elements is both expressive and intuitive. In particular, we demonstrate that Monaco is capable of expressing complex reactive control functionality in a way that coincides closely with domain expert perceptions.We show a simple visualization scheme and the interactive development environment for Monaco programs which makes Monaco control programs even more appealing to domain experts.We give a formal definition of the semantics of the reactive behavior of Monaco programs in the form of labeled transition systems.The Monaco language and its visual notation were first published in [16,17], respectively. This paper subsumes and extends this work by providing a detailed presentation of the language, giving a formal definition of the semantics of the language, and presenting results from implementation and case studies.The outline of this paper is as follows: Section 2 discusses principal ideas for the design of the language. Section 3 introduces the main language elements of Monaco. Section 4 demonstrates how hierarchical control programs can be built using an example control program for an injection molding machine. In Section 5 the interactive visual programming environment is presented. In Section 6 we give a formal definition of the reactive behavior of Monaco programs. Section 7 discusses implementation and results from industrial case studies. Section 8 compares the approach to related work, and Section 9 concludes with a summary and an overview of follow-up work.In discussions with domain experts at our industrial partners, we learned how they conceptualize automation machines. From these findings, we derived the following language design features:Imperative notation: The main motivation for designing a new notation for event-based control systems instead of using, for example, the well-established Statecharts formalism was the observation that domain experts think in sequences of control tasks and their coordination rather than in states and state transitions. Further, we observed that in normal operation mode, that is, without considering abnormal or erroneous behavior, the basic control flow is often inherently sequential. Asynchronous behavior arises only in abnormal situations and exceptions. Our language therefore allows expressing normal behavior as a sequence of operations. In addition, it adopts proven concepts from imperative languages such as procedural abstraction, synchronous procedure calls, parameters, block structure, and static scoping.Concise event handling: Automation control systems are characterized by asynchronous events and parallel activities. Therefore, we introduced statements which allow expressing event handling, parallelism and synchronization, exception handling, and timeouts in a concise way. However, asynchronous event handling occurs in separate handler code segments. This approach is similar to exception handling in state-of-the-art object-oriented programming languages, which avoids contaminating the code for normal behavior with exception handling code.Component-based hierarchical control architectures: Domain experts perceive automation machines as an assembly of independent components working together in a coordinated fashion. Therefore, Monaco pursues a component-based approach in which software component structure resembles the structure of the machine to be controlled. Components are modular units (black boxes) which communicate exclusively via defined interfaces. Unlike many other component-based approaches in this domain, such as UML/RT [18] and IEC 61499 [19], Monaco enforces a strict hierarchical control architecture of subordinate and superordinate components in master–slave arrangements. A component relies only on the operations and state properties of its subordinate components. It composes and coordinates the behavior of its subordinates and provides abstract and simplified views to its superordinate component. Thus, the language supports hierarchical abstraction of control functionality. We argue that this (i) results in more precise and easier to comprehend control programs and (ii) reflects the perceptions of domain experts.It should be noted that such a hierarchical architecture can also be realized by other component-based approaches (see [20] for an example in the IEC 61499 modeling language). However, Monaco provides special language constructs and thus enforces strict hierarchical component architectures.Static configuration: The setup of Monaco programs (i.e., instantiating and assembling components and setting their parameters) is done in a separate configuration phase prior to program execution. Hence, the whole system is statically configured: all components, component parameters, and array sizes are defined. After the program has started, this configuration cannot change, which makes Monaco programs static. For example, although subcomponents of components are polymorphic, they are defined at setup time, and dynamic method binding is not required. This static nature of Monaco programs allows run-time-optimized code to be generated, which avoids memory dynamics at run time and guarantees real-time properties.Visual programming notation: In addition to a text-based notation, there is a dual visual representation of Monaco programs, which is usually preferred by domain experts and end users. Unlike other visual programming approaches in the domain, for instance, Statecharts modeling tools, the visual representation is created automatically from, and is synchronized with, the source code, i.e., generated without user involvement.We have designed Monaco as a component-based language with an imperative notation with a Pascal-like syntax and an event handling mechanism similar to that of Statecharts. Below, we first outline the component approach and then the reactive programming features of the language. We present the language elements using abstract code samples and compare them to UML and Statecharts.As outlined above, Monaco enforces a strict hierarchical component architecture of superior components and subcomponents which communicate via defined interfaces. Therefore, the component approach of Monaco comprises component interface declarations, parameterizable component implementations with polymorphic subcomponent declarations, and a static configuration creating a tree of component and subcomponent instances.Interface declarations (Fig. 1) are used to define the static contract between components and their clients and thus have a similar purpose as interfaces in state-of-the-art object-oriented languages. However, interfaces in Monaco express the hierarchical communication architecture of control programs. On the one hand, an interface defines the externally visible operations a component provides to its user in the form of routine and action declarations. These represent the commands a superordinate caller will be able to invoke. On the other hand, an interface defines how a component will provide feedback about the fulfillment of its control tasks. To this end, it specifies functions for accessing run-time state properties of the component. In other words, the routines and actions define the command operations a component can perform, and the functions define the feedback the component will provide. Additionally, interfaces can define input variables which allow a component to receive dynamic properties as input.Interfaces are implemented by components (Fig. 2), which means that components must implement the inputs, routines, action, and functions defined in the interfaces. A component has parameters and internal state variables. A parameter is a run-time constant used to configure a component instance at setup time, while a variable is used to hold run-time state properties of a component.Components usually rely on subcomponents in fulfilling their control tasks. A component therefore declares subcomponent variables which can hold references to subcomponent instances. Interface types are used in the subcomponent variable declarations. Hence, a subcomponent declaration defines the interfaces required for the subcomponents (Fig. 2). This means that subcomponents are polymorphic: any component implementing (providing) the required interface can be used. The actual subcomponent instance is plugged into the subcomponent slot at setup time (see below). Note that there are no access modifiers in Monaco. Only elements defined in the implemented interfaces of the component are externally visible.Components implement functions, actions, and routines. A function implementation in a component is similar to functions in procedural programming languages such as Pascal. They return run-time state properties of components. In Monaco, functions have no side effects and must not contain blocking statements. Usually, functions are used to compute dynamic properties from lower-level properties of subcomponents, which they forward in a more abstract, concentrated form to the component above.Actions and routines are used to implement control algorithms and therefore constitute the central programming elements of components. Whereas actions represent atomic procedures which cannot block, routine implementations implement longer-term control activities which usually have blocking calls (WAIT, see below). Routine implementations are discussed in detail in the next section.Further, the component must define the inputs for the subcomponents. This is done in the BINDINGS section, where for every input variable of a subcomponent, the input value is defined by an expression. Typically, the expression will access function values from other subcomponents and possibly its own input values to define the value for the input variable of the subcomponent. So an input variable binding simply functions like a value definition which is evaluated whenever the variable is accessed. In this way, subcomponents can exchange property values.Interfaces also can be implemented by so-called native components. Native components are the lowest level components in the component hierarchy and build the interface to the underlying hardware layer or lower-level control system. They are not implemented in Monaco but in the language of the run-time system, i.e., in C++ for our C++ run-time system.Actions of native components form the output commands of a Monaco program and the functions form the input interface of a Monaco program. We therefore speak of−external output actions for actions of native componentsexternal inputs for the functions of native components.In order to create a complete Monaco program, Monaco components need to be instantiated and the component/subcomponent relations established (Fig. 3). Furthermore, component parameters must be set (if the desired values differ from the defined default values). This static system configuration is established in a setup phase prior to program execution. First, components are instantiated by declaring variables in a VARS section, and then parameter values are set for the component instances. Finally, the component/subcomponent relation is established by plugging component instances into subcomponent slots. The language allows for arrays of components and loops for iterating over component arrays.The component configuration cannot be changed while executing a Monaco program. Note that native components form the leaves of the component hierarchy.Functions, actions, and routines are similar to procedures in imperative languages. They are called in the same way as methods in object-oriented languages. In particular, a function, action, or routine defined in the interface of a subcomponent is called by the subcomponent variable name and the function, action, or routine name plus actual parameter separated by a dot. They can have parameters and local variables, and have a body with a statement sequence. Approved language constructs from structured programming languages such as block structure, lexical scoping, loops, and conditional statements are provided (we do not discuss these common constructs further).Aside from these common features, the differences between functions, actions, and routines are significant and important for defining the run-time properties of the language (see also Section 6).−Functions compute run-time state properties of components which are returned by the functions as result values. They usually access internal state properties and values given by functions of subcomponents from which they compute more abstract values. Functions can use Boolean and arithmetic operations, and conditional statements and loops, but must not use blocking statements (see below). Additionally, functions must not have side effects.Actions encode single commands to a component and are similar to procedures in imperative languages. They usually set variables and call other actions. Like functions, actions can use common statements and operations, and conditional statements and loops, but must not use blocking statements.Unlike actions, routines can use blocking statements and therefore implement longer-lasting control activities. They use exclusively the reactive statements presented below.For reactive programming, Monaco provides the following three language constructs: conditional wait statement, ON statement, and parallel execution statement.The WAIT statement is provided to suspend execution of the current execution thread until a specified condition is satisfied. In contrast to many other reactive languages, which usually require an event object as trigger, any Boolean expression can be used. The equivalent of a WAIT in Statecharts is a state node with the condition as triggering event (Fig. 4).ON handlers are used to handle events which can occur asynchronously from normal, sequential program execution. ON handlers specify an arbitrary event condition and are attached to BEGIN/END blocks (Fig. 5). Their role is that whenever the condition of the ON handler becomes true while program execution is within the BEGIN/END block, the block is left, and the statement sequence of the ON handler is executed. For ON handlers to be meaningful, the guarded BEGIN/END block must have blocking statements (i.e., WAIT statements) at which program execution is suspended and the event condition test can occur (program execution from one WAIT state to the next is atomic and cannot be interrupted; see Section 6 for details).ON handlers in Monaco are similar to OR states and their transitions in Statecharts. Fig. 5 shows the relation. The OR state groups the states (e.g., the blocking WAIT statements) and transitions within the BEGIN/END block. The transition leaving the OR state is labeled with the condition of the ON handler. An arbitrary sequence of statements can follow. Since ON handlers have interruptive behavior, program execution continues with the first statement after the block.The behavior of an ON handler is interruptive by default. However, the RESUME statement can be used to resume execution of the block after the handler code has been executed. It therefore uses the same semantics as the deep history node in Statecharts (Fig. 6). Monaco has no statement equivalent of the normal history node.The PARALLEL statement is used to create multiple concurrent execution threads. Each parallel execution thread consists of a statement or a statement block. As soon as all parallel execution threads have terminated, program execution continues after the PARALLEL statement.The PARALLEL statement has the semantics of the AND state in Statecharts (seeFig. 7).In this section, we demonstrate programming in Monaco with a sample application system. We show how the language constructs presented in Section 3 are used to realize the component-based control program. First, we briefly describe the physical process of injection molding, then we demonstrate decomposition of the system into a hierarchy of components, and finally we show hierarchical abstraction of control functionality by components at different hierarchy levels.We have developed several example applications in Monaco for concept validation. One example is a reimplementation of an existing control program for an injection molding machine, originally implemented in the IEC 61131-3 [15] standard languages. We realized the event-based part of the application in Monaco and coupled it with a simulator for testing purposes. Special emphasis was put on handling errors and malfunctions of the machine, and we showed that the Monaco language is capable of describing machine failure handling in a compact and concise way.Injection molding machines are used to produce plastic parts by injecting heated, semifluid plastic into a mold where the plastic cools down and hardens within a short period. Producing plastic parts with various notches and holes requires an adaptable mold that inserts so-called cores into the molding chamber during the injection process. After the plastic part has hardened, the cores are removed, the part is ejected, and the process is repeated. During the cooling phase, new raw material (plastic pellets) is heated up for the next injection phase.Fig. 8 shows the structure of the sample molding machine with two main components: (i) the mold subsystem with the clamp, the ejector, and a core puller and (ii) the nozzle subsystem that is mounted on a sledge with the material funnel, the heating system, and the screw for injection. As the name implies, the ejector ejects the finished parts from the mold. Below we show code fragments of a simplified version of the example control program.The component hierarchy of the control program resembles the structure of the real machine (Fig. 9). Hence, there is a direct mapping from the problem structure to the solution structure. At the top, the Machine component is responsible for encoding the overall control cycles. It knows various operation modes, such as fully automatic or half-automatic. It relies on and coordinates several subcomponents corresponding to the machine subsystems. The components for nozzle and mold are further decomposed according to the parts of the subsystems. At the bottom of the hierarchy are components for interfacing with hardware or lower-level control layers. These are implemented in the native language of the lower layers; in this example program, Java components form the interface to the simulator.Components at different hierarchy levels typically serve different purposes:−Components at the bottom are used for interfacing with the hardware or lower control layers. They usually set and read basic system variables. This layer is often referred to as hardware integration layer.Components at the first level compose these primitive operations into elementary control routines and supervise their execution.Higher up in the hierarchy are several coordination components which coordinate and supervise the operations of several subcomponents.In the example program, the components forming the leaves of the component hierarchy are native Java classes building the interface to a simulator which simulates the real machine and the continuous control layer. The native components, however, implement a Monaco interface for the superior components (with direct mapping of actions and functions to C functions which implement the interface to the lower-level control layer). The following code snippet shows the interface definition for the core puller component ICore. The interface defines elementary actions to set system variables, to start and stop insertion, and to remove the core, and a function that reports the current position of the core puller.INTERFACE ICoreFUNCTION position(): REAL;ACTION startInsert();ACTION stopInsert();ACTION startRemove();ACTION stopRemove();END ICoreThe components residing in the hierarchy level directly above the native components use these interfaces to compose elementary operations into basic control routines. For example, the CoreCtrl component has the native component as its single subcomponent. It defines two routines to insert and remove the core. Additionally, a stop action which immediately stops all movements is provided.The following code snippet shows part of the CoreCtrl component. In addition to showing declaration of parameters, subcomponents, and variables, it also demonstrates how functions are used to abstract state properties from lower-level information of its subcomponents (see function isInserted).Routines implement the basic control tasks. However, in addition to defining the basic sequence of actions, routines also check for correct execution of control activities and correct reactions from the subordinate. This can be accomplished with ON handlers.The following code snippet demonstrates this approach with the insert routine. First, action startInsert is called from its subcomponent core, which sets a hardware signal and starts the insertion process. Next, a reaction from the isRemoved signal is expected. If this sensor does not return FALSE within a given (brief) time period, a fault in the insertion process or a faulty sensor is assumed, the process is stopped, and an error flag is set. It then waits for the isInserted signal to become true, and then stops the insertion process. Again the process is supervised by two ON handlers: one checks that the isRemoved signal does not switch to true again (which might result from a faulty sensor), and the other checks that the reaction of the isInserted signal occurs in time. In both error cases, the process is stopped and the error is signaled. Additionally, a call from outside to the stop() action sets a stop flag, and the process routine stops all movements and terminates.The control behavior defined so far is provided in a more abstract way in an interface declaration to the superior component. The following code snippet shows the interface ICoreCtrl of the CoreCtrl component. There are routines for inserting and removing the core, an action to stop a process, and two Boolean functions that report whether the core is inserted or removed. Additionally, the isInError function appears in the interface, which means that the superior component is able to check for the errors occurring during execution of the control routines.The next higher-level component we discuss is the MoldCtrl component. It coordinates the operations of the coreCtrl and the clampCtrl subcomponents. Additionally, it uses the pressure input variable to receive a pressure value from the sibling PressureCtrl component. The close routine illustrates how the component coordinates the activities of its subcomponents. The task of the routine is to control the processes of closing the clamp and inserting the core, which should occur in parallel. First, a check is performed that the pressure is above a specified lower threshold. Then both activities are started, but core insertion must wait until the clamp has reached coreInsertPos. ON handlers check for error situations. Whenever the pressure drops below a specified lower threshold or one of the components reports an error, all activities are stopped, and an error is reported to the level above.Finally, the topmost component controls the activities of its four direct subcomponents, pressureCtrl, moldCtrl, nozzleCtrl, and ejectorCtrl. It defines bindings that forward the pressure provided by the pressureCtrl subcomponent to the other subcomponents as inputs.The code snippet then shows the overall automatic control cycle of the machine. The operation cycle of the machine is clearly represented in the code. In the inner control loop, first the mold is closed, then injection occurs, and, in parallel, the cooling time is checked. The mold is then opened and, simultaneously, new material is inserted into the screw (nozzleCtrl.plasticize). After the mold has been opened to a specified point, the piece is ejected.We have developed an integrated development environment for programming in Monaco, based on the Eclipse Rich Client Platform (http://eclipsercp.org/). Its back-end consists of a compiler and a virtual machine (VM). The core component of the IDE's front-end is a GEF-based (http://www.eclipse.org/gef/) visual editor that allows visualization and interactive manipulation of the Monaco programs. A text editor with all typical features, such as syntax highlighting, can be used to edit the source code directly, and the IDE keeps textual and visual representation in sync. In this section, we briefly describe the visual representation of Monaco programs.The visual representation scheme for Monaco programs allows visualization of component structures and the control algorithms implemented in routines. The visual representation of routines maps directly to the source code and visualizes it in two dimensions. Its goal is to exploit two-dimensional space to reveal the event-based control flow. The essential elements to be visualized are block structure, sequential control flow and standard imperative constructs (conditional statements and loops), parallel execution threads, and asynchronous event handling. The tool derives the visual representation automatically from the source code, thereby freeing the programmer from the need to place elements by hand. Further, it allows collapsing and expanding visual elements.Block structure and block nesting are visualized as rectangular shapes of color tones that grow brighter as the nesting level of the block increases. Thus, block nesting is clearly displayed. Sequential control flow is shown in the vertical dimension, and sequential statements are connected with vertical lines.Fig. 10(a) shows the statement sequence as introduced in the insert routine in the example in Section 4. Further, IF–THEN–ELSE constructs are arranged vertically. The horizontal dimension is reserved for parallelism and exception-handling constructs. ON handlers are attached to the right side of the rectangles of their BEGIN/END blocks (Fig. 10(b)). Additionally, the asynchronous event nature of ON statements is emphasized by a lightning symbol. Although the example is very simple, it shows the advantages of the visual representation, particularly in combination with the possibility to collapse and expand program elements. When all ON handlers are collapsed, the normal flow of control is clearly visible (see Fig. 10(a)). Expanding handlers offers the possibility to see coverage of all unexpected events.Statements that are executed in parallel are arranged horizontally side by side. Connecting lines show the forking and joining of parallel execution threads. Additionally, dashed lines separate the thread blocks.Fig. 11 shows the visual representation of the “automatic” routine from the example in Section 3.In this section, we define the semantics of the reactive behavior of Monaco programs by labeled transition systems. This is done in a constructive approach in which labeled transition systems are first defined for elementary statements and essential control structures and then composed by composition operators. This means that the construction process is bottom-up: transition systems of statements are combined using composition operators to build transition systems of routine implementations. Crucial concerns in the construction process are (i) how labels of transitions are formed and (ii) where states are introduced. The reason is that transitions are executed atomically and cannot be interrupted, whereas states represent possible decision points with possibly several follow-up transitions.Thus, for the construction of labeled transition systems of Monaco programs, the distinction between atomic code and code with blocking behavior is essential. Generally speaking, statements are atomic when they do not contain WAIT statements. In labeled transition systems, atomic code appears as labels of transitions, whereas non-atomic code results in transition systems with states. As the goal of Monaco is implementing reactive control logic, we will restrict our formal semantics definition on the reactive part of the language. The semantics of purely imperative code, however, which can be seen as identical to that of traditional imperative programming languages, is not defined in the sequel but assumed to be given by functions which define the effect of imperative code on variable values and outputs.A Monaco program is executed by a run-time system which provides the external inputs from the lower-level layer, triggers the execution of a program step, and receives the external output actions. The Monaco program accesses the external inputs by functions of native components operates on internal variables, and calls the external output actions. The semantics of the reactive behavior is therefore formulated in terms of variables, external input functions, Monaco functions, output actions, Monaco actions and routines. Let us assume a static configuration with a tree of component instances as outlined in Section 3.1 and illustrated in Section 4.2. Then letVbe the set of all variables of all Monaco component instances,Ibe the set of all external inputs provided by the functions of native component instances,Fbe the set of all functions of all Monaco component instances (i.e., functions implemented in Monaco),Obe the set of all external output actions of native component instances,Abe the set of all actions of all Monaco component instances (actions implemented in Monaco),Rbe the set of all routines of all Monaco component instances.Note, that there are unique variables, external inputs, functions, actions, and routines for each component instance.In the following we will formulate the reactive semantics of Monaco programs using those elements. First we define the execution semantics of labels in transitions. Then in Section 6.2, we introduce a labeled transition system formalism and introduce composition operators which we will use in the sequel. We introduce labeled transitions systems for elementary statements in Section 6.3. Then we show how transition systems for the essential control structures and routine calls are built in Section 6.4 and Section 6.5, respectively. This construction process for labeled transition systems resembles the compilation process of Monaco programs. In Section 6.6 we therefore discuss the compilation process and execution system of Monaco programs.Labels are sequences of−imperative code which are basically assignment statements, calls to external output actions, internal actions, conditional statements and loops, and sequences thereofpredicates over variables, external inputs, and calls of internal functions.The execution of imperative code is specified as the effect it has on the values of internal variables and the output actions executed. It is based on current values of variables and external inputs. So let a value assignmentαVfor internal variablesVbe a functionαV:V→Dwhich assigns a unique value to each variable inVwhereDis the universal domain for values. We writeΑ(V)for the set of all variable value assignments. Accordingly, a value assignmentαI:I→Dgives unique values to external inputs and we useΑ(I)to denote the set of all value assignments of external inputs. A functionα:V∪I→Dis a value assignment for variables and external inputs and we useΑ(V∪I)for the set of all value assignments of variables and external inputs. Obviously, given value assignmentsαVandαIa value assignmentα∈Α(V∪I)is defined byα=αV∪αI.LetO⁎be the set of all sequences of external output actions. We use the concatenation operator°for concatenating sequences andεto denote the empty sequence.Without loss of generality we abstract from imperative code in labels and assume the semantics of imperative code to be given by a function which gives the effect of the code in terms of changes of variable values and issued output actions. So letS(V∪I∪F∪O∪A)be the set of all imperative statements using variablesV, external inputsI, internal functionsF, output actionsO, and internal actionsA. Then we assume the semantics ofs∈S(V∪I∪F∪O∪A)be given by functionSDef:S(V∪I∪F∪O∪A)×Α(V∪I)→Α(V)×O⁎i.e.,SDef(s,α)defines the semantics ofsin terms of the resulting variable assignment and sequence of output actions given a current value assignment of variables and external inputs (note, that such a definition can easily be derived using standard operational semantics and follows the line of the operational semantics of traditional imperative languages).Similarly, we assume the semantics of functionsf∈Fto be given by the functionFDef:F×Α(V∪I)→Di.e.,FDef(f,α)gives a value forfgiven the current value assignmentα. Then we define predicates as Boolean valued formulae over variablesV, external inputsI, and internal functionsF. LetP(V∪I∪F)be the set of Boolean formulae over variablesV, inputsI, and functionsF. Again, let the semantics of predicatesp∈P(V∪I∪F)be given by the functionPDef:P(V∪I∪F)×Α(V∪I)→BoolThe set of valid atomic labels are the predicatesp∈P(V∪I∪F)and imperative statementss∈S(V∪I∪F∪O∪A), plusεdenoting an empty label. Then, a concatenation operator°for building sequences of labels is defined: letl1andl2be two labels, thenl1°l2is again a label. Note that the empty sequenceεis the neutral element for the concatenation operator withl°ε=landε°l=l. Further, we allow negation of labels by a not operator (which will be exclusively used to resolve non-determinisms in parallel statements; cf. Section 6.4). So the set of allowed labels is given by the EBNF definitionL=P(V∪I∪F)|S(V∪I∪F∪O∪A)|"ε"|L"°"L|"not"L.Now we introduce three operations on labels which define (i) the changes of internal variable values when executing a label, (ii) the sequence of external actions when executing a label, and (iii) if a label is satisfied and can be executed. Given a current value assignmentα, the execution of a labell∈Lis defined as a function on value assignmentsexec:L×Α(V∪I)→Α(V)withexec(l,αV∪αI)=αVifl∈P(V∪I∪F)∪{ε}exec(notl,αV∪αI)=αVl∈Lexec(s,α)=αV′ifs∈S(V∪I∪F∪O∪A)andSDef(s,α)=(αV′,os)exec(l1°l2,α)=exec(l2,exec(l1,α))The output operator is defined as a functionoutput:L×Α(V∪I)→O⁎withoutput(s,α)=osifs∈S(V∪I∪F∪O∪A)andSDef(s,α)=(αV′,os)output(l1°l2,α)=ouput(l1,a)°ouput(exec(l1,a),α))output(l,a)=εotherwiseFinally, the satisfied operator is defined as a Boolean functionsat:L×Α(V∪I)→Boolwithsat(l,α)=TRUEifl∈S(V∪I∪F∪O∪A)∪{ε}sat(p,α)=PDef(p,α)ifp∈P(V∪I∪F)sat(notl,α)=¬(sat(l,α)l∈Lsat(l1°l2,α)=sat(l1,α)∧sat(l2,exec(l1,α))Note, the last line in the definition of thesatoperator. It defines that the second labell2is evaluated with the variable value assignment established by executing the first labell1.For representing the reactive behavior of Monaco programs, we introduce a labeled transition system as a structureTS=〈V,I,O,S,si,sf,L,T〉,whereVis the set of variables,Iis the set of external inputs,Ois the set of external output actions,Sis the set of states,si∈Sis the single initial state,sf∈Sis the single final state,Lis the set of labels, andT=S×L×Sis the transition relation with the constraintssi≠sf, i.e., we have two unique initial and final states,∀l∈L,sx∈S:(sx,l,si)∉T, i.e., the initial state has no incoming transitions, and∀l∈L,sy∈S:(sf,l,sy)∉T, i.e., the final state has no outgoing transitions.To support definition of sequential composition and inline operators, we first introduce an append operator∼sbsathat appends transitions in a transition systemTSat given statessaandsbas follows: Letsaandsbbe states of a transition systemTSwithsa≠si,sa≠sf,sb≠si,sb≠sf, andsa≠sb,sahas no outgoing transitions, i.e.,∀l∈L,sx∈S:(sa,l,sx)∉T,sbhas no incoming transitions, i.e.,∀l∈L,sy∈S:(sy,l,sb)∉T, and there are no direct transitions fromsbtosa, i.e.∀l∈L:(sb,l,sa)∉T. Then the append operator~sbsaapplied toTS, denotedTS~sbsa, gives a transition systemTS~=V~,I~,O~,S~,s~i,s~f,L~,T~withV~=V,I~=I,O~=O,S~=S\{sa,sb},s~i=si,s~f=sf,All other transitions ofTare carried over unchanged intoT~, i.e., for all transitions(sx,lxy,sy)∈Twithsy≠saandsx≠sbit follows that(sx,lxy,sy)∈T~.The set of labelsL~is naturally defined as the resulting labels in all transitionsT~, i.e.,L~={l|(sx,l,sy)∈T~}.Fig. 12 illustrates the append operator. The transition system is composed at transitions to the statesaand transitions from the statesband the labels of those transitions are concatenated. Note that due to this construction process, a transition tosawith a sequence of atomic statementslxaappended with a transition fromsbwith a sequence of atomic statementslbyresults in one single transition with the statement sequences concatenated and no state in between. Statessaandsbdisappear.Since we want to be able to apply append operations to different states in arbitrary order, the append operator must be associative.LemmaThe append operator is associative, i.e.,(TS~sbsa)~sdsc=(TS~sdsc)~sbsaifsa≠sb≠sc≠sd.A sketch of the proof is given in the Appendix.Equipped with the append operator, we define a sequential composition operator for composing transition systems for code blocks which are put into sequence as follows. LetA; Bbe two arbitrary code partsAandBput into sequence, and let transition systemsTSA=〈SA,sAi,sAf,LA,TA〉be the transition system representing the behavior of codeAandTSB=〈SB,sBi,sBf,LB,TB〉be the transition system representing the behavior of codeB. The sequential compositionTSA→TSBis thenTSA→B=TSA+B~sBisAf,whereTSA+B=〈VA∪VB,IA∪IB,OA∪OB,SA∪SB,sAi,sBf,LA∪LB,TA∪TB〉,i.e., the sequential compositionTSA→TSBis the union of systemsTSAandTSBwith the initial state taken fromTSAand the final state taken fromTSBand the resulting system appended at statessAfandsBi.For the sequential composition of systems to be applicable in arbitrary order, the sequential composition operator must be associative.Lemma→The sequential composition operator is associative, i.e.,(TSA→TSB)→TSC=TSA→(TSB→TSC).The proof is provided in the Appendix.For building transition systems of control flow statements, we define an inline operatorTSI>sTesTbTSTwhich allows inlining of a transition systemTSI– the inlined system – into a transition systemTST– the target system – at begin statesTband end statesTeofTSTasTSI>sTesTbTST=(TST⁎I~sIisTb)~sTesIf,whereTST⁎I=〈VT∪VI,IT∪II,OT∪OI,ST∪SI,sTi,sTf,LT∪LI,TT∪TI,〉i.e., the inline operatorTSI>sTesTbTSTis defined by the union of systemsTSTandTSIwith the initial and the final state taken fromTSTand the resulting system first appended at statessTbandsIiand the resulting transition system then appended at statessIfandsTe.Fig. 13 illustrates the inline operator.For the inline operator to be well defined, the inlined system must contain no direct transitions from initial statesIito final statesIfand no loop transitions from end statesTeto begin statesTb(see WHILE loops in Section 6.4 for an explanation).We want to use inlining of different systems at different states into one target system in arbitrary order.LemmaInlining systemTSI1at statessTb1andsTe1and systemTSI2at statessTb2andsTe2into a target systemTSTcan be done in any order, i.e.,TSI2>sTe2sTb2(TSI1>sTe1sTb1TST)=TSI1>sTe1sTb1(TSI2>sTe2sTb2TST)ifsTb1≠sTb2≠sTe1≠sTe2.The proof is given in the Appendix.In this section, we define labeled transition systems for elementary statements.A single atomic statementa;yields a transition system (seeFig. 14(a))TSA=Va,Ia,Oa,{sAi,sAf},sAi,sAf,{a},{(sAi,a,sAf)}withVa,IaandOaare the variables, external inputs, and output actions used in statement a, respectively.Further, we define an empty statement;to obtain a transition system (see Fig. 14(b))TSε=〈∅,∅,∅,{sεi,sεf},sεi,sεf,{ε},{(sεi,ε,sεf)}〉.A WAIT statementWAIT w;with condition w is represented by a transition system (see Fig. 14(c))11We will write predicatesp∈P(V∪I∪F)which occur in labels in brackets, i.e.,[p], in the following.TSW=〈VW,IW,∅,{sWi,sWw,sWf},sWi,sWf,{ε,[w]},{(sWi,ε,sWw),(sWw,[w],sWf)}〉withVWandIWare the variables and external inputs used in condition w, respectively.Fig. 15 illustrates how sequential composition of these elementary statements works. Note how atomic statements are combined and initial and final states disappear. The resulting system always has just one initial and one final state.Equipped with the inline operator, we can define the transition system for an IF statement as follows: Letbe an IF statement with condition c, THEN branch T, and ELSE branch E, and letTSTbe the transition system for the THEN branch andTSEthe transition system for the ELSE branch. First we define a transition systemTSCfor representing the conditional branch only asTSC=〈VC,IC,∅,SC,sCi,sCf,LC,TC〉withVCandICare the variables and external inputs used in condition c, respectively.SC={sCi,sCbt,sCet,sCbe,sCee,sCf},LC={[c],[¬c],ε}, andTC={(sCi,[c],sCbt),(sCi,[¬c],sCbe),(sCet,ε,sCf),(sCee,ε,sCf)}.The transition systemTSIFdefining the behavior of the IF statement is then defined by inlining the transition system for THEN and ELSE branches at statessCbtandsCetand statessCbeandsCee, respectively,TSIF=TSE>sCeesCbe(TST>sCetsCbtTSC).Fig. 16 illustrates the construction of the transition system for IF statements. Note that the cascaded IF conditions result in multiple atomic transitions with labels containing multiple conditions.We build transition systems for WHILE loopsWHILEcLOOPBEND_LOOPwhich have a body B with a transition systemTSB=〈VB,IB,OB,SB,sBi,sBf,LB,TB〉which has no direct transitions(sBi,l,sBf)∉TBfrom initial to final states as follows: LetTSL=〈VL,IL,∅,SL,sLi,sLf,LL,TL〉be a transition system with (cf.TSLinFig. 17).VLandILare the variables and external inputs used in condition c, respectively,SL={sLi,sLb,sLe,sLf}LL={[c],[¬c]}andTL={(sLi,[c],sLb),(sLi,[¬c],sLf),(sLe,[c],sLb),(sLe,[¬c],sLf)}The transition systemTSWLdefining the behavior of the WHILE statement is then defined by inlining the transition system for the loop body at statessLbandsLeTSWL=TSB>sLesLbTSL.Fig. 17 illustrates the construction of a transition system for WHILE loops.The construction process clearly shows why direct transitions(sBi,l,sBf)from initial to final states are not allowed in the inlined system: no state would exist for the loop, and a direct transition from final statesLfto initial statesLiwould result. This, however, is not allowed for transition systems. Therefore, Monaco provides different looping constructs for atomic statements. Such a loop is treated as an atomic statement and becomes part of a label in a transition system.For an ON statementBEGINBONcHENDwe define a transition systemTSONin the following way: LetTSB=〈VB,IB,OB,SB,sBi,sBf,LB,TB〉be the transition system representing the codeBwith set of statesSB={sBi,sBa,sBb,…,sBf}. LetTSH=〈VH,SH,sHi,sHf,LH,TH〉be the transition system representing the handler codeH. Then we first define a transition systemTSOasTSO=〈VO,IO,OO,SO,sOi,sOf,LO,TO〉withVO,IOandOOare the variables, external inputs, and output actions used in B and c,SO=SB∪{sOb,sOe}sOi=sBisOf=sBfLO=L′B∪{[c]}andTO=T′B∪{(sBx,[c],sOb)|sBx∈SB\{sBi,sBf}}∪{(sOe,ε,sBf)}whereL′B={[¬c]°lB|lB∈LB}andT′B={(sBx,[¬c]°lBxy,sBy)|(sBx,lBxy,sBy)∈TB}i.e., the transition systemTSBis changed so that each transition label is prefixed with[¬c]guaranteeing that the ON condition does not occur. Additionally transitions from all statessBx∈SB(except initial and final states) to the statesObrepresenting the begin of the ON handler with the ON condition[c]as label are added. Moreover, there is a single transition from the statesOe(representing the end of the ON handler) to the final state.Fig. 18(a) shows the transition systems for ON statements.The final transition systemTSONfor the whole BEGIN/END with ON handler statement is obtained by inlining the transition systemTSH(representing the handler code at statessObandsOe)intoTSO:TSON=TSH>sOesObTSO.For an ON statement with a RESUME at the end of the handler codeBEGINBONcHRESUME;ENDthe transition systemTSONis constructed in a similar way, but with transitions back to the previous state instead of to the final state. LetTSB=〈VB,SB,sBi,sBf,LB,TB〉be the transition system representing codeBas previously defined. Then we define the transition systemTSORasTSOR=〈VOR+s,IOR,OOR,SOR,sORi,sORf,LOR,TOR〉.withVOR,IORandOORare the variables, external inputs, and output actions used in B and c andVOR+s=VOR∪{s},SOR=SB∪{sORb,sORe},sORi=sBi,sORf=sBf,LOR=LB'∪{[c]s:sBx|sBx∈SB\{sBi,sBf}},and,TOR=TB'∪{(sBx,[c]s:sBx,sORb)|sBx∈SB\{sBi,sBf}}∪{(sORe,[s=sBx],sBx)|sBx∈SB\{sBi,sBf}},wheres:=sBxis the statement for saving the current statesBxin a local variables,and[s=sBx]is a condition testing if the saved state is equal tosBx.LB'andTB'are defined as above.Fig. 18(b) shows the construction of transition systems for ON statements with RESUME.For a PARALLEL statementPARALLELA||BENDdefining the parallel execution of codeAand codeB,we construct the transition system by a parallel interleaving of states and state transitions ofAandBwhich is defined by a parallel composition operatorTSA||TSB. LetTSA=〈SA,sAi,sAf,LA,TA〉be the transition system for the code blockAwith set of statesSA={sAi,sAa,sAb,…,sAf}andTSB=〈SB,sBi,sBf,LB,TB〉be the transition system for the code blockBwith set of statesSB={sBi,sBc,sBd,…,sBf}. Then we define the transition system for parallel execution ofAandBbyTSA||B=TSA||TSB=〈VA||B,VA||B,VA||B,SA||B,sA||Bi,sA||Bf,LA||B,TA||B〉withVA||B=VA∪VB,IA||B=IA∪IB,OA||B=OA∪OB,SA||B=(SA\{sAi})×(SB\{sBi})∪{(sAi,sBi)},sA||Bi=(sAi,sBi),sA||Bf=(sAf,sBf)TA||B={((sAi,sBi),lAix°lBiu,(sAx,sBu))|(sAi,lAix,sAx)∈TA,(sBi,lBiu,sBu)∈TB}∪{((sAx,sBu),lAxy,(sAy,sBu))|(sAx,lAxy,sAy)∈TA,sAx≠sAi,sBu∈SBâ§¹{sBi}}∪{((sAx,sBu),(°(sAx,lAxy,sAy)∈TAnotlAxy)°lBuv,(sAx,sBv))|(sBu,lBuv,sBv)∈TB,sBu≠sBi,sAx∈SAâ§¹{sAi}},andLA||B={l|(sAx,sBu),l,(sAy,sBv)∈TA||B}.Note the three lines in the definition of the transitions relation. The first line handles the transitions from the initial state of both componentsTSAandTSBwhich are immediately executed. The second line handles the transitions stemming fromTSA. The third line handles the transtions fromTSBand contain the conditionnotlAxyfor all possible transitions(sAx,lAxy,sAy)∈TAfromTSAwhich guarantees that none of them can be executed. That means that transitions ofTSAalways have priority.Fig. 19 illustrates parallel composition of transition systems.Again we want the ability to apply parallel composition in arbitrary order and thus require the parallel composition operator to be associative.LemmaThe parallel composition operator is associative, i.e.,(TSA||TSB)||TSC=TSA||(TSB||TSC).Assuming that((sAx,sBu),sCs)=(sAx,(sBu,sCs))=(sAx,sBu,sCs), proof follows directly from the construction process.□Note that, due to the priority scheme that enforces thatTSAhas priority overTSB, the parallel composition operation is not commutative.Finally, we define the transition systems for routine implementations and routine calls. The transition systems use a queueqof calls to allow multiple calls, and a variablecurrto represent the current call. These variables are used to synchronize the call with the execution of the routine. Note that, although the call semantics allows for multiple calls to be initiated, a call must wait until the previous call has finished. Thus, routines are not reentrant.LetROUTINErout() BEGINBENDroutbe a routine implementation in a component with a bodyBwithTSB=〈VB,SB,sBi,sBf,LB,TB〉being the transition system forB. The transition system for the routine is defined by inliningTSBinto the transition systemTSR.TSB>SReSRbTSR,whereTSRencodes the entry and return as follows (seeFig. 20(a)):TSR=<VR,∅,∅,SR,sRi,sRf,LR,TR>withVR={q,curr},SR={sRi,sRf,sRw,sRb,sRe},LR={[¬q.empty]°curr:q.first°q:=q.deque,curr:=NULL},andTR={(sRi,ε,sRw),(sRw,[¬q.empty]°curr:q.first°q:=q.deque,sRb),(sRe,curr:=NULL,sRw)}.This means that the transition system waits until the queue is not empty (i.e., a call has arrived). It stores the next call as its current callcurr. At this point, the inlined transition systemsTSBis executed, and after finishing, the current callcurris reset to NULL, and the process is repeated.A transition system is created for every instance of the component. We denote the transition system for routineroutin component instancecompascomp.rout.A routine callcomp.rout();of a routineroutin subcomponent instancecompdefines a transition system (see Fig. 20(b))TSC=〈VR,∅,∅,SC,sCi,sCf,LC,TC〉withVR={comp.rout.q,comp.rout.curr},SC={sCi,sCc,sCr,sCf},LC={comp.rout.q:=comp.rout.q.enque(this),[comp.rout.curr=this],[comp.rout.curr≠this]},TC={(sCi,comp.rout.q.enque(this),sCc),(sCc,[comp.rout.curr=this],sCr),(sCr,[comp.rout.curr≠this],sCf)},wherecomp.routrepresents the transition function of subcomponentcomp,andthisuniquely represents this call. Note that the first transition enqueuesthisin the queuecomp.rout.qof the routine, the second transition waits until the routine accepts the call and setsthisas the running callcomp.rout.curr, and the third transition waits for the running call to be reset, which signifies the return of the call.We implemented a compiler which reads a fully configured Monaco program – that is, a program with all components instantiated, their parameters set, and the subcomponent tree configured – from which it creates a C++ program which can then be executed by a run-time system. The Monaco compiler resembles the construction process for transition system as presented above. In particular, it creates objects representing the transition systems for each routine and each individual component instance which then contain state objects for the states of the transition system. The state object contains a pointer to a compiled C++ function which encodes all transitions originating from that state. The C++ function returns the next state object or null if no transition can trigger. Note, that the C++ function implements thesat,execandoutputoperations of the labels of all transitions originating from a state.Fig. 21 illustrates the approach schematically for transitions from a stateswcorresponding to a statement WAIT w;. The block of this statement is guarded by a ON condition. Therefore there is a transition fromswtosxwith label[c]g;. Then there are two transitions with [w] being the triggering condition. Additionally the labels are prefixed with condition[¬c]guaranteeing that the ON condition is not satisfied. The IF statement testing conditiondresults in two transitions, one with condition [d] and the other with[¬d]with two different labels and follow up states. The C++ function for this code is shown in Fig. 21(c). Note that the ON conditioncis tested first and only if this is not satisfied (i.e., condition[¬c]holds) conditionwis tested. When conditionwis satisfied, it returns either statesvorsuand executesa;e;ora;f;, depending on conditiond. If neithercnorware satisfied, the function returnsnull, indicating that no transition is possible.Note that, if the first triggering condition is satisfied, it is guaranteed that one of the transitions can be executed. The reason is that conditions which occur after imperative code in labels always come from conditional branches and not from blocking statements. So, if there is a transition with label with a condition after some imperative code, like the condition[d]in the example, there will be an equivalent transition with same beginning and with the negation of the condition, e.g.,[¬d]. So both transitions can be encoded in a C++ function with equal beginning and then a branch on that condition.The run-time system uses a current state list and current time variabletiand starts with an initial value assignment for internal variables. The current state list contains all currently active states. It starts by putting the initial states of the transition systems of routines into the current state list. Then the run-time system works in a cyclic mode with a fixed cycle period (1ms by default). First, it will receive new input values from the hardware interface or lower-level control layer and provides those as input value assignmentsαI(ti)to the Monaco program. Note that those values get frozen for the execution cycle. Then it iterates through the current state list and executes the transition functions of the states. When the transition function returns a non-null next state, the current state is removed from the state list and replaced with the next. Scanning of the current state list restarts from the beginning until no transition returns a non-null next state. This is the point to advance the time and repeat.ti:=0initialize variables valuesαV(ti)current_states +=initial states of transitions systems of routinesloopαI(ti)=take over variable values from lower control layerdonext:=nullfor state in current_states while next =nullnext:=state.transition()if (next!=null)current_states −=statecurrent_states +=nextuntil (next =null)ti:=ti+ cycle_periodend_loopThe PARALLEL statements are treated slightly differently by the compiler and run-time system than defined in the formal definition. Actually the interleaving of states of parallel code blocks is not performed explicitly but generated by executing the code blocks in parallel threads.Fig. 22 illustrates the approach: (1) the threads start immediately executing codelAixandlBiu(in that order) and run to the first blocking statessAxandsBu; this corresponds to transition from((sAi,sBi),lAix°lBiu,(sAx,sBu))in the parallel interleaving. (2) Let us assume then thatlAxyis not statisfied butlBuvis. SoTSBtransits tosBvexecutinglBuvwhich corresponds to state transition to(sAx,sBv). Note, that transitions in the two parallel threads are tested and executed in the orderTSAbeforeTSB. This guarantees that, when transitionlBuvinTSBis tested, transitionlAxyis not satisfied and hence¬(satlAxy)already holds, which exactly corresponds to the labelnotlAxy°lBuvin the parallel interleaving.We developed and tested the language on the basis of a set of typical examples, ranging from simple machines to small manufacturing cells. In particular, we re-implemented two existing automation solutions from our industrial partner which are both currently implemented in the IEC 61131-3 [19] languages Structured Text and Sequential Function Chart as SoftPLC applications running on industrial PCs with a real-time operating system extension. The first is an automation solution for an injection molding machine. The example in Section 3 was taken from this system. The other is an existing solution for the paint supply system of a painting robot used in the automotive industry. Both are typical SoftPLC solutions from the domain of our industrial partner. In both programs, we covered the event-based reactive part of the systems, connected the applications to a lower-level control system written in IEC 61131-3, and tested the applications with systems simulating the machine to be controlled.The results of these two case studies were very encouraging. Our code was a fraction of the length of the original. The original injection molding solution has in total more than 30,000 lines of code (Structured Text), of which about a quarter (conservative estimate) is for the purely reactive control part. Our solution has exactly 942 lines of code. The abstract control part for the paint supply system typically consists of over 20 medium-sized Sequential Function Charts plus several time-based programs (a proprietary programming model is used in this type of solution). Our Monaco program has 1403 lines of code.These two case studies showed that two features of the Monaco language are particularly helpful: the hierarchical component approach and the exception handling approach with ON handlers. Unsurprisingly, hierarchical component structuring is more appropriate when the machine has a clear hierarchical structure. Although the hierarchical structure was clearer in the injection molding application, the paint supply system also had a clear hierarchical structure, but with stronger coupling between sibling components. We have found exception handling to be critical and difficult to express. In the original applications, the greater part of the code checked for and reacted to exceptional situations and was extremely difficult to understand. This was considerably simpler with ON statements in Monaco. Moreover, Monaco allows all conceivable exceptions to be expressed concisely, which was not possible, for example, using the Sequential Function Chart language of the IEC 61131-3.The Monaco applications are intended to run in a real-time setting as part of a hard real-time process controller solution. We therefore tested the performance of the run-time system.Fig. 23 shows the results from run-time measurements conducted for the paint supply application. The cycle time is about 5–25μs (the current application runs with a cycle period of 4ms) and very stable. Note the two peaks in the measurements: The first peak, with a median value of 10μs, represents cycles in which no transition occurs, while the second peak, with a cycle time of about 20μs, represents cycles with a transition.

@&#CONCLUSIONS@&#
