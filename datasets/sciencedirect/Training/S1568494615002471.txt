@&#MAIN-TITLE@&#
Modified cuckoo optimization algorithm (MCOA) to solve graph coloring problem

@&#HIGHLIGHTS@&#
Novel discrete approach for combinational optimization based on cuckoo optimization algorithm (COA).Redefining the difference concept between two habitats as a differential list of movements.Proposed method enable to solve non-permutation problems.Modifying egg laying and immigration phase of COA in the proposed discrete cuckoo optimization algorithm (DCOA).High quality results obtained for graph coloring problems.

@&#KEYPHRASES@&#
Modified cuckoo optimization algorithm (MCOA),Optimization,Graph coloring problem,Non-linear optimization,

@&#ABSTRACT@&#
In recent years, various heuristic optimization methods have been developed. Many of these methods are inspired by swarm behaviors in nature, such as particle swarm optimization (PSO), firefly algorithm (FA) and cuckoo optimization algorithm (COA). Recently introduced COA, has proven its excellent capabilities, such as faster convergence and better global minimum achievement. In this paper a new approach for solving graph coloring problem based on COA was presented. Since COA at first was presented for solving continuous optimization problems, in this paper we use the COA for the graph coloring problem, we need a discrete COA. Hence, to apply COA to discrete search space, the standard arithmetic operators such as addition, subtraction and multiplication existent in COA migration operator based on the distance's theory needs to be redefined in the discrete space. Redefinition of the concept of the difference between the two habitats as the list of differential movements, COA is equipped with a means of solving the discrete nature of the non-permutation. A set of graph coloring benchmark problems are solved and its performance is compared with some well-known heuristic search methods. The obtained results confirm the high performance of the proposed method.

@&#INTRODUCTION@&#
Optimization problems are very important in many branches of sciences and their objectives are to find the best possible answer for a specific problem. Thus the need to search in solving optimization problems, has led to the emergence of different search algorithms. Evolutionary algorithms are a category of algorithms that has made remarkable progress in solving optimization problems. Genetic algorithms [1], particle swarm optimization [2], differential evolution [3], imperialist competitive algorithm [4], gravitational search algorithm [5], social-based algorithm [6], are most popular evolutionary optimization algorithms.Most of evolutionary algorithms are considered to be continuous from the very early emergence; however, there are many issues with a discrete nature, such as scheduling applications, minimum distance in routing applications, graph partitioning and graph coloring problem. Solving such problems requires a series of changes on continuous algorithms to make them suitable for discrete problems.The graph coloring problem (GCP) is one of the well-studied NP-hard problems in graph's theory [7]. The reasons why the graph coloring problem is important are divided into two parts. First, in terms of its application, samples of applications include timetabling and scheduling [8,9], radio frequency assignment [10], computer register allocation [11,12], printed circuit board testing [13], channel routing [14], and etc. Another reason is that the graph coloring problems in hard calculations at different levels are shown. Not only does this kind of stuff is making NP-Complete, but rather as an approximate version of the proposed NP-hard.These two reasons to justify efforts to provide different ways of solving graph coloring problem are important enough and quickly new Meta heuristic methods for these problems have been provided and experimented. On the other hand, the graph coloring problem is a discrete problem and because of its use as outlined above, even the Meta heuristic methods in order to solve this problem continue to provide discrete version. So algorithm discretization is important. Also, most of approaches available to solve graph coloring problems are usually in two classes: (1) exact algorithms and (2) approximate algorithms. Due to the fact that exact algorithms can solve instances with up to 100 vertices; so for larger instances we need heuristic methods.In this paper, we modify the most recent evolutionary algorithm called cuckoo optimization algorithm to make it able to solve graph coloring problem. Inspired by the lifestyle of a bird which is called cuckoo, cuckoo optimization algorithm (COA) was developed by Rajabioun in 2011 [15]. Specific egg laying and breeding of cuckoos is the basis of this novel optimization algorithm. Cuckoos used in this modeling exist in two forms: mature cuckoos and eggs. Mature cuckoos lay eggs in some other birds’ nest and if these eggs are not recognized and not killed by host birds, they grow and become a mature cuckoo. Environmental features and the migration of societies (groups) of cuckoos hopefully lead them to converge and find the best environment for breeding and reproduction. This best environment is the global objective function. The main cuckoo optimization algorithm (COA) is introduced basically for continuous problems. Based on the performance of the COA algorithm in optimizing continues problems, it is predictable that this algorithm would be impressive in discrete optimization problems. The idea is that in order to solve graph coloring problem by COA, the standard arithmetic operators such as addition, subtraction and multiplication of COA migration operator, need to be redefined on discrete space.Rest of the paper is organized as follows: In Section 2, a review of related works is presented. In Section 3, original cuckoo optimization algorithm (COA) is reviewed and it's different parts are studied in glance. The idea to modify basic COA and solving graph coloring problem is described in Section 4. The proposed algorithm is tested with some DIMACS CHALLENGE benchmarks in Section 5. Finally the conclusions and future work are presented in Section 6.There are many several approaches for approximate algorithms, such as Greedy constructive, Local Search heuristics and Meta heuristics. The most of Greedy constructive methods are Dsature [16] and RLF [17], which are recently used to generate initial solutions to advanced Meta heuristic algorithms. Local Search method such as TS which is generally used in hybrid approach. Dorne and Hao [18] and Hertz and Werra [19] suggested Two Tabu Search algorithms. The most common approach for approximate algorithms are Meta heuristics or same evolutionary method. Costa and Hertz [20] present Ant Colony Optimization for graph coloring problem which embedded two constructive heuristics RLF and DSATUR.Blöchliger and Zufferey [21] proposed an approach called FOOPARTIALCOL, which is based on Tabu Search. The method considers feasible, but partial solutions and tries to increase the size of the current partial solution. Ray et al. [22] proposed an evolutionary algorithm (GA) with double point Guided Mutation for the Graph Coloring problem, which could advance the performance level of simple GA dramatically. Lu and Hao [23] present a memetic algorithm (MACOL) to solve the graph coloring problem. The proposed MACOL algorithm integrates several distinguished features such as adaptive multi-parent crossover (AMPaX) operator and a distance-and-quality based replacement criterion for pool updating. Ge et al. [24] proposed a hybrid chaotic ant swarm approach for the graph coloring problem (CASCOL). This approach was based on a novel swarm intelligence technique called chaotic ant swarm (CAS) and a simple greedy sequential coloring, First-Fit algorithm.Bessedik et al. [25] presented a marriage in honey bees optimization (MBO) approach to graph coloring problem (GCP). They proposed, a worker, in Bees colony of the following methods: local search, tabu search or a proposed-based ant colony system algorithm (IACSCol). The worker intervened at two levels; it improved initial and crossed solutions.Qin et al. [26] introduced a Hybrid Discrete Particle Swarm Algorithm for Graph Coloring problem. To apply PSO to discrete problems, the standard arithmetic operators of PSO were required to be redefined over discrete space. A conception of distance over discrete solution space was introduced. Under this notion of distance, the PSO operators were redefined. After reinterpreting the composition of velocity of a particle, a general discrete PSO algorithm was proposed. In order to solve graph coloring problem with the discrete PSO algorithm, an algorithm to implement the crucial PSO operator difference of two positions (solutions) was designed. Then, a hybrid discrete PSO algorithm for graph coloring problem was proposed by combining a local search. The local search is Tabucol.Fister and Brest [27] used a hybrid self-adaptive differential evolution algorithm for graph coloring that is comparable with the best heuristics for graph coloring. Abbasian et al. [28] presented an algorithm which combined a novel Sequential Graph Coloring Heuristic Algorithm (SGCHA) with a non-systematic method based on a cultural algorithm to solve the graph coloring problem. In this approach, they first use an estimator which is implemented with SGCHA to predict the minimum colors. Then, in the non-systematic part which has been designed using cultural algorithms, they improved the prediction. Various components of the cultural algorithm have been implemented to solve the GCP with a self-adaptive behavior in an efficient manner. Faraji [29] proposed a new algorithm for graph coloring based on Bees behavior in nature (BEECOL).Hsu et al. [30] proposed a modified turbulent particle swarm optimization (named MTPSO) model for solving planar graph coloring problem based on particle swarm optimization. The proposed model is composed of the walking one strategy, assessment strategy, and turbulent strategy for improving the discrete PSO in the planar graph coloring. It was found that the walking one strategy and assessment strategy can improve the performance of MTPSO algorithm. The turbulent strategy also can be helpful to drive those lazy particles (i.e., those velocities of the particles smaller than threshold), and hence they can find a better solution. In addition, the experimental results indicated that the MTPSO model is more efficient and accurate than the modified PSO algorithm proposed by Cui et al.Xiong, Bao, and Hu [31] evaluated the performances of multi-step-ahead forecasting of crude oil prices that were generated using the revised EMD-based feed-forward neural network (FNN) modeling framework. In addition, the three leading multi-step-ahead prediction strategies proposed in the literature were reviewed, and their performances in generating high-quality multi-step-ahead forecasting in the context of the crude oil market were compared. The quantitative and comprehensive assessments were performed on the basis of prediction accuracy and computational cost. The procured results demonstrated that the proposed EMD–SB M–FNN model using the MIMO strategy was a very promising prediction technique with high-quality forecasts and accredited computational loads.Bao, Hu, and Xiong [32] proposed a particle swarm optimization algorithm (PSO) and pattern search (PS) based on memetic algorithm. In the proposed memetic algorithm, PSO was used to explore of the search space and detect the potential regions by PSO. To balance the exploration of PSO and exploitation of PS, a probabilistic selection strategy was also introduced to select the appropriate individuals among the current population to undergo local refinement. Experimental results supported that the local refinement with PS and the proposed selection strategy were effective, and finally indicated that the proposed PSO-PS based MA could be a promising alternative for SVMs parameters optimization.Using multi-output support vector regression (MSVR), Xiong, Bao, and Hu [33] examined the possibility of forecasting an interval-valued stock price index series over short and long horizons. Furthermore, a firefly algorithm (FA)-based approach, built on the established MSVR, was proposed to determine the parameters of MSVR (abbreviated as FA-MSVR). Three globally traded broad market indices were used to compare the performance of the proposed FA-MSVR method with selected counterparts. The results obtained in this study indicated the effectiveness of the proposed FA-MSVR method for forecasting interval-valued financial time series.In another study, Xiong, Bao, and Hu [34] proposed the incorporation of end condition methods for time series prediction and provided large scale experimental evidences for the purpose of justification. Four well-established end condition methods including Mirror method, Coughlin's method, Slope-based method, and Rato's method were chosen, and support vector regression (SVR) was employed as the modeling technique. The obtained experimental results revealed a significant improvement by the proposed EMD-based SVR models with end condition methods. The EMD–SBM–SVR model and EMD–Rato–SVR model, in particular, achieved the most stable prediction performances regarding rank-based measure, indicating the superiority of slope-based method and Rato's method as end condition methods.Using a hybrid Ant Colony Optimization (ACO)/particle swarm optimization (PSO) technique, Patel, Kabat, and Tripathy [35] presented a swarming agent based intelligent hybrid algorithm to optimize the multicast tree. The performance of the proposed algorithm was evaluated through extensive simulation. The proposed algorithm used the collective and coordination process for the mobile agents attached to each pattern. The simulation results were compared with two existing algorithms PSO-TREE and TGBACA and indicated that the proposed algorithm functioned better than the existing algorithms. It was also found that the proposed algorithm constructed the multicast tree patterns more sensibly such that the tree patterns not only satisfy the QoS constraints, but also tries to minimize the tree cost.Considering that the re-entrant permutation flowshop scheduling problem minimizes the makespan, more recently, Xu et al. [36] adopted the CPLEX solver and developed a memetic algorithm (MA) to cope with the problem. Because it requires a large amount of computer memory to use CPLEX to solve the corresponding MIP model. They conducted computational experiments to test the effectiveness of the proposed algorithm and compared it with two existing heuristics. It was found that CPLEX could solve mid-size problem instances in a reasonable computing time, and the proposed MA performed better than CPLEX in terms of solution quality and solution time. In addition, the proposed solution provided an approach to handle the considered re-entrant flowshop problem, which is relevant to manufacturing and assembly processes.In the same vein, Zhou et al. [37] proposed a new exact algorithm with clause learning for the graph coloring problem. The proposed algorithm cdclGCP extends a backtracking algorithm backGCP by applying the CDCL technology to discover the implicit constraints among vertices. The implicit constraints are utilized to prune the search space. The experimental results revealed that this algorithm outperformed other algorithms on many instances. More specifically, this algorithm allowed to close the open DIMACS instance 4-Fulli ns _5. The results also showed that the search tree size was significantly reduced.In their study, Rahmani and Mir Hassani [38] proposed a discrete firefly algorithm to solve the capacitated facility location problem. Moreover, they employed an improvement method based on GA for transforming a trial solution into a better one; in fact, the method combines the discrete firefly algorithm with the standard (GA). The results of implementation have been compared with the well-known software, CPLEX (for small and medium scale test problems) and PSO algorithm (for large scale test problems). The preliminary results suggested that the proposed method performed the same as CPLEX for small size problems (because of negligible gap), and was also applicable for large scale problems.This algorithm is one of the newest and most powerful evolutionary optimization techniques that have already been introduced. Cuckoo algorithm, inspired by the life of a bird named cuckoo which in 2009 by Yang and Deb has been developed [39]. This algorithm is based on the life of a cuckoo. This algorithm has been developed by flaying levy instead of isotropic random walk. Cuckoo algorithm later in 2011 by Rajabioun fully examined in more detail [15]. In this paper COA algorithm will be studied and before COA details study, discuss why choosing this method.Argue that an optimization algorithm for solving optimization problems is the best method is not correct. Because every year new algorithms to cover the weaknesses of previous approaches have been emerged. Maybe later when GA and PSO optimization algorithm were considered the best of its kind. However, one can still see it in many of his articles. These methods are also sometimes referred to as the criteria used to compare the performance of the new method.Some researchers believe that there is no reason that an evolutionary optimization method is better than another because each method because of evolution should be able to find the right answer. The point is that there are some methods like their real models, slow to evolve in nature. For example, in genetic evolution which is inspired by the true gene, the evolution occurs slowly, over many years. Perhaps this is why the GA requires a more iterations to find a suitable answer. In contrast, there is PSO algorithm, because of the inspiration of birds to act quickly to feed and act faster than GA in solving problems and this makes users more willing to use faster and more accurate evolutionary optimization algorithm. This is true of the cuckoo optimization algorithm and in applications that have been tested so far [40–46] this algorithm has been much better than the rest and show its efficiency. This can be a good motivation for the use of COA in solving many problems with high dimensions and very complex.Fig. 1shows the flowchart of cuckoo optimization algorithm introduced in [15]. COA is a global continues search method which inspired from a bird called cuckoo. Like other evolutionary algorithms, COA starts with an initial population, which is composed of a cuckoos.This population of the cuckoos have eggs that lay them in host bird nest. Some of these eggs that are more similar to the host bird's eggs, have better chance to grow and become an adult cuckoo. Other eggs were identified and destroyed by the host bird. The grown eggs, show nests suitability of the area. The more eggs in the environment and are able to be saved, equally more profit (desire) is assigned to that area. The situation in which the maximum number of eggs to be saved, will be a parameter that COA wants to optimize it.To maximize their eggs saving more, cuckoos looks for the best area. After the chicks were hatched and became mature, make some groups. Each group has its specific habitat. The best habitat is the next destination of cuckoos in other groups. All groups move to the best existent habitat. Each group resides in the area near the current location. Given the number an eggs a cuckoo will lay and cuckoos distant from current optimized habitat, a number of spawning radius calculated. Then cuckoos begin to lay egg in some nests within spawning radius. This process continues to reach the best hatchery. This optimized place is where that more cuckoos come together.In order to solve an optimization problem, it's necessary that the values of problem variables be formed as an array. In GA and PSO, this array specifies with Chromosome and the particle situation but in cuckoo optimization algorithm is called habitat or location. In an Nvar dimensional optimization problem, a habitat will be a 1×Nvar that shows the current location of cuckoos. A sample array is defined as the following equation:(1)habitat=x1,x2,…,xNvarThe suitability of current habitat achieves by (fp) benefit function in habitat. According to the following equation:(2)Profit=fp(habitat)=fpx1,x2,…,xNvarAs it can be seen, COA is an algorithm that maximizes the benefit function. To use COA for Minimization problem solving, it is sufficient to multiply a negative mark in cost function, according to the following equation:(3)Profit=−Cost(habitat)=−fcx1,x2,…,xNvarTo start optimization algorithm, a matrix with Npop×Nvar is created and then for each habitat, randomly egg assigns. In nature, each cuckoo lays from 5 to 20 eggs. So each cuckoo has an upper and a lower limit for egg laying at different iterations. Another habitat of real cuckoos is that they lay eggs within a maximum distance from their habitat. This maximum range is be called “Egg Laying Radius (ELR)”. In an optimization problem with upper limit of varhi and lower limit of varlow for variables, each cuckoo has an ELR which is proportional to the total number of eggs; number of current cuckoo's eggs and also variable limits of varhi and varlow. The ELR is defined as in the following equation:(4)ELR=α×Numberofcurrentcuckoo'seggsTotalnumberofeggs×(varhi−varlow)where α is an integer, supposed to handle the maximum value of ELR.Each cuckoo starts laying eggs randomly in some other host birds’ nests within her ELR.Fig. 2gives a clear view of this concept.After all cuckoos’ eggs are laid in host birds’ nests, some of them, less similar to host birds’ own eggs are detected and thrown out of the nest. So after egg laying process, p%of all eggs (usually 10%), which their utility function is lower are destroyed. These eggs have no chance to grow. Rest of the eggs are fed and grow in the host's nest.Another interesting thing about the cuckoo chick is that only one egg per nest is allowed to grow because when the cuckoo chick hatch from the egg, throw out host bird eggs and if host bird chicks are hatched sooner, cuckoo chick eat the most food host bird brings and after some days, host bird chicks eat die from hungry and just cuckoo chick survive.After the young cuckoos grow and become mature, they live in their own area and society for some time. At the time of spawning, they migrate to new and better habitats that there is more chance of eggs surviving. After the formation of cuckoo groups in different areas of environmental (the search space of the problem), the group holds a position as a target for other cuckoo to migrate is selected.When the mature cuckoos live in different areas of environment, determining that a cuckoo belongs to any group is a tough work to solve this problem, cuckoo grouping id done by k-means (a k between 3 and 5 is sufficient). Now that the cuckoo groups were formed, the average income is calculated to achieve the relative optimality of that group habitats. Then group with the highest amount of profit (optimality) is selected as a target group and other groups migrate toward it.When moving toward goal point, the cuckoos don’t fly all the way to the destination habitat. They only fly a part of the way and also have a deviation. This movement is clearly shown in Fig. 3.As is evident from Fig. 3, each cuckoo travels only λ% of the total direction toward the ideal target and also has a deviation φ radians. These two parameters help cuckoo to search the environment more λ is a random number between 0 and 1, and φ is a number between π/6 and −π/6.When all cuckoos migrate to target location and also new locations are specified, each cuckoo is an owner of some eggs. Given the number of eggs for each cuckoo, an ELR is specified for it and then pawning starts.The Formula for migration operator in cuckoo optimization algorithm is as follow in the following equation:(5)XNextHabitat=XCurrentHabitat+F×XGoalPoint−XCurrentHabitatF is a parameter that causes deviation.Given that there is always equilibrium in birds’ population, a number like Nmax, limits the maximum number of cuckoos that can live in the environment. This balance exists because of food limitations, being killed by predators and also inability to find proper nest for eggs.The main steps of COA are presented in Fig. 4as a pseudo-code. In the next section, COA is modified in a way suits for discrete optimization applications.Before examining how to discrete COA for graph coloring problem, first we discuss why choosing discrete method. Since solvable problems in discrete space divide in various groups, that among these are Permutation and non-Permutation problems.In permutation problems, each solution in search space corresponds to π:{1…n}→{1…n}. In this case, numbers are assigned to problems answer that are just a code for their identification. Then an array of these codes constitute problem answer. Permutation view has many applications in discrete optimization. Traveling salesman problem and the scheduling problem are clear examples. Besides permutation problems, there are problems that are non-permutation. Here, each solution in search space corresponds to integral vector that gets discrete amount and maybe redundant numbers are exist in these vectors. Clear example is graph coloring problem.Now, due to graph application mentioned in introduction, the main motivation to write this paper was to solve graph coloring problem by COA. Since COA is continues in nature, we changed it test the graph by that and because suggested algorithm doesn’t have generality for all discrete problems, we named it the discrete algorithm. This suggested algorithm, is for non-permutation problems.COA is essentially an algorithm which is presented to search continuous space and combinational optimization problems that can be solved in a discrete space. To apply COA on a discrete space, standard arithmetic operators of COA need to be redefined on discrete space which so that concept of space and geometric laws for solutions of discrete spaces is introduced and based on the theory of distance, operators of COA are redefined. Generally, in this section, necessary change in the basic algorithm COA to optimize the discrete problems is the relationship of migration.Before performing discretization on migration operator, we must redefine some concepts in combinational optimization problems involving permutation of integer vectors, direct use of arithmetic operations is invalid because mathematic operations on symbols don’t produce a meaningful direction. In addition, usually invalid responses are obtained. Distance is a good criterion for difference statement between two points in search space. Based on article [26,47].We introduce a distance concept that is appropriate for COA.Search space: (S, O) is a discrete search space which S is a set of solutions and O is the operations that apply to S members enroll others.Metric space: A metric space is a pair (M, d), where M is a set and d is the distance in M, means that: d:M×M→RDistance: given search space (S, O), distance between two solutions si∈S and sj∈S is equal to the minimum number of sequence of actions of operator required for converting sitosj. This definition refers to an interval available to the operator, which is shown in the following equation:(6)Osi=sk,Osk=st,…,Osl=sjAccording to this definition, a discrete search space (S, O) can be given as the corresponding metric space where M=S, and the distance between the solution si∈S and sj∈S means; d=(si, sj) equals to Distance Definition. In other words, in metric space (M, d) introduced by the search space (S, O), geometric concept for d=(si, sj) distance is the shortest length of route between two nodes; respectively that siand sjare displayed.Now, in order to generalize COA to discrete search space, we need to redefine all arithmetic operators in the migration operator that the major is the difference between two habitats. The basic concept of migration in the COA is that each cuckoo tries to migrate into their best bio-region (target point) and reduce the gap with the best position in the space.According to the definition of distance on discrete search space, for each position siand sj, sican be turn to sjthrough operator which is the shortest path between them. Each operator action reduces the distance between siand sja single unit. So, distance between two positions (candidate solutions) from the cuckoos is defined as the sequence of operator actions converting a position to the other.In migration phase of the COA, objective is cuckoo motion toward best population. First, we will change the migration equation in COA continuous that is shown in Eq. (5).F is a random number determines the pace of movement toward the target point. Thus, in the discrete COA, a method is required to model momentum and achieve to the target at each repeat. Then, concepts of subtraction; multiplication and additions in Eq. (5) for discrete space are redefined:The difference between the two situations: for each position siand sj, their difference (si−sj) equals to the sequence of the minimum number of times to apply the operator.(7)si−sj=M=Osi,Osk,…,Osl=sjSo(8)Osi=sk,Osk=st,…,Osl=sjEq. (8) means that difference operator in the cuckoo algorithm for non-permutation problems is equal to the sequence number of times applies to change operator of elements. In other words, to obtain the difference between two vectors in a discrete space, list of necessary motions to change from sjto si, entitled Mj→ithat obtains through element changes is defined. The difference between the two solutions is shown in the following equation:(9)Mj→i=Si⊖SjEq. (9) means that if the motion in the list Mj→ion the solution Sjis imposed, the solution Siwill be obtained. List Mj→imodels the difference between the target point and the current position of the cuckoo. So, the difference between two points equals to the movement list that by triple component term (a, b, c) is displayed; means that in the indices a vector, changes b number into c.Multiplication: Considering F∈[0, 1] that is a decimal number andM′=F×M. Here, multiplication operator means that the number of movements M is selected in the list. So to complete the operation, parameter F, as a random step toward the target point is defined and used. This idea just imposes a random numbers of movements within the list of Mj→ithat is effective.Summation: if sibe position and M′ be the list of movements, si+M′ means M′ movement list imposes on vector sithat creates a new position in the space.So the migration operator is transformed into the following equation:(10)Mj→i=XGoalPoint⊖XCurrentHabitatXNextHabitat=XCurrentHabitat⊕F⊗Mj→iTo explain the idea, we consider the following example; having two following situations in Fig. 5:Clearly, highlighted bits between the current position of mother cuckoo and the target point is different. XGoalPoint−XCurrentHabitat must be defined as the list of motion that when imposes on XCurrentHabitat, XGoalPoint will be generated. But on the other hand, according to the theory of cuckoo migration, as we know that only a percentage of migration distance from the current point to the target is traveled and there is a detour on the route. So, only a part of M on the XCurrentHabitat is applied. List of motions for this example is as follows in the following equation:(11)M=XGoalPoint−XCurrentHabitat=2,3,4;3,2,3;6,4,3Imposing these movements on XCurrentHabitat, in effect produce XGoalPoint. But, in the cuckoo migration in the COA, only a percentage of the movements to XCurrentHabitat should be applied.For this purpose, according to that F∈[0, 1], though F=0.7,M′=F×|M|equals to the first two moves of list M to the form of the following equation:(12)M′=2,3,4;3,2,3By applying the XNextHabitat=XCurrentHabitat⊕M′, new position is obtained as follows in Fig. 6:Pseudo-code of this model of discretization for other non-permutation problems, called MCOA is shown in the following algorithm:Algorithm 1: modified cuckoo optimization algorithm (MCOA)Input: Non-permutation problems with discrete natureOutput: A best solution1. Initialize cuckoo habitats with some random points on the profit function in range2. Dedicate some eggs to each cuckoo3. Define ELR for each cuckoo4. Let cuckoos to lay eggs inside their corresponding5. Kill those eggs that are recognized by host birds6. Let eggs hatch and chicks grow7. Evaluate the habitat of each newly grown cuckoo through objective function8. Limit cuckoos’ maximum number in environment and kill those who live in worst habitats9. Cluster cuckoos and find best group and select goal habitat10. Let new cuckoo population immigrate toward goal habitat by Eq. (10)11. If stop condition is satisfied stop, if not go to 2The graph coloring problem can be defined as follows: Given a graph G=(V, E) with vertex set V and edge set E and given an integer k, a k-coloring of G is a function of C: V→{1…k}. The value C(x) of vertex x is called the color of x. The vertices with color i (1≤i≤k), define a color class denoted as Vi. If two adjacent vertices x and y have the same color i, vertices x and y, the edge [x, y] and color i are said to be conflicting. So the k-coloring without conflicting edges is said legal. A stable set is a subset of vertices that none of these are adjacent. Hence, a k-coloring is legal, if and only if its color classes are stable sets. Now in graph coloring problem, we want to color all nodes in a way that no two adjacent nodes have the same color and use the least amount of color. The least possible color number as a good coloring from graph G achieves is called chromatic number and denoted by χ (G). Reference [48] identifies four different strategies for defining the search space which includes: legal strategy, penalty strategy, k-fixed partial legal strategy and k-fixed penalty strategy. The legal strategy and k-fixed partial legal strategy involves choosing the first k-coloring and then tries to minimize the number of conflicts for candidate k[28]. In this paper we used of k-fixed strategy mode.This section describes how to solve the problem of graph coloring by algorithm MCOA we take the idea of paper [29,49]. Graph with a fixed number K as input entered into algorithm and output of the problem is finding the right coloring k. Initially K=|V| is valued. Solution using the function is colored initiatively then neighborhood search in the section of egg laying algorithm to minimize the number of colors that avoid the collision is applied. Work is described in more detail.COA algorithm contains several sections to produce a cuckoo or same candidate answer to the questioned: production of original responses; production of cuckoo's chicks as a child of cuckoo mother and immigrant to the optimal current location.In the cuckoo algorithm, the initial population is usually generated randomly, but in this part, because of particular condition problem of graph coloring, the initial population is produced by a coloring function called Coloring Vertex in the following algorithm:Algorithm 2: Initialize a solution with coloring_vertexInput: currentColoring and VaOutput: a k-coloring C={V1, V2, …, Vk} of currentColoringCreate adjacentNodesSet (Va);2. Create adjacentNodesColors (adjacentNodesSet);Set N=|V|;4. FOR j=1 to NIF j∉adjacentNodesColorsSet C(Va)=j;ENDIFENDFORFirst, a node is randomly selected and colored by the Coloring Vertex in Algorithm 2. Then, other nodes are sorted based on the degree to have and according to the color of first node, and each node has its own specific color by Coloring Vertex algorithm respectively.In other words, if V is a set of graph nodes and Vaa target node for coloring, in this case, Va∈V and deg(Va), Vanode degree; deg(Va)=m and {V1, V2, …, Vm} equals adjacent nodes to Va; C={c(V1), c(V2), …, c(Vm)} also are assigned colors to Vaadjacent nodes.In Algorithm 2, N number of graph nodes and c(Va) is assigned color to the Vanode. In fact, this assigned the smallest color is not exist in the set C (colors assigned to Vaadjacent nodes) to the Vanode. In this algorithm, the set of used colors to graph coloring is a subset of natural numbers that the color begins by number one.Now for start, we have answers that do not have any interference color. COA should only attempt to reduce the number of used colors. For this purpose, the laying egg part changes in a special way that is suitable for graph coloring.Now, for understanding how mother cuckoos are produced, we follow this example. A produced habitat by MCOA is in a form as follows in Fig. 7:The number of positions in habitat equals with the number of nodes in the graph. Each number in a position of a habitat shows the color code for that node.For Fig. 8, Algorithm 2 works as follow. The solution that is supposed to being colored and the first node that also is supposed to being colored are given to Algorithm 2. In Fig. 8 which have 7 nodes, a number randomly selects for coloring the first node.For example, Va=7 and in which we consider the solution to Fig. 9that for all nodes choose the highest color and give to Algorithm 2 to color.Now in coloring vertex algorithm, first, we hold adjacent node of Vafor node 7 and allocated color to this node like Fig. 10.Now, As Algorithm 2 implies, coloring vertex starts from the least color means 1 and if it is not within the color of adjacent nodes of Va, allocates that color to Vathat in this example, Vagets color 1 and the solution changes to Fig. 11.If V be the set of initial nodes of the graph, as it was shown in the following equation:(13)V={1,2,3,4,5,6,}After coloring the Vanode, this will eliminates from V set of this node; according to the following equation:(14)V={1,2,3,4,5,6}Now, for remaining nodes, calculate the adjacent nodes for each node using adjacent matrix, Fig. 12which derived from graph; means that for each column, we sum amounts 1 to specify each node degree and show that in array degviin the following equation:(15)Degvi=333121i=1,2,…,6Then, arrange the degviin an ascending form and in array index, hold the sorting index as Eq. (16):Then, for coloring based on degsorted, select the node with the highest degree from index as next node that here, we send node 1 with degree 3 and current coloring like Fig. 12 to Algorithm 2 and all steps within the algorithm repeats that derive the numbers of adjacent nodes Va=1 with their colors from adjacent matrix like Fig. 13:(16)degsorted=333211,index=123456Now, compares the least color means 1 with colors within the adjacent node colors and not make interference so, color allocates to Vaand solution comes to the form of Fig. 14.So, for coloring remained nodes, each next node selects degsorted and sends with solution to the algorithm that by this process, finally below solution produces like Fig. 15:So by this trend, mother cuckoo is produced in this way by algorithm instead of being produced randomly.In this section of the COA algorithm according to the current population status of cuckoos, we are attempting to produce an optimal permutation for cuckoo eggs. For this purpose, we search the neighborhood that was defined as in Algorithm 3:To explain this phase, we suggest the following definition:Definition 1If deg(Va)=m and {V1, V2, …, Vm} are adjacent nodes of Vanodes then:(17)Hdeg(Va)=deg(V1)+deg(V2)+⋯+deg(Vm)In Eq. (17), Hdeg (Va) is the total degrees of adjacent nodes of Vanode.Definition 2IfV1,V2,…,VDTare nodes in the solutions S cuckoo with the same color and have T color then:(18)QST=∑i=1DTHdeg(Vi)In Eq. (18)DTis equal to the number of nodes in the solution S cuckoo and has T color.Definition 3If N is the number of nodes of graph and k (S) is the number of colors S cuckoo uses for coloring the graph then:(19)FS=N/k(S)3If the solution of S cuckoo uses k (S) color for coloring the graph so then(20)Xsi=QSi−Qsi+10<i<K(S)Qsi−Qs1i=K(S)At this stage, each cuckoo seeks its neighborhood solutions. The S cuckoo is used for all the colors to solution and formsXSiusing Definition 4.IfnumberOfNodes4EachColor=QSTnumberOfNodes4EachColor=length (nodesWithColors)First i color will choose. After selecting first color, these steps repeat to build the first new solutions S cuckoo.Step 1: If i>1 and i<K(S) and number of Nodes for Each Colori−1>FSand i−1∉bS, then all nodes in the solution S cuckoo are colored i−1 and coloring by Coloring Vertex function and i−1can be added to the bsset. BScollection represents colors that are used in neighborhood search by S cuckoo. In this phase, FSis obtained from the Definition 3 and k(S) is the number of colors for coloring the graph which used by cuckoo S.Step 2: If i>1 and i<K(S) and number of Nodes for Each Colori+1>FSand i+1∉bSthen all nodes S cuckoo solutions have i+1 color can be colored by Coloring Vertex function and i+1 is added to the bSset.Step 3: If i∉bSthen all nodes that S cuckoo solutions have i color can be colored by Coloring Vertex function and i is added to the bSset.Step 4: The next color of nodes to be randomly selected and by Coloring Vertex algorithm allocates a new color to each node. Color choosing is completely random. The random selection, causes a new population of eggs, which are produced on the mother population, should be produced and placed in a better place. In this section, according to each mother, only one egg is produced and placed. It is a variation on the basic COA algorithm. After obtaining color i, go back to step 1 and repeat steps 1 to 4 until all nodes of graph are colored and neighboring solutions are generated. And its algorithm is as follow:Algorithm 3: search neighbourhood of each positionInput: currentColoring which colored by Algorithm 1Output: a k-coloring C={V1, V2, …, Vk} of currentColoring1. Set K=max(currentColoring);//K is the number of colors that used for currentColoring2. Set N=|V|;3. FOR colorNumber=1 to Kfind nodes with color of colorNumberENDFOR4. CalculateFsby Eq. (19)5. Calculate Xsi by Eq. (20)6. Set[Xs_sorted Xs_index]=sort(Xs,’descend’);7. Set newTmpColoring=generate n random number between 1 and N8. WHILE any(newTmpColoring==N)num=Generate Permutation of (length(Xs_index));index=Xs_index(num(1));Apply step 1 by Algorithm 3.a for color i−1Apply step 2 by Algorithm 3.b for color i+1Apply step 3 by Algorithm 3.c for color iENDWHILEAlgorithm 3.a: step 1Input: indexOutput: a coloring vertex index-1 of newTmpColoringIf i>1 and i<K(S) and numberOfNodes4EachColori−1>FSand i−1∉bSthen1. Set allNodesWithSameColorss=nodesWithColor(index-1);2. FOR counterColor=1to length(allNodesWithSameColorss)coloring newTmpColoring by Algorithm 2 with thisinputs(allNodesWithSameColorss(counterColor),newTmpColoring);ENDFORENDIFAlgorithm 3.b: step 2Input: indexOutput: a coloring vertex index+1 of newTmpColoringIf i>1 and i<K(S) andnumberOfNodes4EachColori+1>FSand i−1∉bSthen1. Set allNodesWithSameColorss=nodesWithColor(index+1);2. FOR counterColor=1 to length(allNodesWithSameColorss)coloring newTmpColoring by Algorithm 2 with thisinputs(allNodesWithSameColorss(counterColor),newTmpColoring);ENDFORENDIFAlgorithm 3.c: step 3Input: indexOutput: a coloring vertex index of newTmpColoringIf i∉bSthen1. Set allNodesWithSameColorss=nodesWithColor(index);2. FOR counterColor=1 to length(allNodesWithSameColorss)coloring newTmpColoring by Algorithm 2 with thisinputs(allNodesWithSameColorss(counterColor),newTmpColoring);ENDFORENDIFNow, in order to understand a neighborhood search, we consider an example:Neighborhood search of mother cuckoo is passing to this part and the following is extracted:For example, if currentColoring is as follow, neighborhood search for making eggs of cuckoo children, to the form of Fig. 16and by Eq. (21) acts(21)K=3,nodesWithColor=1,4,62,35,7In Eq. (21), nodes with color is a matrix that shows nodes which get the same color, means; nodes 1,4,6 from considered graph that located in row 1 have color 1 and nodes 2,3 in row 2 have color 2 and so as nodes 5,7,color 3 and k is the used colors in mother cuckoo means, Fig. 16.(22)numberOfNodes4EachColor=322,XS=101,XSsorted=110,XS_index=132(23)FS=73/3=0.7778A random permutation can be constructed based on the number of colors cuckoo's mother, as the following equation:(24)Num=3,2,1Now, based on index=Xs_index(num(1));=Xs_index(3)=2, implement defined procedure in Algorithm 3 for producing child cuckoo, means now that index=2.Step 1: extract all nodes that have color index-1 form matrix nodes with color in Eq. (21) and have Eq. (25):(25)AllnodesWithSameColors=1,4,6And this is the order of nodes that coloring vertex function do in Algorithm 1 on solution Newtempcoloring for coloring in Fig. 17that the Process is shown in Fig. 18:And Color index-1 is set in Bs As in the following equation:(26)Bs=1Step 2: then extract all nodes that have color index+1 from matrix nodes with color and have Eq. (27):(27)allnodeswiththesamecolor=5,7And proceed step 1 output which is Fig. 19that the process is shown in Fig. 20:Bs set updates with color index+1 according to the following equation (28):(28)Bs=1,2Step 3: now extract all nodes that have color index from matrix nodes with color and have Eq. (29):(29)Allnodeswiththesamecolor=2,3And proceed Fig. 21which is the output of step 2 that the process is shown in Fig. 22:Bs set updates with color index according to the following equation:(30)Bs=1,2,3By this, from mother cuckoo, means Fig. 16, produce a child in that local region in the form of Fig. 23according to neighborhood search.And this repeats for all mother cuckoos. Finally, Algorithm 5 shows the imposed MCOA algorithm on coloring problem that is called MCOACOL. Complementary algorithms don’t giver near optimal responses for such problems. Therefore, for responses optimization, we combine MCOACOL algorithm with local search Tabucol of Algorithm 4.Algorithm 4: TabuCol for GCPInput: A graph G=(V, E), an integer k>0Output: Solution C*1. Build a random solution C2. Set C*=C and iter=03. Set the Tabu List to empty set4. WHILE f(C)∼=0 or iter≤MaxIterSet iter=iter+1Choose a candidate 1-move(v,i) with minimum value δ(v,i)Introduce move(v,C(v)) into Tabu List or L+λf(C)Set C=C+(v,i)if f(C)<f(C*) then set C*=CENDWHILEAlgorithm 5: Apply MCOA to Graph Coloring Problem (MCOACOL)Input: A graph G=(V, E)Output: A best k-coloring of G1. Initialize cuckoo habitats with Algorithm 22. Dedicate some eggs to each cuckoo3. Define ELR for each cuckoo4. Let cuckoos to lay eggs inside their corresponding with Algorithm 35. Kill those eggs that are recognized by host birds6. Let eggs hatch and chicks grow7. Evaluate the habitat of each newly grown cuckoo through objective function8. Limit cuckoos’ maximum number in environment and kill those who live in worst habitats9. Cluster cuckoos and find best group and select goal habitat10. Let new cuckoo population immigrate toward goal habitat by Eq. (10)11. Apply Algorithm 4 for local search12. If stop condition is satisfied stop, if not go to 2For graph coloring by this algorithm, it is sufficient to design a cost function for the problem and first, give known number of each graph as the dimensions of V optimization as input to algorithm MCOACOL that the aim is color numbers reduction based on penalty. Our defined cost function contains two different sections and is as follow:(1)If there is no edge between nodes i and j and proposed colors for these two nodes are not the same, penalty increases by one unit. This penalty is used to reduce the number of colors used.The number of proposed colors for coloring the graph is the second value used, for which the first trace of color is stronger and more effective. Despite that these words are just auxiliary tool for penalty that makes a stronger impact; If not treated, but the number of colors used increases.These two components by assigning weights to each of the cost function to be as below:(31)Cost=P1×Penalty+P2×NumberofusedColorswhere P1 and P2 are user-defined weights. The number of highest level for maximum colors maybe used and the minimum color is found by two departments of cost function is obtained. The final algorithm called MCOACOL and cost function of this algorithm is equal to Eq. (31).In solving graph coloring problems to evaluate the algorithms, test function DIMACS (2002) of graphs are usually used [48]. Of course, most of these graphs, before this year, under various categories have been introduced by scientists. Some graphs of the set, were randomly and using programs of graph producer such as DSJ series David Johnson graphs is made. Some graphs also would be result of practical problems for example series graphs SCH Gary Londusky that involves the scheduling of class in each of the states with no spaces and spaces or series graphs LAT, which is related to the Latin square. Most important characteristics of each test graphs are the number of its vertices and the density of ledges. Labeling graphs is based on the characteristics and chromatic number of a graph, if known. For example, DSJC250.5 graph name involves 250 vertices and 0.5 density is of DSJ series. For this graphs,the time to answer, frequency of successful performance than the total numbers of performance and algorithm repetition among the most important of measurement criteria which have been used by researchers.In this section, results of MCOACOL algorithm will be evaluated. Cost function parameters are approximate values in the range, parameters shall be set as trial and error for each graph sample by the user.0.0001<p1<0.11000<p2Table 1shows the parameters MCOA for graph coloring.The implementation of the proposed algorithm is tested on 97 samples. In 67 samples of graph, the optimal solution in 20 times will be obtained and in the 20 remaining, results of implementation includes digressions that in the attached Table 6 shown in bold and in Fig. 24,we show the success rate of these samples in terms of percentage. In effect, the success rate; the number of times that the algorithm is obtained a valid coloring of the graph is measured. As it can be seen from Fig. 24, solving classes of graphs DSJ and queen n_n seems hard. Algorithms with success rates above 60% have accurately been reported in accordance with color value and in most cases, the success rate is close to 100%.The whole table of obtained results from algorithm MCOACOL that time and repetition is mentioned is attached in Appendix A.In Table 2, the results obtained from implementing the proposed algorithm (MCOACOL) with the results of algorithms ABAC [50] and BEECOL [49] are compared. The first column shows the name of the graph, the second column shows the number of vertices, best known chromatic number of a graph is shown in the third column and the next column indicates the chromatic number results of the three algorithms are compared. As seen in the table, based on the number of vertices of the graph are classified.The Performance of MCOACOL proposed algorithm with BEECOL and ABAC algorithms have been compared on 92 subjects of graph. As it can be seen from Table 2, MCOACOL algorithms as two algorithms that have been compared, easily and with accuracy and high speed are able to find known chromatic number of the graph.In 8 cases: (qg.order40; queen6_6; queen8_8; queen9_9; queen10_10; queen15_15; queen16_16 and ash331GP1A) known chromatic number of our proposed algorithm is equal to known chromatic number of BEECOL algorithm in comparison with ABAC algorithms different are 1.In 9 cases: (DSJC250.1; DSJC125.5; DSJC125.9; queen8_12; queen11_11; quenn12_12; queen13_13; queen14_14 and will199GP1A) chromatic number have 1 different with two algorithms is compared. For abb313GPIA sample have two different, for DSJ250.5 have 3 different with two algorithms is compared.In five samples of Graph (DSJR500.1, le450_5c, le450_5d, qg.order30 and queen7_7) our proposed algorithm in finding the chromatic number, obtains the better results than the algorithm BEECOL. MCOACOL algorithm for solving the graph coloring problem is inspired by BEECOL method and as can been seen MCOACOL algorithm shows better results than BEECOL.To ensure the accuracy of performance of MCOACOL algorithm and demonstrate its abilities in solving graph coloring problems, this section compares the proposed algorithms in solving graph coloring problems.As it can be seen from Table 3, MCOACOL algorithm in 12 samples of graph is compared to culture algorithms. in queen7–7 sample, our approach concludes 7 that, than cultural algorithm has achieved better outcomes and in 16 samples were compared with ANN in samples of 5-FullIns-4, 2-FullIns-5 and queen8_8 our proposed algorithm gives better results.We will also have other comparison with SAGCP and MSAGCP [52] algorithms that are reported in Table 4.Table 4 shows the comparison graph for 29 samples. As it can be seen, MCOACOL algorithm in comparison with or SAGCP algorithms in 21 instances gives better response in comparison with MSAGCP algorithm for 6 samples (1-insertion_5, 3-fullins_4, 4-inertion_4, miles1000, miles1500, mulsol. i.1). So our method has achieved a better answer. Our proposed algorithm in comparison with MSAGCP algorithm for queen11_11will results in chromatic number in 3 different.Queen n_n graphs are graphs and if there isn’t any collision, their chromatic number will be n. Including graphs of MIZ categories, are evaluated that is good samples for testing because hard graphs are well known and our approach like popular algorithms in the field, results in best chromatic number with high accuracy.As mentioned, MCOACOL algorithm for DSJ categories, is unable to find known chromatic number that may be seen in comparison with CLAVCA algorithm [53] and to find near-optimal results is adequate. But, for the last two examples CLAVCA algorithm easily finds the chromatic number. Table 5shows this well.To demonstrate the stability of the algorithm, stability diagram for each chromatic number obtained in the 20 times is drawn and Fig. 25shows stability of the algorithm on several graphs as below.In order to demonstrate the accuracy and speed of convergence of the algorithm, charts of convergence in 20 times implementation of the algorithm on sample of graphs, than cost function are plotted. Fig. 26shows faster convergence of algorithm with high precise to obtain chromatic number.The main reason why COA works better than other evolutionary algorithms, is in multiple performance of COA like spawning and migration in other evolutionary algorithms, we face operators that jut have one goal but in cuckoo optimization algorithm, defined operators simultaneously realize several goals. For example, clustering in COA helps cuckoo to divides the space into several sectors and choose the best place approximately. This area is likely to contain the global optimums. Then all cuckoo migrate to this area and better search within that area. This leads to much faster convergence of the cuckoo algorithm.Now, the question may arise why COA premature convergence does not occur?The answer is hidden in the process spawning of cuckoos. Unlike other algorithms, in cuckoo optimization algorithm, cuckoo mother's eggs are in different locations. Spawning particular model used in this algorithm plays an essential role in the COA:1.The eggs were distributed around the current optimal point helps COA not stuck in a local optimum.The process of laying alone is a local search process.Capability of cuckoo optimization algorithm in continuous space will provide an incentive in this paper presents the idea to discretization of cuckoo algorithms that conducted by implementation, the effective results of this discretization is obtained. Discretization on the most popular combinational problems (graph coloring problem) is tested and evaluated, graph coloring problem have done results on a range of benchmark function of this problem and analyzed and we compared the proposed algorithms in this context. Benchmark functions of graph coloring problem in various categories are classified from simple to difficult; in this study it was attempted to a wide range with all the features of the graph selected to test.Since the graph coloring problem is a NP-complete problem as well, some graphs require more time to solve that we based on a maximum iterative algorithm and it can be improved by increasing the quality and better results is obtained. The results show that MCOACOL algorithms is the main focus of this paper in most cases success rate is nearly 100% but as we have shown that compared with other methods, we cannot conclude that our algorithm is best in all cases of graphs. It can be said that the proposed algorithm is able to compete with the other algorithms in this field. Our method provides a good balance between diversification and centralizing, because using a neighborhood search in radius of the lay egg cause the algorithm hardly trapped in local minimum and producing new eggs, the diversity of population is maintained. The results of this study could be useful for solving practical problems of graph problems. To continue offered three suggestions as follows:First suggestion: Our algorithm when reach a fix state, it does not stop calculations because the termination condition based on the number of iterations of the algorithm originally given as input to the algorithm. For the graph coloring problem also occur when some external conditions, alter the relationship between nodes, finally, the algorithm is automatically activated and to restore the balance status, it works better.Second suggestion: Offer more parallelism in migration operator in the discrete cuckoo algorithm that cuckoo group in same time to move toward best current group that it is effective in the algorithm.Third suggestion: In this paper we have tested the algorithm for graph coloring problem. It is possible to continue with any proposed cuckoo discrete algorithms with a few changes, on the other discrete problems such as identification and tracking of social networks or similar problems, testing and analyzed the results.Table A.6.

@&#CONCLUSIONS@&#
