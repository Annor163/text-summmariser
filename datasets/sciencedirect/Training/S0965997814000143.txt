@&#MAIN-TITLE@&#
Finite Element/Fictitious Domain programming for flows with particles made simple

@&#HIGHLIGHTS@&#
Simulation of flows with suspended particles.Fictitious Domain/Finite Elements method.Topological data structure for mixed triangular/quadrangular meshes.Object oriented programming.

@&#KEYPHRASES@&#
Particulate flows,Numerical simulation,Finite element method,Fictitious Domain,Topological data structures,Lagrange multipliers,

@&#ABSTRACT@&#
Flows with suspended particles is a challenging task and important in many applications such as sedimentation, rheology and fluidized suspensions. The coupling between the suspending liquid flow and the particles’ motion is the central point in the complete understanding of the phenomena that occur in these applications. Finite Element/Fictitious Domain is an important class of method used to solve this problem. In this work we propose a simple object oriented implementation for simulations of flows with suspended particles in the plane using the Fictitious Domain method together with Lagrange multipliers to solve the Navier–Stokes and rigid body equations with a fully implicitly and fully coupled Finite Element approach. To have an efficient implementation for Fictitious Domain/Finite Element method, we introduce a new topological data structure that is concise in terms of storage and very suitable for searching the elements of the mesh intersected by the particles.

@&#INTRODUCTION@&#
Flows with suspended rigid particles occur in many different applications, from sedimentation problems to the manufacturing of ordered monolayer of micro and nano particles. The evolution of the particles position is a central point in the complete understanding of the flow of these suspensions. One way of analyzing the flow is to use a moving grid to discretize the Navier–Stokes equations that wraps around all suspended particles. This method requires remeshing and is not very efficient in the case of many particles. An alternative is the Fictitious Domain approach that was first proposed by Glowinski et al. [1], latter improved by Goano et al. [2] and recently extended to handle particle flotation by Lage et al. [3]. The Navier–Stokes equations are solved on a fixed mesh and the particles move over it. This approach avoids the need to remesh around the rigid particles, solving the entire problem on a single fixed mesh. The Navier–Stokes equations are solved on the entire domain, but inside each particle, the flow is constrained to be a rigid body motion using Lagrange multipliers.The implementation of particle flows methods based on Fictitious Domain/Finite Element is quite complex, since the degrees of freedom associated with each individual particle (linear and angular velocities) cannot be written in terms of elemental degrees of freedom. Moreover, the governing equations changes as the overlap of particles over finite elements varies during the flow. Therefore, an efficient implementation requires a topological data structure to optimize the searching procedure of the mesh elements intersected by the suspended particles in the fluid flow simulation. This detection is fundamental to identify where the Lagrange multipliers are active or not in the Fictitious Domain/Finite Element method [2].Contributions: In this work, we present an object-oriented implementation for the 2D Fictitious Domain/Finite Element method using non-structured meshes with triangular and quadrangular elements. The use of object-oriented programming (OOP) has been recognized as an useful coding technique for scientific computing [4–7] and in particular for Finite Element Methods [8–16]. This implementation uses important concepts of OOP, such as modularization, inheritance and encapsulation. As a consequence we provide a simple interface to the data structures and algorithms required to simulate particle flows.To have an efficient implementation for the 2D Fictitious Domain/Finite Element method using Lagrange multipliers, we also propose a new topological data-structure, called Compact Tri-Quad Representation, that gives a suitable balance between time and memory complexity for modeling a hybrid 2D mesh. Other data structures have been proposed in the literature in order to reduce the memory use on Finite Element Method implementations [17]. The Compact Tri-Quad Representation’s main characteristic is the conciseness in terms of storage without loosing its efficiency to answer adjacency and incidence relations queries. To answer such queries among the topological entities of the mesh (faces, edges and vertices), this data structure uses integer tables (implemented as containers) and integer formulas to implicitly represent some adjacency and incidence relations.Paper outline: The remainder of this work is organized as follows. Section 2 describes the Ficticious Domain formulation for fluid flow simulations with suspended particles. Section 3 presents the Compact Tri-Quad Representation data structure. Section 4 proposes the object oriented framework for a simple implementation for the 2D Fictitious Domain/Finite Element method. Section 5 shows the results. Finally, Section 6 concludes this work by making some remarks and suggestions for future developments.Notation:Consider a two-dimensional bounded domainΩwith external boundary∂Ω, which is filled with Newtonian incompressible fluids and suspended solid particles. Whenever the context is clear, we call fluid one or more immiscible, Newtonian and incompressible fluid phases filling the simulation domainΩ.We denoteΩf=⋃fi=1nfΩfithe region ofΩoccupied bynffluid phasesfi∈{1…nf}with densitiesρfiand viscositiesμfi, and we denoteΩp=⋃pi=1npΩpithe region ofΩcovered bynprigid particlespi∈{1…np}with densitiesρpiand radiusRpi. We also represent the interface between fluid and particles by∂Ωp=⋃i=1np∂Ωpi, where∂Ωpirepresents the boundary of the particlepiand we denote the interface between two fluid phasesfiandfjby∂Ωfij. Finally, we observe thatΩ=Ωf⋃Ωp. Fig. 1sketches a typical simulation scenario with a two dimensional domain filled by two fluid phases and one suspended solid particle.Formulation review:In this paper, we propose a programming approach to simulate flows with suspended rigid body particles using the formulation presented by Lage et al. [3]. Here, we briefly review the differential formulation of the problem. Let us define the velocity fieldu→pto be a rigid body velocity inside each particlepiand zero in the fluid regionΩf, i.e.:(1)u→p=U→pi+ωpi×(x→-X→pi)inΩpiwithpi∈(1…n)0inΩfThe integral momentum equation foru→prestricted toΩpican be written as:(2)∫ΩpiρpiDu→pDtdΩpi=∫Ωpiρpig→dΩpi+∫∂Ωpin→pi·σfd∂Ωpi+b→wheren→piis the outward normal to∂Ωpiandb→represents the capillary, repulsion or any other body force acting on the particle.Assuming that the liquid is Newtonian, the stress tensorσfcan be extended over the entire domainΩ. Such extension can always be done if we defineu→and p to be extensions overΩof the velocity and pressure fields.Using this extended stress tensor we can apply the divergence theorem and rewrite Eq. (2) as:∫ΩpiρpiDu→pDtdΩpi=∫Ωpiρpig→dΩpi+∫Ωpi∇·σdΩpi+b→Now, if we adopt the following notation:F→=-ρfDu→Dt+μ▵u→inΩpiwithpi∈(1…n)0inΩftogether with an additional constraint to the extended velocity fieldu→that imposesu→=U→pi+ωpi×(x→-X→pi)inΩpiand the fact the particle’s shape is circular, we can write the equation for the particle’s velocityU→pi:∫Ωpi(ρpi-ρf)∂U→pi∂tdΩpi=∫Ωpiρpig→-∇p+F→dΩpi+b→We can recover the angular velocityωpiassuming the no-slip boundary condition along the surface of particlepi,u→=U→pi+ωpi×(x→-X→pi)in∂Ωpi:∫ΩpiωpidΩpi=12∫Ωpi∇×(u→-U→pi)dΩpiUsing the forceF→, the extended velocityu→, pressure p and stress tensorσfields, we can write the momentum equation:ρDu→Dt=∇·σ+ρg→-F→inΩWe now define a global Lagrange multiplierl→that is related toF→through the following boundary value problem:(3)F→=-αl→+μ▵l→inΩ(4)l→=0on∂Ωwhereαis a positive constant parameter.The problem defined by Eqs. (3) and (4) is a well posed forF→and it is more efficient to use its unique solution to impose the rigid-body constraint on the extended velocity fieldu→(see Goano et al. [2]). The complete formulation of the flow with suspended particles using the Fictitious Domain method is:(5)ρDu→Dt=∇·σ+ρg→+αl→-μ▵l→inΩ∇·u→=0inΩ∫Ωpi(ρpi-ρf)∂U→pi∂tdΩpi=∫Ωpiρpig→-∇p-αl→+μ▵l→dΩpi+b→inΩpi∫ΩpiωpidΩpi=12∫Ωpi∇×(u→-U→pi)dΩpiinΩpiIn addition to the system of Eq. (5), the Lagrange multiplier in the fluid domain, the rigid body constraint inside the particle domain and the evolution of the particles’ position must also be in the complete formulation:l→=0inΩfu→=U→pi+ωpi×(x→-X→pi)inΩpi∂X→pi∂t=U→piforpi∈(1…np)To efficiently handle with the topological relationship between particles and mesh elements, which is the basic query needed to implement fully coupled particle flow simulations based on Fictitious Domain methods, we propose a new topological data structure to represent the simulation domain that we call Compact Tri-Quad Representation or simplyCTQR.Since Baumgart’s Winged-Edge data structure [18] for representing solids inR3, several modifications have been proposed in order to extend the range of objects to be modeled. Among those, Braid [19] introduced the concept of loop and Mäntylä [20] defined the Half-Edge data structure. Guibas and Stolfi [21] proposed a generalization to include non-orientable 2-manifolds implemented as the Quad-Edge data structure. Lopes [22] defined the Handle-Edge, a data structure that extends the Mäntylä’s Half-Edge to represent explicitly the boundary of a combinatorial surface.According to Brisson [23], a topological data structure can model the objects using an explicit or an implicit representation of cells. The Quad-Edge and the Facet-Edge do not explicitly represents each cell, while the Winged-Edge, the Half-Edge, the Handle-Edge are examples of data structures with explicit representation of cells. Another widely used dimension-independent data structure with an explicit representation is the Indexed Data Structure with Adjacencies by Paoluzzi et al. [24].Traditional non-manifold models are also very common in Finite Element applications, but usually for simulation of structures. Weiler [25] was the first to propose a non-manifold data structure, called Radial-Edge. After that, several modifications have been suggested to deal with specific applications. Some substantial contributions to non-manifolds representation include the works of Wu [26,27], Yamaguchi and Kimura [28], Gursoz [29], Rossignac and O’Connor [30], Cavalcanti et al. [31], and Lee and Lee [32]. More recently, de Floriani and Hui [33] presented a very concise data structure for non-manifold manipulation, called NMIA, which is an extension of the Indexed data structure with adjacencies, and Pesco et al. proposed the Handle-Cell[34], which is an extension of the Handle-Edge, to deal with general 2-dimensional cell complexes. All the above structures represent the cells explicitly.The data structures cited above are very suitable to represent unstructured meshes on Finite Element Method implementations, but they are not efficient in terms of memory costs. Thus, the development of concise data structures has been recognized as an important challenge [17]. In this context, Rossignac et al. [35] proposed a concise data structure, called Corner-Table, which uses only two tables of integers and a set of rules to represent triangular surfaces; and, Espinha et al. [17] introduced a concise data structure for tetrahedral meshes.The CTQR data structure has been created to represent 2-manifolds. It extends the Corner-Table[35] by its ability to deal with hybrid 2D meshes [36], composed by triangles and quadrangles, and at the same time can be considered as a concise version of the Handle-Edge[37]. It uses generic containers instead of pointers or static arrays. Similarly to the Corner-Table, it explicitly represents a few adjacencies and incidence relations between cells and uses a set of rules to obtain the others. However, CTQR has a very different and important characteristic that is a low memory consumption without loosing the efficiency in terms of computational complexity of the topological queries.CTQRdata structure uses the concept of half-edge[20] (see Fig. 2) to represent the association of a face (2D-element) with one of its bounding edges, or equivalently the association of this edge with one of its vertices. Any access to the elements of a face is performed through its half-edges, denoted byhe.CTQRrepresents triangles and quadrangles by storing the starting vertex of each half-edge. The half-edges, the vertices and the faces are indexed by non-negative integers. Each face is represented, according to its type, by 3 or 4 consecutive half-edges that define its orientation. The indexing rules for the half-edges are the following: all half-edges belonging to faces of the same type (triangle or quadrangle) comes in sequence, and half-edges of triangle come before the quadrangle ones.The association of each half-edgeheto its starting vertex is stored in one of the two containers of integers, named Tri-Vertex and Quad-Vertex containers and denoted byVt[]andVq[], respectively. The size ofVt[]is3ntwhileVq[]has4nqentries, wherentdenote the number of triangles andnqthe number of quadrangles on the mesh. It is important to notice, that these two tables store the same information as the traditional FEM data structuresNodes(3,elem)and/orNodes(4,elem)[38]. On theCTQR, we adopted a one dimensional array indexed by the half-edge identifier instead of using a two dimensional array of nodes to describe the relation between the nodal points and the elements as it is done in these two traditional FEM data structures. In theNodes(3,elem)andNodes(4,elem)data structures, the first index of the two-dimensional arrays is the register of a nodal point in an element (in counterclockwise direction, for example) and the second index is the identifier of the element. The use of a single indexation facilitates the access to several topological information at theCTQRthat will be explained along this section.Ifheis a half-edge of a triangle, the integerv=Vt[he]is the index of its starting vertex, whenheis a half-edge of a quadrangle, its starting vertex is given byv=Vq[he-3nt]. To simplify the interface for the programmer, we can define a functionV(he)that returnsVt[he]ifhe<3nt, or returnsVq[he-3nt]otherwise.Given a half-edge with indexhe, the first half-edge inside the face ofhehas index:fbasehe(he)=3⌊he/3⌋whenhe<3nt4⌊(he-3nt)/4⌋+3ntotherwiseTherefore, the indexes of the three half-edges that belong to the triangle with indext∈{0…(nt-1)}are3t,3t+1, and3t+2. The indexes of the four half-edges of a quadrangle with indexq∈{0…(nq-1)}are4q+3nt,4q+3nt+1,4q+3nt+2and4q+3nt+3. The next and previous half-edges of a given half-edgeheon its associated element can be obtained by the use of the following rules and are shown in blue in Fig. 2:nexthe(he)≔fbasehe(he)+(he¯+1)%ftypehe(he),prevhe(he)≔fbasehe(he)+(he¯+ftypehe(he)-1)%ftypehe(he).whereftypehe(he)=3ifhe<3ntand 4 otherwise. We also use the notation,he¯to represent the index of the half-edge given the geometry of its incident element, that is:he¯=heifhe<3ntandhe¯=he-3ntotherwise.In order to explicitly represent the adjacency relation of two elements, theCTQRuses another two containers of integers, named the Tri-Opposite container and Quad-Opposite container, denoted, respectively byOt[]andOq[]. Since we are working with 2-manifold, each half-edge is incident to one or two elements (see Fig. 3). The size ofOt[]is3ntand the size ofOq[]is4nq.The edge-adjacency between neighboring elements is represented by associating to each half-edgeheits opposite half-edgeO(he), which has the same vertices but opposite orientation. For example, in Fig. 2 theOq[hei]=hejand symmetricallyOt[hej]=hei. If the half-edgeheis on the boundary, then it does not have an opposite, which is encoded by settingO(he)=-1. Thus, the value ofO(he)allows to directly check whether a half-edgeheis on the boundary or not.It is important to observe that classical FEM implementations can use also two-dimensional arrays (one for quadrangles and other for triangles) to represent the connectivity of an specified element with its neighbor in the mesh [38,39]. The first index of the two-dimensional array is the register of an edge in an element (oriented in counterclockwise direction, for example) and the second index is the identifier of the element. The value stored in each entry of these arrays is an element identifier.Algorithm 1 shows how to build theOt[]andOq[]containers from theVt[]andVq[]containers. Again, to simplify the interface for the programmer, we can also define a functionO(he)that returnsOt[he]ifhe<3nt-1, or returnsOq[he-3nt]otherwise.Algorithm 1Ot[]andOq[]containersOt[i]←-1{Initializes the container}Oq[i]←-1{Initializes the container}map{vi×vj→hek}adjacencyforhe∈{0…c3nt+4nq-1}do{Gets the vertices pair ofhe}v0←V(he);v1←V(nexthe(he));v2←sort(v0,v1)ifadjacency.find(v2)thenifhe<3ntthenOt[he]←adjacency[v2]elseOq[he]←adjacency[v2]end ififO(he)<3ntthenOt[Ot[he]]←he{Found opposite half-edge}elseOq[Oq[he]]←he{Found opposite half-edge}end ifadjacency.erase(v2)else {Temporarily stores half-edge}adjacency[v2]←heend ifend forCTQRexplicit represents the vertices and edges of the mesh. To represent the vertices of the mesh,CTQRstores a new container that we call Extra Vertex Container, and denote byVH[], that associates for each vertexvan index of the lower half-edge incident to vertexv. In the case the vertex is on the boundary, the stored half-edge should be the boundary one (see Fig. 4). Such container has sizenvthat is the number of vertices on the mesh. Algorithm 2 builds theVH[]container using only theV[]andO[]tables.The Extra Vertex Container is very important since it optimizes not only the vertex star computation (we will define the vertex star later), but also the boundary traversal. Many simple numerical operators such as derivative, are based on the computation of the star of a vertex and the elements on the boundary are very important to represent the boundary conditions.Algorithm 2VH[]containerVH[i]←-1{Initializes the container}forhe∈{0…c3nt+4nq-1}doifO(he)=-1ORVH[V(he)]=-1thenVH[V(he)]←heend ifend forCTQRidentifies an edge by its half-edge of lower index. In fact, the edges are explicitly represented by a map called Edge map that is denoted byEH[], which maps the index of the lower of the two incident half-edges an edge to its attributes such as finite element’s related degrees of freedom and/or computer graphic’s properties such as color, normal vector and curvature. The mapEH[]hasneentries, whereneis the number of edges on the mesh. Explicit edge representation is essential in many applications. In computer graphics, simplification algorithms based on edge collapses usually need an additional data structure to store the collapse coast of each edge [40]. UsingCTQRthis information may be stored on the edge map. In finite elements codes, some well know kind of elements (such as biquadratic quadrangular elements) needs to represent degrees of freedom defined over the element edges, which may be easier handled if an explicit representation of the edges is provided [38]. Algorithm 3 shows the construction ofEH[].Algorithm 3Edge Map construction1:EH[]←0{Initializes the container}2:forhe∈{0…c3nt+4nq-1}do3:he0←he;he1←O(he){Gets the half-edge pair ofhe}4:ifhe1≠-1then {The half-edgehe0is in the interior of the mesh}5:heid←min(he0,he1)6:else {The half-edgehe0is in a boundary curve of the mesh}7:heid←he08:end if9:ifnotEH[].find(heid)then10:EH[heid]←Edge(he0,he1)11:end if12:end forThe boundary of a combinatorial 2-manifold is a set of combinatorial 1-manifolds without boundary, i.e., a set of closed simple curves. In Finite Elements/Fictitious Domain methods, the explicit knowledge of the boundary curves of the simulation domain is very important to the imposition of boundary conditions and to the build efficient particle-boundary collision algorithms. In CTQR, such representation is done by storing in the containerBH[], an identifier of a half-edge that belongs to each boundary curve. The containerBH[]hasnbentries, wherenbis the number of boundary curves of the domain. Theith boundary curve can then be traversed using Algorithm 4. The boundary transversal algorithm is very efficient because it uses theVH[]container to detect the next boundary edge in the curve.Algorithm 4Boundary transversal algorithmshe←BH[i]//Gets the first half-edge on theith boundary componenthe0←he//Auxiliary half-edgerepeatv←V(nexthe(he))he←VH[v]untilhe0≠heUsing the proposed data structure, we can develop topological procedures to transverse the mesh elements. The queryRi,jrepresents the adjacency (incidence) relation of a cell of dimension i with the cells of dimension j. For example,R0,2represents the query that for a given vertexvanswer the set the elements incident tov.R0,2is also known as the vertex star. Such queries are essential to detect the elements of the meshes intersected by the particles during the simulation (see Section 4.2).TheCTQRanswers relationsR02(v)in timeO(deg(v)), wheredeg(v)represents the valency of a vertexv. This complexity is achieved sinceVH[]directly stores the starting half-edge to traverse the vertex star. The algorithm to compute theR02topological operation usingCTQRis described in Algorithm 5.Algorithm 5The vertex starhe←VH[v]//Gets the first incident half-edgehe0←he//Auxiliary half-edgerepeathe←O(prevhe(he))R02.push(facehe(he))untilhe0≠heORO(he)=-1More details on the implementation and complexity of all topological queries are found in [41].Here we show explicitly the containers of theCTQRusing a very simple example. The chosen mesh is a planar torus. In this simple example we can observe all features ofCTQRdata structure (see Fig. 5).The containersVt[]andVq[]store the initial vertex of each half-edge belonging to triangles and quadrangles respectively. The containersOt[]andOq[]store the opposite half-edges. Observe that the opposite of the boundary half-edges (he=1,he=5,he=7,he=10,he=12,he=14,he=16,he=18andhe=20) are set to-1.VH[]container stores the first half-edge that parts from each vertex of the mesh. If we observe the entryVH[0]we see that, as the vertexv=0is a boundary vertex, its associated half-edge is the one with idhe=1since it is the boundary half-edge parting from the vertexv=0. Finally, we show the containersEH[]andBH[]. For each edge, we get its lower half-edge to be its identifier and store it inEH[]. When the edge is at the boundary, its identifier is its single half-edge, as we see in the edge with indexhe=1. For each boundary curve, we store its lower half-edge inBH[]. In this example, we have two boundary curves and the representative half-edge of each curve arehe=1andhe=5.All data structures described in the introduction of this section provide different trade-offs between memory usage and time complexity of basic operations such as identifying a topological entity, accessing its vertices, computing its stars, etc. When handling huge amount of data, a programmer has always to balance the memory consumption with the time complexity. We compared CTQR with the Handle-Edge[22] and the Corner-Table[35]. We choose these two data structures because CTQR is a concise representation of the first and an extension of the second. From this point, we assume that the object hasn0vertices,n1edges andn2triangular faces. For the memory comparisons, we will only consider the memory used to store the topological information.To represent the topology of this triangular mesh, the Handle-Edge uses 4 pointers per face, 13 pointers per edge and 4 pointers per vertex. To estimate the memory consumption of the model in terms of the number of vertices we can use the Euler characteristic formula:χ=n0-n1+n2. Assuming that the number of boundary components are smallχ≈0, and also supposing that the number of boundary edges is small when compared to interior edges, we can say thatn1≈32n2. As a consequencen0≈12n2. Assuming that the mean valency of a vertex is 6 and that a pointer uses 4 bytes, then the memory consumption of the Handle-Edge can be approximated to4·4·n0+4·13·32·2·n0+4·4·2·n0≈204·n0bytes.The Corner-Table data structure is very concise, but it does not have a constant time complexity to answer all the adjacencies and incidence relations. It describes the mesh using two tables of integers (equivalent to theVt[]andOt[]tables) with size equal to 3 times the number of faces. Using the same assumptions described in the previous paragraph, this structure spends approximately4·3·2·n0≈24·n0bytes.We observe that the in classical FEM implementations using the data structureNodes(3,elem)together with the neighbor representation described in Section 3 use the same amount of memory ofOt[]andVt[]containers. So, in terms of memory consumption, such classical FEM data structures are equivalent to the Corner-Table[35].The CTQR represents the mesh using two tables of integers (theVt[]andOt[]containers) with length equal to 3 times the number of faces each, one table of integers equal whose length is the number of edges (EH[]), and one table of integers with size equal to the number of vertices (VH[]). Thus, the CTQRconsumes approximately4·3·2·n0+4·32·2·n0+4·n0≈40n0bytes. Table 1resumes the comparison of the memory complexity of these three data structures.Table 2shows the time complexity to answer the incidence and adjacency relations queriesRi,jbetween the topological entities of the mesh. The CTQR answers the queries with the same complexity of the Handle-Edge. And it has a better result compared to the Corner-Table because it stores theVH[],EH[] containers. We also notice here, that the classical FEM implementations using the data structuresNodes(3,elem)together with the neighbor representation described in Section 3 have the same time complexity of the Corner-Table since they store equivalent topological information.Conceptually, the Corner-Table represents only triangles and the Handle-Edge faces with any number of vertices. The CTQR represents meshes with triangles and rectangles, that is suitable for Finite Element Methods implementations using hybrid meshes.The CTQR and the Corner-Table has a low memory complexity when compared to the Handle-Edge, but they are not adequate to support remeshing operations since they use containers instead of pointers. But remeshing is not necessary for the Finite Element/Fictitious Domain methods.As a conclusion, we could say that the CTQR proposal gives a suitable balance between time and memory complexity to a hybrid 2D mesh representation.For the Finite Element/Fictitious Domain implementation, it is also useful to use additional containers to store vertex and face related geometrical and/or physical attributes.The Vertex attributes container, denoted byVA[], hasnventries, wherenvis the number of vertices on the mesh. For each vertex it stores its geometric coordinates and physical attributes.The Face attributes container, denoted byFA[], stores the unknowns defined inside the faces and the particles’ indices that intersect it. Such information is used to improve search algorithm (see Section 4.2). The containerFA[]hasnfentries, wherenfis the number of elements on the mesh.Observe that it is not necessary to define an additional container to represent geometric and physical properties over edges since the edge mapEH[]can easily be used to store any edge related data.Our Finite Element computational framework was developed in C++ programming language and uses object oriented design to encapsulate its structuring concepts. In other words, by means of the structuring capabilities of C++, the most important parts of our finite element simulation program are independently designed. In our proposal, the description of meshes, finite element spaces, and linear algebra objects are encapsulated which allows a very modular and reusable approach in programming finite element softwares.Although some of the concepts proposed in this work are present in [11], the goals of our work are quite different. We did not intend to develop a general propose finite element library. Our aim is to have a simple and reusable Finite Element/Fictitious Domain implementation based on the Lagrange multipliers formulation that can be applied to simulations of flows with suspended particles.We divide the description of our framework in two stages. Section 4.1 describes the object oriented implementation to simulate problems modeled by the Navier–Stokes equations and Section 4.2 reports its extension to Fictitious Domain applications like flows with suspended particles.The relationship between the most important structuring concepts used to simulate Newtonian incompressible flows is shown in Fig. 6. In that figure, we use the UML notation to represent these relationships [42]. The description of the classes in this section follows this figure from left to right.Gauss points, FEM basis and Element classes:In our code, the Element class manages the representation of different types of elements that may be used to perform the computation of Navier–Stokes solution.The representation of an element is based on the definition of its geometry, its local nodes indexation and the numbering of degrees of freedom defined over each node. We adopted the following convention: we first label nodes and degrees of freedom defined over vertices, then the ones over the edges and finally the ones defined over the face. An example of the adopted nodes codification is shown in Fig. 7.In fact, the indexation of degrees of freedom is closely related with the choice of the finite element approximation space used to compute the unknowns of the problem. Based on the indexation information, the Element class access the FEM basis class, that has the implementation of a collection of static methods with the algebraic definition of different basis functions and also their derivatives computed on the local coordinates(ξ,η)defined inside each element. Fig. 7 shows the local coordinate system adopted in our implementation for triangular and quadrangular elements.We implemented biquadratic and bilinear basis function for quadrangular elements and quadratic and linear functions for triangular elements. Fig. 7 shows, in gray, the nodes used to build the bilinear (for quadrangles) and linear (for triangles) basis functions. The gray nodes together with the white ones are used to define the biquadratic (for quadrangles) and the quadratic (for triangles) basis functions. We observe that, if necessary, other sets of basis functions can be easily added to the FEM basis class.Finally, the Element class access the Gauss points class that stores constant tables with the definition of Gauss points and weights, represented in the local system of coordinates. The Gauss points are used to perform the numerical integration of the integral terms that appears on the variational formulation of the problem. In our code, its available one table with 9 Gauss points and weights to integrate over the quadrangles and one table with 6 points and weights to be used to approximate integrals defined over triangles. In order to include new sets of Gaussian Quadrature points and weights to the code, the user needs only to define new tables. It is important to note that the Element class does not represent an element of the mesh, which is the goal of the Mesh class.Mesh and Dof Handler classes:The Mesh class is a wrapper to theCTQRdata structure and is used to represent the domain’s mesh discretization. It encapsulates the access to all topological queries among the cells of the mesh. The Mesh class together with the local description of its elements, given by the Element class, makes possible to code the global indexation of the mesh nodes and its degrees of freedom in a table. In other words, the Dof Handler class builds and stores tables of integers with the global indexation of nodes and degrees of freedom and manages their relationship with the local indexation tables, defined on the Element class. For example, given a local node or degree of freedom and the index of an element, Dof Handler answers the global index of this node or degree of freedom and vice versa. Fig. 8shows an example of local–global indexation mapping.The global indexation is closely related to the sparsity of the Finite Element matrix that describes the discrete version of the system of differential equations to be solved. There are many works that propose improved methods to create the global indexation of nodes and degrees of freedom as the one by Bangerth [11]. The Dof Handler class abstraction creates an interface that makes it possible to change the global numbering algorithm, without affecting the rest of the code.FEM Map class:In finite element codes, the algebraic equations are evaluated in a computational domain that is described using a local system of coordinates. However, it is necessary to map the local and global coordinate system. The FEM Map class is responsible to perform the computations necessary to perform this change of coordinates system, from the local(ξ,η)to the global(x,y)system using isoparametric mapping.In practice, the main task managed by this class is, given an element id, to evaluate and cache the previous computed solution for the unknowns, the basis function values over the Gauss points and the inverse of the Jacobian Matrix that describes the change of coordinates from local system of the element to the global physical system.We observe that those data are only temporarily cached on this class since, as we will see on FEM core class description, the main finite element loop runs over the mesh elements. All data necessary to perform those computations are provided by the Dof Handler class.FEM core class:The central class on our finite element code is the FEM Core class, that derivates from FEM Map. This class manages the main finite element loop: the one in which the non-linear system of differential equations is solved by the Newton’s method, that requires the evaluation of the global Jacobian matrix and residual vector.The assembly loops are performed over the mesh elements. Given an element, the contribution of its degrees of freedom to the Jacobian matrix (the residue vector) are computed and later added to the matrix (vector). The Jacobian matrix is a sparse squared matrix which size is#dof×#dofand the residue vector has dimension#dof, where#dofdenotes the number of global degrees of freedom on the mesh. An entry(i,j)on the Jacobian matrix is non-zero if and only if the nodes associated to the degrees of freedom indexes i and j are both incident to at least one element. The assembly of the residue vector is shown in Algorithm 6.Algorithm 6Assembly loopsfor all mesh elements edoLe←ComputeL (e)// Contribution of the degrees of freedom inside e.C←Assembly (Le)// Puts on the residue vector/Jacobian Matrix.end forThe main simulation loop runs over the time and is responsible to solve Newton’s method at each time step. Once Newton’s method succeeds, the solution is updated and the simulation continues to the next time step. The loop proceeds until it reaches the maximum time or Newton’s method fails.Observe that the algebraic expressions of the differential equations related to the problem’s physics are implemented in this class. If one needs to develop an even more modular code, these computations can be moved to other class that will inherits FEM core elements and will be the responsible for the physical description of the problem.The object oriented implementation we developed for Fictitious Domain simulations of flows with particles is quite similar with the one presented in the previous chapter. The main difference is that we need to include a description for the particles and also to maintain updated a search structure that changes with time. The search structure must answer efficiently when an element or a node is inside any particle, or reciprocally which elements or nodes are inside a given particle. The class relationship on the code is shown in Fig. 9.Particle and Search classes:The particle class describes the degrees of freedom of a particle. Given a particle, each of its degrees of freedom is locally indexed, and their association with a globally defined identifier is managed by the Dof handler class. By convention the global indexation of the particle’s degrees of freedom begins after the indexation of the flow degrees of freedom.One of the most important class in our Fictitious Domain code is the Search class. We use the power of theCTQRdata structure and the adjacency structure between elements of the mesh to develop the particle-element search structure, which uses theCTQRinteger containerFA[] to store the index of the particles inside an elemente. Supposing that the particle displacement is always smaller than the characteristic size of the mesh’s elements, we can update efficiently the search structure in each time step, using theCTQR, only testing elements that are inside any particle in the current step, and also its neighboring elements, computed using the data-structure. This makes a huge reduction in the number of tests needed to update the structure and reduces its complexity fromO(np·(nt+nq))toO(np·n¯e), wheren¯eis the average number of elements that are inside or have a neighbor inside a particle. We also observe that particle flow simulations needs to compute particle–particle and particle boundary collision. With the use of theCTQRdata structure and together with the proposed search structure, the collision tests are straightforward since we only need to check collisions between particles that are over the same element (for particle–particle cases) and collisions of particles over boundary elements (for particle-boundary cases).The update algorithm is sketched in Fig. 10. The left picture on the image shows an hypothetic search configuration on a given time t. The elements that lie inside the particle are shown in light gray, and together with its neighbors (the dark gray elements) they are the elements that must be tested by the algorithm. The image at right shows the search structure after the update process.We divided our tests in two parts. The first part of tests aims to evaluate the efficiency of the particle-elements search algorithm and no physics is solved through the Finite Elements/Fictitious Domain methods. The particles move using an explicit Euler time integration. In the last part, we analyze the efficiency of our software in a Finite Elements/Fictitious Domain simulation. All tests were performed on an iMac with a quad-core Intel Core i5 2.5GHz processor and 4GB DDR3 1333MHz of RAM.Fig. 11shows four frames of a test using a non-uniform triangle mesh with 1017 elements and one particle at different time steps. The particle withRp=0.08was initially located atX→p=(0.4,-0.5)and it moves with a constant velocity ofU→p=(0.1,0.2). When the particle hits the boundary, the velocity vector is reflected according Snell’s law. The marked elements represent those overlapped by the particle. The graphic shows the time consumed by the search routine as the particle moves through the domain. It falls as the particle reaches regions of larger elements. The search time varies with the local mesh discretization since the procedure looks for overlapped elements in the neighborhood of the previous particle position.Fig. 12(a) shows the average search time for the complete particle path as a function of the total number of elements. Since the element size is non-uniform and the mesh is unstructured, the search cost is not a linear function of the number of elements of the mesh. Fig. 12(b) shows the behavior of the algorithm in an analogous test using an uniform and structured mesh of quadrangles, also shown in the figure. The number of elements in the neighborhood of the particle is almost constant for each time step and the total search time varies linearly with the number of elements.Fig. 13shows a snapshot of cases with different number of particles moving with prescribed kinematics, using a mesh with 512 elements. The graphic shows the mean time spent by the search procedure to locate all particles. It varies linearly with the number of particles (see Fig. 14).We now present results of flows with suspended and floating particles obtained by the use of the Finite Elements/Fictitious Domain formulation proposed by Lage et al. [3] and the computational approach described in this paper. We discuss the performance of our implementation in the next paragraphs by studying the result of a prototype fluidized bed with seven particles. Fluid flows from the bottom towards the top of the 2D channel due to an imposed pressure difference.The complete set of parameters is the following: the domainΩis a channel parametrized by[-1,-5]×[1,5], discretized by a mesh of 500 squared elements withQ2-Q1finite elements basis functions. The fluid phaseΩfis a Newtonian incompressible liquid with densityρf=1.0andμf=0.01. Seven particles with radiusRp=0.02and densityρp=0.5are embedded on the fluid. The particles are initially at rest and at positionsX→p0=(-0.75,4.7),X→p1=(-0.25,-4.7),X→p2=(0.25,-4.7),X→p3=(0.45,-4.7),X→p4=(-0.5,-4.35),X→p5=(0.0,-4.35),X→p6=(0.5,-4.35). The simulation’s time step isδt=10-3s and the total simulated time is1.5s. As done in Lage et al. [3], we set the Lagrange multiplier parameterαto be 150.Table 3shows the performance of our code in the fluidizided bed case with seven particles and without particles respectively in the first 50 time steps of the simulation. In both tests we measured mean time to build the Jacobian Matrix, to build the Residue Vector and to solve the linear systems of each Newton’s method iteration. Observe that the most expensive operation is the evaluation and assembly of the Jacobian Matrix and that its mean execution time remains almost the same in both cases – the variation is around 5%. The solution of the linear system of equations at each Newtons step takes approximately 30% more time in the flow with particles. In this case, the Jacobian matrix loses the banded structure of the pure Navier–Stokes solution, which compromises the solution efficiency. Moreover, since the particles move along the finite element mesh, the structure of the matrix changes with time. The total simulation time however, decreases more than two times in the simulation without particles. This fact shows that the assembly algorithm is almost independent of the number of particles but suggests that the Fictitious Domain formulation for flows with embedded particles has stronger non-linearities. In fact, Newton’s method needed 2.05 iterations to converge in the test with particles and only 1.12 iterations without particles.

@&#CONCLUSIONS@&#
