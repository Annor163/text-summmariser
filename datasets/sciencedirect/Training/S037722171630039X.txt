@&#MAIN-TITLE@&#
Robust storage loading problems with stacking and payload constraints

@&#HIGHLIGHTS@&#
We present a new model for stacking problems with payload constraints.Due to uncertain item weights, two robust optimization approaches are developed.Problems are solved using exact decomposition and heuristic algorithms.Using a characterization of worst-case scenarios, a compact model is presented.

@&#KEYPHRASES@&#
OR in maritime industry,Storage loading,Stacking problems,Payload restrictions,Robust optimization,

@&#ABSTRACT@&#
We consider storage loading problems where items with uncertain weights have to be loaded into a storage area, taking into account stacking and payload constraints. Following the robust optimization paradigm, we propose strict and adjustable optimization models for finite and interval-based uncertainties. To solve these problems, exact decomposition and heuristic solution algorithms are developed. For strict robustness, we also propose a compact formulation based on a characterization of worst-case scenarios. Computational results for randomly generated data with up to 300 items are presented showing that the robustness concepts have different potential depending on the type of data being used.

@&#INTRODUCTION@&#
Storage loading problems appear in several practical applications, e.g., in the context of container terminals, container ships, warehouses or steel yards, see Lehnfeld and Knust (2014). Especially container transportation plays a vital role in today’s global economy. For convenient transportation by different modalities, containers are standardized in term of twenty-feet-equivalent-units (TEUs), which refers to containers of twenty-feet lengths. According to an executive summary in UNCTAD/RMT/2014 (2014), the throughput of container ports all over the world was 651.1 million TEUs in 2013 (corresponding to 1524 millions tons of cargo), in which 160 million TEUs were transported by ships. Therefore, it can be seen that the transportation of seaborne containers contributes an important part in international trade. Furthermore, there has been a progressive increase in maximum container-ship size, from 500 TEU ships by the mid 1950s to 18,000 TEU vessels by 2013 (see Lee and Meng, 2015, p. 6). Such numbers make professional and efficient operations essential in container ships. This motivates an active research topic on finding efficient solution methods for maritime container transportation. An up-to-date collection of planning and scheduling problems in large maritime container yards, together with latest solution approaches, can be found in Li, Wu, and Goh (2015). Many other topics on maritime container transportation, such as tactical and operational management in shipping liners, empty container repositioning, etc., are collected in Lee and Meng (2015).In this paper, we focus on storage loading problems where incoming items arrive at a storage area and have to be assigned to stacks so that certain constraints are respected. Usually, only the topmost item of each stack can be directly retrieved, i.e., the items are accessed in last-in-first-out order. The items are often relocated by cranes moving above the stacks, which imposes a restriction on the maximum height of a stack. Additionally, certain stacking constraints have to be respected, i.e., not every item may be stacked on every other item. For example, larger items are not allowed to be put on smaller ones, or items with a later departure time may not be stacked on items with an earlier departure time. For a survey and a classification scheme of such problems we refer to Lehnfeld and Knust (2014). Complexity results for stacking problems taking into account a limited height of the stacks and stacking constraints are provided in Bruns, Knust, and Shakhlevich (2016).In many practical loading problems, additional stability issues are crucial. In load planning of trains (cf. Bruns, Goerigk, Knust, & Schöbel, 2014; Bruns & Knust, 2012) containers have to be loaded onto wagons so that the stability of each wagon is guaranteed. In one-dimensional balanced loading problems (cf. Amiouny, Bartholdi, Vate, & Zhang, 1992; Mathur, 1998), one has to pack a set of homogeneous blocks of given length and weight in an one-dimensional container so that the center of gravity of the packed blocks is as close to a target point as possible. An extension of this problem to two dimensions can be found in air cargo load planning (cf. Vancroonenburg, Verstichel, Tavernier, & Berghe, 2014), where a set of cargo has to be loaded on an aircraft minimizing the deviation between the aircraft’s center of gravity and a given point (in both the longitudinal and lateral directions) to improve stability of the aircraft and reduce fuel consumption. In many studies on three-dimensional container loading problems (see Bortfeldt and Wäscher, 2013 and references therein), the aim is to find a best three-dimensional packing pattern for loading a subset of rectangular boxes into a container maximizing the total value. Here, stability issues arise due to the strength of the boxes’ faces or the maximum number of boxes that can be stacked one above each other.Also, when loading items onto a ship, the stability of the ship is an important issue that needs to be taken into account. It follows from a physical principle (see Halliday, Resnick, and Walker, 2014, Chapter 12) that the position of the gravity center of the loaded ship affects the ship’s stability in the following sense: the lower the gravity center, the more stable the ship is. Consequently, as shown in Appendix A, to obtain the best stability of a ship (i.e., to have the lowest gravity center of the loaded ship), the items should be stored in such a way that heavier items are assigned to lower levels. Therefore, in the existing literature about storage loading problems in containerships, stability issues of the ships are mostly handled by imposing hard stacking constraints on the weights of the containers (i.e., heavier containers must be put below lighter ones). For example, such stacking constraints appear in the context of the master bay plan problem (MBPP) (cf. Ambrosino, Sciomachen, & Tanfani, 2004, 2006; Sciomachen & Tanfani, 2003). Formally, this problem is to determine a plan of minimum operating time for stowing a set of containers of different types into available locations of a containership, with respect to some structural and operative constraints (e.g., a restriction on the maximum weight of the containership, containers retrieved later may not be stored on top of containers that are retrieved earlier). For the equilibrium of ships, the weights of containers are classified into three groups (light, medium, heavy), and the following restrictions are considered. First, the total weight of three consecutive containers in a stack cannot be greater than an a priori established value. Second, the weight on the right side of the ship should not differ much from the weight on the left side (for cross equilibrium). Finally, the stacking constraints on weights are applied to guarantee horizontal equilibrium. In Ambrosino et al. (2004) the authors propose a binary linear programming model for the problem, present a heuristic approach, and give some prestowage rules for being able to solve the model. Another solution approach for the same problem is presented in Ambrosino, Sciomachen, and Tanfani (2006) based on a three-phase algorithm using the idea of splitting the ship into different parts and assigning the containers to them on the basis of the containers’ destinations. In Sciomachen and Tanfani (2003) a heuristic method based on a relationship of the MBPP to three-dimensional bin packing problems is proposed.In real-world containership loading problems, the hard stacking constraints on the containers’ weights might be too conservative due to their interaction with other practical constraints. Moreover, the lowest center of gravity of the loaded ship caused by imposing the hard stacking constraints on weights might make the ship become too rigid, which may be bad for the ship when hit by waves. To get rid of these issues, a simple approach is to assume that the total weight of the containers allocated in a stack is limited by a given bound. For example, this approach is applied in Delgado, Jensen, Janstrup, Rose, and Andersen (2012); Delgado, Jensen, and Schulte (2009) to generate optimal stowage plans for container vessel bays by using constraint programming techniques. Another approach is to impose a limited area for the gravity center of the ship. One may find the use of this approach in literature dealing with the multi-port master bay plan problem (MP-MBPP), which is an extended version of the (one-port) MBPP mentioned above. In the MP-MBPP, the whole route of a ship is considered, and different sets of containers are loaded at each port of the route for shipping to successive ports. Various objective functions are considered, as well as different solution methods are proposed, (see e.g. Ambrosino, Paolucci, & Sciomachen, 2015a, 2015b, 2015c; Kang & Kim, 2002; Pacino, Delgado, Jensen, & Bebbington, 2011, 2012). There, the containers are sorted according to their departure ports. In turn, the containers of the same departure port are classified into different weight groups, where the average weight of each group is assigned to every container belonging to the group. The ship is divided into different parts called bays, each bay in turn is partitioned into sub-sections. Then the containers are stored into these sub-sections in such a way that the center of gravity of the ship is within a limited area.In the paper at hand, we use another approach to tackle the mentioned drawbacks of hard stacking constraints on weights and to control the stability of a ship by imposing additional constraints on the payload of the items. More precisely, we assume that the total weight that can be put on top of an item i with weight wimust be limited by awi, where a is a given positive parameter which may depend on the stacks. With this additional constraint on the payload of the items, the height of the highest possible position of the gravity center of each stack is an increasing function with respect to a (see Appendix A). The payload parameter a can therefore be chosen to achieve the desired position of the gravity center of each stack, and consequently it can be used to control the stability of the ship.In practice, it might also be possible that payload violations are allowed and the gravity center of the ship may be shifted to a higher position. To achieve the desired stability of the ship, an amount of ballast corresponding to the total payload violation is put at the bilge of the ship so that the gravity center of the whole ship is adjusted to a safe position (cf. Zeng et al., 2010). By minimizing the total payload violation over all stacks, the amount of ballast needed is minimized, and consequently, the shipping cost is reduced while the ship’s stability is guaranteed.Since in real-world applications, often not all data are exactly known during the planning stage, we consider storage loading problems under data uncertainty in this paper. In particular, we assume that the weight of each item is uncertain and may come either from a finite set of possible scenarios or from an interval of potential outcomes. We consider two approaches to include robustness in this setting: strict robustness (see Ben-Tal & Nemirovski, 1998), where the location of each item needs to be fixed before its actual weight becomes known, and adjustable robustness (see Ben-Tal, Goryashko, Guslitzer, & Nemirovski, 2003), where each item must only be assigned to a stack, but its position within the stack can be decided once the weight is known. Our approach using payload constraints takes advantage of using knowledge of all possible weight outcomes of the items, rather than binning the items into groups and assigning to each item the average weight of its group.For general surveys on robust optimization, we refer to Ben-Tal, Ghaoui, and Nemirovski (2009); Bertsimas, Brown, and Caramanis (2011); Goerigk and Schöbel (2016); Kouvelis and Yu (1997). Other applications of robust optimization include disaster management (Ben-Tal, Chung, Mandala, & Yao, 2011; Goerigk & Grün, 2014), load planning of trains (Bruns et al., 2014), shunting problems (Cicerone, D’Angelo, Stefano, Frigioni, & Navarra, 2007), empty container repositioning (Erera, Morales, & Savelsbergh, 2009), and many more. Storage loading problems with uncertain data have, for example, been studied in Kim, Park, and Ryu (2000). There, the weights of the items are classified into three groups and the weight group of each item is not known before its arrival. In the storage area, the heavier items should be stored in higher levels of the stacks, since they have to be retrieved earlier to put them in the bottom of a vessel according to the hard stacking constraints on weight. In Kang, Ryu, and Kim (2006) the authors propose a simulated annealing algorithm to find a good stacking strategy for a similar problem where the incoming items have uncertain weights. In Le and Knust (2015), incoming items arriving at a partly filled storage area have to be assigned to stacks regarding that not every item may be stacked on top of every other item and taking into account uncertain data of items arriving later. Strict and adjustable robust solutions are calculated using different MIP formulations.The remainder of the paper is organized as follows. In Section 2, we describe the deterministic stacking problem and formally introduce the uncertainty sets. The strictly robust counterpart of this uncertain problem is considered for both finite and interval uncertainty sets in Section 3, while adjustable counterparts are discussed in Section 4. Computational experiments are presented in Section 5. Finally, conclusions can be found in Section 6.In this section, we give a formal definition of the studied storage problem, formulate its deterministic version as a mixed-integer program (MIP), and introduce the considered uncertainties.In the following, we describe the nominal (deterministic) problem in more detail. Let m be the number of stacks where for each stack a position in the storage area is fixed. Each stack can hold at most b items. The set of all items is denoted byI={1,2,⋯,n}where normally the inequality m < n holds, i.e., some items have to be stacked on others. Since all items have to be stacked, we assume that n ≤ bm; otherwise the problem is infeasible.As a hard constraint we assume that not every item may be stacked on every other item (for example, a larger item may not be stacked on top of a smaller one or an item with a later departure time may not be stacked on top of one with an earlier departure time). Such stacking constraints may be encoded by a 2-dimensional binary matrixS=(sij)n×n,wheresij=1if i can be stacked onto j andsij=0otherwise. Stacking constraints may be transitive (i.e., if item i is stackable on top of item j and item j is stackable on top of item h, then also i is stackable on top of h) or may have an arbitrary structure. For example, restrictions coming from lengths or departure times of the items are transitive, while restrictions induced by materials may be non-transitive. In this paper we develop models which are capable to deal with stacking constraints of an arbitrary structure.Items stored in a stack are defined by a tuple(ik,…,i1),where ildenotes the item stacked at level l andl=1corresponds to the ground level. Such a tuple is feasible if k ≤ b andsil+1,il=1for alll=1,…,k−1.Additionally, we assume that each item i ∈ I has a weight wiand that the total weight of items put on top of item i should not be larger than awiwith a given payload factora∈R+. If the total weight W of all items above i exceeds awi, a payload violation ofW−awioccurs. The total payload violation of a stacking configuration is defined as the sum of the payload violations over all items in all stacks of the configuration. Note that all our models are also valid for the more general situation where the payload factor may depend on the assigned stack. In this paper, the payload constraints are assumed to be soft, i.e., payload violations are allowed, but have to be minimized. Our discussion also includes the situation of hard payload constraints, since in this case a feasible solution exists if and only if the minimal total payload violation is equal to zero.The simplest version of a storage loading problem is the feasibility problem (cf. Bruns et al., 2016) which asks whether all items can be feasibly allocated to the storage area respecting all hard constraints, i.e., the stack capacity b and the stacking constraints sij. If this is possible, the objective is to assign each item to a feasible location (specified by a stack number and a level in the stack). In Bruns et al. (2016) it was shown that deciding whether a feasible solution exists is strongly NP-complete even forb=3and transitive stacking constraints. In an optimization version of the problem additionally some objective function (e.g., the total number of used stacks or the number of items stacked above the ground level) may be minimized. In this paper we concentrate on minimizing the total payload violation as the objective function. This problem is strongly NP-hard for b ≥ 3, since it generalizes the feasibility problem.In the following, we present a MIP formulation for the nominal problem wherew∈R+nis the vector of the nominal weights of all items. Furthermore, letQ:={1,…,m}be the set of stacks andL:={1,…,b}be the set of levels. We use the notation[α]+to indicate max {α, 0}. Let xiqlfor i ∈ I, q ∈ Q, l ∈ L be binary variables withxiql={1,ifitemiisstoredinstackqatlevell,0,otherwise.For a stacking configuration encoded by x, the payload violation of an item in stack q ∈ Q at level l ∈ L∖{b} is[∑j∈I∑h=l+1bwjxjqh−a∑i∈Iwixiql]+and hence the total payload violation of the configuration is given byf(x,w):=∑q∈Q∑l∈L∖{b}[∑j∈I∑h=l+1bwjxjqh−a∑i∈Iwixiql]+To linearly represent the objective function f(x, w), we use additional non-negative variables vqlfor q ∈ Q, l ∈ L to compute the payload violation of the item stored in stack q at level l. Then the problem can be formulated as follows.(1)min∑q∈Q∑l∈L∖{b}vql(2)s.t.∑q∈Q∑l∈Lxiql=1∀i∈I(3)∑i∈Ixiql≤1∀q∈Q,l∈L(4)∑j∈I∖{i}sijxjq,l−1≥xiql∀i∈I,q∈Q,l∈L∖{1}(5)∑j∈I∑h=l+1bwjxjqh−a∑i∈Iwixiql≤vql∀q∈Q,l∈L∖{b}(6)xiql∈{0,1}∀i∈I,q∈Q,l∈L(7)vql≥0∀q∈Q,l∈L∖{b}According to (1) the sum of all payload violations is minimized. Constraints (2) guarantee that all items are stored. Constraints (3) ensure that at most one item is stored at each level of each stack. Due to (4) the stacking constraints sijare satisfied and no item is placed to a location where no item is stacked below. Inequalities (5) ensure that the payload violations vqlare computed correctly.We refer to this problem as (P). Note that (P) usesO(nmb)variables and constraints. In the following we denote byX:={x∈{0,1}|I|×|Q|×|L||xsatisfies(2)--(4)}the set of feasible solutions respecting all hard constraints of the stacking problem.In this paper, we consider two kinds of uncertainties for the item weights that affect the payload constraints:•In the first case, we assume that for every item i, we are provided with lower and upper boundswi,w¯ion the possible outcome of item weights. We writeUI=[w̲1,w¯1]×…×[w̲n,w¯n]to denote an interval-based uncertainty set. An elementw∈UIis called a scenario. The lower and upper bounds stem from empirical observations or expert knowledge. We do not assume knowledge of any probability distribution overUI.In the second case, we assume that we are given a list of N possible scenarios, whereas before a scenario consists of a weight for each item. We writeUF={w1,…,wN}for the uncertainty set containing all possible outcomes. Such a description of scenarios may either be based on the expertise of practitioners (e.g., an experienced storage loading manager is able to enumerate typical outcomes of uncertain weights), or may stem from a probabilistic analysis and represents the most likely outcomes. We writeN={1,…,N}.In case that we do not need to distinguish these two kinds of uncertainty sets, we simply writeUto denote the uncertainty set. Note thatUFis a finite set, whileUIcontains infinitely many possible outcomes. This leads to different solution approaches for the robust models we consider in this paper.In this section, we consider the problem setting where a complete stacking solution has to be fixed in advance before the actually realized scenario becomes known. Such an approach is required if the storage plan has to be announced before the actual weights of the items are known and the plan cannot be changed later on. This means that the planner has to find a complete stacking solution, i.e., to decide for each item to which stack and level it is assigned, based on incomplete knowledge. Following the approach of Ben-Tal and Nemirovski (1998); Kouvelis and Yu (1997), we focus on strictly robust solutions where the worst-case payload violation over all scenarios is minimized. The strictly robust counterpart (SR,U) of the optimization storage loading problem (P) under affection of uncertainty setUis(SR,U)minx∈Xmaxw∈Uf(x,w).We first consider the case of finite uncertainty in Section 3.1, afterwards the more elaborate case of interval-based uncertainty is discussed in Section 3.2.In the following, we modify the problem formulation (P) to include a finite uncertainty set. First, we introduce new variablesvqlk≥0forq∈Q,l∈L∖{b},k∈Nmeasuring the payload violation of the item stored in stack q at level l in the solution for scenario k. Additionally, an auxiliary variable v ≥ 0 is introduced to measure the total payload violation in the worst-case over all scenarios. We denote this problem as (SRF), though we may also write (SR,UF) when the usage of uncertainty setUFshould be emphasized, and obtain the following MIP formulation:(8)(SRF)minv(9)∑q∈Q∑l∈Lxiql=1∀i∈I(10)∑i∈Ixiql≤1∀q∈Q,l∈L(11)∑j∈I∖{i}sijxjq,l−1≥xiql∀i∈I,q∈Q,l∈L∖{1}(12)∑j∈I∑h=l+1bwjkxjqh−a∑i∈Iwikxiql≤vqlk∀q∈Q,l∈L∖{b},k∈N(13)∑q∈Q∑l∈L∖{b}vqlk≤v∀k∈N(14)xiql∈{0,1}∀i∈I,q∈Q,l∈L(15)vqlk≥0∀q∈Q,l∈L∖{b},k∈N(16)v≥0The objective (8) is to minimize the largest total payload violation over all scenarios. As in the nominal problem, constraints (9) ensure that every item is stored, constraints (10) model that at most one item is assigned to every location, and constraints (11) take care of the stacking constraints sij. Furthermore, according to constraints (12) the payload violationsvqlkare correctly computed for every scenario k. Finally, constraints (13) (together with the minimization in (8)) ensure that the variable v equals the maximum of these values. Compared to the nominal model (which usesO(nmb)variables and constraints), this formulation requiresO((n+N)mb)variables and constraints.We now consider (SR,UI), i.e., the strictly robust model with interval-based uncertainty setsUI. We denote this problem as (SRI) for short. Due to the continuous nature of the uncertainty setUI,there are infinitely many scenarios and we cannot include all these scenarios into a MIP formulation as we have done with (SRF). Therefore, we discuss approaches that iteratively choose scenarios fromUIto include them in a finite uncertainty set (see also Bouman, Akker, and van den Hoogeveen, 2011; Montemanni, 2006; Zeng and Zhao, 2013, where similar ideas have successfully been applied). The general procedure is shown in Algorithm 1. We start with an arbitrary scenariow0∈UI. In each iteration k, we find a best stacking configuration xkwith respect to the current (finite) set of scenariosUk,i.e., xkis a solution to (SR,Uk). Then we determine a worst-case scenariowk+1∈UIcorresponding to this stacking configuration (i.e., a scenario of item weights maximizing the total payload violation f(xk, w) for configuration xk). The worst-case scenario found in each step is added to the current set of scenarios. This is repeated until the objective value of the robust problem and the objective value of the worst-case problem coincide.Theorem 1Algorithm 1terminates after a finite number of iterations and yields an optimal solution x to (SRI).Let f* be the optimal objective value of (SRI), i.e.,f*=minx∈Xmaxw∈UIf(x,w).SinceUk⊆Uk+1⊂UI,we haveLBk=minx∈Xmaxw∈Ukf(x,w)≤minx∈Xmaxw∈Uk+1f(x,w)=LBk+1≤minx∈Xmaxw∈UIf(x,w)=f*.On the other hand, by definition of UBkin Step 7 of the algorithm, we haveUBk=f(xk,wk+1)=maxw∈UIf(xk,w)≥minx∈Xmaxw∈UIf(x,w)=f*.This means that LBkis a lower bound on f* and UBkis an upper bound on f*. Therefore, ifLBk=UBk,then(xk,wk+1)is an optimal solution to (SRI) andLBk=f*is the optimal objective value of (SRI).We now show that if LBk≠ UBk, thenwk+1∉Uk,so that the algorithm never enters a cyclic loop. Indeed, assume to the contrary thatwk+1∈Uk. As defined in Step 6 of the algorithm, we havewk+1=argmaxw∈UIf(xk,w)⇔UBk=f(xk,wk+1)≥f(xk,w)∀w∈UI⇒UBk=f(xk,wk+1)≥f(xk,w)∀w∈Uk(sinceUk⊂UI)⇔UBk=f(xk,wk+1)=maxw∈Ukf(xk,w)(sincewk+1∈Uk).Moreover, as defined in Step 5 of the algorithm, we haveLBk=maxw∈Ukf(xk,w). Therefore, we again obtainLBk=UBkunder the assumption thatwk+1∈Uk. This means that if LBk≠ UBk, then we must havewk+1∉Uk.The termination of the algorithm after a finite number of iterations follows immediately from the two following claims: (a) the number of possible stacking configurations xkgenerated by the algorithm is finite, (b) the number of possible worst-case scenarios wkgenerated by the algorithm is also finite. Indeed, since there is a finite number of items, also the number of possible stacking configurations for these items is finite, and claim (a) follows. By Step 6 of the algorithm, we generate only one worst-case scenariowk+1corresponding to stacking configuration xk, so claim (b) follows from claim (a).□How to solve Step 5 of the algorithm was shown in Section 3.1. We now discuss how Step 6 can be realized. Given a stacking configuration x, we need to find a vectorw∈UIof item weights maximizing the total payload violation (i.e., the sum of payload violations over all levels of all stacks). Since there is no payload violation in stacks containing only one item, we have to compute the maximum total payload violation in all stacks containing at least two items.For any stack q ∈ Q in the given configuration x, let I(q) be the set of items contained in it andL(q):={1,…,|I(q)|}. We assume that |I(q)| ≥ 2. For the sake of simplicity, we denote the weight of the item at level l ∈ L(q) by w[l].Lemma 2The total payload violation of any stack q ∈ Q, given byvq(w)=∑l∈L(q)[∑h>lw[h]−aw[l]]+is a convex function.We have that∑h>lw[h]−aw[l]is linear in w, and taking the maximum of two convex functions is again a convex function. Since the sum of convex functions is also convex, the claim follows.□We denote the problem of finding item weights w that maximize the payload violation vq(w) for a stack q ∈ Q as (V). Due to the convexity of vq, we can make use of the fact that there is always an optimal solution to (V) where each item weight is at its lower or upper bound. This gives rise to the following formulation as a mixed-integer program. For all l ∈ L(q), we introduce continuous variables w[l] determining the weight of the item at level l in q. Furthermore, we use binary variables βlwithβl=0ifw[l]=w̲[l]andβl=1ifw[l]=w¯[l]. Finally, variables αlare used to correctly compute the payload violation[∑h>lw[h]−aw[l]]+in the objective function. We haveαl=1if∑h>lw[h]−aw[l]≥0andαl=0if∑h>lw[h]−aw[l]<0. Then, problem (V) can be formulated as follows.(17)(V)max∑l∈L(q)(∑h>lw[h]−aw[l])αl(18)s.t.w[l]=w̲[l]+(w¯[l]−w̲[l])βl∀l∈L(q)(19)αl,βl∈{0,1}∀l∈L(q)(20)w[l]≥0∀l∈L(q)Note that this formulation is non-linear, due to the product of α and w in the objective function. We can remove variables w[l] by inserting Eq. (18) in the objective function, and get the equivalent model(21)max∑l∈L(q)∑h>l(w̲[h]+(w¯[h]−w̲[h])βh)αl−∑l∈L(q)a(w̲[l]+(w¯[l]−w̲[l])βl)αl(22)s.t.αl,βl∈{0,1}∀l∈L(q)By introducing new variablesγlh=αl·βhfor all l, h ∈ L(q), we obtain the binary linear program(23)max∑l∈L(q)(∑h>lw̲[h]−aw̲[l])αl+∑l∈L(q)(∑h>l(w¯[h]−w̲[h])γlh−a(w¯[l]−w̲[l])γll)(24)s.t.αl+βh−1≤γlh≤12(αl+βh)∀l,h∈L(q)(25)αl,βl∈{0,1}∀l∈L(q)(26)γlh∈{0,1}∀l,h∈L(q)The objective function (23) is the same as in (21) after substituting and reordering terms. The additional constraints (24) are used to ensure that γlhis one if and only if both αland βhare one. Solving problem (23)–(26) independently for each stack q ∈ Q hence gives the desired solution to Step 6 of Algorithm 1.Note that maximizing a convex function over a convex domain in general is an NP-hard problem (Benson, 1995). However, we can show that for this special case an efficient solution algorithm exists.Theorem 3For a given stacking solution and any value of the payload parameter a, the maximum total payload violation of each stack q ∈ Q can be found by evaluatingO(|I(q)|2δ−1)scenarios, whereδ:=min{⌈a⌉,⌊|I(q)|2⌋}.As mentioned above, due to the convexity of vq, to find an optimal solution to (V) it is sufficient to consider only scenarios where the weights of all items in I(q) are either on their lower or upper bounds. For a choice of item weights w, we say that at level l < |I(q)| a solution has a break ifw[l]=w̲[l]andw[l+1]=w¯[l+1],and an anti-break ifw[l]=w¯[l]andw[l+1]=w̲[l+1]. An example with six items, two breaks and one anti-break is depicted in Fig. 1, left. Items having their upper-bound weights are painted in gray, while items having their lower-bound weights are painted in white. There are breaks at levels two and five, and an anti-break at level three.Note that there is always an optimal solution where the bottom item is as light as possible, and the top item is as heavy as possible; therefore, there is always an optimal solution with at least one break. Whenever there is a break at some level l of an optimal solution to (V), without loss of generality we can assume that∑h>lw[h]−aw[l]≥0. Indeed, if this was not the case, then we have ∑h > lw[h] < aw[l], i.e., there is no payload violation at level l of stack q. Therefore there is still no payload violation at this location if we increase w[l] by a positive amount. In other words, we could increase the weight of the item at level l without decreasing vq(w).We now show that there is an optimal solution to (V) with at most δ breaks. Firstly, we note that each break occupies two consecutive levels in the stack, and different breaks occupy different levels. Therefore, there are no more than⌊|I(q)|2⌋breaks in stack q. Secondly, there exists an optimal solution to (V) with at most ⌈a⌉ breaks. Indeed, let w* be an optimal solution of (V) with β* > ⌈a⌉ breaks and let l* be the level of the topmost break. If we increase the weight of the item at level l* byΔ=w¯[l*]−w̲[l*],the payload violation at level l* decreases by at most aΔ. However, there are at leastβ*−1more payload violations beneath level l*, which result in an increase of vq(w) by at least(β*−1)Δ(see Fig. 1, right). Due to β* > ⌈a⌉, the total payload violation could be increased. Therefore, we can remove the break at level l* without decreasing the violation vq(w). Repeating this argument until the next break level, we find that there is an optimal solution with at most ⌈a⌉ breaks.We now count the number of possible scenarios withβ∈{1,…,δ}breaks. In such a scenario, between any two consecutive breaks there must be exactly one anti-break. Therefore, each of such scenarios corresponds to a choice of2β−1levels for β breaks together withβ−1anti-breaks in between. Since stack q contains |I(q)| items, there are|I(q)|−1levels that can have breaks or anti-breaks. This leads to(|I(q)|−12β−1)possible scenarios having β breaks. Enumerating all these possibilities forβ=1,2,…,δgivesO(|I(q)|2δ−1)possible scenarios that have to be tested.□Note that if a is a fixed value, the complexityO(|I(q)|2δ−1)is polynomially bounded in the input length of the problem and hence (V) can be solved in polynomial time.Due to Theorem 3, Step 6 of Algorithm 1 can alternatively be realized by enumerating all relevant item weights per level. However, the result can also be used to avoid the iterative algorithm and to formulate a compact model that includes all relevant scenarios directly. Note that these are not scenarios in the sense that a specific item gets some weight; instead, we assign to a specific level either the lower or upper weight of an item. The result is a formulation similar to the one used in Section 3.1.We present this compact formulation of (SRI) for the case a ≤ 1 where we know that for each stack only a single break has to be considered. Hence, only|I(q)|−1scenarios are relevant for stack q, where in the solution for scenario k the break occurs at level k. We introduce auxiliary variableswqlk≥0denoting the weight of the item in stack q at level l in the solution for scenario k with a break at level k. Modifying the formulation (SRF), we get the following MIP formulation for (SRI):(27)min∑q∈Qvq(28)s.t.∑q∈Q∑l∈Lxiql=1∀i∈I(29)∑i∈Ixiql≤1∀q∈Q,l∈L(30)∑j∈I∖{i}sijxjq,l−1≥xiql∀i∈I,q∈Q,l∈L∖{1}(31)wqlk=∑i∈Iw̲ixiql∀q∈Q,k,l∈L,l≤k(32)wqlk=∑i∈Iw¯ixiql∀q∈Q,k,l∈L,l>k(33)∑h>lwqhk−awqlk≤vqlk∀q∈Q,k,l∈L∖{b}(34)∑l∈L∖{b}vqlk≤vq∀q∈Q,k∈L∖{b}(35)xiql∈{0,1}∀i∈I,q∈Q,l∈L(36)vqlk≥0∀q∈Q,k,l∈L∖{b}(37)wqlk≥0∀q∈Q,k,l∈L(38)vq≥0∀q∈QIn the solution for scenario k, all items up to level k are assumed to be as light as possible (constraints (31)), while all items at higher levels are as heavy as possible (constraints (32)). The payload violation in the solution for scenario k for stack q and level l is measured by the variablevqlkin constraints (33). The worst-case over all scenarios is computed with the help of the variables vqand constraints (34).For a > 1 a similar formulation can be used by enumerating all possible scenarios via the number of breakpoints, usingO(b2δ−1)relevant scenarios per stack. We present the formulation for a ≤ 2 in Appendix B.Note that in the case of hard payload constraints (i.e., no payload violations are allowed which implies that the total payload violation must be equal to zero), a more compact formulation can be given. For this, we consider the single robust payload constraint∑j∈I∑h=l+1bwjxjqh−a∑i∈Iwixiql≤0∀q∈Q,l∈L∖{b},w∈UIFor a fixed location (q, l) ∈ Q × (L∖{b}), the first term of the left hand side in this inequality is equal to the total weight of all items stored above this location, while the sum in the second term equals the weight of the item stored at the location. The maximum difference over allw∈UIbetween the former and the latter term is therefore attained when the item stored at the location has minimum weight, while the items stored above have maximum weights. As we have pointed out, there exists a worst-case scenariow∈UIwhich dominates all other scenarios fromUIwith respect to this constraint. Hence, this robust payload constraint can be equivalently written as(39)∑j∈I∑h=l+1bw¯jxjqh−a∑i∈Iw̲ixiql≤0∀q∈Q,l∈L∖{b}Now, any stacking solution has zero payload violation if and only if all these worst-case inequalities are fulfilled, i.e., the robust counterpart of the problem is given by (1)–(4), (39), (6).Following the ideas first introduced in Ben-Tal et al. (2003), we now consider a robust model where not all stacking decisions need to be fixed in advance, but some can be made after the realized scenario becomes known. In our setting, we follow the idea that a planner needs to determine in advance to which stack an item is assigned (“here-and-now” decision); however, he is allowed to choose the level of the item within the stack depending on the weight scenario of all items later (“wait-and-see” decision). This gives the planner more flexibility in his decision making and potentially better results with less payload violations.Such a setting occurs in practice if special subareas (stacks) must be reserved for the items in advance (for example, according to the different destination of the items). As another example we refer to the following setting from Tierney, Pacino, and Jensen (2014): In the hatch overstow problem, containers need to be loaded onto a ship with several hatches, where different areas of the ship have to be filled separately. In our setting, in the first stage we assign containers to subsets of stacks in the terminal (corresponding to the subareas on the ship). In the second stage, these subsets are then loaded onto the ship, and the precise locations of the items in the stacks of the corresponding subarea are determined using the weights that are now known. For the sake of simplicity, we restrict our presentation to the setting that items are assigned to single stacks in the first stage (and not to subsets of stacks). However, models and solution algorithms can be extended to this setting (see Appendix C).In Section 4.1, we first consider finite uncertainty sets before the more complex interval-based models are discussed in Section 4.2.As in Section 3, we would like to optimize the worst-case performance of a stacking solution over all possible weight realizations. There are two kinds of decisions that need to be made: Here-and-now decisions independent of realized item weights, which determine for every item the stack it is assigned to; and wait-and-see decisions depending on the scenario, which decide the level of each item at which it should be stored.We introduce binary here-and-now variables ziqfor i ∈ I, q ∈ Q whereziq=1if item i is assigned to stack q. Furthermore, wait-and-see variablesxiqlkdepend on the realized scenario k and determine if item i is stored in stack q at level l in the solution corresponding to scenario k. Then the problem can be formulated as follows.(40)(ARF)minv(41)s.t.∑q∈Qziq=1∀i∈I(42)∑i∈Iziq≤b∀q∈Q(43)∑q∈Q∑l∈Lxiqlk=1∀i∈I,k∈N(44)∑i∈Ixiqlk≤1∀q∈Q,l∈L,k∈N(45)∑l∈Lxiqlk=ziq∀q∈Q,i∈I,k∈N(46)∑j∈I∖{i}sijxjq,l−1k≥xiqlk∀i∈I,q∈Q,l∈L∖{1},k∈N(47)∑j∈I∑h=l+1bwjkxjqhk−a∑i∈Iwikxiqlk≤vqlk∀q∈Q,l∈L∖{b},k∈N(48)∑q∈Q∑l∈L∖{b}vqlk≤v∀k∈N(49)ziq∈{0,1}∀i∈I,q∈Q(50)xiqlk∈{0,1}∀i∈I,q∈Q,l∈L,k∈N(51)vqlk≥0∀q∈Q,l∈L∖{b},k∈N(52)v≥0Constraints (41) model that every item has to be assigned to some stack, while every stack contains at most b items (constraints (42)). Constraints (43) ensure that also for each scenario every item has to be assigned to exactly one stack and level in the corresponding solution, while constraints (44) restrict the number of items at any location to be at most one. We couple the here-and-now variables ziqwith the wait-and-see variablesxiqlkin constraints (45): If the here-and-now decisions assign item i to stack q, then also in every scenario k item i has to be assigned to some level l in stack q. Constraints (46)–(48) are used to model the stacking constraints and to compute the payload violations.Note that this formulation is more sensitive to the number of scenarios than the strictly robust model, withO(Nnmb)variables andO((N+n)mb)constraints.We now consider the adjustable robust problem with interval uncertainty, denoted as (ARI). As in Section 3.2, we follow the idea of an iterative approach that considers relaxed problems with finite uncertainty sets, and a subproblem to generate worst-case scenarios. This subproblem now becomes more complex, since the worst-case generation also needs to take the possible wait-and-see decisions into account.According to the here-and-now decisions all items are assigned to stacks, but their ordering in the stacks (i.e., the assignment to levels) is determined later when the weights of all items are known. To this end, we consider the following two subproblems for a single stack:1.Given a subset of possible item orderings, we search for a worst-case weight scenario that maximizes the smallest total payload violation over all orderings.Given a weight scenario, we search for an item ordering that minimizes the total payload violation.Both subproblems are iteratively solved, until their objective values coincide.We consider a fixed stack q ∈ Q and assume that the set I(q) contains all items which are assigned to q according to the here-and-now decisions ziq. Furthermore, letL(q):={1,…,|I(q)|}and L′(q) ≔ L(q)∖{|I(q)|}. LetP(Iq)be the set of all permutations for the items in the set I(q), each permutation describing an assignment of all items to levels in the stack. Furthermore, we denote by vq(π, w) the total payload violation for stack q with respect to the weights w if the items in I(q) are ordered according to the permutation π.In the first subproblem, for a given subsetP′(Iq)⊆P(Iq)of permutations for the items in stack q we search for a worst-case weight scenariow∈UIthat is a solution of problem(Max-w)maxw∈UIminπ∈P′(Iq)vq(π,w).In the following, we assume that the setP′(Iq)contains K permutationsπ1,…,πKwhich are described by binary valuespilkwithpilk=1if and only if in permutation πkitem i ∈ I(q) is assigned to level l ∈ L(q). LetK:={1,…,K}.To solve problem (Max-w) for all i ∈ I(q), we introduce continuous variableswi∈[w̲i,w¯i]determining the weight of item i. Additionally, we have variablesvlk≥0measuring the payload violation for the item assigned to level l in the permutation πkand binary auxiliary variablesαlkto determine whether there is a payload violation at level l in the permutation πkor not. Finally, the auxiliary variable v ≥ 0 denotes the total payload violation of the stack. Then problem (Max-w) can be formulated as follows.(53)maxv(54)s.t.∑l∈L′(q)vlk≥v∀k∈K(55)(∑h>l∑i∈I(q)pihkwi−a∑i∈I(q)pilkwi)αlk=vlk∀k∈K,l∈L′(q)(56)w̲i≤wi≤w¯i∀i∈I(q)(57)αlk∈{0,1}∀k∈K,l∈L′(q)(58)vlk≥0∀k∈K,l∈L′(q)(59)v≥0According to (53) the total payload violation of the stack is maximized. Constraints (54) ensure that v equals the smallest payload violation over all item permutations. Due to (55), the payload violations are correctly computed. Finally, (56) guarantees that the weight variables wiare contained in the given intervals.Note that constraints (55) are non-linear, due to the product of α with w. To remove this non-linearity, we introduce new variablesβilk=wiαlkand require0≤βilk≤Mαlkandwi−M(1−αlk)≤βilk≤wifor a suitable large constant M (note thatM≥w¯isuffices). This gives rise to the following new formulation:(Max-w)maxvs.t.∑l∈L′(q)∑h>l∑i∈I(q)pihkβilk−a∑l∈L′(q)∑i∈I(q)pilkβilk≥v∀k∈Kβilk≤w¯iαlk∀k∈K,l∈L′(q),i∈I(q)wi+w¯i(αlk−1)≤βilk≤wi∀k∈K,l∈L′(q),i∈I(q)w̲i≤wi≤w¯i∀i∈I(q)αlk∈{0,1}∀k∈K,l∈L′(q)βilk≥0∀k∈K,i∈I(q),l∈L′(q)v≥0We denote this problem as (AV1, I(q),P′) and its optimal objective value byv¯q(P′).We now consider the second subproblem, which consists of finding a (possibly new) permutation for the items in stack q minimizing the total payload violation with respect to the current weights w, i.e., a solution of problem(Min-π)minπ∈P(Iq)vq(π,w).For i ∈ I(q), l ∈ L(q) we introduce binary variables pildetermining the item permutation, i.e.,pil=1if and only if item i is assigned to level l. Variables vl≥ 0 for l ∈ L′(q) are used to determine the payload violation at level l. Then, problem (Min-π) can be formulated as follows.(60)(Min-π)min∑l∈L′(q)vl(61)s.t.∑h∈L(q)h>l∑j∈I(q)wjpjh−∑i∈I(q)awipil≤vl∀l∈L′(q)(62)∑i∈I(q)pil=1∀l∈L(q)(63)∑l∈L(q)pil=1∀i∈I(q)(64)pi,l+1+pjl≤1∀i,j∈I(q)withsij=0,l∈L′(q)(65)pil∈{0,1}∀i∈I(q),l∈L(q)(66)vl≥0∀l∈L′(q)Due to (60) the total payload violation is minimized. Constraints (61) are used to determine the violations vlat the different levels. The assignment constraints (62) and (63) ensure that at each level exactly one item is stored and that each item is assigned to exactly one level, respectively. Due to constraints (64) the item permutation is feasible with respect to the stacking constraints sij. We denote this problem as (AV2, I(q), w) and its optimal objective value byvq*(w).These two subproblems are then solved, until their objective values coincide and the worst possible total payload of a fixed stack assignment is determined, which also yields a new worst-case weight scenario. This scenario is added to the main adjustable problem, and the process is repeated. We summarize this approach in Algorithm 2.In the following, we present three heuristics to solve (ARI). Each is provided with a feasible starting solution, whose generation is explained at the end of this section.In our first approach, we generate a set of candidate patterns (corresponding to subsets of items assigned to the same stack). To this end, we consider an extended problem formulation for (ARI). LetCdenote all possible subsets C⊆I of items that are feasible with respect to the stacking constraints and the stack capacity b (i.e., these items can be assigned together to the same stack). We introduce a binary variable yCfor each such subset C to decide if subset C is used. For eachC∈C,letv(C)=maxw∈UIminπ∈P(C)v(π,w)be the worst-case payload violation of the set C (which can be determined using (AV1) and (AV2)).In the following,χjCindicates whether j ∈ I is contained in C withχjC=1if and only if j ∈ C, and zero otherwise. Then, we get the following equivalent formulation (ARI-PG) for (ARI) based on the concept of pattern generation:(67)(ARI-PG)min∑C∈Cv(C)yC(68)s.t.∑C∈CχjCyC=1∀j∈I(69)∑C∈CyC≤m(70)yC∈{0,1}∀C∈CConstraints (68) ensure that every item is contained in one pattern, and constraint (69) bounds the number of available patterns.As there are potentially exponentially many relevant setsC∈C,we use the following algorithm to solve (ARI-PG) heuristically. We keep a working set of patterns, which is initially filled with the patterns that are given by some feasible starting solution. In every iteration, we generate a setC′of subsets C⊆I at random, where the cardinality of each such subset C is chosen between 1 and b in a way that the expected cardinality equals n/m. These candidate patterns are made up of new, random patterns, by the working set of patterns, and by randomly merging patterns from the working set. Items that have once been part of the working set are never removed. Hence, we generate new patterns in the fashion of a genetic algorithm.We evaluate each subset using (AV1) and (AV2) iteratively to compute v(C). Then, we solve (ARI-PG) using the heuristic setC′instead of the full setC. Patterns of the resulting solution that are not part of the working set yet are added to it. We then begin with the next algorithm iteration by generating new patterns.Note that problems of type (ARI-PG) are easy to solve with current commercial MIP solvers (constraints (68) are special ordered set constraints, and constraint (69) is a single knapsack constraint), which means that a large number of sets C can be used in the heuristic with still small computation times. Thus, one can expect this approach to give better solutions than Algorithm 2 within the same amount of time; however, no quality bounds (or even a proof of optimality) are produced.In our second approach, we follow an iterative improvement local search heuristic. Given a feasible assignment of items to stacks, we consider the following two moves: An item is moved from one stack to another stack with sufficient capacity; or two items from two stacks are swapped. All feasible moves are evaluated in random order (again, by solving (AV1) and (AV2) iteratively) until an improving move is found, which is then performed. The process is repeated until either a local optimum or some time limit is reached.Finally, in our third heuristic, we follow a destroy-and-repair approach, which can also be considered as a variable neighborhood heuristic.Given a feasible assignment, we randomly select one stack with a high objective value and one stack with a low objective value. We then solve a problem of type (ARI) restricted to only these two stacks, i.e., we find a new, optimal assignment for these two stacks using the iterative procedure described in Algorithm 2. This process is repeated until a time limit is reached.To increase the number of iterations, we limit the time for a repair operation by stopping Algorithm 2 once a gap of 3 percent is reached or ten seconds have elapsed, whichever comes first. We also provide the solver with the current stack order as a starting solution.Note that the neighborhood this algorithm investigates is larger than for the local search, i.e., every move the local search evaluates is contained in the set of possible moves for this destroy-and-repair heuristic. However, every iteration is computationally more costly, as we do not only evaluate an assignment of items to two stacks, but also find a best possible assignment.To provide the heuristics from above with a feasible starting solution, one could simply solve the nominal problem. As this turns out to be too computationally difficult for large-scale problems, we present a different model where the payload violation is not considered.This model is inspired by network flows. Consider a directed graph, where there exists one node i for every item i ∈ I, and an arc (i, j) connecting i, j ∈ I iffsij=1. Every arc can carry an integer amount of flow between 0 and b. The topmost item within a stack receives b unit of flow, and in every subsequent node, loses one unit of flow. Every node needs to be provided with at least one unit of flow.We use variablesxij∈{0,…,b}to denote the flow along arc (i, j), binary variables zijto model if arc (i, j) carries any flow, and binary variables yito determine whether item i is the topmost item of a stack. The corresponding feasibility problem can be formulated as follows:(71)∑i∈Iyi≤m(72)∑j∈Isji=1xji−∑j∈Isij=1xij+byi≥1∀i∈I(73)xij≤bzij∀i,j∈I(74)∑j∈Isij=1zij≤1∀i∈I(75)∑j∈Isji=1zji≤1∀i∈I(76)xij∈{0,…,b}∀i,j∈I:sij=1(77)zij∈{0,1}∀i,j∈I:sij=1(78)yi∈{0,1}∀i∈IConstraints (71) ensure that at most m stacks can be used, while constraints (72) model the integer flow. Constraints (73) are used to determine whether an arc is used or not, while constraints (74) and (75) ensure that every node has at most one predecessor and at most one successor. Note that a solution found this way is feasible for (ARI), as only the payload violation is ignored, which is part of the objective.We solve this problem once using a MIP solver to provide any of the three heuristics from above with a feasible starting solution.To test the performance of the models and algorithms introduced in this paper, we performed four experiments with different sets of instances. The first three experiments use smaller instances with up to 30 items to compare exact and heuristic algorithms, and to analyze the impact of different parameters. The fourth experiment considers heuristic solutions for larger instances with up to 300 items.Recall that an uncertain stacking problem is parameterized by: The number of items n, the number of available stacks m, the maximum height of stacks b, and the payload violation parameter a. Additionally, a stacking matrix S is required as well as either an interval-based uncertaintyUIor a finite uncertainty setUF.We randomly generated stacking matrices S by using a density parameter d ∈ [0, 1], which is the relative number of ones within the non-diagonal elements of the matrix (i.e., ford=1,all items can be stacked onto each other, and ford=0.5,there aren(n−1)/2randomly distributed allowed pairings). Furthermore, we generated lower and upper boundswiandw¯ion item weights in the following way: There are two types of items, which both occur with the same probability. The first type of items haswi∈ [9, 10] andw¯i∈[10,11]; the second type of items haswi∈ [0, 10] andw¯i∈[10,20]. Thus, the expected average of lower and upper bound is 10 in both cases, but the variance is different. This reflects the case that items have on average a similar weight, but different variance. For finite uncertainty sets, we sample scenarios uniformly.For the three experiments, we modified problem parameters such that the first experiment considers few high stacks, and the second experiment considers many small stacks. The third experiment, which is described in the appendix, analyzes the impact of the payload parameter a.For each parameter choice, we generated 20 instances (all of them were noted to be feasible). For each instance, we solve:•The nominal model, where nominal weights are the midpoints of the respective intervals. We refer to this solution as “Nom”.The strictly robust model with finite uncertainty, sampling 10 and 20 scenarios; we denote these solutions as “S-10” and “S-20”, respectively.The strictly robust model with interval-based uncertainty using Algorithm 1. This is denoted as “SI”.The strictly robust model with interval-based uncertainty using the compact model. This is denoted as “SIC”.The adjustable model with finite uncertainty, sampling 5 and 10 scenarios; we denote these solutions as “A-5” and “A-10”, respectively.The adjustable model with interval-based uncertainty using the exact Algorithm 2. This is denoted as “AI”.The adjustable model with interval-based uncertainty, based on the formulation (ARI-PG), using the pattern generation heuristic with 1,000 candidate sets. We denote this heuristic solution as “AIPG”.The adjustable model with interval-based uncertainty using local search, which is denoted as “AILS”.The adjustable model with interval-based uncertainty using the destroy-and-repair heuristic, which is denoted as “AIDR”.We used CPLEX v.12.6 (IBM, 2013) to solve all MIPs. All experiments were conducted on a computer with a 16-core Intel Xeon E5-2670 processor, running at 2.60 gigahertz with 20 megabytes cache, and Ubuntu 12.04. Processes were pinned to one core. To restrict computation times, a time limit of 15 minutes was imposed on every solution approach.In this experiment, we fixa=1,d=0.5andm=3,and vary the number of items n from 9 to 30 in steps of 3. The stack height b is equal to n/3, that is, this experiment considers relatively few but high stacks.We present the median computation times (in seconds) in Table 1. Nominal solution times are very small, while the iterative approaches hit the time limit of 15 minutes already for small n. In particular, comparing SI and SIC shows that the compact model for strict robustness is considerably more efficient than the iterative approach, and needs only slightly longer computation times than the nominal model.Comparing S-10 with S-20 and A-5 with A-10, we note that already a small increase in scenarios results in a large increase in computation times.We now consider strict objective values, i.e., the worst-case payload violation when stacks cannot be adjusted. Note that strict objective values are not well-defined for adjustable solutions, as they do not specify a complete stacking in their first-stage. The average gaps for strict objective values are presented in Table 2, which are computed as(UB−LB)/UBusing the best-known lower bound on every instance (which is the objective value of SIC, as it solves all instances to optimality).Values are given as percentages; i.e., the nominal solution has an average gap of 12.39 percent on instances with sizen=30. Note that the iterative approach SI still produces solutions that are close to optimality. The increased number of scenarios for S-20 results in better solutions than for S-10, which is in turn better than the nominal solution. Note that even though the nominal solution takes comparatively little computational effort, it leads to large gaps in the worst-case, underlining the value of using a robust approach here.The average gaps for adjustable objective values are presented in Table 3. Adjustable objective values are given as the worst-case payload violation when only the assignment of items to stacks is fixed (i.e., it can also be computed for the nominal and strict solutions). As a lower bound, we used the largest lower bound produced by AI. Overall gaps are relatively small, and solutions tend to perform better with larger n. This is because m is kept constant, meaning that more items are assigned to the same number of stacks, which increases the chances to correct mistakes made in the assignment during the recovery step.The heuristics and AI perform best, but also SIC performs well. As for strict objective values, an increased number of scenarios for the sampling algorithms improves their performance.In this second experiment, we fixa=1,d=0.5andb=3,and vary the number of items n from 9 to 30 in steps of 3. The number of stacks m is equal to n/3, that is, this experiment considers relatively many but small stacks.We present the counterparts to Tables 1–3 as Tables 4–6.Note that computation times for the strict models increased compared to experiment 1. This is also reflected in the solution gaps. For strict objective values, gaps are considerably larger than before; in particular the iterative approach SI is not competitive anymore, while SIC still solves all instances to optimality in a short amount of time.Also the adjustable objective gaps increase, and show larger differences between the solution approaches than before. On these instances, the heuristic approaches tend to perform best; in particular AIPG outperforms all other algorithms. In this setting, SIC is not competitive anymore. The nominal solution performs poorly in both strict and adjustable objective values.We summarize the differences between the results of experiments 1 and 2 from a more general perspective. We note that for experiment 1, where few but large stacks are used, all solutions tend to perform relatively well for adjustable robustness. This is because there are more possibilities to rearrange items once the scenario becomes known, and the first-stage decision where to put items becomes less important.However, when many but smaller stacks are used as in experiment 2, adjustable objective values significantly differ between solution approaches, which shows the increased potential of using an adjustable approach.This is not the case for strict robustness, where we note that the nominal solution performs worse when there are few but high stacks, and better when there are many but low stacks.Thus, from a practical perspective, it depends on the instance which approach to follow makes most sense. For few and high stacks, the planner should be concerned about strict objective values, but is fine using a nominal solution if adjustments are possible. On the other hand, if there are many and low stacks, the nominal solution is fine if no recovery is possible, but more effort needs to be taken if adjustments are possible.In this experiment, we tested the performance of our heuristic algorithms on larger datasets. The considered instance sizes are given in Table 7, they were chosen such thatm·b=1.2n,i.e., there is always a spare capacity of 20 percent available. Other parameters were generated as described in Section 5.1.1, usingd=0.6anda=1.We use the heuristic methods AIPG, AILS and AIDR with a time limit of 15 minutes, and record their adjustable objective values. All heuristics are provided with a feasible starting solution by solving model (71)–(78), which is denoted as “Start”. To better evaluate their quality, a lower bound is computed for each instance by solving the nominal problem without stacking matrix constraints.Resulting average gaps for adjustable objective values are shown in Table 8, in the left columns.While AIPG showed the most promising performance for smaller instances, it tends to be outperformed by AILS and AIDR on larger instances. Note that the gap is relatively unaffected by the number of items n, but depends more on the stack size b. This is because all three heuristic methods need to evaluate stacks, and the required computation time to evaluate a single stack scales with b. Hence, the improvements the heuristics can make compared to the feasible starting solution are reduced with increased b within the time limit.Overall, gaps tend to decrease with larger b. This can be explained as in the comparison between experiments 1 and 2, where larger stacks indicate that the error made in the first decision stage tend to be less important.Note that the lower bound used for Table 8 is simple, and actual gaps can be assumed to be considerably smaller. To give a more detailed view on algorithm performance, we also present the average difference in percent to the best solution found on every instance in the right columns of Table 8.

@&#CONCLUSIONS@&#
We considered stacking problems with two kinds of constraints: The first is given by a general stacking matrix encoding which items can be stacked onto each other. This can be used to model practical requirements such as item departure times, or incompatible item dimensions. The second are payload constraints, which ensure that not more weight is stacked on top of an item than the stability of this item allows. However, as item weights are uncertain, we introduced robust stacking problems.Two robust models were tackled: One where the complete item stacking needs to be fixed in advance before item weights are known; and one where adjustments in the item order can be made afterwards. Finite and interval-based uncertainty sets were considered and different solution approaches presented. In an extensive computational study on randomly generated instances, the impact of the number of items, the payload violation parameter, and the stacking matrix were analyzed.We briefly review possible problem extensions in the following. Further uncertainty sets, such as interval-based uncertainty sets with additional restrictions may be considered. An example for such sets include the model of Bertsimas and Sim (see Bertsimas & Sim, 2004), where the total relative deviation of item weights from their nominal values is bounded by some parameter Γ. Using such an uncertainty set, Algorithms 1 and 2 are still applicable, with only slight differences in the computation of worst-case scenarios.Finally, the adjustable approach presented in this paper can be extended by considering restrictions on the rearrangements that are allowed once the scenario becomes known. This is similar to the idea of recoverable robustness (see, e.g., Liebchen, Lübbecke, Möhring, & Stiller, 2009). We count the number of operations which are necessary to rearrange a stack. As an example, for a single stack, possible recovery cost measurements between two solutions x, x′ include: The Hamming distance (i.e., the number of differently positioned items, given by∑i,l|xiql−xiql′|); or the number of items from top which have to be removed to transform x to x′ or vice versa. In both cases, the recoverable robust counterpart for a finite number of scenarios can be modeled as a mixed-integer linear program similar to (ARF).In the following we show in more detail how the stacking configuration of items in a stack should be to attain the lowest gravity center of the stack, and how the stack’s gravity center is influenced by the payload parameter a.Consider a single stack consisting of n items of positive weights stored from level 1 to level n. Assume that the items have a common height h > 0 and the weight of each item is uniformly distributed over the item’s volume. By this assumption, the gravity center of each item is exactly in the middle of the item. More precisely, if we start measuring the height from the ground (height 0) where all items are put on, then the height of the gravity center of the item stored at level i ishi:=(i−12)h(see Fig. 2). Let G be the gravity center of the whole stack.By “hard stacking constraints on weights” we mean that heavier items must be put below lighter ones. The following lemma shows how we should store the items with given weights in order to have the lowest position for G.Lemma 4Among all configurations of stacking items with given weights, a configuration satisfying the hard stacking constraints on weights has the lowest position of the gravity center G.Let wibe the weight of the item stored at level i. According to Halliday et al. (2014), Chapter 12, the height of G is computed by(A.1)hG=∑i=1nwihi∑i=1nwi.A global minimizer of the numerator is then to sort items non-increasingly according to weight.□We now assume that the weights of the items can vary, but always satisfy the payload constraints with a given payload parameter a > 0. This means that we always have(A.2)∑i=0k−1wn−i≤awn−k(k=1,…,n−1),where again the weight of the item stored at level i is denoted by wi. Denote byh¯Gthe height of the highest possible position of G. The behavior ofh¯Gwhen the value of payload parameter a varies is shown in the following lemma.Lemma 5h¯G(a)is a monotonically increasing function.Regarding (A.2), it follows from (A.1) that the highest possible gravity center of the set consisting of the two topmost items is attained whenwn=awn−1. Similarly, the highest possible gravity center of the set consisting of the three topmost items is attained whenwn=awn−1,wn+wn−1=awn−2.By induction on n we can deduce that the highest possible position of G is attained whenwn=awn−1,wn+wn−1+…+wn−k+1=awn−k∀k=2,…,n−1,or equivalently,wn−1=1awn,wn−k=(a+1)k−1akwn(k=2,…,n−1).Therefore, we get∑i=1nwi=((a+1)n−2an−1+…+a+1a2+1a+1)wn=Awn,whereA=(a+1)n−2an−1+…+a+1a2+1a+1.As we havea+1aA−A=(a+1)n−1an,it holds thatA=(a+1a)n−1.By applying the formula (A.1) we have(A.3)h¯G=∑i=1nwihi∑i=1nwi=∑i=1n(i−12)hwi∑i=1nwi=∑i=1nihwi∑i=1nwi−12h=∑i=1n−1ih(a+1)n−i−1an−iwn+nhwn(a+1a)n−1wn−12h=∑i=1n−1i1a(aa+1)ih+n(aa+1)n−1h−12h.If we setu:=aa+1,then 0 < u < 1 anda=u1−u. Moreover, we can rewrite (A.3) as follows:(A.4)h¯G=∑i=1n−1i1−uuuih+nun−1h−12h=∑i=1n−1i(1−u)ui−1h+nun−1h−12h=∑i=1n−1i(ui−1−ui)h+nun−1h−12h=(12+∑i=1n−1ui)h.It is an immediate consequence of (A.4) thath¯Gis monotonically increasing with respect to u. Obviously,u=aa+1=1−1a+1is monotonically increasing with respect to a. It follows thath¯G(a)is a monotonically increasing function.□As a consequence of Lemma 5, the smaller the value of a is, the lowerh¯Gis, i.e., the more stable the stack is. Moreover, given a desired position for G, we can compute the payload parameter a corresponding to that position, and then use that value of a for controlling the stability of the stack during the loading process.In the following we present a compact formulation for (SRI) when 1 < a ≤ 2. This contains formulation (27)–(38) for a < 1, which is extended by new variableswqlk1,k2,k3representing the weight of the item in stack q at level l when there is a break at positions k1 and k3, as well as a light item atop a heavy item in level k2. Additionally, variablesvqlk1,k2,k3are used to measure the payload violation in this scenario. We denote L* ≔ {(k1, k2, k3) ∈ (L∖{b}) × (L∖{b}) × (L∖{b}): k1 < k2 < k3}.(B.1)min∑q∈Qvq(B.2)s.t.∑q∈Q∑l∈Lxiql=1∀i∈I(B.3)∑i∈Ixiql≤1∀q∈Q,l∈L(B.4)∑j∈I∖{i}sijxjq,l−1≥xiql∀i∈I,q∈Q,l∈L∖{1}(B.5)wqlk={∑i∈Iw̲ixiqlifl≤k∑i∈Iw¯ixiqlifk<l∀q∈Q,l∈L,k∈L∖{b}(B.6)wqlk1,k2,k3={∑i∈Iw̲ixiqlifl≤k1∑i∈Iw¯ixiqlifk1<l≤k2∑i∈Iw̲ixiqlifk2<l≤k3∑i∈Iw¯ixiqlifk3<l∀q∈Q,l∈L,(k1,k2,k3)∈L*(B.7)∑h>lwqhk−awqlk≤vqlk∀q∈Q,k,l∈L∖{b}(B.8)∑h>lwqhk1,k2,k3−awqlk1,k2,k3≤vqlk1,k2,k3∀q∈Q,l∈L,(k1,k2,k3)∈L*(B.9)∑l∈L∖{b}vqlk≤vq∀q∈Q,k∈L∖{b}(B.10)∑l∈L∖{b}vqlk1,k2,k3≤vq∀q∈Q,(k1,k2,k3)∈L*(B.11)xiql∈{0,1}∀i∈I,q∈Q,l∈L(B.12)vqlk≥0∀q∈Q,l,k∈L∖{b}(B.13)vqlk1,k2,k3≥0∀q∈Q,l,(k1,k2,k3)∈L*(B.14)wqlk≥0∀q∈Q,l∈L,k∈L∖{b}(B.15)wqlk1,k2,k3≥0∀q∈Q,l∈L,(k1,k2,k3)∈L*(B.16)v≥0The adjustable models in this paper have been concerned with the setting that every item is assigned to a specific stack in the first stage. Here we show that this can be extended to assigning items to subsets of stacks in the first stage instead.Let the set of stacksQ={1,…,m}be partitioned into subsetsQ1,…,QRsuch that an item assigned to the subset Qrmay be assigned to any position in any stack q ∈ Qrin the second stage, but not to any stack outside of Qr. We writeR={1,…,R}.(C.1)(ARF-Sub)minv(C.2)s.t.∑r∈Rzir=1∀i∈I(C.3)∑i∈Izir≤|Qr|b∀r∈R(C.4)∑q∈Qr∑l∈Lxiqlk=zir∀i∈I,k∈N,r∈R(C.5)∑i∈Ixiqlk≤1∀q∈Q,l∈L,k∈N(C.6)∑j∈I∖{i}sijxjq,l−1k≥xiqlk∀i∈I,q∈Q,l∈L∖{1}(C.7)∑j∈I∑h=l+1bwjkxjqhk−a∑i∈Iwikxiqlk≤vqlk∀q∈Q,l∈L∖{b},k∈N(C.8)∑q∈Q∑l∈L∖{b}vqlk≤v∀k∈N(C.9)zir∈{0,1}∀i∈I,r∈R(C.10)xiqlk∈{0,1}∀i∈I,q∈Q,l∈L,k∈N(C.11)vqlk≥0∀q∈Q,l∈L∖{b},k∈N(C.12)v≥0In constraints (C.2) we enforce that every item needs to be assigned to exactly one subset of stacks, while constraints (C.3) restrict the number of items assigned to every subset according to its capacity. This assignment is connected to the second-stage variables xkvia constraints (C.4), which ensure that one level in one of the appropriate stacks needs to be used for every item. The remaining constraints are the same as in (ARF): A level can only be used once, stacking matrix constraints need to be respected, and the worst-case payload violation is modeled.We now consider the impact of different values for the payload violation parameter a. We choosea=0.5toa=1.5with a stepsize of 0.1. Other parameters are fixed ton=24,m=4,b=6,d=0.5. Results are presented in Tables 9–13.Note that computation times, presented in Table 9, are not monotone in a; instead, problems with a being in the vicinity of 1 tend to take longer to solve for algorithms using a fixed number of sampled scenarios. Hence, it may be helpful to slightly change the value of parameter a if computation times are too high for a practical instance.Considering the strict objective values (Table 10), we note the gap to be roughly monotonically increasing with a for Nom, S-10 and S-20; for SI, there is a disproportional increase in gap for a ≥ 1. Absolute objective values are smaller for increasing a, which may also add to an increased algorithm gap.We show the adjustable objective value gaps in Table 11. Note that overall gaps tend to be smaller than for strict robustness, which is in agreement with the observations made in Section 5.1.4. The heuristic algorithms perform best, in particular AIDR is slightly outperforming AIPG and AILS. As with strict objective values, gaps tend to increase with a.In Tables 12 and 13, we investigate the sensitivity of solutions regarding the parameter a. In Table 12, we evaluate solutions calculated for varying values of a as if they were solutions toa=0.5,and toa=1.5in Table 13. We find that those solutions that have the smallest gap in Table 11 (i.e., AI, AIPG, AILS and AIDR), tend to be most sensitive to changes in a; however, they still outperform the other algorithms. Overall, gaps remain small, which means that solutions are relatively robust to changes in or wrong estimates of the parameter a. This also aligns well with the suggestion to slightly change parameter a when computation times are too high.