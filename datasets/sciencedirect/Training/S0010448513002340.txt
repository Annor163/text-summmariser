@&#MAIN-TITLE@&#
Defining tools to address over-constrained geometric problems in Computer Aided Design

@&#HIGHLIGHTS@&#
Support for analyzing over-constraint sketches in CAD.Use of non-cartesian geometric modeling.Tool for decision making in constraint choice.Methodology to solve over-constraint problems.Possible application in collaborative environment.

@&#KEYPHRASES@&#
Geometric modeling,Non-cartesian,Over-constrained,Geometric constraints,GCSP,Specification,

@&#ABSTRACT@&#
This paper proposes a new tool for decision support to address geometric over-constrained problems in Computer Aided Design (CAD). It concerns the declarative modeling of geometrical problems. The core of the coordinate free solver used to solve the Geometric Constraint Satisfaction Problem (GCSP) was developed previously by the authors. This research proposes a methodology based on Michelucci’s witness method to determine whether the structure of the problem is over-constrained. In this case, the authors propose a tool for assisting the designer in solving the over-constrained problem by ensuring the consistency of the specifications. An application of the methodology and tool is presented in an academic example.(34)[2.52.15781.854−2.5−2.1578−1.854000000000000⋯0000−2.3454−2.3−1.71162.34542.31.7116000000000⋯0000−2.3568−2.0017−1.96670002.35682.00171.9667000000⋯0−1.1957−1.3623−1.35750000000001.19571.36231.3575000⋯0000000−1.6612−1.3705−1.72220001.66121.37051.7222000⋯0000000000−2.0754−2.1397−1.72892.07542.13971.7289000⋯00000000000002.17981.49241.6768−2.1798−1.4924−1.6768⋯00000000000002.43442.2711.7365000⋯00000000000002.45582.00121.9071000⋯−1.9071000−1.9762−2.0172−1.741000000000000⋯1.741000−1.7689−1.6297−1.7538000000000000⋯0000−1.159−1.5984−1.10540000000001.1591.59841.1054⋯0000000000000000−0.415690.41832−0.47819⋯0000000000000000−1.389−0.53979−1.0454⋯1.0454000000000000000000⋯0.548240000000.670111.19410.060784−0.67011−1.1941−0.060784000000⋯00.987180.120510.80576000−0.98718−0.12051−0.80576000000000⋯01.7541.58320.83324000000−1.754−1.5832−0.83324000000⋯0](35)[①0000000000−0.5430900000−0.638360−0.87313⋯0.9040①0000000001.5846000000.7454401.8806⋯−1.30900①00000000−1.1119000000.428800⋯−1.2757000①00000000000002.069404.8563⋯−2.6990000①000000000000−1.14080−4.7575⋯−0.8226900000①00000000000−1.027100⋯3.0168000000①0000−2.084100000−0.876940−0.7622⋯1.7860000000①0001.5431000000.5398300.97193⋯−1.408900000000①000.78228000000.7518500⋯−2.3414000000000①00.84097000000.3254500.67516⋯−0.82870000000000①−0.007652900000−0.09664900.16532⋯−0.060778000000000000①0000−1.58950−3.1882⋯1.89210000000000000①0000.7022203.9125⋯0.5063900000000000000①001.309900⋯−3.9679000000000000000①00.8634300.66885⋯−0.672730000000000000000①−0.285110−1.7211⋯−0.2056000000000000000000①1.3945⋯−0.4658200000000000000000000⋯0]

@&#INTRODUCTION@&#
In Computer Aided Design (CAD), the model is the computer representation of the object being designed. This geometric model is often named the Digital Mock-Up (DMU) and is now the core of CAD systems. In this study, the geometric model is the reference model.There are essentially two strategies for building a digital mock-up in CAD systems: the procedural approach and the declarative approach  [1]. This paper focuses on declarative approaches because they are often used in the 2D sketcher and 3D assembly workbenches of CAD systems  [2] and because the authors have already worked on them in  [3–6]. The declarative approach assumes that the designer first specifies a list of generic geometric objects and, second, a list of constraints between the objects defined previously. Then, a software application is used to solve all these constraints and build the virtual object. In order to obtain a valid object, it is necessary to ensure that all the specifications (generic objects and constraints) given by the user are consistent.Moreover, the DMU is used in many simulations that cause the geometry to evolve due to changes made to the specifications required by the design team. It is therefore very important to maintain consistency in the statement of the problem. In general, problems that present inconsistencies are of two types: under-constrained problems and over-constrained problems. In this paper, we focus on over-constrained problems.At present, when a designer comes across an over-constrained problem, no plans are available (at best a message is displayed on the screen). They must unravel it alone. Maintaining the consistency of the digital mock-up is even harder when several designers are involved in the design process. In this paper the authors propose to generate relations between the parameters of specifications in view to guiding users to ensure the consistency of the sets of parameters used. Therefore this paper will describe how to provide users with the elements necessary for maintaining the consistency of the geometry created. How is it possible to help designers to clearly specify their geometry? In the framework of collaboration, if a geometric problem is over-constrained, who arbitrates between the values of different specifications? This paper presents a solution for managing over-constrained geometric problems by giving users a tool for generating consistent sets of specifications.The authors have already developed a conceptual model based on vectorizing the geometry for generic geometric objects. The associated solving strategy uses a coordinate-free representation. The major advantage of this approach is that it is unnecessary to take the cartesian reference frame into account for solving purposes. In 3D space, a geometric object is characterized by a Gram matrix that is positive semidefinite and has rank 3. Some elements of this matrix must have specific values imposed by the user, the others are unknowns. The geometric problem is solved by obtaining a Gram matrixHthat meets the above conditions. This entails a matrix completion problem  [7,8]. Indeed, in order to complete a partial matrix it is necessary to make specific choices of values for the unspecified entries.The solution proposed by us is to find a transformationTthat changes an initial object into a final object. TheGGram matrix characterizes the initial object.HGram matrix characterizes the final object and is defined by the fundamental relationship (1), as explained in greater detail in  [9]:(1)H=TGTt.More specifically, in our study,T=(I+CX), whereCis the topological connection matrix,Xthe vertex perturbation matrix andIthe Identity.The authors make use of their previous work to address the problem of consistency. The proposed methodology and tool are applied to a case study shown in Fig. 1. It is a 3D bar structure called “double banana”. The lengths of the 18 bars are specified, it can be seen that this system is not rigid because each banana can rotate about the axis defined by the two end pointsAandBconnecting them.We begin in Section  2 by giving a series of tools used to describe the geometric problem. Section  3 describes the coordinate free formulation applied to this GCSP22Geometric Constraint Satisfaction Problem.and presents the solving method. In Section  4, a method for analyzing whether the geometric problem is overconstrained or not, is described. Following this, if the problem is declared over-constrained, we propose a method for assisting a design team to seek a consistent set of constraints. Finally, Section  5 uses the example of the double banana to illustrate the application of this methodology.RemarkThe Einstein notation or Einstein summation convention is employed in this paper. This notation implies the summation over a set of indexed terms in a formula, thus achieving notational brevity.This section presents a non-cartesian model that characterizes geometric objects. We recall here the basics of the method as described in  [5]. The characteristic of this approach is that it is unnecessary to perform cartesian reference frame, which is a real benefit for the sketching tasks of CAD designers. The principle is that any geometry can be represented as points and vectors. These are the central elements of our modeling. In the following, we describe three models that fully describe the design geometry.The geometry is reduced to a skeleton composed of points and line segments. An incidence matrixC, establishes the relation between each point of an object and its edges. It is ann×mmatrix, wherenandmare the number of edges and vertices respectively, such thatCij=−1if the edgeeileaves vertexpj, 1 if it enters vertexpjand 0 otherwise. Fig. 2gives an example of an incidence matrix. Edges are oriented arbitrarily.The geometrical object is closely related to the topological model. Indeed, a vector is associated with each edge. Therefore each vector is an oriented bipoint. Thus the geometrical model is represented by a list of vectors.GivenVa set ofnnon-normed vectors asV=(v1,v2,…,vn). The Gram matrix is the mathematical tool used to represent this vectorial model. ThusG(V)is defined by:Gij(V)=〈vi,vj〉where〈vi,vj〉is the scalar product between vectorsviandvj. This matrix is also notedGin the following.The Gram matrix of a set of vectors is constructed for each representation of a sketch. This Gram matrix fully defines the metrics of the object. It should be noted that this modeling is independent of the Cartesian coordinate system since all the vectors are defined in relation to one another: the vectors are not represented by their Cartesian coordinates but by their relative scalar products. An advantage of this approach is the possibility of ensuring specification consistency by verifying the mathematical properties of the Gram matrix (symmetrical, positive-semidefinite, rank, etc.). For example, by calculating specific determinants, it is possible to know whether or not there is a solution to the problem (see  [10]).For our purpose, it is assumed that a geometric problem is defined by a skeleton, totally defined by the topological and geometrical models, and by a list of geometric constraints. In this study, we only focus on the length of the vectors, calledL, or the angle between two vectors calledα. All the specifications are stocked inS. It is a partially filled Gram matrix.ElementSiiis known if the user chooses a specific length forvi, as presented in Eq. (2).(2)Li=Sii.ElementSijis defined if the user specifies the angle betweenviandvj. Thus,(3)cos(αij)=SijSiiSjj.These three models fully characterize the GCSP.The previous section presented the geometric model based on a vectorial representation of the geometric entities and constraints. We now present the approach developed, based on the transformation of the initial geometry and using a perturbation matrix (see Eq. (1)). This method is particularly appropriate for CAD as the users always start by “drawing” an initial shape that is gradually modified to obtain the desired object.To illustrate this method, let us take the trivial object presented in Fig. 3. For example,v1hasp1as origin andp4as end vertex. TheG(V)matrix defines the initial object whereasG(V′)characterizes the final object. As theCincidence matrix forms the relation between each point of the object and vectors, we express the edge relation for the initial object in (4).(4)vi=Cijpj.The edge relation for the final object is found in (5).(5)vi′=Cijpj′.It should be noted that the two objects are represented by the same connection matrixCbecause the topology is invariant during the transformation, The variationpi′−picorresponds to the vertex displacement. Herepiandpi′are vectors which are the positions of the vertexibefore and after transformation. IfVis a set of vectors andV′a set of vectors obtained after a transformation from an initial state to a final one, we express the relation between these two states. We define the vertex variation by (6):(6)pi′−pi=Xijvj.Xijare elements of matrixX, which is called the perturbation matrix from the initial state of the geometry to the final one. It is ann×mmatrix. The last three Eqs. (4)–(6), make it possible to obtain the relation between the initial vectors and the final one in (9) using formulas (7) and (8). Here,δikrepresents the Kronecker symbol which equals 1 ifi=kand, 0 otherwise.(7)vi′=Cij(Xjkvk+pj)(8)vi′=vi+CijXjkvk(9)vi′=(δik+CijXjk)vk.The aim is to obtain the transformation of an object from its initial shape to its final one. The Gram matrixH=G(V′)characterizes the final object. Indeed,(10)Hij=〈vi′,vj′〉(11)Hij=〈(δip+CikXkp)vp,(δjq+CjkXkq)vq〉(12)Hij=(δip+CikXkp)(δjq+CjkXkq)〈vp,vq〉(13)Hij=(δip+CikXkp)(δjq+CjkXkq)Gpq.This expression written in matrix form is:(14)H=(I+CX)G(I+CX)t.NoteTthe vectorial transformationI+CX. Due to the rank property:rank(H)≤min(rank(T),rank(G))His a matrix of rankr. Formula (14) above represents the variation of the geometric object. The elements of the perturbation matrixXare the unknowns of the problem. So far, the Gram matrixGhas only been used to characterize the position and orientation of all the vectors of the initial sketch. Numerically, this matrix is totally known.The geometric constraints specified by the user lead to a set of equations that are presented in the following section. Here we itemize only two types of specifications (useful as examples) but many other specifications have been developed by the authors. The reader may refer to [5,11] for more details.By definition, an element of diagonal matrixGii(Hiifor the final one) represents the squared length of an initial vector (final resp.). The length specification of vectorviimposed by the designer is denotedLi. Thus:(15)Hii=Li.Given that each final matrix element is expressed as Eq. (13), and by developing this latter expression to the 1st order, we obtain (16):(16)Hij≅Gij+(CikXkp)Gpj+Gip(CjkXkp).In particular, for the formula of the diagonal elements (17) can be used.(17)Hii≅Gii+2(CikXkp)Gpi.And by developing Eq. (15), it becomes Eq. (18). This equation is a set of linear equations in the unknownsXkp.(18)1Gii(CikXkp)Gpi≅Li−Gii.TermsLi,Gpi,CikandGiiare known. The unknowns of this equation are elements ofX.By definition, elementGijrepresents the scalar product between vectorsviandvj. The designer requires the cosine of the angle between vectorviandvjto satisfy specificationαij, resulting in the Eq. (19) below:(19)Hij=HiiHjjcosαij.Rewriting Eq. (19) to move all the terms ofHto the left of the equal sign gives:(20)Hij(Hii)−1/2(Hjj)−1/2=cosαij.By developingHij,HiiandHjjusing Eq. (16) and by linearization to the 1st order, the expression of an angular specification is expressed as follows:(21)(Gip−GijGjjGpj)CjkXkp+(Gpj−GijGiiGpi)CikXkp≅GiiGjjcosαij−Gij.TermsGip,Gpj,Gii,Gij,Gjj,Cjk,Cikandcos(αij)are known. The unknowns are elements ofX. Eq. (21) is a set of linear equations in the unknownsXkp.In this section, we do not attempt to describe in detail the method used to solve the equations for the isoconstrained problem. This study was carried out by Moinet in  [11] for a different set of equations but it remains well-adapted to the problem presented in this paper. The geometrical solver developed with Matlab®  computes theXperturbation matrix of Eq. (14) in order to obtain an object that conforms to the specifications given by the designers. The system to be solved consists of non-linear relations (15) and (19). The known terms are the elements of the initial Gram matrixG, line–line angle specificationsαij, and length specificationsLi. For solving purposes, the equations generated by the above mentioned solver are linearized to the 1st order. Then it is necessary to find the elements of perturbation matrixXijto solve the problem. The most frequently used method to solve this kind of system,F(X)=0, is the Newton–Raphson method. However, the algorithm implemented is a variation of the Newton–Raphson method that has been described in  [5]. Then Eqs. (18) and (21), as presented in the previous paragraph, can be rewritten and stored in the linear form presented in (22).(22)Ax=b.In this equation, all the unknown elements from matrixXare stored in the column vector notedx. The elements of matrixAand the second memberb(a column vector) are computed fromS,GandC. Note that there are as many elements inbas the number of specifications given by the user. Indeed, these elements are extracted from matrixS−G(i)at each stepi. In this case,Sis the specification given by the designer, whereasG(i)is the Gram matrix at stepi. The initial value,G(0)=G, is given by the measure of the geometric parameter in the initial sketch. Then, the solving method can be summed up as in Algorithm 1:This algorithm converges if the GCSP is underconstrained, isoconstrained or overconstrained with consistent specifications. Therefore in the next section the authors present a method that always ensures consistency of the GCSP.An application of this algorithm is presented in Section  5.When, for generic values of the GCSP, the number of solutions is finite and nonzero (resp. zero, infinity), the problem is said to be well- (resp. over-, under-) constrained.Here, we only focus on the overconstrained problem and propose using the witness method of Michelucci et al.  [12–14] to perform the problem analysis. The first part of this section will briefly introduce Michelucci’s witness method. In the second part, we explain how to generate a useful witness using a coordinate free formulation for the geometric constraint solving problem. Then, the third part introduces the proposed method to analyze the chosen witness using the Rouché–Fontené theorem. The fourth part proposes a method to handle over-constrained problems.Michelucci’s witness method proposes studying the generic properties of a collection of objects by studying one of them that is called a “witness”. Up to now this method has always been used in the context of constraints formulated in a Cartesian framework. In addition, the literature states that if there is a sketch with the same properties as the solution sought (coincidence, collinearity, coplanarity, etc.) then this is generally a witness. In the framework of this research, it is always assumed that the user has drawn such a sketch to describe a problem of geometrical constraints. This is why this method seems well-adapted to this task. It should be noted that the witness method has never been applied with non-Cartesian formulations. The authors therefore felt it pertinent to demonstrate that this method can be applied in this case.Sometimes the sketch proposed by a designer is not totally representative of the shape of the desired solution. This occurs when certain geometric elements are drawn with specific properties (collinearity, coplanarities, etc.) without representing a real constraint. In this case the sketch cannot be used as a witness. This situation occurs when the sketch is not generic. A sketch is considered generic when it remains rigid before and after an infinitesimal perturbation. Likewise if the sketch was not rigid before the perturbation and continues not being rigid after it. Details on rigidity and generic frameworks can be found in  [15]. This situation is illustrated in Fig. 4. The rigid sketch (Fig. 4(a)) is not generic: a small perturbation on the dimensions of the bars will result in a non rigid sketch like that shown in Fig. 4(b). On the other hand the sketch in Fig. 4(b) is generic: if a small perturbation is introduced in the dimension of this sketch, it will remain non rigid. Usually, non generic sketches are constituted with line segments that are aligned as presented in Fig. 4(a). In the representation chosen (based on Gram matrix) for this paper, the vectors representing these line segments are collinear or coplanar. The collinearity of the vectors will lead to an artificial redundancy between the constraints associated with the collinear vectors. Consequently, before using the witness method with a coordinate free formulation of the GCSP, it is necessary to ensure that the sketch used as witness is generic. In order to ensure that the sketch is generic, the authors have used a naive technique that consists of the algorithm presented in Fig. 5. This algorithm has four steps:1.The system of equations modeling the GCSP is based on the user’s sketch. The rank of this system is calculated.The starting point is a random perturbation of the sketch. Then a second linearized system is generated and its rank calculated.If the rank of the second system is higher than that of the first, the first sketch is replaced by the second and the second step is reiterated.Otherwise the first sketch is considered generic.Once the witness has been generated, it can be analyzed. In the second case of an over-constrained problem, the purpose of this analysis is to determine which constraints are redundant. Overconstrained problems that are locally underconstrained do not disturb the proposed methodology of this article. For example, system (23) holds this characteristic. Furthermore, the analysis proposed by the authors also permits determining, for each redundant constraint, the relation that links this constraint to those that are independent. The main steps of the method proposed are presented in Fig. 6. In this paragraph we assume that the system of equations is written in linear form:Ax=b(cf. Section  3.3). It should be noted that matrixAhas the dimensiond×nm. We also assume that this system is composed ofrindependent constraints (the matrixAhas rankr). As the GCSP is overconstrained, it is additionally assumed thatd>randnm≥r.To find the redundant constraints, the authors propose using the Gauss elimination method  [17] to obtain a triangular form of the matrixA. This triangular form is used to identify the redundant constraints by searching the lines that contain only 0. These redundant constraints are withdrawn from the problem. The independent specifications are stored inS̃, a partially filled Gram matrix. Comment: if a column of the matrix does not contain an elimination value, this means that the value of the unknown associated with this column can be fixed freely.(23){x1+x4=b1x2+x4=b2x3+x4=b3x1+x2+2x4=b4x2+x3+2x4=b5x5=b6x6=b7x5+x6=b8.For example, the system (23) can be represented by the matrix shown in Fig. 7(a). This matrix can be given a triangular form in Fig. 7(c) by using the circled values and by performing the sequence of operations indicated in Fig. 7(b) on its lines: Using this example, we can conclude that Eqs. (4), (5) and (8) are redundant. We can also conclude that the 4th unknown can be chosen freely since the fourth column of the matrix (Fig. 7(c)) does not contain a Gauss value.If the systemAx=bis over-constrained the Rouché–Fontené theorem  [17,18] indicates that for a solution to exist, the second memberbmust conform tod−rconditions. In the following, these conditions will be called equations of compatibility. It is always possible to rewrite the system without loss of generality so that the firstrlines and the firstrcolumns are independent. This amounts, on the one hand, to writing the redundant constraints on the last lines, and on the other hand, to rewriting the unknowns that can be fixed freely at the end (which corresponds to the last columns of the matrix). Thus the systemAx=bwill take the form presented in Eq. (26). Then, the expression of each compatibility equation is given byhq=0. The expression ofhqis given in Eq. (27) withq∈{1,…,d−r}.(26)[A11⋯A1rA1r+1⋯A1nm⋮⋱⋮⋮⋱⋮Ar1⋯ArrArr+1⋯ArnmAr+11⋯Ar+1rAr+1r+1⋯Ar+1nm⋮⋱⋮⋮⋱⋮Ad1⋯AdrAdr+1⋯Adnm]×[x1⋮xrxr+1⋮xnm]=[b1⋮brbr+1⋮bd](27)hq=|b1A11⋯A1r⋮⋮⋱⋮brAr1⋯Arrbr+qAr+q1⋯Ar+qr|=0.It is important to note that in Eq. (27) variablesAijhave known numerical values. On the contrary, the objective of this calculation is to obtain a linear relation that links variablesbiin the form presented in Eq. (28).(28)hq=∑i∈{1,…,r,r+q}γqibi.To explain this relation it is possible to expand the determinant of Eq. (27) by the first column. We therefore obtain the value of the coefficientsγqiby the formula (29).(29)γqi={(−1)i+1|A11⋯A1r⋮⋱⋮Ai−11⋯Ai−1rAi+11⋯Ai+1r⋮⋱⋮Ar1⋯ArrAr+q1⋯Ar+qr|ifi∈{1,…,r,r+q},0otherwise.In the case where the problem is over-constrained, i.e. there is no solution that conforms to all the specificationsS, the authors propose a method to help designers to find all the consistent specification values bringing them close to the initial expectations. The idea is to use the compatibility equations to change the independent specifications so that the redundant specifications draw close to the value desired. To do this the authors propose searching a set of new specifications stored in the Gram matrixS′. The specification values must conform to the compatibility equation  (30):(30)Γt=0.We definet, the vector of size(d×1)equal to thedelements extracted from the column vector formed by stacking the lines of(S′−H). The expression of termsγqiof matrixΓis given by Eq. (29). In a general way, we note that matrixΓhas size(d−r)×d. In most engineering cases, the number of compatibility equations is much lower than the number of independent specifications(d−r<r). Whend−r≥rthe designers must have imposed a very high number of redundant constraints(d≥2r). In this specific but improbable case, the designers would be asked to reformulate their problem. Furthermore, in the general case whered−r<r, matrixΓwill have rankd−rsince the compatibility equations are independent by construction. Consequently, by using system (30) it is possible to calculated−rvalues oftiamongd. If, without loss of generality, the columns of matrixΓare re-ordered so that its firstd−rcolumns are independent, system (30) can be written in the form (31) and (32) by introducing two matricesΓ1(of size(d−r)×(d−r)) andΓ2(of size(d−r)×r). In this form matrixΓ1is invertible and we can calculate the valuest1totd−rusing the formula (33).(31)[γ11⋯γ1d−r⋮⋱⋮γd−r1⋯γd−rd−r]×[t1⋮td−r]+[γ1d−r+1⋯γ1d⋮⋱⋮γd−rd−r+1⋯γd−rd]×[td−r+1⋮td]=0(32)Γ1×[t1⋮td−r]+Γ2×[td−r+1⋮td]=0(33)[t1⋮td−r]=−Γ1−1Γ2×[td−r+1⋮td].Now the above has been presented, the problem remaining to be solved is to partitiontso that theΓ1matrix is full rank.The technique presented in Section  4.3.1 allows for determining the redundant constraints. It also provides a set of independent target specifications. However, in an engineering context, the designer may want to conserve the initial value for the redundant specification detected by the Gauss elimination method. In this case, it is necessary to find another partition for the target specifications. The following proposition does not claim to solve the problem of partitioning the set of specification parameters. The two ideas raised here are more the paths to be followed to give a clear framework for designers to choose a partition ofti. Firstly, the designers may wish to assign priorities or importances to specifications: the solution must meet the important specifications as precisely as possible, whereas the accuracy for other specifications can be lower. In this case it is advisable to place the important specifications in subassembly(td−r+1,…,td)and the less important specifications in subassembly(t1,…,td−r)which will be calculated using relation (33). Secondly, it could also be interesting to follow paths suggested in research works on robust design such as  [19]. This study indicates criteria to help designers to divide their specifications into two parts to minimize the variation of values(t1,…,td−r)that are calculated from(td−r+1,…,td)which is also our aim. Whatever the case, once the designers have chosen a partition, it is advisable that matrixΓ1is invertible.

@&#CONCLUSIONS@&#
