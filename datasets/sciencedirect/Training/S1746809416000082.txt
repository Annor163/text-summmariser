@&#MAIN-TITLE@&#
FPGA-based communication interface for persons with motor neuron diseases

@&#HIGHLIGHTS@&#
The usage of MEMS accelerometers have been proposed as muscles activity sensors for disabled peoples.A complete assistive tool prototype, based on FPGA chip, has been presented.The tool can be used either as an input switch for virtual keyboards or as a stand-alone tool.As a stand-alone tool, the communication interface allows disabled persons to write a text by means of the Morse code.To eliminate the necessity of dealing with unstable Morse code, the usage of two sensors has been proposed.Four different FPGA implementation methods of a digital signal processing algorithm, namely: manual HDL coding, usage of the Matlab HDL coder, Xilinx Vivado HLS and embedded soft-microcontroller, have been investigated and compared.

@&#KEYPHRASES@&#


@&#ABSTRACT@&#
This paper focuses on the architecture and FPGA implementation aspects of a kind of assistive tool for disabled persons with motor neuron diseases, specifically with muscle atrophy. The tool, called a communication interface, allows such persons to communicate with other people by means of moving selected muscles, e.g., within the face. The application of MEMS accelerometers have been proposed as muscle movement sensors. Four different FPGA implementation methods of signal processing from MEMS sensors, i.e., manual HDL coding, usage of the Matlab HDL coder and Vivado HLS as well as embedded microcontroller exploitation, have been investigated. The communication interface can be used either as an input switch for, so called, virtual keyboards or as a stand-alone tool, which allows disabled persons to write a text by means of the Morse code.

@&#INTRODUCTION@&#
The basic human inter-communication method is speech. However, for some people with motor neuron diseases (NMDs) this is impossible. The NMDs are a group of progressive neurological disorders, such as amyotrophic lateral sclerosis (ALS), spinal muscular atrophy (SMA) or bulbospinal muscular atrophy (Kennedy syndrome) [1]. These diseases cause the destruction of cells which control essential muscle activities. Therefore, some people with NMDs are not only unable to speak or walk but they have limited movement of merely a few selected muscles, e.g., cheeks, brows or eyes. For such people, having any tool which allows them for even a limited communication with the surrounding world is of much help.There are a number of assistive tools developed for disabled persons, supporting their interaction with the environment. In general, these tools take an input from the user (only two distinguishable states, somehow generated by the user, are sufficient here) and allow them to write a text by means of the Morse code or a kind of virtual keyboard. As an input method, a single mechanical button can be used [2] (only for persons able to operate it) or specific sensors analyzing selected muscle activity [3,4] or working with electro-oculography (EOG) [5,6] and electromyography (EMG) [7] signals have been proposed. Another widely used and commercially available method includes eye movement tracking [8,9]. Apart from video-based systems, the eye movement recognition solutions using electroencephalography (EEG) signals [10] are reported. A specific classification algorithm for the communication systems based on the EEG signals has been proposed as well [11]. There are also research activities regarding the usage of brain-controlled interfaces (BCIs). Yet it seems that BCIs are currently still less consistent than other input methods [4].A virtual keyboard, as an assistive tool, dedicated to disabled persons is a software keyboard displayed on the computer screen. A cursor successively scans across this keyboard by row or by column. To stop the cursor and select the character, dedicated signal must occur (e.g., cheek muscle or eye movement must be detected). Virtual keyboard software is usually equipped with a word prediction algorithm, which allows the user to write only the first couple of characters before the whole word can be selected. These kinds of keyboards are also commercially available, e.g., [12].Other tools for disabled persons, allowing them to write a text, exploit the Morse code [5,13]. However, the code entered by individuals with physical limitations are often very unstable—it is hard to hold stable time intervals related to Morse code tone ratio (dot/dash) or silent ratio (character-space/dot-space). Therefore, several algorithms for the recognition of unstable Morse code have been developed, e.g., [13,14].In this paper, the proposal of a new communication interface for persons with physical limitations is introduced. The interface can be exploited either as an input switch for virtual keyboards or as a stand-alone tool, which allows disabled persons to write a text by means of the Morse code. Instead of a piezoelectric sensor [3], infra-red sensor [4] or other sensors used so far, a MEMS acceleration sensor has been applied. The MEMS sensor should be attached to the selected muscle, i.e., cheek or brow muscle, whose movement constitutes input information entered by a user. In order to eliminate the necessity of dealing with unstable Morse code, two sensors attached to the left and to the right cheek (or brow) muscle have been proposed. An active signal from the left sensor can then be interpreted e.g., as a Morse code dash symbol, whereas a signal from the right sensor might be treated as a dot symbol. This solution, however, applies to peoples who are able to operate two independent sensors.As a hardware platform for signal processing, field programmable gate arrays (FPGAs) have been applied instead of the most commonly encountered, general purpose, microcontrollers. The main advantages of FPGAs usage in the communication interface are the ability to integrate the elements of the whole system within a single chip and the feasibility of the division of computational tasks between hardware and software, executed by the embedded soft-processors.This paper mainly focuses on the FPGA implementation side of the signal processing path. A few specific implementation methods have been investigated and compared, including manual HDL coding, Matlab HDL coder usage, applying the Xilinx HLS (High Level Synthesis) tool and using simple embedded microcontrollers.The remainder of the paper is structured as follows. Section 2 briefly describes the used MEMS-based sensors and FPGA realization of data transfer and signal acquisition from the sensors. In Section 3, the general idea of the signal processing path is presented, whereas in Section 4 the details of different FPGA implementation of the path and their comparison is discussed. Finally, the prototype of the communication interface is presented in Section 5.The key component of the communication interface is a sensor monitoring selected muscle activity. As such a sensor, the exploitation of micro-electro mechanical system (MEMS) accelerometers has been proposed here. Nowadays, MEMS accelerometers are widely used in many domains, e.g., gaming, virtual reality, impact recognition, vibration monitoring and more [15]. Some healthcare applications, e.g., heart rate performance measured using a ballistocardiology signal, are also reported [16].For the communication interface, a small-sized, 3-axes LIS331H accelerometer from ST [17] has been chosen. The accelerometer has a digital output with a 12-bit resolution. Since FPGAs, unlike typical microcontrollers, are not equipped with embedded analog to digital (A/D) converters, having a digital output is an important feature of the sensor. Although A/D converters, e.g., sigma-delta type, can be implemented inside FPGA, they require some amount of FPGA resources and significant design effort. Having acceleration data coming from all 3 axes allows, in turn, to choose the axis, which ensures better sensitivity to specific motions of the monitored muscle.Fig. 1shows the prototype of the two MEMS based sensors for the communication interface. Since the MEMS chip has an extremely small package (3×3×1mm3 only), it requires a piece of printed circuit board (PCB) to connect its contact pads to the external wires. Apart from MEMS chip, the sensor's PCBs contain decoupling capacitors only. The sensors can be attached to the selected muscle e.g., by an elastic headband.The selected accelerometer offers two types of communication interfaces: SPI (4 or 3 wires) and I2C. In order to minimize the number of wires connecting the sensor with an FPGA board, an I2C interface has been chosen. On FPGAs side, an implementation of the I2C master interface is more difficult than with SPI. The realization of two types of I2C master interfaces has been investigated: software-based with an FPGA embedded microcontroller and a typical hardware-based. In the case of software approach, a previously developed FPGA embedded microcontroller, based on the Microchip PIC16 family [18] has been exploited. As a microcontroller software, the C code, primary targeted and used for the 8051 microcontroller, has been adopted. For the hardware realization of an I2C master interface, a specific state machine has been developed, described in Verilog HDL, and implemented.Table 1shows the FPGA resources requirement for the two I2C implementation options and additionally for the SPI interface implementation. The Xilinx XC6SLX9 FPGA (Spartan 6) chip has been used. As expected, the SPI implementation requires the least resources. Software-based I2C realization needs in turn more resources than hardware-based. However, writing a software program or adopting an existing one is easier and faster than developing an equivalent hardware.Instead of the Microchip PIC16 based embedded microcontroller used here, another microcontroller type, such as the resource-efficient PicoBlaze [19] from Xilinx, can be exploited. Spartan 6 FPGA implementation of the PicoBlaze itself only requires 104 LUTs and 82 flip-flops. However, for I2C realization the overall resources requirement slightly increases since the implementation of I/O ports is needed. Additionally, a C compiler for the PicoBlaze is not available, which makes software preparation harder. Nonetheless, in terms of FPGA resources requirement, the PicoBlaze microcontroller can be an alternative to the proposed PIC16 based microcontroller and the typical HDL-coded I2C hardware implementation.Having previously developed an I2C master interface and MEMS motion sensors, a simple data acquisition system has been implemented on the FPGA development board. Then, acceleration data coming from one sensor attached to a cheek muscle, have been sampled with 400Hz frequency, transmitted to a PC computer via serial interface and imported to Matlab software. The waveforms are presented in Fig. 2a and d. In the case of Fig. 2a, four weak muscle contractions surrounded by a noise have been recorded. Fig. 2d includes, in turn, a recorded signal with a few stronger muscle contractions (samples 1000…3000) and slow horizontal and vertical head movement (samples 4000…8000).As it can be inferred from the acceleration signal waveforms, efficient detection of weak muscle contraction requires a few steps of signal processing. These steps must include, at least, a signal denoising and a DC component removing.The signal from MEMS accelerometers under vibration is usually very noisy [20]. Therefore, several methods of signal denoising have been developed, such as moving average, low-pass filtering, wavelet transform, optimal estimation, adaptive filtering and short time Fourier transform [21]. For the communication interface, two methods have been taken into consideration: wavelet transform and low-pass filtering. To choose the more suitable one, several virtual experiments under Matlab have been carried out. Since both methods have given similar denoising results and low-pass filtering is significantly easier to implement, the latter method was finally chosen. Fig. 2b and e show denoised signal waveforms. A finite impulse response (FIR) filter with 31 coefficients and a 20Hz cut-off frequency has been applied here.In general, an output of a digital filter can be expressed by the time domain difference Eq. [20]:(1)y(n)=∑i=0Mbi⋅x(n−1)−∑j=1Naj⋅y(n−1)where, n is the current sample number, b0…bMand a1…aNare filter coefficients. For FIR filters, coefficients and a1…aNare all equal to zero. In the case of the waveforms from Fig. 2b and e, the filter Matlab function, which realizes the Eq. (1) has been used. The coefficients b0…bM, in turn, have been calculated using the fir1 Matlab function (the Hamming window has been applied).Apart from denoising, the next step of signal processing consists of DC component removal. It can be done by a simple DC notch filter. As Matlab simulations show, such a filter can be realized under the conditions where N=M=1 and a=[1,−0.98], b=[−1,1] in Eq. (1). However, its characteristic of very narrow–slow signal change, caused for example, by slow head movement, is not attenuated. Despite that, many peoples with NMDs are not able to make a movement of their heads, insensitivity to slow signal changes from the sensor, can still be useful. A good enough result of this type of signal attenuation can be achieved by altering the coefficients vectors values, i.e., a=[1,−0.817], b=[−0.833,0.833].The waveforms, after applying a two-stage filtering (a low-pass for denoising and a high-pass for the attenuating of slow signal changes) are shown in Fig. 2c and f. As can be seen, the filtered signal slightly oscillates around the 0 value when no muscle contractions occurred. The influence of slow position changes of the MEMS sensor, caused by user head movement, is significantly attenuated. When muscle contractions occur, short signal pulses emerge. Therefore, to detect contractions, a window comparator, which checks whether the signal exceeds two arbitrary chosen threshold values, should be used. The threshold values are represented by the two horizontal lines in Fig. 2c and f. However, as observed, a single muscle contraction generates more than one impulse exceeding the threshold values. Thus, a retriggerable off-delay timer should be applied to achieve a single output impulse in response to a single muscle contraction.Taking into account the above considerations, a block diagram of a signal processing path for the communication interface can be developed. Fig. 3shows the diagram. It consists of an I2C master interface, a 31 order low-pass FIR filter (LPF), a 2-nd order high-pass IIR filter (HPF), a widow comparator (WC) and a retriggerable off-delay timer (RODT). Some of the blocks are parameterized, e.g., MEMS sensor active axis (X, Y or Z) can be selected, and threshold values as well as time constant for RODT may be configured. It is worth to note, that active axis choice and threshold values influence the sensitivity of muscle movement detection. The RODT output can be then used as input switch either for virtual keyboards or for Morse code text devices.In this section, a few different methods of signal processing path FPGA implementation are investigated. The methods were then compared in terms of the FPGA resources requirement, number of clock cycles needed and maximum achievable clock frequency. Since the RODT implementation in FPGA is straightforward (it can be easily described using HDL), the following considerations regard only the three key blocks from Fig. 3, i.e., LPF, HPF and WC, marked as the signal processing block (SPB) in the figure.Realization of the filters and window comparator blocks requires some arithmetic operations. Instead of the most commonly used fixed point or distributed arithmetic [22], the exploitation of the floating point (FP) arithmetic is proposed here. FPGA structures are optimized for fixed point computations, thus FP arithmetic usage requires more design efforts and takes a larger amount of FPGA resources. On the other side, the advantage is that changing filter coefficients (and the widow comparator thresholds) does not require reimplementation of the whole project. The coefficients can be directly imported from Matlab software, without recalculation to fixed point or distributed arithmetic format. The other advantage of FP arithmetic is a higher dynamic range and, related to it, a reduced risk of excess word length.For the filters and window comparator realization, only two FP operations are needed: multiplication and addition. Specific intellectual property (IP) blocks for the operations implementation must be used. The blocks can be either manually designed using HDL coding or generated automatically by IP generator software from FPGA vendors. As an example, let us consider a few different FP multiplier implementations.Table 2shows the multiplier versions post implementation parameters such as the FPGA resources requirement, maximum achievable clock frequency and number of clock cycles needed to complete FP multiplications. Both design types – manual HDL coding (versions A…D) and the usage of IP cores from an FPGA vendor (versions E…G) – have been investigated (the Xilinx Spartan 6 chip has been used). A detailed architecture of the FP multiplier for manual HDL coding, as well as other basic FP operations, can be found in the work [23]. Here, a few different implementations of the architecture from [23] are considered. The multiplier versions A…D from Table 2 differ in the design of a fixed point 24×24 bit internal multiplier whose structure has an essential influence on the final parameters. Version A applies a standard serial paper-and-pencil multiplication algorithm. Version B includes a 24-bit 3-stage pipelined multiplier consisting of four 12-bit fast array multipliers and two adders. The 12-bit fast array multiplier based on direct, parallel realization of the paper-and-pencil algorithm has been designed as a pure combinatorial circuit. Version C is the same as version B with one exception, namely, a 3-stage pipeline has been added to each of the fast array multipliers. Version D follows version B, but instead of the array multipliers, four embedded 18-bit hardware multipliers from the DSP48A1 blocks of Spartan-6 FPGA have been applied.As can be seen, the multiplier implementations A…D, designed with manual HDL coding (Verilog HDL has been used), feature slightly worse parameters than the vendor and family optimized IP cores E…G. Taking the implementation cost into account, given by the amount of FPGA resources, the multiplier version G has been chosen for the realization of FP multiplication. Similar evaluations regarding FP adder has also been carried out. The adder block from the Xilinx IP core generator was finally selected (428 LUTs and 74 registers are needed for the adder).Having designed an FP multiplier and adder, for the FPGA implementation of LPF and HPF filters, the Eq. (1) can be directly used. Yet, the general filter structure presented in Fig. 4is more useful for hardware realization. The structure realizes the Eq. (1) where N=M[22]. The z−1 block represents a delay element. Based on the structure, most of the arithmetic operations can be parallelized, i.e., in the first step all multiplications can be done, then, in the second step, all additions may be accomplished. Thus, it is the fastest realization of a filter; however, it requires engagement of a significant number of multipliers and adders, which might be very expensive in terms of FPGA implementation cost. As far as communication interface filters are concerned, computing speed–due to relatively low sampling frequency (400Hz only)–is not critical. Therefore, serial implementation of the Eq. (1), with a single multiplier and a single adder block is fully sufficient. Nonetheless, the arithmetic blocks can provide computations simultaneously, e.g., at the same time when the final addition is calculated (the first adder block from the right side of Fig. 3), the multiplication by the b1 coefficient can be accomplished. This reduces the overall filter computation time by the factor of two.A detailed architecture of the hardware block, which realizes filters and window comparator functions, is presented in Fig. 5. The bold lines in the schematic represent multi bit buses. Since there are two input sensors, the block from Fig. 5 is able to provide computations for both sensors with a single pair of an FP adder (FPADD) and an FP multiplier (FPMUL). The 12-bit integer acceleration data from the I2C interface modules for both input sensors (DATA1, DATA2 signals) are provided to the input multiplexer and then converted to the FP format (I2FP block—a specific IP core from core generator has been used). Floating point data are subsequently processed by the control unit. Two blocks of 30 RAM cells (32-bit each cell) for storing intermediate addition results for data of both sensors are needed (each z−1 block from Fig. 4 is, in fact, a single RAM cell). Intermediate computations results for the HPF filter are stored in the control unit internal registers. The filters coefficients and threshold values are held, in turn, in a dedicated registers file, which are initialized during the FPGA configuration process. The content of the registers file can be also modified without reimplementation of the whole project for instance by an embedded microprocessor software. The control unit's outputs, which represent calculation results from window comparators, should be connected to RODT timers to complete the signal processing path. The control unit itself is designed as a state machine and described in Verilog HDL.Table 3shows the SPB block implementation results. The Xilinx XC6SLX9 was used as a target FPGA chip. The implementation of the block consumes almost one half of the available resources. Computations take 151 clock cycles, which in conjunction with a 84MHz maximum clock frequency gives 1.8μs as the minimum calculation time.Manual HDL coding of data processing algorithms is not easy and is a time consuming process. In an engineering approach, many algorithms are first developed and tested using the well-known Matlab environment. Some time ago, MathWorks company introduced the HDL coder software, which automatically generates HDL code (Verilog or VHDL) from Matlab functions, Simulink blocks or System Objects [24]. Such a tool significantly reduces the designers’ efforts of HDL coding and allows them to implement FPGA designs from the widely used Matlab language.In order to perform automatic HDL code generation for the communication interface SPB block, a specific Matlab function has been created, which describes the behavior of the single SPB block. No embedded library functions have been used. Having such a function and the test bench script, which also has been created, HDL coder software automatically have converted floating point arithmetic to its fixed point counterpart, and HDL code has been generated.Table 4shows the implementation results of the SPB block VHDL description, generated by the HDL coder (Verilog code turned out to not be synthesizable). Two versions have been considered, which differ in the degree of embedded multipliers exploitation: with full multipliers exploitation (A), and without any multiplier (B). The unique feature of the implementation is that, the calculations are performed within a single clock cycle (very fast realization of the SPB block). When embedded multipliers are used, very little FPGA resources (specifically LUTs) are needed. However, unlike in the case of the manually coded version, this SPB realization, coming from the Matlab description, performs the calculations only for a single data channel. If two sensors are used, the number of required FPGA resources must be doubled.Another way of automatic HDL code generation from high-level programming languages is the usage of Vivado HLS software as a part of Vivado Design Suite [25]. This is a relatively new tool from Xilinx, which allows for algorithm specification in C/C++ or System C languages. Vivado HLS, unlike Matlab HDL coder, also supports floating point data types. It provides the ability of automatic usage of Block RAM blocks, DSP blocks and floating point libraries. Unfortunately, Vivado HLS is only dedicated for newer Xilinx FPGAs families, such as Virtex-7 or Kintex-7, and does not support older Spartan-6 chips, used in the communication interface prototype.Using Vivado HLS, realization of the SPB block only requires a definition of the C function with proper parameters, which is really straight forward. Single precision floating data types have been used for the SPB block C function specification.Table 5shows the implementation results of the SPB block C function, delivered by Vivado HLS. The Xilinx Kintex-7 family was used as a target chip. Therefore, the results cannot be directly compared with those obtained for Matlab HDL coder and manual HDL coding. Nevertheless, we can notice that the calculations take more clock cycles (231 vs. 151) and require more embedded multipliers (8 vs. 4) than for manual HDL coding.Looking at the implementation results for the microcontroller used in the I2C interface and the floating point multiplier, we can notice that the FPGA resources requirement for these components are comparable. Therefore, if it was possible to implement the SPB block algorithm by means of this microcontroller, such a solution would be very cost effective (small number of required FPGA resources) and simple for realization. The only limitation of the microcontroller usage is the algorithm calculations time. Conducted tests showed that the time, even when floating point calculations were used, should not be longer than 0.7ms, whereas the maximum required time accounts for 1.25ms (400Hz sample frequency, 2 channels). This means that the microcontroller is able to handle the calculations. However, the amount of RAM memory is not enough for storing the filter's intermediate values. Software realization of the buffer for the filter's intermediate values requires at least 240 bytes (2 channels, 30 locations of 32-bit). Current microcontroller implementation delivers two memory banks (96 bytes in each bank) with a total available space of 192 bytes [18]. Although it could be easily extended to 384 bytes (four memory banks), the used C compiler (Hitech Picc Lite) is only able to operate within a single memory bank (96 bytes).The considered microcontroller exists as an IP core, described in Verilog HDL. Therefore it can be upgraded and equipped with new functionalities like an additional RAM memory. Such an extension has been introduced to the primary architecture, developed in [18].Fig. 6shows the microcontroller architecture with the introduced extension, marked with a shadowed rectangle. A detailed description of the old architecture part can be found in [18]. The extension mainly relies on the addition of three new 8-bit registers within the special function registers (SFRs) area. Two of them (MADDRL and MADDRH) establish a 16-bit address bus for the additional memory (64KB space can be implemented). The third register (MDATA) is a kind of virtual register. Writing to it causes a write cycle to the Block RAM memory, whereas reading it, reads the Block RAM memory location, addressed by the MADDRL and MADDRH registers. An additional instruction has also been introduced (unused SLEEP instruction code has been exploited), which increments, in a single clock cycle, the two address registers, treated as one 16-bit register. This speeds up some memory operations.Although the additional memory space is not directly available for compilers, the memory can easily be accessed by the dedicated software functions and used as buffers for a larger number of data.For software SPB block realization with the embedded microcontroller, the C function code, prepared for Vivado HLS, has been used. Then the code has been slightly altered to exploit the microcontroller's additional memory. Table 6shows the implementation results of the SPB block implemented with the embedded microcontroller. The modified microcontroller architecture implementation requires a little more FPGA resources (e.g., 620 LUTs vs. 462 LUTs) than the primary version. The measured SPB block algorithm calculation time accounts for 0.548ms (55MHz clock frequency), which means that the calculations need as many as 30,140 clock cycles.In order to directly compare the results of different SPB block realization methods, presented in previous subsections, the HDL description of the block, obtained by means of all the methods, has been synthesized and implemented in the common Xilinx Kintex-7 family chip (XC7K70T). Using the Kintex-7 family instead of the Spartan-6, applied in the prototype board, was necessary due to the fact that the Vivado HLS tool generates an HDL description which cannot be applied for the Spartan-6 family.The results are presented in Table 7. The meaning of the methods is as follows: A—manual HDL coding, B and C—Matlab HDL coder usage with (B) and without (C) the exploitation of embedded multipliers, D—Vivado HLS applied, E—embedded microcontroller usage. Calculation times are given under the assumption that the actual clock frequency is close to the maximum allowable value.As Table 7 shows, the method requiring the least resources is A (embedded microcontroller), which is also the slowest (by around two orders of magnitude than the others). Although method B requires a little less LUTS for a single channel, it needs as many as 19 multipliers. The fastest methods are definitely those obtained by means of the Matlab HDL coder. They calculate the result within a single clock cycle. However, fixed point calculations must be used. Methods A and D both exploit floating point arithmetic, but method A is faster and less resources saving than method D. However, A is the most challenging method in terms of designer efforts and involvement.Comparing the implementation methods, it should be noted that only methods A and E allow the realization of the calculations for two sensors channels. Therefore, the FPGA resources requirement for the remaining methods must be doubled if two sensors are used. It is also worth to note that the complete signal path with all the SPB block implementation methods, except D, has been physically implemented on the board with a Spartan-6 chip and experimentally tested. The conducted tests have proved the implementation correctness.Fig. 7shows the complete block diagram of the proposed interface. Apart from the I2C, SPB and RODT modules, it consists of an embedded microcontroller (uC), serial interface (UART) and program memory block (PM). The most important part is the SPB block, which realizes the signal processing algorithm, described in Section 3 (denoising, DC component removal and signal comparing with configured threshold values). The microcontroller, besides performing the main program, i.e., decoding Morse code, is responsible for delivering the thresholds values for the SPB block, time constant for RODT timers and the MEMS accelerometer active axis choice signal for the I2C module. These values can be changed by the user during the operation, which allows the adjustment of the sensitivity of muscle motion detection.The proposed communication interface can be used in two ways. In the first way, it can be applied as a simple input switch for virtual keyboard software, such as Wivik [8]. The output signal of the RODT timers is then used for driving the virtual keyboard. In the second way, the interface allows the writing of words and sentences by means of the Morse code. The active signal from sensor 1 is interpreted as a dot symbol, whereas the signal from sensor 2, as a dash symbol. A simultaneous signal from both sensors means that the entering of a character has been completed. A double simultaneous signal from both sensors (two simultaneous signals divided by a short, configurable, period of time) is configured as the space character (end of a word), and a triple simultaneous signal, as a backspace (deleting of the last entered character). Following characters and words are displayed on the simple LCD display and they are also transmitted via serial interface to a PC computer.A photo of the assembled prototype of the communication interface is shown in Fig. 8. Apart from the main module with the FPGA chip (XC6SLX9), it consists of a simple panel with an LCD display and a standard game pad controller board with USB (small fragment of the board is visible near to the top-left of the main module), which provides a connection with the Wivik virtual keyboard.Table 8shows, in turn, the overall FPGA resources requirement for the communication interface implementation. Two versions have been considered: with SPB block implemented by means of an embedded microcontroller (A) and with manual HDL coding method (B). Resources of the used FPGA chip for both implementation versions are sufficient, yet version A requires significantly less resources than version B.The described prototype (with manual HDL coding of the SPB block and hardware version of the I2C block) was exercised by one individual, who is only able to move their cheek muscles. The MEMS sensors were provisionally attached to the individual's cheeks by means of an adhesive bandage (a plaster). The conducted tests showed the need for the usage of a more convenient way of information presentation than allowed by a simple LCD display. Also, the Wivik software seemed to be slightly inconvenient for effectively entering the characters (selecting a character took a relatively long time). Therefore, the currently used prototype's version was slightly altered to only act as an input switch for a dedicated software program–currently under development (the information, coming from the RODT timers, is passed via serial port). Instead of the uC block from Fig. 7, the altered prototype was equipped with a hardware block—the downloader, which communicates with a PC computer and allows the transfer of the threshold values (sensitivity adjustment), coefficients values for both LPF and HPF filters, and the time constant for RODT timers. The downloader, whose design is based on the communication module from [23], also allows the storage of all the values in non-volatile memory, available on the prototype's board. Additionally, the window comparator block was modified in order to generate an output signal only if a configured number of consecutive excessiveness of the threshold values will occur. This enhances the feasibility of the adjustment of a sensors’ reaction sensitivity.

@&#CONCLUSIONS@&#
It has been shown that FPGA can be an efficient platform for building a single chip communication interface for disabled persons. Application of MEMS accelerometers, as muscle motion detection sensors, seems to be a reliable alternative to other types of sensors used so far in this area. As conducted experiments show, using Morse code with two sensors allows to write words and sentences faster than with a single sensor and virtual keyboard such as Wivik (scanning process by rows and columns takes time). However, general knowledge of the Morse code is required here. Using two sensors for two basic code symbols makes it so that Morse code timing issues become irrelevant, which significantly simplifies characters entering process.The presented communication interface prototype can be upgraded relatively easy. For example, instead of the simple LCD display, a more sophisticated TFT display or even a typical computer monitor can also be used, without additional external components (the display driver can be realized inside FPGA). Having such a display, virtual keyboard software can be implemented using an embedded microcontroller and integrated with the communication interface—all inside a single FPGA chip, which would make it for that the complete solution could be very cheap.Apart from the functional aspects of the presented solution, different FPGA implementation methods of a particular signal processing algorithm have been investigated. It has been shown that if the main design criterion is to obtain the most resources saving implementation, then the usage of an embedded microcontroller is a good choice. However, this implementation brings low calculations speed. To achieve faster implementation with significantly reduced design efforts – in comparison with a typical manual HDL coding technique – Matlab HDL coder and Vivado HLS tools can be used. Such tools, allowing automatic HDL code generation from high level programming languages, seem to have a great potential. They provide fast a prototyping feature and allow for the implementation of complicated algorithms without a very challenging and time-consuming manual HDL coding process. Yet, some digital circuits behavior are still described easier and faster by standard HDL languages. For example, it was hard to describe in Matlab or C programming language the control circuit behavior allowing for signal processing, alternatively coming from two sensors. Thus, only manually HDL coded SPB block implementation is able to process two data channels. In the case of floating point arithmetic usage, which is not quite natural for FPGAs, manual HDL coding allows obtaining faster and more resource efficient implementations than with Vivado HLS.A certain disadvantage of the usage of the MEMS sensors is the difficult way of attachment the sensors to the subject's cheeks. Dedicated research is required to find a suitable solution to the problem. Yet, the sensors can also be attached to other, easier available, muscles as long as the subject is able to move them (the MEMS sensors can even replace mechanical buttons, applied in some assistive tools).So far, the prototype has only been exercised by one disabled person. To better evaluate the proposed solution, further examinations with a wider group of controlled subjects, including normal subjects, are needed. They will be conducted as a future work. One of the preliminary results, already achieved, may suggest that a slightly shorter time (approx. 10%) of entering selected text, in comparison with the Morse based applications, can be attained using a virtual keyboard with a configuration similar to that applied by Stephen Hawking (contrary to the Wivik software, this is a non-QWERTY configuration). Therefore, currently conducted work is focused on developing a PC software, which implements a few different ways of information exploitation, coming from the communication interface (e.g., Morse-based and virtual keyboard-based applications), and leaving the end-user to make a choice of the most suitable one for his/her individual preferences.