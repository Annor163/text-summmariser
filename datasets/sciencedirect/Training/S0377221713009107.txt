@&#MAIN-TITLE@&#
Scheduling with few changes

@&#HIGHLIGHTS@&#
We consider scheduling problems where a sequence of assignments has to be determined.The goal is to minimize the costs incurred by the interplay between the assignments.We propose simple and efficient algorithms to solve those optimization problems.We also provide hardness results where such algorithms most likely do not exist.

@&#KEYPHRASES@&#
Assignment problem,Changeover cost,Algorithm,

@&#ABSTRACT@&#
In this work we consider scheduling problems where a sequence of assignments from products to machines – or from tasks to operators, or from workers to resources – has to be determined, with the goal of minimizing the costs (=money, manpower, and/or time) that are incurred by the interplay between those assignments. To account for the different practical requirements (e.g. few changes between different products/tasks on the same machine/operator, few production disruptions, or few changes of the same worker between different resources), we employ different objective functions that are all based on elementary combinatorial properties of the schedule matrix. We propose simple and efficient algorithms to solve the corresponding optimization problems, and provide hardness results where such algorithms most likely do not exist.

@&#INTRODUCTION@&#
In many industrial production environments, considerable costs (=money, manpower, and/or time) are incurred whenever the production is disrupted, e.g. to readjust, retool or clean the machines. Undoubtedly due to their relevance in numerous practical applications, scheduling problems that aim to minimize these costs have received a lot of attention in the literature (see e.g. Allahverdi, Ng, Cheng, & Kovalyov, 2008; Błażewicz, Ecker, Pesch, Schmidt, & We¸glarz, 2001; Brucker, 2007 and references therein). Another fundamental problem in combinatorial optimization is the assignment problem, where tasks are to be assigned to machines, such that the costs to complete all the tasks are minimized (see e.g. Ahuja, Magnanti, & Orlin, 1993; Çela, 2002; Cook, Cunningham, Pulleyblank, & Schrijver, 1998; Pentico, 2007).In this work we consider a family of scheduling problems at the intersection of the two above-mentioned problems: We are interested in finding an entire sequence of assignments, and the costs are incurred (only) by the interplay between those assignments. More specifically, we are given a set of parts{1,2,…,n}and a sequence of productsP1,…,Pℓ, each consisting of a subset of the parts,Pi⊆{1,2,…,n}. There are m identical machines, and in the ith step of the production, productPi=:{p1,…,pk}is produced by assembling the corresponding partsp1,…,pk. For this purpose the partsp1,…,pkhave to be assigned to k of the machines, and the remainingm-kmachines are idle. Ifm⩾n, then we can reserve each machine for only one particular part throughout the production and assign all occurrences of this part to this machine (this is considered an ‘ideal’ schedule). In practice however, we usually havem<n(there could be as few asm=maxi∈[ℓ]|Pi|machines), and a schedule will necessarily be more ‘disordered’, i.e., we cannot avoid assigning different parts to the same machine in subsequent time slots, or assigning the same part to different machines during the production. Later, we will formally define four different objective functions that measure this ‘disorder’ in a schedule (see Fig. 1below).To demonstrate that our model is quite versatile, we briefly mention three concrete applications in the following. These will also serve as a plausibility check when giving the formal definitions of our objective functions. Furthermore, the examples immediately suggest natural extensions of the model, some of which will be discussed in Section 1.2.4 below.Example 1A chemical manufacturing plant produces various chemicals (=products), each consisting of a specific set of constituents (=parts). The constituents are supplied to the mixing and reaction stage through a number of supply pipes (=machines). Whenever a constituent on a supply pipe changes during the production, this incurs costs to retool and clean the pipe.A pharmaceutical packaging facility bundles together different types of pills (=parts) into patient or region specific boxes (=products). The pills are stored in containers that can be hooked to the feeding holes (=machines) of the packaging unit. Costs are incurred by the manpower necessary to exchange the containers, possibly interrupting the whole production.The last example shows that our model also captures a set of applications that are phrased in an entirely different language.Example 3An insurance company has a number of employees (=parts) who use the company cars (=machines) for their field work. Work is organized in hourly timeslots, and during each timeslot, only a subset of employees (=products) needs a company car. Costs are incurred by the time losses and inconveniences caused whenever two different employees are assigned the same car in directly subsequent time slots (one has to prematurely hurry back for the exchange), and also whenever the same employee has to switch and adapt to a different car.The main contribution of this work are simple and efficient algorithms for the optimization problems arising from the above-mentioned scenarios. We also provide hardness results to identify problems where such algorithms most likely do not exist. We hope to address those hard problems (which are important for some of the mentioned applications) in future work, by providing approximation algorithms with provable guarantees.Before stating our results, we give a formal definition of the problem outlined above.Products and machines. For any two integers r and s withr⩽swe define[r,s]≔{r,r+1,…,s}and[r]≔[1,r]={1,2,…,r}.A production is a pair([n],P), where n is an integer andP=(P1,…,Pℓ)is a sequence of non-empty subsets of[n], such that⋃i∈[ℓ]Pi=[n](or equivalently, for everyp∈[n]there is somei∈[ℓ]withp∈Pi). As before, we refer to each of the setsPias a product, and to the elements ofPias the parts of productPi(these terms will often be used in informal discussions). Clearly, the requirement that each part appears in at least one product is just a natural way to exclude artificial complications. As before we use m to denote the number of machines.Schedules. A schedule for a production([n],P),P=(P1,…,Pℓ), on m machines is anℓ×mmatrixσwith values from[n]∪{ε}(εis a symbolic placeholder) with the property that for everyi∈[ℓ]every element ofPioccurs exactly once in the ith row ofσ(so the ith row contains exactlym-|Pi|values equal toε). The interpretation of an entry(i,j)withσ(i,j)=p∈Piis that when producing productPithe part p is assigned to machine j, andσ(i,j)=εmeans that when producing productPimachine j is idle. We useΣ=Σ([n],P,m)to denote the set of all schedules for the production([n],P)on m machines.Clearly, a necessary (and sufficient) condition for the existence of a schedule for a given production([n],P),P=(P1,…,Pℓ), on m machines is thatm⩾maxi∈[ℓ]|Pi|.Objective functions. We now define four objective functions that measure the ‘disorder’ of a schedule. The reader is invited to check that each of the objectives is meaningful for some or all of the previously mentioned applications (not all objectives are relevant for all examples, and often some objectives are more important than others). For the reader’s convenience, the following definitions are illustrated in Fig. 1.For a production([n],P)and integer m, a changeover in a scheduleσ∈Σ([n],P,m)is a triple(i1,i2,j)withi1<i2,σ(i1,j)=:p∈[n],σ(i2,j)=:q∈[n],p≠q, andσ(i,j)=εfor alli1<i<i2. We denote the number of changeovers inσbyNchange(σ).In many applications (cf.the above examples), a changeover(i1,i2,j)gets more relevant/more costly, if the differencei2-i1gets smaller (think ofi2-i1as the available time in which the changeover has to be performed). In this work we distinguish changeovers(i1,i2,j)withi2-i1=1, which we call critical, from changeovers withi2-i1⩾2(those are not critical). We denote the number of critical changeovers inσbyNcrit(σ).A critical changeover on one machine may delay or interrupt the production on all m machines (as in Examples 1 and 2 above, but not in Example 3). A stop in a scheduleσ∈Σ([n],P,m)is an indexi∈[2,ℓ]for which there exists a critical changeover(i-1,i,j),j∈[m]. Note that a single stop can be caused by several critical changeovers between rowsi-1and i. We denote the number of stops inσbyNstop(σ).A move in a scheduleσ∈Σ([n],P,m)is a quadruple(i1,j1,i2,j2)withi1<i2,j1≠j2,σ(i1,j1)=σ(i2,j2)=:p∈[n]andp∉Pifor alli1<i<i2. We denote the number of moves inσbyNmove(σ).For the four above-mentioned quantities we define the minimal number of changeovers, the minimal number of critical changeovers, the minimal number of stops and the minimal number of moves, by setting for*∈{change,crit,stop,move}(*is used as a variable representing each of the four cases)(1)N∗min=N∗min([n],P,m)≔minσ∈Σ([n],P,m)N∗(σ),respectively. Later we will also consider combinations of these optimization goals. We remark here that minimizing the number of stops is equivalent to makespan minimization (assuming that every stop takes the same amount of time).Clearly, form⩾nchangeovers, stops and moves can be avoided completely (we may choose a different machine for each part, and assign all occurrences of a part to the corresponding machine). We are therefore only interested in the casem<nin the following.We are now ready to state our results.Theorem 4There is an algorithm which computes, for any production([n],P),P=(P1,…,Pℓ), and any integer m withmaxi∈[ℓ]|Pi|⩽m<n, the minimal number of changeoversNchangeminas defined in(1)and a scheduleσ∈Σ([n],P,m)withNchange(σ)=Nchangeminin timeO(ℓ·m).Note that the required bounds on m in Theorem 4 are only included to avoid trivial cases as mentioned in Section 1.1.In many applications, e.g. if m is constant, every|Pi|is a positive fraction of m (recall that thePiare all non-empty), and then the size of the input satisfies∑i∈[ℓ]|Pi|=Θ(ℓ·m). In those cases, the claimed running time is therefore best possible. Note also that if we wish to output the computed optimal scheduleσas an entireℓ×mmatrix, then already this requires timeΘ(ℓ·m), and the given runtime bound is best possible. Nevertheless, if the input is sparse, i.e.,∑i∈[ℓ]|Pi|=o(ℓ·m), and if we either decide to output an optimal scheduleσin sparse form (e.g., by returning for everyi∈[ℓ]and everyp∈Pithe machine to which p is assigned) or restrict ourselves to computing only the integerNchangeminand no optimal schedule at all, then the claimed running time might not be best possible. Observe however thatℓ·m⩽∑i∈[ℓ]|Pi|2(clearlyℓand n are both bounded from above by∑i∈[ℓ]|Pi|, andm<n), so in any case the claimed running time is at most quadratic in the size of the input of the algorithm.Given a production([n],P),P=(P1,…,Pℓ), and an integer m, note that two consecutive productsPi-1andPicontribute at least(2a)max{0,|Pi-1∪Pi|-m}=:cito the number of critical changeovers in any scheduleσ∈Σ([n],P,m). Observe also that the elements fromPican be assigned to the ith row ofσ(while leaving rowi-1unchanged) such that exactlycicritical changeovers occur between rowsi-1and i. As critical changeovers occur only between consecutive rows, repeatedly applying this observation yields a simple greedy strategy to efficiently compute a schedule with exactlycicritical changeovers between rowsi-1and i for alli∈[2,ℓ]. It follows that the minimal number of critical changeoversNcritminas defined in (1) satisfies(2b)Ncritmin=∑i∈[2,ℓ]ci.We conclude furthermore that any schedule that minimizes the number of critical changeovers also minimizes the number of stops, and that the minimal number of stopsNstopminas defined in (1) satisfies(3)Nstopmin=|{i∈[2,ℓ]||Pi-1∪Pi|>m}|.Summarizing, critical changeovers and stops by themselves are an entirely local phenomenon (they occur only between consecutive rows ofσ) and can thus be trivially minimized as a primary and sole optimization goal. The following theorems show that even if we require few changeovers as a secondary optimization goal (arbitrary changeovers, not just critical ones), an optimal solution can still be computed efficiently. To state these results, we define for any production([n],P)and integer m, and for∗∈{crit,stop}(4)N∗,changemin=N∗,changemin([n],P,m)≔minσ∈Σ([n],P,m):N∗(σ)=N∗minNchange(σ).Theorem 5There is an algorithm which computes, for any production([n],P),P=(P1,…,Pℓ), and any integer m withmaxi∈[ℓ]|Pi|⩽m<n, the numberNcrit,changemindefined in(4)and a scheduleσ∈Σ([n],P,m)withNcrit(σ)=Ncritmin,Nstop(σ)=NstopminandNchange(σ)=Ncrit,changeminin timeO(ℓ·m).As a consequence of the above observation that any schedule which minimizes the number of critical changeovers also minimizes the number of stops, the conditionNcrit(σ)=Ncritminmentioned in Theorem 5 directly implies the second conditionNstop(σ)=Nstopmin. Our next theorem shows that we may drop the requirement of few critical changeovers as a primary optimization goal, and only focus on stops.Theorem 6There is an algorithm which computes, for any production([n],P),P=(P1,…,Pℓ), and any integer m withmaxi∈[ℓ]|Pi|⩽m<n, the numberNstop,changemindefined in(4)and a scheduleσ∈Σ([n],P,m)withNstop(σ)=NstopminandNchange(σ)=Nstop,changeminin timeO(ℓ·m).Let us emphasize here that the resulting scheduleσreferred to in Theorems 5 and 6 contains only as many critical changeovers or as many stops, respectively, as are unavoidable (those numbers are given by (2) and (3)).Observe that the numbers defined in (4) and referred to in Theorems 5 and 6 satisfy(5)Ncrit,changemin⩾Nstop,changemin.As we shall see, the algorithms referred to in Theorems 5 and 6 can be obtained by extending the algorithm from Theorem 4.In contrast to the previously mentioned optimization goals, most likely there is no efficient algorithm that computes the minimal number of moves.Theorem 7ComputingNmoveminas defined in(1)is NP-hard.In the following we present several results about generalizations of our problem that are relevant in practice (recall the examples from the beginning).Variable product order. Suppose that the order of the productsP1,…,Pℓin a production is not fixed, but also part of the scheduling procedure. I.e., we aim at finding a permutationπ:[ℓ]→[ℓ]and an assignment of the parts in each of the productsPπ(1),…,Pπ(ℓ)(in this permuted order) to the m machines, such that the costs for the resulting schedule as defined in Section 1.1 are minimized. For changeovers, critical changeovers, stops and moves we denote the corresponding minimal quantities byN^changemin,N^critmin,N^stopminandN^movemin, respectively.Not so surprisingly, the additional freedom of a variable product order makes each of those optimization problems hard.Theorem 8ComputingN^changemin,N^critmin,N^stopminorN^moveminis NP-hard.Multiset products. All our previous results (Theorems 4–8) carry over to the generalized setting where the productsP1,…,Pℓin a production([n],P)are allowed to be multisets (i.e., a partp∈[n]may occur multiple times in a productPi,i∈[ℓ]). This is trivially the case for the hardness results (Theorems 7 and 8). Furthermore, as we shall see, algorithms for such multiset productions having the properties claimed in Theorems 4–6 can be obtained by a simple extension of the original (non-multiset) algorithms.

@&#CONCLUSIONS@&#
