@&#MAIN-TITLE@&#
A temporal agent based approach for testing open distributed systems

@&#HIGHLIGHTS@&#
We present some technical issues for testing distributed frameworks with timing constraints.We model an architecture taking into account the delay of messages exchanged between the components of the testing distributed applications.We propose a Multi-Agent based system to capture the complex monitoring tasks of distributed tester behaviors

@&#KEYPHRASES@&#
Distributed testing,Timing constraints,Multi-agent systems,

@&#ABSTRACT@&#
The development of distributed testing frameworks is more complex, where the implementation process must consider the mechanisms and functions required to support interaction as long as the communication and the coordination between distributed testing components. The typical reactions of such systems are the generation of errors‘set: time outs, locks, observability, controllability and synchronization problems. In other side, the distributed testing process must not only check if the output events have been observed, but also the dates when these events have been occurred. In this paper, we show how to cope with these problems by using a distributed testing method including timing constraints. Afterwards, a multi-agent architecture is proposed in the design process to describe the behavior of testing a distributed chat group application on high level of abstraction.

@&#INTRODUCTION@&#
Several reference models, architectures and frameworks such as ODP (Open Distributed Processing), CORBA (Common Object Request Broker Architecture), and TINA (Telecommunications Information Networking Architecture) have already been designed and proposed for developing distributed systems [1]. However, even though models provide a good basis for developing working open distributed applications, conformance testing approaches are required for gaining confidence in final products and guaranteeing their integration and interoperability within open distributed environment [2].The conformance testing may be seen as mean to execute an IUT (Implementation under Test) by carrying out test cases, in order to observe whether the behavior of the implementation is conforming to its specification. Hence, the IUT (Implementation under Test) may be viewed in the context of open distributed systems as a system providing standardized interfaces for interacting with other systems. Based on testing of OSI communicating systems, conformance of an open distributed system can be assessed by attaching a related tester at each provided interface [4]. However, many problems influencing faults detection arise during the conformance testing process if there is no coordination between distributed testers.In fact, the use of multiple testers introduces the possibility of coordination problems amongst remote testers. These potential problems are known as controllability and observability fault detections which are fundamental features of conformance testing [2–7]. To avoid these problems, many works [1–4] propose to introduce coordination messages which lead each tester to determine when to apply a particular input to the implementation under test (IUT) and whether a correct output from the IUT is generated in response to a specific input, respectively. Nevertheless, even if the introduction of such messages can resolve such mentioned issues, it leads to another kind of problems commonly known as synchronization problems. In this perspective, the distributed testing process must not only check if the output events have been observed, but also the dates when these events have been occurred especially if the system has to respect some timing constraints. Thus, two different time constraints are defined: transfer time i.e. the time required for a coordination message to travel from a tester to another, and reaction time, i.e. the time elapsed between the reception of an input by the IUT and the sending of the corresponding output by the IUT. We emphasize that even if some authors [4–6] have made a simplifying assumption that the time required for a transfer time, is greater than the reaction time of the IUT. Many academic researches [8,9] showed that controllability and observability problems are indeed resolved if and only if the test system observes those timing constraints.In this paper, we focus on the temporal properties that specify the time required to exchange messages between the various components of the distributed test application. Thereby taking into consideration the temporal properties in the specification of the behavior of conformance testing it will provide a higher degree of expressiveness and flexibility. The proposed approach consists firstly on introducing a new architecture taking into account the delay of messages exchanged between testers and the IUT, and between testers. The main based idea of the proposed work is to develop an algorithm for generating Timing Local Test Sequences for each tester guarantying to avoid problems of coordination, observation and synchronization. Secondly, on high level of abstraction, we show how multi-agent based system used in distributed testing prototype realization contribute to capture the complex monitoring tasks of distributed tester behaviors.The paper is structured as follows: Section 2 describes the architecture and some modeling concepts of distributed testing application and presents the synchronization problems arisen in distributed testing execution. Section 3 is dedicated to introduce the architecture and modeling concepts of testing distributed applications with timing constraints. Section 4, presents the algorithm allowing the generation of timing local test sequences. Sections 5 and 6 describe the behavior of testing a distributed chat group application and design the test process of such application on high level of abstraction using a multi-agent architecture. Finally Section 7 gives some conclusions and identifies future works.Alongside the academic research activities, efforts have been made in the industry and standards bodies (ISO and ITU) to develop approaches to conformance testing of OSI protocols. A standardized methodology, tools, experiences and theories exist today with a certain degree of maturity [10]. This section is devoted to the extension of the results of testing protocols for dealing with the test of open distributed systems.The principle is to apply input events to the IUT and compare the observed outputs with expected results. A set of input events and planned outputs is commonly called a test case and it is generated from the specification of the IUT.The basic idea of distributed testing architecture is to coordinate parallel testers called PTCs (Parallel Test Components) using a communication service in conjunction with the IUT. Each tester interacts with the IUT through a port PCO (Point of Control and Observation), and communicates with other testers through a multicast channel.Fig. 1gives an abstract view of what have could be an ODP distributed testing architecture. An IUT is the implementation of the distributed application to test. It can be considered as a “black-box”; its behavior is known only by interactions through its interfaces with the environment or other systems. Each tester sends some stimulus to the IUT via their attached interfaces called PCOs (Points of Control and Observations) and from which it observes the output IUT reactions. The external behavior of the IUT is observable via another interface type called IAP (Implementation Access Points). The difference between the PCO and the IAP is that PCOs are the logical points where communications are made, but the IAPs are the physical access points of the IUT. In order to control the test execution, PTCs exchange messages that encapsulate the information avoiding controllability and observability problems.To approach the testing process in a formal way, the specification and the IUT must be modeled using the same concepts. The specification of the behavior of a distributed system is described by an automaton with n-port [11] (FSM: Finite State Machine) defining inputs and the results expected for each PCO. We denote Σk the input alphabet of the port “k” (PCO number k) and Γk the output alphabet of the port k. Fig. 2gives an example of a 3p-FSM with: Q={q0, q1, q2}, q0 the initial state, Σ1={a1, a2}, Σ2={b1}, Σ3={c1}, and Γ1={x1, x2 }, Γ2={ y1,y2}, Γ3={z1}.A test sequence of an np-FSM is a sequence in the form:!X1? Y1!X2 ? Y2…! Xt ?Yt where for i=1,..,t, Xi belongs to Σ=Σ1U … U Σn with Σi ∩ Σj=∅ for i≠j and Yi is a subset of∪nk=1Γksuch that, for each port k, |Yi ∩Γk|≤1, i.e. Yi contains at most one symbol from the output alphabet of each port ofA.•!Xi: Denotes sending the message Xi to IUT.?Yi: Denotes the reception of messages belonging to the Yi from the IUT.An example of a global test sequence (GTS) deduced from the 3p-FSM given in Fig. 2 is:(1)!a1?x1.y1!b1?x2.y2!c1?z1Generally, test sequences are generated from the specification of the IUT and characterized by fault coverage. Several methods exist for generating test sequence from FSM specification. They are mainly used for detecting two basic types of faults output faults and transfer faults [12].The work [4] allows generating local test sequences for each tester, and thus the behavior of the test application in each PCO is well defined. In fact, each tester executes its local test sequence (LTS), built from the global test sequence of the IUT. The generated LTS encapsulate the information that allows controlling the test execution. Indeed, many problems influencing fault detection during the conformance testing process arises if there is no coordination between distributed testers. These potential problems are known as controllability and observability fault detections which are fundamental features of conformance distributed testing. The controllability may be defined as the capability of the test system to realize input events at corresponding PCO in a given order, and observability may be defined as the capability of the test system to determine the output events and the order in which they take place at corresponding PCO [4]. To solve such problems, authors in [4] propose an algorithm to generate Local Test Sequences (LTS) from Global Test Sequence (GTS). The following LTS are the results given by applying the proposed algorithm to test sequence (1):(2)W1=!a1?x1?x2?O3W2=?y1!b1?y2!C3W3=?C2!O1!c1?z1where:•!x denote sending of message x to IUT?y denote receiving of message y from the IUT!Ck denote sending coordination message to tester k and ?Ck receiving coordination message from tester k.!Ok denote sending observation message to tester k and ?Ok receiving observation message from tester k.Thus, each tester executes its LTS as follows: for each message “xi” sent to the IUT or a coordination message, the tester supports the process of sending this message. If “xi” is an expected message from the IUT or a coordination message, the tester waits for this message. If no message is received, or if the received message is not expected, the tester returns a verdict Fail (fail). If the tester reaches the end of its local test sequence, then it gives a verdict Accept (accepted). Thus, if all testers return a verdict Accept, then the test system ends the test with a global verdict Accept.In the distributed test, each tester (PTC) executes its local test sequence produced from the global test sequence of the IUT. Let the execution of the first fragment of each local test sequence Wf1, Wf2and Wf3select from W1, W2 and W3 as follows:(3)Wf1=!a1?x1?x2Wf2=?y1!b1Wf3=?C2!O1The execution of local test sequences Wf1, Wf2and Wf3must give the result shown in Fig. 3(a) but the execution of our prototype provides an incorrect result given in Fig. 3(b).Indeed, in the diagram Fig. 3(b) the second tester sends the message “b2” to the IUT before the first tester receives the message “x1” from the IUT. So, the execution of local testing does not conform with the specification given in (1), where the message “b2“ must be sent only if all messages due to the sending of “a1” by the tester-1 are received by the IUT.In this perspective, the distributed testing process must not only check if the output events have been observed, but also the dates when these events have been occurred especially if the system has to respect some timing constraints.For example, in the execution of the first fragment of the GTS given in (1): !a1?{x1.y1}!b1?{x2.y2}, the tester-1 begins by sending a message “!a1” to the IUT. However, the tester-2 can't send the message “!b1“ and must wait until receiving the message “?y1“ from the IUT and the message “?x1“ to be received by the tester-1.Now, the principal question that can be studied and discussed is how much time the tester-2 and tester-1 can wait for receiving “?y1” and “?x1” respectively, so that the tester-2 can send “!b2” to the IUT?

@&#CONCLUSIONS@&#
