@&#MAIN-TITLE@&#
Fault tolerance at system level based on RADIC architecture

@&#HIGHLIGHTS@&#
A system-level fault-tolerant mechanism for message passing applications.Fully decentralized and transparent, for applications and communication library.Protection, detection and recovery functions, implemented at socket API level.Semi-coordinated vs. uncoordinated checkpoints: performance based election.

@&#KEYPHRASES@&#
Software fault tolerance,Resilience,RADIC,Message passing,Semi-coordinated checkpoint,Uncoordinated checkpoint,Socket,

@&#ABSTRACT@&#
The increasing failure rate in High Performance Computing encourages the investigation of fault tolerance mechanisms to guarantee the execution of an application in spite of node faults. This paper presents an automatic and scalable fault tolerant model designed to be transparent for applications and for message passing libraries. The model consists of detecting failures in the communication socket caused by a faulty node. In those cases, the affected processes are recovered in a healthy node and the connections are reestablished without losing data. The Redundant Array of Distributed Independent Controllers architecture proposes a decentralized model for all the tasks required in a fault tolerance system: protection, detection, recovery and masking. Decentralized algorithms allow the application to scale, which is a key property for current HPC system. Three different rollback recovery protocols are defined and discussed with the aim of offering alternatives to reduce overhead when multicore systems are used. A prototype has been implemented to carry out an exhaustive experimental evaluation through Master/Worker and Single Program Multiple Data execution models. Multiple workloads and an increasing number of processes have been taken into account to compare the above mentioned protocols. The executions take place in two multicore Linux clusters with different socket communications libraries.

@&#INTRODUCTION@&#
The number of components in HPC systems is continuously increasing. On the one hand, there are more sockets per node to accomplish the demand of more performance, and, on the other hand, the deploy of system with more but less powerful components, allows to save power consumption. A growing number of components implies that the probability of failure increases as well. Although the Mean Time Between Failures (MTBF) of each component tend to be high, the system can fail frequently because it is composed by a higher number of them  [34]. Moreover, reliability issues come up when chips are operated at significantly lower voltage  [37].The remarkable increase in the failure rate of the systems  [7,39] encourages the investigation of fault tolerance (FT) mechanisms. A node failure during the execution causes the loss of computation done until this point. The fault tolerance strategies have the aim to minimize fault’s effects on applications to guarantee the execution in spite of node faults, in such cases in which the reliability to achieve a successfully end is very required.Fault tolerance techniques based on rollback-recovery are highly recommended in the literature for message passing applications  [14,13]. One of the most implemented approaches is based on coordinated checkpointing. It is a straightforward technique to recover the global state but it forces to roll back all the processes and the checkpoint coordination may slow down the application execution because of congestions on I/O  [7,21]. However, current research is focusing on improving these scaling issues  [35,32].This research provides a transparent FT model, that is, it can be used without changing the parallel application and can be adopted at system level, independently of the message passing library chosen. It is based on RADIC Redundant Array of Distributed Independent Controllers   [38,12], an FT model architecture for message passing application, which works in a distributed and decentralized way during failure-free operations and recovery to allow the application to scale.A complete FT model should provide a way to protect the state, detect faults as soon as possible and automatically recover a consistent state in order to finish the execution. Automatic recovery allows us to decrease the Mean Time to Repair (MTTR). The Availability, defined as the degree to which a system or component is operational and able to perform its designed function, is calculated as follows:(1)Availability=MTBF/(MTBF+MTTR).Therefore, a reduction in the Mean Time To Repair (MTTR) implies a higher availability even though the MTBF of the system increases.A message passing parallel application is able to resume and successfully end its execution in case of a node failure when it is provided for fault tolerant functionality. According to Gropp and Lusk  [20], FT can be added at different layers with distinct degrees of transparency for the application.Fig. 1(a) represents the software tiers in a parallel node. Usually, message passing libraries use the Socket Application Program Interface (API) to make inter-processes communications. The socket API is a de-facto standard for network programming in most used operative systems (OS) and provides means for interconnecting processes through the network. This API is widely used because of its simplicity, robustness and portability  [2]. Fig. 1(b) aggregates the tiers in the parallel computer and it depicts the location of our proposal. Fault tolerance at system level can be used as a transparent service for the message passing library and for the application.Our approach is located at system level and has two pillars. The first, which is called reliable socket manager (RSM), consists of replacing the socket communications for reliable connections which are able to detect and recover from network errors. Instead of returning a fatal error when a socket is closed due to a remote failure, the connection is reestablished again without losing data, by using the new IP address where the remote process has been migrated. Secondly, FT functions based on RADIC are devised at socket level in order to save the state of the processes and to recover only the affected ones when a node faults.The actions related to saving the state, detecting the errors, recovering the processes state and keeping reliable communications are triggered when the processes use the socket API, which works at OS level. The default socket behavior is transformed into reliable connections with fault tolerance mechanisms by intercepting calls to socket API as a dynamic library. The mechanism is transparent not only for the application designer, but also for the system administrator because the failure is automatically detected and recovered, and the application is able to finish successfully without human intervention.RADIC architecture has been applied as an FT model for two main reasons: firstly, because it has a completely distributed and decentralized behavior which allows the application to scale and, secondly, because it is based on an uncoordinated checkpoint with message logging. This rollback recovery protocol allow us to recover only the failed processes instead of recovering all of them  [14]. Specifically, pessimistic receiver-based logging allows us to recover the failed process in an autonomous way. Furthermore, only the last checkpoint and the messages received from it have to be kept. However, that protocol is slower than other alternatives such as sender-based or causal algorithms.In order to reduce the overhead of the log procedure, we propose using the semi-coordinated checkpoint  [10]. Current HPC systems based on multicore processors tend to execute several parallel processes in each node of the system, usually following the strategy of one process by core. Semi-coordinated checkpoint consists of relating the processes running in a node because all of them are affected in case of node faults. The logging of messages among them is avoided and they are checkpointed coordinately. The receiver-based pessimistic log is applied for messages between processes in different nodes.This paper provides a global vision of the system architecture presented in previous works  [8–10] and the functionality of the following rollback recovery protocols are described and their impact in the performance is analyzed and compared.•Fully uncoordinated checkpoint (NCO): It is the default RADIC protocol using uncoordinated checkpoint combined with receiver-based pessimistic message log.Blocking Semi-coordinated checkpoint (BSCO): It performs a blocking coordinated checkpoint  [10] among processes in a node combined with receiver-based pessimistic message log for inter-node messages.Semi-coordinated checkpoint (SCO): It performs a non-blocking coordinated checkpoint among processes in a node combined with receiver-based pessimistic message log for inter-node messages.Two popular distributed programming schemes which follow a well-known communication patterns, such as master–worker (M/W) and Single Program Multiple Data (SPMD), have been selected for the experimental evaluation. Both patterns allow us to analyze the overhead of the semi-coordinated alternative in the worst scenario, when no message is interchanged among processes on the same node, and, on the contrary, when there are internal communications.Experiments using different input size are carried out to analyze and compare the FT overhead using distinct relations between the computation and the communication time needed for each task. In other sets of executions, the number of processes are increased as well in order to check whether the FT system affects the scalability of the application.The content of this paper is organized as follows. In Section  2 we mention the related works. Section  3 defines the RADIC architecture used as a model for our solution. Section  4 explains the devise of our approach at socket level and Section  5 describes the semi-coordinated rollback recovery protocols which can be selected as alternatives to reduce overhead. The experimental evaluation is presented in Section  6, and lastly, we state the conclusions and the future work in Section  7.

@&#CONCLUSIONS@&#
In this paper, we have presented a fault tolerance model which allows a message passing application to end successfully even when node failures occur. It is transparent for the application and it is able to detect node faults and recovering the processes automatically. As it is based on RADIC, it is distributed and has a decentralized behavior.The model is located at system level, specifically at socket level. The application source is not required for adding FT. The message passing library does not need to be updated to support node failures, nor reconfigured or compiled again. The data and the procedures required to achieve a transparent and automatic fail-over mechanism at system level without losing in-transit packages are exposed through the reliable socket manager.A blocking (BSCO) and non-blocking (SCO) semi-coordinated checkpoint protocols have been exposed as alternatives of the fully uncoordinated checkpoint (NCO) proposed by RADIC.The experimental evaluation is carried out using socket message applications, which follow very well-known patterns in the scientific field, such as M/W and SPMD. It has been shown that the FT model is successfully applicable to both cases.This paper demonstrates the feasibility of supplying FT functionality to message passing applications independently of the message passing library chosen, provided that it uses socket API to establish inter-processes communications. This feature would allow to avoid having to upgrade applications or message passing library without FT mechanisms, thus reducing the development and testing cost.The results obtained from comparisons using different workloads, number of processes and clusters show that both SCO and BSCO are good alternatives for reducing time execution overhead when multiple processes with internal communications are executed in multicore clusters.We are working on a set of experiments to demonstrate that we can use this middleware to fault tolerance applications, using either MPICH or Open MPI, the most popular MPI libraries. Additional socket functions have to be considered.The model could be extended to other networks like Infiband  [26] which provides application program interfaces that can be treated using socket API.