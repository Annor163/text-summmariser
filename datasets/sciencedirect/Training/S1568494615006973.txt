@&#MAIN-TITLE@&#
A hybrid evolutionary algorithm for multiobjective variation tolerant logic mapping on nanoscale crossbar architectures

@&#HIGHLIGHTS@&#
The problem of variation tolerant logical mapping on nanoscale crossbar architectures is modeled as a bilevel multiobjective optimization problem. A hybrid multiobjective evolutionary algorithm is designed to solve the problem in a bilevel optimization framework.The lower level problem is modeled as a MMBM problem, and a Hungarian-based Linear Programming (HLP) method is proposed, which can solve MMBM in polynomial time.The upper level optimization problem is solved by evolutionary multiobjective optimization algorithms, where a greedy reassignment local search operator, capable of leveraging the domain knowledge and information from problem instances, is introduced to improve the efficiency of the algorithm.

@&#KEYPHRASES@&#
Nanoscale crossbar,Variation tolerant logic mapping,Bilevel multiobjective optimization,Hungarian-based linear programming,Hybrid evolutionary algorithm,

@&#ABSTRACT@&#
Nanoscale crossbar architectures have received steadily growing interests as a result of their great potential to be main building blocks in nanoelectronic circuits. However, due to the extremely small size of nanodevices and the bottom-up self-assembly nanofabrication process, considerable process variation will be an inherent vice for crossbar nanoarchitectures. In this paper, the variation tolerant logical mapping problem is treated as a bilevel multiobjective optimization problem. Since variation mapping is an NP-complete problem, a hybrid multiobjective evolutionary algorithm is designed to solve the problem adhering to a bilevel optimization framework. The lower level optimization problem, most frequently tackled, is modeled as the min–max-weight and min-weight-gap bipartite matching (MMBM) problem, and a Hungarian-based linear programming (HLP) method is proposed to solve MMBM in polynomial time. The upper level optimization problem is solved by evolutionary multiobjective optimization algorithms, where a greedy reassignment local search operator, capable of exploiting the domain knowledge and information from problem instances, is introduced to improve the efficiency of the algorithm. The numerical experiment results show the effectiveness and efficiency of proposed techniques for the variation tolerant logical mapping problem.

@&#INTRODUCTION@&#
Although the complementary metal oxide semiconductor (CMOS) technologies have met the demand of increasing functionalities by scaling exponentially as Moore's law predicted in the past four decades, the scaling is predicted to approach fundamental limits at the end of next decade [1]. Nanoelectronic technologies (circuits built with components on the scale of 10nm) [2] has recently been studied as one possible heir to CMOS technologies to continue the scaling when CMOS technologies hit their limit. Some novel nanoelectronic devices have been fabricated and characterized in chemistry labs using bottom-up approach (in which devices are created by chemical assembly instead of top–down–based lithography) [3], such as carbon nanotube field-effect transistors (CNT-FETs) [4], nanowire field-effect transistors (NW-FETs) [5], and single electron tunneling junctions (SETJs) [6]. Using nanoelectronic devices and bottom-up approach could achieve more scaling and make it possible to produce higher speed, higher density, and lower power consumption electronic systems compared to customer CMOS technologies.However, variations caused by the nanoelectronic technologies are expected to be much more serious than the CMOS technologies. At the nanoscale level, even an uncertainty of a few atoms may adversely affect the parameters and the behavior of nanoelectronic devices. There are various sources of variations for the new technologies: variations in the features of nanowires and nanotubes caused by stochastic assembly process [7,8], material density variations resulted from the lack of precise control over material positioning [9,10], and variation of resistance due to poor connections of crosspoints [8,11]. Such variations might prevent circuits from meeting timing and power constraints and degrade the parametric yield [12]. Therefore, variation tolerant techniques will be crucial to the generalization of bottom-up nanoelectronics technologies.Nanoscale crossbar architectures have been widely studied [13–15] for their great potential to be main building blocks in nanoelectronic circuits. They are the easiest computational structure to fabricate at nanoscale and have the merit of configurability, interchangeability, and regularity [16]. Similar to the programmable logic array (PLA) [17], a nanoscale crossbar consists of two layers of orthogonal nanowires. Variation tolerant logic mapping (VTLM) problem can be defined generally as: given a crossbar and a logic function to be implemented on it, find a mapping of the logic function to the crossbar with consideration of variation of delay. The VTLM is one critical technique to mitigate process delay variation by utilizing the reconfigurable nature of the crossbar. There exist n!×m! permutations for an n×m logic mapping problem, so it is intractable for exhaustive methods to deal with large scale crossbars. Some previous works [18–23] have investigated the VTLM in different ways, which can be broadly divided into three types according to the objectives set for optimization.Ghavami et al.et al. [18] and Zamani et al.et al. [22] considered minimizing the maximum variation as the design objective. In [18] a mathematical model based on weighted bipartite a graph is proposed, after which a greedy algorithm is presented to solve VTLM. The method shows great advantage over exhaustive method in terms of runtime. However, the authors did not pay much attention to the effectiveness, quality of the solution of the algorithm, which depended much upon the nature of the benchmark problems. In [22] a set of interger linear programming (ILP) formulations is introduced to solve the VTLM, and the experimental results show this method can find better results at a higher time cost compared to simulated annealing [19], the computational complexity of the method would be further high if the size of crossbar becomes larger.Tunc and Tahoori [19,20] took into account two optimization objectives (minimizing maximum delay and minimizing output variations) separately for mapping a function to a crossbar. They translated the logic mapping problem into the mapping between two matrices by exploiting variation matrix (VM) and binary function matrix (FM). A simulated annealing (SA) algorithm was used to optimize the matrix mapping, its effectiveness was testified with better experimental performance over the exhaustive method. With their approach, since the optimizations of the two objectives are conducted separately, optimizing with respect to one objective may result in a bad performance with respect to the other objective.Very often, a decision maker prefers an approximation of the Pareto front for a good insight to the problem and making his or her final choice. In order to get a set of good (in the sense of Pareto optimum) solutions to be examined for trade-offs rather than a single solution, Yang et al.et al. [21] formulated the VTLM problem into a multiobjective optimization problem, and used an evolutionary algorithm, NSGA-II, to get a set of nondominated solutions. Experimental results show that the obtained solutions are close to the Pareto front of the benchmark problems of small sizes. However, NSGA-II shows its performance degrading when the size of crossbar becomes larger. To improve the performance of NSGA-II, Zhong et al.et al. [23] introduced a greedy local search into NSGA-II and presented a hybrid NSGA-II, which could find better solutions than [21].To make the VTLM problem more tractable, the problem can be treated as a bilevel multiobjective optimization problem (BLMOP), where the tough problem can be divided into two level of correlated subproblems, and be solved respectively with different methods. Bilevel optimization problems, arise from hierarchical problems in practice, are characterized by the existence of one (lower level) problem embedded in other (upper level) optimization problem. BLMOP involve optimization of multiple objectives at one or both of the levels [24]. Though many works [25,26] have been done for bilevel single-objective optimization, not much attention has been paid to the BLMOP until recent years [27–31]. Deb and Sinha [27] proposed a viable algorithm based on evolutionary multiobjective optimization (EMO) principles to solve BLMOP. Based on those studies, Deb and Sinha [28] proposed a hybrid evolutionary local search-based algorithm as a solution methodology, Sinha [29] presented a progressively interactive EMO for bilevel problems, where preference information from the decision maker at the upper level of the bilevel problem is used to guide the algorithm toward the most preferred solution. Zhang et al.et al. [30] proposed an improved particle swarm optimization (PSO) for solving BLMOP, which was further improved in [31] by hybrid with a crossover operator to prevent premature convergence. These algorithms are able to solve generic bilevel multiobjective optimization problems, but not efficient enough for the VTLM problem.In this paper, the VTLM problem is treated as a bilevel multiobjective optimization problem and a hybrid multiobjective evolutionary algorithm (HMOEA) is designed to solve the problem in a bilevel optimization framework [28,32]. The lower level optimization problem is modeled as the min–max-weight and min-weight-gap bipartite matching (MMBM) problem, which is defined in weighted bipartite graph as a perfect matching, where both the maximal edge weight and edge weight gap are minimized simultaneously. A Hungarian-based linear programming (HLP) method is proposed, which can solve MMBM in polynomial time. The upper level optimization problem is based on optimality of the lower level optimization problem. An evolutionary multiobjective optimization is designed to solve the upper level optimization problem, where a greedy reassignment local search operator, capable of exploiting the domain knowledge and information from problem instances, is introduced to improve the efficiency of the algorithm. The numerical experiment results show the effectiveness and efficiency of the bilevel optimization framework and the proposed hybrid evolutionary algorithm.The remainder of this paper is organized as follows. In Section II, the statement of the VTLM problem for nanocrossbar architectures are described. Section III provides the formulation of the optimization problem. Section IV introduces the proposed hybrid optimization algorithms. In Section V, experiment results, comparisons, and analysis are presented. Finally, Section VI concludes the paper.A nanoelectronic crossbar consists of two series of orthogonal nanoscale wires with configurable devices at the crosspoints (junctions). Each junction can be independently activated or deactivated. If a junction is deactivated, its corresponding crossing wires do not interact electrically. When it is activated, two wires of the junction are connected to behave as a diode or a transistor, depending on the nature of nanowires. Fig. 1shows an example of general structure of two-dimensional crossbar.Using the programmable architectures, researchers have presented logic operations implanted on diode-based crossbar and FET-based crossbar [33]. The diode-based crossbar can be used to implement wired OR logic as shown in Fig. 2a. While the FET-based crossbar can not only build NAND logic as shown in Fig. 2b, but also NOT, AND, NOR, and OR logic [33].The lumped delay information in a crossbar can be represented by a real matrix called variation matrix (VM) [19,21]. Each entry of VM corresponds to the delay from a horizontal nanowire to a vertical nanowire, including delay of nanowires, contact, and crosspoints. VM is the property of the nanoscale crossbar and differs from one crossbar to another crossbar. An example of 4×4 VM is shown in Fig. 3a, where the delays are random values distributed on the interval between 1 and 100.The mapped logic function can be represented by a binary matrix called function matrix (FM) [19,21]. Each entry of FM indicates relationship between input and output. If one output depends on one input, the corresponding entry is one, otherwise is zero. Fig. 3b shows the FM for logic functions in Fig. 2.Thus, the mapping from inputs and outputs of logic function to horizontal and vertical nanowires of crossbar turns to mapping between two matrices. Consider that VM and FM are both size of n×m, then the mapping scheme can be expressed by an input mapping vector (IMV) and an output mapping vector (OMV) [19,21]. IMV[i]=j means that the ith input of function is assigned to the jth horizontal nanowire of crossbar, 1≤i, j≤n OMV[i]=j means that the ith output of function is assigned to the jth vertical nanowire of crossbar, 1≤i, j≤n There are two optimization goals for VTLM: minimizing maximum delay and minimizing output variations [19,21]. In this paper, minimizing maximum path delay is set as primary objective, which aims to deduce transfer delay of the mapped function, and minimizing output variation is set as secondary objective, which aims to balance all the paths. The two optimization objectives are defined as follows:(1)objective1=minmaxiCfi(2)objective2=minmaxiCfi−miniCfi,whereCfirepresents the delay of output fi, differs from the property of crossbar.For diode-based crossbars, as shown in Fig. 3a, programmable diodes are connected between outputs and inputs in a parallel way. Therefore, the maximum delay of the activated paths can be considered as the delay of an output, see more precisely demonstration in [22]. Thus, for diode-based crossbars, the delay of output fi denoted byCfiis calculated as follows [22]:(3)Cfi=maxkFMki×VMIMVkOMVi.On the contrary, FETs are connected in a cascaded way for FET-based crossbars. Hence, the delay of an output can be estimated by the sum of delay of the activated paths. Thus, for FET-based crossbars, the delay of output fi denoted byCfiis calculated as follows [19,21,22]:(4)Cfi=∑k=1nFMki×VMIMVkOMVi.In this paper, the proposed algorithms are tested on the VTLM of FET-based crossbar, which is more promising than diode-based crossbar [22]. Actually, we just need to change the fitness calculation when the algorithm is applied for the problem of diode-based crossbar.There are n!×m! permutations for an n×m logic mapping problem, which make the problem very hard to be solved with limited computational resource. In this paper, the VTLM problem is transformed to be a bilevel multiobjective problem, as illustrated in Fig. 4, where the upper level problem is to optimize a variable vector IMV (input mapping vector) that is corresponding to a mapping between the input of function and the horizontal nanowire of crossbar, and the lower level problem is to optimize the variable vector OMV (output mapping vector, corresponding to a mapping between the output of function and the vertical nanowire of crossbar) with a fixed vector IMV inherited from the solution of upper level optimization problem. The two level problems here share the same two optimization objectives as defined in Eq. (1) and (2).For the lower level problem, it is possible to determine an optimal OMV in a polynomial time for a fixed vector IMV by constructing a weighted bipartite graph model and using HLP method. The weighted bipartite graph is denoted byG=F,O,E,W,where F represents the set of function outputs, O represents the set of vertical output wires, E denotes the edges of the graph, and W is set of weight of associated edges. It is a complete bipartite graph where every vertex of F is connected with every vertex of O via an edge e∈E. The weightwij∈Wmeans the delay of an output when the ith output of function is assigned to the jth vertical nanowire of crossbar, which is calculated as follow:(5)wij=∑k=1nFMki×VMIMVkj.Fig. 5a shows a weighted bipartite graph formulated for a logic mapping problem with n=4. The number of perfect matching (that is, there is a one-to-one mapping between the sets F and O) is n! or a logic mapping problem whose size is n. Fig. 4b shows an example of a perfect matching.To select a proper OMV, we should solve the min–max-weight and min-weight-gap bipartite matching (MMBM) problem, that is, find a perfect matching where both the maximal edge weight and edge weight gap are minimized simultaneously in the weighted bipartite graph. It is well known that the Hungarian method [34], originally proposed as an assignment algorithm, has shown its efficiency to solve maximum (minimum) weighted bipartite matching (MBM). However, the MMBM is quite different from the MBM, which is defined in complete weighted graph, where the sum of the weights of the edges in the matching have a maximal (minimal) value. Therefore, a heuristic algorithm based on Hungarian method (HLP) is proposed here to deal with MMBM.The target of the upper level optimization is to find a set of good IMVs that can balance well between two objectives; it is a typical biobjective optimization problem. But the fitness of solutions (IMVs) can only be evaluated through solving the lower level optimization problem. When the optimal OMV is found in the lower level optimization for every IMV, multiobjective evolutionary algorithm is used to deal with the upper level optimization problem.In this section, a hybrid optimization algorithm adhering to the bilevel optimization framework is presented for the VTLM. The procedure of proposed algorithm is depicted in Algorithm 1 and the skeleton is shown as a flowchart in Fig. 6. HLP is implemented on the lower level optimization problem to find one of the true optimal solutions. The upper level optimization problem is solved by NSGA-II, which has a brief framework that use a selection operator based on Pareto domination and a reproduction operator iteratively. A greedy reassignment local search operator is also introduced to improve the efficiency of the algorithm.In the Algorithm 1, Steps 1–2 are the initialization and Steps 3 creates the new population. In Step 4, individuals of the population are chosen to perform local search with probability of pland then fitness of individuals are calculated by employing HLP method in Step 5. Steps 6–8 are the same as the NSGA-II algorithm, see more detail in [35,36]. Finally, the termination criterion is checked in Step 9, if it is satisfied then the algorithm stops, else the algorithm goes back to Step 3 to continue evolving.Algorithm 1: Hybrid NSGA-II with HLP (HN_HLP)Input: Size of population, N; size of the crossbar M×M; Variation Matrix VM and Function Matrix FM; and terminal generation number genmax.Output: The evolved population P.Step 1: Produce a random initial population P0of size N; set generation count t=0.Step 2: Calculate fitness of P0by employing HLP to every individual of the initial population; sort row of FM according to number of related column from more to less; and sort row of VM according to average delay from shorter to longer.Step 3: Make new population Qt′of size N by using selection, crossover, and mutation to Pt.Step 4: Create Qtby employing the local search to Qt′at a certain probability pl.Step 5: Calculate fitness of Qtby employing algorithm 1 to every individual of the new population.Step 6: Combine the parent and the offspring populations and create Rt=Pt∪Qt.Step 7: Sort all solutions of Rtto get nondominated fronts F=nondominated-fast-sort (Rt), where F=(F1, F2,…).Step 8: Set Pt+1=φ, m=1. Until |Pt+1|+|Ft|≤N, calculate the crowding distance of Fmand add it to the parent population Pt+1=Pt+1∪Fm, m=m+1. Sort the Fmaccording to the crowding distance and fill up the parent population Pt+1=Pt+1∪Fm[1:(N-| Pt+1|)].Step 9: Set t=t+1. If t<genmax, go to Step 3.Step 10: Stop.In the bilevel optimization framework, the lower level problem (MMBM) needs to be solved for every individual solution of upper level problem when the fitness evaluation is required, so the algorithm for lower level problem would be executed for a large number of times (N×genmax times in this paper), therefore, the computational complexity of the algorithm for lower level problem will influence the efficiency of the whole algorithm in great deal. In this paper, a Hungarian-based linear programming (HLP) is designed to find an optimal OMV in a polynomial time for each given IMV.As the MMBM is a two-objective optimization problem, there is a set of optimal solutions (OMV) for each IMV as illustrated in Fig. 7. One of the solutions (black point in Fig. 7), where the maximal weight of the edges has a minimal value (Fig. 7), is chosen as the target point to explain how the HLP works.First of all, find the minimal maximal weight Wmax by removing the edges in the weighted bipartite graph step by step in descending order of their weights, while a MBM algorithm (Hungarian method) is used to check the cardinality of the current MBM, until the cardinality reduces. After that, find the corresponding maximal minimal weight Wmin in a similar way by removing the edges in updated bipartite graph in ascending order. The difference between Wmax and Wmix is the corresponding minimal maximal gap. The steps of the HLP are shown in the Algorithm 2. H (G) is a function for finding a maximum matching in the bipartite graph G using the Hungarian algorithm, it returns the matching and the maximum matching number of updated bipartite graph for the judge of edge deleting in step 3 and 5. The bipartite graph is adjusted in step 4, in case of deleting the edges that also have the minimal maximal weight.Algorithm 2: HLPInput: Input mapping vector, IMV; size of the crossbar N×N.Output: Output mapping vector, OMV; two objectives value, objective1 and objective2.Step 1: Built weighted bipartite graph model,G=F,O,E,W.Step 2: Sort edge by weight value in ascending order,eN2.Step 3: Set k=N2, G'=G. While H(G'−ek)≥N, k=k−1, G′=G′−ek.Step 4: Regenerate deleted edges to G’ if their weight value are same to ek.Step 5: Set p=1. While H(G'−ep)≥N, p=p+1, G′=G′−ep.Step 6: Return objective1=ek. objective2=ek-ep.Given a bipartite graph:G=F,O,E,W,the time complexity of the Hungarian method isOF∪OE2.Since the Hungarian method is iteratively called to remove the edges in the bipartite graph, the worst case time complexity of the HLP isOF∪OE2.Suppose, the size of the crossbar is M×M, that isF∪O=M,E=M2,then the time complexity of the HLP isOM5.Though all of the Pareto set for each IMV could be found in this way, only one of the Pareto optimal solutions that pays more attention to the primary objective is chosen and the relevant pair of two objective values is considered as the fitness of MOEAs. In fact, it is time-consuming and unnecessary to find out the whole Pareto set.In the upper level optimization problem, IMV is encoded as chromosome generated by random permutation in the initialization step. The algorithm chooses tournament selection [37,38], two-point crossover, adaptive mutation, and local search to generate new population. The latter three operations are explained in the following.Adaptive mutation: Exchange a sequence of genes in the chromosome until the offspring has a predefined distance to its parent [39]. The distance described here means the number of locations that have different genes between two chromosomes. An example of the mutation operation is shown in Fig. 8.Two-point crossover [40]: Two different random locations are selected from chromosomes of two parents. Then genes between the two locations are copied to the corresponding locations in the offspring. Finally choose the genes from the other parent not located in the offspring to fill the offspring in order. Fig. 9shows an example.Local search: greedy reassignment local search [23,41], which could take advantage of the greedy information extracted from the problem instances, shows its usefulness for the algorithm approaching the Pareto set when applied to OMV in [23]. In this proposed hybrid algorithm, the local search is applied to IMV to improve the efficiency of the algorithm. Greedy reassignment local search is based on the conjecture that for the variation tolerant logic mapping problem, input of function related with more outputs should be mapped to the path with shorter average delay in the crossbar [18], that is, the row of FM that has more related column should be mapped to the row of VM that has shorter average delay.The pseudo code of the local search for VTLM is given in Algorithm 3. The greedy strength k and individual learning intensity n define the degree of exploration against exploitation in the algorithm. Greedy strength k falls between 1 and M (the length of chromosome), which should be chosen carefully. It means doing nothing to the individual when k=1 and a certain rearrangement to the IMV of the individual when k=M. Individual learning intensity n is an integer larger than zero. The balance between local search and global search can be adjusted by k.Algorithm 3: Greedy Reassignment Local SearchInput: Population at generation t, Qt′; sorted number of VM's row, vi; sorted number of FM's row, fi; greedy strength [23,41], k; individual learning intensity [23], tl; and length of IMV, M.Output: Population after local search at generation t, Qt.Step 1: Set individual learning count n=0.Step 2: Select k random number between 1 and M to be a function input vector a; find the horizontal nanowire vector b,bi=IMVai.Step 3: Sort vector a and b, according vector fi and vi, and create new vector a′ and b′.Step 4: Do the reassignment according to a’ and b’,IMVa'i=a'i.Step 5: Set n=n+1. If n<tl, go to Step 2.Step 6: Stop.

@&#CONCLUSIONS@&#
In this paper, the variation tolerant logical mapping problem is transformed into a bilevel multiobjective optimization problem, in which the original complex problem is decomposed into two relatively simpler problems, and then, the two level problems are solved by different methods. The lower level problem (MMBM) needs to be solved for every individual solution of upper level problem when the fitness evaluation is required, so the algorithm for lower level problem would be executed for a very large number of times, therefore, the computational complexity of the algorithm for lower level problem will influence the efficiency of the whole algorithm in great deal. In this paper, the lower level problem is modeled as a MMBM problem, and a Hungarian-based linear programming (HLP) is designed to find an optimal OMV in a polynomial time for each given IMV. The capacity of global exploration is maintained by the NSGA-II implemented for the upper level optimization problem. Moreover, a greedy reassignment local search operator, capable of leveraging the domain knowledge and information from problem instances, is introduced to achieve a fast and directed convergence. The numerical experiment results show the introduction of bilevel optimization framework and the proposed hybrid evolutionary algorithm can achieve better approximation to the Pareto optimal front. It is also observed that the bilevel optimization framework with HLP and local search play more positive roles on improving the performance of evolutionary algorithm for VTLM problem. Further research topics include the enhancement of the population diversity, such as finding more than one optimal OMV for every IMV by HLP in the lower level task, employing a structured intertwined evolution of upper and lower level populations rather than the nested approach [28], and design of a self-adaptive probability of local search for the hybrid evolutionary algorithm.