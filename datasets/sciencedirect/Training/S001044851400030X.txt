@&#MAIN-TITLE@&#
Decomposition of geometric constraint graphs based on computing fundamental circuits. Correctness and complexity

@&#HIGHLIGHTS@&#
A new algorithm to solve the 2D geometric constraint problem is described.The graph is decomposed according to a set of fundamental circuits.Fundamental circuits are induced by a spanning tree.We prove the algorithm soundness.The worst running time is quadratic with the number of geometric elements.

@&#KEYPHRASES@&#
Geometric constraint solving,Graph decomposition,Fundamental circuits,Bridges,Planar embeddings,

@&#ABSTRACT@&#
In geometric constraint solving, Decomposition–Recombination solvers (DR-solvers) refer to a general solving approach where the problem is divided into a set of sub-problems, each sub-problem is recursively divided until reaching basic problems which are solved by a dedicated equational solver. Then the solution to the starting problem is computed by merging the solutions to the sub-problems.Triangle- or tree-decomposition is one of the most widely used approaches in the decomposition step in DR-solvers. It may be seen as decomposing a graph into three subgraphs such that subgraphs pairwise share one graph vertex. Shared vertices are called hinges. Then a merging step places the geometry in each sub-problem with respect to the other two.In this work we report on a new algorithm to decompose biconnected geometric constraint graphs by searching for hinges in fundamental circuits of a specific planar embedding of the constraint graph. We prove that the algorithm is correct.

@&#INTRODUCTION@&#
Geometric constraint solving was developed as a core technology in parametric and feature-based Computer-Aided Design systems. Lately it has found a number of applications in fields like linkage design, chemical molecular modeling, computer vision and dynamic geometry.Many attempts to provide general, powerful and efficient techniques to solve the geometric constraint problem have been reported in the literature. For an extensive review refer to  [1] and the references therein.Among the different approaches to geometric constraint solving, we are interested here in a divide and conquer approach consisting of three steps,  [2]1.Divide the problemPinto several sub-problems, sayP1,P2,…,Pn.Solve each sub-problemPirecursively with known algorithms.Build the solution to problemPby merging the solutions to sub-problems,P1,P2,…,Pn.Constraint solvers that fit in this description are known as Decomposition–Recombination solvers (DR solvers). This approach has been particularly successful when the decomposition into sub-problems and subsequent recombination of solutions to these sub-problems can be described by a plan generated a priori, that is, a plan generated as a preprocessing step without actually solving the subsystems. The plan output by the DR-planner remains unchanged as numerical values of parameters change. Such a plan is known as the DR-plan and the unit in the solver that generates it is the DR-planner,  [3]. In this setting, the DR-plan is then used to drive the actual solving process, that is, computing specific coordinates that properly place geometric objects with respect to each other.Our interest focuses on DR-solvers where the geometric constraint problem is abstracted as a graph and thus, solving the problem generically corresponds to solving the corresponding graph. Therefore the DR-planner is based on graph analysis whose operation will be purely combinatorial. We consider well-constrained problems, loosely speaking, problems where resulting geometric objects are well-defined.In a pioneering work, Hoffmann et al.,  [3], classify graph-based DR-planners into two main categories. Planners in one category, called Constraint Shape Recognition, work by recognizing specific solvable subgraphs of known shape, most commonly, triangular patterns. DR-planners have been widely used and related literature is profuse. Examples are  [4–16]. DR-planners in the second category are called Generalized Maximum Matching planners. Planners in this category work in two steps. First they isolate certain solvable subgraphs by transforming the constraint graph into a bipartite graph where a maximum generalized matching is found. Then the DR-plan is figured out by connectivity analysis. To this category belong DR-planners reported in [17–20].In  [21], Hoffmann et al. reported on two new DR-planners that exhibit features of both categories. The Condensed Algorithm applies repeatedly a flow-based algorithm to find minimal dense solvable subgraphs,  [22], that are subsequently extended by adding more geometric objects one at a time. The Frontier Algorithm and the Modified Frontier Algorithm are essentially improvements of the Condensed Algorithm. These algorithms have been further developed for problems considering purely distance constraint systems by Lomonosov,  [23] and by Zhou,  [24]. Surveys can be found in  [25] and  [26]. A discussion on geometric constraint solving progress and research directions can be found in  [27].We consider geometric constraint problems in the Euclidean plane consisting of a finite set of geometric objects and a finite set of constraints defined between them. The geometric objects are drawn from a fixed set of types such as points, straight lines, circles and arcs of circle. The constraints include topological constraints such as tangency, incidence and perpendicularity, and metric constraints such as point–point distance, perpendicular point–straight line distance and line–line angle. Geometric constraint problems are always well-constrained or minimally rigid,  [28].In this paper we develop the DR-planner introduced in  [29] in three ways: (1) we give detailed algorithms, (2) we show that the approach is sound and, (3) we prove that the runtime isO(n2)wherenis the number of geometric elements in the problem. Experimental results show that for problems with3≤n≤200, the runtime isO(n).The DR-planner belongs to the constraint shape recognition category and is inspired in the algorithm for finding triconnected components of a graph reported by Miller and Ramachandran in  [30]. The strategy used to divide a graph into subgraphs is the tree- or triangle-decomposition approach reported in  [31]. Decomposition may be understood as decomposing a problem into three sub-problems such that pairwise share a common geometric primitive, that we call hinge. Recombination is to place three primitives with respect to each other. In this approach, constraint problems consisting of three primitives are used as building blocks for larger constraint problems.The DR-planner searches for a set of three hinges in fundamental circuits associated to a given spanning tree of the constraint graph. The algorithm has two main steps, (i) transforming the given graph into a simpler, planar graph and (ii) computing a planar embedding for the transformed graph where hinges are identified as a set of three vertices shared by two faces. We have proved that the algorithm is correct in the following sense. First the graph transformation preserves the hinges. Second hinges, if present, always belong to the common boundary of two faces in a planar embedding of the transformed constraint graph.The rest of this paper is organized as follows. In Section  2 we recall some basic concepts from graph theory and planar embeddings that we shall use later on. For the sake of completeness, we include in Section  3 a short description of tree-decomposability, a basic concept in our DR-planner. In Section  4 we describe our DR-planner and in Section  5 we provide an additional case study to illustrate how the approach works. In Section  6 we prove that the algorithm is correct. The algorithm worst running time is analyzed in Section  7. Section  8 gives experimental algorithm runtime values. Finally, in Section  9 we offer a short discussion and a couple of issues that deserve further work.In this section we recall basic terminology of graph theory, the concept of geometric constraint graph associated to a geometric problem defined by constraints, and some definitions related to geometric constraint graphs. For more information on general graphs theory we refer the reader to Even  [32] and to Thulasiraman and Swamy  [33]. Concerning geometric constraint graphs the reader can check the works by Hoffman et al.  [34] and Joan-Arinyo et al.  [31].In this work, a graphG=(V,E)is a finite setVof nodes or vertices and a collection of edges,E. An edge is an unordered pair(u,v)of distinct verticesu,v∈V(G). In generalV(G)andE(G)will denote respectively the set of vertices and edges of the graphG.The degree of a vertexv∈V(G)is the number of edges inE(G)incident tov.A path is a sequence of verticesv1,v2,…,vnsuch that(vi,vi+1)is an edge for1≤i≤n. A path is simple if all vertices on the path are distinct.In this work, a circuit is a simple path that does not contain any repeated vertices exceptv1andvnwhich are the same. In what follows, we shall denote the set of vertices in a circuit asC=〈v1,v2,…,vn−1〉and we shall consider that vertices are circularly sorted. For example,〈b,d,e,c〉and〈d,e,c,b〉are equivalent descriptions for the circuit in Fig. 1. Whether vertices are sorted clockwise or counterclockwise is irrelevant.A graphG=(V,E)is connected if there exists a path between every pair of vertices inG, otherwiseGis disconnected. The maximal connected subgraphs of a disconnected graphGare the connected components ofG.LetG=(V,E)be a connected graph. A vertexv∈V(G)is an articulation vertex ifV(G)−{v}is disconnected. Ifv∈V(G)is an articulation vertex, there are verticesu,w∈V(G), withu≠vandw≠vsuch thatvis on every path connecting verticesuandw.A non-separable or biconnected graphG=(V,E)has no articulation vertices, otherwise it is separable. A biconnected component of a connected graphGis a maximal biconnected subgraph ofG. A connected graph can be decomposed into biconnected components. For any biconnected graphG=(V,E), given a pair of verticesu,v∈V(G)withu≠v, there are, at least, two disjoint paths connectinguandv.The connectivity of a graphGis the minimum numberkof vertices that must be removed to disconnectG. If the connectivity ofGisk, we writeκ(G)=k. For a disconnected graphG,κ(G)=0. For a connected graphG,κ(G)≥1. A separable graphGhasκ(G)=1. A biconnected graphGhasκ(G)≥2. In a similar way a graphGwithκ(G)≥3is called triconnected. Biconnected graphs can be decomposed into triconnected components.A graph is said to be acyclic if it has no circuits. A tree of a graphGis a connected acyclic subgraph ofG. A spanning treeTfor a graphGis a tree that connects all the vertices inV(G). The edges of a spanning treeTare called branches. The edgesE(G)which are not inTare called chords. If|V(G)|=nand|E(G)|=mthe spanning treeThasn−1branches andm−n+1chords. A connected graph always contains a spanning tree.For a given spanning tree, a unique circuit can be obtained by adding to the spanning tree each of the chords. The set ofm−n+1circuits obtained in this way is called the fundamental system relative to the spanning tree. A circuit in the fundamental system is called a fundamental circuit.The ring sum of two graphsG1=(V1,E1)andG2=(V2,E2)is defined asG1⊕G2=(V1∪V2,(E1∪E2)−(E1∩E2))with isolated vertices dropped.A result of graph theory that we will use later on is the Fundamental Circuit Theorem,  [32]. IfG=(V,E)is a graph andTa specific spanning tree, any cycleCinGcan be expressed as the ring sum of some fundamental circuits ofGwith respect toT. Further, no fundamental circuit is the ring sum of any of the others.Planar graphs and embeddings are topics widely discussed in the literature. See, for example,  [35,36]. Here we recall basic concepts that we will use later on.A graphG=(V,E)is planar if there is a mapping from every vertexv∈Vto a point in a two-dimensional space, and from every edgee=(v1,v2)⊆Eto a plane continuous curve such that the bounding points of each curve are the points mapped from the edge end vertices and all curves are disjoint except on their bounding points. The resulting projection is called a plane graph or planar embedding. In this work we consider planar graphs and embeddings, therefore we will use just the word embedding to refer to a planar embedding.The complement with respect to the two-dimensional plane of an embedding is a collection of two-dimensional regions, from now on faces. Since we consider well-constrained problems, every face is homeomorphic to an open, regularized disc. An embedding of a planar graph has an external or unbounded face however, none of the faces of the embedding have particular privileges. In general, the embedding of a planar graph is not unique.Each face is bounded by a circuit of mapped vertices that unambiguously describe the face. Fig. 1 depicts a planar embedding of a graph with five faces. Facefu=〈a,b,d,f,g,e,c〉is the unbounded face and the other faces aref1=〈a,b,c〉,f2=〈b,d,e,c〉,f3=〈e,c〉andf4=〈d,f,g,e〉.In this paper we consider constraint problems in the Euclidean space defined by giving a set of geometric elements like points, lines, line segments, circles and circular arcs, along with a set of relationships, called constraints, like point–point distance, angle between straight lines, incidence and tangency.Among the many general, powerful and efficient methods to solve systems of geometric constraint problems we focus on the constructive, graph-based approach. The method first transforms the problem input at the user interface into a constraint graph,G=(V,E), where verticesV(G)stand for geometric elements and edgesE(G)stand for geometric constraints.Geometric constraint problems we consider can be abstracted as graphs that belong to a class called tree decomposable or triangle decomposable graphs. Let us recall here the basic concepts. For a more in depth formal development of this topic see  [7] and  [10].First we introduce the concept of set decomposition illustrated in Fig. 2. LetSbe a set with, at least, three different members, saya,b,c. We say that three subsets ofS, sayS1,S2andS3is a set decomposition ofSif (i)S1∪S2∪S3=S, (ii)S1∩S2={a}, (iii)S1∩S3={b}and (iv)S2∩S3={c}. Shared geometric elementsa,bandcare called hinges.Next we recall the concept of set decomposition of a graph. IfG=(V,E)is a constraint graph, the subsetsV1(G),V2(G)andV3(G)define a set decomposition ofGif they are a set decomposition ofV(G)and for every edgee=(v1,v2)withe∈E(G),v1,v2∈V(Gi)for somei,1≤i≤3. Roughly speaking, a set decomposition of a graphG, is a set decomposition of the set of verticesV(G)such that the two ends of each edge belong to a given subset of vertices.Finally we recall the concept of tree decomposition of a graph illustrated in Fig. 3.LetG=(V,E)be a graph. We say that a ternary treeTis a tree decomposition ofGif1.V(G)is the root ofT,Each nodeV′⊂V(G)ofTis the father of exactly three nodes, sayV1′,V2′,V3′, which are a set decomposition of the subgraph ofGinduced byV′(G), andEach leaf node contains exactly two vertices{a,b}ofVsuch that edge(a,b)is inE(G).IfG=(V,E)is the graph of an abstract geometric constraint problem, a tree decomposition ofGcan be seen as a construction plan that solves the problem at hand. Each node in the tree stands for a rigid object, called cluster, built on the geometric objects included in the node. Leaf nodes represent elemental placement problems corresponding to two geometric elements and the constraint defined on them. Examples are: two points at a given distance, a point and a straight segment at a given distance, two straight segments at a given angle and so on.Each internal node in the tree decomposition represents the merging of three solved clusters into a larger rigid cluster by application of a specific solving rule. The root node includes all the geometric elements in the problem and represents a solution instance.In this section we describe an algorithm to compute a set decomposition of a constraint graph. A recursive application of this algorithm yields a decomposition of a tree decomposable graph. Decomposition algorithms for 0-connected and 1-connected geometric constraint graphs are trivial. Besides, Todd in  [37] reported a simple method to decompose graphs by isolating vertices of degree two. Therefore in this work we focus on decomposing biconnected constraint graphs whose vertices have degree three or higher. As we have said, in this work we focus on decomposing graphsG(V,E)for well-constrained geometric problems for which the two following relations hold  [28],1.|E|=2|V|−3,For each subgraphG′(V′,E′)withV′⊂VandE′⊂E, the relationship|E′|≤2|V′|−3.The main idea underlying the algorithm is that if there is a planar embedding of either the graphGor a graph resulting from a specific transformation ofG, where two faces share three vertices, say{a,b,c}, then these vertices are hinges forGthat define a set decomposition ofV(G).The algorithm is based on the decomposition of a graphG=(V,E), according to the bridges induced inGby a circuitC, and is inspired in the algorithm for finding the triconnected components of a graph reported by Miller and Ramachandran  [30]. IfG=(V,E)is the geometric constraint graph, the algorithm starts by computing a spanning tree forGusing a depth-first search and computing the set of fundamental circuits induced by the spanning tree. Then, the algorithm seeks for a fundamental circuitCwith a set of hinges that define a set decomposition ofV(G). If the algorithm fails in finding a fundamental circuit with a set of hinges, the input graph is not tree decomposable.In what follows we describe in detail each step in the algorithm shown in Fig. 4. We shall illustrate how the algorithm works by taking as a running example the bridge coplanar compound truss depicted in Fig. 5.Fig. 6(a) shows the graphG=(V,E)which captures the truss as a geometric constraint problem. VerticesV(G)are the truss joints and bars connecting two joints define the set of edgesE(V). Here constraints are distances between joints.The algorithm starts by computing a spanning tree to the graphGby applying a depth-first search technique  [33]. Assuming that vertexahas been taken as the starting root, Fig. 6(b) shows the resulting spanning tree. The set of fundamental circuits induced by the spanning tree considered are depicted in Fig. 7. Notice that every chord in the spanning tree induces a fundamental circuit.Following  [32], we recall the concepts of components and bridges induced in a graphG=(V,E)by a subset of verticesS⊂V(G).LetG=(V,E)be a non-separable graph and letS⊆V(G). Consider the partition of the setV−Sinto classes such that two vertices are in the same class if and only if there is a path connecting them which does not include any vertex ofS. Let≡denote this relationship and assume thatV(G)−S/≡={K1,…,Km}. Each classKidefines a non-singular component,H=(V′,E′)ofG, such that•V′⊃Ki,V′includes all the vertices ofCwhich are connected by an edge to a vertex ofKi.E′⊆Econtains all those edges ofE(G)which have at least one end vertex inKi.The dashed circle in Fig. 8shows the classK1defined by the circuitC5, depicted in thick line, in the running truss graph example. The circuitC5has only one class.An edge(u,v)∈E(G), where bothu,v∈S, defines a singular component denotedH=({u,v},{(u,v)}). Therefore a set of verticesS⊂V(G)induces a decomposition ofGinto a set of singular and non-singular components, say{H1,…,Hn}. Note that two components share no edges, and the only vertices they can share are vertices ofS.Consider again the circuitC5=〈b,k,j,c,i,h,d,e〉in the running graph example. The set of components is shown in Fig. 9. The labeled subgraph,H1=({a,e,f,g,b},{(a,e),(a,g),(a,f),(f,g),(f,b),(g,b)})defines a non-singular component. The remaining unlabeled subgraphs correspond to singular components.LetCbe a circuit of the graphGand consider the set of verticesV(C). LetHbe the set of components induced inGbyV(C). A bridge,Bi, is a componentHi∈Hwhose edges do not belong toC. A bridge is said to be singular if the corresponding component is singular, otherwise it is non-singular. The vertices of a bridgev∈V(H)such thatv∈V(C)are called attachments and will be denoted asat(H). In what follows, vertices in bridge attachments are considered sorted according to the circular order defined in the vertices of the circuit which originated the bridges. The set of bridges in the truss graph corresponding to the components in Fig. 9 is depicted in Fig. 10. We denote them asB1=({a,e,f,g,b},{(a,e),(a,f),(a,g),(f,g),(f,b),(g,b)}),B2=({b,j},{(b,j)}),B3=({k,c},{(k,c)}),B4=({c,e},{(c,e)}),B5=({c,h},{(c,h)})andB6=({i,d},{(i,d)}).LetC=〈v1,v2,…,vn〉be the fundamental circuit under consideration and letBbe a bridge with attachmentsat(B)={a1,a2,…,am}⊂V(C)where vertices are sorted according to the circular order inC. We define the span of a bridgeBover a circuitCbysp(B)={v∈V(C)|a1<v<am}. By span length we mean the number of vertices in the span plus two.The algorithm used to compute the set of bridges is a depth-first search slightly modified to account for halting recursive calls when reaching bridge attachments. The algorithm is described in the Appendix in Fig. A.29 whereedenotes an edge inE(G)bounded by verticese.v,e.w∈V(G). In what follows, usual notation for LIFO and FIFO data structures has been used,  [38].A star graph,  [32], is a connected graphG=(V,E)with one vertexv∈Vcalled center with degree greater than 1 and such that for each vertexvi∈V−{v}the degree is 1.Now consider a graphG=(V,E)and a fundamental circuitC⊂V(G)that induces inGthe set of bridgesB={B1,…,Bm}. LetBi=(Vi,Ei)be a bridge inBsuch thatat(Bi)={a1,…,an}⊆Vi. We define the star graphSi=(V,E)associated to bridgeBias the graph such thatV(Si)={x,a1,…,an}, wherexis a new vertex, andE(Si)={(x,aj),1≤j≤n}.LetGbe a graph in the conditions described above. We define the collapsed graph ofGas the graph resulting from replacing each bridgeBiwith the corresponding star graphSi. The algorithm is trivial and is omitted.For the circuitC5=〈b,k,j,c,i,h,d,e〉in the running truss graph example and the set of bridgesBi,1≤i≤6listed above, the collapsed graph resulting by replacing every bridgeBiby the corresponding star graphSiis shown in Fig. 11(a) where each bridge is identified by its center vertex.LetG′be the collapsed graph resulting from replacing the bridges induced by the fundamental circuitCin the graphG=(V,E)with the associated star graphs. LetSiandSjbe two stars inG′attached toC. We say that starsSiandSjinterlace if one of the following two holds,  [32]:1.There are four distinct verticesa,b,c,din increasing order inCsuch that eithera,cbelong toat(Si)andb,dbelong toat(Sj)ora,cbelong toat(Sj)andb,dbelong toat(Si); orat(Si)andat(Sj)share three distinct vertices.LetSiandSjbe two star graphs with centersxiandxjrespectively andxi≠xj. By merging starsSiandSjwe mean replacing these stars with a new oneSijformed by combining the attachments ofSiandSjand identifying the centers. Given a collapsed graphG′, the merged graphG″is obtained fromG′by merging all pairs of stars that interlace.Miller and Ramachandran reported in  [39] on a scan-line linear algorithm to find the merging of a set of star graphs. As described, we understand that as the algorithm scans the set of sorted edges, stars stored in the stack must be sorted from bottom to top according to decreasing indexes of the last attachment of each star graph. This ordering defines an invariant the algorithm must preserve. As far as each vertex in the cycleCis an attachment for at most one star edge, the order defined on the set of vertices and the one defined on the set of edges are coincident and just scanning edges automatically preserves the stack invariant. However, when two or more edges belonging to different stars in the input graph share as attachment a vertex in the cycleC, the stack may store stars which do not interlace with the star the edge at hand belongs to. In this scenario, the stack invariant no longer holds if the star is directly pushed on the stack.To illustrate the situation consider the graph example in Fig. 12. The set of sorted edges is {e0,e4,e2,e6,e5,e3,e1,e7}. After visiting edgese0ande4, the stack stores from bottom to top star bridgesB0andB2. When considering edgee2, we found that star bridgeB1does not interlace with any star in the stack. If star bridgeB1is pushed onto the stack, the stack invariant no longer holds and the algorithm fails.To deal with problems where star bridges attachments are common to more than one star bridge in the input graph, we have generalized the approach reported in  [39]. Our algorithm is outlined in Figs. A.30–A.32. The algorithm uses three main data structures: two bucket-sorted tables to store respectively bridges and edges, and a stack to dynamically manage the set of bridges currently under consideration. Additionally, we use a stack of bridges for housekeeping. So far no attempt has been made to minimize the amount of storage used by the algorithm. Function isTheFirstBridge(bridge,B) in the algorithm of Fig. A.32 returns true if and only if the last edge of the popped bridge,bridge, is no smaller than the last edge of the current bridge,B. See  [39].The main algorithm in Fig. A.30, first merges bridges with the same span. Next edges are sorted in increasing order of their attachment inV(C). Edges with the same attachment are sorted in increasing order of the last edge of the bridge they belong to with ties broken by ordering in decreasing order of the first edge of bridges they belong to, [39]. Since no two bridges have the same span, ties are always broken. Then the bridge to which the first edge in the sorted edges belongs to is pushed on the stack. The remaining edges are sequentially visited and dispatched according to whether the edge is the last edge, an internal edge or the first edge in the bridge they belong to.The algorithm leverages from merging at the beginning bridges with the same span in three ways. First bridges leading to faces in the final planar embedding whose attachments do not contribute to the set of hinges are removed. Consider a circuitCwith bridgesBiandBjsuch thatsp(Bi)=sp(Bj)andBj⊂Bias depicted in Fig. 13(a). Clearly, vertices common toat(Bi)andV(C)are just the first and last vertices inat(Bi)which are coincident respectively with the first and last vertices inat(Bj). Therefore the contribution of bridgeBito the set of hinges is subsumed byBjand there is no need for further consideringBi.Then it is easy to see that if two bridges, sayBiandBj, share three attachments and at least one of them has more than three vertices, the first part of the interlacing definition given in Section  4.4 holds. Thus, the second part of the definition concerning bridges which share three attachments is introduced just to consider the case where bridgesBiandBjhave both exactly three attachments common to both bridges. See Fig. 13(b). From the point of view of how bridgesBiandBjcontribute to the existence of hinges, clearly we only need to consider one of them. Thus merging them does not result in the loose of any hinge. Besides, the merging of these bridges frees our merging algorithm from the need of checking for the second part of the interlacing definition.Finally, ifsp(Bi)=sp(Bj)andBiorBjor both have four or more attachments, then eitherat(Bi)=at(Bj)and one of the bridges can be removed orBiandBjinterlace and can trivially be merged.Fig. 11(b) shows a collapsed graph and the corresponding merged graph output by our algorithm. Notice that now merged star bridges with center verticesx23andx56do not interlace. Moreover the resulting merged graph has a planar embedding. See Even,  [32].The next stage is to compute a planar embedding for the planar merged graphG″induced in the input graphGby a fundamental circuit. In the running case we consider the circuitC5=〈b,k,j,c,i,h,d,e〉depicted in Fig. 7.Many general algorithms to compute embeddings of planar graphs have been published. See, for example  [40,35,36]. However we are interested in finding a specific embedding. According to the Jordan Curve Theorem,  [41], embedding the circuitCin the plane results in a planar embedding with two faces, one bounded face,fb, and one unbounded face,fu. See Fig. 14. We want our embedding to preserve the bounded facefb.We assume that circuit verticesV(C)are circularly labeled with increasing label values and that bridges attachments are accordingly sorted. Moreover, we assume that if the circuit under consideration isC=〈v1,v2,…,vn〉, the attachments of each bridgeat(Bi)={vi1,vi2,…,vim}fulfillv1≤vi1andvim≤vn. Notice that this assumption entails, at most, a coherent relabeling of vertices in the circuit and bridges.Our algorithm first sorts edges in the merged graph in increasing order of their attachments in circuitC. Notice that given a vertexv∈V(C), the number of edges incident onvwhich are internal to some bridge is at most one. Otherwise, the merged graph would have at least two interlacing star bridges. The algorithm is described in Fig. A.33 whereL=L+outList+xList+inListmust be understood as a list append.Then, for each face in the planar embedding, the scan-line sequential algorithm described in Fig. A.34 extracts the set of vertices that the face shares with the cycle verticesV(C).The algorithm is based on two observations. First notice that any edge incident on a vertexv∈V(C)is either the first edge of a bridge, an internal edge or, the last edge of a bridge. If the edge is the first one a new face in the embedding is found. If the edge is internal to a bridge then a face has been completed and a new one has been found. Finally, if the edge is the final edge of a bridge, a face has been completed.Now note that, given a face of the planar embedding, we want to identify the set of vertices common to the face at hand and the face bounded by the cycleC. Consider two bridges, sayBiandBj, with spanssp(Bi)andsp(Bj)such thatsp(Bj)⊆sp(Bi). Clearly, faces generated by bridgeBicannot include vertices insp(Bj). To formalize this idea, we define the concept of covered vertex as follows. We say that a vertexv∈V(C)is covered by the bridgeBin the merged graph ifv∈sp(B). To capture the covering property, the algorithm associates with each vertexv∈V(C)a label which initially identifies the vertexvand that takes value ’x’ whenever vertexvis covered by a bridge.For the merged graph in the running example given in Fig. 11(b), the set of faces in the resulting planar embedding are shown in Fig. 15. The faces defined by the vertices aref1=〈b,x23,c,x4,e,x1〉,f2=〈b,k,x23〉,f3=〈k,j,x23〉,f4=〈j,c,x23〉,f5=〈c,x56,d,e,x4〉,f6=〈c,i,x56〉,f7=〈i,h,x56〉,f8=〈h,d,x56〉andfu=〈b,x1,e〉.LetG=(V,E)be a graph andCa fundamental circuit inG. LetG′be the corresponding merged graph andFthe set of faces of a planar embedding ofG′. We will show later on that if there are two facesfi,fj∈Fsuch thatfi∩fj={va,vb,vc}⊂V(G)thenva,vb,vcare hinges that define a set partition ofV(G)and therefore decomposeGinto three clusters. In our algorithm we fix the bounded facefb, defined by the circuit under consideration, as one of the two faces to be checked.In the planar embedding for the case study at hand shown in Fig. 15, the set of faces is{fb,f1,f2,f3,f4,f5,f6,f7,f8,fu}. We can see that facesfbandfushare vertices{b,c,e}, therefore they are hinges that define inV(G)the set partitionV1={a,e,b,f,g},V2={b,j,c,k}andV3={c,e,d,h,i}which induce the graph decomposition into clustersG1,G2andG3shown in Fig. 16.In Section  4 we have illustrated the concepts involved in our approach with the bridge coplanar compound truss case depicted in Fig. 5. To further illustrate how the approach works, we consider now a 2D cross section that will be used to model a 3D shape by sweeping it along a given trajectory. The 2D cross section depicted in Fig. 17is adapted from  [20].Our approach only considers constraint problems where geometric elements have two degrees of freedom. Therefore, circles and arcs have fixed radii and what needs to be placed with respect to other geometries is just their centers. In these conditions, the 2D cross section includes 14 points and 11 segments. Constraints include point–point distances, perpendicular point–segment distances and segment–segment angles. They are depicted in Fig. 17 as thin lines. Distance constraints are depicted as straight segments with arrows, arbitrary angle constraints are depicted as arcs of circle while 90° angles are depicted as a pair of perpendicular straight segments with a common bound.The constraint graph is shown in Fig. 18. Geometric elements are depicted as the graph vertices. Constraints are translated as graph edges. Since the problem is well-constrained,  [28], with|V|=25and|E|=47, the Laman relation,|E|=2|V|−3, holds. It is routine to check that for each subgraph,|E′|≤2|V′|−3also holds.As explained in Section  4 in a preprocessing step, our approach trivially solves constructions corresponding to geometric elements whose nodes in the constraint graph have degree two, that is, geometric elements on which just two constraints have been defined. After sequentially removing degree two vertices, the connectivity of the graph to be further considered is two or higher. The graph is shown in Fig. 19(a). Fig. 19(b) shows a different embedding of the same graph redrawn for the sake of readability in what follows.Assume that the spanning tree to the constraint graph computed by the algorithm is the one depicted in Fig. 20(a). Then the set of fundamental circuits induced by the spanning tree in the graph is shown in Fig. 20(b).Assume now that, when looping over the set of fundamental circuits, the algorithm in Fig. 4 considers the circuitC6=〈l2,p12,p13,l10,l11,p1,l1,p2〉shown in Fig. 20(b). The planar embedding of the merged graph resulting from computing bridges and collapsing the graph is given in Fig. 21. Up to two faces in the planar embedding which share three vertices with the bounded facefbcan be identified. The pair of faces(fb,f2)share vertices{l2,p12,l1}and the pair(fb,f1)share the vertices{l2,l1,p2}. Therefore two different decompositions can be performed.When at a given decomposition step two or more possible different decompositions exist, our algorithm does not control, so far, which one is chosen. As a matter of fact the specific decomposition chosen does not matter for the final decomposition for tree decomposition-based DR-planners are canonical,  [42,10]. Thus, if we assume that the algorithm identifies first the triple of vertices{l2,p12,l1}corresponding to the pair of faces(fb,f2), the decomposition step yields the clustersG1,G2andG3shown in Fig. 22. Next the algorithm is recursively applied to graphsG1andG3. Notice thatG2includes two geometries and one constraint on them therefore it is a trivial geometry placing problem and no further decomposition is needed.In this section we show that the decomposition algorithm described so far is correct. First we establish the relationship between graph hinges and fundamental circuits. Then we show that transforming the input graph into the merged graph preserves hinges. Next we prove that the resulting merged graph is planar. Finally we prove the main result: a merged graph is tree decomposable if and only if there is a planar embedding with two faces which share three or more vertices.The strategy of our algorithm relies on the fact that given a spanning tree for a biconnected, tree decomposable constraint graph, hinges are always included in some fundamental circuit of the graph related to the spanning tree. In what follows, if{a,b,c}are hinges to a biconnected decomposable graphG=(V,E)we will denote byGab,GbcandGcathe graphs resulting from the set decomposition ofGsuch thatGab∩Gbc=b,Gbc∩Gca=candGca∩Gab=a.We start by proving the following lemma.Lemma 6.1LetG=(V,E)be a biconnected, tree decomposable graph with hinges{a,b,c}and clustersGab,GbcandGca. LetCbe a circuit inG. Then one of the following two holds1.CircuitCshares vertices with clustersGab,GbcandGca. Furthermore{a,b,c}⊆V(C).V(C)is a subset of eitherV(Gab)orV(Gbc)orV(Gca).ProofFor the first case just apply the definition of tree decomposition of a graph. See Fig. 23(a).For the second case assume, without loss of generality, thatCis a circuit ofGsuch that it shares vertices withV(Gab)andV(Gbc)but has no vertices in common withV(Gca). See Fig. 23(b). For a contradiction letu,vbe two vertices inV(C)such thatu∈V(Gab),v∈V(Gbc)andu≠v. SinceCis a circuit, there are two distinct paths inC, saypuvandpuv′, such that they connect verticesuandv. Both paths must include the hinge{b}=V(Gab)∩V(Gbc)thereforeCis not a circuit.□Now we show that if a circuitCshares vertices with clustersGab,GbcandGca, thenCis a fundamental circuit ofG.Theorem 6.1LetG=(V,E)be a biconnected tree decomposable graph with hinges{a,b,c}and letTbe a spanning tree toG. Then there is a fundamental circuit, sayC, such that{a,b,c}⊆V(C).ProofAssume thatG=(V,E)is a tree decomposable, biconnected graph with hinges{a,b,c}that splitGinto clustersGab,GbcandGca. Let{C1,…,Cn}be the set of fundamental circuits ofGwith respect to a spanning treeT.For a contradiction assume that there is no fundamental circuitCi∈{C1,…,Cn}such that{a,b}⊆V(Ci)∩V(Gab),{b,c}⊆V(Ci)∩V(Gcb)and{c,a}⊆V(Ci)∩V(Gca). Then, according to Lemma 6.1, each fundamental circuitCiis a subset of eitherGaborGbcorGca. Consequently, the ring sum of fundamental circuits in clusterGxyresults in circuits which are subgraphs of clusterGxy.SinceGis biconnected, there are two vertex disjoint paths that connect any pair of vertices inV(G). Thus there is a circuit, sayC′, such that it connects the three hinges{a,b,c}, has non empty intersection with clustersGab,GbcandGcaand, by hypothesis is not a fundamental circuit. Therefore,C′can be expressed as the ring sum of some fundamental circuits ofGinduced by the spanning treeT. This fact contradicts the assumption.□Therefore the decomposition algorithm starts by computing a spanning treeTand the set of fundamental circuitsCinduced in the graphG=(V,E)byT.The algorithm iterates over the set of fundamental circuits already computed searching for a planar embedding with two faces sharing three vertices inV(G). For each fundamental circuit, the decomposition algorithm computes the bridges, the collapsed graph and the merged graph. Here we need to prove that the algorithm preserves the hinges of the given graph.Assume thatG=(V,E)is a biconnected, tree decomposable planar graph with hinges{a,b,c}on the fundamental circuitC⊂V. Hinges define inCthree circuit segments, sayCab,CbcandCca, where eachCuvdefines a path that connects verticesuandvalong the circuitCwhich does not include the third hinge. See Fig. 24.In the following, when we refer to a circuit segmentCuv, withu,v∈{a,b,c}, we assume thatu≠vand thatCuvandCvuare the same circuit.We first prove that each bridge is attached to just one circuit segment induced by the hinges in the fundamental circuit under consideration.Lemma 6.2LetG=(V,E)be a biconnected tree decomposable graph,C⊆Ga fundamental circuit andB={B1,…,Bk}the set of bridges induced byCinG. Assume that{a,b,c}⊆V(C)are three distinct vertices which induce inCthe segmentsCab,Cbc,Cca. Then,{a,b,c}are hinges ofGif and only if the attachments of each bridgeBi∈Bbelong to eitherCaborCbcorCca.ProofFor the if part assume that{a,b,c}are hinges ofG,v,ware two different vertices inat(Bi)and there are two different segments ofC, sayCabandCca, such thatv∈Cabandw∈Cca. See Fig. 24. SinceBiis connected, there is a path inBiconnectingvandw. Thus{a,b,c}are not hinges ofG.For the only if part assume that∀Bi∈B, there arex,y∈{a,b,c}such thatat(Bi)⊆Cxy. Now we can define the subgraphsGxy=Cxy∪{Bi∈B|at(Bi)⊆Cxy}forx,y∈{a,b,c}. Note thatG=⋃x,y∈{a,b,c}GxyandGab∩Gca=a,Gab∩Gbc=bandGbc∩Gca=c. ThusGxyis a set decomposition ofGand{a,b,c}is a set of hinges.□Next we show that collapsing bridges does not change the connectivity of their attachments.Lemma 6.3LetG=(V,E)be a biconnected, tree decomposable graph,Cbe a fundamental circuit ofGand letB={B1,…,Bk}be the set of bridges induced byV(C). LetG′be the collapsed graph resulting from replacing eachBi∈Bwith the corresponding star bridge. Then, vertices{a,b,c}are hinges ofGif and only if they are hinges inG′.ProofJust notice that vertices in the circuitCand bridges attachments are not involved in the replacement of a bridge with a star graph. Therefore vertices inCand bridges attachments are neither created nor removed.□Next we proceed to prove that computing the merged graph also preserves hinges. Let us start proving that two bridges in the collapsed graph interlace only if they are attached to the same fundamental circuit segment.Lemma 6.4LetG=(V,E)be a biconnected tree decomposable graph. Leta,b,c∈Vbe hinges that define in the fundamental circuitCthe circuit segmentsCab,Cbc,Cca. LetB={B1,…,Bk}be the set of bridges induced byCinGands(B)={s(B1),…,s(Bk)}the set of corresponding star bridges. If two star bridgess(Bi),s(Bj)∈s(B)interlace, then there is a circuit segmentCuvsuch thatat(s(Bi))⊆V(Cuv)andat(s(Bj))⊆V(Cuv).ProofConsider that each bridgeBiis transformed into a star bridges(Bi)preserving attachments, that is,at(Bi)=at(s(Bi)). Now apply Lemma 6.2.□The next step is to show that the process of merging bridges in the collapsed graph preserves hinges.Lemma 6.5Merging star bridges preserves hinges.Assume that the fundamental circuit isCand the hinges are{a,b,c}. By Lemma 6.4, merging star bridges only merges bridges whose attachments belong to the same fundamental circuit segment eitherCab,CbcorCca. Therefore{a,b,c}are hinges for the merged graph.□Therefore, we have the following result.Theorem 6.2LetG=(V,E)be a biconnected tree decomposable graph with{a,b,c}vertices on the fundamental circuitCofG. Thena,b,care hinges to the collapsed graph and to the merged graph induced by the fundamental circuitCinGif and only ifa,b,care hinges to the graphG=(V,E).ProofApply Lemmas 6.3 and 6.5.□The goal now is to show that the resulting merged graph is planar.Lemma 6.6LetG=(V,E)be a biconnected, tree decomposable graph andCa fundamental circuit with hinges{a,b,c}. LetG′andG″be respectively the collapsed and the merged graphs induced by hinges{a,b,c}inC. ThenG″is planar.ProofSee Even,  [32], page 150.□LetG=(V,E)be a planar graph and letDbe a planar embedding ofG. Each facefi∈Dis bounded by a circuit ofGand there is one unbounded face inD, called the external face. Recall that the embeddingDis not unique.Theorem 6.3LetG=(V,E)be a planar graph and letDbe an embedding ofG. For every facefinD, there exists a planar realization, sayD′, of the same graph, which has the same set of faces and such that the faceFis the external face inD′.ProofSee Even,  [32].□Now we proceed to prove the correctness of the last step of the decomposition algorithm. LetG=(V,E)be the input graph of the decomposition algorithm and letG′be the corresponding merged graph. The goal now is to find one embeddingDofG′and two facesfi,fj∈Dsuch that they share three or more vertices. We will show that if the number of shared vertices is three, they are the hinges of the tree decomposition ofG. If there are more than three shared vertices, the problem is underconstrained and any subset of three shared vertices are hinges.Theorem 6.4LetG=(V,E)be a biconnected planar graph.Gis tree decomposable with hinges{a,b,c}⊆Vif and only if there is a planar embeddingDwith two facesfi,fj∈Dsuch that{a,b,c}⊆boundary(fi)∩boundary(fj).ProofWe first prove that if{a,b,c}are hinges that decompose the graphG, there is a planar embeddingDofGwith two faces ofDwhose boundaries share the hinges.LetG=(V,E)be a biconnected tree decomposable planar graph with hinges{a,b,c}. LetG′be the graph resulting from collapsing and mergingGwhere hinges{a,b,c}induce the clustersGab′,Gbc′,Gca′. Since according to Lemma 6.6G′is a planar graph, subgraphsGab′,Gbc′,Gca′are also planar. Now by Theorem 6.1 there is a fundamental circuitCofG′which includes hinges{a,b,c}. Since a circuit is planar,Ccan be embedded in the plane defining two faces. One face is bounded, sayfb, and the other face is unbounded, sayfu, as illustrated in Fig. 25(a). Let us denote this embedding byD.We build an embedding ofG′with all the faces drawn within the bounded facefbofDas follows. Consider the clusterGab′. Depending on the cardinality ofV(Gab′), there are two possible different situations. If|V(Gab′)|=2, then the cluster is coincident with the fundamental circuit segmentCaband the set of faces in the current embeddingDremains unchanged. See Fig. 25(b).Assume now that|V(Gab′)|≥3. The clusterGab′is planar thus it can be embedded within the bounded facefbinDstarting the embedding from vertices and edges in the fundamental circuit segmentCab. Biconnectivity guarantees that there is another path, sayPab, such that it connects vertexawith vertexb, bounds the embedding and splits facefbinto two faces,R1andR2. See Fig. 25(c).According to Lemma 6.4, bridges included in a cluster are such thatV(Gab′)∩V(Cbc)={b},V(Gab′)∩V(Cca)={a}andV(Gbc′)∩V(Cca)={c}. Therefore, by Theorem 6.3, there is an embedding ofGab′within the face labeledR1such that the embedding exactly shares vertexawith circuitCcaand vertexbwith circuitCbc. See Fig. 26(a). Similarly, graphsGbc′andGca′can be embedded in faceR2resulting in an internal face, labeledfbin Fig. 26(b), which always shares with the unbounded facefuhinges{a,b,c}. Then, by Theorem 6.2,{a,b,c}are hinges for the given graphG=(V,E). The fact that replacing the embedding of each clusterGxy′, sayDxy′, with the embedding of the corresponding subgraphGxy⊂Gthat originated it affects just faces and vertices inDxy′, completes the proof.Assume now that there is a planar embeddingDof graphG=(V,E)and two facesfiandfj∈Dwhich share vertices{a,b,c}, as illustrated in Fig. 27(a). Then the set of vertices{a,b,c}induces a partition ofV(G)into three subsetsVab,VbcandVcasuch that any path connecting vertexv∈Vxywith any vertexznot inVxymust include either vertexxor vertexy. Assume that there is a path between a vertex inVaband a vertex inVbcwhich does not include the vertexbcommon toVabandVbc. There are two different situations illustrated in Fig. 27(b). Consider first the case where at least one of the vertices connected by the path does not belong to the facefj, say verticesvandwin Fig. 27(b). Then the graph is no longer planar as assumed from the beginning. Now consider the case where the path connects two vertices, sayuandwshared by the facefjand the setsVabandVbcrespectively. Then facesfiandfjno longer share the vertexband the setsVab,VbcandVcado not define a partition ofV(G). □Thus we have proved the following result.Corollary 6.1The algorithm given inFig.  4   computes a set decomposition of a biconnected graph, if one exists.First we analyze the worst case running time for the work done by the basic decomposition step algorithm given in Fig. 4, that is the work done by our algorithm outside the recursive calls. Then we analyze the running time for the whole recursive DR-Planner. We apply the usual unit-cost operations, unbounded memory random access machine computational model which have unit cost for read and write access to all of its memory cells,  [43].Given the constraint graphG=(V,E), the first step in the algorithm computes a spanning treeTand then computes the set of associated fundamental circuits ofG. Both the spanning treeTand the set of fundamental circuits are computed by applying a depth-first search algorithm. The spanning treeTis computed in a worst case time given byO(|V|+|E|), [44]. Identifying the fundamental circuits as cycles inTamounts to, at most, visiting all the edges inE, therefore, the running time isO(|E|). Since for well-constrained and under-constrained graphs, the Laman relation can be written as|E|≤2|V|−3,  [28], we conclude that the worst case running time for computing the spanning tree and fundamental circuits isO(|V|).The algorithm that computes the set of bridges described in Fig. A.29 has two parts. In the first step the algorithm finds the set of singular bridges, that is, those bridges which include just one edge incident on two vertices inV(C). Trivially, the running time isO(|V(C)|). The second part of the algorithm is a depth-first search approach modified to account for halting the backtracking when a vertex inV(C)is reached. Therefore the overall worst running time isO(|V|).Collapsed bridgesB′are computed by collapsing each bridge inB. Clearly the worst running time needed to collapse the bridges inBisO(|B|). The number of attachments in a singular bridge is two and for a non-singular bridge the number is two plus, at least, one internal bridge attachment. That is, for each bridgeBi∈B, we have|V(Bi)|≥2. Hence the total number of bridges is|B|≤|V(G)/2|. Computing the collapsed graph entails visiting once each vertex inV(G)−V(C). Since|B|≤|V(G)/2|and since the total number of visited vertices is|V(G)−V(C)|<|V(G)|, the total running time needed to collapse bridges isO(|V|).The set of merged bridges{B1″,…,Bn″}is computed by applying to the set of collapsed bridgesB′the sequential scan-line algorithm described in Section  4.4. This algorithm merges a set of star subgraphs where interlacing occurs and is implemented in linear time with respect to the total number of stars attachments. In our case, the graph is derived from a well-constrained Laman graph therefore the number of attachments is at most|V(G)|and the worst running time isO(|V|).Computing the planar embedding includes two steps. First the set of edges is sorted by the algorithm given in Fig. A.33. Each vertex in the cycleV(C)is visited once and the algorithm can be implemented in linear time with a bucket sort. Then each face in the planar embedding is extracted by the algorithm in Fig. A.34 as the set of vertices the face shares withV(C). Edges in the merged graph which are either the first or the last edge in a bridge are visited once while each edge internal to a bridge is visited twice. Since the merged graph is planar, the Euler relation|V|+f−|E|=2, wherefis the number of faces, holds  [32]. The number of faces infis fixed once|V|and|E|are fixed. Therefore the worst running time for computing the planar embedding isO(|V|).The basic tree-decomposition step algorithm described in Fig. 4 loops over the set of fundamental circuits. Then, for each circuit, the algorithm loops over the set of faces in the planar embedding. Therefore, the worst case running time isO(|V|2).The DR-planner computes the decomposition plan by recursively applying basic tree-decomposition steps. We show the following result.Lemma 7.1Given a tree-decomposable biconnected graph,G=(V,E), the DR-planner based on the tree-decomposition given inFig.  4   computes a tree-decomposition inO(|V|2)time.ProofConsider biconnected graphs with|V|>3. At each decomposition step our DR-planner divides the constraint graphG=(V,E)into three subgraphs,G1=(V1,E1),G2=(V2,E2)andG3=(V3,E3). Under the assumption that the biconnected constraint graph is well-constrained, the number of vertices in each subgraph, say|Vi|, is roughly|V|/3. We have shown that the amount of work done outside the recursive calls isO(|V|2). Therefore the total amount of work done by our recursive DR-planner can be expressed as a function of the cardinality of the set of vertices,|V|, asT(|V|)=3T(|V|/3)+O(|V|2).This recurrence relation follows the patternT(n)=aT(n/b)+nc, wherea=3,b=3andc=2. Hence we have thatc>logb(a)+ϵwithϵ>0and according to the generalization of the Master Theorem  [45] proposed by Akra and Bazzi in  [46], the work done by our recursive DR-planner isT(|V|)=O(|V|2).□

@&#CONCLUSIONS@&#
