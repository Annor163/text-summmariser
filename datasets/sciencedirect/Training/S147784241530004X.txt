@&#MAIN-TITLE@&#
Compiling and verifying SC-SystemJ programs for safety-critical reactive systems

@&#HIGHLIGHTS@&#
Introduction of safety-critical subset of the SystemJ language called Safety-Critical (SC) SystemJ.Automata-based compilation approach for the SC-SystemJ language.A tool-chain for verifying correctness properties (e.g. liveness and safety) of the SC-SystemJ programs and generating executable from the verified code for deployment.The new compiler generates both faster and smaller executable compared to the original SystemJ compiler.

@&#KEYPHRASES@&#
SystemJ,SC-SystemJ,Safety-critical,Model-checking,Verification,Compilation,

@&#ABSTRACT@&#
Most of today's embedded systems are very complex. These systems, controlled by computer programs, continuously interact with their physical environments through network of sensory input and output devices. Consequently, the operations of such embedded systems are highly reactive and concurrent. Since embedded systems are deployed in many safety-critical applications, where failures can lead to catastrophic events, an approach that combines mathematical logic and formal verification is employed in order to ensure correct behavior of the control algorithm. This paper presents What You Prove Is What You Execute (WYPIWYE) compilation strategy for a Globally Asynchronous Locally Synchronous (GALS) programming language called Safey-Critical SystemJ. SC-SystemJ is a safety-critical subset of the SystemJ language. A formal big-step transition semantics of SC-SystemJ is developed for compiling SC-SystemJ programs into propositional Linear Temporal Logic formulas. These LTL formulas are then converted into a network of Mealy automata using a novel and efficient compilation algorithm. The resultant Mealy automata have a straightforward syntactic translation into Promela code. The resultant Promela models can be used for verifying correctness properties via the SPIN model-checker. Finally there is a single translation procedure to compile both: Promela and C/Java code for execution, which satisfies the De-Bruijn index, i.e. this final translation step is simple enough that is can be manually verified.

@&#INTRODUCTION@&#
What You Prove Is What You Execute (WYPIWYE) is a paradigm first proposed by Berry [1] for execution of safety-critical systems – systems in which incorrect program behavior can lead to serious damage including loss of life. The WYPIWYE paradigm has been successfully applied to compilation of languages with a formal semantics such as Esterel [2], Lustre [3] and Signal [4]. The usual approach to verifying properties of a program is via a model-checker [5,6]. Model-checking properties on controllers developed in synchronous languages have been successful since these languages are based on a formal semantics. The semantics for both sequential and concurrent computation allows one to generate models or embed the compiler generated code into model-checkers, which can then be used to verify properties of programs. Model-checking, with its complete state exploration and counter example (witness) generation, greatly complements the standard programming approach of unit testing for bug detection in safety-critical programs. In this paper we extend the WYPIWYE approach to safety-critical programs developed in Globally Asynchronous Locally Synchronous (GALS) [7] languages, in particular SystemJ. GALS is an extension of the synchronous Model of Computation (MoC), wherein a number of synchronous islands are composed asynchronously to achieve a given task.Although a rigorous study of verification of GALS systems is important in itself, our motivation for verification is derived from practical needs. In this paper we verify properties on GALS programs designed in the Safety-Critical SystemJ (SC-SystemJ) programming language, which is a subset of the SystemJ language [8] suitable for verifying functional correctness properties of safety-critical systems. The SystemJ language extends Esterel style synchrony with CCS/CSP [9,10] style asynchrony and rendezvous channel communication between synchronous program islands. Java is used for data computation. SystemJ is based on formal semantics and is being used to design different types of embedded systems [11,12] including those used in industrial automation and control. Those systems, consist of components, especially, embedded controllers that need safety and real-time guarantees within a larger context. During our study of industrial control systems (manufacturing and home automation systems) we found that the critical control components usually use pure (binary) signals due to the nature of controlled system. Thus designers only use binary signals and channels for programming the critical low-level control components, while Java data-support is used to build higher level of intelligence such as high-level decision making and cloud support. SystemJ currently lacks the tools to verify these safety-critical parts of the overall system, leaving a large gap, which in our studies we found cannot be fulfilled using unit testing alone. Static (design time) guarantees are essential to forward looking manufacturers. Thus, following this pressing industrial demand for verification tools of critical control dominated components, in this paper we provide a technique for WYPIWYE control dominated SC-SystemJ GALS program compilation.The main advantage of the compilation techniques presented in this paper is the ability to verify properties of programs before deployment. The technique presented in this paper transforms SC-SystemJ program into an intermediate format; a network of Finite State Machines (FSMs). Promela [13] code is generated from this intermediate format. These Promela models, which capture the behavior of the SC-SystemJ program, are used for verifying the functional correctness properties via the SPIN model-checker [14]. The verified model is then used for carrying out a simple syntactic translation into ‘C/Java’ executable, thereby guaranteeing the WYPIWYE paradigm as stated by Berry [1].The proposed WYPIWYE tool-chain flow for generating WYPIWYE executables is shown in Fig. 1. The tool-chain flow is as follows:1.An informal (natural language) and control logic and (optionally) plant model descriptions are converted into SC-SystemJ programs.Here, control logic is a program, controlling operations of the system. On the other hand, plant is the environment, providing input stimuli to this control system. Control logic and plant model are then combined together to form a single SC-SystemJ program, making the overall system a closed loop control system for verification. This technique is required for verifying certain types of functional properties of a system, which make certain assumptions on the environment, i.e. the system will halt when the heat or air conditioning is not working. On the other hand, system can be left open, i.e. without a plant model, for verifying the properties which should hold regardless of the event generated from the environment, e.g., verifying the absence of deadlocks in the control logic.Apply inductive semantic transition rules to translate the SC-SystemJ program into a propositional Linear Temporal Logic (LTL) formula.The SC-SystemJ program (optionally combined with a plant) is first converted into a propositional LTL formula. These formulas are then converted into a network of Labeled Generalized Büchi Automata (LGBA) [15], a type of finite state machine that accepts infinite input sequence. Finally, a novel algorithm (cf. Algorithm 3) is applied to transform these automata into a network of deterministic Mealy automata.Generate a network of Promela processes and verify properties on the program.The network of Mealy automata generated in Step-2 is then converted into a network of Promela processes, which is given as an input to the SPIN model checker. Properties specified in LTL formulas are checked on these Promela processes.Generate an executable.If all specified properties are verified with SPIN in Step-3, then the SC-SystemJ control logic is directly compiled into executable C or Java code, using a straightforward syntactic translation technique, and deployed on the target execution platform. If the verification stage fails, a witness (fault trace) is generated and can be used to update the control logic or original specification of the system.The next section further discusses our motivation behind introducing the SC-SystemJ, a safety-critical subset of the SystemJ language.

@&#CONCLUSIONS@&#
In this paper, a novel approach for generation of What You Prove Is What You Execute (WYPIWYE) Globally Asynchronous Locally Synchronous (GALS) programs designed in SC-SystemJ is presented. The approach produces a network of finite state Mealy machine from SC-SystemJ programs automatically, which are then translated into Promela for verification using Linear Temporal Logic (LTL) properties or executable C/Java code. The presented approach is scalable, i.e., the compiler does not run out of memory when compiling SC-SystemJ programs unlike previously described approaches to compilation of purely synchronous languages. This scalability has been achieved by translating SC-SystemJ programs into LTL formulas and then applying novel translation algorithms. The SC-SystemJ compiler generates both smaller and faster executable than the original SystemJ compiler. In the future work, we plan to investigate how to optimize the compiler to reduce runtime complexity.