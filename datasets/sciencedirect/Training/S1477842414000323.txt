@&#MAIN-TITLE@&#
A sparse evaluation technique for detailed semantic analyses

@&#HIGHLIGHTS@&#
We propose a new sparse evaluation technique.The proposed technique can be effectively applicable to abstract interpretation-based semantic analyses.We show that our technique effectively improves the scalability of an industrial-strength static analyzer.

@&#KEYPHRASES@&#
Static analysis,Abstract interpretation,Sparse evaluation,Data-flow analysis,

@&#ABSTRACT@&#
We present a sparse evaluation technique that is effectively applicable to a set of elaborate semantic-based static analyses. Existing sparse evaluation techniques are effective only when the underlying analyses have comparably low precision. For example, if a pointer analysis precision is not affected by numeric statements like x≔1 then existing sparse evaluation techniques can remove the statement, but otherwise, the statement cannot be removed. Our technique, which is a fine-grained sparse evaluation technique, is effectively applicable even to elaborate analyses. A key insight of our technique is that, even though a statement is relevant to an analysis, it is typical that analyzing the statement involves only a tiny subset of its input abstract memory and the most are irrelevant. By exploiting this sparsity, our technique transforms the original analysis into a form that does not involve the fine-grained irrelevant semantic behaviors. We formalize our technique within the abstract interpretation framework. In experiments with a C static analyzer, our technique improved the analysis speed by on average 14×.

@&#INTRODUCTION@&#
In static analysis, the technique of sparse evaluation has been widely used to optimize the analysis performance [4,27,11,26,17,14]. Sparse evaluation is based on the observation that static analysis sometimes aggressively abstracts program semantics and therefore a number of program statements are irrelevant to the analysis. For instance, typical pointer analyses (e.g., [14,15]) have comparably low precision and not affected by numeric statements such asx≔1. The goal of existing sparse evaluation is to remove such irrelevant statements, which makes the analysis problem smaller and improves the analysis׳ scalability. In the literature, sparse evaluations have been effectively used to improve the performance of pointer analysis [14,30] and classical data-flow analyses [4,27].However, existing sparse evaluation techniques are not effective for elaborate semantic analyses in general. Note that the basic assumption of existing sparse evaluation is that the given analysis problem is simple-minded and hence a number of program statements are irrelevant to the analysis. However, in general semantic analyses, it is not uncommon that the analysis is so detailed that the assumption of sparse evaluation does not hold. That is, such an analysis considers all types of values (e.g., including both numbers and pointers) and almost all statements in the program are relevant to the underlying analysis. For instance, consider an elaborate pointer analysis that considers not only pointers but also numeric values. Then statements likex≔1, which would be irrelevant to simple pointer analyses, are no longer irrelevant and cannot be removed by existing sparse evaluation techniques.In this paper, we present a new sparse evaluation technique for such detailed static analyses. The intuition behind our technique is that, even though an analysis is detailed and a statement is relevant, the analysis is still sparse in a fine-grained way: analyzing the statement uses only small part of its abstract memory. For example, consider analyzing the statementx≔1. The abstract semantics for the statement would update only the value of x but other values, say y, are not involved in the analysis of the statement. To exploit this sparsity, we first reformulate the analysis problem into an equivalent form that is more fine-grained in that semantic equations are expressed explicitly in terms of individual abstract locations. We call this step decomposition. Then, we define two elimination procedures (which we call no-change and no-contribution eliminations, respectively) that remove the fine-grained irrelevant behaviors of the analysis. We present our technique in the abstract interpretation framework [8,6] and prove that the decomposition and elimination procedures are semantics-preserving, which means that our technique maintains the original analysis׳ soundness and precision.Our work provides a general and flexible alternative to the recent sparse analysis framework [23]. Although the goal of ours and the sparse analysis in [23] is the same (i.e., making the analysis sparse), the techniques used are different: the technique in [23] constructs def-use dependencies while we eliminate unnecessary dependencies. This difference makes our technique flexible in controlling the sparseness of the final analysis. We discuss this point in Section 8 in more detail. Furthermore, we generalize the idea of sparse technique in the abstract interpretation framework with arbitrary trace partitioning.We show the effectiveness of our technique in a realistic setting. We implemented our technique on top of Sparrow, an interval domain-based abstract interpreter [18,16,21,22,24]. In experiments, our technique improved the analysis speed from 2 to 59 times, on average 14 times, and reduced peak memory consumption by 29–80%, on average 56%, for a variety of open-source C benchmarks (6K–111K LOC).Overview: We illustrate our technique with an example. Suppose that we analyze the program in Fig. 1(a) with a non-relational analysis: the abstract state of the analysis is a map from the set of abstract locations (simply variables x and y in this example) to abstract values, say numeric intervals [8]. During the analysis, the first statement defines the value of x, the second statement defines y, and the last statement updates y with the value of x. Observe that existing sparse evaluation techniques remove no statements in this example, because all the three statements have some effects on the analysis. On the other hand, our technique works as follows:1.We reformulate the analysis (Fig. 1(a)) into the decomposed form (Fig. 1(b)) in which values of each abstract location are computed separately: each instruction c in Fig. 1(a) is split into (c, x) and (c, y) that hold the values of x and y, respectively. For instance, at node(1,x), the value of x at instruction 1 is stored and value for y at instruction 1 is stored at(1,y). Edge(c,x)→(c′,x′)means that the value ofx′atc′may depend on the value of x at c.In Fig. 1(b), we eliminate nodes that have no effect on the analysis, which we call no-change elimination. Note that, among the six nodes in Fig. 1(b), values are actually updated at nodes(1,x),(2,y), and(3,y). At other nodes (dotted ones in Fig. 1(b)), values are not changed. The goal of this step is to remove such “no-change” nodes from the analysis. We simply remove the nodes and short-circuit their in/outflows, which results in Fig. 1(c). Observe that, after no-change elimination, the value of x from(1,x)is directly propagated to(3,y).In Fig. 1(c), we remove irrelevant input flows, which we call no-contribution elimination. In Fig. 1(c), only the value of x is necessary to update the value of y at(3,y); the value of y is not used at(3,y). So, we remove the “no-contribution” flow(2,y)→(3,y). Other unnecessary flows are also removed, leading to Fig. 1(d).With our technique, the original analysis problem (Fig. 1(a)) is reduced to a smaller problem (Fig. 1(d)). Obviously, fixpoint computation for the smaller problem will be cheaper than the original analysis.Outline: Section 2 describes the family of static analyses that this paper considers. Section 3 defines the decomposition step. Section 4 defines two semantic independence involved in the static analysis defined in Section 2. Section 5 formally presents no-contribution and no-elimination procedures. Section 6 shows how to apply our technique to an example analysis. Section 7 presents the experimental results. Section 8 discusses related work. Section 9 concludes the paper.Notation: In this paper, all functions are considered partial functions. We consider functions that are of typef∈A→B, where A is a set and B is a complete partial order (cpo). We writedom(f)⊆Afor the domain of f. we writef|Cfor the restriction of function f to the domaindom(f)∩C. We writef\Cfor the restriction of f to the domaindom(f)−C. We abuse the notationf|aand f\afor the domain restrictions on singleton set{a}anddom(f)−{a}, respectively. We writef[a↦b]for the function constructed from function f by changing the value for a to b. We writef[a1↦b1,…,an↦bn]forf[a1↦b1]⋯[an↦bn]. We writef[{a1,…,an}↦wb]forf[a1↦f(a1)⊔b,…,an↦f(an)⊔b](weak update). We write[a↦b]∈A→Bfor a function[a↦b](x)=bif a=x, otherwise undefined, i.e.,[a↦b](x)=⊥. For all domains (cpos), we assume an implicit join operator ⊔, ordering relation ⊑, and appropriate⊤and⊥elements. In particular, we define⊔,⊑,⊤,⊥for functions in a pointwise fashion, e.g.,f⊔g=λx.f(x)⊔g(x). We writee.A,e.Bto denote the first and the second element ofe∈A×B, respectively.In this section, we define a class of static analysis that we consider in this paper. We consider transition systems as a program model so that the analysis is general for arbitrary programming language. Thus, our technique is generally applicable to any language.In Sections 2.1 and 2.2, we define the program and its collecting semantics, respectively. In Section 2.3, we abstract the collecting semantics and derive the abstract semantics that we consider. We suppose basic knowledge of the abstract interpretation framework [8,6] and the trace partitioning [19].We describe a program P as a transition system(S,→,Sι), whereSis the set of states of the program,(→)⊆S×Sis the transition relation describing how the program execution progresses from one state to the next state, andSι⊆Sdenotes the set of initial states.We writeS⋆for the set of all finite non-empty sequences of states. When σ is a finite sequence of states, σidenotes the(i+1)th state of the sequence, σ0 the first state, andσ⊣the last state. Given a sequence σ and a state s,σ·sdenotes a sequence obtained by appending s to σ. A sequence σ is said to be a trace of the program P if σ is a partial execution sequence of P, i.e.,σ0∈Sι∧∀i.σi→σi+1. We abuse the notion of transition relation→for traces, i.e.,σ′→σ⟺∃s.σ=σ′·s∧σ⊣′→s.The collecting semantics〚P〛∈P(S⋆)of the program P is the set of all traces of P:〚P〛={σ∈S⋆∣σ0∈Sι∧∀i.σi→σi+1}Note that the semantics〚P〛is the least fixpoint of the semantic functionF∈P(S⋆)→P(S⋆), i.e.,〚P〛=lfpF, defined as follows:F(Σ)≜I∪{σ·s∣σ∈Σ∧σ⊣→s}whereI={s∣s∈Sι}is the set of singleton traces of initial states.We consider the abstract semantics that are obtained from the collecting semantics of the program P by the following Galois connections:P(S⋆)⇆α1γ1(Δ→P(S⋆))⇆α2γ2(Δ→S^)The abstract domain (Δ→S^) is obtained by applying the following two abstractions in order.1.Partitioning abstraction(α1,γ1): we abstract the set of traces(P(S⋆))into partitioned sets of traces (Δ→P(S⋆), whereΔis the set of partitioning indices, e.g.,Δis the set of control points in the program). Suppose we are given a well-chosen partitioning functionδ∈Δ→P(S⋆)such that δ is a partition, i.e.,S⋆=⋃x∈Δδ(x)and∀x,y∈Δ.x≠y⇒δ(x)∩δ(y)=∅. Then, α1 and γ1 are defined as follows: (It is well-known that such α1 and γ1 form a Galois-connection [19].)α1(Σ)≜λc∈Δ.Σ∩δ(c)γ1(ϕ)≜⋃c∈Δϕ(c)By choosing a suitable δ, we can define various partitioning strategies [19]. For example, in imperative languages, a state is often decomposed into a control point inCand a memory state inM, i.e.,S=C×M. We useCas the set of partitioning indices and letδC∈C→P(S⋆)partitionS⋆based on the final control point:δC(c)≜{σ∈S⋆∣∃m.σ⊣=(c,m)}. Then,δCdefines the usual flow-sensitive analysis. Likewise, we can define any other trace partitioning such as flow-insensitivity, context-(in)sensitivity, and path-(in)sensitivity by choosing an appropriate δ.State abstraction(α2,γ2): for each partition, we suppose that the associated set of traces is abstracted into an abstract state (S^) that over-approximates the reachable states of the traces. α2 and γ2 are defined as follows:α2(ϕ)≜λc∈Δ.αS(ϕ(c))γ2(ϕ^)≜λc∈Δ.γS(ϕ^(c))whereαSandγSare abstraction and concretization functions for set of traces such thatP(S⋆)⇆αSγSS^. We assume thatαSabstracts the traces in a way thatS^is a function cpo (complete partial order)L^→V^whereL^is a finite set of abstract locations, andV^is an arbitrary cpo for representing abstract values. All non-relational analyses are expressible in this domain. For example, in numerical analysis that uses interval domain, the abstract memory state is a map from all abstract locations to interval values. In addition, the packed relational domain [7,20,31,2] also fits to this domain. LetPacks⊆P(Var)be a set of variable groups (i.e., packs) such that⋃Packs=Var, andRbe a relational abstract domain such as the octagon domain [20]. Then, the packed relational domain has the form ofPacks→R, which associates each pack with constraints among the variables in the pack. In our framework, we impose thatL^is fixed prior to the analysis, which means that our technique is not applicable to analyses with, for example, dynamic variable packing.We consider abstract semantics that is characterized by the least fixpoint of abstract semantic functionF^∈(Δ→S^)→(Δ→S^)defined as(1)F^(X^)=λc∈Δ.f^c(⨆c′↪cX^(c′)).wheref^c∈S^→S^is the semantic function at partitioning index c and ↪ is the transition relation between partitioning indices such that(↪)⊇{(c′,c)∈Δ×Δ∣∃σ′∈δ(c′).σ′→σ∧σ∈δ(c)}Transition relation ↪includes all the possible transitions between partitioning indices: ↪includes a flow(c′,c)if there exists a traceσ′in partitionc′and the next ofσ′belongs to partition c. Note that transition → is generally unknown prior to the analysis and this is why ↪ is a superset of the possible transition flows. For example, suppose we analyze an imperative language and we useδCas the partitioning function. Then, ↪ is identical to the control flow relation of the program, which is often given before the program execution. When analyzing a functional program, for another example, the transition flows can be approximated before the analysis; ↪ can be given by a separate pre-analysis.The abstract semantic functionF^should be designed to satisfyα○F⊑F^○α(α=α2○α1), then the soundness of the abstract semantics is guaranteed by the fixpoint transfer theorem [9].The first step of our approach is to re-formulate the analysis equation (1) into a fine-grained form, which we call “decomposition”. Note that it is not obvious to identify independencies (irrelevant semantic behaviors) directly from the original analysis given in (1), because the semantic functionf^c∈S^→S^works for abstract states but the independencies are usually defined in terms of individual abstract locations. Thus, we first decompose the original analysis so that the analysis is expressed in terms of each abstract location rather than the entire abstract states. In the case of packed relational analyses, the analysis can be expressed in terms of each variable pack rather than each abstract location. With this decomposition, the elimination procedures, which will be defined in Section 5, become simpler.We first decompose the partitioning indices:Δis refined byL^, yielding ΔdΔd≜Δ×L^Then, the transition relation ↪ is decomposed into↪d:↪d≜{((c′,l′),(c,l))∈Δd×Δd∣c′↪c}That is, each partitioning index (e.g., control point)c∈Δis split by the number (|L^|) of elements inL^. One transitionc′↪cin the original analysis is represented by|L^|2flows{((c′,l′),(c,l))∣l,l′∈L^}in the decomposed analysis.Next, we suppose that each semantic functionf^c∈S^→S^is defined with decomposed functions{f^(c,l)∈S^→V^∣l∈L^}such that(2)f^c(s^)=λl.f^(c,l)(s^)In contrast tof^c(s^)that computes the entire output state for index c,f^(c,l)(s^)computes the value for abstract location l only. Other values, sayl′∈L^, are handled by their respective semantic functions,f^(c,l′).Finally, we define the abstract semantics of decomposed analysis, which is characterized by the least fixpoint of abstract semantic functionF^d∈(Δd→V^)→(Δd→V^)defined as(3)F^d(X^d)=λ(c,l)∈Δd.f^(c,l)(⨆(c′,l′)↪d(c,l)[l′↦X^d(c′,l′)])The following lemma ensures that the decomposed analysis (3) is essentially the same as the original analysis (1).Lemma 1∀c∈Δ,l∈L^.(lfpF^d)(c,l)=(lfpF^)(c)(l).We prove the lemma by showing that the semantic functionF^dis equivalent toF^. BecauseΔd=Δ×L^, we can change the type ofF^d∈(Δd→V^)→(Δd→V^)intoF^d∈(Δ→L^→V^)→(Δ→L^→V^)as follows:F^d(X^)=λc∈Δ.λl∈L^.f^(c,l)(⨆(c′,l′)↪d(c,l)[l′↦X^(c′)(l′)])Then, we can transformF^dintoF^as follows:F^d(X^)=λc.λl.f^(c,l)(⨆(c′,l′)↪d(c,l)[l′↦X^(c′)(l′)])=λc.λl.f^(c,l)(⨆c′↪c⨆l′∈L^[l′↦X^(c′)(l′)])⋯def.of↪d=λc.λl.f^(c,l)(⨆c′↪cλl′.X^(c′)(l′))⋯def.of⊔L^→V^=λc.λl.f^(c,l)(⨆c′↪cX^(c′))⋯λl′.X^(c′)(l′)=X^(c′)=λc.f^c(⨆c′↪cX^(c′))⋯(2)□Note that the abstract semantic function given in (3) involves some independencies. For example, when we analyze statementx≔y, we surely know that the abstract semantic function changes the abstract value of variable x but the function causes no changes for other variables. In addition, in order to change the value of x, only the value of y is necessary and other variables have no contributions to the change. Nonetheless, the function given in (3) naively follows the transition flows of the program, propagating the entire abstract states from all predecessors to the current partitioning index. In this section, we formally define such independencies (no-changes and no-contributions) involved in the analyses.We say a decomposed index(c,l)∈Δdis a no-change if the semantic functionf^(c,l)does not define new information during the analysis. The most obvious case is whenf^(c,l)has identity transference for all input states, i.e.,f^(c,l)satisfies the condition∀s^∈S^.f^(c,l)(s^)=s^(l). That is,f^(c,l)does not modify the value of l but always produces the same value as the value in the input state,s^(l). However,f^(c,l)needs not to have identity transference for all inputs; instead, it is sufficient forf^(c,l)to have identity transference only for those inputs that would occur during the analysis. For example, consider statement⁎p≔1. The semantic function for the statement is not identity for all input states. However, suppose p points to at most location b during the analysis, then, we know that the decomposed semantic functions for other locationsa(≠b)all have identity transference during the analysis because p does not point to other location than b. Thus, in general,(c,l)is a no-change if it satisfies the following condition:(4)∀s^⊑lfp(c,l).f^(c,l)(s^)=s^(l)wherelfp(c,l)denotes the input state to(c,l)at the fixpoint:lfp(c,l)≜⨆(c′,l′)↪d(c,l)[l′↦(lfpF^d)(c′,l′)]Note thats^quantifies over the set of states that possibly occur at index(c,l)during the course of the analysis. Thus, condition (4) means that the semantic functionf^(c,l)does not generate new information during the analysis. We writeNChgfor the set of all no-change indices, i.e.,NChg≜{(c,l)∈Δd∣∀s^⊑lfp(c,l).f^(c,l)(s^)=s^(l)}Note that the above definition is mathematical but not finitely computable. At the moment, suppose that we haveNChgbefore the analysis. In Section 5.4, we will show how to approximateNChgso that it is computable in practice.We say that an abstract locationl′is a no-contribution to(c,l)if the value ofl′does not contribute to changing the value for(c,l), i.e.,(5)∀s^⊑lfp(c,l).f^(c,l)(s^\l′)=f^(c,l)(s^)which means that the value ofl′is not necessary to produce the value off^(c,l)during the course of the analysis. We writeNCon(c,l)for the set of all no-contributions to index(c,l), i.e.,NCon(c,l)≜{l′∈L^∣∀s^⊑lfp(c,l).f^(c,l)(s^\l′)=f^(c,l)(s^)}Note that the above definition is mathematical but not finitely computable. At the moment, suppose that we haveNConbefore the analysis. In Section 5.4, we will show how to approximateNCon.Our goal is to transform the semantic functionF^dto a sparse versionF^sthat does not involve no-changes and no-contributions. As a result, when we analyze a statement, only the relevant input values are involved in the analysis and only the meaningful values are generated from the statement.In this section, we show how to eliminate the independencies. By eliminating them, the original analysisF^dis transformed into its sparse versionF^s. What are actually transformed is↪d; we transform↪dinto its sparse version↪sby eliminating no-changes and no-contributions involved in↪d. With↪s, sparse abstract semantic functionF^s∈(Δd→V^)→(Δd→V^)is defined as follows:(6)F^s(X^s)=λ(c,l)∈Δd.f^(c,l)(⨆(c′,l′)↪s(c,l)[l′↦X^s(c′,l′)])Note thatF^sis only different fromF^din that it is defined over↪srather than↪d. Thus, we can reuse abstract semantic functionf^(c,l)and its soundness results from the original analysis design.We define no-change-elimination and no-contribution-elimination. Because these two transformations remove only the must-independences that do not affect the analysis results,F^sshould preserve both soundness and precision of original analysisF^d.Suppose we are given a no-change index (c, l). Eliminating such a no-change sacrifices neither the analysis’ correctness nor precision because, no-change indices are just placeholders that do not generate new information during the analysis.When (c, l) is a no-change, we remove (c, l) and rearrange the remaining flow edges properly. For example, consider Fig. 2: the leftmost (respectively, rightmost) figure represents the flow relation (↪d) before (respectively, after) applying no-change-elimination to (c, l). In Fig. 2, suppose (c, l) is a no-change point. Then, we observe its two implications: (1) the abstract value associated with (p, l), a predecessor of (c, l), is the only one that is needed to generate the value for (c, l) because the semantic functionf^(c,l)simply propagates the value of (p, l) without any change (in other words, other values such as(p,l′)are not necessary); (2) in order for the value of (p, l) to be propagated to (s, l) and(s,l′), the value needs not pass through (c, l) because the value is not changed byf^(c,l). From these observations, we directly connect the input flow((p,l),(c,l))into all the successors of (c, l), adding the thick flows in Fig. 2(b). Then, we remove (c, l) as well as flow edges connected to (c, l), leading to Fig. 2(c).Formally, given a no-change point (c, l), the no-change-elimination is defined by transformationTnoChg(c,l)∈P(Δd×Δd)→P(Δd×Δd)defined as follows:TnoChg(c,l)(↪)≜(↪)∪{((p,l),(s,l′))∣(p,l)↪(c,l)∧(c,l)↪(s,l′)}⋯\{((p,l′),(c,l))∣(p,l′)↪(c,l)}⋯\{((c,l),(s,l′))∣(c,l)↪(s,l′)}⋯Given a no-change point (c, l),TnoChg(c,l)performs three operations:it connects (p, l) to all of the successors of (c, l);it removes all the inflows((p,l′),(c,l)); andit removes all the outflows((c,l),(s,l′)). In effect, after the elimination, the no-change point (c, l) is ignored during the analysis. The following lemma ensures the correctness ofTnoChg(c,l).Lemma 2Let(c,l)∈Δdbe a no-change point. Let↪dand↪d′be flow relations such that(↪d′)=TnoChg(c,l)(↪d). LetS′andSbelfpF^d′andlfpF^d, respectively, whereF^d′(X^)=λ(c,l)∈Δd.f^(c,l)(⨆(c′,l′)↪d′(c,l)[l′↦X^(c′,l′)])F^d(X^)=λ(c,l)∈Δd.f^(c,l)(⨆(c′,l′)↪d(c,l)[l′↦X^(c′,l′)]).Then,∀(c′,l′)∈Δds.t.(c′,l′)≠(c,l).S′(c′,l′)=S(c′,l′).We prove the lemma by showing that the fixpoint equation ofF^d′is equivalent to the equation ofF^dup to the points that remain after the transformation. For simplicity, consider the case with the following assumptions:L^={l}and↪d={((p,l),(c,l)),((c,l),(s,l))}(it is easy to extend this proof to the general case.). Then, the fixpoint equations ofF^dare as follows:(7)S(c,l)=f^(c,l)([l↦S(p,l)])S(s,l)=f^(s,l)([l↦S(c,l)])We can transform the equation into the fixpoint equation ofF^d′as follows:S(s,l)=f^(s,l)([l↦S(c,l)])⋯by(7)=f^(s,l)([l↦f^(c,l)([l↦S(p,l)])])⋯by(7)=f^(s,l)([l↦S(p,l)])⋯f^(c,l)(s^)=s^(l)By the definition ofTnoChg(c,l),↪d′is{((p,l),(s,l))}. Thus, the fixpoint equation ofF^d′isS′=f^(s,l)([l↦S(p,l)]), which is equivalent to the equations ofF^das derived above. □The second one removes no-contributions from the analysis. It is enough to apply the no-contribution elimination only to the change points where values are ever changed during the analysis, because independencies involved in no-changes are all removed by the no-change elimination.Suppose we are given a flow((p,l′),(c,l))∈(↪d)to a change point. We say the flow is no-contribution flow ifl′∈NCon(c,l). The goal of the no-contribution-elimination is to remove all such flows, which is also safe because no-contribution flows are, by definition, unnecessary in generating new information during the course of the analysis.For each no-contribution flow((p,l′),(c,l)), we simply remove it from↪d. For example, consider Fig. 3: the left (respectively, right) figure represents the flow relation (↪d) before (respectively, after) applying no-contribution-elimination to((p,l′),(c,l)). In Fig. 3, suppose (c, l) is a change point, i.e.,∃s^⊑lfp(c,l).f^(c,l)(s^)≠s^(l), and((p,l′),(c,l))is a no-contribution flow. In this case, we can safely remove the flow because it is unnecessary to generate the value of (c, l).Formally, given a no-contribution flow((p,l′),(c,l)), the no-contribution-elimination is simply defined by transformationTnoCon((p,l′),(c,l))as follows:TnoCon((p,l′),(c,l))(↪)≜(↪)\{((p,l′),(c,l))}.Lemma 3Let((p,l′),(c,l))be a no-contribution flow. Let↪dand↪d′be flow relations such that(↪d′)=TnoCon((p,l′),(c,l))(↪d). LetS′andSbelfpF^d′andlfpF^d, respectively, whereF^d′(X^)=λ(c,l)∈Δd.f^(c,l)(⨆(c′,l′)↪d′(c,l)[l′↦X^(c′,l′)])F^d(X^)=λ(c,l)∈Δd.f^(c,l)(⨆(c′,l′)↪d(c,l)[l′↦X^(c′,l′)])Then,∀(c,l)∈Δd.S′(c,l)=S(c,l).We prove the lemma by showing that the fixpoint equation ofF^d′is equivalent to the equation ofF^d. For simplicity, consider the case with the following assumptions:↪d={((p,l),(c,l)),((p,l′),(c,l))}andl′∈NCon(c,l)(it is easy to extend this proof to the general case.). Then, the fixpoint equations ofF^dare as follows:(8)S(c,l)=f^(c,l)([l↦S(p,l)]⊔[l′↦S(p,l′)])We can transform the equation into the fixpoint equation ofF^d′as follows:S(c,l)=f^(c,l)((l↦S(p,l))⊔(l′↦S(p,l′)))=f^(c,l)([l↦S(p,l),l′↦S(p,l′)])⋯def.of⊔=f^(c,l)([l↦S(p,l),l′↦S(p,l′)]\l′)⋯l′∈NCon(c,l)=f^(c,l)([l↦S(p,l)])⋯def.of\By the definition ofTnoCon((p,l′),(c,l)),↪d′={((p,l),(c,l))}. Thus, the fixpoint equation ofF^d′isS′=f^(c,l)([l↦S(c,l)]), which is equivalent to the equations ofF^das derived above. □The final flow relation↪sis obtained by applying the two eliminations to↪duntil stabilized. No-change-elimination and no-contribution-elimination do not interfere with each other because no-change-elimination is applied only to no-change points and the no-contribution-elimination is applied only to change points. Thus, we can repeatedly apply the transformations in any order. Both transformations eventually terminate because the space Δdis finite. With↪s, we obtain the final sparse semantic function (6).Note that we do not need to apply the transformations until stabilized. Because the analysis semantics is preserved over the elementary step of both transformations (TnoChg(c,l)andTnoCon((p,l′),(c,l))), we can stop the elimination procedures at any desired point.In practice, we need to approximateNChgandNCon. Our method presented so far serves as a purpose of defining a mathematically correct analysis; it does not yet serve for practical uses. The main reason is thatNChgandNConare defined with the original fixpointlfpF^computed; thus, in order to computeNChgandNCon, we need to first computelfpF^, the analysis that we actually want to make sparse. Therefore, we should use approximations ofNChgandNCon, which, from now on, we denoteNChg^andNCon^, respectively. Then, no-change-elimination and no-contribution-elimination are also approximated in that they operate withNChg^andNCon^instead ofNChgandNCon.For correctness,NChg^andNCon^should be under-approximations ofNChgandNCon, respectively. This condition is intuitive and we can easily find a counterexample if the condition is not satisfied. Suppose(c,l)∈NChg^and(c,l)∉NChgfor abstract location (c, l). Performing the no-change-elimination withNChg^is unsafe because (c, l) is not an actual no-change point ((c,l)∉NChg).It is easy to check that the analysis obtained by removing approximated independencies are still correct and precision-preserving. We already proved that eliminating no-changes and no-contributions is safe. The approximated independencies are subsets of concrete ones, i.e.,NChg^⊆NChgand∀(c,l)∈Δd.NCon^(c,l)⊆NCon(c,l), and therefore they are clearly no-changes and no-contributions and removing them is safe. However, because of the approximation, some no-changes and no-contributions would be still present in the final analysis.In this section, we show how our technique is applied to a non-relational static analysis. In Section 6.1, we describe a framework for a simple class of non-relational abstract interpretation, and in Section 6.2, we show how to findNChg^andNCon^for the analysis.Language: We assume that the partitioning indicesΔare control points of the program and each partitioning indexc∈Δis associated with a command. We consider a simple imperative language that has integers and pointers as values. The syntax of the language is as follows:cmd→assign(x,e)∣assign(*x,e)∣assume(x<n)e→n∣x∣&x∣*x∣e+eCommandassign(x,e)assigns the value of expression e to variable x.assign(*x,e)performs indirect assignments; the value of e is assigned to the location that x points to.assume(x<n)makes the program continue only when the condition is satisfied.Abstract semantics: Note that our framework requires abstract states to be maps from abstract locations to values (Section 2.3). Consider the following abstract domains:S^=L^→V^,L^=Var,V^=Z^×P^,P^=P(L^)An abstract state (S^) is a map from a set of abstract locations (L^) to a domain of abstract values (V^). We treat each program variable as an abstract location. An abstract value is a pair of an abstract integer (Z^such thatP(Z)⇆αZγZZ^) and an abstract pointer (P^). An abstract pointer is a set of abstract locations. Note that the domain is generic so we can freely choose any non-relational numeric domains forZ^, such as intervals [8].The abstract semantics is defined by the least fixpoint of semantic functionF^as described in Eq. (1), where the abstract semantic functionf^c∈S^→S^is defined as follows: (Notation: we writee.A,e.Bto denote the first and the second element ofe∈A×B, respectively.)f^c(s^)={s^[x↦E^(e)(s^)]c=assign(x,e)s^[s^(x).P^↦wE^(e)(s^)]c=assign(⁎x,e)s^[x↦〈s^(x).Z^⊓Z^αZ({z∈Z|z<n}),s^(x).P^〉]c=assume(x<n)The abstract effect ofassign(x,e)is to update the value of x with the evaluation result of e.assign(*x,e)weakly updates the value of abstract locations that*xdenotes.11For brevity, we consider only weak updates. Applying strong update is orthogonal to our sparse analysis design.assume(x<n)prunes the numeric value of x according to the condition. The abstract value of expression e is computed by an auxiliary functionE^∈e→S^→V^, defined as follows:E^(n)(s^)=〈αZ({n}),⊥〉E^(x)(s^)=s^(x)E^(&x)(s^)=〈⊥,{x}〉E^(*x)(s^)=⨆{s^(a)∣a∈s^(x).P^}E^(e1+e2)(s^)=〈v1.Z^+^Z^v2.Z^,v1.P^∪v2.P^〉wherev1=E^(e1)(s^),v2=E^(e2)(s^)To approximateNChg^andNCon^, we use a conservative pre-analysis. The pre-analysis we use is a flow-insensitive version of the baseline analysis:Δ→S^⇆αpγpS^αp=λX^.⨆{X^(c)∣c∈dom(X^)}F^p=λs^.⨆c∈Cf^c(s^)Other than the above pre-analysis, any sound approximation of the original analysis can be used as a pre-analysis.LetT^p∈S^be the pre-analysis results. UsingT^p, we approximate no-changes and no-contributions in the analysis. For each partitioning index c, we computeNChg^by excluding abstract locations whose values are possibly modified at cNChg^={(c,l)∈Δ×L^∣l∈(L^−{x})∧(c=assign(x,e)orassume(x<n))}∪{(c,l)∈Δ×L^∣l∈(L^−T^p(x).P^)∧c=assign(*x,e)}According to the definition off^(c,l),assign(x,e)andassume(x<n)do not define any abstract locations except x.assign(*x,e)may change values of abstract locations inT^p(x).P^. Because the pre-analysis is conservative, we ensure that all abstract locations inL^−T^p(x).P^are never modified during the actual analysis.We computeNCon^(c,l)by excluding abstract locations that are possibly used when analyzing control point c:NCon^(c,l)={L^−U(e)(T^p)c=assign(x,e)L^−({x}∪T^p(x).P^∪U(e)(T^p(c)))c=assign(⁎x,e)L^−{x}c=assume(x<n)whereU(e)(s^)computes the set of abstract locations that are used during the evaluation ofE^(e)(s^):U(n)(s^)=∅U(x)(s^)={x}U(&x)(s^)=∅U(*x)(s^)={x}∪s^(x).P^U(e1+e2)(s^)=U(e1)(s^)∪U(e2)(s^)The definition ofNCon^(c,l)is also naturally derived from the definition off^c. Whencmd(c)isassign(x,e), all locations except those inU(e)(T^p)are unnecessary. Analyzingassign(*x,e)requires location x (because of semantic definition of weak updates), the points-to set of x (T^p(x).P^), andU(e)(T^p). Note that in the above definition, for simplicity, we aggressively approximatedNCon(c,l)even without considering the current location l. If this is unsatisfactory, we can designNCon(c,l)more precisely, discriminating each l, which increases the sparseness of the final sparse analysis.

@&#CONCLUSIONS@&#
