@&#MAIN-TITLE@&#
Combining deep and shallow embedding of domain-specific languages

@&#HIGHLIGHTS@&#
We present a technique for combining deep and shallow embedding for embedded languages.The technique gives a more natural programming interface to embedded languages.The technique makes it easy to extend embedded languages.We give a plethora of examples demonstrating the advantages of the technique.

@&#KEYPHRASES@&#
Domain specific languages,Shallow embedding,Deep embedding,Fusion,Monads,

@&#ABSTRACT@&#
We present a technique to combine deep and shallow embedding in the context of compiling embedded languages in order to provide the benefits of both techniques. When compiling embedded languages it is natural to use an abstract syntax tree to represent programs. This is known as a deep embedding and it is a rather cumbersome technique compared to other forms of embedding, typically leading to more code and being harder to extend. In shallow embeddings, language constructs are mapped directly to their semantics which yields more flexible and succinct implementations. But shallow embeddings are not well-suited for compiling embedded languages.Our technique uses a combination of deep and shallow embedding, which helps keeping the deep embedding small and makes extending the embedded language much easier. The technique also has some unexpected but welcome secondary effects. It provides fusion of functions to remove intermediate results for free without any additional effort. It also helps us to give the embedded language a more natural programming interface.

@&#INTRODUCTION@&#
Domain specific languages (DSLs) provide an effective means of increasing programmer productivity [25]. In order to lessen the initial cost of implementing the DSL, many implementors choose to embed the language in a host language. Embeddings can come in many shapes and forms [19], partly dictated by the purpose of the language. This paper focuses on DSLs which are designed to generate code. In this situation it is natural to use an algebraic data type to represent the abstract syntax tree (AST) of the DSL. This is known as a deep embedding. Deep embeddings can be cumbersome: the AST definition can grow large when each language construct has its own constructor. It is also laborious to add new language constructs as it requires changes to the AST as well as all functions manipulating the AST.In contrast, shallow embeddings do not require an abstract syntax tree and all the problems that come with it. Instead, language constructs are mapped directly to their semantics. Nevertheless, there are many situations in which it is convenient to have access to an AST – especially when we wish to transform expressions and generate code from them.In this paper we present a technique for combining deep and shallow embeddings in order to achieve many of the advantages of both styles. Concretely, we propose to define DSLs using shallow embeddings which generate a deeply embedded AST. This combination turns out to provide surprising but welcome secondary effects which we explore. In particular, our technique has the following advantages:Simplicity: By moving functionality to shallow embeddings, our technique helps keep the AST small without sacrificing expressiveness.Abstraction: The shallow embeddings are based on abstract data types leading to better programming interfaces (more like ordinary APIs than constructs of a language). This has important additional benefits:•The shallow interfaces can have properties not possessed by the deep embedding. For example, our vector interface (Section 4.9) guarantees removal of intermediate structures (see Section 5).The abstract types can sometimes be made instances of standard Haskell type classes, such as Functor and Monad, even when the deep embedding cannot (demonstrated in Sections 4.8, 4.9 and 6).Extensibility: Our technique can be seen as a partial solution to the expression problem [43] as it makes it easier to extend the embedded language with new language constructs and functions.The paper is organized as follows: In Section 2 we start by giving a more detailed introduction to shallow and deep embeddings, including a comparison of the two methods (Section 2.1). Section 3 gives a detailed description of our technique. Section 4 demonstrates the technique by defining a deep embedding and showing a number of examples of how it can be extended with new shallow language constructs. Section 5 describes how fusion comes for free as a consequence of our technique and explain in detail what guarantees it provides. Section 6 describes how to embed arbitrary monads and shows a monad for mutable data structures as an example. Finally, Section 7 discusses how the presented techniques can be scaled up to a full EDSL implementation.Throughout this paper we will use Haskell [32] and some of the extensions provided by the Glasgow Haskell Compiler. Code from this paper can be found in the following repository: https://github.com/josefs/deep-shallow-paper.This paper is an extended version of our paper “Combining Deep and Shallow Embedding for EDSL” which appeared in Trends in Functional Programming 2012 [38]. New material presented here includes Sections 6 and 7 which are completely new. Section 5 has been expanded with more examples of fusable data structures. The deep embedding in Section 4 has been changed in some ways: binding is now handled using the Lam and :$ constructors. We have included a Syntactic instance for functions, which simplifies the definition of smart constructors. Literals have been generalized to more closely match what an actual implementation would look like. We have also added a function for rendering the generated ASTs in Section 4.10. Finally, bugs have been fixed in the evaluator in Section 4 and the description of the Option type in Section 4.8.To explain the meaning of “deep” and “shallow” we will use the following small embedded domain specific language (EDSL) by Carlson et al. [9] as an illustrating example.This piece of code defines a small language for regions, i.e. two-dimensional areas. It only shows the interface; we will give two implementations, one deep and one shallow.The type Region defines the type of regions which is the domain we are concerned with in this example. We can interpret regions by using inRegion, which allows us to check whether a point is within a region or not. We will refer to functions such as inRegion which interpret values in our domain as interpretation functions. The function inRegion takes an argument of type Point and we will just assume that there is such a type together with the expected operations on points.Regions can be constructed using circle which creates a region with a given radius (again, we assume a type Radius without giving its definition). The functions outside,(∩)and(∪)take the complement, intersection and union of regions, respectively. As an example of how to use the language, we define the function annulus which can be used to construct donut-like regions given two radii:The first implementation of our small region EDSL will use a shallow embedding. The code is shown below:Our concrete implementation of the type Region is the typePoint→Bool. We will refer to the typePoint→Boolas the semantic domain of the shallow embedding. It is no coincidence that the semantic domain is similar to the type of the function inRegion. The essence of shallow embeddings is this:Definition 1A shallow embedding represents language constructs as their semantics in the host language.The implementation of the function inRegion becomes trivial; it simply uses the function used to represent regions. This is common for shallow embeddings; interpretation functions like inRegion can make direct use of the operations used in the representation. All the other functions encode what it means for a point to be inside the respective region.We characterize deep embeddings as follows:Definition 2A deep embedding represents language constructs as constructors in an abstract syntax tree.Writing the functions for constructing new regions becomes trivial. It is simply a matter of returning the right constructor. The hard work is instead done in the interpretation function inRegion which has to interpret the meaning of each constructor.As the above example EDSL illustrates, a shallow embedding makes it easier to add new language constructs – as long as they can be represented in the semantic domain. For instance, it would be easy to add a function rectangle to our region example. On the other hand, since the semantic domain is fixed, adding a different form of interpretation, say, computing the area of a region, would not be possible without a complete reimplementation.In the deep embedding, we can easily add new interpretations (just add a new function like inRegion), but it comes at the price of having a fixed set of language constructs. Adding a new construct to the deep implementation requires updating the Region type as well as all existing interpretation functions.This comparison shows that shallow and deep embeddings are dual in the sense that the former is extensible with regards to adding language constructs while the latter is extensible with regards to adding interpretations. The holy grail of embedded language implementation is to be able to combine the advantages of shallow and deep in a single implementation. This is an instance of the expression problem[43].One way to work around the limitation of deep embeddings not being extensible is to use “derived constructs”. An example of a derived construct is annulus, which we defined in terms of outside, circle and(∩). Derived constructs are shallow in the sense that they do not have a direct correspondence in the underlying embedding. Shallow derived constructs of a deep embedding are particularly interesting as they inherit most advantages of both shallow and deep embeddings. They can be added with the same ease as constructs in a fully shallow embedding. Yet, the interpretation functions only need to be aware of the deep constructs, which means that we retain the freedom of interpretation available in deep embeddings. There are, of course, limitations to how far these advantages can be stretched. We will return to this point in the concluding discussion (Section 9).The use of shallow derived constructs is quite common in deeply embedded DSLs. However, the technique presented in this paper is novel and goes beyond “simple” derived constructs to extensions with new interface types leading to drastically different interfaces.One existing solution to the problem of extending deep embeddings is Data Types á la Carte [41]. It makes it possible to define several independent data types and combine them to a single deep embedding in a modular way. However, regardless of this modularity, extending a deep embedding makes the language larger and increases the number of cases that need to be handled when traversing expressions. In contrast, our approach allows the definition of rich languages on top of simple deep embeddings. It is often possible to extend the language with no or minimal changes to the compiler when using our approach.To be clear, our technique is not in competition with Data Types á la Carte. The two techniques complement each other and can be combined just fine [2,31].We assume a setting where we want an EDSL that generates code. Code generation tends to require intensional analysis of the AST, which is not directly possible with a shallow implementation. Hence, we will start with a deep embedding as a basis. Our technique can be summarized in the following steps:1.Implement a deeply embedded core language. The aim of the core language is not to act as a convenient user interface, but rather to support efficient generation of common code patterns in the target language. For this reason, the core language should be kept as simple as possible.Implement user-friendly interfaces as shallow embeddings on top of the core language. Each interface is represented by a separate type and operations on this type.Give each interface a precise meaning by giving a translation to and from a corresponding core language program. In other words, make the deep embedding the semantic domain of the shallow embedding. This is done by means of type class instantiation. If such a translation is not possible, or not efficient, extend the core language as necessary.In the sections that follow we will demonstrate our technique by defining a deep embedding and showing a number of examples of shallow extensions. For the sake of concreteness we have made some superficial choices which are orthogonal to our technique. In particular, we use a typed representation of the deep embedding and employ higher order abstract syntax to deal with binding constructs. Neither of these choices matters for the applicability of our technique.To demonstrate our technique we will use a small embedded language called FunC as our running example.The data type describing the FunC abstract syntax tree can be seen in Fig. 1.11We use a serif font to refer to the language FunC, and sans serif to refer to the data type implementation FunC.FunC is a low level, pure functional language which has a straightforward translation into C. It is meant for embedding low level programs and is inspired by the core language used in Feldspar [4]. We use a GADT to give precise types to the different constructors. We have also chosen Higher Order Abstract Syntax (HOAS) [33] for the Lam constructor.The first two constructors, :$ and Lam, correspond to application and abstraction in the lambda calculus. Then there are a number of symbols for different language constructs: Lit introduces a literal; If introduces a function for testing booleans; While introduces a functional while loop (explained in Section 4.3); Pair, Fst and Snd are for constructing and eliminating pairs; Prim introduces a primitive function.The last two constructors, Value and Variable, are not part of the language. They are used internally for evaluation and printing respectively (see Sections 4.4 and 4.10). It would be possible to avoid these odd constructors by using a parameteric HOAS representation [10], but we have opted for a simpler representation in this paper.Instead of letting the user write explicit applications, we can define smart constructors corresponding to the different symbols:The Prim symbol introduces a primitive function from a name (used for printing and code generation) and a semantic function (used for evaluation). We can use Prim and Lit to instantiate the Num class for FunC:Note that the arity of the semantic function passed to Prim determines the number of applications needed. With the above Num instance, we can write FunC expressions that look like ordinary Haskell; for example, 10 + 5 :: FunC Int.While numeric literals are conveniently introduced using the Num instance, boolean literals are written using the following definitions:We will also be using comparison and integral operators in FunC. For tiresome reasons it is not possible to overload the methods of the corresponding type classes Eq, Ord and Integral: for example, the == operator returns a Haskell Bool and there is no way we can change that to fit the types of FunC. Instead we will simply assume that the standard definitions of the comparison and integral operators are hidden and we will use definitions specific to FunC.The While symbol has a higher-order type:(s→Bool)→(s→s)→s→s. Seen as an ordinary Haskell function, it is supposed to work as follows: the first argument is a function that determines whether or not to continue based on the current state (of type s); the second argument is the step function that computes the next state from the current state; the third argument is the initial state; the result is the final state. The reason for having a step function is that FunC is pure, so the body of the loop cannot perform side-effects.A first attempt to make a smart constructor for While might lead to the following definition:The problem with this function is that it expects FunC expressions of function types as argument. Such expressions can be created using Lam or some of the symbols of FunC. However, using symbols to construct the function expression is generally not a good idea, because when analyzing or compiling expressions we usually want the state of the while loop to be associated with a variable. So, since we always want to use Lam for these arguments, it is convenient to let the smart constructor insert Lam automatically for us:Now the while loop starts to look like an ordinary higher-order Haskell function, and we can even write some examples with it. The following toy program computes the smallest multiple of 2 that is greater than 100:Being based on the lambda calculus, FunC can represent arbitrary higher-order expressions. This is problematic if we want to generate efficient low-level code from FunC. In Section 7, we will discuss how to restrict the use of higher-order expressions, so that efficient code can be generated.

@&#CONCLUSIONS@&#
