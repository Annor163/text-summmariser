@&#MAIN-TITLE@&#
Semantics-based approach for detecting flaws, conflicts and redundancies in XACML policies

@&#HIGHLIGHTS@&#
We provide policy analysis scheme to detect access contradictions among web services.We propose semantic-based policy analysis through deductive logic and inference rules.We present flaw, conflict and redundancy detection algorithms for XACML policy analysis.We show through experiments that SBA-XACML provides efficient detection mechanisms.

@&#KEYPHRASES@&#
Web services security,Access control,Policy analysis,Set theory,Semantics,XACML,

@&#ABSTRACT@&#
XACML (eXtensible Access Control Markup Language) policies, which are widely adopted for defining and controlling dynamic access among Web/cloud services, are becoming more complex in order to handle the significant growth in communication and cooperation between individuals and composed services. However, the large size and complexity of these policies raise many concerns related to their correctness in terms of flaws, conflicts and redundancies presence. This paper addresses this problem through introducing a novel set and semantics based scheme that provides accurate and efficient analysis of XACML policies. First, our approach resolves the complexity of policies by elaborating an intermediate set-based representation to which the elements of XACML are automatically converted. Second, it allows to detect flaws, conflicts and redundancies between rules by offering new mechanisms to analyze the meaning of policy rules through semantics verification by inference rule structure and deductive logic. All the approach components and algorithms realizing the proposed analysis semantics have been implemented in one development framework. Experiments carried out on synthetic and real-life XACML policies explore the relevance of our analysis algorithms with acceptable overhead. Please visit http://www.azzammourad.org/#projects to download the framework.

@&#INTRODUCTION@&#
The heavy reliance on Web services as one of the primary methods for data exchange between partners and distributed systems still faces the risk of exploitation as a result of their infinite accessibility over the Internet [1,2]. In addition, services with critical data such as banking and other financial businesses are emerging, which increase security challenges [3]. In this regard, policy-based computing [4–6] is taking an increasing role in governing the systematic interaction among distributed services. Particularly, access control is the most challenging aspect of Web service security to determine which partner can access which service [7]. Currently, an increasing trend is to declare policies in a standardized specification language such as XACML, the OASIS standard eXtensible Access Control Markup Language [8]. Many vendors are adopting XACML for controlling access to their services.Before stating the addressed problems and contributions of our work, we depict in the sequel a brief introduction about XACML [8], which has a policy structure divided into three layers. The top layer consists of a policy set, the middle layer consists of policies and the lower layer consists of rules. Each layer contains a target element which is used to define the subjects, resources and actions. The policy set contains a set of policies, a set of obligations and a policy combining algorithm used to break the tie between its policies. Each policy has a set of rules, a set of obligations and a rule combining algorithm used to break the tie between its rules. A rule consists of a set of conditions and a rule effect. The obligations at the policy set and policy level are carried out when the final decision is reached to either permit or deny. The illustrative policy set example in Fig. 1, which will be used and explained in the case study (Section 5), depicts the policy structure.Nowadays, mid and large size online systems may embed several distributed services heavily interacting and composed together to provide features satisfying the clients’ needs. This may require policies with hundreds and even thousands of rules to control access and enforce business behaviors. As a result, policies used as means of protection can be a source of weaknesses due to the presence of flaws and conflicts between their rules. For instance, considering the example in Fig. 1, rules R3 and R4 lead to an access flaw because both rules have no targets, both rules have the same effect Permit, R3 precedes in order R4 and R4 is more restricted than R3. With the current XACML decision mechanism, the generic rule R3 will always take precedence and be evaluated before the restricted rule R4. Therefore the response will always be given by R3 that grants access to any subject, while R4 that limits the access to subject Joe will be disregarded. In this context, the true objective of access control is to give higher priority to more restricted rules. Current XACML tools give major role to security administrators to resolve some tie/conflict decisions through policies/rules modifications and/or combining algorithms (e.g.Permit-overridesandFirst-Applicable). Although manual corrections may seem practical for small size policies, it is doubtful if not impossible for large ones within the complex structure of XACML. The problem grows more when integrating and composing different policies [9,2,7,10,6,5], where contradictions between combining algorithms are apparent. In this regard, some approaches have been proposed addressing XACML policy composition and analysis [11–18]. However, these propositions did not address the presence of access flaws, conflicts and redundancies between policies, and did not consider the logical meaning of rules that reflect the objectives of a policy.In this paper, we tackle the aforementioned problems by elaborating a set-based scheme that provides formal specification of policies and semantics-based detection built on top of it to efficiently perform analysis tasks. The main contributions of this paper are two folds: (1) Addressing the complex constructs of XACML through an abstract set-based syntax (SBA-XACML), while maintaining a similar policy structure that covers all its elements and sub elements and (2) offering novel detection mechanisms that analyze the meaning of policy rules through semantics verification by inference rule structure and deductive logic. All the approach components and algorithms have been implemented in one development framework that accepts XACML policies as inputs, converts them automatically to SBA-XACML constructs, and produces a list of access flaws, conflicts and redundancies between rules. The provided experiments conducted on real-life and synthetic XACML policies explore the relevance and efficiency of our analysis approach with acceptable overhead.The rest of the paper is organized as follows. Section 2 covers for the approach overview and architecture. Section 3 presents the semantics rules for policy and rule analysis. Section 4 illustrates the analysis algorithms. Section 5 depicts the case study and semantics-based detection. Section 6 focuses on the experiments and performance analysis. Section 7 summarizes the related work. Finally, Section 8 presents the conclusion.The overall architecture of our approach is illustrated in Fig. 2with all its components, i.e. SBA-XACML Language, Compiler and Analysis Module. Using the framework, the user can analyse the policies for access flaws, conflicts and redundancies and get the corresponding analysis report using the module embedding the analysis algorithms.SBA-XACML is a set-based language composed of all the elements and constructs needed for the specification of XACML based policy. Please refer to [19] for the complete definition and syntax of SBA-XACML elements and attributes. Its compiler includes XACML parser and converter to SBA-XACML. It takes XACML policy set as inputs, parses their XACML elements and generates SBA-XACML constructs according to the language syntax and structure. In the sequel, we present a brief summary about its constructs that are needed in this paper. SBA-XACML based policy, referred to as a policy set PS, is ordered into 3 levels:PolicySet,Policy, and Rule. Every element can contain a Target. PolicySet element contains otherPolicySet(s)and/orPolicie(s). Policy containsRule(s).A target TR is an objective and is mapped to SBA-XACML within the context of rule, policy and policy set according to the following syntax:TR={S,R,A}where S is a set of subjects, R is a set of resources and A is a set of actions.PS may contain other policy sets, policies or both. It can also be referenced by other policy sets. It is mapped to SBA-XACML according to the following syntax:PS∷=〈ID,SP,PR,PCA,IPS,OBLs,TR〉where ID is the policy set id, SP is the set of policies that belongs to policy setPS,PRis the precedence order of policies that belongs toPS,PCAis the policy combining algorithm, IPS is the policies or policy set that are referenced byPS,OBLsis the set of obligations and TR is the target.A policy P contains a set of rules, rule combining algorithm, target and obligations. It is mapped to SBA-XACML according to the following syntax:P∷=〈ID,SR,PR,RCA,OBLs,TR〉where ID is the policy id, SR is the set of rules that belongs to policyP,PRis the precedence order of rules that belongs toP,RCAis the rule combining algorithm, OBLs is the set of obligations and TR is the target.A rule R is the most elementary element of a policy. A rule contains rule conditions, target and rule effect. It is mapped to SBA-XACML according to the following syntax:R∷=〈ID,RC,TR,RE〉where ID is the rule id, RC is the set of rule conditions, TR is the target and RE is the rule effect.A rule condition RC is a boolean function over subjects, resources, actions or functions of attributes. It is mapped to SBA-XACML within the context of a rule according to the following syntax:RC={Applyfunction,{parameters}}whereApplyfunctionis the function used in evaluating the elements and parameters are the input to the function being applied.This module allows to analyse policies for detecting access control flaws, conflicts and redundancies between rules. It is composed of policy-level and rule-level analysis algorithms that realize the elaborated analysis semantics presented in Section 3. The policy-level algorithm is responsible for analysing policies and triggers the rule-level one in order to analyze the rules in each policy. The analysis module works effectively if scheduled as a trigger on the repository to run whenever any modification is performed on policies. It can be scheduled to run in parallel with policy evaluation as well. It accepts a policy set as input and generates an analysis report.The structural operational semantics used in this paper is an approach proposed to give logical means in defining operational semantics [20,21]. It defines the behavior of a process in terms of the behavior of its parts. Computation is represented by means of deductive logic that turn the abstract machine into a system of logical inferences. This allows to apply formal analysis on the behavior of processes. The behavior of a process is defined in terms of a set of transition relations. Such specifications take the form of inference rules. Definitions are given by inference rules, which consist of a conclusion that follows from a set of premises, possibly under control of some conditions. An inference rule has a general form consisting of the premises listed above a horizontal line, the conclusion below, and the condition, if present, to the right [21].In this section, we present the formal semantics of SBA-XACML policy analysis following the inference rule structure and deductive logic. Given a policy set PS, the analysis report R is derived from the evaluation→PAof all premises combined between each other using designated operators op as follows:(premise1)op(premise2)op…op(premisen)〈PS〉→PARThroughout the rest of the paper, please note the difference between a semantic rule that expresses the analysis at a particular level, and a policy rule which is a construct in SBA-XACML. All the semantics rules follow the bottom up structure, where all the common ones are presented first, then followed by the rule level, policy level and policy set level ones.Rule R1 has subject set S1, resource set R1 and action set A1. Rule R2 has subject set S2, resource set R2 and action set A2.Rules 1 and 2 in Table 1describe the different cases of subset rules. In Rule 1, a target TR1 is a subset of target TR2 if subject set S1 is a subset of subject set S2, resource set R1 is a subset of resource set R2, and action set A1 is a subset of action set A2. In Rule 2, a target TR1 is not a subset of target TR2 if subject set S1 is not a subset of subject set S2, or resource set R1 is not a subset of resource set R2, or action set A1 is a not a subset of action set A2.Rules 3 and 4 in Table 2describe the different cases of intersection rules. In Rule 3, two targets TR1 and TR2 intersect if subject set S1 and subject set S2 share common elements, resource set R1 and resource set R2 share common elements, and action set A1 and action set A2 share common elements. In Rule 4, two targets TR1 and TR2 do not intersect if subject set S1 and subject set S2 share no common elements, resource set R1 and target resource set R2 share no common elements, or action set A1 and action set A2 share no common elements.Table 3presents the analysis semantics rules for detecting access flaws in SBA-XACML policy set. Two rulesR1andR2cause access flaw if: (1) Both share the same effect (i.e. access decision) over the same set of subjects, resources and actions, (2)R2is more restricted thanR1and (3)R1takes a precedence order overR2, i.e. the decision is based on the evaluation ofR1whileR2is ignored. In other words, the access decision is taken based on the more general ruleR1evaluated first, while the more restrictedR2is ignored. Accordingly, semantics Rules 5–8 realize the aforementioned logic and describe the different access flaw analysis cases for a policy set PS. It is worth noting that such flaws cannot be resolved with the current combining algorithms of XACML.In Rule 5, two rules R1 and R2 return flaw if R2 target TR2 is a subset of rule R1 target TR1, rule condition RC2 is a subset of R1 rule condition RC1, and both R1 and R2 have the same rule effect, i.e. RE1 is equal to RE2. In Rule 6, for every pair of rules R1 and R2 in policy P such that R1 and R2 are appended to the Flaw Set FS if R1 and R2 evaluate to flaw. In Rule 7, given a pair of policies P1, P2 in policy set PS, P1 and P2 are appended to the Flaw Set FS if the rule combining of P1 is equal to the rule combining of P2, the targets of P1 and P2 intersect, and there exists R1 in P1 and R2 in P2 such that R1 and R2 evaluate to flaw and appended to the Flaw Set FS. In Rule 8, given policy set PS, the Flaw Set FS is the union of all flaws between any two flawed rules R1 and R2 in one policy and between two flawed rules R1 and R2 from every two flawed policies P1 and P2.Table 4presents the analysis semantics rules for detecting redundancies in SBA-XACML policy set. Two rulesR1andR2are considered redundant if both have the same effects (i.e. access decision) over the same set of subjects, resources and actions. Accordingly, semantics Rules 9–12 realize the aforementioned logic and describe the different conflict analysis cases for a policy set PS.In Rule 9, two rules R1 and R2 are redundant if R1 target TR1 and R2 target TR2 intersect, rule condition RC1 and rule R2 rule condition RC2 intersects, and both rules R1 and R2 have the same rule effect, i.e. RE1 is equal to RE2. In Rule 10, for every pair of rules R1 and R2 in policy P such that R1 and R2 are appended to the Redundant Set RS if R1 and R2 are redundant. In Rule 12, given a pair of policies P1, P2 in policy set PS, P1 and P2 are appended to the Redundant Set RS if the rule combining of P1 is equal to the rule combining of P2, the targets of P1 and P2 intersect, and there exists R1 in P1 and R2 in P2 such that R1 and R2 are redundant and appended to the Redundant Set RS. In Rule 12, given policy set PS, the Redundant Set RS is the union of all redundancies between any two redundant rules R1 and R2 in one policy and between two redundant rules R1 and R2 from every two redundant policies P1 and P2.Table 5presents the analysis semantics rules for detecting conflicts in SBA-XACML policy set. Two rulesR1andR2cause conflict if both have opposite effects (i.e. access decision) over the same set of subjects, resources and actions. Accordingly, semantics Rules 13–16 realize the aforementioned logic and describe the different conflict analysis cases for a policy set PS. Once such conflict is detected, the current combining algorithms of XACML can be used to resolve it.In Rule 14, two rules R1 and R2 conflict if R1 target TR1 and R2 target TR2 intersect, rule condition RC1 and R2 rule condition RC2 intersects and R1 with effect RE1 is the opposite of R2 with effect RE2. In Rule 14, for every pair of rules R1 and R2 in policy P such that R1 and R2 are appended to the Conflict Set CS if R1 and R2 conflict. In Rule 15, given a pair of policies P1, P2 in policy set PS, P1 and P2 are appended to the Conflict Set CS if the rule combining of P1 is equal to the rule combining of P2, the targets of P1 and P2 intersect, and there exists R1 in P1 and R2 in P2 such that R1 and R2 conflicted and appended to the Conflict Set CS. In Rule 16, given policy set PS, the Conflict Set CS is the union of all conflicts between any two conflicting rules R1 and R2 in one policy and between two conflicting rules R1 and R2 from every two conflicting policies P1 and P2.In this section, we present the algorithms realizing the SBA-XACML policy analysis semantics. The analysis module is divided into three algorithms: (1) the rule analysis algorithm is presented in Algorithm 1, (2 the policy analysis algorithm in Algorithm 2 and (3) policy set analysis algorithm in Algorithm 3.The Rule Analysis Algorithm is presented in Algorithm 1. It takes two rules R1 and R2 as input and compares their targets, rule conditions and rule effects to determine if there exists any flaw, conflict or redundancy between the two rules. It returns the proper response to the Policy Analysis Algorithm in Algorithm 2. If the target of rule R2 is a subset of the target of rule R1, the rule condition set of R2 is a subset of the rule condition set of R1, R1 and R2 have the same effect and R1 takes a precedent order over R2, then the rule R1 is considered as access control flaw. If the subject set of R1 intersects with subject set of R2, resource set of R1 intersects with resource set of R2 and action set of R1 intersects with action set of R2 and R1 and R2 have opposite effect, then R1 conflicts with R2. Otherwise, if R1 and R2 have the same effect then R1 and R2 are redundant. Empty set is returned if no issues were found between the two rules.Algorithm 1Rule_Analysis (R1,R2)Input: Two Rules R1 with Target TR1={S1,R1,A1}, rule condition RC1, ruleeffect RE1 and R2 with Target TR2={S2,R2,A2}, rule condition RC2, rule effect RE2Output: Rule analysis∈{Flaw, Conflict, Redundant or Null}1: if (S2⊆S1)∧(R2⊆R1)∧(A2⊆A1) then2:if (RC2⊆RC1) then3:if (RE1=RE2) then4:// R2 is a subset of R15:return “Flaw”;6:end if7:end if8: end if9: if ((S1∩S2)≠∅)∧((R1∩R2)≠∅)∧((A1∩A2)≠∅) then10:if ((RC1∩RC2)≠∅) then11:if (RE1≠RE2) then12:return “Conflict”;13:else14:return “Redundant”;15:end if16:end if17: end if18: return;The policy analysis algorithm is presented in Algorithm 2. It takes two policies P1 and P2 as input and produces a set of all access flaws FS, conflicts CS and redundancies RS. The algorithm is composed of two parts. The first part of the algorithm checks for flaws, conflicts and redundancies within each policy. The second part of the algorithm checks for them between rules from different policies. The returned responses from the Rule Analysis calls are appended to the proper sets.Algorithm 2Policy_Analysis(P1,P2)Input: Policy P1 with Target TR1 = {S1,R1,A1} and P2 with Target TR2 = {S2,R2,A2}Output: Flaw Set FS, Conflict Set CS and Redundancy Set RS1://Check rules in each policy2: forl≔1to2do3:fori≔1toPlNumberofRules-1do4:forj≔2toPlNumberofRulesdo5:if (Rule_Analysis(Rli,Rlj)= “Flaw”) then6:FS=FS∪FlawRli,Rlj;7:end if8:if (Rule_Analysis(Rli,Rlj)= “Redundant”) then9:RS=RS∪RedundantRli,Rlj;10:end if11:if (Rule_Analysis(Rli,Rlj)= “Conflict”) then12:CS=CS∪ConflictRli,Rlj;13:end if14:end for15:end for16: end for17: //Check rules in both P1 and P218: if (RCAP1=RCAP2) then19:if (((S1∩S2)≠∅)∧((R1∩R2)≠∅)∧((A1∩A2)≠∅)) then20:forl≔1toP1_NumberofRulesdo21:form≔1toP2_NumberofRulesdo22:if (Rule_Analysis(Rl,Rm)= “Flaw”) then23:FS=FS∪FlawRl,Rm;24:FS=FS∪FlawP1,P2;25:end if26:if (Rule_Analysis(Rl,Rm)= “Conflict”) then27:CS=CS∪ConflictRl,Rm;28:CS=CS∪ConflictP1,P2;29:end if30:if (Rule_Analysis(Rl,Rm)= “Redundant”) then31:RS=RS∪RedundantRl,Rm;32:RS=RS∪RedundantP1,P2;33:end if34:end for35:end for36:end if37: end if38: return;The PolicySet Analysis algorithm is presented in Algorithm 3. It takes a policy set PS as input and produces a report of all access flaws, conflicts and redundancies between policies and rules. It initializes global set FS, CS and RS and calls the Policy Analysis algorithm in Algorithm 2 on for checking and appending flaws, conflicts and redundancies at both policy and rule levels, in each policy and between every two policies.Algorithm 3PolicySet_Analysis(PS)Input: A Policy Set PSOutput: Analysis report1: Global FS =∅; RS =∅; CS =∅;2: fori≔1toPSNumberofPolices-1do3:forj≔i+1toPSNumberofPolicesdo4: PA=Policy_Analysis(Pi,Pj);5:end for6: end forIn this section, we present a case study illustrating the practicality of SBA-XACML policy analysis process through semantics rules. Listing 1contains the generated SBA-XACML based policy corresponding to the XACML policy example presented in Fig. 1.Line 1 is the policy set PS. The policy set ID isPS1. It has two policiesP1andP2.P1is ordered beforeP2. The policy combining algorithm ispermit-overrides.PS1has no reference to other policies. It has no obligations to perform and the target subjects, resources and actions are any. Line 2 is the policyP1. The policy ID isP1. It has two rulesR1andR2.R1is ordered beforeR2. The rule combining algorithm isdeny-overrides.P1has no obligations and no target. Line 3 is the ruleR1. The rule ID isR1.R1has a set of conditions. The conditions are: the subject ID must be equal to Bob and the resource ID must be equal toBankService/Withdraw. The target subjects, resources and actions are any.R1has a permit effect. Line 4 is the ruleR2. The rule ID isR2.R2has no conditions.R2has no target specified.R2has a deny effect. Line 5 is the policyP2. The policy ID isP2. It has three rulesR3,R4andR5. The precedence order isR3,R4thenR5. The rule combining algorithm ispermit-overrides.P2has no obligation to perform and the target elements are not defined. Line 6 is the ruleR3. The rule ID isR3.R3has one condition. The condition states that the resource ID must be equal toBankService/Deposit. The target subjects, resources and actions are not specified.R3has a permit effect. Line 7 is the ruleR4. The rule ID isR4.R4has a set of conditions. The conditions are: the subject ID must be equal to Joe and the resource ID must be equal toBankService/Deposit. The target subjects, resources and actions are not specified.R4has a permit effect. Line 8 is the ruleR5. The rule ID isR5.R5has a set of conditions. The conditions are: the subject ID must be equal to Joe and the resource ID must be equal toBankService/Deposit. The target subjects, resources and actions are not specified.R5has a deny effect.Based on the SBA-XACML policy analysis semantics in Section 3, the elaborated framework will analyze the based policy PS1 presented in Listing 1 for detecting access flaws, conflicts and redundancies. The result of the analysis shows that PS1 hasFlawR3,R4,ConflictR3,R5andRedundantR3,R4. To avoid repetition and for space limitation, we will only present the access flaws detection and three different cases where flaws exist between two rules, no flaws between two rules and no flaws between two policies in PS1. The analysis for conflict and redundancy detection is performed in similar way. The analysis of each semantics rule in Fig. 3is based on analyzing its premises, hence they should be read from bottom up, i.e at the level of policy sets, policies and then rules as follows:(1)The based policy is composed of a PolicySet PS1. PS1 contains a flaw because there exists a policy P2 in PS1 such that P2 contains a flaw between rules R3 and R4 as depicted in (3). Hence, based on the semantics (Rule 8) that applies in this case and combines the results of all the premises, the final response is the flaw set FS containingFlawR3,R4.Policy P1 is composed of two rules R1 and R2, which cause no flaw by applying semantics (Rule 5). First,Premise1evaluates to True because R1 and R2 have no targets defined, which means TR1 = {S=Any, R=Any, A=Any} and TR2 = {S=Any, R=Any, A=Any}. Second, R2 rule conditionsRC2is not a subset of R1 rule conditionsRC1since R2 has no condition, while R1 has two conditions that limit the access to resource equals toBankService/Withdrawand subject equals to Joe. Hence,Premise2evaluates to False. This fact denies the presence of a flaw, where the decision is based on the restricted rule that precedes the general one. Hence, the response is null and there is no need to continue checking the remaining premises.Policy P2 is composed of three rules R3, R4 and R5. Rules R3 and R4 cause flaw by applying semantics (Rule 5). First,Premise1evaluates to True because R3 and R4 have no targets defined, which means TR3 = {S=Any, R=Any, A=Any} and TR4 = {S=Any, R=Any, A=Any}. Second, R4 rule conditionsRC4is a subset of R3 rule conditionsRC3since both rules require the resource to beBankService/deposit, while R4 limits the subject to Joe. Hence,Premise2evaluates to True. This fact constitutes the first sign for a flaw, where the decision is based on the general rule that precedes the restricted one. Third,Premise3evaluates to True because both rules R3 and R4 have the same effect Permit. All premises of semantics (Rule 5) evaluate to true, therefore policyP2has access flaw between rules R3 and R4. The same analysis steps will be applied between R3 and R5 and between R4 and R5, without any existence of flaws. We did not include them to avoid repetition. Hence, the response is the flaw set FS containingFlawR3,R4.Policies P1 and P2 do not cause flaw. By Applying semantics (Rule 7),Premise1evaluates to False because the rule combining algorithmRCA1of P1 is equal todeny-overrides, which is different than the rule combining algorithmRCA2of P2, which is equal topermit-overrides. Hence, the response is null and there is no need to continue checking the remaining premises and analysing the rules of P1 and P2.In this section, we examine the results of our experiments for analyzing policies for access flaws, conflicts and redundancies. The SBA-XACML framework is implemented in PHP. The experiments were carried out on a notebook running Windows XP SP3 with 3.50GB of memory and dual core 2.8GHz Intel processor. The tests were conducted on both real world and synthetic policies to show the scalability and performance whether small or large. The real policies utilized in the experiments are small and mid-sized ones ranging between 2 and 298 rules. The synthetic policies are small and large ranging between 400 and 4000 rules. The flawed, conflicted and redundant rules were injected at random with different rate from 1 to 5 per every 10 rules. This process has been repeated hundreds of times with both real and synthetic policies.The first set of experiments has been performed to assess the detection rate of our approach. At each trial, extensive testing has been performed in order to make sure that the proposed detection mechanisms are able to successfully detect all the injected flaws, conflicts and redundancies. The results of our experiments gave 100% detection rate. The second set of experiments were conducted to assess the performance and efficiency of the analysis process. The processing time is the average time calculated based on 100K run per every policy set. Our analysis experiments were performed based on two scales, the normal case and the worst case. The normal case considers having policies injected with flaws, conflicts and redundancies up to 10%, while the worst case injected up to 50%. The analysis processing time is static and includes the conversion of the policy set from XACML to SBA-XACML, which is optional and executed only once when deploying policies.Fig. 4a and b show the experimental results for analyzing real life policies utilizing the normal scale, with injecting flaws, conflicts and redundancies up to 10%. Policies with 4 rules require less than 40m-s to complete the analysis process, while policies with 298 rules require on average about 24.2s to complete.Fig. 5a presents the statistics for analyzing synthetic policies utilizing two different scales, the normal and the worst. Fig. 5a shows the processing time when 1 out 10 rules/policies cause access flaws, conflicts or redundancies. At 400 rules, the analysis processing time consumes 5.54s to complete. At 1200 rules, it consumes 44s. And at 4000 rules, it consumes 692s.Fig. 5b shows the processing time when five out of ten rules/policies cause access flaws, conflicts or redundancies. The policies are designed in such a way that not only rules within each policy are verified, but also rules from different policies are verified as well due to similarities between policy targets and rule combining algorithms. The statistics show that policies with 400 rules can be analyzed with 29s, 1200 rules with 352s and 4000 rules with 7210s. The worst case processing times seem reasonable considering the policy size and the percentage of flaws, conflicts and redundancies injected. However, such cases are very unlikely to incur in real world policies. The results of these experiments explore the efficiency in terms of performance for reasonable size policies. The addition overhead is affordable, even though such analysis is performed most of the time offline.

@&#CONCLUSIONS@&#
