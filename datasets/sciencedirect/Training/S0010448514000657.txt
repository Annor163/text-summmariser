@&#MAIN-TITLE@&#
A fully geometric approach for interactive constraint-based structural equilibrium design

@&#HIGHLIGHTS@&#
The initial definition of structural behaviors is of primary importance when seeking material efficiency.A CAD approach is introduced allowing the user to build any plane static equilibrium interactively and graphically.All the design freedoms of the structural problem are permanently contained within dynamic graphical regions of positions.Techniques benefiting from fully geometric abstraction offer some computational simplifications and new capabilities.As a result, this approach frees the designer from the usual hierarchical and chronological structural design processes.

@&#KEYPHRASES@&#
Structural design,Static equilibrium,Coordinate-free geometric solving,Inequality constraints,Strut-and-tie model,Graphic statics,

@&#ABSTRACT@&#
This paper introduces computational techniques to support architects and structural designers in the shaping of strut-and-tie networks in static equilibrium. Taking full advantage of geometry, these techniques build on the reciprocal diagrams of graphic statics and enhance the interactive handling of them with two devices: (1) nodes–considered as the only variables–are constrained within Boolean combinations of graphic regions, and (2) the user modifies the diagrams by means of successive operations whose geometric properties do not at any time jeopardize the static equilibrium. This constructive approach enables useful design-oriented capabilities: a graphical control of multiple solutions, the direct switching of the dependencies hierarchy, the execution of dynamic conditional statements using static constraints, the computation of interdependencies, and coordinate-free methods for ensuring consistency between certain continuums of solutions. The paper describes a computer implementation of these capabilities.

@&#INTRODUCTION@&#
Today’s structural design practices are usually isolated in a process that sizes the structural parts after an analysis of a predetermined shape. Although satisfactory for most common routines, this process does not encourage a direct return to initial choices and hence does not favor adequate control of the structural behavior being shaped. If the structural behavior is not mastered throughout the process, the result consists of a collection of uncoordinated local arrangements without any kind of global assessment. The structure is therefore likely to have a lack of efficiency and durability or more generally a lack of internal consistency: structural parts might be over-dimensioned or superfluous, the structure might not fit with initial design intentions and, in the worst case scenario, the process might lead to a mechanically unsafe structure.Approaches exist to master the initial definition of the structural behavior. They generally consist of design-oriented uses of simplifying assumptions, problem reductions guaranteeing permanent control and extensive use of graphical methods and geometry. If executed properly, these approaches may render common computational analysis superfluous and hence reverse the classical process of structural design since the features of the structural behavior are a preliminary and not a result of the geometry and its structural analysis.The computational techniques described in this paper aim to support these approaches in a more interactive way than existing structural design tools. They are not intended to replace structural analysis tools, but rather to precede them. In order to meet the need for abstraction, simplicity, speed and interactivity that are inherent to the initial stages of creative design, the proposed environment only deals with static equilibrium. Its main role is to allow the designer to shape strut-and-tie networks and their inner forces graphically and simultaneously–i.e. using interactive graphic statics diagrams–by means of geometric operations (1) that guarantee static equilibrium at each step of the process and (2) from which the display of the available design freedoms is inferred.The range of structures that can be explored with graphic statics diagrams is quite large but is limited to those that can be modeled with a finite number of forces, struts and ties. They include the design and analysis of any reticular systems regardless of whether they are isostatic, indeterminate, articulated, pre-stressed or self-constrained; the design and analysis of any regular or irregular beam subjected to bending; and the sketch of discontinuous stress fields (e.g. within concrete shear walls  [1]) or lines of thrusts (e.g. within masonry arches  [2]) — the use of strut-and-tie models is actually ideally suited to working with the lower-bound theorem of plastic theory [3,4].This paper only considers planar systems although the techniques presented can also be used to control spatial systems by means of fixed projected planes.The remainder of this paper is organized into six sections. Section  2 highlights the overall functioning and reviews past contributions. Section  3 then specifies the data to be processed. Section  4 describes the various native operations that the user can invoke in order to constrain, shape and modify strut-and-tie networks in static equilibrium. It also explains how the update of position is performed and to what extent the environment may ease coordinate-free techniques to ensure the existence of consistent solutions. Section  5 introduces the role of higher procedures and specifies some of them. Lastly Section  6 screens one example of application, before Section  7 discusses the paper.Graphic statics is a theory stretching back 150 years  [5,6] that is used to represent and compute the geometry of a structure and its inner forces in a fully graphic-based approach. The geometry of the structure is drawn in a diagram called the form diagram, while its inner forces are drawn in another diagram called the force diagram in which a distance between two points measures a magnitude of force — i.e. in newtons or kilograms. These two diagrams must satisfy the following rules:(1)In order for any sub-structure–including any isolated node and the overall structure itself–in the form diagram to be in static equilibrium, the sum of the forces applied to it–including those applied by a strut or a tie–must be zero. This means that the vector description of these forces in the force diagram has to be a closed polygon. If this condition is satisfied for all the nodes of the strut-and-tie structure, the sum of moments is always zero and the rotational equilibrium does not have to be checked per se.In order for each force, strut and tie to be drawn only once in each diagram, the forces applied to any sub-structure must be read in the form diagram on a cycle that (a) is always read either clockwise or anti-clockwise and (b) is identical to the order described by the corresponding closed polygon in the force diagram (Fig. 1).Some software implementations of interactive graphic statics diagrams have already been developed for education purposes [7,8]. They are however only capable of dynamic displacements of nodes on preassembled diagrams. For this reason, the following two paragraphs introduce two new concepts that enhance the interactive use of graphic statics.The first device consists of assigning to each node of both diagrams a graphical region representing all its positions that solve the desired structural problem. If a node stays within its graphical domain, then the user is assured that the structure satisfies all the geometric and physical conditions applied. As an illustration, the strut-and-tie network presented by the form diagram in Fig. 2stays within the shaded area as long as the highlighted point in the force diagram remains within the shaded triangle, limiting its movement and hence the maximal magnitude of the three convergent rods. These domains are the result of the application of constraints by the user or are computed by the software in order to ensure consistency with all the constraints applied on the other points.The constraint-based geometric solving techniques presented in this paper are logic-based and constructive (see  [9–11] for related reviews). Domains of solutions are solved incrementally on graphical regions. In this regard, the approach can be related to the work of  [12]. However, it stands out for two main reasons.The first is that it extends the classical scope of compass-and-straightedge constructions by considering graphical inequalities and relative directions as fundamental constraints, leading to the possible formulation of infinite domains of solutions. Current geometric software usually offers very little support for geometric constructions allowing multiple solutions  [13,14], i.e. allowing points to be constrained on graphical inequalities (including half-planes) and on unions and negations of regions defined by other points. Software that enables these devices  [15] does not ensure consistency between constraints (i.e. regions may become empty).The second is that all the constraints here only take positions as parameters, whereas other solvers deal with constraints and parameters of various kinds (distances, angles, parallelism, tangency, proportionality etc.). Although this second feature does not imply any restriction of application–e.g. an angle can still be defined with three positions–it does allow some helpful simplifications in the problem terms that enhance solver capabilities, such as inverting the dependencies hierarchy between two relative points without requiring the construction to be rebuilt, guaranteeing some consistency by means of coordinate-free propagation and processing constraints that are interdependent. These features are developed further in Sections  4 and 5.The second device consists of simultaneously constructing and modifying both diagrams with geometric operations that transform a given strut-and-tie network in static equilibrium into another one. This single feature brings new interactivity to graphic statics diagrams. Indeed, current and classical graphic statics methods  [16] require the force diagram to be built with successive parallels copied from the form diagram, meaning that global equilibrium is only reached at the end of the construction process and that this construction must be re-started everytime the typology of the form diagram changes. Here, equilibrium exists from the start, the modifications affect both diagrams simultaneously and it does not require their complete reconstruction.As an illustration, Fig. 3describes the states before the combination of two sub-equilibriums into a new one (Fig. 5). Fig. 4is an intermediate step where points are dragged or geometrically constrained by the user in order to make paired forces opposite, equal and parallel. Since the change from one state of equilibrium to the other is governed by geometric reasoning alone, it does not require a matrix computation of equilibrium from a temporary non-equilibrated state.Five types of data are used: points, primitive constraints, Boolean constraints, forces and rods. Each of them is defined in the following sub-sections. The term “geometric constraint” refers to either a primitive constraint or a Boolean constraint.Points are either stored in the setPFORMor in the setPFORCE, depending on whether they belong to the form diagram or to the force diagram. They are all characterized by two coordinates and seven geometric constraints. Each of these geometric constraints can be seen as a particular sub-domain–i.e. a graphical region–in which the point must be in order to fulfill certain conditions:•the explicit domainthe strict domainthe force domainthe reading cycle domainthe topological domainthe consistency domainthe solution domain.The strict domain represents the region of positions for which no other point moves. Its construction is given in Section  4.3. The force domain is the intersection of all the geometric constraints that the point must hold in order to define forces correctly (see Section  4.1). The reading cycle domain gives the positions for which the current reading cycle of forces (adjacent in force polygons) remains valid (Figs. 6 and 7). The topological domain gives the positions for which the set of rods crossing each other in the form diagram remains unchanged (Fig. 8). The need for and the construction of these last two domains is not explained in this paper. Detailed information about them can be found in  [17].The consistency domain is the intersection of all the geometric constraints that the point must satisfy in order to ensure consistency with the domain of all the other points. Its general construction and limits of its applications are explained in Section  4.4.Finally, the solution domain is the Boolean intersection of the explicit domain, the force domain and the consistency domain.Primitive constraints are one of the eight following types: a half-plane, the inside of a disc, the outside of a disc, a unit compass and their respective inversions. These constraints only take points as parameters and are stored in the array of setAPC.HalfPlane[p0p1p2] is the closed region, i.e. with the boundary included, on the left of p0 according to the direction going from p1 to p2 (Fig. 9). The inversion of the HalfPlane constraint, written∖HalfPlane[p0p1p2], is then an open region–i.e. with the boundary excluded–to the right of p0 according to the direction going from p1 to p2. If p1 and p2 are coincident, HalfPlane[p0p1p2] comprises the entire plane of p0 and its inversion does not exist.DiscInside[p0p1p2] is the closed region inside the circle of center p0 and radius p1p2 (Fig. 10). Its inversion, written∖DiscInside[p0p1p2], is then an open region outside the circle of center p0 and radius p1p2.DiscOutside[p0p1p2] is the closed region outside the circle of center p0 and radius p1p2 (Fig. 11). Its inversion, written∖DiscOutside[p0p1p2], is then an open region inside the circle of center p0 and radius p1p2. If p1 and p2 are coincident, the inversion of DiscOutside[p0p1p2] does not exist.Finally, UnitCompass[p0] is a circle of center p0 and of radius equal to the unit length of the diagram in which p0 is applied.As the HalfPlane constraint and its inversion depict the affine nature of geometry with relative directions, the DiscInside and DiscOutside constraints depict the metric nature of geometry with inequalities of distances. Furthermore, these regions are appropriate for use with two separate diagrams because the points that define the orientation of the half-plane or the radius of the disc can be distinct from their point of application.An essential property of these primitive constraints is their symmetry. For instance, if the statement “ p0∈HalfPlane[p1p2p3]” means that the point p0 belongs to a HalfPlane[p1p2p3] constraint, then the four following statements are always equivalent (Figs. 12–15):p0∈HalfPlane[p1p2p3]⇔p1∈HalfPlane[p0p3p2]⇔p2∈HalfPlane[p3p1p0]⇔p3∈HalfPlane[p2p0p1].The same is valid with DiscInside and DiscOutside constraints and their inversions. For instance:p0∈DiscInside[p1p2p3]⇔p1∈DiscInside[p0p2p3]⇔p2∈DiscOutside[p3p0p1]⇔p3∈DiscOutside[p2p0p1].Boolean constraints, stored in the array of setABC, are of three types: the intersection constraint(∩), the union constraint(∪)and the inversion constraint(∖). The first two take any set of geometric constraints–i.e. primitive or Boolean constraints–as parameters and the third takes only one geometric constraint as a parameter.Boolean operations are useful for creating more complex constraints. For instance, the following lines define a parametric circle (as drawn by the compass) of center p0 and diameter p1p2, a parametric line (as drawn by the straightedge) passing through p0 and parallel to p1p2, and a single position p0:•Compass[p0p1p2]≔DiscInside[p0p1p2]∩DiscOutside[p0p1p2]Straightedge[p0p1p2]≔HalfPlane[p0p1p2]∩Halfplane[p0p2p1]Position[p0]≔DiscInside[p0p0p0].Forces are defined completely by four positions. A forceF0determined by the sequence[p0p1p2p3](a) is applied on p0 lying in the form diagram, (b) has an equal magnitude to the distance between p2 and p3 lying in the force diagram, (c) has the same direction as the one going from p2 to p3, and (d) pulls on p0 if the directions going from p0 to p1 and from p2 to p3 are equal (Fig. 18) or pushes on p0 if these directions are different (Fig. 19).Rods are defined completely by the two opposite forces they replace. The rod is in tension or in compression depending on whether the two opposite forces are pulling or pushing. The geometric properties that these two opposite forces must hold are detailed in Section  4.1, Fig. 23.The arrays of setsAFandARcontain all the forces and rods currently in use and their parameters.This section initially lists native operations and then outlines the general functional flow whereby they are processed. The following sub-sections then highlight techniques that take full advantage of the high-level of abstraction of the fully geometric approach presented.The idea here is to identify a minimal set of basic operations that the user can use to constrain and transform any strut-and-tie network in equilibrium into another one. If algorithms exist to process these native operations, then they can be assembled in sequence in order to define and hence perform more complex operations (see Section  5). The following list explains how these native operations modify the arrays of dataPFORM,PFORCE,AED,APC,ABC,AFandAR. Other native operations should complement this list in order to obtain information on values, perform checks on values and select objects.These native operations have here very limited purposes in order to ease their implementation. Their capabilities are expected to be extended with more general and intuitive higher-order procedures (see Section  5).•CreatePointInFormDiagramadds a new point at the end ofPFORMCreatePointInForceDiagramadds a new point at the end ofPFORCEDeletePoint[pA]ifpAis not a member ofAED,APC, andAF: removespAfromPFORMorPFORCEMovePoint[pAxy]according to the method presented in Section  4.3:updates the x and y coords ofpAas close as possible to the desired position and,if required, updates the coords of all the descendants ofpA, their reading cycle domain and the topological domain of all the points referenced inAFMergePoint[pApB]if the coords ofpAandpBare equivalent andifpBbelongs toPFORCEor if it does not belong toAF:replaces every occurrence ofpBbypACreatePrimitiveConstraint[type][pApBpC]adds a constraint and its given parameters at the end ofAPCthis constraint is of one of the eight primitive types given in Section  3.2CreateIntersection[cAcB]adds an Intersection[cA  cB] constraint at the end ofABCCreateUnion[cAcB]adds a Union[cA  cB] constraint at the end ofABCCreateInversion[cA]adds an Inversion[cA] constraint at the end ofABCDeleteConstraint[cA]if cA does not belong toAEDor toABC: removes cA fromAPCApplyConstraint[pAcA]checks whether the application of cA empties the domain ofpA(similar to the method used to update positions in Section  4.3)if not, adds the membership “ pA∈cA” toAEDupdates the strict domain ofpAupdates the consistency domain of the ancestors ofpACancelConstraint[pAcA]removes the constraint cA from the set of constraints applied topAinAEDupdates the strict domain ofpAupdates the consistency domain of the ancestors ofpAif cA is applied onpAinAEDand ifpBis a parameter of cA inAPC:cancels the application of cA ontopAinAED,adds cB at the end ofAPC, cB is a new constraint that is symmetric to cA according to the rules of symmetry described in Section  3.2,adds the membership “pB∈cB” toAED,updates the strict domain ofpAandpBupdates the consistency domain of the ancestors ofpAandpBCreateZeroForce[pApB]ifpAbelongs toPFORMand ifpBbelongs toPFORCE:adds a new force[pApApBpB]at the end ofAFDeleteZeroForce[FA]ifFAis a zero force inAF:removes the forceFAfromAFResolveForce[FApApBpC](Figs. 20 and 21)ifpAandpBbelong toPFORM, ifpCbelongs toPFORCEandifFAis in the form of[pDpEpFpG]inAF:removesFAfromAFremoves the constraint “Straightedge[pDpFpG]∩CoincidenceCondition[pDpFpG]” from the force Domain ofpEadds a new force[pDpApFpC]at the end ofAFadds a new force[pDpBpCpG]at the end ofAFadds the constraint “Straightedge[pDpFpC]∩CoincidenceCondition[pDpFpC]” in the force Domain ofpAadds the constraint “Straightedge[pDpCpG]∩CoincidenceCondition[pDpCpG]” in the force Domain ofpBselects all the forces inAFthat are applied onpDand updates the reading cycle domain of their parametersupdates the topological domain of all the points referenced inAFupdates the strict domain ofpA,pBandpEupdates the consistency domain of the ancestors ofpA,pBandpESwapForceCycle[FAFB](Fig. 22)if neitherFAnorFBis part ofARifFAis in the form of [pApBpCpD] inAFandifFBis in the form of [pApEpDpF] inAFandif there is no constraint applied onpA,pB,pC,pD,pEandpFinAED:removes the constraint “Straightedge[pApCpD]∩CoincidenceCondition[pApCpD]” from the force Domain ofpBremoves the constraint “Straightedge[pApDpF]∩CoincidenceCondition[pApDpF]” from the force Domain ofpEchanges the parameters ofFAandFBinAFsuch thatFAis defined by the points[pApBpDpF]andFBby the points[pApEpCpD]adds the constraint “Straightedge[pApDpF]∩CoincidenceCondition[pApDpF]” to the force Domain ofpBadds the constraint “Straightedge[pApCpD]∩CoincidenceCondition[pApCpD]” to the force Domain ofpEselects all the forces inAFthat are applied onpDand updates their reading cycle domainupdates the topological domain of all the points referenced inAFupdates the strict domain ofpBandpEupdates the consistency domain of the ancestors ofpBandpECreateRod[FAFB](Fig. 23)if neitherFAnorFBis already part ofARandifFAis in the form of[pApBpEpF]inAFandifFBis in the form of[pCpDpFpE]inAFandif constraints exist inAEDsuch thatpApCandpEpFare parallels andif the following memberships exist inAED(for any pointspGandpH)pB∈HalfPlane[pApGpH]pD∈HalfPlane[pCpHpG]pG∈Compass[pApApC]∩Compass[pCpApC]∩HalfPlane[pApApC]pH∈Compass[pApApC]∩Compass[pCpApC]∩HalfPlane[pCpCpA]adds a new entry [FAFB] inARupdates the topological domain of all the points referenced inAFCancelRod[RA]removes the rodRAfromARupdates the topological domain of all the points referenced inAF.The non-fundamental constraint CoincidenceCondition is defined in Section  5.2.The SwapForceCycle operation is intended to be called by the software itself as soon as a point is moved outside its reading cycle domain.The CreateZeroForce operation actually inserts the smallest strut-and-tie network that is proved to be in static equilibrium whatever its parameter points, while the ResolveForce operation implements the rule of the force parallelogram in a way that guarantees the reciprocal rules between the two diagrams of graphic statics (see Section  2.1). These two operations suffice to create as many forces in equilibrium as desired. The sum of two forces is simply obtained by canceling a force in the force diagram — i.e. by superimposing the two points defining one of the two forces in the force diagram and merging them.The constraints that are required by the CreateRod operation (Fig. 23) are also meant to guarantee the permanency of the reciprocal rules of graphic statics.Since the structural designer modifies his or her design step by step, the resolution of the geometric constraints is performed in a similar way — i.e. in a sequential manner that builds on the previous results. Fig. 24presents the functional flow diagram of the approach: boxes are computed data and arrows are algorithms or user commands. The construction plan holds a declarative list of all the native operations (Section  4.1) applied by the designer to the strut-and-tie network.These native operations are first interpreted by a coordinate-free solver that updates the arrays of dataPFORM,PFORCE,APC,ABC,AFandAR, the sets of explicit domainsAED, the sets of children, descendants, parents and ancestors of all points, the sets of strict domains (see Section  4.3), force domains (see operation ResolveForce), reading cycle domains, topological domains and certain sets of consistency domains (see Section  4.4). The conjunctive and disjunctive normal forms of these domains are also computed by this solver. Except for the reading cycle domains, these various domains offer the advantage of not being recalculated when points are dragged  [17].The update of the positions and hence of the actual shape of the domains of solutions is undertaken by a numerical solver whose job is primarily to compute orthogonal projections on lines or circles (see Section  4.3) and to complete the consistency domains that could not be created by the coordinate-free solver.The user can then modify the strut-and-tie network by moving points or applying a new operation. Thanks to the nature of the native operations, a local treatment of the data is usually sufficient for processing these modifications in both the symbolic and numerical solvers.If a constraintc∗is applied on a pointp∗, it is expected thatp∗remains insidec∗when one of its ancestors pi (i.e. a parameter ofc∗) is moving. To this end, the MovePoint operation (Section  4.1) updates the positionp∗automatically to the closest position inside its solution domain as soon as one of its ancestors point pi is dragged. Thanks to the nature of the three primitive regions, this new position is fairly quick to compute because it is either an orthogonal projection on a line or a circle, or the intersection between two lines, two circles or a line with a circle. It can be noticed that in most cases this action minimizes the disturbance of the model when it jumps from one solution to the other.Interdependency occurs when constraints present a loop — meaning that each point in that loop is constrained by itself to some extent. The update of positions might then either (1) converge after a finite number of updates, (2) converge after an infinite number of updates — in which case it can be stopped as soon as the distance of the displacement is smaller than a fixed small valueε— or (3) never converge (in which case the application of the last constraint should be avoided).The resulting iterative adjustment gives the ability to constrain a point directly on any algebraic or transcendental curve, something that is not feasible with non-interdependent compass and straightedge constraints. As an example, the following description constrains a point p2 on a parabola whose focus is on p0 and whose directrix passes through p1 and is perpendicular to p0p1 (Fig. 25):p3∈HalfPlane[p0p0p1]∩Compass[p0p0p1]∩Compass[p1p0p1]p4∈HalfPlane[p0p1p0]∩Compass[p0p0p1]∩Compass[p1p0p1]p5∈Straightedge[p1p3p4]∩Straightedge[p2p0p1]p2∈Compass[p0p2p5].The two interdependent cycles can be identified in the center of Fig. 26.The region resulting from the explicit domain might in some cases be a unique position, as was the case for points p1,p3 and p4 in Fig. 16. This means that the point can no longer be moved.The general update of positions when a point p0 is dragged is consequently formalized as follows:•get T1= the set of all the descendants of p0add p0 at the beginning of T1while every point pj in T1 is not marked “updated”:–T2= the set of all the ancestors of pj that are also in T1–if T2 is emptyor if every point in T2 is either already marked “updated” or is also a child or grandchild of pj (interdependency) :∗check (Boolean search) whether pj belongs to its solution domainif true: mark pj as “updated”if false:⋅get T3= the set of positions representing all the orthogonal projections and all the intersections between the primitive lines and circles of its solution domainfind the position pC of T3 that is closest to pjgetλ=the distance between pC and pjapply the coords of pC onto pj (if pC is not inside the explicit domain because its boundary is excluded, then slightly shift its coords inside the boundary)if T2 is empty or if every point in T2 is already marked “updated” or ifλis less than or equal toε(convergent interdependency):–mark pj as “updated”else ifλis greater than the previousλcalculated for the same pj:–the interdependency does not converge and the application of the last constraint that creates that interdependency should be canceled.An empty set T3 means that the region resulting from the solution domain of pj is empty. This case is not taken into account here because the consistency domains of the ancestors of pj are assumed to prevent the solution domain of pj from being empty.This sub-section shows how the above-mentioned fully geometric approach can favor coordinate-free methods to ensure consistency between specific domains of solutions.A domain of solution is consistent here if every point has a non-empty graphical region of possible positions. Owing to the constraint dependencies, this means that the set of possible positions of each father point must be restricted so that it can never be placed in a position that empties the domain of one of its descendants. This is called constraint propagation.Fig. 27presents an example in which points p0 and p1 are constrained as follows:p0∈HalfPlane[p2p2p3]∩HalfPlane[p4p4p5]p1∈HalfPlane[p6p6p7]∩HalfPlane[p8p8p9]∩HalfPlane[p0p10p11].If p0 moves to the right, its child p1 is then moved to the right too until the domain of p1 becomes empty, meaning that the problem has no solution. In order to prevent this impasse, the domain of p1 is propagated on the consistency domain of p0.The resulting solution domain of p0 shown in Fig. 28is the intersection between its explicit domain and its consistency domain.Propagation of inequalities constraints (like the HalfPlane, DiscInside and DiscOutside constraints) is a problem that is not yet successfully tackled by the scientific community and that requires extensive development. Possible approaches may perform numerical approximations to delimit the consistency domain with a desired accuracy or reproduce exact known loci of possible positions based on the given constraints and their dependencies. The following method exemplifies how the latter approach can in some cases be here done in a fully constructive way using coordinate-free geometric reasoning.The scope of application of this method is limited to regions that can be described with HalfPlane, DiscInside and DiscOutside constraints. As a consequence, it is restricted to propagations where the path of paternal filiation between the child point and the father point is unique, e.g. if a point is the father point of another point, it can be its father several times (by several constraints) but it cannot also be its grandfather or its child. This restriction is intended for two reasons. Firstly, the description of the resulting propagated regions, i.e. the consistency domains, uses a coordinate-free grammar, meaning that any technique developed in this paper can be applied to it. Secondly, consistency domains can be defined by combinations of constraints in such a way that their geometrical behavior, i.e. the resulting region, remains valid for any new position of a point. They therefore do not have to be recalculated every time they are moved and the update of their coordinate-free description is only required when new constraints are applied or old ones canceled.The propagation of Fig. 28 is relatively simple since it concerns two direct relatives whose domain comprises only an intersection of constraints. When the paternal filiation is greater, the following general procedure should be used to obtain the consistency domain of a point p0. It is based on the facts that (1) no parallel paternal filiation exists and (2) the solution domain of a child pointp∗cannot be propagated on its parents if the solution domain of its own children has not already been propagated onto its consistency domain:•Tchild= the set of all the descendants of p0Tchild is breadth-first sorted starting from childless points and ending with the direct children of p0for each point pi of Tchild (starting from the first element):–if pi is childless: its consistency domain is equal to the entire plane (not constrained)∗consider the next point pielse, propagate the solution domain of pi on its direct parents:∗getC∪=the disjunctive normal form of the Boolean combination of the primitive constraints in the solution domain of pigetT∗=the subset of “ Tchild+p0” containing the direct parents of pifor every point pj in T*:⋅for every sub-intersectionC∩ofC∪:–getCk=the subset ofC∩that uses pi as parameter–getC∩−k=the subset ofC∩that does not use pi as parameter–for every constraintCminCk:- find the pattern of sub-propagation to be applied (see below) according toCmandC∩−k- construct Dm= the consistency sub-domain corresponding to that pattern–get D∩= the intersection of every Dmget D∪= the union of every D∩intersect D∪ with the existing consistency domain of pjthe solution domain of p0 is the intersection of its explicit domain with its force domain and its consistency domain.Patterns of sub-propagation are specifications based on the constraint type ofCmandC∩−kand their quantity. They are used to differentiate the geometric reasoning to be applied. The following paragraphs present three patterns among others. Their complete implementation goes beyond the purpose of this paper. The implementation of all the conceivable patterns is an area that requires additional research.(1)A first pattern that is very easily automated comprises no more than one HalfPlane or∖HalfPlaneand an undetermined number of DiscOutside or∖DiscInsideconstraints. Since the intersection of these constraints always includes points at infinity, the propagation domain resulting from this pattern is the entire plane.A second pattern is the one for which the constraint that propagates is a DiscOutside or a∖DiscInsideconstraint and the intersection to be propagated (a convex shape) includes only HalfPlane,∖HalfPlane, DiscInside and∖DiscOutsideconstraints. The resulting domain is always a union of arcs of DiscOutside and∖DiscInsideconstraints.A third pattern is concerned only with the convex primitive constraints (i.e. HalfPlane,∖HalfPlane, DiscInside and∖DiscOutside). Using Eduard Helly’s theorem  [18], it can be shown that the set Cm∩C∩−k is non-empty if each sub-intersection comprising a maximum of three constraints is non-empty, whatever the large number of constraints inCm∩C∩−k. Moreover, since this pattern considers only four types of primitive constraints there are only 60 types of such sub-intersections. This means that each propagation of these sub-intersections is predefined constraints that can be propagated on an individual basis.For instance, Fig. 29presents one of the typical intersections, here involving two half-planes:HalfPlane[p1p2p3]∩HalfPlane[p4p5p6]. If (1) their borders are parallel, (2) they do not face one another and (3) their borders are distinct, they then describe an empty domain in Euclidean geometry (Fig. 30). To avoid this situation, a propagation constraint must be applied to each of these six points. For instance, the one applied to p1 can be written as follows:HalfPlane[pGpGp4]∪HalfPlane[pHpHp4]∪Straightedge[p4p5p6]where:pA∈Compass[p2p2p3]∩Compass[p3p3p2]∩HalfPlane[p2p2p3]pB∈Compass[p2p2p3]∩Compass[p3p3p2]∩HalfPlane[p3p3p2]pC∈Compass[p5p5p6]∩Compass[p6p6p5]∩HalfPlane[p5p5p6]pD∈Compass[p5p5p6]∩Compass[p6p6p5]∩HalfPlane[p6p6p5]pE∈Compass[p4p2p3]∩Straightedge[p4p5p6]∩HalfPlane[p4pCpD]pF∈Compass[p4p2p3]∩Straightedge[p4p5p6]∩HalfPlane[p4pDpC]pG∈Compass[p4p2p3]∩Straightedge[p4p2p3]∩HalfPlane[p4pApB]pH∈Compass[p4p2p3]∩Straightedge[p4p2p3]∩∖Position[pE]∩(HalfPlane[p4pBpA]∪Position[pF]).As previously mentioned, this constraint remains valid whatever the current positions are: if the orientation of the two half-planes are different, the domain of p1 is not altered (Fig. 31), but if these orientations are parallel and opposite, the domain of p1 is restrained (Fig. 32). This remains true even if the orientations are undefined — when p2 and p3 are coincident or p5 and p6 are coincident.The native operations presented in Section  4.1 are not very practical for direct use by the designer. An extensive library of higher-order procedures must be created in order to meet the user’s intuitive workflows. These routines can be seen as declarations of successive native operations. A first set of routines can concern purely geometric statements — e.g. constraining a point on the middle of a segment, on a certain distance from a given segment or on the mirror of another constraint. Another set of routines can build the equilibrium of standard sub-structures — e.g. sustaining a set of forces with a catenary or a basic truss or refining a sub-structure to allow a denser discretization of a certain distributed load.More specialized routines can be used in line with the nature of the current structural abstraction — e.g. graphically describing the bending moments in a given beam, defining new operations that are able to build and modify discontinuous stress fields, or graphically optimizing the given criteria of a strut-and-tie network.Other routines can also be used to handle topological restrictions. For instance, Fig. 33presents the domain that the highlighted point must satisfy in order for the rod to remain in compression. This domain can be deduced from the rules defining the type of application of a force (see Section  3.4).Finally, routines can be used to apply boundary conditions to the strut-and-tie network. Fig. 2 shows one example of this, while Fig. 41 presents another.An interesting consequence of the nature of the geometric constraints discussed in this paper is the ability to compute conditional statements graphically–such as If/Else conditions–by basic combinations of primitive constraints. Although these constraints are constructed symbolically as usual, their inner behavior produces conditional results that are continually updated when points are moving. The conditional result–i.e. the graphical region of this constraint–is chosen to be the unique position if the condition is satisfied and its inverse–i.e. the entire plane excluding the unique position–if the condition is not satisfied. A complete set of conditional expressions can be obtained with five non-fundamental constraints: the first checks the coincidence of two positions, the second and third check if four points presently verify a membership with a HalfPlane or with a DiscInside constraint, and the final two compare two simultaneous coincidences either conjunctively or disjunctively.By way of introduction, theConcidenceCondition[p0p1p2]constraint is presented. It returns a domain equal to the position of p0 if p1 and p2 are coincident, and the inverse if not. This constraint can be defined using the following combinations (Fig. 34):CoincidenceCondition[p0p1p2]≔∖(Straightedge[p0p1p2]∩Straightedge[p0pApB])∪(Compass[p1p2p0]∩Straightedge[p1p2p0]∩HalfPlane[p1pCpD])where:pA∈Compass[p1p1p2]∩Compass[p2p2p1]∩HalfPlane[p1p1p2]pB∈Compass[p1p1p2]∩Compass[p2p2p1]∩HalfPlane[p2p2p1]pC∈Compass[p2p2p0]∩Compass[p0p0p2]∩HalfPlane[p2p2p0]pD∈Compass[p2p2p0]∩Compass[p0p0p2]∩HalfPlane[p0p0p2].A second interesting technique is the ability to switch the dependencies of constraints between themselves — that is to say, to make a child point its father’s father and vice versa. This feature is highly convenient for the user because it allows an inversion of the parametric hierarchy at any time, without having to rebuild the entire problem. It is as if the user first analyzes the behavior of a certain result by varying the terms of the problem and then decides to alter this result explicitly to see how the terms of the problem would behave.If the dependencies hierarchy between two pointspAandpBis to be switched, the following procedure applies:•ifpBis a descendant ofpA–T1=the set of all the descendants ofpAthat are also ancestors ofpBT1 is breadth-first sorted starting from childless points and ending with orphans (parallel dependencies may occur)addpAat the end of T1 andpBat the beginning of T1for every pi and pi+1 of T1:∗fromAEDgetT2=the set of all the constraints applied onto pifromAPCget T3= the subset of T2 that uses pi+1for every constraint cj in T3:⋅apply the native operationSwitchDependencies[pipi+1cj](see Section  4.1).This procedure is significant only when there is no loop of interdependency betweenpAandpB. Moreover, this procedure does not create superfluous interdependency because all the parallel dependencies–i.e. when a point is the parameter of another point through several constraints–are switched together. The following construction is used as a basic example (Figs. 35 and 36):p7∈StraightedgeA[p4p1p2]∩StraightedgeB[p6p0p1]p8∈StraightedgeC[p5p2p3]∩StraightedgeD[p7p0p2]p9∈StraightedgeE[p8p0p3].This description can be seen as the geometric skeleton of a simply-connected structure passing through p6 and bearing two forces that are applied on p7 and p8 and that have magnitudes equal to the distances p1p2 and p2p3 respectively.The point p6 can be moved anywhere in the plane while p8 is constrained on the intersection of two straightedges. The example consists of switching those two degrees of freedom. Since p8 is a grandson of p6, the algorithm must perform two successive changes on the graph of Fig. 36: the first between p8 and p7  (SD), and the second between p7 and p6  (SB). After the switching, the resulting dependencies are as follows (Fig. 37):p6∈StraightedgeF[p7p0p1]p7∈StraightedgeA[p4p1p2]∩StraightedgeG[p8p0p2]p8∈StraightedgeC[p5p2p3]p9∈StraightedgeE[p8p0p3].Point p8 is now the one that controls the structure geometry. It is important to note that no computation of solutions is required by these changes of dependencies because the positions remain unchanged. Another example will be introduced at the end of Section  6.Many practical applications are strut-and-tie networks that are required to remain inside a given area (Fig. 41). In order to ensure consistency, these areas are propagated on every domain of solutions associated with the strut-and-tie network. Although it is easy to constrain a point inside a given region by direct application of constraints, to constrain an entire rod inside a given region is less straightforward. Fig. 38shows a rod that is not entirely inside a region although its extreme points are constrained inside that region. This issue can here be settled by applying particular constraints on both extreme points of the rod and the boundary segment it crosses. In concrete terms, the two line segments p0p1 and p2p3 never cross if the point p0 is constrained as follows (Figs. 39 and 40):p0∈HalfPlane[p1p1pA]∪HalfPlane[pBpBp1]∪HalfPlane[pBpBpA]where:pM∈MidPoint[p2p3]pA∈(Position[p2]∪Position[p3])∩HalfPlane[p1p1pM]pB∈(Position[p2]∪Position[p3])∩HalfPlane[pMpMp1].This definition remains valid when p1,p2 and p3 are aligned and when p2 and p3 are coincident.The following figures briefly simulate the reconstruction of the structural skeleton of Robert Maillart’s Chiasso sheds (1924). Other applications may be found in [19]. First the buildable volume is defined as a Boolean combination of HalfPlane constraints (Fig. 41) and a first load case is discretized and applied on a Straightedge constraint representing the roof (Fig. 42) using the operations CreateZeroForce, ResolveForce and MovePoints. Unlike Maillart’s original design process  [20], the goal here is not to find a way to close the force polygon by successive adjustments in the form diagram. Rather the role of the designer is to focus on what operations should be applied to transform the initial equilibrium until the only remaining forces are the loads applied on the structure or the reactions at the supports. For instance, Fig. 43shows two sub-networks being combined together in Fig. 44with the operations CreatePrimitiveConstraint, ApplyConstraint and CreateRod: the pairs of forcesFAFA′,FBFB′andFCFC′form the rods RA,RB and RC. Fig. 45shows the final strut-and-tie network. In some cases, rods (e.g.  RD) and their magnitudes directly provide the orientation and width of the effective structural members. In other cases, the eccentricity between a rod (e.g.  RE) and the corresponding line of centroids multiplied by the magnitude of the rod measured in the force diagram provides the bending moment occurring in the structural member.Since every rod in the form diagram is constrained to remain inside the buildable volume, this buildable volume is propagated onto each movable point of the final network. The solution domains ofpAandpBfor example (Fig. 45) consequently synthesize the remaining degrees of freedoms with which this structural shape can be altered (Fig. 46).The impact of these alterations can be studied simultaneously in two ways: according to spatial considerations and mechanical considerations. For instance, pC (defining the buildable volume) can be dragged to see how the buildable volume modifies the extreme valuepA∗of the domain ofpAand hence to see what the allowable orientations are that minimize the stresses inside RF and RG. As a consequence, specific design objectives can be simply achieved by dragging points (e.g. the smaller the force diagram, the less volume of material is needed) or by applying new geometric constraints (e.g. compellingpAto remain inside a disc centered inpFand whose radius is given by the maximum allowable tensile strength in RH, Fig. 47).Moreover, other load cases may be studied by varying the points that define the loads in the force diagram. For instance the position ofpEcan be dragged (Fig. 48) to see how the bending moments in the column RE fluctuate when the loadFYincreases or has another orientation.In the current construction, draggingpA(respectivelypB) has the effect of changing the position ofpD(respectivelypE) (Fig. 45). That means that two points in the force diagram (pAandpB) control the geometry of the structure. If the user now wishes to control the structure by moving points in the form diagram in order to see how the force diagram reacts, he simply has to switch the dependencies betweenpAandpDand betweenpBandpE(Fig. 49). This operation is fully automated (Section  5.3) and no reconstruction of the parameterization of both diagrams is needed.

@&#CONCLUSIONS@&#
