@&#MAIN-TITLE@&#
Distributed evolutionary algorithms and their models: A survey of the state-of-the-art

@&#HIGHLIGHTS@&#
Provide an updated and systematic review of distributed evolutionary algorithms.Classify the models into population and dimension-distributed groups semantically.Analyze the parallelism, search behaviors, communication costs, scalability, etc.Highlight recent research hotspots in this field.Discuss challenges and potential research directions in this field.

@&#KEYPHRASES@&#
Distributed evolutionary computation,Coevolutionary computation,Evolutionary algorithms,Global optimization,Multiobjective optimization,

@&#ABSTRACT@&#
The increasing complexity of real-world optimization problems raises new challenges to evolutionary computation. Responding to these challenges, distributed evolutionary computation has received considerable attention over the past decade. This article provides a comprehensive survey of the state-of-the-art distributed evolutionary algorithms and models, which have been classified into two groups according to their task division mechanism. Population-distributed models are presented with master-slave, island, cellular, hierarchical, and pool architectures, which parallelize an evolution task at population, individual, or operation levels. Dimension-distributed models include coevolution and multi-agent models, which focus on dimension reduction. Insights into the models, such as synchronization, homogeneity, communication, topology, speedup, advantages and disadvantages are also presented and discussed. The study of these models helps guide future development of different and/or improved algorithms. Also highlighted are recent hotspots in this area, including the cloud and MapReduce-based implementations, GPU and CUDA-based implementations, distributed evolutionary multiobjective optimization, and real-world applications. Further, a number of future research directions have been discussed, with a conclusion that the development of distributed evolutionary computation will continue to flourish.

@&#INTRODUCTION@&#
With metaheuristic and stochastic characteristics, evolutionary computation (EC) has shown to be effective solvers for hard optimization problems in real-world applications. However, with rapid development of the information age and the emergence of “big data”, the increasing size and complexity of the problems has posed new challenges to EC. This is especially so if the search space involves a huge number of local optima or the computational cost of fitness evaluation becomes extremely high. When a traditional sequential evolutionary algorithm (EA) is unable to provide satisfactory results within a reasonable time, a distributed EA (dEA), which deploys the population on distributed systems, can improve the availability. It also offers an opportunity to solve extremely high dimensional problems through distributed coevolution using a divide-and-conquer mechanism. Further, the distributed environment allows a dEA to maintain population diversity, thereby avoiding local optima and also facilitating multiobjective search.The framework of developing a distributed EA is illustrated in Fig. 1. Its fundamental algorithms embrace all kinds of EAs including the genetic algorithm (GA), evolutionary programming (EP), evolution strategy (ES), genetic programming (GP), and differential evolution (DE). Moreover, other population-based algorithms, such as ant colony optimization (ACO) and particle swarm optimization (PSO), share common features with EAs and are hence also included in this survey. Then, by employing different distributed models to parallelize the processing of EAs, various dEAs can be designed. The logistical distributed models have several issues to address, such as the distribution of evolution tasks and the protocols for communications among processors. The granularity of the distribution may be at the population level, the individual level, the operator level, or the variable level. Correspondingly, there can be various communication rules in terms of the content, frequency, and direction of message passing. In the literature, master-slave [31], island (a.k.a. coarse-grained model) [56,99], and cellular (a.k.a. fine-grained model) [51,1] models have been commonly used to build dEAs. Moreover, other models such as the hierarchy (a.k.a. hybrid model) [41], pool [104], coevolution [121,122], and multi-agent models [10] are also widely accepted. After designing a dEA, different programming languages and tool sets can be adopted to implement the algorithm, such as the Message-Passing Interface (MPI) [63], MapReduce [81], and Java [129,38]. There also exist software packages for dEC, such as the Paladin-DEC [126,127] and ParadisEO [14,15]. Finally, the format of the physical platform that can be used to deploy the algorithms includes cluster [73], grid [39], P2P network [141], cloud [44], and GPU [151]. These platforms have different architectures, network connectivity, resource management schemes, and operating systems. Two recent papers, [133,65], review and discuss the parallel and distributed GAs in considering different physical platforms. The selection of the underlying platform partially influences the implementations of dEA models, and also determines the system performance such as scalability and fault-tolerance.As there exist a very large number of research outputs in dEAs, it is impossible to cover all the relevant works within the page limit of this article. Therefore, references are presented based on their influence, rigor, years of publication, numbers of citations, and coverage. Models (the second layer in Fig. 1) continue to be a focus of interest in developing dEAs and will hence form the main body of this article.We aim at providing readers with an updated, comprehensive and systematic coverage of dEAs and the state-of-the-art dEA models. The characteristics (or novelties) of this article are presented as follows. (1) Compared with [3,16,4,131] published ten years ago, this survey introduces and describes more recent works in this area. In addition to the master-slave, island, cellular, and hierarchical models surveyed in the literature [3,16,4,131,97], we further review some state-of-the-art distributed models for EC, including resource pool-based model, coevolution model, and multi-agent model. To the best of our knowledge, no previous survey of dEC covers these fields. (2) To update with a systematic treatment on the research progress, we semantically divide dEA models into two major categories, i.e., population-distributed models and dimension-distributed models. The operating mechanisms of different dEA models are analyzed and compared, as well as their corresponding performance, advantages, disadvantages, and ranges of applicability. (3) Recent research hotspots, including cloud and MapReduce-based implementations, GPU and CUDA-based implementations, multiobjective dEAs, and real-world applications, are also discussed in this survey. (4) In addition to a literature review, emerging research directions and applications are presented for possible further development.The rest of this article is organized as follows. Section 2 introduces terminologies for a systematic treatment and classification. Section 3 presents population-distributed and dimension-distributed models, followed by a summary and analysis of characteristics in Section 4. Section 5 is devoted to the four recent research hotspots. Finally, we highlight some potential future directions in Section 6 and draw conclusions in Section 7.In this section, we briefly introduce the terminologies that will be used throughout this article. The first two concepts, i.e., “synchronism/asynchrony” and “homogeneity/heterogeneity”, are widely used to describe the properties of dEAs, whereas the “speedup”, “distributed efficiency”, “fault-tolerance”, and “scalability” are performance metrics for evaluating dEAs.Synchronism and asynchrony. An indispensable issue in a dEA as well as any other distributed algorithm is the communications among processors. If all communications are controlled by a clock signal, then the algorithm is said to be synchronous, otherwise asynchronous. In an asynchronous dEA, communications take place more freely or automatically driven by data.Homogeneity and heterogeneity. For dEAs, homogeneity and heterogeneity are used to describe whether the evolution tasks on different processors are of the same settings. In a homogeneous dEA, each processor adopts the same operators, control parameters, fitness evaluation, etc., whereas in a heterogeneous dEA, the local algorithmic settings for different processors vary.Speedup and distributed efficiency. The distributed processing performance of dEAs is qualified by a speedup measure, the ratio of sequential execution time to parallel execution time of the algorithm [31]. Ideally, the speedup should be equal to the number of processors being used. Based on this, distributed efficiency is defined as the ratio of speedup to the number of processors and its ideal value is 100%. In practice, the speedup and efficiency of dEAs may be limited by the computational overhead, the performance of the most loaded node, and the communication speed between processors.Fault-tolerance. When running EAs on a physical distributed system, part of the underlying hardware or network may encounter failure. Fault-tolerance measures the ability of a dEA to continue optimization in the condition of some physical components failing. A fault-tolerant dEA will not be suspended in such condition, instead, it continues search with the remaining working nodes at a level of graceful degradation.Scalability. The scalability of dEAs involves two aspects: “size scalability” and “task scalability”. Size scalability refers to the ability of the algorithm to achieve proportionally increased performance by increasing the number of processors. Task scalability refers to the ability of algorithm to adapt to the changes in the problem scale, e.g., whether the algorithm can retain its efficiency when the problem dimension increases.As a final note, within this paper, the terms dEC and dEAs are used in a general sense, which include both the algorithms implemented on parallel systems (where the processors or threads are tightly coupled with a shared memory) and the algorithms implemented on distributed systems (where the processors are loosely coupled with a computer network).Basically, a distributed EA divides computing tasks based on two types of models. As illustrated in Fig. 2(a), a “population-distributed” model distributes individuals of the population (or subpopulations) to multiple processors or computing nodes, whilst a “dimension-distributed” model distributes partitions of the problem dimensions (or subspaces). The population-distributed model can be further divided to master-slave [31], island (a.k.a. coarse-grained model) [56,99], cellular (a.k.a. fine-grained model) [51,1], hierarchical (a.k.a. hybrid model) [41], and pool models [104], as illustrated in Fig. 2(b). On the other side, the dimension-distributed model can be divided to coevolution [121,122] and multi-agent models [10].The master-slave model summarizes a distributed approach to the EA operations and domain evaluations as illustrated in Fig. 3. The master performs crossover, mutation, and selection operations, but sends individuals to slaves for fitness evaluations because these form the majority of the computing load. As the evaluations of individuals are mutually independent, there is no requirement of communication among slaves. The master-slave model is hence simple, in which communications only occur when the unique master sends individuals to slaves and the slaves return the corresponding fitness values back to the master in each generation.Variants to improve efficiency. For problems whose evaluation costs are not relatively high, however, employing a master-slave model may become inefficient in that communications occupy a large proportion of time in the dEA. In recent years, variants of master-slave dEAs have been developed to address this issue. A commonly used method is to distribute not only the evaluation tasks but also the individual update tasks to slave nodes [63,84,105,61]. Another approach is a coarse-grained master-slave model in which each slave processor contains a subpopulation, while the master receives the best individual from each slave and sends the global best information to all slaves [144]. Note that such a coarse-grained master-slave model is different from the island model being introduced in the next subsection. First, the control of the former is centralized whereas the control of an island model can be either centralized or distributed. Second, as mentioned above, slaves do not communicate with slaves, but in an island model, the islands frequently communicate with each other. The third possible way to improve the distributed efficiency of master-slave dEAs is to conduct local search on slaves [147,119]. In the algorithms, master conducts basic EA for global search whereas the slaves execute local search by considering the individuals received from the master as neighborhood centers.Synchronism and asynchrony. Most existing master-slave dEAs are synchronous that the master stops and waits to receive the information of all slaves before proceeding to the next generation. Some are asynchronous, where the selection operations on the master node perform on a fraction of the population only [106,107]. In an experimental study of a master-slave PSO algorithm [110], it is shown that synchronization plays a vital role in algorithm performance on load-balanced problems, whilst asynchronous dEAs are more efficient for load-imbalanced problems.Speedup. The speedup and efficiency of master-slave dEAs may be limited by the master's performance and by the communication speed between master and slaves [17]. Specifically, the limitation is determined by the computational costs of the tasks executed on the slaves. For example, Dubreuil et al. [31] show that the master-slave model can perform well as long as the individual evaluation time is much greater than the message passing time, as can be expected. In their experiment, solving a problem requiring 0.25s for evaluation yields an efficiency of 82%, but if the evaluation time increases to 1s while the communication overhead remains the same, the efficiency becomes 95%.Fault-tolerance. For massive dEAs, how to improve the fault-tolerance is another important issue. Gonzalez and De Vega [55] argue that master-slave dEAs are intrinsically fault-tolerant. In [120], a fault-tolerant DE algorithm based on a master-slave model is proposed, where the individuals are distributed to a grid of nodes for fitness evaluations and if certain individuals fail to return from their nodes in an acceptable time, they can be replaced with random individuals. This mechanism not only shows fault-tolerance, but can also help improve population diversity.An island model, as well as a cellular model, is a spatially distributed model. The difference between an island model and a cellular model lies in the parallelization grain. As depicted in Fig. 4, an island model is coarse-grained, where the global population is divided into several subpopulations, each of which is processed by one processor. Communications between the islands occur when certain individuals in one island migrate to another at a set interval. The migration mechanism includes the migration frequency and extent, the selection policy on the source island, and the replacement policy on the target island.Synchronism and asynchrony. An island dEA is often synchronous that the best individual on each island propagates to all the other islands at a specific interval of generation [89,100,148]. Asynchronous island models also exist [30,80], where an island can receive migrated information as soon as it is ready. In general, synchronous island dEAs are simpler to design and implement, whereas asynchronous algorithms are more flexible and can maximize efficiency.Homogeneity and heterogeneity. In a homogeneous island model, each subpopulation adopts the same settings of operators, control parameters, and fitness evaluations, etc. There exist two shortcomings. First, if the underlying physical system is heterogeneous, slower processors will hinder the efficiency of the algorithms. Second, using the same algorithmic settings on different subpopulations may not balance global exploration and local exploitation. Because of these, heterogeneous island models are developed. One example is the heterogeneous island GA [112], where subpopulations are arranged in a three-layer hierarchal manner: the top layer refines exploitation, the intermediate layer balances exploration and exploitation, and the bottom layer conducts full-on exploration. A hypercube island model is developed in [56], where subpopulations on the front side use different crossover operators for exploration and the others on the rear side adopt crossover operators that are more suitable for exploitation. Moreover, the exploration and exploitation degrees of subpopulations on the same side are gradual. Other heterogeneous island dEAs can be found in [138,139].Topology and migration strategy. The original island dEAs adopt a complete graph as the topology of the islands (i.e., they are fully connected “using no topology”). Whitley and Starkweather [140] and Lorion et al. [79] put forward that, if the migration conducts among all islands, the distributed algorithm has almost the same search behavior as a sequential algorithm. In recent years, research into network topology of island models has attracted much attention [140,79,148]. In [62], island DE algorithms with different network topologies including ring, torus, hypercube, and hierarchy are studied, and experimental results confirm the superior performance of adopting a network topology in island DE.The advantages of using an island model include not only time saving, but also the improvement of global search ability of EAs. Traditional EAs with a single population suffer from premature convergence problem when all individuals gather in a same valley. By deploying a number of subpopulations on isolated islands, it is possible to maintain more than one best individual (attractor). Within the time interval between communications, individuals on different islands can evolve with different directions. This helps EAs to maintain population diversity so as to repel local optimality [99,76]. In [7], an island-based distributed DE algorithm is tested on the well-known CEC 2005 test suite for real-parameter optimization [123], with results showing that the algorithm outperformed eight sequential EAs. Further, the work in [62] shows a tradeoff between the exploration and convergence feature of DE by using different migration frequencies. With a higher communication frequency, the island DE can converge faster but may get trapped, and, oppositely, the algorithm exhibits better global exploration ability but converges much slower when the communication frequency is lower. Moreover, the work in [130] indicates that the migration extent also bears a significant impact on the algorithm performance. In [18], a Markov chain model of predicting the expected solution quality of dEAs is developed, with correctness verified by numerical experiments.Scalability and fault-tolerance. Regarding the system performance of island model, Hidalgo and Fernandez [58] argue that, as performance of island-based dEAs is highly sensitive to the number of islands used and the resulting granularity, scalability of the island model can be limited. Besides, Hidalgo et al. [59] point out that, to a certain extent, fault-tolerance also exists in an island model.Illustrated in Fig. 5, a cellular model is fine-grained and spatially structured, which has only one population but arranges the individuals on the grid, ideally one per processor (cell). The interaction among individuals is realized through the communication defined by a network topology. Each individual can only compete and mate within its neighborhood. As the neighborhood of individuals overlaps, good individuals can propagate to the entire population.Synchronism and asynchrony. Similar to an island EA, a cellular EA (cEA) can also be either synchronous or asynchronous [132]. In the former, all cells update their individuals simultaneously, whereas in the latter, the cells are updated one by one. The four commonly used asynchronous update strategies are the fixed line sweep (LS), fixed random sweep (FRS), new random sweep (NRS), and uniform choice (UC), as proposed in [109]. Alba et al. [2] compare the asynchronous cEAs using these four update strategies with synchronous cEAs on both discrete and continuous problems. Their experimental results show that, with respect to discrete problems, asynchronous algorithms are more efficient, but synchronous algorithms can achieve better fitness. On the contrary, in solving continuous problems, they draw complementary conclusions that asynchronous cEAs are better in solution quality whereas synchronous cEAs win in efficiency. A novel asynchronous communication method for a cEA is proposed in [71], which uses self-adaptation of the migration rate to provide a better leverage network capacity than using a fixed migration rate.Topology. So far, most efforts in cEAs have been devoted to analyzing the effects of different topologies on the algorithm performance. In particular, the selection intensity in cEAs on various topologies has been widely investigated. In [51,47,49,46], Giacobini et al. study the selection intensity of cEAs with linear topology, toroid topology, and regular lattices as well as the asynchronous cEAs, respectively. In their studies, a takeover time measure proposed by Goldberg and Deb [53] is used. The takeover time is defined as the duration of a single individual propagating to the entire population with no variation other than selection. The shorter the takeover time is, the higher the selection intensity is, which represents a higher exploitation degree of the algorithm. Their experiments show that choosing of a network topology can have significant impact on the selection intensity and the algorithm performance.In recent years, as the network scale of cEAs becomes larger, complex networks such as the well-known small-world network and scare-free network have been introduced to cEAs. In [50,48], Giacobini et al. use takeover time analysis to investigate the selection intensity of cEAs based on small-world topology and scale-free topology, respectively. In [68], the performance of cEAs using four topologies, including the 2D regular lattice, small-world network, random graph, and scale-free network, is investigated. Their experimental results show that, with the increase of the problem complexity, the ideal topology should change from one with a high mean degree distribution (the regular topologies) to a network with a high clustering coefficient (the complex networks).Apart from the takeover time, a ratio measure of the neighborhood radius to the topology radius proposed in [108] has been widely used to study the performance of cEAs. In [5], Alba and Troya conduct a set of tests to analyze the performance of cEAs with different ratio values on different classes of problems. The paper concludes that a cEA with low ratio is more effetive for multimodal and/or epistatic problems, whereas a cEA with high ratio performs better on non-epistatic and simple problems. Based on these, a novel cEA with dynamic ratio from low to high during a run is developed, which is verified to be efficient in the paper. Further, an adaptive cellular GA is developed in [1], which adaptively adjusts the neighborhood-to-topology ratio during the search process according to some rules defined on the average fitness (AF), population entropy (PH), and their combination (AF+PH).The hierarchical model, also known as hybrid model, combines two (or more) distributed models hierarchically to take advantages of both models for improving scalability and problem-solving capability.Island – master-slave hybrid. In [12,13,75], the population is divided into several subpopulations, which run on different master processors and communicate in some specific time. For each subpopulation, the master sends the individual evaluation tasks to its own slave processors so as to further improve parallelization grain. As shown in Fig. 6(a), the model is island and master-slave hybrid, which uses island model in upper layer and master-slave model in lower layer. Such a model not only eases scalability limitation of an island model but also reduces dependency of the single master node in a master-slave model. In [13], Burczyski et al. show that the speedup of their island–master-slave hierarchical algorithm is relatively linear.Island – cellular hybrid. The hybridization of island and cellular models has also attracted attention. Folino and Spezzano [42] develop a distributed GP algorithm running on multiple islands that contain local cellular GP approaches. Such a model is shown in Fig. 6(b), where an island and a cellular model are adopted in the upper and lower layers, respectively. Numerical results on benchmark functions show that a hierarchical GP algorithm presents accuracy comparable with classical distributed models, while providing advantages of high scalability and fault-tolerance [42]. The algorithm has been further improved by Folino et al. and applied in pattern classification in [41].Island – island hybrid. Another hierarchical model of dEAs is to adopt the island models in both upper and lower layers, as shown in Fig. 6(c). Herrera et al. [57] point out that, in this kind of model, a key issue is to develop two different migration approaches, i.e., local and global ones, since they establish the real hierarchy between basic dEAs and the hierarchical dEAs. Moreover, the advantages of using such a hierarchical model include improved efficiency of each node, more diverse collaboration, and good conjunction of homogeneous and heterogeneous dEAs. Based on these, Herrera et al. develop a heterogeneous hierarchical dEA and achieve promising results.The above master-slave, island, cellular, and hierarchical models offer the promise of massive scalability and fault-tolerance if the problem to solve can be properly adapted to their size and peculiarities [85]. However, there is still certain inflexibility and inefficiency that hinders the use of these models. For example, in a master-slave model, with the increase of the number of slave nodes, the speedup will eventually become poor when the master saturates. In island and cellular models, the predefined topology and the rigid connectivity restrict the amount of islands or cells to be used and the spontaneous cooperation among the nodes. Although the models can be asynchronous and heterogeneous, the asynchronization and heterogeneity pose restriction on the performance of corresponding dEAs. Compared with this, a pool model deploys a set of autonomous processors working on a shared resource pool. The processors are loosely coupled, which do not know each other's existence and interact with only the pool. The model provides a natural approach to realizing asynchronization and heterogeneity.Instance. For better understanding of the pool model, we describe a distributed pool architecture for EC proposed by Roy et al. [104] in detail as an instance. As illustrated in Fig. 7, the pool is a shared global array of length n representing n individuals in the population. Then, the array is partitioned into p segments of size u, which correspond to p processors (or threads). Each processor can read individuals from any segments of the array, but can only write the individuals back to its own partition. In the optimization process, a processor randomly chooses u individuals from the entire pool to undergo genetic operations. After generating u offsprings c1, c2, …, cu, the processor writes each new individual ciback to the ith entry of its own partition if the fitness of ciis better than that of the current ith entry. In summary, key issues of designing such a dEA include 1) implementing the resource pool, 2) individual selection policy (consuming policy on the pool), and 3) individual replacement policy (producing policy on the pool).Advantages. As processors are loosely coupled to work on a shared resource pool, they can accommodate asynchronization and heterogeneity relatively easily. Moreover, in a pool model, the set of participating processors can be dynamically changed, and the system works well even when some of the processors crash. By replicating (backing up) the resource pool, the model can achieve superior fault-tolerance. Another possible advantage of such a loosely coupled distributed model is that it can be cost-efficient. For example, volunteers around the world can contribute the idle time of their computers for processing the tasks.Resource pool. In a pool-based distributed model for EAs, how to implement the resource pool is a crucial issue to address. Tuple-Space (TS), the shared-memory programming model of Linda, provides a virtual shared-memory data storage that processors can read and write. By mapping a GA onto TS, a pool-based distributed GA is built, with a natural load-balancing effect that faster processors end up doing more work than slower processors [23]. This work is perhaps the first dEA based on a pool model. Since then, work has been reported on employing a database as the central resource pool for dEAs. There are two major advantages of adopting a database as the pool. First, as suggested by Bollini and Piastra [9], an object-oriented database management system provides mature transaction and data locking mechanisms. It allows any number of evolutionary processes run in parallel on the underlying population without extra control policies. Second, the database can persistently and permanently store the population until it is modified by the users. Therefore, the computation of dEAs can span weeks or even months, such as the distributed BEAGLE proposed in [43].In recent years, there are many pool dEAs developed, based on matching implementations of EAs to programming models or toolkits such as MapReduce and CouchDB. As this section mainly focuses on the models rather than the implementations, these works will be described briefly in Section 5.1.A coevolution model is a dimension-distributed model. Instead of dividing the population, a dimension-distributed model divides a high dimensional complex problem into several lower dimensional and hence simpler problems. Note that, however, dimension distributed and population-distributed models have no clear boundaries, and a dimension-distributed model can also arrange its tasks in an island, cellular, or hierarchical manner, etc.If the problem is decomposable, i.e., the sub-problems can be solved independently, the subcomponent on each processor can evolve without interacting with the others. At the end of the optimization, by jointing the sub-solutions together, an optimal solution of the entire problem emerges. Unfortunately, most of practical optimization problems exhibit complex interdependencies, for which the solution obtained by the above divide-conquer-and-joint mechanism may be inferior. It is suggested that a change of one subcomponent (e.g., a new optimal solution found in one processor) can lead to the deformation or warping of the fitness landscapes in its interdependent subcomponents. The distributed coevolution model is developed to deal with the above problem.In biology, coevolution indicates that the change of a species triggers the change of its related species, and then leads to an adaptive change of its own part, and so forth. This way, different species in the environment have correlative dependence, and, from a general viewpoint, they evolve cooperatively. The coevolution model for dEC borrows this concept, where each node performs a local evolution process in a solution subspace. Then, by intercommunication, the nodes interact with the others, adaptively adjust their search direction, and cooperatively find the global optimum. Potter and De Jong [101] point out that, when developing coevolutionary algorithms, four issues need to be addressed. They are problem decomposition, the evolution of interdependent subcomponents, credit assignment (evaluation), and maintenance of diversity.Fundamental framework. In 2004, Subbu and Sanderson [121,122] develop a fundamental framework for distributed coevolutionary algorithms, analyze the convergence of the framework, and examine the network-based performance. As illustrated in Fig. 8, assuming the variable vector x consisting of p blocks (x1, x2, …, xp), each node i in the algorithm performs a local evolutionary search process by considering the ith block xiprimarily and the other p−1 blocks secondly. Specifically, the local reproduce operation is conducted on the primary block xiwhile the remaining variables are clamped. In the evaluation, the fitness of the whole solution (including both the primary and secondary blocks) is calculated, and the local algorithm is more likely to preserve solutions with better fitness. In this way, the primary variable block on the node evolves. Then, in the intercommunication phase, the nodes update their secondary variable blocks. By alternating the local search and intercommunication phases, an adaptive system is built, capable of solving high-dimensional complex problems. Most recent distributed coevolutionary algorithms have adopted the above framework, but differ in problem decomposition strategies, local EAs, and intercommunication.Decomposition strategy. It may be possible to decompose an n-dimensional problem into n one-dimensional problems in some applications. However, this is often not the case and hence Yang et al. [145] suggest using a group-based decomposition strategy to better capture variable interdependencies for nonseparable problems. For this, an adaptive weighting strategy is developed in [145], where the chance of one dimension to be assigned into a subcomponent is adaptively adjusted during the search process. Li and Yao [72] further improve the decomposition strategy of Yang et al. by dynamically changing the group size, and successfully solve up to 2000-dimensions problems. In [73], a coevolutionary DE is designed for power system optimization. The whole system is decomposed into a series of subsystems with different numbers of control variables by using an agglomerative hierarchical clustering (AHC) method. Each species is responsible for the regulation of control variables in its own subsystem, while taking the values of the other control variables from the global best individual found so far. Ray and Yao [102] develop an adaptive variable partition strategy, in which all variables involve together at the beginning of the algorithm and then be grouped by a correlation coefficient.Intercommunication and credit assignment. Intercommunications in [149] are realized through adaptive migration of the best primary variable block of each node during the optimization. Potter and De Jong [101] and Tan et al. [128] point out that combining the primary block of one species with only the best blocks from the other species is often too greedy, which may result in getting trapped in local optima. In their proposed algorithms, the primary block of each species is first combined with the best blocks from other species and then combined with some random representatives of every other species. After evaluation, the better one is retained. In [52], Goh and Tan further introduce a competitive process in the coevolution to improve the contribution of each species. In their proposed competitive-cooperative coevolutionary paradigm, the interplay of competition and cooperation facilitates the discovery of interdependencies among species.In the above coevolution model, the global goal of the entire system is essentially the local goal of each subcomponent, which is achieved by coordination of subpopulations. In comparison, a multi-agent model does not require any direct coordination of agents to achieve the global goal. Instead, it adopts game-theoretic method in the field of distributed artificial intelligence (DAI) that agents optimize local functions and establish some equilibrium. In the equilibrium, once the local objectives cannot be further improved, the global goal of the entire system is achieved. In this way, the global goal is realized by observation rather than evaluation.Methodology. The main idea of a multi-agent model is to consider a dEA as a multi-agent system that p players (agents) are playing a strategy game. Each player in the game has a payoff function that depends on the actions of itself and its limited neighbors. Then, each player plays independently in the game and selects actions to maximize its own payoff selfishly. A widely accepted solution for this non-cooperative game is the Nash equilibrium point, a p-tuple of actions for all players that anyone who deviates from it cannot improve its own payoff [96]. One issue to be addressed here is how to convert the global optimal solutions of the problem (or the maximal price points in the game) into Nash equilibrium points. Not all practical problems can be solved by dEAs based on a multi-agent model, unless the problem accommodates the above converting process.Loosely coupled GA. EA based on a multi-agent model appeared as early in the 1990s as the loosely coupled GA (LCGA) proposed by Seredynski [113]. In this algorithm, each player creates a subpopulation of its actions, and the payoff is considered as the evaluation value of the local fitness function. Standard genetic operations, including selection, crossover, and mutation, are applied locally to the subpopulation of actions. Then, after a number of iterations, the players find actions corresponding to the Nash equilibrium. Experimental study in [113] has shown that the LCGA can optimize the global objective in a fully distributed way of evaluating only local fitness functions. Afterwards, the LCGA is widely used in both function optimization and real-world applications such as mapping and scheduling problems [10,114].Comparisons between multi-agent and coevolution models. A comprehensive comparison between the LCGA and the cooperative coevolutionary GA (CCGA) is reported in [115], which can also be regarded as a comparison between the multi-agent model and the coevolution model. As introduced above, the main difference between LCGA and CCGA is that the former evolves local objectives on agents and requires no coordination of agents. The experimental study in [115] illustrates that if the global objective problem can be expressed in a sum of local objectives, using LCGA is more efficient, as it can obtain high-quality solutions at a relatively low computational cost. However, for the other complex problems that are hard to be expressed in a fully distributed way, CCGA outperforms LCGA. The study in [22] shows similar conclusions, although Danoy et al. further point out that LCGA is more scalable than CCGA. Besides the LCGA, a multi-agent memetic algorithm named MA2 is developed in [98], in which each agent in the multi-agent system is a subpopulation of a memetic algorithm (GA with local search). The algorithm has also shown its powerfulness in tackling high-dimensional optimization problems.In this section, we summarize and analyze dEC models by comparing their parallelism, search behaviors, objectives, communication costs, scalability, and fault-tolerance, for the ease to readers in considering future work. This is conducted in a general sense regarding our above presentation of models. For example, if model A offers a higher scalability than model B, it implies that algorithms with model A “generally” offer a higher scalability than B, but exceptions may exist in implementations. Further, in the comparisons, we assume that the five population-distributed models do not use problem decomposition, which is also in accordance with most reported work. The comparisons are summarized in Table 1and are explained as follow.As a master-slave model parallelizes its individual evaluation tasks as well as some other operations (such as local search) on the slave nodes, the model has an operation-level of parallelism. Island and cellular models are population and individual level-based because they deploy subpopulations and individuals on the processors, respectively. As the hierarchical model can be island–master-slave hybrid, island-cellular hybrid, or island–island hybrid, etc., the parallelism level of the model can be operation-, individual-, and population-based. The two dimension-distributed models in Fig. 2(b) divide the evolution tasks by dimensions, where a model is variable-based if each processor engages with one variable only. Otherwise, if each processor optimizes a group of variables, the model has a variable block-based parallelism level.The first six models listed in Table 1 apply the unique global objective function to evaluate individuals on different processors. Differently, in multi-agent model, each processor has a local objective function to optimize. Nevertheless, it is to be noticed that the local objective-based multi-agent model can be implemented by different population-distributed models such as island, cellular, etc. In this sense, these population-distributed models can also have local objective functions on their parallel processors.The search behavior of master-slave dEAs is similar to that of sequential EAs because it conducts the major evolution process of the algorithm on its master node and only sends some computationally expensive tasks to the slave nodes. For an island model, by deploying a number of subpopulations on isolated islands, the algorithm maintains more than one best individual (attractor) during the optimization and hence increases the population diversity. Literature also shows that using an island model not only saves computing time but also improves the global search ability of EAs [99,76,7]. For a cellular model, the use of local topologies reduces the selection intensity as well as the information propagation speed on the population network, which also results in a better population diversity. Besides, as a hierarchical model hybridizes the island model with others, it exhibits the effect of an increasing diversity as well.The core method of a pool model is that the processors automatically evolve the individuals in the resource pool. The search behavior of the corresponding EAs is highly dependent on the algorithmic components in use (such as individual selection and replacement policies on the pool). Without specifying implementations of the algorithm, it is hard to identify the search behavior of a pool-based dEA. On the other hand, for the two dimension-distributed models with a divide-and-conquer method, the primary effect is the reduction of the problem space.The entire computational cost of a dEA consists of three parts, namely, the evaluation cost Cevalof the problem, the operation cost Coperof the baseline EA, and the communication cost Ccommof the distributed model. As Cevaland Coperare relatively fixed, the communication cost Ccomm, if significant, may affect the speedup and efficiency of the algorithm.In a master-slave model, the communication cost is relatively high as the master frequently communicates with slaves sending individuals and receiving fitness values. Some variants, such as the coarse-grained master-slave model, decrease the frequency of communication between master and slaves and hence partially reduce the communication cost. For an island model, as the subpopulations share their information only at set intervals, the communication cost is relatively low. Nevertheless, the number of islands and the migration strategy can affect the communication cost to a great extent. In cellular and hierarchical models, communications occur between individuals, and hence the communication costs are considered to be medium. These are however highly related to the topology or hierarchical structure in use. In pool and multi-agent models, communication costs are relatively lower because no coordination among processors is needed. In a coevolution model where local search and intercommunication phases are alternated, the communication costs lie in a medium level.The scalability of a master-slave model is limited by the workload of the master node. When it is saturated, increasing the number of slaves would only decrease the distributed efficiency of the algorithm. For an island model, as the performance of the algorithm is sensitive to the number of islands used [58], the scalability is relatively low. In the literature, dEAs with island model always use a small number of processors. The scalability of a cellular model is better than an island model. With the introducing of the complex network-based topologies, the scalability of cellular models can be further improved.Considering the hierarchical mode, as described in Section 3.4, it combines different models in a hierarchical fashion to improve its scalability. The pool model employs loosely coupled processors that do not know each other's existence. This offers high scalability. For the two dimension-distributed models, as the performance of the algorithms depends on the problem decomposition strategy (task division mechanism) used by the models to a great extent, the scalability of these two models is limited.The master-slave dEAs are fault-tolerant unless the master node fails. For island, cellular, and hierarchical models, failure of some processers will result in loss of some subpopulations or individuals. The fault-tolerance is medium to high. In a pool model, the set of participating processors can be dynamically changed, which enables the algorithms to achieve superior fault-tolerance. On the other hand, for the two dimension-distributed models, failure of a processor will result in losing subcomponents of the global solution and hence lead to a crash of the entire algorithm. Therefore, these two models are not fault-tolerant.In this section, recent research hotspots of dEAs will be presented, including the cloud and MapReduce-based implementations, GPU and CUDA-based implementations, distributed multiobjective optimization, and some real-world applications. The work is however diverse, and hence this article is restricted to derivations, benefits and representative references.Cloud computing represents a pool of virtualized computer resources. Compared to grid computing, the major difference is that cloud computing utilizes virtualization and autonomic computing techniques to realize dynamic resource allocations. As an on-demand computing paradigm, cloud offers high scalability and cost-effectiveness. Therefore, it is well suited to building highly scalable and cost-effective dEA systems for solving problems with requirements of variable demands. Although cluster [73], computing grid [39,28] and P2P network [141,71,111] have been widely used as physical platforms for dEAs, the studies of dEAs based on a cloud platform has received increasing attention since 2008 [44,45,27,16].MapReduce is a programming model for accessing and processing of scalable data with parallel and distributed algorithms. Since introduced by Dean and Ghemawat [25] in 2004, MapReduce has been seen in various web-scale and cloud computing applications. The infrastructure of MapReduce provides detailed implementations of communications, load balancing, fault-tolerance, resource allocation, and file distribution, etc. All the things a user has to do are to implement the Map and the Reduce functions. In this way, the user can focus on the problem and algorithm only, without caring about the distributed implementation details. Because of this, implementing dEAs using MapReduce has attracted increasing attention in recent years [81,64,135,78,142,153,124].Note that, although Google has described its MapReduce infrastructure, it has not released its system to public. Much of the work has been developed on Hadoop, a Java-based open-source clone of Google's private MapReduce infrastructure (by the Apache Lucene project). Moreover, Apache CouchDB, an open-source database, is used together with MapReduce to implement pool-based dEAs by Merelo et al. in [85,88,86,87].Possessing many advantages, such as high scalability, cost-effectiveness, and transparency, the cloud and MapReduce-based implementations of dEAs still have some shortcomings. Generally, the speedup and distributed efficiency of dEAs deployed on clouds are lower than those deployed on clusters and computing grids, due to the increased communication overhead. The cloud computing paradigm prefers availability to efficiency, and hence the corresponding dEAs are more suitable for business and engineering applications, but rather the scientific computing where the speedup and distributed efficiency continue being a core index for performance evaluation.A Graphics Processing Unit (GPU) is a powerful electronic circuit capable of executing hundreds of threads simultaneously. Early GPUs functioned as coprocessors to offload CPUs from tedious graphics tasks in video or game applications. As they are more efficient than CPUs, modern GPUs are not restricted to accelerate graphics or video coding, but used as a general-purpose processing unit for algorithms with intensive data processing tasks. With this trend, some recent research concentrates on implementing EAs on general-purpose GPUs (GPGPUs) to reduce the communication overhead and arrive at a high speedup. Numerous GPGPU-based EAs have thus been designed, with coverage of GA [117,82,83], GP [103], ES [155], EP [40], DE [136], PSO [151,91,154], and ACO [8]. Among these works, [40,136,103,83] apply master-slave model, [82,91] use island model, [117,155,8,154] adopt cellular model, and [151] applies hierarchical model.It is to be noted that not all dEAs can benefit from being implemented on a GPU platform, but only the ones being synchronous, homogeneous, and lightweightly parallelized. The reasons are presented as follows. First, most GPGPU-based dEAs consider CPU and GPU as a host and a coprocessor, respectively, in which the data transferred between CPU and GPU are the population of individuals. The memory transfer process from CPU to GPU is commonly a synchronous operation, where the bus bandwidth and latency influence the performance significantly. Second, the “single program, multiple data (SPMD)” model of GPU device assumes that multiple processors execute the same program on different data (individuals in EAs). Thus, the distributed components of dEAs should contain the same operators. Third, as the thread of GPU is lightweight which can be considered as processing a data element, the task allocated to a thread by the EA should be in a very lightweight/fine-grained level. Although has some restrictions, a well-designed GPGPU-based EA can bring considerable speedup, e.g., “121×” when using 2014 threads and “286×” when using 15360 threads on the platform of Intel XeonTM E5420 CPU @2.5GHz, 2GB RAM, and nVidia GeForce GTX 280 GPU, as reported in [155].Considering the programming environments, the Compute Unified Device Architecure (CUDA) developed by Nvidia is currently the most commonly used programming model to implement GPGPU-based EAs [136,8,155,91,154,103]. CUDA provides a sophisticated application programming interface (API) for an easy access of the “single instruction, multiple data (SIMD)” architeture. It builds a comprehensive environment to translate the C and C++ codes to the GPU platform, as well as Fortran, C#, Python, etc.Unlike traditional single-objective problems (SOPs), a multiobjective optimization problem (MOP) involves multiple conflicting objectives with Pareto optimal solutions. MOPs are more difficult to solve than SOPs because the algorithms should be able to approximate a Pareto front instead of a single optimum. Because an EA is population-based, it is suitable to deal with a set of optimal solutions simultaneously in a single run. In order to characterize the entire Pareto front, a multiobjective EA (MOEA) employs a number of additional mechanisms, such as Pareto selection, solution maintenance, and diversity preservation. These mechanisms are often time consuming. The emergence of distributed MOEAs (dMOEAs) helps in speed and also provides a natural way to realize diversity preservation. In 2003, Veldhuizen et al. [134] paint a picture of dMOEAs with different paradigms, which leads dMOEAs to becoming one of the currently hottest research spots in the field of EC, dEC, and MOEAs.Many dMOEAs are extensions of the Non-dominated Sorting GA (NSGA-II), a well-known MOEA proposed in [26]. Distributed NSGA-II with master-slave [35], island [39,11], and cellular models [69] can be found in the literature. Proposed in 2007, MOEA/D uses a decomposition method to transform an MOP into a set of SOPs to solve, which has remarkable performance in optimizing difficult MOP instances [150]. To make further improvement, parallel and distributed versions of MOEA/D are developed in [92,36,32,33]. Other dMOEAs include the distributed Strength Pareto EA (SPEA) [143], the distributed multiobjective PSO (MOPSO) [90], the distributed vector evaluated PSO (VEPSO) [137], and the parallel single front GA (PSFGA) [24], all of which are based on island models. In comparison, the dMOEAs proposed in [93,34] employ cellular models. In addition, Tan et al. [128] developed a distributed cooperative coevolutionary algorithm for multiobjective optimization, where the decision vectors are divided into subcomponents and evolved by cooperative subpopulations. By executing intercommunication of subpopulations residing in the distributed system and incorporating archiving, dynamic sharing, and extending operators, the algorithm is able to efficiently approximate solutions uniformly along the Pareto front. Other dMOEAs based on divide-and-conquer and coevolution techniques can be found in [29,152].Although being a vibrant area, the research of dMOEAs still has some critical issues to be further addressed. Existing dMOEAs assume an ideal running environment that all processors are homogeneous and the communication costs between processors are identical, which is not always the case. The design of heterogeneous and asynchronous dMOEAs needs exploration. As described in Section 3.5, the resource pool-based model provides a natural way to realize asynchronization and heterogeneity. The model is very suitable for developing dMOEAs since we can deploy the searched nondominated solutions (or the so-called external archive) in the shared resource pool and let processors autonomously access and process them. This also brings more flexibility in designing the algorithms because it is now possible to assign heterogeneous tasks, such as individual reproduction, Pareto selection, solution maintenance, and diversity enhancement, to different sets of processors. Currently, the study of pool-based dMOEAs is still missing, which could be a potentially useful future direction. On the other hand, few efforts have been paid on regularizing the evaluation of dMOEAs such as proposing uniform test suites and performance metrics. Instead, the test suites and metrics of traditional MOEAs are applied, however, they are inadequate to investigate and analyze the performance of different dMOEAs, such as the scalability and speedup. To fully test the performance of dMOEAs, the test suite should cover a wide range of instances, by taking into account the variation of computational cost, symmetry, scalability, decomposability, etc. Meanwhile, the metrics of effectiveness, efficiency, or their hybrid, can be refined, as well as the significance test method in the distributed multiobjective environment.Because of its powerfulness, dEC can have and has seen a variety range of applications in science and engineering. Areas where dEAs have shown particular promise are problems with computationally expensive objective functions and extremely complex landscapes. The applications are so numerous and diverse that they exceed the scope of this paper. Hence we focus on several main fields and representative references here. Applications of dEAs in the literature can be classified into several categories, including the system design [99,137,74,118], resource scheduling [39,125,70,94], network planning [122,21,20], intelligent transportation [66,67,146], classifier optimization [129,95,6], feature extraction [77], and parameter training [37]. Compared to sequential EAs, the main benefits brought by dEAs are two-fold. On one hand, they improve the efficiency of EAs, and on the other, they enhance the global search ability and solution accuracy. In this sense, the dEC techniques improve the availability for solving real-world problems with large-scale, high-dimensional, and complex features.As surveyed in the above sections, significant efforts have been devoted to utilizing distributed computing resources to enhance the performance of EC. It is expected that dEC will continue to be a hot research topic because the complexity of real-world optimization problems is growing rapidly and there still exist many issues unexplored. In this section, we highlight several research directions of dEC.Scalability is an important factor in distributed systems. For dEC, the increasing scale of real-world optimization problems requires the algorithm to scale up well to satisfy the intensive data processing need, but an overuse of computing resources is not cost-effective. Therefore, it is important to develop highly scalable dEC techniques that can increase or decrease resources, depending on the problem at hand. To address this issue, adopting a virtualization technique and an adaptive population size may be effective. Besides, some brand new branches of EC, such as the imperialist competitive algorithm (ICA) [60] and the social learning algorithm (SLA) [54], can be adopted as baseline algorithms for possible performance enhancement.As the communication bandwidth in a dEA is limited, it becomes harder to make clear how dEAs converge. Beside experimental analyses in the literature, studying the convergence of dEAs from a theoretical perspective will be appealing and meaningful. By building up a theoretical base for dEC, it may be convenient to develop some more powerful dEAs in the future.Another issue introduced by the distributed paradigm is that dEAs have more parameters than sequential EAs. Compared with parameters of classical EAs, the newly introduced parameters have not yet been studied carefully, although they influence the performance of dEAs to a large extent. Therefore, it is crucial to control parameter settings systematically in dEAs or even automatically during the search process.Currently, MOEAs and dMOEAs have been effectively applied to deal with MOPs with a few, generally two or three, objectives. However, when facing the many-objective optimization problems involving four to tens of objectives, the performance of the algorithms deteriorates severely. The challenges arise from both the increased computational cost for evaluating the objective functions and the rapidly increased number of nondominated solutions in the population that breaks the Pareto selection pressure. Developing dEAs for many-objective optimization is promising since, by utilizing the distributed platform, it is now possible to manipulate a large population without incurring overlong computational time. The interplay of local evolution and global migration helps to seek a balance between convergence and diversity, which plays a decisive role in the performance of many-objective optimization. Moreover, the “many objectives, many processors (MOMP)” scheme, which optimizes a single objective on each processor and coordinates the optimization of different objectives during the intercommunication phase, forms an interesting and potentially useful future research direction.The coming era of big data poses new challenges to data management and processing since the data involved are always large-scale, sparse, unstructured, uncertain, and spatial–temporal dependent. Owing to that EC does not require explicit mathematical models in problem solving, and that it can respond to application queries in a relatively short time, the EC paradigm can be considered as a promising solution in current data-driven optimization domain. Further, dEC, especially the cloud-based dEC and the mobile dEC being described in the next subsection, greatly improves the computational volume of EC and the cost-efficiency of deploying massive EC system, which is rather suitable for handling real-world big data optimization applications, such as information recommendation, disease prediction, and logistics transportation control, etc.Smartphones possess useful computational capacity and the market is proliferating rapidly in recent years. The increasing quantity, mobile data connectivity and computational power have made smartphones a new and promising distributed system for dEC. Specifically, mobile crowdsourcing [19] is a probable form of deploying dEC on smartphones. Most existing mobile crowdsourcing applications emphasize on the sensing capability of smartphones, while in the context of dEC, the computation resource is of a central place. The challenge lies in that the deployment of dEAs on smartphones should not decrease the user experience, which is a basic requirement for the success of mobile crowdsourcing. Hence it is necessary to develop adaptive scheduling methods for executing mobile dEAs.

@&#CONCLUSIONS@&#
This article provides a comprehensive survey of the state-of-the-art distributed evolutionary algorithms and models. The models have been classified into two groups according to the task division mechanism. Population-distributed models include master-slave, island, cellular, hierarchical, and pool models, which parallelize an optimization task at population, individual, or operation levels. Dimension-distributed models include coevolution and multi-agent models that focus on the reduction of problem space. The characteristics of different models, such as the search behaviors, objectives, communication costs, scalability, and fault-tolerance, have been summarized and analyzed. It can be seen that these distributed models have different features and characteristics, which are suitable for developing different dEAs and solving different kinds of problems. We have also highlighted recent hotspots in dEC, including the cloud and MapReduce-based implementations, GPU and CUDA-based implementations, dMOEAs for multiobjective optimization, and real-world applications. Further, a number of future research directions have been discussed. Based on the survey, we believe that the study and development of distributed evolutionary computation will continue to be a vibrant and active field in the future.