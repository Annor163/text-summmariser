@&#MAIN-TITLE@&#
Observing real Multipath TCP traffic

@&#HIGHLIGHTS@&#
We analyse a Multipath TCP dataset collected from multipath-tcp.org consecutively in 5 months.Multipath TCP correctly passes through a wide range of Internet paths.Current implementations of Multipath TCP try to utilise additional paths as quickly as possible.Multipath TCP could be further improved in terms of traffic overhead and path management.

@&#KEYPHRASES@&#
Networking,Transport layer,Measurement,Performance,

@&#ABSTRACT@&#
Multipath TCP is a recent TCP extension that enables multihomed hosts like smartphones to send and receive data over multiple interfaces. Despite the growing interest in this new extension, little is known about its behavior in real networks. We analyze a five-month trace collected on multipath-tcp.org using Multipath TCP. This first detailed study of real Multipath TCP traffic reveals several interesting points about its behavior in the wild. With packets from thousands of hosts using IPv4 and/or IPv6, we confirm that Multipath TCP correctly passes through a wide range of Internet paths. We observe long Multipath TCP connections that benefit from handovers and also connections composed of subflows having very different round-trip-times. We also analyze some inefficiencies in the current Multipath TCP implementations and quantify the importance of reinjections, i.e. the transmission of the same data over two or more subflows.

@&#INTRODUCTION@&#
The Transmission Control Protocol (TCP) is the dominant transport protocol in today’s fixed and wireless networks. The design of TCP dates from the 1970s. Over the years, the protocol and its implementations have significantly evolved. Although today’s TCP implementations still use the packet format proposed forty years ago, they include various optimizations [1] that are key in today’s networks. These optimizations and extensions include TCP congestion control schemes [2], TCP timestamp option, large windows extensions, improved round-trip-time estimations and several forms of selective acknowledgements for better retransmission.Multipath TCP [3,4] is the latest significant TCP extension approved by the Internet Engineering Task Force (IETF). It enables hosts to exchange the packets that belong to one connection over different interfaces or paths. This is a major change to TCP that assumes that a connection is identified by the source and destination addresses and the source and destination ports. Multipath TCP breaks this assumption by combining several TCP connections, called subflows, into a single Multipath TCP connection. Multipath TCP includes a special congestion control scheme that couples the congestion window among the different subflows [5].Several use cases for Multipath TCP have already been identified in the scientific literature [6]. The initial motivation for Multipath TCP were the multihomed hosts like today’s smartphones that are equipped with several network interfaces. Such hosts did not exist when TCP was designed. Users of smartphones expect that multiple available interfaces could be used simultaneously to increase the bandwidth [7] or successively to support mobility [8,9]. With regular TCP, this form of resource pooling is not possible since each interface uses a different IP address. A second use case are the datacenters [10] where Multipath TCP improves the network utilization with Equal Cost Multipath (ECMP). A third use case are single-homed but dual-stack hosts that support IPv4 and IPv6. On such hosts, Multipath TCP can use both network layer paths simultaneously for increased performance [11].In September 2013, Apple took the networking community by surprise by implementing and enabling Multipath TCP on all its iOS devices (including smartphones and tablets). Within a few months, hundreds of millions of devices started to use this TCP extension. On iOS, Multipath TCP does not replace regular TCP. As of this writing, the Multipath TCP API on iOS is not public and only Apple’s Siri voice recognition application uses Multipath TCP to exchange small amounts of data with a few servers managed by Apple. Given the difficulty of implementing a complex protocol like Multipath TCP [12], it can be expected that other applications will leverage Multipath TCP in the coming years. It is now included in the latest MacOS releases and there are plans to upstream the Linux implementation in the official Linux kernel [13].In this paper, we provide the first detailed analysis of the operation of Multipath TCP in real networks by analyzing long packet traces collected on a Multipath TCP server often used by researchers and implementers. More precisely, this paper provides the following contributions that improve our understanding of the dynamics of this new protocol.We first collected a five-month-long packet trace that contains 190,451 Multipath TCP connections originated from more than 7,000 different hosts across the Internet. This is the largest publicly available dataset about this new protocol.11This dataset is available at www.multipath-tcp.org/data/COMCOM16To analyze this long trace, we improve the open-source mptcptrace software [14] and develop custom scripts. Our analysis reveals various important information about the current usage of Multipath TCP. Multipath TCP works well over many Internet paths and we observe very few fallbacks caused by middleboxes. Multipath TCP connections can last thousands of seconds or more and we observe handovers on such connections. From the performance viewpoint, our analysis reveals that Multipath TCP connections are often composed of subflows having very different round-trip-times. We also analyze some inefficiencies of the current Multipath TCP implementations and study in more details the reinjections, i.e. the transmissions of the same data over several paths, and how they affect the performance.This paper is organized as follows. We first provide a brief overview of Multipath TCP and discuss related work in Section 2. We describe the dataset that we have collected in Section 3 and our extensions to mptcptrace that enabled us to process them efficiently in Section 4. In Section 5, we analyze how the Multipath TCP connections use their subflows. We discuss in Section 6 main lessons that we learned from this first detailed analysis of Multipath TCP packet trace.This section provides a brief introduction to the Multipath TCP protocol [3] and the key characteristics of its implementation in the Linux kernel. A more complete introduction to Multipath TCP may be found in [15].A Multipath TCP connection is a logical association between a client and a server. To understand the operation of Multipath TCP, let us consider the simple but common case of a smartphone using WiFi and cellular and a single-homed server. To request the utilization of Multipath TCP, the smartphone adds the MP_CAPABLE option in the TCP’s SYN segment sent over its cellular interface. This option contains several flags and a random key [3]. If the server supports Multipath TCP, it also replies with the MP_CAPABLE option in the SYN+ACK segment. This option also contains a random key chosen by the server. To cope with middleboxes that could remove the MP_CAPABLE option from the SYN+ACK segment, an MP_CAPABLE option containing the two keys is also placed in the third acknowledgement returned by the client. According to the Multipath TCP terminology, this initial TCP connection is called a subflow [3]. Thanks to this subflow, the smartphone and the server can exchange data over the cellular interface. The smartphone or the server must then send some data over this subflow to verify that the Multipath TCP options placed in data segments are not modified by middleboxes. Once this first data has been correctly acknowledged, the subflow is considered to be valid and other subflows can be created to use different paths.If the smartphone wants to send data also over its WiFi interface, it sends a new SYN segment with the MP_JOIN option over this interface. This option contains a token derived from the key announced by the server in the MP_CAPABLE option. This token identifies the Multipath TCP connection and allows the server to attach the new subflow to the existing Multipath TCP connection. The server replies with an MP_JOIN and the subflow is established. The smartphone can also inform the server of the other addresses that it uses through the ADD_ADDR option.At this stage, the Multipath TCP connection is composed of two subflows. This number of subflows is not fixed. A subflow can stop at any time and other subflows can be established during the lifetime of the Multipath TCP connection. Data can be sent over any of the available subflows. To enable the receiver to reorder the received data, Multipath TCP relies on two levels of sequence numbers: the regular TCP sequence number and the Data Sequence Number (DSN) which corresponds to the application-level bytestream. When data is sent over a subflow, its DSN is mapped to the regular sequence numbers within the Data Sequence Signal (DSS) option. The DSS option also contains DSN acknowledgements. Thanks to this option, the same data can be transmitted over more than one subflow. This is called a reinjection [4]. A reinjection can occur if data transmitted over one subflow has not been acknowledged quickly enough. For example, a smartphone could send some data over its WiFi interface while moving out of reach of the access point. This data will have to be retransmitted later over the cellular interface to reach the server.Several independent implementations of Multipath TCP have been written [12]. Apple’s implementation is the most widely deployed, but it is only used by one application. The Multipath TCP implementation in the Linux kernel [16] is the most complete one. It includes several algorithms that are not part of the protocol specification [3] but influence its performance and the transmission of packets. There are three main modular components that affect the performance of the Linux implementation: (i) the path manager, (ii) the congestion control scheme and (iii) the scheduler.The path manager defines the strategy that is used by the Multipath TCP stack to create subflows. Two path managers are included in the Linux implementation: full-mesh and ndiffports. They decide when and how subflows are created. As of this writing, subflows are only created by the clients. The server does not attempt to create subflows because the clients are often behind NATs or firewalls that would block these subflows [12]. The full-mesh path manager creates a subflow from each address owned by the client to each address advertised by the server. These subflows are created at the beginning of the connection, as soon as the initial subflow has been validated. If the host learns a new address, e.g., a smartphone attaches to a new WiFi access point, the full-mesh path manager automatically creates a new subflow over this interface. The ndiffports path manager was designed for single-homed hosts in datacenters [10]. With this path manager, a Multipath TCP connection is composed ofnsubflows that use different source ports. The full-mesh path manager is the default path manager in the Linux implementation, but some researchers use the ndiffports path manager.The second important algorithm is the congestion controller. Several congestion control algorithms have been proposed for Multipath TCP. These congestion control schemes couple the congestion windows of the different subflows to preserve fairness with the regular TCP congestion control scheme. Four of them are included in the Linux kernel implementation: LIA [5], OLIA [17], BALIA [18] and wVegas [19]. LIA is the default congestion control scheme, but users can opt for other congestion control schemes. Some users have reported that they used non-coupled congestion control schemes like CUBIC which is the default congestion control scheme in Linux.The third important algorithm of the Linux kernel is the packet scheduler[20]. This algorithm is used every time a data segment needs to be sent. It selects, among the active subflows that have an open congestion window, the subflow that will be used to send the data. The default scheduler tries to send data over the subflow having the lowest round-trip-time.

@&#CONCLUSIONS@&#
