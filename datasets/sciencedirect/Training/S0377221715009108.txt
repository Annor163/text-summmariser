@&#MAIN-TITLE@&#
Improved algorithms for joint optimization of facility locations and network connections

@&#HIGHLIGHTS@&#
We study how to jointly optimize facility locations and their connections to clients.We develop an improved approximation algorithm based on a minimum spanning tree.When each vertex has a client, the problem is equivalent to matroid minimization.When all vertices are on a tree, the problem can be solved by dynamic programming.

@&#KEYPHRASES@&#
Approximation algorithm,Polynomial time algorithm,Facility location,Network connection,Steiner forest,

@&#ABSTRACT@&#
This paper studies a k-median Steiner forest problem that jointly optimizes the opening of at most k facility locations and their connections to the client locations, so that each client is connected by a path to an open facility, with the total connection cost minimized. The problem has wide applications in the telecommunication and transportation industries, but is strongly NP-hard. In the literature, only a 2-approximation algorithm is known, it being based on a Lagrangian relaxation of the problem and using a sophisticated primal-dual schema. In this study, we have developed an improved approximation algorithm using a simple transformation from an optimal solution of a minimum spanning tree problem. Compared with the existing 2-approximation algorithm, our new algorithm not only achieves a better approximation ratio that is easier to be proved, but also guarantees to produce solutions of equal or better quality—up to 50 percent improvement in some cases. In addition, for two non-trivial special cases, where either every location contains a client, or all the locations are in a tree-shaped network, we have developed, for the first time in the literature, new algorithms that can solve the problem to optimality in polynomial time.

@&#INTRODUCTION@&#
Consider a complete undirected graphG=(V,E)whereV={1,2,…,n}denotes the vertex set, E denotes the edge set, and each edge e ∈ E has a non-negative weight denoted by ℓ(e). Let W ⊆ V denote a set of potential facilities, and J ⊆ V a set of clients, where both W and J are not empty. Let k with 1 ≤ k ≤ |W| indicate the maximum number of facilities that are allowed to be opened. Each client in J needs to be served by connecting it to an open facility along a path. The resulting connections can be represented by a k-median Steiner forest, which is defined as a collection of at most k trees that covers all the clients, with each tree containing a distinct facility location as the root, where vertices in V∖J are Steiner vertices that may or may not be included in the forest. To minimize the total connection cost, we study in this paper a k-median Steiner forest problem that aims to find an optimal k-median Steiner forest that minimizes the total edge weight. See Fig. 1.The k-median Steiner forest problem aims to jointly optimize facility locations and network connections. This problem has wide applications, particularly in the telecommunication and transportation industries, where facilities, such as service centers or factories, need to be located and connected to clients by cable or road constructions. Its solutions can also be utilized to construct plans of facility locations combined with vehicle routing or cargo shipping (Carnes & Shmoys, 2011; Prodhon & Prins, 2014; Ravi & Sinha, 2006).The k-median Steiner forest problem is strongly NP-hard, since it contains the classical Steiner tree problem as a special case with|W|=k=1. As with the classical Steiner tree problem (Vazirani, 2001), it can be assumed without loss of generality that the weight of each edge equals the total edge weight of the shortest path that connects the endpoints of the edge, so that the edge weights satisfy triangle inequality and form a metric. This is because each edge of a k-median Steiner forest can always be replaced by the shortest path that connects its endpoints, without increasing the total edge weight of the Steiner forest.Since the k-median Steiner forest problem is strongly NP-hard, it is of great interest to develop approximation algorithms for it with provable guarantees on running time and solution quality, as well as to identify special cases that are commonly seen in practice and can be solved to optimality by polynomial time algorithms. In this paper, we develop an improved approximation algorithm for the k-median Steiner forest problem, as well as new polynomial time algorithms that can solve two non-trivial special cases of the problem. For a minimization problem, we recall that an algorithm is said to be a ρ-approximation algorithm with an approximation ratio ρ if it runs in polynomial time and can always produce a feasible solution of an objective value no more than ρ times that of an optimal solution, and that the approximation ratio ρ is tight if there exists an instance of the problem to which the solution produced by the algorithm is of an objective value exactly equal to ρ times that of an optimal solution.For the k-median Steiner forest problem, only a 2-approximation algorithm is known in the literature (Carnes & Shmoys, 2011; Ravi & Sinha, 2006). It is based on a Lagrangian relaxation of the problem, and uses a sophisticated primal-dual schema that holds a so-called Lagrangian preserving performance guarantee to construct Steiner forests. (See a detailed review in Section 1 of the online supplementary materials.) As a result, the proof of its approximation ratio is complicated.The k-median Steiner forest problem is a joint optimization problem that takes into account decisions on both facility locations and network design (Contreras & Fernández, 2012). Among many facility location problems that have been extensively studied in the literature (Aardal, van den Berg, Gijswijt, & Li, 2015; Prodhon & Prins, 2014), the k-median problem is the most relevant one, which aims to open at most k facilities and directly connect each client to an open facility by an edge with the total edge weight minimized. For the k-median problem, Charikar, Guha, Tardos, and Shmoys (1999) achieved the first constant approximation ratio of 6.67, and recently, based on a breakthrough made by Li and Svensson (2013), Byrka, Pensyl, Rybicki, Srinivasan, and Trinh (2015) achieved the current best approximation ratio of2.61+ϵfor any ϵ > 0. The existing 2-approximation algorithm for the k-median Steiner forest problem (Carnes & Shmoys, 2011) followed the approach of a 6-approximation algorithm developed by Jain and Vazirani (2001) for the k-median problem. Jain and Vazirani (2001) reduced the k-median problem to an uncapacitated facility location problem by relaxing the constraint of opening at most k facilities, and penalizing the opening of each facility by a Lagrangian multiplier. They then applied a primal-dual schema to obtain a 3-approximation of the uncapacitated facility location problem, and transformed it to a 6-approximation of the k-median problem. This approach has been improved by Jain, Mahdian, and Saberi (2002) and Arya et al. (2004) to achieve approximation ratios of 4 and3+ϵfor the k-median problem.Among various network design problems that have been extensively studied in the literature (Contreras & Fernández, 2012; Li & Balakrishnan, 2015), the classical Steiner tree problem is the most relevant one, which, as mentioned earlier, is a special case of the k-median Steiner forest problem with|W|=k=1,aiming to minimize the total cost of connecting all the clients to a given facility. It is well-known that a minimum spanning tree of the subgraph induced by the clients can lead to a 2-approximation of the Steiner tree problem (Vazirani, 2001). Moreover, approximation ratios smaller than 2 have been achieved by Zelikovsky (1993),Karpinski and Zelikovsky (1997),Prömel and Steger (2000),Robins and Zelikovsky (2000), and with the current best approximation ratio beingln(4)+ϵ<1.39,recently achieved by Byrka, Grandoni, Rothvoss, and Sanità (2013). Moreover, Ravi (1994) proposed a primal-dual schema that achieves an approximation ratio of 2 for a Steiner forest problem, which aims to connect clients by a given number of trees with the total edge weight minimized. This problem is equivalent to a special case of the k-median Steiner forest problem, where each vertex contains a facility, i.e.,W=V.Solutions to the k-median Steiner forest problem are often used to construct approximations of other problems that jointly optimize facility locations and network design (Drexl & Schneider, 2015). Ravi and Sinha (2006) studied a location-shipping problem that aims to open at most k facilities and install cables of sufficient capacity for shipping cargo from clients to facilities. By combining the 2-approximation of the k-median Steiner forest problem and a ρ-approximation of the k-median problem, they constructed a(ρ+2,2)bicriteria approximation with a total cost at mostρ+2times that of the optimal solution, and with a total of at most 2k facilities opened. Carnes and Shmoys (2011) studied a k-location-routing problem that aims to assign depots (facilities) to k vehicles and to route the vehicles to serve clients, with the total routing cost minimized. By duplicating each edge of the 2-approximation of the k-median Steiner forest problem, they obtained a collection of k tours with each tour starting and ending at an open facility, and proved that such a tour collection is a 2-approximation of the k-location-routing problem. Moreover, Xu, Xu, and Xu (2013) studied a special case of the k-location-routing problem, where vertices are located in a tree-shaped network and edge weights represent lengths of shortest paths on the tree. Such a tree shaped network appears in several manufacturing and logistics applications (Asano, Katoh, & Kawashima, 2001; Chen, Campbell, & Thomas, 2008; Chhajed & Lowe, 1992; Karuno, Nagamochi, & Ibaraki, 1996; Wang, Lim, & Xu, 2006), including those in rural or water transportation systems (Tsitsiklis, 1992; Xu, Lai, Lim, & Wang, 2014). For this special case, solutions to the k-median Steiner forest problem and solutions to the k-location-routing problem are one-to-one correspondence, and therefore these two problems are equivalent. Xu et al. (2013) developed an algorithm that can solve this special case of the problem to optimality in O(n26k) time. However, when k is part of the input, whether or not this special case has a polynomial time algorithm still remains open.For the k-median Steiner forest problem, we have developed a new 2-approximation algorithm. It is simpler than the existing 2-approximation algorithm of Carnes and Shmoys (2011), consisting of only an O(n2)-time transformation from a minimum spanning tree of the clients and a new vertex that replaces all the facilities. This extends the well-known result that a minimum spanning tree of the clients can lead to a 2-approximation of the Steiner tree problem. Compared with the existing 2-approximation algorithm, our new algorithm has an improved approximation ratio of2−1/|J|,which is not only tight but easier to be proved, and it can always produce solutions of equal or better quality, the quality improvement being up to 50 percent in some cases.Moreover, we have developed new polynomial time algorithms that can solve two non-trivial special cases of the k-median Steiner forest problem to optimality. For a special case where each vertex contains a client, i.e,J=V,we show that it is equivalent to a problem of finding a minimum weighted basis for a matroid, and that its optimal solution can be obtained in polynomial time by a transformation from a minimum spanning tree of the clients. This result is interesting because the same special case for the k-median problem, whereJ=V,is still strongly NP-hard. For the other special case, where vertices are located in a tree-shaped network, we develop a dynamic programming algorithm that, for the first time in the literature, can solve the problem to optimality in polynomial time, a significant improvement over the existing best algorithm of O(n26k) running time (Xu et al., 2013).The remainder of this paper is organized as follows: In Section 2 we present the improved approximation algorithm for the k-median Steiner forest problem, and compare its performance with the existing 2-approximation algorithm. In Section 3 we present the new polynomial time algorithms for the two special cases of the problem. We then conclude the paper in Section 4 with discussions on applications of the results obtained as well as directions for future research.We present our new approximation algorithm for the k-median Steiner forest problem in Section 2.1, prove its tight approximation ratio of2−1/|J|in Section 2.2, and then show its improvement over the existing 2-approximation algorithm in Section 2.3.As mentioned earlier, we can assume without loss of generality that edge weights satisfy triangle inequality. Throughout this section, we also assume that W and J are disjoint, since each vertex that belongs to both W and J can be duplicated to two vertices, one being a facility and the other being a client.Our new approximation algorithm consists of the following three steps:Step 1.Construct a complete undirected graph H by shrinking vertices of W to a new vertex r and eliminating vertices not in J. As a result, H is a complete graph on vertices of J ∪ {r}. For each edge (u, v) with u ∈ J and v ∈ J, its weight still equals ℓ(u, v), and for each edge (r, v) with v ∈ J, we letℓ(r,v)=min{ℓ(u,v):u∈W}.Define a k-root-degree spanning tree of H, or k-RDST of H in short, as a spanning tree of H, with r being its root, such that the degree of r does not exceed k. Compute a minimum k-RDST TH, which is a k-RDST of the minimum total edge weight.Construct from THa k-median forest F of G withℓ(F)=ℓ(TH),as follows. For each edge (r, v) of THwith v ∈ J, we replace it with an edge (u, v) where u ∈ W andℓ(u,v)=ℓ(r,v). Since the degree of r in THdoes not exceed k, we know that the resulting tree collection F must contain at most k trees, with each tree containing a distinct facility in W. Thus, F is a k-median Steiner forest of G. Since each edge (r, v) of THwith v ∈ J corresponds to an edge (u, v) with u ∈ W of equal weight, we haveℓ(F)=ℓ(TH). Since k ≤ n, this step takes O(n) time.It can be seen that the above algorithm constructs a k-median Steiner forest F of G by an O(n)-time transformation from a minimum k-RDST THof H withℓ(F)=ℓ(TH),where H is a complete graph with its vertices including all the clients, as well as an additional vertex r that replaces all the facilities. We next show that THcan be computed by an O(n2)-time transformation from a minimum spanning tree of H.Lemma 1For any minimum spanning tree T*of H, it can be transformed to a minimum k-RDST TH of H in O(n2)-time.Let T(k) indicate a spanning tree of H that minimizes the total edge weight, with the degree of r equal to k. If the degree of r in T* does not exceed k, then we directly obtain that T* is a minimum k-RDST of H. Otherwise, the degree of r in T exceeds k. For this case, we know from Malik, Rathinam, and Darbha (2007) that T(k) must be a minimum k-RDST of H. Since T(k) can be obtained by an O(n2)-time transformation from T* (Gabow & Tarjan, 1984), Lemma 1 is proved.□By Lemma 1, the new approximation algorithm is also an O(n2)-time transformation from a minimum spanning tree of H. It is noted that the fastest minimum spanning tree algorithm runs inO(α(|E|,|E|)|E|)time, whereα(|E|,|E|)is the functional inverse of Ackermann’s function, which grows very slowly and can be considered as a constant (Chazelle, 2000). Since |E| is in O(n2), we obtain that our new algorithm runs in O(α(n2, n)n2) time.Example 1Apply the new algorithm on the instance shown in Fig.1, wherek=2. In H constructed by Step 1, we haveℓ(r,v)=1for v ∈ {3, 4},ℓ(r,v)=2for v ∈ {1, 2},ℓ(1,2)=2,andℓ(3,4)=3. By the definition in Step 2, it is easy to verify that the tree ({r, 1, 2, 3, 4}, {(r, 1), (1, 2), (r, 3), (3, 4)}) is a minimum k-RDST THof H withℓ(TH)=8. Thus, replacing edges (r, 1) and (r, 3) with (6, 1) and (7, 3), we obtain a k-median Steiner forest F of G in Step 3 ofℓ(F)=ℓ(TH)=8.Consider the k-median Steiner forest F obtained by the new approximation algorithm. Let OPT indicate an optimal k-median Steiner forest. We prove as follows that the new approximation algorithm guarantees an approximation ratio of2−1/|J|.Theorem 1ℓ(F)≤(2−1/|J|)ℓ(OPT).For each tree T of OPT, let wTindicate its facility, nTindicate the number of clients in T, and PTindicate the path of the largest total edge weight that connects wTand a client in T, for which we use vT∈ J to indicate the endpoint of PTthat is a client. We duplicate each edge of T except those on PT, so as to obtain a subgraph that contains an Eulerian path that starts from wT, visits every edge exactly once, and then returns to vT. Thus, by short-cutting vertices not in J ∪ W as well as facilities other than wTat the start, we obtain a path T′ that starts from wTand visits all the clients of T exactly once. See Fig. 2.Hence, by repeating the above procedure for every tree T in OPT, and replacing all the facilities with r, we can obtain a collection of at most k paths that all start from r, cover all the clients, and contain no other vertices. Thus, it forms a k-RDST of H, denoted byTH′,and we haveℓ(TH)≤ℓ(TH′). Hence, byℓ(F)=ℓ(TH),we haveℓ(F)≤ℓ(TH′).Moreover, since OPT is an optimal k-median Steiner forest, without loss of generality it can be assumed that each leaf of the trees in OPT is a client. Thus, for each tree T ∈ OPT, since every edge of T belongs to a certain path that connects wTand a client in T, we obtain that ℓ(PT) ≥ ℓ(T)/nT. By triangle inequality, we knowℓ(TH′)≤2[ℓ(OPT)−∑T∈OPTℓ(PT)]+∑T∈OPTℓ(PT)=2ℓ(OPT)−∑T∈OPTℓ(PT),which, together with ℓ(PT) ≥ ℓ(T)/nTand nT≤ |J| for each T ∈ OPT, implies thatℓ(TH′)≤(2−1/|J|)ℓ(OPT). Hence, we obtain thatℓ(F)≤ℓ(TH′)≤(2−1/|J|)ℓ(OPT).□Moreover, the approximation ratio(2−1/|J|)is tight by the following example.Example 2Letk=1,n=h+2,J={1,2,..,h},andW={h+1,h+2}. Defineℓ(h+1,u)=1for u ∈ J, andℓ(h+2,1)=1. For other edges (u, v), defineℓ(u,v)=2. It can be seen that the edge weights satisfy triangle inequality, and that it is optimal to connect facilityh+1to each client u ∈ J by an edge(h+1,u),so thatℓ(OPT)=h=|J|. Moreover, since edges(h+2,1)and (1, v) for 2 ≤ v ≤ h form a minimum k-RDST of H, it can be seen that the approximation solution F produced by the proposed algorithm consists of edges(h+2,1)and (1, v) for 2 ≤ v ≤ h, so thatℓ(F)=1+2(h−1)=2|J|−1=(2−1/|J|)|J|=(2−1/|J|)ℓ(OPT). Thus, the approximation ratio of(2−1/|J|)is tight for the proposed approximation algorithm.We next compare the solution returned by the existing 2-approximation algorithm of Carnes and Shmoys (2011) with the solution returned by our newly proposed approximation algorithm. As shown in Section 1 of the online supplementary materials, the existing 2-approximation algorithm of Carnes and Shmoys (2011) is equivalent to the following transformation from a minimum k-RDST of H, where H, as defined earlier in Section 2.1, is a complete graph on J ∪ {r}.Step 1.Define revised edge weights π0(·) for edges of H, whereπ0(r,v)=min{ℓ(u,v):u∈W}for v ∈ J, andπ0(u,v)=ℓ(u,v)/2for u ∈ J and v ∈ J;Compute a minimum k-RDST S* of H under π0(·);Transform S* to a Steiner forestF^of G by replacing each edge (r, v) inF^with (u, v), where u ∈ W andℓ(u,v)=min{(u′,v):u′∈W},so that we haveℓ(F^)=ℓ(S*).Consider the solutionF^returned by the above equivalence of the existing 2-approximation algorithm of Carnes and Shmoys (2011), and the solution F returned by our newly proposed approximation algorithm. The following theorem shows that our algorithm always produces solutions of equal or better quality than the existing algorithm.Theorem 2ℓ(F)≤ℓ(F^).It is known thatF^is constructed from a minimum k-RDST S* of H under π0(·) withℓ(S*)=ℓ(F^),and that F is constructed from a minimum k-RDST THof H under ℓ(·) withℓ(TH)=ℓ(F). Thus, since S* is also a k-RDST of H under ℓ(·), we obtain thatℓ(F)=ℓ(TH)≤ℓ(S*)=ℓ(F^),which completes the proof of Theorem 2.□Moreover, the following example shows that ℓ(F) can be strictly better thanℓ(F^),and that the improvement can be up to 50 percent in some cases.Example 3ConsiderJ={1,2,…,k}andW={k+1,k+2,…,2k},whereℓ(k+1,1)=1,ℓ(k+v,v)=1+ϵfor eachv∈{2,…,k}and for any ϵ > 0, andℓ(u,v)=2for other edges (u, v). Since edges in {(r, v): v ∈ J} form a minimum k-RDST of H under ℓ(·), it can be seen that our algorithm produces a solution F that consists of edges(k+v,v)for v ∈ J withℓ(F)=k+(k−1)ϵ. Since edges in {(r, 1)}∪{(1, v): 2 ≤ v ≤ k} form a minimum k-RDST of H under π0(·), it can be seen that the algorithm of Carnes and Shmoys (2011) produces a solutionF^that consists of edges(k+1,1)and (1, v) for 2 ≤ v ≤ k withℓ(F^)=2(k−1)+1=2k−1. It can be seen that[ℓ(F^)−ℓ(F)]/ℓ(F^)=1/2−[1+2(k−1)ϵ]/(4k−2),which can be arbitrarily close to 50  percent when k grows to infinity and ϵ goes to zero.We have also conducted computational experiments on randomly generated instances to evaluate the average improvement made by F overF^,which is measured by the gap ratio[ℓ(F^)−ℓ(F)]/ℓ(F^)·100percent. Following the method proposed by Gourdin, Labbé, and Laporte (2000), we generated 30 classes of 600 problem instances randomly, with each class containing 20 instances for a specific combination of |V| and |J|, and we setW=V∖J. The computational results are shown in Table 1, where columns 5–11 present the average gap ratios over the 20 instances of each class for different values of k with k/|W| in{0.2,0.3,…,0.8},respectively. From the results, it can be seen that the solution F produced by our new algorithm is always better than the solutionF^produced by the algorithm of Carnes and Shmoys (2011). Moreover, the average improvement increases from 4.0  percent to 11.5 percent when k grows from 0.2|W| to 0.8|W|. This is mainly because the improvement[ℓ(F^)−ℓ(F)]equals[ℓ(S*)−ℓ(TH)],and both S* and THare minimum k-RDSTs of H but under different edge weights, i.e., π0(·) and ℓ(·), respectively. Since π0(r, v) equals ℓ(r, v) for v ∈ J, and π0(u, v) is only half of ℓ(u, v) for u ∈ J and v ∈ J, those root edges (r, v) in THmay not be preferred by S*. A further investigation on the numerical results reveals that S* contains significantly fewer root edges than TH, and this difference becomes greater as k increases. This results in the increase of[ℓ(S*)−ℓ(TH)],which equals the increase of the improvement[ℓ(F^)−ℓ(F)].To examine the solution quality, we have further evaluated the optimality gap of our approximation solution against the lower bound on the optimal solution. The best lower bound is obtained by a commercial optimization solver CPLEX 12.6. We restricted the evaluation to only a set of small sized random instances with |V| ≤ 25, because for large sized instances, the best lower bound produced by CPLEX has a large gap (more than 25 percent on average) from the best solution that CPLEX can produce within two hours. According to the numerical results, our approximation solution is close to the optimal solution, with an average optimality gap decreasing from 5.7 percent to 0.1 percent as k increases. See Section 2 of the online supplementary materials for details of the numerical results on the solution quality.In this section, we present new polynomial time algorithms that can solve two non-trivial special cases of the k-median Steiner forest problem to optimality.First, we show that solving the k-median Steiner forest problem withJ=Vis equivalent to finding a minimum weighted basis for a matroid. Consider a collectionSof edge subsets of E, such that for eachS∈Sthe subgraph (V, S) satisfies that it has no cycles, and that at least k of its connected components each contain at least one facility in W.The system(E,S)is a matroid, due to the following arguments. It is easy to see that∅∈S,and that ifX⊆Y∈S,thenX∈S. Thus, to prove that(E,S)is a matroid, we only need to show that, for each subset Y ⊆ E, every maximal independent subset X of Y, which is also called a basis of Y, has the same cardinality. For each S ⊆ E, let αSand βSdenote the numbers of connected components of the subgraph (V, S) that contain no facility, and that contain at least one facility, respectively. Since X contains no cycle, we have|X|=|V|−αX−βX. Since X is a maximal independent subset of Y, we have thatαX=αYandβX=max{k,βY}. Hence, |X| is always equal to(|V|−αY−max{k,βY}),and so(E,S)is a matroid.Since G is a complete graph, implying thatαE=0andβE=1,every basis of(E,S)consists of|V|−kedges that correspond to a k-median Steiner forest of G. Moreover, it is easy to see that for every k-median Steiner forest of G, its edge set is a basis of(E,S). Hence, we obtain the following theorem, which implies that the k-median Steiner forest problem withJ=Vcan be solved to optimality by finding a minimum weighted basis of the matroid(E,S),which can be obtained in O(n2log n) time by a greedy algorithm known in the literature (Korte & Vygen, 2008).Theorem 3Solving the k-median Steiner forest problem withJ=Vis equivalent to finding a minimum weighted basis of(E,S).Next, we will show how the running time of the matroid intersection algorithm can be improved by using a minimum spanning tree transformation. Consider a complete graph H extended from G, whereV(H)=V∪{r},E(H)=E∪{(r,u):u∈W},andℓ(r,u)=0for u ∈ W. We can show as follows that, whenJ=V,an optimal k-median Steiner forest F of G can be transformed from a minimum k-RDST T of H. First, by eliminating vertex r and all edges (r, u) with u ∈ W from T, we can obtain a tree collection F that covers all vertices in V. Since the degree of r in T does not exceed k, we know that F has at most k trees, with each tree containing a vertex in W as the root. Hence, F is a k-median Steiner forest of G, and it can be seen thatℓ(F)=ℓ(T). As defined in Section 2.2, we still use OPT to denote an optimal k-median Steiner forest of G. Thus, we haveℓ(OPT)≤ℓ(F)=ℓ(T). Moreover, from OPT we can obtain a k-RDST of H by joining the root of each tree in OPT to r. This implies that ℓ(T) ≤ ℓ(OPT). Hence, we haveℓ(F)=ℓ(T)=ℓ(OPT),and so F is an optimal k-median Steiner forest of G. Since T can be obtained by an O(n2)-time transformation from a minimum spanning tree T* of H (by Lemma 1), F can also be obtained by an O(n2)-time transformation from T*. Since T* can be obtained in O(α(n2, n)n2) time (Chazelle, 2000), F can also be obtained in O(α(n2, n)n2) time, faster than by directly applying the greedy algorithm of finding a minimum weighted basis for a matroid.Example 4Consider the instance in Fig. 1, but letJ=V={1,2,…,8}. It can be seen that H contains vertices1,2,…,8as well as a new vertex r, and that edges in {(r, 6), (r, 7), (6, 5), (5, 1), (5, 2), (7, 3), (7, 4), (4, 8)} form a minimum k-RDST of H. By removing (r, 6) and (r, 7) we obtain an optimal k-median Steiner forest of G of total edge weight equal to 7. This can also be obtained by applying the greedy algorithm of finding a minimum weighted basis for a matroid, which selects edges (1, 5), (2, 5), (5, 6), (3, 7), (4, 8), (4, 7) sequentially to form the optimal k-median Steiner forest.Suppose that vertices of G are all located on a tree T with a root r ∈ W, so that the weight ℓ(u, v) of each edge (u, v) of G equals the total edge weight of the simple path that connects the endpoints u and v in T. For this special case, the k-median Steiner forest problem on G is equivalent to that on T, and we can solve it to optimality by an O(kn)-time algorithm, which improves on the existing fastest algorithm of Xu et al. (2013) that runs in O(n26k) time.To simplify the presentation of our algorithm, we can assume without loss of generality that J and W are disjoint. We can also assume that T is a full binary tree, where each vertex other than the leaves has exactly two children, due to the following transformation, similar to those in Tamir (1996) and Xu et al. (2013):1.For any non-leaf vertex v with only one child, we can add a new vertex s as a child of v withℓ(v,s)=0. Repeat this until every non-leaf v in G has at least two children.For any non-leaf vertex v with more than two children, as denoted byu1,u2,…,uqwith q ≥ 3, we can add a new vertex s as a second child of v withℓ(v,s)=0,and add edges (s, uj) withℓ(s,uj)=ℓ(v,uj)to replace (v, uj) for 2 ≤ j ≤ q, so thatu2,…,uqbecome children of s. Repeat this until every non-leaf vertex v has exactly two children.Notice that J and W are not changed. It can be seen that each k-median Steiner forest for the original tree corresponds to a k-median Steiner forest for the transformed tree with equal total edge weights, and vice versa. See Fig. 3, where the instance on the right is on a full binary tree, and it is equivalently transformed from the instance on the left. Hence, we can assume without loss of generality that T is a full binary tree.To solve the k-median Steiner forest problem on T, we need to transform it to an equivalent k-subtree covering problem, and show later that this equivalent problem can be solved to optimality in polynomial time. The k-subtree covering problem is defined as to select a collection of at most k vertex-disjoint subtrees of T with the total edge weight minimized, such that it covers all the clients and contains at least one facility in each subtree. It can be seen that from any k-median Steiner forest F of T, we can always obtain another k-median Steiner forest of T as follows, such that trees of the new forest are all vertex-disjoint, without increasing the total edge weight: If trees in F are all vertex-disjoint, then F is the forest we need. Otherwise, we can repeatedly combine those trees in F that share some vertices into one tree, until trees in F are all vertex-disjoint. In light of the above observation we know that finding an optimal k-median Steiner forest of T is equivalent to solving the k-subtree covering problem to optimality.To show as follows that the k-subtree covering problem can be solved to optimality in polynomial time, in Section 3.2.1 we first decompose the problem into subproblems, and then in Section 3.2.2 we devise a dynamic programming algorithm to solve the subproblems recursively, this being followed by a proof of its polynomial time complexity in Section 3.2.3.For each vertex v, let Tvindicate the subtree of T rooted at v that contains v and all descendants of v. For each integerq∈{0,1,…,k},anda→=〈a2a1a0〉with ai∈ {0, 1} for 0 ≤ i ≤ 2, we use(v,q,a→)to denote a subproblem that aims to minimize the total edge weight of a collection of q selected vertex-disjoint subtrees of Tvsuch that: (i) Each client of Tvbelongs to one and only one selected subtree; (ii) each selected subtree that does not include v contains at least one facility; (iii) v belongs to a selected subtree if, and only if,a2=1; (iv) v belongs to a selected subtree that contains at least one client if, and only if,a1=1; and (v) v belongs to a selected subtree that contains at least one facility if, and only if,a0=1. It can be seen that ifa2=0,then unlessa1=a0=0,no feasible solutions to the subproblem(v,q,a→)exist. Hence, it is sufficient to consider only those subproblems witha→∈A,whereA={〈000〉,〈100〉,〈110〉,〈101〉,〈111〉}.For example, consider the instance in Fig. 3(b), for which a subtree formed by edges in {(8, 5), (8, 6)} and vertices in {5, 6, 8} is feasible to subproblem (8, 1, ⟨110⟩), and for which a collection of two vertex-disjoint subtrees formed by edges in {(6, 1), (6, 2)} and vertices in {1, 2, 5, 6} is not feasible to subproblem (8, 2, ⟨000⟩), because the subtree ({5}, ∅) does not include 8 or any facility.LetS(v,q,a→)indicate the optimal value of the subproblem(v,q,a→). Since r ∈ W and r ∉ J, the minimum value ofS(r,q,a→)over 1 ≤ q ≤ k anda→∈{〈000〉,〈111〉}equals the total edge weight of the minimum k-median Steiner tree of T.We next present a dynamic programming algorithm to computeS(v,q,a→)recursively for v ∈ V, from leaves to the root r. For each leaf v of T, we can computeS(v,q,a→)with 0 ≤ q ≤ k anda→∈Aby the following three cases:•Case 1: v ∈ J is a client. Since only the subtree ({v}, ∅) can cover v, and since v ∈ J, we have thatS(v,q,a→)=0ifq=1anda→=〈110〉,and thatS(v,q,a→)=∞otherwise.Case 2: v ∈ W is a facility. Since only the subtree ({v}, ∅) can cover v, and since v ∈ W, we have thatS(v,q,a→)=0ifq=1anda→=〈101〉,thatS(v,q,a→)=0ifq=0anda→=〈000〉,and thatS(v,q,a→)=∞otherwise.Case 3: v ∈ V∖J∖W. Since v is neither a client nor a facility, we have thatS(v,q,a→)=0ifq=0anda→=〈000〉,thatS(v,q,a→)=0ifq=1anda→=〈100〉,and thatS(v,q,a→)=∞otherwise.For example, consider the instance in Fig. 3(b) withk=2,for which Table 2 presents the values ofS(v,q,a→)for each leaf v ∈ {1, 2, 3, 4, 5} of the tree, where q ∈ {0, 1} anda→∈A,and we knowS(v,2,a→)=∞for each leaf v ∈ {1, 2, 3, 4, 5} anda→∈A.For each non-leaf v of T, let u1 and u2 denote its left and right children. Consider each subproblem(v,q,a→)withq=0,1,…,kanda→∈A. We solve it as follows for two situations, a simpler one wherea→=〈000〉,and a more complicated one wherea→∈A∖{〈000〉}.For the situation wherea→=〈000〉,we know that v does not belong to any selected subtree of Tv. Thus, an optimal solution to(v,q,a→)exists only when v is not a client, and if such an optimal solution exists, then we can partition it into two collections of selected subtrees that are optimal to subproblems(u1,q1,a→1)and(u2,q2,a→2),respectively, for certain q1 and q2 withq1+q2=q,and for certaina→1anda→2in A. Moreover, for j ∈ {1, 2}, since (v, uj) is not selected, the selected subtree that contains uj(if any) must contain at least one client and at least one facility. In other words, for any optimal solution to the subproblem(uj,qj,a→j),it can be part of an optimal solution to(v,q,a→)only ifa→j∈{〈000〉,〈111〉}. Thus, if v ∈ J, we obtain thatS(v,q,〈000〉)=∞,and otherwise,S(v,q,〈000〉)=minS(u1,q1,a→1)+S(u2,q2,a→2)s.t.q1+q2=q,0≤q1,q2≤q,a1→∈{〈000〉,〈111〉},a2→∈{〈000〉,〈111〉}.For example, consider the instance in Fig. 3(b), in which it can be seen thatS(6,1,〈000〉)=∞since 6 is a client, and that by Table 2,S(7,1,〈000〉)=∞sinceS(v,1,〈000〉)=S(v,1,〈111〉)=∞for both v ∈ {3, 4}.Next, consider the situation wherea→∈A∖{〈000〉}={〈100〉,〈110〉,〈101〉,〈111〉},implying thata2=1,and thus v belongs to a selected subtree of Tv. Depending on whether or not edge (v, u1) and/or edge (v, u2) are selected, there are four possibilities for v to be connected to a selected subtree of Tv. We can thus decompose the subproblem(v,q,a→)into the following four restricted subproblems denoted by(v,q,a→)iwith 1 ≤ i ≤ 4, so that representing the optimal value of each restricted subproblem bySi(v,q,a→),we have(1)S(v,q,a→)=min1≤i≤4Si(v,q,a→).For the restricted subproblem(v,q,a→)1,it is restricted to a constraint where neither edge (v, u1) nor (v, u2) is selected. Thus, the subtree ({v}, ∅) must be selected. Define(2)b→:=〈1b1b0〉,whereb1=1if v is a client, andb1=0otherwise, andb0=1if v is a facility, andb0=1otherwise. Ifa→≠b→,then no feasible solution exists to the restricted subproblem(v,q,a→)1,implying thatS1(v,q,a→)=∞. Otherwise,a→=b→,and then, for any optimal solution to(v,q,b→)1,it can be partitioned into three components, including a vertex v, a collection of subtrees that is optimal to subproblem(u1,q1,a→1),and a collection of subtrees that is optimal to subproblem(u2,q2,a→2),for certain q1 and q2 withq1+q2+1=q,and for certaina→1∈Aanda→2∈A. Moreover, for each j ∈ {1, 2}, since (v, uj) is not selected, by following the same argument used earlier fora→jin solving S(v, q, 〈000〉), we know that for any optimal solution to(uj,qj,a→j),it can be part of an optimal solution to(v,q,a→)1only ifa→j∈{〈000〉,〈111〉}. Hence, we obtain thatS1(v,q,b→)=minS(u1,q1,a→1)+S(u2,q2,a→2)s.t.q1+q2+1=q,0≤q1,q2≤q,a1→∈{〈000〉,〈111〉},a2→∈{〈000〉,〈111〉},whereS1(v,q,b→)=∞ifq=0. For example, consider the instance in Fig. 3(b) withv=6,u1=1andu2=2,for whichb→=〈110〉,and it can be seen thatS1(6,1,〈111〉)=∞sinceb→≠〈111〉,and thatS1(6,1,〈110〉)=0,since by Table 2S(1,0,〈000〉)=S(2,0,〈000〉)=0.For the restricted subproblem(v,q,a→)2,it is restricted to a constraint where (v, u1) is selected but (v, u2) is not. Thus, for any optimal solution to(v,q,a→)1,it can be partitioned into three components, including (v, u1), a collection of subtrees that is optimal to subproblem(u1,q1,a→1),and a collection of subtrees that is optimal to subproblem(u2,q2,a→2),for certain q1 and q2 withq1+q2=q,and for certaina→1∈Aanda→2∈Awitha→1∨b→=a→,where b is as defined in (2). Since (v, u2) is not selected, by following the same argument used earlier fora→2in solving S(v, q, 〈000〉), we know that for any optimal solution to(u2,q2,a→2),it can be part of an optimal solution to(v,q,a→)2only ifa→2∈{〈000〉,〈111〉}. Moreover, since (v, u1) is selected, we know that for any optimal solution to(u1,q1,a→1),it can be part of an optimal solution to(v,q,a→)2only if q1 ≥ 1 anda1,2=1,or in other words, q1 ≥ 1 anda→1∈{〈100〉,〈101〉,〈110〉,〈111〉}. Hence, we obtain thatS2(v,q,a→)=minℓ(v,u1)+S(u1,q1,a→1)+S(u2,q2,a→2)s.t.q1+q2=q,a→1∨b→=a→,1≤q1≤q,0≤q2≤q,a1→∈{〈100〉,〈101〉,〈110〉,〈111〉},a2→∈{〈000〉,〈111〉},whereS2(v,q,a→)=∞ifq=0or noa→1∈{〈100〉,〈101〉,〈110〉,〈111〉}satisfies thata→1∨b→=a→. For example, consider the instance in Fig. 3(b) withv=6,u1=1andu2=2,for whichb→=〈110〉,and it can be seen thatS2(6,1,〈111〉)=ℓ(6,1)=1,since by Table 2S(1,1,〈101〉)=S(2,0,〈000〉)=0.For the restricted subproblem(v,q,a→)3,it is restricted to a constraint where (v, u2) is selected but (v, u1) is not. Since the subproblem(v,q,a→)3can be transformed to(v,q,a→)2by switching the notation u1 and u2, similarly toS2(v,q,a→),we obtain thatS3(v,q,a→)=minℓ(v,u2)+S(u1,q1,a→1)+S(u2,q2,a→2)s.t.q1+q2=q,a→2∨b→=a→,0≤q1≤q,1≤q2≤q,a1→∈{〈000〉,〈111〉},a2→∈{〈100〉,〈101〉,〈110〉,〈111〉},whereS3(v,q,a→)=∞ifq=0,or noa→2∈{〈100〉,〈101〉,〈110〉,〈111〉}satisfies thata→2∨b→=a→. For example, consider the instance in Fig. 3(b) withv=6,u1=1andu2=2,for whichb→=〈110〉,and it can be seen thatS3(6,1,〈111〉)=∞,since by Table 2S(1,0,〈111〉)=S(2,1,〈101〉)=S(2,1,〈111〉)=∞.Finally, for the restricted subproblem(v,q,a→)4,it is restricted to a constraint where both (v, u1) and (v, u2) are selected. Thus, for any optimal solution to(v,q,a→)1,it can be partitioned into three components, including edges (v, u1) and (v, u2), a collection of subtrees that is optimal to subproblem(u1,q1,a→1),and a collection of subtrees that is optimal to subproblem(u2,q2,a→2),for certain q1 and q2 withq1+q2−1=q,and for certaina→1∈Aanda→2∈Awitha→1∨a→2∨b→=a→. Moreover, for each j ∈ {1, 2}, since (v, uj) is selected, by following the same argument used earlier fora→1in computingS1(v,q,b→),we know that for any optimal solution to the subproblem(uj,qj,a→j),it can be part of an optimal solution to(v,q,a→)4only if qj≥ 1 anda→j∈{〈100〉,〈101〉,〈110〉,〈111〉}. Hence, we obtain thatS4(v,q,a→)=minℓ(v,u1)+ℓ(v,u2)+S(u1,q1,a→1)+S(u2,q2,a→2)s.t.q1+q2−1=q,a→1∨a→2∨b→=a→,1≤qj≤q,aj→∈{〈100〉,〈101〉,〈110〉,〈111〉},forj∈{1,2},whereS4(v,q,a→)=∞ifq=0,or noaj→∈{〈100〉,〈101〉,〈110〉,〈111〉}forj=1andj=2satisfy thata→1∨a→2∨b→=a→. For example, consider the instance in Fig. 3(b) withv=6,u1=1andu2=2,for whichb→=〈110〉,and it can be seen thatS4(6,1,〈111〉)=ℓ(6,1)+ℓ(6,2)=1,since by Table 2S(1,1,〈101〉)=S(2,1,〈100〉)=0. Hence, from (1), we obtain thatS(6,1,〈111〉)=min{∞,1,∞,1}=1.We can now follow the above dynamic programming algorithm to solve subproblems(v,q,a→)recursively for all vertices v ∈ V, from leaves to the root r, for eachq=0,1,…,k,and for eacha→∈A. As shown earlier, by taking the minimum value ofS(r,q,a→)over 1 ≤ q ≤ k anda→∈{〈000〉,〈111〉},we can obtain the total edge weight of the optimal k-median Steiner forest of T. For example, consider the instance in Fig. 3(b) withr=9andk=2,for which we can follow this dynamic programming algorithm to compute subproblems for vertices1,2,3,…,r=9,sequentially, and to obtain thatS(r,2,〈111〉)=7is the total edge weight of the optimal k-median Steiner forest.It can be seen that the above dynamic programming algorithm needs to solve at most O(kn) subproblems(v,q,a→)recursively. Since q ≤ k, by definition each subproblem(v,q,a→)can be solved in O(k) time. Thus, the total time complexity of the algorithm is O(k2n). However, by applying a technique of Tamir (1996), this can be reduced to O(kn) time, as shown below.Theorem 4When vertices are located on a tree T, the k-median Steiner forest problem can be solved to optimality in O(kn) time.We have shown that for this special case, an optimal k-median Steiner forest can be obtained by a dynamic programming algorithm. We next show that the total time complexity of the algorithm is O(kn). Similar to the analysis in Tamir (1996), we define that a vertex v is rich if it is not a leaf, and for each of its children ujwith j ∈ {1, 2}, the subtreeTujrooted at ujcontains at least k/2 vertices. By Lemma 1 in Tamir (1996), we know that the number of rich vertices is bounded above by 2n/k. This implies that the total time complexity for solving subproblems(v,q,a→)with v being a rich vertex is O(kn). Next, we will show that the total time complexity for solving subproblems(v,q,a→)with v not being a rich vertex is also O(kn). For each vertex v, letHv′denote the total time spent for solving subproblems(u,q,a→)with u ∈ Tvbeing not rich, and defineHv:=nHv′. If v is rich, thenHv′=Hu1′+Hu2′,which impliesHv=Hu1+Hu2. Otherwise, v is not rich, and then, it can be seen thatHv′≤Hu1′+Hu2′+cmin{|V(Tu1)|,k/2}min{|V(Tu2)|,k/2},where c is a constant, andV(Tuj)indicates the set of vertices inTujfor j ∈ {1, 2}. This implies thatHv≤Hu1+Hu2+cnmin{|V(Tu1)|,k/2}min{|V(Tu2)|,k/2}. By Lemma 2 in Tamir (1996), we have Hv≤ ckn|V(Tv)|, where V(Tv) indicates the set of vertices in Tv. Thus, we obtain thatHr′≤Hr/n≤ckn|V|/n=ckn. Hence, the total time complexity of the dynamic programming algorithm is O(kn).□

@&#CONCLUSIONS@&#
We have presented a new approximation algorithm for the k-median Steiner forest problem that jointly optimizes facility locations and network connections. The new algorithm is based on a simple transformation from a minimum spanning tree of the clients and a new vertex that replaces all the facilities. Compared with the existing best 2-approximation algorithm that combines a Lagrangian relaxation with a primal-dual schema, our new algorithm is simpler, and achieves a better approximation ratio that is easier to be proved. We have also shown that the new algorithm can always produce solutions of equal or better quality than the existing 2-approximation algorithm, and the quality improvement can be up to 50 percent in some cases. Moreover, we have developed new polynomial time algorithms that can solve the problem to optimality for two special cases, where either each vertex contains a client, or all the vertices are located in a tree-shaped network.One direction of our future research is to improve the approximation ratio for the k-median Steiner forest problem. For this, a possible approach is to extend the techniques that have successfully been used in improving the approximations of the Steiner tree problem, for which the current best approximation ratio isln(4)+ϵ<1.39(Byrka et al., 2013). The other direction of our future research is to develop constant ratio approximation algorithms for other variants of the problem, such as those with a capacity constraint that restricts the maximum number of clients that can be connected to each facility. For this, the results obtained in this study have laid down a sound foundation and can be extended even further.