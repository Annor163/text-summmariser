@&#MAIN-TITLE@&#
@Java: Bringing a richer annotation model to Java

@&#HIGHLIGHTS@&#
A finer grained annotation model for Java that supports annotations on expressions and statement blocks.An extension to the standard annotation model to support annotation׳s members of any time that can be evaluated at run-time.Several case studies included an extension of AspectJ that supports the new annotation model.

@&#KEYPHRASES@&#
Java,Meta-data,Annotations,Reflection,

@&#ABSTRACT@&#
The ability to annotate code and, in general, the capability to attach arbitrary meta-data to portions of a program are features that have become more and more common in programming languages.Annotations in Java make it possible to attach custom, structured meta-data to declarations of classes, fields and methods. However, the mechanism has some limits: annotations can only decorate declarations and their instantiation can only be resolved statically.With this work, we propose an extension to Java (named @Java) with a richer annotation model, supporting code block and expression annotations, as well as dynamically evaluated members. In other words, in our model, the granularity of annotations extends to the statement and expression level and annotations may hold the result of runtime-evaluated expressions.Our extension to the Java annotation model is twofold: (i) we introduced block and expression annotations and (ii) we allow every annotation to hold dynamically evaluated values. Our implementation also provides an extended reflection API to support inspection and retrieval of our enhanced annotations.

@&#INTRODUCTION@&#
Computational reflection is the ability of a system to reason and operate on its own structure. The compiler of a reflection-capable programming language implicitly produces meta-data describing both the structure of the program itself and the structure of the objects that the program manipulates. For instance, the binary form of a Java class includes meta-data about the class it extends, the interfaces it may implement, the methods and fields it defines and the type signatures of said methods and fields. Many reflection-capable programming languages (Java since version 5 and C#) also allow the programmer to explicitly attach arbitrary meta-data to some pieces of code. Annotations in Java are one example of such kind of meta-data.Java annotations make it possible to decorate method, field and class declarations by adding custom pieces of information that may be available at compile-time or even at run-time. Every annotation is defined in its own separate class file, where a programmer can also specify its retention policy: namely, whether it will be available at run-time or not. When they are retained at run-time, annotations are also available for inspection using the reflection API. C# allows arbitrary data to be stored in assemblies as well, using custom attributes. Similar to Java, attributes may decorate method, class, and field declarations. They are serialized into the assembly at compile-time and ignored by the runtime system, but they can still be retrieved using the platform׳s native reflection API. Both C# attributes and Java annotations show common limits:1.They have limited granularity: While it is possible to decorate any kind of declarations with meta-data (e.g., classes and fields declarations), it is impossible to decorate a generic statement, an expression or a code block. In other words, this kind of meta-data cannot appear in the body of a method.They accept only a strict subset of types: In particular, Java annotations can only hold values that can be resolved statically (for instance, it is not possible to assign the return value of a method call), and the only accepted types are primitive values, Strings, Classes, enums, annotations, and arrays of the preceding types.The values that they hold must be resolvable in a static context: they cannot hold values that are only known at run-time (e.g., the result of a method call).Many Java tools overcome the limitations of the language annotation model using non-standard, custom extensions, and employing workarounds such as stylized comments. In most of these cases, the provided annotations are often predefined and specific to a particular purpose; moreover, because the richer annotation constructs are non-standard, they are often mutually incompatible; finally, the constraints of allowing only static values or arbitrary types can only be worked around. Among the others, verification tools and defect detectors for Java (cf. JML in [1,2]) use custom annotations to specify constraints such as loop invariants, pre- and post-conditions, etc.; worst-case execution time analyzers use stylized comments for loop counts [3–5]; UML reverse-engineering tools such as eUML211http://www.soyatec.com/euml2/use annotations in comments to describe relations between classes and methods. There is not much literature about extending annotations with more types and support for runtime-bound values. Dynamic annotations by Noguera et al. [6] embed Groovy expressions in string attributes of plain Java annotations so that they can be evaluated at run-time. However, frameworks that make heavy use of annotations such as the AOP framework Spring, often require programmers to work around the limitation that Java annotations cannot hold runtime-bound values. Even though there is not much literature on the topic, we have found enough help requests on web forums on this subject to believe that it is a known problem, needing a solution.22cf., http://stackoverflow.com/search?q=change+annotation+runtime.Many aspect frameworks are also known to suffer from the fragile pointcut problem (e.g., see [7,8]), that can be dealt with by making pointcuts more explicit, using annotations. In this case, a finer-grained annotation model, coupled with runtime-bound values would make pointcut definition easier, less tailored to the syntax of a program, and, in general, more flexible.Our contribution is @Java, an extension to Java with a richer annotation model that (i) supports custom types and runtime-bound values in annotations, together with (ii) a finer-grained annotation model, that goes beyond the scope of methods, and allows annotations on blocks and expressions.Use Case: @AspectJ.Listing 1Unselectable join points in the Fibonacci computation.The fragile pointcut problem is a consequence of the limitation of pattern-based pointcut languages such as AspectJ [9]. However, pointcut expressions grow in complexity as it becomes necessary to select particular code regions without affecting the others. In addition, there are some computational patterns, although simple, that cannot be captured by AspectJ at all [10]. For instance, code between two method calls, a specific invocation of some method, and code bound to statements likeif,for, and expressions cannot be easily matched unless we resort to artificial refactorizations or very complex pointcut expressions.In Listing 1 we are showing the Fibonacci series computation, where a couple of unselectable join points are marked with two small red circles. The first is the evaluation of a boolean expression that does not involve any method call, the second is the first invocation of the recursive method within its body. These join points could be selected if the boolean expression and the first method call were wrapped into two new methods: but these methods would serve no other function than exposing the join point, at the expense of the readability and simplicity of the code.The coarse grain of the join point model and its dependency on the program syntax allows the capture of only those join points that relate to the application interface, like method invocations, field manipulations and exception handler execution [9], without taking into account their position or context. Thus, it is really hard to pick a particular join point among those that are associated with the same event (e.g., one particular invocation of a given method), and to select those join points that do not appear explicitly in the application interface (for instance, those that are attached to an expression or those that are found inside a loop). This often hinders a neat separation of concerns.AspectJ supports pointcut definition through annotations. Annotations can be used to tackle the problem of pointcut fragility, by making pointcuts more explicit. In this case, the pointcut would target the annotation name instead of patterns, which makes the definition easier to express and less semantically error-prone. Yet, because of the restrictions in Java׳s annotation model, join points such as those in Listing 1 would be still unselectable.Hereafter, we will show how to exploit @Java׳s richer annotation model to implement an extension on top of AspectJ called @AspectJ that includes finer-grained annotations and dynamically evaluated annotations that have been shown [6,11] to be extensions that help to overcome the limitations in AspectJ׳s join point model.The rest of this paper is structured as follows: in Section 2 we describe the @Java extension with respect to Java׳s native annotation model. In Section 3 we describe the implementation of the @Java compiler. In Section 4 we present the @AspectJ extension, and we also present two other case studies to demonstrate the features of @Java in practice. In Section 6 we provide an overview of the related work and in Section 7 we draw our conclusions and describe our future work.In this section we describe the Java annotation model and we detail the features that the @Java extension provides. The model that we presented here builds upon the previous work in [12].Annotations in Java. Almost since its introduction, the Java platform has always supported some form of meta-data to describe internal data structures and to direct the behavior of the virtual machine and of the compiler. For instance, modifiers such as,in Java code, instruct the compiler to treat some values in a special way; similarly, the interfaces Serializable and Clone are often called marker interfaces, because they do not declare any methods and they just tag a class with a specific property.Listing 2Java annotations.Since Java 5, the platform provides a general purpose and customizable annotation mechanism (also known as meta-data facility) that allows the programmer to define and use annotation types. The facility consists of a syntactic mechanism to declare annotations, annotate declarations, APIs to retrieve such annotations, along with an internal binary representation to represent them in class files. Annotations are defined using a specialtype. The definition of an annotation type is similar to an interface declaration. Listing 2 shows how to create and use an annotation type in Java. Annotations can be markers, single-valued, or multi-valued. Annotation types with no members or that provide default values for all members may be used as marker annotations. Single-valued annotations expect one parameter, multi-valued one or more named parameters.The Annotation class also provides meta-annotation types that describe properties of a new annotation type, and that are used to actually annotate other annotations. Among the others, @Target specifies which elements of a program can be annotated by the annotation that is being defined, and @Retention instructs the compiler whether the annotation should be made available in the class file, possibly for run-time consumption. The Java core reflection API provides methods to dynamically retrieve annotations that have a run-time retention policy. The classes Method, Field and Class all implement the AnnotatedElement interface that includes methods to access the associated annotations (if any). For instance, isAnnotationPresent(A.class) returns true when @A decorates the target element, and getAnnotations() returns an array of all the annotations decorating a given element. The following code snippet shows how the getAnnotation() API can be used to retrieve the A annotation associated with a given class.In short, annotations in a Java program play the role of user-defined parameterized keywords, describing properties of a particular piece of code. These properties can be exploited to direct the compilation process, or even describe run-time-specific properties. For instance, in the case of AOP, annotations may be employed to mark specific code sections that need advising.The main limit in Java׳s current annotation model is that annotations can only be attached to element declarations—e.g., method and field declarations—but they cannot decorate a specific code section or an expression. Moreover, they can only be resolved statically: it is not possible to assign the return value of a method call, or the value of a field, unless it is defined, and the only allowed values that can be assigned are primitive values, Strings, Classes, enums, annotations, and arrays of the preceding types.Listing 3Foo.java@Java in a nutshell. The @Java language is a natural extension to Java that supports a richer annotation model, where assignment of runtime-computed values is supported, and even blocks and expressions can be annotated. These richer annotation types are defined following the familiar, native Java syntax, with only a few extensions.In @Java, annotation may hold values of any Java type, and members can be dynamically evaluated; that is, they can refer non-constant values that are only known at runtime. We call annotations that use this feature Dynamically Evaluated Annotations (DEAs). DEAs extend seamlessly the native Java model, without requiring any additional hints to the compiler. The @Java compiler detects occurrences of extended types in annotations (that is, types that are not native to Java׳s annotation model), and it works behind the scenes to make the usage of these custom types as seamless as possible. Thus, DEAs in @Java code look and feel mostly identical to Java annotations; but, because they support non-values, DEAs, as opposed to traditional annotations, are evaluated dynamically at run-time (hence, the name). For instance, Listing 4 shows theannotation that takes ainstance as its.Block and expression annotations are an extension to the native Java annotation model to support finer-grained meta-data injection in code. Block annotations (see Listing 3) can be used to decorate a statement or a sequence of statements. Syntactically, an annotated block is a Java block (a sequence of zero or more statements, enclosed within braces) preceded by an annotation. Block annotations may also be nested. Annotated expressions are Java expressions that have been surrounded by braces, and are preceded by an annotation (see Listing 3). The main difference between a block annotation and an expression annotation is that the expression annotation evaluates to a result (simply put, it can be assigned to a variable). Annotated expressions can be nested as well. On the other hand, consistently with Java blocks, an annotated block groups a sequence of zero or more statements, and it does not evaluate to a result, in the sense that a block can never be assigned to a variable. Listing 4 shows an example of annotated code that uses both block (@Trace) and traditional (@Author) annotations with DEAs.Listing 4Example usage for block and dynamically evaluated annotations.Java 5 provides the reflective API to inspect method, class or field declarations for the presence of an annotation. Likewise, the @Java language comes with an extended reflection API to inspect DEAs and look for annotated blocks and expressions inside method bodies. This extension is meant to fit seamlessly within Java׳s annotation model, and it therefore abides to the rules that the native annotation model (directly or indirectly) imposes.Dynamically evaluated annotations. The introduction of DEAs poses some interesting questions. For instance, one problem with DEAs is when they should be evaluated. In the case of block and expressions, it makes sense to evaluate them during program execution. In particular, our choice was to evaluate the contents of the annotation after the code that it contains has executed. In every other case, DEAs annotate declarations, just like their native Java counterparts. The choice here was to lazily calculate their value only when they are inspected using reflection.DEAs may contain references to class fields, results of method invocations, constructors, and in general, valid Java expressions. Block and expression annotations are also allowed to refer local variables. The value held by the annotation assumes the value that is being passed. For instance, the annotation @Trace in Listing 4 would contain the number of times (hits) the body of the while loop has been actually executed. This information may be extracted a posteriori using reflection. The @Author annotation in the same listing decorates the class with rich data about the author that is retrieved from an external source. DEAs can be retrieved using an extended API. In the introduction we showed that a common problem for programmers using frameworks that make extensive use of annotations is to be able to assign updatable values to their annotations. It is easy to see that DEAs are able to hold stateful object instances that can be updated at run-time.Listing 5Example usage of the extended reflection API for DEAs.Block and expression annotations. Expression and block annotations are represented by subclasses of Annotation. Since these annotations occur in the body of a method, they can be retrieved by interrogating a Method object (that is, the reification of a method that the reflection API returns). However, by the same reasoning, block and expression annotations may occur in constructors, and expression annotations may occur in the initialization expression of a field.The implementation of the Method, Constructor and Field classes is then augmented by adding specific methods to deal with annotated expressions (see Table 1for a short summary). For instance, the method getExpressionAnnotations() returns an array of all the expression annotations. Moreover, Method and Constructor also include methods related to block annotations. For instance, if m is a Method instance, then m.getBlockAnnotations() returns an array of all the block annotations in the body of that method. In Listing 6, we are retrieving an array of every block annotation Block occurring in Listing 3. In this particular case, there is only one annotation of that type, but the method returns an array because multiple occurrences are possible in principle.Listing 6Using the extended reflection API.There are also methods to access the bytecode and source code representation of an annotated construct. For instance, getAnnotatedBlocks() returns an array of AnnotatedBlock instances. This class provides the programmer with additional methods to inspect the annotated code block. For instance it is possible to iterate over the bytecode and over the lines of the source code, and there are methods that describe the offset in the file where the block begins (see Table 2). Similar operations are available for expression annotations (e.g., getAnnotatedExpressions()).@Java׳s reflection API does not allow the programmer to perform further manipulations on the annotated code, since it is limited to introspection operations, like Java׳s native reflection library. The so-called intercession, that is, reflective alteration of the behavior of a program, can be realized by way of third-party tools such as Javassist [13] and BCEL[14] to perform source code or bytecode manipulation. An example is shown in Listing 7.Listing 7Extruding a code block using BCEL.

@&#CONCLUSIONS@&#
Many code processing tools define their own annotation models, especially when a finer-grained annotation model is required, since Java׳s annotation model limits to field, method and class declarations. In this paper we have presented @Java, an extension to the Java language with a richer annotation model supporting custom types and dynamically evaluated members, as well as support for annotating at a finer-grained level (block and expressions). @Java has been developed to feel as much of a natural extension as possible. Block and expression annotations are declared just like any other regular Java annotation whereas DEAs are smoothly integrated to the traditional annotation syntax. The extended reflection API follows the standard, implicit or explicit conventions in Java׳s own native reflective API.@Java does not provide a predefined set of annotations, but provides the tools that are necessary to build around them a complete framework. @Java׳s APIs allow us to manipulate the annotated source code and bytecode to perform operations such as extrusion, removal and injection of code.@Java׳s compiler is still in its early stage. The compiler runs on top of the standard javac tool, and therefore it must first translate custom annotations to a backward-compatible form. A future effort may involve developing patches for the Java virtual machine and compiler to support the @Java richer annotation model. The reflective library may evolve, for instance by providing built-in code manipulation APIs without requiring external libraries.We are also developing tools on top of @Java. As we saw in Section 4, the @Java richer annotation model can be employed to reverse engineer UML diagrams starting from code, or co-evolve code with its model. Moreover, we also employed it to provide a finer-grained join point selection mechanism in an AspectJ-like AOP framework that we called @AspectJ.A prototype of @Java can be found at the URL http://cazzola.di.unimi.it/atjava.html.