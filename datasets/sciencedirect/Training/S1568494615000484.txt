@&#MAIN-TITLE@&#
Tuning compilations by multi-objective optimization: Application to Apache web server

@&#HIGHLIGHTS@&#
A strategy and tool for tuning compilations by multiobjective optimization are proposed.Multiple criteria satisfaction is based on NSGA-II algorithm.The tool has been tested using a case of study based on Apache web server.Overall Apache improvement achieved up to 8.5% assuming 4 criteria of interest.30.1% of improvement when a single criterion (minimize L2 cache misses) is selected.

@&#KEYPHRASES@&#
Multi-objective optimization,NSGA-II,Compiler,Tuning compilations,Evolutionary search,

@&#ABSTRACT@&#
Modern compilers present a great and ever increasing number of options which can modify the features and behavior of a compiled program. Many of these options are often wasted due to the required comprehensive knowledge about both the underlying architecture and the internal processes of the compiler. In this context, it is usual, not having a single design goal but a more complex set of objectives. In addition, the dependencies between different goals are difficult to be a priori inferred. This paper proposes a strategy for tuning the compilation of any given application. This is accomplished by using an automatic variation of the compilation options by means of multi-objective optimization and evolutionary computation commanded by the NSGA-II algorithm. This allows finding compilation options that simultaneously optimize different objectives. The advantages of our proposal are illustrated by means of a case study based on the well-known Apache web server. Our strategy has demonstrated an ability to find improvements up to 7.5% and up to 27% in context switches and L2 cache misses, respectively, and also discovers the most important bottlenecks involved in the application performance.

@&#INTRODUCTION@&#
In software solution production, compilers constitute a crucial tool in the software prototype development. Modern compilers expose an ever increasing number of optimization features. However, these options are not fully exploited because that would require a deep knowledge of both the underlying architecture and the target application as well as the compiler usage and internals. The selection of the most convenient set of options to improve a specific goal (e.g. execution time, code size, cache misses, context-switching rate, etc.) represents a task of enormous complexity because there are inter-dependencies that cannot be predicted. Modern most-used compilers, such as GCC [1], CLang [2] or ICC [3], provide a large number of compilation options which can modify the features of the compiled programs.Many of these compiler options support different modifiers that markedly increase the number of possibilities to compile an application and, consequently, this complicates the selection of the most convenient set of options. Furthermore, certain option combinations can diminish the performance or even change the execution results (for example, code vectorization may relax the floating point accuracy). With thousands of possibilities to consider, estimating the optimal combination to compile a certain code by brute-force is unfeasible in terms of time.On the other hand, the performance improvement of an application can be characterized by various technical criteria and design constraints that must be satisfied simultaneously and optimized as far as possible. Occasionally, these criteria may conflict and result in a mutual worsening (e.g. performance and power consumption in embedded systems).Aforementioned reasons lead us to propose a strategy that is able to produce good solutions in an affordable time. In this paper, multi-objective optimization based on a Genetic Algorithm is used to explore the huge solution space. Our proposal runs independently of the underlying compiler under consideration, and it simultaneously optimizes any kind of objective of interest. Furthermore, the process has been accelerated using a parallel scheme based on an island model.Eventually, the goodness of the proposed approach is shown in a case of study applied to improve the performance of the Apache web server. In this kind of network applications, as they usually involve many processes from the web server, the network stack and the operating system, global compiler optimization options are not enough to optimize. When our method is applied, however, a set of compilation options that simultaneously improve several metrics is obtained.The rest of the paper is structured as follows: Section 2 includes some related works; Section 3 presents the intrinsic of the compilation process; the proposed system is described in Section 4; Section 5 describes the experimental case of study, the obtained results are deeply analyzed in Section 6; finally, Section 7 provides the conclusions of this work.

@&#CONCLUSIONS@&#
In this paper we present an optimization tool which figures out the compiler options that aims to maximize the performance of a specific application. As multiple criteria are required in the optimization process, this tool has been implemented using a multi-objective Genetic Algorithm that can work in parallel in a multi-computer environment, speeding up the overall process. It has been observed that the presented technique performs well when dealing with optimization problems with multiple criteria satisfaction, by means of the implemented sorting and conservation of the best solutions strategy based on the algorithm NSGA-II. In addition, the presented tool may reveal the relationship among objectives. This is an important feature as the results can be used for further software and hardware improvements.In our case of study, focused on optimizing the operation of Apache, we found a limited room for improvements with respect to the default compilation in each criterion separately. However, we show improvements in the cache operation and a relationship between cache hits and web server performance is figured out. This way, our strategy has demonstrated an ability to find improvements up to 7.5% and up to 27% in context switches and L2 cache misses, respectively, contributing to release CPU cycles that remains available to other processes.As a future direction we will attempt to infer the incidence of compilation options to each criterion. In this case, it would be interesting to know which option or combination of options makes individuals belong to a better or worse front as seen in the graphs. Another interesting field of study would be to consider other applications that do not have such a high dependency on network resources in order to compare the results. This would also allow us to make a study of the incidence of compilation options depending on the application type, whose results could be used in the strategy as a priori knowledge. In fact, the presented technique can be used with every application and platform, constituting a valuable tool to optimize the performance of a specific application. Moreover, the optimization process also discovers the most important bottlenecks involved in the application performance through the relationships between objectives, which can be used to improve the software and to optimally scaling the server hardware.