@&#MAIN-TITLE@&#
The two-machine flowshop scheduling problem with sequence-independent setup times: New lower bounding strategies

@&#HIGHLIGHTS@&#
We study the two-machine flowshop problem with sequence-independent setup times.The total completion time is to be minimized.Several lower bounding schemes are proposed.Computational results show the good performance of the derived bounds.

@&#KEYPHRASES@&#
Scheduling,Two-machine flowshop,Sequence-independent setup times,Total completion time,Lower bounds,Lagrangian relaxation,

@&#ABSTRACT@&#
The two-machine flowshop environment with sequence-independent setup times has been intensely investigated both from theoretical and practical perspectives in the scheduling literature. Nevertheless, very scant attention has been devoted to deriving effective lower bounding strategies. In this paper, we propose new lower bounds for the total completion time minimization criterion. These bounds are based on three relaxation schemes, namely the waiting time-based relaxation scheme, the single machine-based relaxation scheme, and the Lagrangian relaxation scheme. Extensive computational study carried on instances with up to 500 jobs reveals that embedding the waiting time-based bounding strategy within the Lagrangian relaxation framework yields the best performance while requiring negligible CPU time.

@&#INTRODUCTION@&#
Due to the increasing competition caused by globalization, manufacturing industries are nowadays forced to minimize costs and reduce delays in order to maintain competitive positions in the fast changing markets. Flexible production systems together with modern scheduling tools, which rely on sophisticated and effective techniques, proved to substantially help in reaching such key success factors. Flexible production systems induce more important setup times during which the tools of each machine of a production line are changed in order to be able to switch from one batch to another. Setup activities include several important tasks such as tools acquirement and adjustment, machine cleaning up, and material inspection. Recent studies show the significant impact of reducing setup times with respect to several performance criteria encompassing production speed increase, competitiveness improvement, lead times shortening, stock reduction, and customer satisfaction increase [5]. For the sake of illustration, Trovinger and Bohn [29] reported that combining the SMED method with IT-based techniques in a printed circuit board assembly yielded a setup time reduction of more than 80%, resulting to an annual benefit of $1.8 million.Not only it is crucial to optimize setup times, but more importantly, it is often essential to explicitly take them into account while scheduling numerous production systems. Allahverdi and Souroush [5] listed various real-world scheduling applications where setup times are considered separately from processing times. In addition to industrial applications (e.g. metal processing, brake manufacturing, electronics, etc.), the list covers a wide range of areas including finance, information processing, health care, cosmetics, and satellite imaging, to quote just a few.In the present paper, we investigate a two-machine flowshop scheduling environment with setup time consideration. The setup times are assumed to be sequence-independent, i.e. they only depend on the job to be processed, regardless of its preceding job. The objective is to find a feasible job sequence which minimizes the total completion time. More formally, a set of n jobs has to be processed on machines M1 and M2 in that order. Processing job j∈{1,…,n} on machine Mi(i∈{1,2}) requires si,junits of setup time and pi,junits of non-preemptive processing time. At this point, it should be made clear in the reader’s mind that the setup times are separate entities that are not hidden in the processing times. Indeed, the setup time of a given job on M2 can be dealt with during its processing on M1. All data are assumed to be deterministic and integer. Each machine processes at most one job at one time and each job cannot be processed by more than one machine at one time. According to Allahverdi et al. [8], this stronglyNP-hard problem is denoted byF2|STsi|∑Cj. It is worth noting that we only focus on permutation schedules, i.e. where both machines have the same job sequence. Indeed, for any regular optimization criterion in a two-machine flowshop environment with sequence-independent setup times, it can be shown that there always exists an optimal schedule where the job sequence is the same for both machines [7]. Also, it should be noted that the total completion time is equivalent to the mean flow time criterion.Interestingly, several real-world industrial applications can be modeled as a two-machine flowshop scheduling problem with sequence-independent setup times. These include scheduling multimedia data objects for World Wide Web applications [9], and scheduling automated manufacturing cells with computer-controlled transportation robots [24]. In particular, theF2|STsi|∑Cjarises in the context of three-tiered Internet/database connectivity model which provides an interface between the enterprise service and clients [3]. In this model, client requests need to be processed by the application server and then by the database server (which represent M1 and M2, respectively). For the sake of efficiency, the queued requests are to be scheduled so that the average completion time of a client request is minimized. Before a request can be processed, the resources needed for this request are to be made ready in the application server. Also, an access to the database must be preceded by a preprocessing operation which consists in a database query decomposition and a partial optimization. Since this latter preprocessing operation can start while the application server is processing the query, then it can be seen as its setup operation on the second server.From a theoretical point of view, the two-machine flowshop with sequence-independent setup times has been the scope of numerous investigations. One of the pioneering results is that of Yoshida and Hitomi [31] who showed that the minimum makespan can be computed in polynomial time. The last decade witnessed a particular interest arousal in this scheduling environment with various optimization criteria [4,6,9]. Also, thorough studies have been conducted on several variants of the machine/job settings, encompassing the single server variant, the no-wait variant, the assembly variant, and the random setup and/or processing times variants [4,10,12,17]. For an exhaustive overview of scheduling literature that deals with setup times, the reader is referred to the excellent survey papers of Allahverdi et al. [7,8].Bagga and Khurana [11] were the first to address theF2|STsi|∑Cjproblem. They proposed two lower bounds, a dominance rule and a branch-and-bound algorithm which could only solve small-sized instances with up to 9 jobs. The most important contribution inF2|STsi|∑Cjrelated research is probably that of Allahverdi [6]. He implemented the lower bounds of Bagga and Khurana [11] together with two new dominance rules in a branch-and-bound algorithm which was able to solve instances with up to 35 jobs. He also proved that if s1,j+p1,j⩽s2,jfor all j∈{1,…,n}; then the optimal sequence is obtained by sorting the jobs according to the nondecreasing order of s2,j+p2,j. Moreover, he proposed three constructive heuristics which sequence one, two, and three jobs at a time, respectively. These heuristics have been combined with local search procedures by Al-Anzi and Allahverdi [3] and provided better results. Recently, Ladhari et al. [25] proposed a dynamic priority rule-based constructive heuristic which proved to consistently outperform those of [3]. Moreover, Ladhari et al. [25] devised a multiple crossover genetic local search algorithm that provided near-optimal solutions in reasonable CPU time for large-sized instances with up to 500 jobs.Despite the non-negligible research efforts that have been devoted to theF2|STsi|∑Cj, there is still a big hole in the related literature in terms of lower bounding procedures. As far as we know, the only developed lower bounds forF2|STsi|∑Cjare those of Bagga and Khurana [11] and Gharbi et al. [18]. As it will be detailed in the next section and assessed in our experimental analysis, these bounds are much simplistic and prove to have a low performance. Undoubtedly, efficient and tight lower bounds constitute the bedrock of highly performant branch-and-bound algorithms. Consequently, the lack of strong lower bounding procedures considerably obstructs the development of efficient exact methods for theF2|STsi|∑Cj. On the other hand, it is well-known that a critical performance measure of an approximate solution is its relative gap with respect to a lower bound. Therefore, relying on loose lower bounds would yield inaccurate assessments of potentially good heuristics for theF2|STsi|∑Cj.Actually, theF2|STsi|∑Cjgeneralizes the classicalF2||∑Cjwhere the setup times are assumed to be merged with the processing times. Several lower bounds have been proposed for theF2||∑Cjso far. The very first machine-based lower bounds have been proposed by Ignall and Schrage [22]. Improved lower bounds that are based on similar bounding schemes have been proposed by Ahmadi and Bagchi [1] and Della Croce et al. [15]. Akkan and Karabati [2] proposed a lower bounding scheme that is based on a network formulation of theF2||∑Cj. In particular, numerous Lagrangian-based lower bounds have been proposed so far for theF2||∑Cj[14,20,21,30].In an initial version of this paper [18], two new lower bounding schemes have been proposed for theF2|STsi|∑Cj. The first bounding scheme, baptized the waiting time-based bounding scheme, is based on the minimum time each job has to wait since its finishing time on the first machine until its start time on the second machine. The second one, namely the single machine-based bounding scheme, is based on relaxing the capacity of the first machine. Preliminary computational results have shown that the derived polynomial-time lower bounds outperformed those of Bagga and Khurana [11]. In this paper, we revisit those lower bounding schemes in more details from both theoretical and experimental aspects as detailed in the following points:•Five waiting time-based lower bounds are described, includingLBWT1,LBWT2,LBWT3of [18] and two newly proposed ones, namelyLBWT4andLBWT5. Actually,LBWT4brings a new idea of estimating the minimum required waiting time if one job precedes another, whileLBWT5constitutes a promising extension of anF2||∑Cjlower bound that was proposed by Della Croce et al. [15]. We provide proof thatLBWT4theoretically dominatesLBWT1andLBWT2, whilst we show by using simple counter-examples that no dominance relationship exists betweenLBWT4andLBWT3. However, an empirical pairwise comparison provides evidence thatLBWT4consistently dominatesLBWT3. On the other hand,LBWT5is shown to only dominateLBWT1from the theoretical point of view. Nevertheless, the computational performance ofLBWT5proves to considerably outperform all of the discussed waiting-time based lower bounds.In addition to the two single machine-based lower bounds of [18], namelyLBSM1andLBSM2, two newly derived ones are discussed in this paper. The first one,LBSM3, consists in exactly solving a single machine problem that is obtained through an equivalence result. This latter bound dominates theoretically and empirically bothLBSM1andLBSM2. Not surprisingly, due to its exponential nature,LBSM3provides improved results with a higher computational time which seems however to be reasonable. The second lower bound,LBSM4, is inspired-again-from anF2||∑Cjlower bound that was proposed by Della Croce et al. [15]. Although we provide evidence thatLBSM1is the only single machine-based lower bound that is theoretically dominated byLBSM4, the empirical results show that the latter bound exhibits the best effectiveness/efficiency trade-off among the one machine-based lower bounds.A more thorough computational analysis of those preliminary lower bounds as well as of the newly derived ones is provided. The experiments have been conducted on a larger set of instances with up to 500 jobs. Moreover, the adopted performance criteria go beyond the percentage of times each bound yields the maximal value over all of the discussed ones. Indeed, a pairwise comparison of the lower bounds has been carried out in order to provide a clear picture of the empirical dominance of each bound with respect to another. Also, the relative distance of each lower bound with respect to the best obtained one and to the state-of-the-art upper bound are provided. These important measures, along with the average CPU time, allow the reader to easily assess the quality-to-effort ratio of each lower bound. Actually, one major finding of this analysis is that the lower bound that seems to have the best performance in our preliminary work (namelyLBWT3) reveals not to be of much interest. Indeed, besides the fact thatLBWT3is consistently dominated byLBWT4, it equalsLBWT2in 96.33% of the cases while requiring much more computational effort. Finally, the worth of implementing each of the discussed lower bounds is appraised by analyzing the impact of its incorporation within a branch-and-bound algorithm.Furthermore, we investigated two additional bounding techniques, namely the Linear Programming (LP) scheme and the Lagrangian Relaxation (LR) scheme. The LP scheme relies on the position-based formulation of theF2|STsi|∑Cj. Actually, it is important for the reader to know that our computational study revealed that the LP-based bound outperforms all of the discussed lower bounds in terms of effectiveness. However, its huge computation time compared to the other bounds makes it much less competitive in terms of efficiency. Indeed, the LP-based bound was shown to be worthless after having been assessed through two exact procedures, namely a branch-and-bound algorithm and a Mixed Integer Linear Programming (MILP) approach. On the other hand, the LR-based bounds consist of a generalization of the method that has been initially proposed by Van De Velde [30] for theF2||∑Cj. Interestingly, embedding the waiting time-based concept within the LR framework enabled to derive promising lower bounds that exhibit a good performance within a branch-and-bound algorithm.The remainder of the paper is organized as follows. In Section 2, we describe the lower bounds proposed in the literature. The newly proposed waiting time-based and single machine-based lower bounds are detailed in Sections 3 and 4, respectively. Section 5 displays the mathematical model that computes the LP-based bound. The proposed LR-based lower bounds are discussed in Section 6. Computational experiments on a large set of randomly generated instances are reported in Section 7. Section 8 concludes the paper with some directions for future investigations.In this section, we describe the lower bounds that are proposed in theF2|STsi|∑Cjliterature. We start by describing the two lower bounds of Bagga and Khurana [11]. Then, we present the waiting time-based and the single machine-based lower bounds that have been proposed by Gharbi et al. [18].Assume that the resource constraint of the second machine is relaxed. Then, M2 can now process any number of jobs at the same time. The obtained problem is thus a single machine one (denoted by1|STsi,qj|∑Cj) with setup times sj=s1,j, processing times pj=p1,jand delivery times qj=p2,jfor all j∈{1,…,n}. Since∑j=1nqjis constant, then the obtained problem is equivalent to1|STsi|∑Cj. The optimal total completion time of this latter problem, denoted hereafter byLBBK1, is a valid lower bound forF2|STsi|∑Cj. LetCj1denote the completion time of job j in the Shortest Processing Time (SPT) sequence of the1||∑Cjproblem, which is obtained after merging the setup time and the processing time of each job j∈{1,…,n}. Therefore, we haveLBBK1=∑j=1nCj1+∑j=1nqjThe computation ofLBBK1requires sorting the jobs according to the nondecreasing order of their s1,j+p1,j. Thus,LBBK1can be computed in O(nlogn) time.The second lower bound that has been proposed by Bagga and Khurana [11], denoted hereafter byLBBK2, assumes that s1,j=p1,j=0. In this case, a single machine problem1|STsi|∑Cjwith setup times sj=s2,jand processing times pj=p2,j(j∈{1,…,n}) is obtained. Then,LBBK2is equal to the corresponding optimal total completion time which is obtained using the SPT rule after merging the setup time and the processing time of each job j∈{1,…,n}.LBBK2can be computed in O(nlogn) time.It should be pointed out thatLBBK1andLBBK2are straightforward generalizations of the first and second bounds proposed by Ignall and Schrage [22] for theF2||∑Cj, respectively.The waiting time-based bounding scheme has been initially proposed by Gharbi et al. [18]. It relies on the minimum amount of time, denoted by δj, that a job j∈{1,…,n} has to wait between its finishing time from M1 and its starting time on M2. SinceCj1is a lower bound of the completion time of job j on the first machine, then job j cannot starts beforeCj1+δjon the second machine. Thus, job j cannot end beforeCj1+δj+p2j. Clearly, a valid lower bound forF2|STsi|∑CjisLBWT=∑j=1nCj1+∑j=1np2,j+Δ, whereΔ=∑j=1nδjdenotes the total waiting time. Note that trivially setting δj=0 for all j∈{1,…,n} yields the first lower boundLBBK1of Bagga and Khurana [11]. Therefore, all the proposed waiting time-based lower bounds dominateLBBK1.Gharbi et al. [18] considered three scenarios on the number of job predecessors: a zero-predecessor, a one-predecessor, and a multiple-predecessor scenario. The first scenario assumes that job j is not preceded by any job, which means that the setup operation of job j on M2 starts at the same time as its setup operation on M1. Consequently, a lower bound on δjisδj1=max(s2,j-s1,j-p1,j,0), and a valid O(nlogn)-time lower bound for theF2|STsi|∑Cj, isLBWT1=∑j=1nCj1+∑j=1np2,j+Δ1, whereΔ1=∑j=1nδj1.The second scenario generalizes the first one by observing that only one job has no predecessor, and any other job j could have a longer waiting time thanδj1. Indeed, for each such job j, the setup operation on M2 has to wait until its predecessor, say job h, finishes its processing. Note that there are at leastδh1+p2,hunits of time that must elapse between the finishing time of job h on M1 (which corresponds to the starting time of job j on M1) and its finishing time on M2. Consequently, if a job j is not the first scheduled job, then a better lower bound on δjisδj2=max0,s2,j-s1,j-p1,j+minh≠jδh1+p2,h. Therefore, if a particular job j0 is the first one to be processed, then a lower bound on the total waiting time isδj01+∑j≠j0δj2. Hence, a valid O(nlogn)-time lower bound for theF2|STsi|∑CjisLBWT2=∑j=1nCj1+∑j=1np2,j+Δ2, whereΔ2=minj0∈{1,…,n}δj01+∑j≠j0δj2.The multiple-predecessor scenario advantageously extends the waiting time-based approach in the following way. Let Ci,jdenote the completion time of job j on machine Mi(i∈{1,2}) in any feasible schedule, and [k] denote the job that is scheduled at position k. Gharbi et al. [18] showed thatδj[k]=maxminh≠jδh[k-1]+p2,h+s2,j-s1,j-p1,j,0is a valid lower bound on δjif job j is scheduled at position k. Using a dynamic programming algorithm, the computation ofδj[k]for all j, k∈{1,…,n} can be performed in O(n2) time. Now, since each job has to be assigned exactly one position, then a better lower bound on Δ can be obtained by solving the assignment problem where the cost of assigning job j to position k isδj[k]. If Δ3 denotes the minimum total assignment cost, then a valid O(n3)-time lower bound for theF2|STsi|∑CjisLBWT3=∑j=1nCj1+∑j=1np2,j+Δ3. It should be noticed thatLBWT3⩾LBWT2⩾LBWT1⩾LBBK1[18].The single machine-based bounding scheme [18] assumes that the resource constraint of the first machine is relaxed. As a consequence, M1 can process any number of jobs at the same time. The obtained problem is a single machine scheduling problem, denoted by1|STsi,rj|∑Cj, with setup times sj=s2,jand release dates rj=s1,j+p1,j. Therefore, the optimal solution as well as any lower bound for1|STsi,rj|∑Cjconstitutes a valid lower bound for theF2|STsi|∑Cj. At this level, it should be noticed that the1|STsi,rj|∑CjisNP-hard, since the1|rj|∑CjisNP-hard [27]. Note also that the lower boundLBBK2proposed by Bagga and Khurana [11] can be seen as a trivial lower bound for the1|STsi,rj|∑Cjwhere all the release dates are set to zero.Interestingly, Gharbi et al. [18] showed that 1∣STsi,rj∣f and 1∣rj∣f are equivalent, and that valid lower bounds for theF2|STsi|∑Cjcould be obtained through relaxing the derived1|rj|∑Cjinstance. The first single machine-based lower bound, denoted hereafter byLBSM1, is derived by computing the optimal total completion time of the preemptive version of the obtained1|rj|∑Cjproblem.LBSM1can be computed in O(nlogn) by using the Shortest Remaining Processing Time (SRPT) rule: at any time schedule an available job having the shortest processing time [1]. It is worth noting thatLBSM1seems to be similar in spirit to the SRPT-based lower bound proposed by Ahmadi and Bagchi [1] for theF2||∑Cj. Nevertheless, it should be pinpointed that designing an SRPT-based lower bound for theF2|STsi|∑Cjwould not have been achievable without the key role of the equivalence result. The second single machine-based lower bound, denoted hereafter byLBSM2, is obtained by computing the O(n2)-time improved version of the preemptive lower bound that has been proposed by Della Croce and T’Kindt [16]. It should be noticed thatLBSM2⩾LBSM1⩾LBBK2[18].In this section, we propose two new waiting time-based lower bounds for theF2|STsi|∑Cj. The first lower bound is based on the observation that if job j is preceded by a job i, then a lower bound on the minimum waiting time δjisδi,j=maxδi1+p2,i+s2,j-s1,j-p1,j,0. Note that, except the first (resp. last) scheduled job, each job has to be preceded (resp. succeeded) by another one. The first scheduled job is assumed to be preceded by a dummy job, denoted by job 0, withδ0,j=δj1for all j∈{1,…,n}. Moreover, the last scheduled job is assumed to be succeeded by a dummy job, denoted by job n+1, with δi,n+1=0 for all i∈{1,…,n}. Obviously, since job 0 cannot precede job n+1, then we set δ0,n+1=∞.Consequently, a lower bound on Δ can be obtained by solving the assignment problem where the assignment costs are δi,j(i∈{0,…,n}; j∈{1,…,n+1}). Obviously, we set δj,j=∞ for all j∈{1,…,n}. Let Δ4 denote the minimum total assignment cost. Therefore, the following lower bound for theF2|STsi|∑Cjholds:LBWT4=∑j=1nCj1+∑j=1np2,j+Δ4Clearly, the computation ofLBWT4requires O(n3) time.Proposition 1LBWT4⩾LBWT2.The result follows sinceδi,j⩾δj2for all i,j∈{1,…,n}.□Table 1depicts the data of a 5-jobF2|STsi|∑Cjinstance. The values of δi,j(i,j∈{0,…,n+1}) are depicted in Table 2. The bold values correspond to the optimal assignment. We have Δ4=19 andLBWT4=∑j=1nCj1+∑j=1np2,j+Δ4=644+174+19=837. Note thatLBWT1=827,LBWT2=833, andLBWT3=836.It is worth mentioning that there is no dominance relationship betweenLBWT3andLBWT4, as shown by the following example.Consider the three-job instance defined by s1,j=2, p1,j=2, s2,j=6, and p2j=4(j∈{1,2,3}). We have:δj[1]=2,δj[2]=8,δj[3]=14(j∈{1,2,3}). Therefore, we get Δ3=2+8+14=24 andLBWT3=∑j=1nCj1+∑j=1np2,j+Δ3=(4+8+16)+(4+4+4)+24=60. On the other hand, we have δ0,j=2(j∈{0,1,2}), δ1,1=δ1,2=δ2,0=δ2,2=δ3,0=δ3,1=8 and δi,3=0 (i∈{1,2,3}). The optimal assignment gives Δ4=18. Thus, we haveLBWT4=54.Now, we describe a promising lower bound that can be obtained through the generalization of the lower boundLBDNT1of Della Croce et al. [15] for theF2||∑Cj. Recall that the latter lower bound is equal to∑j=1nCj1+∑j=1np2,j+γ(hereCj1are computed with zero setup times), where γ is a lower bound on the following quantity:(1)Γ(S)=∑j=1n-1max(0,p2,[j](S)-p1,[j+1](S))+∑j=1n-1max(0,p1,[j](S)-p1,[j+1](S))(pk,[j](S) denotes the processing time of the jth job on machine Mkaccording to the job sequence S). The value of γ is computed by adding a dummy job j0 and solving an assignment problem where the assignment costs are defined by:wi,j=max(0,p2,i-p1,j)+max(0,p1,i-p1,j)∀i,j∈{1,…,n};i≠jwi,j0=wj0,i=0∀i∈{1,…,n}By using similar arguments to those of Della Croce et al. [15], it is easy to prove that a valid lower bound forF2|STsi|∑CjisLBWT5=∑j=1nCj1+∑j=1np2,j+Δ5where Δ5 is equal to the optimal value of the assignment problem with the following assignment costs:di,j=max(0,p2,i+s2,j-s1,j-p1,j)+max(0,s1,i+p1,i-s1,j-p1,j)∀i,j∈{1,…,n};i≠jdi,j0=0∀i∈{1,…,n}dj0,i=δi1∀i∈{1,…,n}Actually, this result can be intuitively derived from that of Della Croce et al. [15] by viewing theF2|STsi|∑Cjas anF2||∑Cjwhere s1,[j] is merged with p1,[j], and s2,[j+1] is merged with p2,[j], for all j∈{1,…,n−1} (recall that [j] denotes the job that is scheduled in position j). The computation ofLBWT5requires O(n3) time.The values of di,jare depicted in Table 3. The bold values correspond to the optimal assignment. We have Δ5=32 andLBWT5=∑j=1nCj1+∑j=1np2,j+Δ5=644+174+32=850.LBWT5⩾LBWT1.Obvious sincedi,j⩾δj1for all i, j∈{1,…,n}.□The following example shows that there is no dominance relationship betweenLBWT2andLBWT5.Example 2ContinuedWe have di,j=6 for all i, j∈{1,2,3}(i≠j); anddj0,i=2for all i∈{1,2,3}. The optimal assignment gives Δ5=14. Thus, we haveLBWT5=50<LBWT2=54(note thatLBWT5>LBWT2in Example 1).In this section, we propose two new single machine-based lower bounds that outperform those of Gharbi et al. [18]. The first lower bound, denoted byLBSM3, can be derived by optimally solving the obtained1|rj|∑Cjproblem. Since the1|rj|∑Cjis stronglyNP-hard, thenLBSM3requires an exponential computation time. Nonetheless, several efficient branch-and-bound algorithms for the1|rj|∑Cjexist in the literature. In our implementation, we used the branch-and-bound algorithm presented in [28].Proposition 3LBSM3⩾LBSM2.Obvious.□Table 4provides the data of the obtained1|STsi,rj|∑Cjinstance after relaxing the capacity of the first machine. Table 5depicts the data of the equivalent1|rj|∑Cjinstance. The optimal non-preemptive sequence is 1-5-3-2-4 and we haveLBSM3=843.An additional interesting by-product of the single machine equivalence theorem of Gharbi et al. [18] is the generalization of the lower boundLBDNT2of Della Croce et al. [15] that has been proposed for theF2||∑Cj. We introduce the following notations:•C¯[j](S): the completion time of the jth job according to the sequence S for the1|STsi,rj|∑Cjinstance that is obtained after relaxing the capacity of the first machine.C[j](S): the completion time of the jth job according to the sequence S for the1|rj|∑Cjinstance that is derived from the equivalence theorem of Gharbi et al. [18].C2,[j](S): the completion time of the jth job on M2 according to the sequence S for theF2|STsi|∑Cjinstance.We state the following result that is derived from the equivalence theorem of Gharbi et al. [18]:Corollary 1Let σ denote the sequence of jobs obtained by the SRPT rule on the preemptive version of the derived1|rj|∑Cjinstance. For any sequence S, we have:C[j](σ)⩽C2,[j](S)∀j∈{1,…,n}For any sequence S, we clearly haveC¯[j](S)⩽C2,[j](S)∀j∈{1,…,n}From Eqs. (8) and (10) of Gharbi et al. [18], we know thatC¯[j](S)=C[j](S)∀j∈{1,…,n}. Therefore, we getC[j](S)⩽C2,[j](S)∀j∈{1,…,n}The result follows since Chu [13] proved that, for any sequence S, we haveC[j](σ)⩽C[j](S)∀j∈{1,…,n}□By using the same arguments of Della Croce et al. [15], along with Corollary 1, a valid single machine-based lower bound for theF2|STsi|∑Cj, denoted hereafter byLBSM4, can be computed in the following way. LetC[j]1denote the completion time of the jth job on M1 according to the SPT rule after merging s1,jand p1,jfor all j∈{1,…,n}. Denote by U and V the sorted vectors of p2,jandC[j](σ)-C[j]1according to the nondecreasing order, respectively. The lower boundLBSM4is given by the following formula:LBSM4=LBSM1+∑j=1nmax(0,Uj-Vj)The computation ofLBSM4requires O(nlogn) time.Proposition 4LBSM4⩾LBSM1.Obvious.□We have U=(29,30,36,38,41) and V=(19,35,43,44,44). Therefore,∑j=1nmax(0,Uj-Vj)=10andLBSM4=839.The following example shows that no theoretical dominance relationship exists betweenLBSM2andLBSM4.Example 3Consider the 3-jobF2|STsi|∑Cjinstance that is defined in Table 6. We haveLBSM2=40andLBSM4=38(note thatLBSM2<LBSM4in Example 1).In this section, we introduce a Mixed Integer Linear Programming model for theF2|STsi|∑Cjproblem. For that purpose, let xjkdenote the decision variable that is equal to 1 if job j∈{1,…,n} is scheduled at position k∈{1,…,n}, and 0 otherwise. Let Cikdenote the completion time of the job scheduled at position k∈{1,…,n} on machine Mi(i∈{1,2}). TheF2|STsi|∑Cjcan be formulated as follows:(2)min∑k=1nC2k(3)∑k=1nxjk=1,∀j∈{1,…,n}(4)∑j=1nxjk=1,∀k∈{1,…,n}(5)Ci(k-1)+∑j=1n(sij+pij)xjk⩽Cik,∀k∈{2,…,n},∀i∈{1,2}(6)∑j=1n(s1j+p1j)xj1⩽C11(7)∑j=1n(s2j+p2j)xj2⩽C21(8)C1k+∑j=1nxjkp2j⩽C2k,∀k∈{1,…,n}(9)xjk∈{0,1},∀j,k∈{1,…,n}(10)Cik⩾0,∀i∈{1,2};∀k∈{1,…,n}Eq. (2) minimizes the total completion time on M2. Constraints (3) ensure that each job j∈{1,…,n} is assigned to exactly one position. Constraints (4) guarantee that each position k∈{1,…,n} is held by exactly one job. Constraints (5) take into consideration the completion time of the job’s predecessor on each machine. Exceptional jobs with no predecessors are handled by Constraints (6) and (7). Constraints (8) enforce each job to finish processing on M1 before being processed on M2. The nature of each decision variable is displayed by Constraints (9) and (10).In the following, we denote by LBLPthe optimal objective value that is obtained after solving the LP relaxation of the mathematical model (2)–(10).LR techniques have received a lot of attention in devising promising lower bounds for theF2||∑Cj. To the best of our knowledge, Van de Velde [30] was the first author who developed an LR-based lower bound for theF2||∑Cj. Since then, numerous variants of this technique have been proposed in the literature [14,20,21]. In this section, we extend Van de Velde’s lower bound to theF2|STsi|∑Cjand we show how to improve it by incorporating the waiting time concept that is described in Section 3.First, consider the followingF2|STsi|∑Cjformulation, where Cijdenotes the completion time of job j∈{1,…,n} on machine Mi(i∈{1,2}):(11)min∑j=1nC2j(12)C1j⩾s1j+p1j,j∈{1…n}(13)C2j⩾s2j+p2j,j∈{1…n}(14)C1h-p1h-s1h⩾C1j∨C1j-p1j-s1j⩾C1h,∀h≠j(15)C2h-p2h-s2h⩾C2j∨C2j-p2j-s2j⩾C2h,∀h≠j(16)C2j⩾C1j+p2j,j∈{1,…,n}(17)TheobtainedsequenceisapermutationoneConstraints (12) and (13) ensure that the first scheduled job cannot start processing before its setup time is finished. Constraints (14) (respectively (15)) verify that M1 (respectively M2) can only setup or process one job at a time. Constraints (16) guarantee that the processing of job j∈{1,…n} on M2 cannot start before its completion on M1.Now, assume that constraints (16) are relaxed and dualized via the vector of nonnegative Lagrange multipliers λ=(λ1,…,λn). Then, the following Lagrangian problem is obtained:(18)LR(λ)=min∑j=1n(λjC1j+(1-λj)C2j+λjp2j)Subjectto:(12)–(15),and(17)Using the same arguments of Van de Velde [30], LR(λ) can be obtained in O(nlogn) time by taking λj=l for all j∈{1,…,n} (with 0⩽l⩽1). Indeed, it suffices to schedule the jobs according to the nondecreasing order of l(s1,j+p1,j)+(1−l) (s2,j+p2,j). Therefore, a valid LR-based lower bound for theF2|STsi|∑CjisLBLR0=maxl∈LLR(l)whereLis a set of values that are arbitrarily selected from [0,1]. In our implementation, we adopted the same values as in [30] by settingL={0,0.05,0.10,…,0.95,1}.Interestingly, we can improve the value of LR(λ) by considering the waiting time δjthat is introduced in Section 3. Indeed, constraints (16) can be modified so that each job j∈{1,…,n} has to wait for a minimum amount of time δjafter its completion on M1 before starting its processing on M2. Therefore, constraints (16) can be substituted by the following valid ones:(19)C2j⩾C1j+δj+p2j,j∈{1,…,n}By relaxing and dualizing constraints (19), the following objective function for the Lagrangian problem will be obtained:(20)LRw(λ)=min∑j=1n(λjC1j+(1-λj)C2j+λjp2j)+∑j=1nλjδjSetting λj=l for all j∈{1,…n} yields LRw(l)=LR(l)+lΔ whereΔ=∑j=1nδjdenotes the total waiting time. Since Δi(i∈{1,…,4}) is a lower bound on Δ, then a valid lower bound forF2|STsi|∑CjisLBLRi=maxl∈LLR(l)+lΔi(i∈{1,…,4}). Clearly,LBLR1andLBLR2can be computed in O(nlogn) time, whereasLBLR3andLBLR4can be computed in O(n3) time.Proposition 5LBLRi⩾LBLR0∀i∈{1,…,4}.Obvious.□LBLRi⩾LBWTi∀i∈{1,…,4}.It suffices to observe that for l=1, we haveLR(l)+lΔi=LBWTi∀i∈{1,…,4}.□All the discussed lower bounds were coded in C and compiled with the Microsoft Visual C++.net 8.0. All the experiments were conducted on a personal computer with an Intel i7 3.4gigahertz processor and 16gigabyte RAM. The assignment problems were solved using the code of Goldberg and Kennedy [19] available at http://www.avglab.com/andrew/soft.html.In this section, all the experiments were carried on a test bed of 2400 instances which were randomly generated in a fashion similar to that adopted in [6]. More precisely, the processing times were randomly generated using the discrete uniform distribution on [1,100]. The setup times were uniformly drawn from [1,100K], where K∈{0.25,0.5,0.75,1}. The number of jobs n was taken equal to 10, 15, 20, 25, 30, 35, 50, 70, 100, 200, 300 and 500 jobs. For each combination of n and K, 50 instances were generated.Actually, one major aim of this section is to bring a more detailed picture of the performance of the proposed lower bounds. A pairwise comparison between lower bounds belonging to the waiting time-based, single machine-based and LR-based lower bounds is given in Tables 7–9, respectively. In these tables, we provide for each pair of lower bounds LBrow and LBcol that are displayed in some given row and column, respectively, the percentage of times LBcol improves LBrow.Clearly, the results depicted in Tables 7–9 strongly support the theoretical dominance results provided by Propositions 1–6. More importantly, this pairwise comparison brings a more detailed picture of the preliminary results that have been obtained in [18]. Indeed, the implementation of the best obtained bound of [18], namelyLBWT3, proves not to be worthwhile since it provides the same values asLBWT2in 2312 instances out of 2400. In particular, the two newly derived waiting time-based lower bounds with respect to [18], namelyLBWT4andLBWT5, exhibit a much better performance thanLBWT3. Indeed, althoughLBWT3has the “theoretical” advantage of being competitive withLBWT4andLBWT5, it outperforms them in only one and two instances, respectively, while being dominated byLBWT4in 2175 instances, and byLBWT5in 2395 instances. Clearly,LBWT5shows to be the most promising waiting time-based lower bound.On the other hand,LBSM3andLBSM4consistently outperform the single machine-based lower bounds of [18], namelyLBSM1andLBSM2. In particular,LBSM4provides the best results since it outperformsLBSM2andLBSM3in 72.92% and 70.04% of the instances, respectively.As for the LR-based lower bounds, it is clear that considering the waiting time in the Lagrangian problem yields consistently better results. Indeed, even embedding the simplest evaluation of δj(namelyδj1) improvesLBLR0in 87.83% of the instances.In order to have a better picture of the quality-to-effort ratio of each lower bound LB, we provide the following measures in Tables 10–12:•UBgap: the average deviation of LB with respect to an upper bound UB, where the deviation is defined by 100(UB−LB)/UB. The upper bound is equal to the minimum value that is obtained by the two best heuristics that have been recently developed by Ladhari et al. [25], namely H3LSII and MCGLS.LBgap: the average deviation of LB with respect to the best obtained lower bound LBmax, where the deviation is defined by 100(LBmax−LB)/LBmax.Time: the average required CPU time in milliseconds.From Tables 10–12, we observe that all of the displayed lower bounds require extremely short average computation time, never exceeding 0.03seconds. It should be highlighted that althoughLBSM3(theoretically) requires an exponential computation time, it only takes 0.2seconds, on average, for large-sized instances with 500 jobs. In fact, this behavior is due to the fact that all release dates of the obtained1|rj|∑Cjproblem are condensed at the beginning of the schedule. Consequently, after scheduling some jobs at the first positions, the remaining problem becomes polynomially solvable by the SPT rule. Not surprisingly,LBWT5has the best performance among the waiting time-based lower bounds, whileLBSM4shows the best behavior among the single machine-based lower bounds. Noticeably, the LR-based lower bounds offer the closest values to the upper bound along with very negligible computational effort, outperforming thus all the discussed lower bounds in terms of effectiveness/efficiency trade-off.Table 13provides a comparative picture between the LP-based lower bound LBLPand the best lower bound of each family, namelyLBWT5,LBSM4,LBLR2andLBLR4.We observe from Table 13 that LBLPyields the best values, being equal to LBmax for all instances with n⩾50. Unfortunately, the required computational effort of LBLPis by far larger than that of the other bounds. For instance, LBLPrequires an average computation time of about 358seconds for n=500, whileLBLR4takes only 0.014seconds. According to Table 13, the most promising lower bounds are the LR-based boundsLBLR2andLBLR4.The aim of this section is to better appraise the worth of implementing the most competitive lower bounds from each family (namelyLBWT5,LBSM4,LBLR2,LBLR4and LBLP) by analyzing the impact of their incorporation within an exact algorithm. For that purpose, we implemented five variants of a branch-and-bound algorithm, each of which corresponding to one selected lower bound. At each node of the search tree, one unscheduled job is added to the last position of an initial partial sequence. We adopted the depth-first node selection strategy. Moreover, for a better performance, the branch-and-bound algorithm includes the following features:•An upper bound provided by the two state-of-the-art heuristics, namely H3LSII and MCGLS [25], is computed at the root node.The dominance criteria of [6,11,26] are implemented in order to eliminate a maximum number of nodes.The search tree is consistently reduced by using the No-Good List pruning technique (see [23,28]).Furthermore, in order to benchmark the implemented exact procedures, the MILP that is defined by Eqs. (2)–(10) has been solved using CPLEX 11.1 software package. A reduced set of generated instances has been considered where the number of jobs n does not exceed 40 jobs, and only 10 instances are generated for each pair (n,K). A time limit equal to 3600seconds has been set for all the algorithms. In Table 14, we provide for each algorithm:•Solved: the number of solved instances within the time limit.Nodes: the average number of explored nodes.Time: the average CPU time (in seconds).It can be observed from Table 14 thatB&BSM4dominatesB&BWT5since it solves more instances while requiring less CPU time. Moreover, althoughLBSM4is much less effective than LBLP, its extremely short computation time seems to make it more worthwhile for relatively small instances. Indeed, both LP-based algorithms, namely B&BLPand MILP, are outperformed byB&BSM4in terms of average computation time for n⩽25. Beyond this size, MILP does clearly better than bothB&BSM4and B&BLP.The best performance of the branch-and-bound algorithms goes with the ones using the LR-based lower bounds. Indeed, both ofB&BLR2andB&BLR4exhibit the best behavior in terms of number of solved instances and average CPU time. For instance, forn=25,B&BLR2andB&BLR4solve all of the instances while requiring 13% and 17% of the CPU time required by MILP, respectively. Moreover, for the largest instances,B&BLR2andB&BLR4solve about 89% more instances than MILP does. A slight advantage is globally observed forB&BLR2. At this point, it should be emphasized that the computational effort ofLBLR2can be reduced to O(n) time at each non-root node. This can be done using a preprocessing procedure that stores the sorted list of jobs for each value ofl∈L.

@&#CONCLUSIONS@&#
