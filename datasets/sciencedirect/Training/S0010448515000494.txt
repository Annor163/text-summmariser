@&#MAIN-TITLE@&#
Extending CSG with projections: Towards formally certified geometric modeling

@&#HIGHLIGHTS@&#
Extension of classical CSG with the projection operator.Support for gradient computations.Topological property computation.Application of formal methods like interval analysis and proof assistants to CSG models.

@&#KEYPHRASES@&#
Constructive solid geometry,Projection,Homotopy equivalence,Formal methods,Constraint solving,Disjunctive normal form,

@&#ABSTRACT@&#
We extend traditional Constructive Solid Geometry (CSG) trees to support the projection operator. Existing algorithms in the literature prove various topological properties of CSG sets. Our extension readily allows these algorithms to work on a greater variety of sets, in particular parametric sets, which are extensively used in CAD/CAM systems. Constructive Solid Geometry allows for algebraic representation which makes it easy for certification tools to apply. A geometric primitive may be defined in terms of a characteristic function, which can be seen as the zero-set of a corresponding system along with inequality constraints. To handle projections, we exploit the Disjunctive Normal Form, since projection distributes over union. To handle intersections, we transform them into disjoint unions. Each point in the projected space is mapped to a contributing primitive in the original space. This way we are able to perform gradient computations on the boundary of the projected set through equivalent gradient computations in the original space. By traversing the final expression tree, we are able to automatically generate a set of equations and inequalities that express either the geometric solid or the conditions to be tested for computing various topological properties, such as homotopy equivalence. We conclude by presenting our prototype implementation and several examples.

@&#INTRODUCTION@&#
Constructive Solid Geometry was one of the first representation schemes in Computer Aided Design and Manufacturing (CAD/CAM)  [1–3]. However, dealing with complex scenes efficiently can be costly, since a rigorous mathematical description is obtained. As a result, other representations have been preferred such as Boundary Representations (Brep) or Selective Geometric Complex (SGC)  [4,5]. Modelers using the latter representations are hybrid and procedural, solids are no longer represented by systems of equations and inequalities. This lack of algebraic representation makes geometric models (and modeling software) hard to certify.On the other hand, CSG modeling is quite prevalent in the video game industry and computer graphics, with traditional game engines like Quake or Unreal  [6] making extensive use of it through binary space partitioning (BSP)  [7]. The latter engine has been used by hundreds of commercial titles  [8]. Moreover, it is the preferred method of some open-source and web-based modelers and there is recent work for speeding up CSG rendering through late polygonization  [9].In CSG, solids are represented as Boolean constructions via regularized11A regularized set is equal to the closure of its interior.set operators (union, intersection, difference). CSG representations are essentially binary expression trees where non-terminal nodes represent operators and terminal nodes typically represent primitive solids (like spheres, cones, cuboids). By traversing the expression tree, one may derive an algebraic representation of the solid, in the form of a system of equations and inequalities. The set of Boolean operations is quite restrictive for practical use.In this paper we extend the descriptive power of classical CSG by introducing the projection operator. This immediately allows us to deal with a greater variety of objects, i.e., objects defined as projections of other objects or parametric objects, including those defined by extrusions and sweeps. We do so by describing the projected objects as classical CSG expressions in the projected (lower-dimension) space. We show that our method can be used to extend existing algorithms in the literature that compute various properties of CSG sets like connectivity and topology  [10,11]. Moreover, since (extended) CSG derives an algebraic representation of the geometric models, it provides an elegant way for certification tools to apply.In hardware design, formal verification is a significant part of the design process [12]. The infamous Pentium bug and more recently, the TSX Haswell bug are only a few cases of misdesigns. We naturally raise the question: What about misdesigns in CAD?Current certification methods which are relevant to our applications include computer algebra methods, model checkers or proof assistants like PVS  [13] or Coq  [14] (Coq was recently used to check the proof of the four color theorem and the proof of the Feit–Thompson theorem for the classification of simple groups) and last but not least, interval analysis. The latter has been used to prove the Kepler conjecture by Hales  [15]. Under a more algebraic–geometric context, in CSG modeling, it suffices to prove the correctness of an underlying interval solver, instead of proving all the procedures currently used in today’s procedural modeling. See  [16] for an example where interval analysis is being used, relying on the properties of the tensorial Bernstein basis, to certify critical software that prevents collisions in air traffic.Other methods for certified computing are exact algebraic algorithms which can typically be combined with interval arithmetic for efficiency. See  [17] for an application regarding exact boundary computation on low degree sculptured solids and  [18] for accurate Brep generation from a CSG expression. Exact algebraic algorithms have also become popular in the Computational Geometry area  [19]. All these efforts aim to redefine modern computing, through efficient algebraic algorithms allowing us to step further from the inexact floating-point arithmetic of the 1980s. We believe our work is a small step in this direction, in particular towards formally certified geometric modeling.Almost no literature exists regarding projections in CSG. There is some previous work  [20] where it is mentioned that projections are non-trivial to handle and the author deals only with the projection of unions, since projections propagate over unions. In this paper we show how to deal with intersections, by transforming intersections into disjoint unions.A geometric primitive inRdis represented as a manifoldfin(d+1)-space(x1,…,xd,s)wheresis the characteristic variable of the manifold. This way, the geometric primitive consists of interior points where thes-coordinate is negative and of exterior points where thes-coordinate is positive. The cases=0corresponds (in general) to the boundary of the object. Thus the geometric primitive is essentially a solid inddimensions. Through relationf(x;s)=0,x∈Rd,sis implicitly defined by a characteristic function. For example, manifoldf(x,y,s)=x2+y2−1−s=0describes the unit disk as a paraboloid in 3-space. For every point(xˆ,yˆ)inside the unit disk, there existssˆ≤0such thatf(xˆ,yˆ,sˆ)=xˆ2+yˆ2−1−sˆ=0. See Fig. 1, for a contour graph with respect tos. Due to the regularized set condition, we consider inequalitiess≤0ors≥0instead of their strict counterparts. This modeling via the characteristic variable is in accordance with the classical representation as a finite Boolean combination of semi-algebraic or semi-analytic sets of the formF(x)≤0, whereF:Rd→R. However in our approach, the use of characteristic variables proves more convenient.We consider each node of the expression tree separately in order to compute a contributing primitive for each point in the set. That is in the case of projections, every point is associated with a point in the higher dimension space. The tree is traversed and a set of simple subsystems with inequality constraints is generated. We denote this set asF(x;s), wheresis the characteristic variable. Individual equations are still denoted asf(x;s).A geometric set is described in Disjunctive Normal Form (DNF) as a union of intersections of primitives (Section  2). Having the union operator at the top level has the advantage that projections distribute over unions (Section  3). Such canonical forms are also considered in other algorithms dealing with CSG representations [21].The paper is organized as follows. Section  2 presents the computation of the DNF for CSG operators. Section  3 deals with projections and parametric objects showing how to obtain a classical CSG expression in the lower-dimension space. Section  4 deals with gradient computations in the projected space, that allow us to compute topological properties. Section  5 presents several applications of our approach. Our reference implementation is presented in Section  6 and finally, in Section  7 we conclude with discussion and future extensions.A CSG formula can be converted to DNF by applying De Morgan’s laws and by distributing∩over∪as follows. LetA,Bbe geometric primitives. LetP,Qibe geometric sets defined by an expression tree.1.Aand¬Aare in DNF.A∪BandA∩Bare in DNF.¬(Q1∪Q2)=¬Q1∩¬Q2¬(Q1∩Q2)=¬Q1∪¬Q2P∩(Q1∪Q2∪⋯∪Qn)=(P∩Q1)∪(P∩Q2)∪⋯∪(P∩Qn).(Q1∩Q2)∩Q3=Q1∩Q2∩Q3(Q1∪Q2)∪Q3=Q1∪Q2∪Q3.The simplest operation is the complement. If for primitiveA:f(x;s)=0then¬A:f(x;−s)=0.Remark 1It is important that the complement is still represented by points from the manifold.Recall that we require the characteristic variable to be defined for all points inRd. As a counter-example, considerf(x,y,s)=x2+y2−1+s2=0. Points outside the unit disk, like(2,2)are not represented at all, sincef(2,2,s)=0cannot be satisfied fors∈R.LetP=A1∩⋯∩Anbe an intersection of primitives. We have to impose the constraint that pointxbelongs to allAi,i=1…nat the same time. This is achieved by setting the characteristic variablesof the set to bes=max(s1,…,sn)(cf.  Fig. 2). In order to representmax, we consider the union of all possible cases formax, i.e.,s=s1and∀j:s1≥sjors=s2and∀j:s2≥sj, and so on.Definition 1LetA,Bibe geometric sets andsAandsBitheir characteristic variables at pointx. We say thatAdominatesB1,…,Bnand denoteA|B1,…,Bnfor allx∈Rdwhere0≥sA≥sBi,i=1,…,n. In this caseAis a dominant set over eachBi.The notion of dominant set allows us to express intersections as unions. Note that operator|has lower precedence than the comma in the above notation. Consequences of the above definition are the following properties:(i)A∩B=A|B∪B|A(see Figs. 2 and 3)(A|B)|C=A|B,C=A|C,BA|(B|C)∪A|(C|B)=A|B,CA∩B∩C=(A|B,C)∪(B|C,A)∪(C|A,B)¬(A|B)=¬A∪¬B∪B|A.LetP=A1∪⋯∪Anbe a union of primitives. Since the formula is in DNF form, it suffices to consider each primitive separately, that isAi:fi(x;si),i=1…n. Note that a pointxmay not be uniquely associated with a primitive, since it may belong to the intersection of many primitives, i.e., the unions may not be disjoint. In our context (for topological property computation) this does not cause any problems. In the case where one requires disjoint unions, we can impose the uniqueness constraint by satisfying∀j:si≤sj, wheresjrefers to the characteristic variable of each object in the considered union. We choose the characteristic variable of the set to bemin(s1,…,sn)and this way we obtain similar properties as those in the case of intersections.The first non-trivial operation which concerns sets that cannot be described with CSG primitives is projection. LetA:F(x;s)wherex=(x1,…,xd), then the projection ofAwith respect toxiis denoted asπi(A). Letxi=(x1,…,xi−1,xi+1,…,xd).Thenπi(A)=Fπ(xi;s). Projections with respect to more than one dimension are denoted with commas, e.g.πi,j(A)=Fπ(xi,j;s)=πj(πi(A)).When the particular dimension is not of importance we may simply writeπ2(A)=π(π(A)). An interesting property of the projection is that it distributes over∪:π(Q1∪Q2∪⋯∪Qn)=π(Q1)∪π(Q2)∪⋯∪π(Qn).A naive way to deal with projections is to just “forget” coordinatexi. Doing so however, may result in a k-dimensional(k≥1)set of values forxiands, such thatF(x;s)is satisfied. This may slow down an interval solver (used to find a cover of the set for example) since an infinite set of solutions will have to be covered. We remedy this problem by introducing extra constraints so as to limit the range of the characteristic variable to a 0-dimensional set of values for every projected point.One way to consistently generate additional constraints is to choose the smallest value of the characteristic variable, among all possible values of coordinatesx1,…,xk(the coordinates being eliminated). That isπ1,…,k(A)is the set of pointsx1…k∈Rd−ksuch that∃x1,…,xkwherex∈Rd∩Aandsis minimal. This way we pick the point that lies “deepest” in the set to map to the projected set. Note that the use of the term “minimal” in the above is abusive. We are actually looking for a critical point (without loss of generality), i.e., the derivative of the characteristic function with respect tosvanishes. Thus, we do not have to perform extra computations to ensure that a critical point is actually a minimum. This is because we are interested in reducing the solution set to a hopefully 0-dimensional variety. It is perfectly acceptable for a point in the interior of the (projected) set to have not necessarily the smallest value of the characteristic variable, but some other (critical) value.Note that coordinatesx1,…,xkare no longer free variables, but take a value and become parameters. The minimization constraint can be written in terms of an optimization problem with constraints those exactly inFand the objective functions. Typical approach involves considering a Lagrangian (i.e., the Fritz John conditions). This is quite powerful a technique, but it has the disadvantage that it introduces extra equations and unknowns and our experiments have shown that after 6 or 7 unknowns solution times become impractical. Here we make use of differential calculus and wedge products. See  [24] for an introduction to wedge products and their applications in optimization problems. The wedge product vanishes if its operands are linearly dependent. Lagrange multipliers encapsulate linear dependence, therefore optimization problems may be efficiently transformed to calculus with wedge products.The leaves of the DNF expression tree contain primitives (or complements of primitives) or dominant sets. Consequently, to distribute projections, we need to handle projections of primitives and projections of dominant sets. For the latter, we will define an auxiliary construction, called join set which we will show that it contributes to the projection.Theorem 1Projection of Geometric PrimitiveLetA:f(x;s)be a geometric primitive. When projecting downkdimensions (eliminatingx1…xk), the projection can be specified by the following additional constraints:∂f∂x1=∂f∂x2=⋯=∂f∂xk=0.Proof0=ds∧df=ds∧(∂f∂x1dx1+⋯+∂f∂xkdxk+∂f∂xsdxs)=∂f∂x1ds∧dx1+⋯+∂f∂xkds∧dxk⟺∂f∂x1=⋯=∂f∂xk=0. An alternative proof is also possible using Lagrange multipliers.□Note that we assume that there exists some critical value in the interior of the set (we can guarantee that by construction), otherwise we would have to consider the boundary of the set.Definition 2LetA,Bbe geometric sets andsAandsBtheir characteristic variables at pointx. We define the join setA⋈Bas:A⋈B≔x∈Rd:sA=sB∧sA≤0.We define the precedence of the new operators to be:¬≻,≻|≻⋈≻∩≻∪. Observe the similarity with the join operator from relational algebra. Indeed, we join the two relationsA(x;sA)andB(x;sB)on their characteristic variable. Since the join operator introduces an equation, the dimension of the join set drops. See for example Fig. 2. The dotted line is the join of the two disks. Obviously, this line is no longer a solid in 2 dimensions.Definition 3We denote withJi1i2…in(f1,f2,…,fn)the followingn×nJacobian determinant:|∂f1∂xi1∂f1∂xi2⋯∂f1∂xin∂f2∂xi1∂f2∂xi2⋯∂f2∂xin⋮⋮⋱⋮∂fn∂xi1∂fn∂xi2⋯∂fn∂xin|Lemma 1Projection of Join SetsLetA:f0(x;s)andBi:fi(x;s),i=1…nbe geometric primitives. Then to describeπk(A⋈B1⋈⋯⋈Bn)we additionally consider  (i)  no constraints whenk≤n;  (ii)Ji0i1…in(f0,f1,…,fn)=0,1≤i0<i1<⋯<in≤k, whenk>n.ProofBasic idea: We shall exploit wedge products to capture the linear dependence in order to minimizes. Not surprisingly, these operations yield equivalently the Jacobian determinant.Assume without loss of generality that we are projecting with respect tox1,x2,…,xk. Considering the wedge product (to find the critical value ofs) we haveds∧df0∧df1∧df2∧⋯∧dfn=ds∧(∑i=1k∂f0∂xidxi+∂f0∂sds)∧(∑i=1k∂f1∂xidxi+∂f1∂sds)∧⋯∧(∑i=1k∂fn∂xidxi+∂fn∂sds)=ϵxi0xi1…xin(∑j=0n∂fj∂xijdxij)ds∧dxi0∧⋯∧dxin. Symbolϵis the permutation sign determined by the number of inversions in the considered permutation, which appears in the combinatorial definition of the determinant [25]. Now, ifk≤nthe wedge product is identically zero, because of somedxibeing equal, due to the pigeonhole principle (we have a wedge product ofn+1factors withkchoices for each factor, and we have thatdxi∧dxi=0). Otherwise, ifk>n, the wedge product expands to(kn+1)coefficients which should all vanish. These coefficients are preciselyJi0i1…in(f0,f1,…,fn),1≤i0<i1<⋯<in≤k.□Since no extra condition is required to describe a projection of a join with respect to a single variable, we have thatCorollary 1π(A⋈B)=A⋈B.Theorem 2Projection of Dominant Setπk(A|B)=πk(A)|B∪πk(A⋈B).ProofWithout loss of generality we assume that we project with respect tox1,…,xk. Since we have a constrained optimization problem, the critical value can be attained either when a constraint is active or not.πk(A|B)=x1…k∈Rd−k:∃x1,…,xk:(x∈Rd∩A)∧(sAis critical)∧(sA≥sB). This means thatsAtakes its critical value on the critical points ofπ(A)that happen to satisfysA≥sB, which is preciselyπk(A)|Bor somewhere wheresA=sB, which isπk(A⋈B). Alternative proofs are possible using wedge products or Lagrange multipliers [26].□Care has to be taken here that the setBin the expressionπk(A)|Blies in a lower dimension. That is we consider points inπk(A)that happen to lie inB. We could denoteBin this case asB/πk(A)but we avoid so due to abuse of notation. Let[Bm]1:ndenote sequenceBm,m=1…n. The following theorem comes as a generalization of Theorem 2.Theorem 3Projection of Dominant Sets, Generalizedπk(A|[Bm]1:n)=πk(A)|[Bm]1:n⋃i=1nπk(A⋈Bi)|[Bm]m≠i1:n⋃i,j=1i<jnπk(A⋈Bi⋈Bj)|[Bm]m≠i,m≠j1:n⋃⋯⋃=πk(A⋈B1⋈⋯⋈Bn).The way join sets were defined allows us to express the intersection of manifolds: a join is performed on the common variables, hence the common variable is implicitly eliminated. The idea is therefore to use joins to eliminate the parameters, as illustrated in Section  5. For exampleX:x−cos(t)=0,Y:y−sin(t)=0. NowX⋈Yexpresses points(x,y)that lie on the unit circle. This way, the join variabletis implicitly eliminated, because we project with respect tot, due to the join operator being applied. Lemma 1 shows that projection of joins may be trivial if the number of variables projected is less than the number of terms in the join expression. HereX⋈Yhas 2 terms therefore, the resulting subspace consists ofxandyonly.More generically, given a parametric solidGinRddefined byXi=fi(x;t1,…,td),i=1…d, we can represent this set as the join of the defining manifolds. That isG=X1⋈X2⋈⋯⋈Xd. Assume thattdis the characteristic variable. Now projection in the firstd−1dimensions eliminates the corresponding variables, and we have from Lemma 1 thatπd−1(X1⋈⋯⋈Xd)=X1⋈X2⋈⋯⋈Xd,sincek=d−1<d. See Section  5 for examples.We shall adapt the HIA algorithm (Homotopy via Interval type Analysis)  [10] to work with CSG sets extended with projection. The algorithm works computing a contractible cover of an initial setSand generating an abstract simplicial complex homotopy equivalent toS(Fig. 4left). The basic predicate of the algorithm is the star test, which provides a sufficient condition of contractability. For completeness, we recall the corresponding definitions.A pointvis a star for a subsetXof a Euclidean set ifXcontains all the line segments connecting any of its points andv(cf.  Fig. 4 right). We callXstar-shaped orv-star-shaped. IfXandYare twov-star-shaped sets, thenX∩YandX∪Yare alsov-star-shaped. A topological spaceXwhich is homotopy-equivalent to a point is contractible, therefore a star-shaped set is contractible. The following sufficient condition for contractability can be checked with interval analysis.Proposition 1Letf:Rn→Rbe aC1function,Dbe a convex set andS={x∈D⊂Rn|f(x)≤0}. If there existsvinSsuch that{x∈D|f(x)=0∧∇f(x)⋅(x−v)≤0}=0̸thenSis star-shaped.Observe that the equation∇f(x)⋅(x−v)=0expresses the tangent plane at the boundary pointx, since it is satisfied for all points perpendicular to the normal vector. Taking into account the characteristic function, the boundary of a primitive isf(x;0)=0, therefore the star condition is written as∇f(x;0)⋅(x−v)≤0. We setF(x)≔f(x;0). Now we may rewrite∇F(x)⋅(x−v)≤0.For primitivef(x;s), the boundary of the projection is given fromf(x;0)and∂f∂xi(x;0)=0. We defineF(x)=f(x;0). Now we haveF(x)=∂F∂xi(x)=0. The latter equation implies a relationxi=G(xi)and by substitution in the first one we obtainR(xi)=0(recall thatxidenotes vector(x1,x2,…,xi−1,xi+1,…,xn)). The process is similar when more variables are eliminated. When the functions are multivariate polynomials,R(xi)is precisely the resultant of the polynomial and its derivative with respect to variablexi(this particular resultant is a multiple of the discriminant).Lemma 2GivenF(x)=0and∂F∂xi=0,i=1…k. Then there exist functionsyiso thatxi=yi(x̃),i=1…kwherex∈Rdandx̃=(xk+1,xk+2,…,xd). Therefore we may writeF(x)=F(y1,y2,…,yk,xk+1,xk+2,…,xd).ProofBasic idea: We take a pair of the given equations that has not been considered so far, and eliminate a variable using the implicit function theorem.We haveF(x)=0andF′(x)=∂F∂x1(x)=0. Subtracting the two equations yields an implicit equation inx1,…,xd. For readability purposes we denote the comma separated listxi,xi+1,…,xjwithxi…j. From the implicit function theorem we havex1=g1(x2…d). Replacingx1inFyieldsF(g1(x2…d),x2…d)=0. We also obtain∂F∂xi(g1(x2…d),x2…d)=0,i=2…k. Now we apply the same process toF(g1(x2…d),x2…d)and∂F∂x2(g1(x2…d),x2…d)which will yieldF(g1(g2(x3…d),x3…d),g2(x3…d),x3…d)=0∂F∂x3(g1(g2(x3…d),x3…d),g2(x3…d),x3…d)=0and so on until we arrive atR(x̃)=F(g1(g2(⋯gk(x̃)⋯),…),g2(⋯),…,gk,x(k+1)…d)=0. Thereforeyi(x̃)=gi(gi+1(⋯gk(x̃)⋯),…),i=1…k.□Theorem 4LetR(x̃)=0be the boundary of the projection of primitivef(x;s)=0with respect tox1,x2,…,xk, wherex∈Rdandx̃=(xk+1,xk+2,…,xd). Then∇R(x̃)⋅(ũ−x̃)=∇F(x)⋅(u−x),whereF(x)=f(x;0).ProofSince we project with respect tox1,x2,…,xkwe have∂F∂xi=0,i=1…k. It follows from Lemma 2 that there exist functionsyiso thatxi=yi(x̃),i=1…k. We have thatR(x̃)=F(y1,y2,…,yk,xk+1,xk+2,…,xd). We trivially setxi=yi(x̃),i=(k+1)…dso that we may now writeR(x̃)=F(y(x̃)). Now from the chain rule we have∂R∂xi=∑j=1d∂F∂yj∂yj∂xi,i=(k+1)…d. We also have that∂F∂yj=0,j=1…k(by hypothesis due to projection, seeingFas a function inyinstead ofx) and that∂yj∂xiequals∂yj∂xi, whenj≤k, or 0, whenj>k∧j≠ior 1, whenj=i. This yields in the end∂R∂xi=∂F∂yi. Finally,∇R(x̃)⋅(ũ−x̃)=∑i=k+1d∂R∂xi(x̃)(ui−xi)+0=∑i=k+1d∂F∂yi(y)(ui−yi)+∑i=1k∂F∂yi(y)(ui−yi)=∇F(ỹ)⋅(u−y)≡∇F(x̃)⋅(u−x).□The geometric interpretation of Theorem 4 is that the tangent plane at a point of the boundary in the projected space, is equal to the projection of the tangent plane in the original space (Fig. 5). As such, in order to compute the star test on the projection of a primitive, it suffices to compute the star test in the original space (before projection). Therefore, no computation of the implicit relationRis required, and the test can be evaluated using only the known relationf. The following lemma comes as a generalization of Lemma 2.Lemma 3GivenFi(x)=0,i=0…n. Then there exist functionsyiso thatxi=yi(x̃),i=1…k≤nwherex∈Rdandx̃=(xk+1,xk+2,…,xd). Therefore we may writeR(x̃)=F(y1,y2,…,yk,xk+1,xk+2,…,xd).ProofThis is a generalization of Lemma 2. We haveF0(x)=F1(x)=0. Subtracting the two equations yields an implicit equationR0(x)=0. From the implicit function theorem we havex1=g1(x2…d). Now we replacex1inFi,i=0…nand getFi(g1(x2…d),x2…d)=0,i=0…n. Now we apply the same process toF0andF2and getR1(x2…d)=0,x2=g2(x3…d)andFi(g1(g2(x3…d),x3…d),g2(x3…d),x3…d)=0,i=0…n.Finally we obtainR(x̃)=Fi(g1(g2(⋯gk(x̃)⋯),…),g2(⋯),…,gk,xk+1,xk+2,…,xd)=0,i=0…n. Thereforeyi(x̃)=gi(gi+1(⋯gk(x̃)⋯),…),i=1…k.Note that in the endF0(x̃)≡F1(x̃)≡⋯≡Fk(x̃). Instead of0…kwe can apply the same elimination process to any(k+1)-subset of the(n+1)equations. We have also assumed generic enough functions, i.e., no two functions are identically the same.□Theorem 5LetR(x̃)=0be the boundary of the projection of primitiveπk(A⋈B1⋈⋯⋈Bn)with respect tox1,x2,…,xk, wherex∈Rd,x̃=(xk+1,xk+2,…,xd)andk≤n,d−k≥2. Letfi(x;s)be the characteristic functions andFi(x)=fi(x;0). Then the valueSof the star testS=∇R(x̃)⋅(ũ−x̃)is the(k+1)-th coordinate of the solution vectorwof system(J|[−1])w=a, whereJthe(k+1)×kJacobian matrix ofF0,F1,…,Fkwith respect to(x1,…,xk),(J|[−1])isJaugmented with column(−1,−1,…,−1)T,w=(w1,w2,…,wk,S)Tanda=(a0,a1,…,ak)Twithaj=−∑i=k+1d∂Fjxj(ui−xi),j=0…k.ProofFrom Lemma 3 we have thatR(x̃)=Fm(y1(x̃),y2(x̃),…,yk(x̃),xk+1,xk+2,…,xd),m=0…n. We trivially defineyi(x̃)≔xi,i=(k+1)…d,so that we may writeR(x̃)=Fm(y(x̃)). Applying the chain rule we obtain∂R∂xi=∑j=1d∂Fm∂yj∂yj∂xi. Now, as in the proof of Theorem 4,∂yj∂xiequals 0 whenj>k,j≠iand 1 whenj=i. Therefore∂R∂xi=∑j=1k∂Fm∂yj∂yj∂xi+∂Fm∂yi. We have thatS=∇R(x̃)⋅(ũ−x̃)⇔∑i=k+1d∂Fm∂yi(ui−xi)+∑i=k+1d∑j=1k∂Fm∂yj∂yj∂xi(ui−xi)−S=0,m=0…k. We setam≔−∑i=k+1d∂Fm∂yi(ui−yi)(recall thatxi=yiwheni>k) and rewrite (swapping sums):∑j=1k∂Fm∂yj∑i=k+1d∂yj∂xi(ui−xi)−S=am.Now we setwj≔∑i=k+1d∂yj∂xi(ui−xi),j=1…kandwk+1≔Swhich allows us to rewrite(J|[−1])w=a, whereJ, the(k+1)×kJacobian matrix ofF0,F1,…,Fkwith respect to(x1,…,xk)is augmented with column(−1,−1,…,−1)T.Note that the Jacobian can be defined using any(k+1)-subset of the(n+1)functions. We have also assumed thatd≥k+2, so that the dimension of the space after projection is at least 2 and the notion of a tangent hyperplane makes sense.□Lemma 4The geometric interpretation ofTheorem  5   is that the tangent plane at the projected space, is equal to the projection of the intersection of the tangent planes in the original space, fork+1primitives participating in the join (cf.Fig.  6).ProofA tangent plane in the original space is given as∇Fm(u−x)=0(withm=0…k). The intersection of allk+1tangent planes is an over-constrained system in the firstkdimensions. Equation in linemis∑i=1d∂Fm∂xi(ui−xi)=0⇔∑i=1k∂Fm∂xi(ui−xi)+∑i=k+1d∂Fm∂xi(ui−xi)=0⇔(1)∑i=1k∂Fm∂xi(ui−xi)=am,withamdefined as in Theorem 5.The tangent plane at the projected space is obtained when the star test (Theorem 5) evaluates to zero. ReplacingS=0in Theorem 5 we obtain the following system:(2)∑i=1k∂Fm∂xiwi=am,withm=0…k. It is obvious now that systems (1) and (2) are equivalent.□Now we are able to perform the star test onπ(A)|B. First, observe thatA⋈B⊆π(A), by definition. Moreoverπ(A)|Bappears in an expression paired withA⋈B, from Theorem 2. Leta=π(A)|B,b=π(B)|Aandc=π(A⋈B)=A⋈B. Now we haveπ(A∩B)=a∪b∪c=(a∖c)∪(b∖c)∪c. The boundary of each set in the union consists either of the boundary of the projection of a primitive(π(A),π(B))or of the boundary ofA⋈B. Moreover, we have that if two sets are star-shaped, then their intersection and union is star-shaped as well. Therefore Theorems 4 and 5 allow us to compute the gradient and as a result, the outcome of the star test.In this section we present some examples of our proposed approach dealing with projections. Note that union operators pose no problems, since they generate independent systems and we can typically handle hundreds of unions independently. Therefore we focus on projections of intersections which provide the biggest challenge. Currently our algorithm is not optimized for handling many levels of projection (note the combinatorial explosion in Section  5.2). However, as mentioned in Section  2.1, techniques like propagation of bounding boxes allow us to detect terms that do not contribute to the final result and quickly skip over them. Finally, our examples can be easily converted to any dimension, however, we restrict to 2D and 3D because they are easier to visualize and understand.Consider the ellipsoid from Fig. 5:f(x,y,z,s)=2x2+y2+3z2+23xz−1−s=0.Then from Theorem 1 we have for its projection onx,y:f(x,y,z,s)=0∧∂f∂z=6z+23x=0⇔x2+y2−1−s=0∧z=−33xwhich is effectively the unit disk.LetE1,E2,E3be three primitives inRd, we want to express the objectGdefined asG=π(E1∩E2)∩π(E1∩E3). The above expression will be transformed in DNF. We have that:G=[π(E1|E2)∪π(E2|E1)]∩[π(E1|E3)∪π(E3|E1)]=[π(E1|E2)∩π(E1|E3)]∪[π(E1|E2)∩π(E3|E1)]∪[π(E2|E1)∩π(E1|E3)]∪[π(E2|E1)∩π(E3|E1)]=[π(E1)|E2∪E1⋈E2]∩[π(E1)|E3∪E1⋈E3]∪⋯=[π(E1)|E2∩π(E1)|E3]∪⋯=[π(E1)|E2,π(E1)|E3)]∪[π(E1)|E3,π(E1)|E2]∪⋯=⋃i=118Si. That isGis equal to the union of 18 sets which in fact can be grouped into five sets depending on the contributing set beingπ(E1),π(E2),π(E3),E1⋈E2,E1⋈E3, as shown in Table 1. Note how this expansion of the formula is independent of the dimension. To visualize the above, let(x,y,z,r)denote a sphere centered at(x,y,z)with radiusr. IfE1=(0,0,0,1),E2=(12,0,12,32)andE3=(−32,0,32,32)thenπ(E1∩E2),π(E1∩E3)andπ(E1∩E2)∩π(E1∩E3)are shown in Figs. 7 and 8.E1⋈E2,π(E1)|E2andE1⋈E3are also visible.LetX(t,r)=x−(12+r)cost,Y(t,r)=y−(12+r)sint,R(r,s)=r(r−1)−s. EquationR(r,s)=0restricts the characteristic variables, so thats≤0whenr∈[0,1]. Thenπr,t(R⋈X⋈Y)is a 2D annulus in thexy-space, as shown in Fig. 9left. The parametric constructionπr(R⋈X⋈Y)in 3D (xyt-space), before being projected down with respect tot-axis, is an infinite spiral ribbon along thet-axis (Fig. 9 right). This example demonstrates an artificial example for the join operator, which however is not very practical, as we do not obtain a solid in every dimension (the ribbon is not a 3D solid — it unavoidably loses one dimension due to the fact that we have 2 joins).22The join operator is mainly used to describe the projection of dominant sets, in order to describe the projection of intersections.There is an alternative formulation that gives us a solid, both in 3 and 2 dimensions, which also allows us to compute the gradient applying Theorem 4. We setf(x,y,t;s)=(xcos(−t))2+(y−sin(−t))2−1/4−s. Now we have a cylindrical spiral in the 3D space(x,y,t)which projects down to an annulus in 2D (cf.  Fig. 10). Note that the minus sign inthas been used merely for illustration purposes (to force a clockwise drawing order).

@&#CONCLUSIONS@&#
