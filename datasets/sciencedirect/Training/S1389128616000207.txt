@&#MAIN-TITLE@&#
Design of an anonymity-preserving three-factor authenticated key exchange protocol for wireless sensor networks

@&#HIGHLIGHTS@&#
We observed that Farash et al.’s authentication protocol for WSN is susceptible to many security attacks.The protocol is also unable to preserve user anonymity.We designed an anonymity preserving authentication scheme for WSN.We analyze the security of the proposed protocol using AVISPA S/W.The proposed protocol is secure against active and passive attacks and more efficient than other protocols.

@&#KEYPHRASES@&#
Anonymity preserving,Key exchange protocol,Wireless sensor network,Internet of Things,Sensor node,Gateway node,

@&#ABSTRACT@&#
Recently, Farash et al. pointed out some security weaknesses of Turkanović et al.’s protocol, which they extended to enhance its security. However, we found some problems with Farash et al.’s protocol, such as a known session-specific temporary information attack, an off-line password-guessing attack using a stolen-smartcard, a new-smartcard-issue attack, and a user-impersonation attack. Additionally, their protocol cannot preserve user-anonymity, and the secret key of the gateway node is insecure. The main intention of this paper is to design an efficient and robust smartcard-based user authentication and session key agreement protocol for wireless sensor networks that use the Internet of Things. We analyze its security, proving that our protocol not only overcomes the weaknesses of Farash et al.’s protocol, but also preserves additional security attributes, such as the identity change and smartcard revocation phases. Moreover, the results of a simulation using AVISPA show that our protocol is secure against active and passive attacks. The security and performance of our work are also compared with a number of related protocols.

@&#INTRODUCTION@&#
A wireless sensor network (WSN) is composed of many low-cost and low-power sensor devices. These sensor nodes are deployed manually or randomly over any target region. The WSN has become an emergent and popular technology for potential applications in environmental monitoring, agriculture, health-care, disaster management, domestic setting, and surveillance systems [1]. Initially, WSNs were homogenous in nature; that is all sensor nodes were equivalent in terms of battery power, storage, computation power, and so on. However, with the rapid development of computer networks and the Internet, a heterogenous infrastructure of WSNs has also been observed. In this paper, we assume that the network model is heterogenous. In such an environment, all sensor nodes forward information to the nearby gateway node (GWN) and to the user, who resides outside the network and accesses the data for various purposes. As the communications network is insecure by nature, an attacker or adversary can intercept, insert, delete, and re-route these messages. Therefore, user authentication, message integrity, and privacy are important design factors for such kinds of unreliable networks [2,3]. For secure data communication over an unreliable channel, the entities require between them a shared session key agreement protocol in which mutual authentication as well as the user-anonymity property a equally important.As stated in [4], the Internet of Things (IoT) includes all the devices within the global network, accessible and interconnected through the Internet. The IoT can be understood as a multi-layered infrastructure that allows information from remote products, sensors, machines, assets, and other entities to be used anywhere, by any authorized party. It uses multiple communications technologies and a variety of embedded-intelligence technologies, including sensors and actuators. It can be applied in many domains, including health-care, WSN, smart cities, retail, and smart transport. Therefore, the IoT has nowadays become an important field of research. The IoT can also be applied in industry, which is termed the Industrial Internet of Things (IIoT). The IIoT enables new business models through secure, remote access to connected machines and other devices. In this paper, the architecture of the presented WSN is based on the concept of the IoT in which all sensor nodes and the GWN are interconnected through the Internet. Note that WSN covers a wide range of application fields and thus plays a vital role in the IoT. In such an environment, a user can access any sensor node, that is part of a WSN through a GWN.In two-factor authentication protocols based on a password and a smartcard, users favour low-entropy passwords selected from a small dictionary. As a result, an adversary performs an off-line procedure to guess the user’s password within polynomial time. Therefore, two-factor authentication systems cannot provide high security due to this off-line password-guessing attack. Three-factor authentication protocols based on a password, smartcard, and biometrics (e.g., fingerprint, iris, retina) have thus gained popularity. In a three-factor authentication protocol, the user enjoys higher security than a two-factor protocol because (i) biometric data cannot be forgotten, and (ii) biometric data cannot be guessed easily. In order to tackle the password-guessing attack, Huang et al. [5] proposed a framework to upgrade two-factor authentication systems to three-factor systems. In this paper, we have adopted the existing bio-hashing operation [6,7] in our protocol to generate a cancellable biometric template. The bio-hashing operation, as a non-invertible function, can generate a protected biometric template. Numerous authentication protocols [8,9] have utilized a protected biometric template to identify the genuine user.In WSNs, sensor nodes that are deployed in a hostile environment are powered by small batteries, and recharge or replacement of these batteries may not always be possible. Although it is challenging to prolong network service, energy conservation specifically of the sensor nodes of WSNs is mandatory. Sensor nodes include a transceiver, external memory, micro-controller, power source, and one or more sensor(s), with the transceiver responsible for receiving and forwarding messages. As mentioned in [10], the energy consumed by transmitting or receiving, respectively, a message of l-bits over or from a distance (d) are measured by Eqs. (1) and (2). Here, the free-space model is used if d is less than a threshold d0; otherwise, a multi-path model is used.(1)ET(l,d)={lEelec+lɛfsd2ford<d0lEelec+lɛmpd4ford≥d0(2)ER(l)=lEelecwhere Eelecis the energy required by the electronic circuit, and εfsand εmpare the energy required by the amplifier in free space and the multi-path model, respectively.Remark 1The above discussion shows that the communication cost of the sensor node depends on the transmitted and received messages, and is also directly proportional to the distance between the sensor node and the target entity. Compared to the sensor device, the GWN has huge energy resources; thus, to reduce power consumption, the distance between the GWN and the sensor nodes should be as small as possible for IoT-based WSNs.The network model proposed in [4,11] is presented in Fig. 1and includes three entities: the GWN, the user (Ui), and the sensor node (Sj). Note that the main task of Sjis to sense real-time data, which is accessed by Uiafter mutual authentication. In the model presented in Fig. 1, Uicollects the sensed data from Sjdirectly. For user authentication in IoT-based WSNs, the GWN provides a registration facility for Sj. In Section 1.1, we analyzed that the power consumption of Sjfor receiving and transmitting data is directly proportional to the distance between Sjand Ui. Since Uiaccesses the data from outside of the network, the distance between Sjand Uiwould be high. Therefore, the network model presented in Fig. 1 is not appropriate for IoT-based WSNs.To upgrade the functionality and security of WSNs, many user authentication and key agreement protocols [12–15] have been proposed in the literature. Now, we will describe briefly the security loopholes of the authentication protocols proposed for IoT-based WSNs. In 2004, Watro et al. [12] proposed a user authentication protocol using RSA[16]. Later, it was demonstrated that this protocol cannot withstand the man-in-the middle attack. Thereafter, Xu et al. [13] and Song [14] proposed two different authentication protocols based on RSA. However, the protocols in [13,14] required high memory overhead because all the public keys of the sensor nodes and users were stored. To overcome this problem, Yeh et al. [15] offered an authentication protocol based on the elliptic curve cryptography. In 2006, Wong et al. [17] proposed another authentication protocol using a hash function. The following year, Tseng et al. [18] proposed a dynamic-identity-based authentication protocol. However, Vaidya et al. [19] claimed that the protocols in [17,18] suffer from the forgery attacks, replay attacks and man-in-the-middle attacks. They further contributed an improved protocol. Afterwards, Das [20] proposed an authentication protocol against the protocol designed in [17].In 2010, Khan and Alghathbar [21] described how Das’s protocol [20] is susceptible to a gateway-node-bypassing attack and a privileged-insider attack. In the same year, He et al. [22] also proposed an improvement of Das’s protocol. Later, Vaidya et al. [23] again demonstrated that the protocols in [20,21] suffer from the privileged-insider and user-impersonation attacks, presenting an extended two-factor user authentication protocol as a remedy. Fan et al. [24] introduced a user authentication protocol for two-tiered WSNs[25]. Yuan et al. [26] claimed that the protocol in [12] is insecure against forgery attack, contributing a biometric-based, three-factor user authentication protocol for WSNs. In 2011, Kumar and Lee [27] proved that He at al.’s protocol [22] is vulnerable to an information-leakage attack and is unable to preserve the user-anonymity and mutual authentication properties. They further demonstrated that the protocol in [21] cannot achieve the mutual authentication property. Das et al. [28] and Xue et al. [29] proposed two user authentication protocols. Later, Xu and Wang [30] and, Turkanović and Hölbl [31] claimed that the protocol in [28] is imperfect, proposing two enhanced protocols. Li et al. [32], and Turkanović and Hölbl [31] also presented different vulnerabilities of Xue et al.’s protocol [29] and provided an improved protocol. Unfortunately, He et al. [33] improved the security of the protocol in [29]. Wang and Wang [34] addressed the security loopholes of the protocol in [28] and then put forward another improved protocol. Further, they provided a solution against the sensor node capture attack.In 2014, Turkanović et al. [4] proposed a hash-function-based, lightweight user authentication protocol for heterogenous, ad-hoc WSNs using the concept of the IoT. The main aim of their protocol was to be energy-efficient and anonymous with high security and low computational cost. However, Ruhul and Biswas [35], and Farash et al. [11] claimed that this protocol is not suitable for practical applications because of its security weaknesses. Additionally, Ruhul and Biswas proposed a secure multi-gateway-based user authentication protocol using a smartcard.Recently, Farash et al. [11] proposed an improved protocol. We have examined Farash et al.’s protocol [11] and found that it cannot withstand the user-anonymity problem, stolen-smartcard attack, off-line password-guessing attack, new-smartcard-issue attack, user-impersonation attack and known session-specific temporary information attack. We have also identified that the network architecture used in [4,11] is inefficient for those environments where energy is a big issue. Therefore, we have modified the architecture (see Fig. 6), designing a secure user authentication protocol using a password, a smartcard and biometrics. The AVISPA software simulation and informal security analysis strongly suggest that our protocol can withstand all the relevant security attacks and meet relevant requirements. In addition, the proposed protocol contributes post-deployment, identity change, password change, and smartcard revocation phases.The rest of this paper is arranged as follows. We review Farash et al.’s protocol in Section 2, explaining its security weaknesses in Section 3. We propose an improved protocol in Section 4. The results of the AVISPA software simulation of our protocol are given in Section 5, and rigorous security analysis appears in Section 6. We evaluate the performance of our protocol against other protocols, as presented in Section 7. Finally, we conclude the paper in Section 8.In this section, we briefly review Farash et al.’s protocol, which includes the following phases: pre-deployment, registration for the user and the sensor node, login, authentication, password change, and dynamic node addition. The list of notations used in this paper is given in Table 1.This setup phase is executed in off-line mode by the system administrator (SA). In this phase, the GWN generates and stores a shared passwordXGWN−Sj(1 ≤ j ≤ m) for each Sj, where m represents the number of sensor nodes within the network.Remark 2The shared passwordXGWN−Sjis used during sensor node registration. In Farash et al.’s protocol,XGWN−Sjis deleted from the memory of the GWN, whereas Turkanović et al.’s protocol stores it permanently in the GWN.After deploying the sensor nodes, two registration phases are required, as described below.This phase is outlined in Fig. 2.Remark 3We have observed that GWN does not store the hash function h(·) on the smartcard. The function h(·) must be included; otherwise, computation of ⟨ei, fi, gi⟩ is impossible.This phase is outlined in Fig. 3.This phase is outlined in Fig. 4.This phase is outlined in Fig. 4.This phase is outlined in Fig. 5.In this section, we present the security vulnerabilities of Farash et al.’s protocol. The following are the widely accepted, valid assumptions used in analyzing the security of authentication protocols.Assumption 1AdversaryAhas the capability to retrieve smartcard information using the power-consumption monitoring methods explained in [36,37].All messages generated by the protocol during the protocol execution are transmitted through unreliable communications channels such as the Internet. Therefore,Acan intercept, delete, modify, re-route, or re-send the transmitted message over unreliable networks. It is worth noting thatAcannot intercept any information from reliable networks.Aknows how to execute the proposed protocol, which means the protocol is public. In addition,Acan act as a legitimate user/client (or vice-versa).In a password-based user authentication protocol, it is assumed that registered users always use dictionary words as passwords and identities. It is worth to noting thatAcannot guess the identity and password within polynomial time. LetAi=h(IDi∥PWi)be known toA: then it is infeasible to verify the guessed identity and password using Aiin polynomial time.In cryptography, it is assumed that the secret key and random nonce are sufficiently large (high entropy parameter) thatAcannot guess this information in polynomial time.Let there be an equationAi=Bi⊕Ci. Only the value of Aiis known toA. It is hard forAto find Bior Ciin polynomial time.Let the length of the identity or password be n characters. The probability of guessing n characters is approximately126n[38].In Farash et al.’s protocol [11], an authorized user Uican impersonate GWN after extracting the secret key XGWN. Assume that Uiretrieves the information ⟨ei, fi, gi, ri⟩ from his or her smartcard (see Assumption 1), whereei=h(MPi∥IDi),di=h(IDi∥XGWN),gi=h(XGWN)⊕h(MPi∥di),andfi=di⊕h(MPi∥ei). Then, UicomputesMPi=h(ri∥PWi)anddi=fi⊕h(MPi∥ei). Based on ⟨gi, MPi di⟩, Uicomputesh(XGWN)=gi⊕h(MPi∥di). Now, Uican impersonate GWN since the secret key XGWNis now known to him or her.User-anonymity states that adversaryAshould not be able to detect by any means a user’s identity from the login and authentication messages. Farash et al. claim that IDiof Uiis protected fromA. However, we have observed that Farash et al.’s protocol does not protect user-anonymity, as presented below:(1)In Section 3.1, we described how h(XGWN) can be known to an authorized user Uj, who acts as an adversaryA.Ujintercepts Ui’s login messageMSG1=〈M1,M2, M3, T1⟩ during protocol execution, whereM1=IDi′⊕h(h(XGWN)∥T1),M2=Ki⊕h(di∥T1),andM3=h(M1∥M2∥Ki∥T1).UjcomputesIDi′=M1⊕h(h(XGWN)∥T1),which is the original identity of Ui.Thus, Uj(A) can compute Ui’s identity and easily break the user-anonymity property of Farash et al.’s protocol.In this attack,Aneeds a smartcard of a legal user Ui, obtained either by stealing or by some other means. After that,Aextracts the information ⟨ei, fi, gi, ri⟩ from the smartcard (see Assumption 1), whereei=h(MPi∥IDi),di=h(IDi∥XGWN),gi=h(XGWN)⊕h(MPi∥di),andfi=di⊕h(MPi∥ei). Later,Alaunches the following attacks against Farash et al.’s protocol.In Section 3.2, we illustrated that an authorized but malicious user Uj(A) can extract identity IDiof another legal user Ui. Then,Acan launch an off-line password-guessing attack to learn the password PWiof Ui. We describe the off-line password-guessing attack procedure in Algorithm 1.This is a very serious attack on any smartcard-based authentication protocol in whichAattempts to prepare a new smartcard without altering the identity IDiof Uior GWN’s information. We have noticed that Farash et al.’s protocol suffers from such a type of attack if the smartcard of Uihas been stolen, as presented below:(1)In Sections 3.1 and 3.3.1, we explained thatAcan derive the IDiand PWiof Ui.Based on IDiand PWi,AcomputesMPi=h(ri∥PWi),ei=h(MPi∥IDi),anddia=di=fi⊕h(MPi∥ei).Aguesses a passwordPWiaand computesMPia=h(ri∥PWia),eia=h(MPia∥IDi),ga=h(XGWN)⊕h(MPia∥dia),andfia=dia⊕h(MPia∥eia).Aselects a new smartcard and embeds〈eia,gia,fia,ri⟩ its memory.After preparing the new smartcard,Acan easily login into the system on behalf of Uiusing IDiandPWia. Thus,Adoes launch the new-smartcard-issue attack.In this attack,Aattempts to generate GWN’s login message after intercepting the login message during protocol execution. The execution of the user-impersonation attack byAis given below.(1)During protocol execution,AinterceptsMSG1=〈M1,M2, M3, T1⟩, whereM1=IDi′⊕h(h(XGWN)∥T1),M2=Ki⊕h(di∥T1),andM3=h(M1∥M2∥Ki∥T1). Note that Kiand T1 are the random number and timestamp, respectively.Agenerates a new random numberKiaand the system’s fresh timestampT1a,computingM1=IDi⊕h(h(XGWN)∥T1a),M2=Kia⊕h(di∥T1),andM3=h(M1∥M2∥Kia∥T1a).Atransmits ⟨M1, M2, M3,T1a〉to Sjthrough an unreliable channel.The message ⟨M1, M2, M3,T1a〉can be verified as valid. Thus,Acan launch a user-impersonation attack.Resilience against the known-session specific temporary information attack requires that the attacker cannot compute a session key even if short-term confidential information, such as the session’s random numbers, be known. Farash et al.’s protocol computes a session keySK=h(Ki⊕Kj)between Uiand Sj, where Kiand Kjare the random nonces generated by Uiand Sj, respectively. Since the session key is reliant only on Kiand Kj, the computation of SK byAis not hard with the disclosure of these random numbers. Therefore, the protocol in [11] cannot withstand this attack.As discussed in Section 1.2, the network model [4,11] given in Fig. 1 is inappropriate for the IoT. Thus, we present a modified model in Fig. 6, which solves the issues as discussed in Section 1.2. Based on our network model, we present an efficient remote-user authentication and session key agreement protocol for WSNs using the concept of IoT.In our protocol, we use a bio-hashing function. As discussed in [39], that bio-hashing function can generate a cancellable fingerprint (i.e., protected) template. However, if a noisy biometricfngi*and accurate biometric fngiof the same user Uiare of the same class,fngi*is roughly equivalent to fngi. Note that the biometric features of different samples of the same class are not exactly identical, so an exactly accurate biometric key needs to be extracted before using the hash function.For this purpose, a biometric key generation and extraction function BK() is required that can produce the same biometric key from different biometric templates of the same class. A description and concrete explanation of the function BK() can be found in [40]. Our protocol comprises system setup, sensor node registration, user registration, login, authentication and session key agreement, password change, and smartcard revocation phases all of which are presented below.This phase is executed by the system administrator (SA) in off-line mode. This phase is described below.Step 1.SA chooses the identity IDjof Sj(1 ≤ j ≤ m).SA selects a master secret key XGWN, which is only known to GWN, and then computesXj=h(IDj∥XGWN),which is the secret key of Sj(1 ≤ j ≤ m), different for each sensor node.SA selects a random number Rshrd, which is shared between GWN and Sj. Finally, SA embeds ⟨IDj, Xj, Rshrd⟩ into the tamper-proof memory of Sjin a secure manner. We assume that an adversaryAcannot extract ⟨IDj, Xj, Rshrd⟩ from the memory of Sjeven if it is compromised.After system setup, SA deploys all Sjand a single GWN on the target field to form a sensor network. This phase is described in Fig. 7. For the purpose of registration, each Sjexecutes the following with GWN:Step 1.SjcomputesS1=IDj⊕h(Rshrd∥Ts1)andS2=h(IDj∥Xj∥Rshrd∥Ts1),and then sends ⟨S1, S2, Ts1⟩ to GWN through an unreliable network, where Ts1 is the fresh timestamp.GWN verifies whether|Tgwn−Ts1|≤ΔTholds. If it is incorrect, GWN rejects Sj, otherwise computingIDj′=S1⊕h(Rshrd∥Ts1),Xj′=h(IDj′∥XGWN),andS2′=h(IDj′∥Xj′∥Rshrd∥Ts1)and checking whetherS2′=S2holds. If it is incorrect, GWN rejects Sj; otherwise, GWN authenticates Sjand stores IDjinto the database.GWN sends a confirmation message to Sjafter successful completion of the registration phase. After getting the confirmation message, Sjdeletes Rshrdfrom memory.This phase is described in Fig. 8 and below:Step 1.Uichooses an identity IDiand sends it along with personal credentials to SA through a reliable channel [4,35]. Note that personal credentials help in re-issuing new smartcard for any Uiwhose smartcard is either stolen or damaged by some means.SA checks for the existence of IDiin the database. If it exists, SA requests a fresh identity; otherwise, SA computesdi=h(IDi∥XGWN)andLi=h(SCNi∥XGWN),then embedding ⟨di, Li, SCNi, BK()⟩ in the smartcard and delivering it to Uithrough a reliable channel. Here, BK() denotes the biometric key generation and extraction function. Note that SA maintains a table storing IDiand the personal credentials of each Ui.Uiinserts the smartcard into a card reader. Uiinputs ⟨IDi, PWi⟩ to the smartcard and fingerprint fngiat the sensor device. The smartcard computesBi=BK(H(fngi)),ei=h(IDi∥PWi∥Bi),fi=di⊕h(IDi∥PWi),andgi=Li⊕h(PWi⊕IDi),where H(·) is the bio-hashing operation [6,7]. Finally, the smartcard stores ⟨Bi, ei, fi, gi, SCNi, BK()⟩ into its memory and deletes ⟨di, Li⟩.In Turkanović et al.’s and Farash et al.’s protocols, we have observed that GWN issued a smartcard for Ui. However, smartcards are physical devices, so how’s GWN might preparing and delivering a smartcard to Uiwithout involving a human seems impractical. To solve this issue in our protocol, we perform the user registration phase with SA, not GWN. SA prepares a smartcard and delivers it to Ui.Whenever any registered user Uiwishes to access sensor information, he or she has to execute this phase to compute the login message, sending it to GWN through an unreliable channel. The description of this phase is given in Fig. 9and below.Step 1.Uiinserts the smartcard and enters the fingerprint fngiat the sensor device. Then, the smartcard computesBi*=BK(H(fngi))and checks whetherBi*is equal to Bi. If the verification is incorrect, smartcard denies Ui’s login request; otherwise, it requests his or her identity and password. Then Uiinputs IDiand PWito the smartcard, and it computesei*=h(IDi∥PWi∥Bi). The smartcard rejects Ui’s login request ifei*does not match ei; otherwise,IDi*=IDiandPWi*=PWihold.After verifying the legitimacy of Ui, the smartcard computesdi*=fi⊕h(IDi*∥PWi*),andLi*=gi⊕h(PWi*⊕IDi*). The smartcard also generates a random number Kiand a timestamp T1 and computesM1=IDi*⊕h(Li*∥T1),M2=Ki⊕h(di*∥T1),M3=h(di*∥Ki∥T1)andSCTi=SCNi⊕h(T1). The smartcard then asks Uifor the identity of a sensor node. Uichooses a sensor node Sjand inserts its identity IDjto the smartcard.The smartcard computesEIDj=IDj⊕h(IDi∥Ki∥T1)and sendsMSG1=〈M1,M2, M3, T1, SCTi, EIDj⟩ to GWN through an unreliable channel.In this phase, mutual authentication and a session key negotiation is executed between Ui, GWN, and Sj. The description of this phase is given in Fig. 9 and below.Step 1.After receiving the login message MSG1 from Ui, GWN computesSCNi=SCTi⊕h(T1),Li′=h(SCNi∥XGWN),IDi′=M1⊕h(Li′∥T1),di′=h(IDi′∥XGWN),Ki′=M2⊕h(di′∥T1),andM3′=h(di′∥Ki′∥T1). GWN rejects the current session ifM3′is not equal to M3; otherwise, it computesM4=h(IDi∥di′∥T1)and then forwardsMSG2=〈M4〉to Uithrough an unreliable channel.UicomputesM4*=h(IDi∥di*∥T1). Uiaborts the session ifM4*≠M4,otherwise computingM5=h(di*∥IDi∥Ki∥T1)and sendingMSG3=〈M5〉to GWN through an unreliable channel.GWN computesM5′=h(di′∥IDi′∥Ki′∥T1)and aborts the connection ifM5′≠M5; otherwise it believes that an attacker is not attempting to launch a replay attack.In Steps 2 and 3, the protocol does not utilize timestamp verification to resist a replay attack. In order to resist a replay attack between Uiand GWN, we execute Steps 2 and 3 in our authentication phase.In order to prove Ui’s and GWN’s legitimacy to Sj, GWN computesIDj′=EIDj⊕h(IDi∥Ki∥T1),Xj′=h(IDj′∥XGWN),M6=h(IDi′∥IDj′∥IDGWN∥Xj′∥Ki′∥T2),M7=IDi′⊕h(IDGWN∥Xj′∥T2),M8=Ki⊕h(IDi′∥Xj′)and then forwardsMSG4=〈IDGWN,M6, M7, M8, T2⟩ to Sjthrough an unreliable channel.Sjchecks whether|T3−T2|≤ΔTholds, where T3 is the current timestamp. If it is incorrect, Sjimmediately rejects the connection; otherwise, it computesIDi**=M7⊕h(IDGWN∥Xj∥T2),Ki**=M8⊕h(IDi**∥Xj),andM6**=h(IDi**∥IDj∥IDGWN∥Xj∥Ki**∥T2). Sjaborts the connection ifM6**≠M6; otherwise, it believes that Uiand GWN are authentic entities. Furthermore, SjcomputesSKj=h(IDi**∥IDj∥Ki**∥Kj),M9=h(SKj∥Xj∥Kj∥T3),andM10=Ki**⊕Kj,where Kjis the random number generated by Sj. Finally, SjforwardsMSG5=〈M9,M10, T3⟩ to GWN through an unreliable channel.GWN checks whether|T4−T3|≤ΔTholds, where T4 is the current timestamp. If it is incorrect, GWN aborts the session, otherwise computingKj′=M10⊕Ki,SKGWN=h(IDi′∥IDj∥Ki′∥Kj′),andM9′=h(SKGWN∥Xj′∥Kj′∥T3). GWN rejects the session ifM9′≠M9,otherwise computingM11=h(SKGWN∥IDi′∥di∥Kj′). Finally, GWN forwardsMSG6=〈M11,M10〉to Uithrough an unreliable channel.UicomputesKj*=M10⊕Ki,SKi=h(IDi∥IDj∥Ki∥Kj*)andM11*=h(SKi∥IDi∥di∥Kj),aborting the session ifM11*≠M11. Otherwise, Uibelieves that GWN and Sjare authentic. Note that the protocol establishes a session keySKi=SKj=SKGWNbetween Ui, Sj, and GWN after performing mutual authentication.Our protocol negotiates a session keySKi=SKj=SKGWNbetween Ui, Sj, and GWN, the main objective of which is to maintain a session key for secure, real-time communication over an unreliable channel.The main aim of this phase is to deploy sensor nodes after forming the network. As a practical issue, one or more sensor node(s) may become damaged, requiring replacement. Assume that a damaged node Skneeds to be replaced by a new sensor node Slin the target field. To do so, SA chooses the identity IDlof Sl, computesXl=h(IDl∥XGWN),and embeds ⟨IDl, Xl, Rshrd⟩ into the memory of Sl. Now, SA deploys Slin the target region. After deployment, Slexecutes the sensor node registration phase presented in Section 4.2.The main intention of this phase is to securely update the identity of a registered user. This phase requires the assistance of GWN. Uiinserts his or her smartcard into the card reader and executes Step 1 of the login phase (Section 4.4) to verify Ui’s legitimacy. Now, the smartcard and GWN compute the following operations:Step 1.Uiinputs a new identityIDinew,and then the smartcard computesdi*=fi⊕h(IDi∥PWi),Li*=gi⊕h(PWi⊕IDi),Zi=h(di*∥IDi∥Tid),Wi=IDi⊕h(Li∥Tid),SCTi=SCNi⊕h(Tid),andDDi=IDinew⊕h(Li∥di∥Tid). The smartcard then sends ⟨Zi, Wi, DDi, SCTi, Tid⟩ to GWN through an unreliable channel.GWN computesSCNi=SCTi⊕h(Tid),Li′=h(SCNi∥XGWN),IDi′=Wi⊕h(Li′∥Tid),di′=di′=h(IDi′∥XGWN),andZi′=h(di′∥IDi′∥Tid),and then checks whetherZi′=Ziholds. If it holds, GWN believes that the message sent by Uiis correct. GWN then computesIDinew=DDi⊕h(Li′∥di′∥Tid),di**=h(IDinew∥XGWN),Yi=di**⊕di′,andZZi=h(di**∥Zi′)and sends ⟨ZZi, Yi⟩ to the smartcard through an unreliable channel, and updatingIDinewin the database.The smartcard computesdi**=Yi⊕di′,andZZi*=h(di**∥Zi)and checks whetherZZi*=ZZiholds. If it holds, the smartcard computeseinew=h(IDinew∥PWi∥Bi),finew=di**⊕h(IDinew∥PWi),andginew=Li⊕h(PWi⊕IDinew). Finally, the smartcard replaces the old information ⟨ei, fi, gi⟩ with the new information〈einew,finew,ginew〉,which is stored on the smartcard.For security reasons, an authorized user Uiwill want to update the password PWi. Any password-based authentication protocol must include a password change facility. In order to reduce complexity and network congestion, the password change must be performed without any help from SA or GWN. This phase is described below:Step 1.Uiinserts his or her smartcard into the card reader and executes Step 1 of the login phase (see Section 4.4) to verify the fingerprint, password, and identity.The smartcard prompts Uifor a new password,PWinew. Uithen entersPWinew,and the smartcard computeseinew=h(IDi∥PWinew∥Bi),di′=fi⊕h(IDi∥PWi),finew=dinew⊕h(IDi∥PWinew),Li′=gi⊕h(PWi⊕IDi),andginew=Li′⊕h(PWinew⊕IDi).The smartcard replaces the old information ⟨ei, gi, fi⟩ with the new information〈einew,ginew,finew〉in the memory of smartcard, keeping the rest of the parameters unchanged.As a practical matter the smartcard of a registered user may be stolen or lost. In our protocol, Uican get a new smartcard by executing the following steps:Step 1.Uisent his or her identity IDialong with personal credential to SA using a reliable channel. SA first verifies Ui’s credential and, if it is correct, computesdinew=h(IDi∥XGWN)andLinew=h(SCNinew∥XGWN),whereSCNinewis the unique number of the new smartcard . Then, SA stores〈dinew,Linew,SCNinew,BK()⟩ in the new smartcard’s memory and sends the card securely to Ui. Then, SA updates the database withSCNinew.Uiinserts the smartcard into the card reader. Uithen keys IDiand PWiinto the smartcard and provides fingerprint fngiat the sensor device. The smartcard then computesBinew=BK(H(fngi)),einew=h(IDi∥PWi∥Binew),finew=dinew⊕h(IDi∥PWi),andginew=Linew⊕h(PWi⊕IDi). Finally, the smartcard stores〈Binew,einew,finew,ginew,SCNinew,BK()⟩ into its memory, and deleting〈dinew,Linew〉.We simulated our protocol using AVISPA software to verify its security. AVISPA is a widely accepted tool with which the security correctness of many authentication protocols have been proven. We first describe AVISPA and then present the simulation results, followed by the specification of the proposed protocol.AVISPA measures whether a security protocol is SAFE or UNSAFE. AVISPA supports the High Level Protocol Specification Language (HLPSL). The structure of AVISPA is described in [35]. Note that AVISPA[41] supports four different back-ends and abstraction-based methods, all of which are integrated through HLPSL. The on-the-fly Model-Checker (OFMC) uses symbolic techniques to explore the state space in a demand-driven way. The back-end CL-AtSe (Constraint-Logic-based Attack Searcher) provides a translation from any security protocol specification written as a transition relation in an intermediate format (IF) into a set of constraints, which are effectively used to find security weaknesses of the designed protocol. The model checker SATMC generates propositional formulae, which feed into a state-of-the-art SAT solver; any model found is translated back into an attack. The model checker TA4SP is responsible for approximating an intruder’s knowledge by using regular tree languages. As mentioned above, the HLPSL specification is translated into an intermediate form using the hlpsl2if translator.AVISPA supports role-oriented language, with each participant playing a role during protocol execution. Each role is independent from the others, with some initial information (parameters) and, communicating with the other roles through channels. The intruder is modeled using the Dolev and Yao model [42], with the intruder able to assume a legitimate role in a protocol run. The role system also describes the number of sessions, the number of principals, and the number and types of roles. The OUTPUT FORMAT (OF) is generated based on the four back-ends. After successful execution, OF describes the results: whether the protocol is safe or unsafe, along with under what conditions that output is obtained.This section briefly presents the role for each participant of the proposed protocol, namely the user Ui, the gateway node GWN, the sensor node Sj, the session, the goal, and the environment. We implemented the Ui’s role in HLPSL language, as presented in Fig. 10. During execution of the user registration phase, Ui sends the registration message Snd(IDi_SKey1) to SA through a reliable channel using the symmetric key SKey1 and the Snd() operation. The type declaration channel(dy) defines that the channel follows the Dolev and Yao threat model [42]. The declaration secret(IDi, subs1, {Ui, GWN, Sj}) indicates that IDiis known to ⟨Ui, GWN, Sj⟩. Since only ⟨Ui, GWN, Sj⟩ know the user’s identity, the protocol provides user-anonymity.In Transition 2, Ui receives the smartcard informationRcv({Di′.Li′.SCNi′}_SKey1)securely using the symmetric key SKey1 and Rcv() operation. After that, Ui generates a random nonce Ki′ and timestamp T1′ using the new() operation. Then Ui sends Snd(M1′.M2′.M3′.T1′.EIDj′.SCNi) to GWN through an unreliable channel. The declaration witness(Ui,GWN,user_gateway, Ki′) indicates that Ui has freshly created Ki′ for GWN, and secret({PWi}, subs2, {Ui}) declares that PWi is only known to Ui. In Transition 3, Ui receives Rcv(M4′) through an unreliable channel and sends Snd(M5′) to GWN over a public channel. In Transition 4, Ui receives another message Rcv(M11′. M10) and then computes a session key. The declarations secret({Ki, Kj}, subs3, {Ui, GWN, Sj}) and secret({SKi′}, subs4, {Ui, GWN, Sj}) indicate that ⟨Ki, Kj, SKi⟩ are known only to ⟨Ui, GWN, Sj⟩.We present GWN’s role in the HLPSL language in Fig. 11. Initially, GWN receives the registration messageRcv({IDi′}_SKey1)securely from Ui using the symmetric key SKey1. Then, GWN generates the smartcard number SCNi and shares key Rshrd. GWN securely forwards the smartcard informationSnd({Di′.Li′.SCNi′}_SKey1). At the same time, GWN starts the registration phase of Sj. The declaration secret({Xgwn}, subs5, {GWN}) indicates that the secret key Xgwn is known only to GWN, while secret({Xj}, subs6, {GWN, Sj}) states that Xj is known only to ⟨GWN, Sj⟩. During the sensor node registration phase, GWN publicly receives the message Rcv(S1′.S2′.Ts1′). In Transition 3, GWN receives the login message Rcv(M1′.M2′.M3′.T1′.EIDj′.SCNi) through an unreliable channel and then sends Snd(M4′) to Ui. In Transition 4, GWN receives Rcv(M5′) and then generates the timestamp T2′. Thereafter, GWN transmits Snd(IDgwn.M6′.M7′.M8′.T2′) to Sj through an unreliable channel. In Transition 5, GWN receives Rcv(M9′.M10′.T3′) and sends Snd(M11′. M10) to Ui after computing the session key.In Fig. 12, we present Sj′s role in the HLPSL language. Initially, Sj securely receives the messageRcv({IDj′.Xj′.Rshrd′}_SKey2)from GWN with the help of the symmetric key SKey2. Then, Sj forwards Snd(S1′.S2′.Ts1′) to GWN through an unreliable channel. The statement secret({Rshrd}, subs7, {Sj, GWN}) indicates that Rshrd is shared between GWN and Sj. In Transition 2, Sj receives Rcv(IDgwn.M6′.M7′.M8′.T2′) and then generates the random number Kj′ and timestamp T3′ using the new() operation. Finally, Sj sends the message Snd(M9′.M10′.T3′) to GWN. The statement witness(Sj, GWN, gateway_sensor, Kj′) declares that Sj generates a fresh value of Kj′ for GWN.In Fig. 13, we present the session, goal, and environment roles in the HLPSL language. All the basic roles, as well as the roles for ⟨Ui, GWN, Sj⟩, are instanced with concrete arguments in the session segment. The environment section contains the global constant and composition of one or more session(s), and the intruder’s knowledge is also given. It may be noted that we have provided all the public parameters, including all the messages transmitted between the entities involved in our protocol.The current version (2006/02/2013) of HLPSL supports standard authentication and secrecy goals. In our implementation, the following seven secrecy goals and two authentications properties were verified.•G1. Thesecrecy_ofsubs1represents that IDiis kept secret to (Ui, GWN, Sj) only.G2. Thesecrecy_ofsubs2represents that PWiis kept secret to Ui only.G3. Thesecrecy_ofsubs3represents that the random numbers ⟨Ki, Kj⟩ are kept secret to (Ui, GWN, Sj) only.G4. Thesecrecy_ofsubs4represents that the negotiated secret key is only known to (Ui, GWN, Sj).G5. Thesecrecy_ofsubs5represents that the secret key Xgwn of GWN is permanently kept secret, known to only GWN.G6. Thesecrecy_ofsubs6represents that Xjis only known to (GWN, Sj).G7. Thesecrecy_ofsubs7represents that the shared secret Rshrd is only known to (GWN, Sj).A1. Theauthentication_onuser_gateway_kirepresents that Ui generates a random number ki. If GWN securely receives ki through a message, it authenticates Ui.A2. Theauthentication_ongateway_sensor_kjrepresents that Sj generates a random number kj. If GWN securely receives kj through a message, it authenticates Sj.This section discusses the results obtained after executing the HLPSL code using the web implementation of the AVISPA simulation tool. From these results, which are presented in Figs. 14and15, we find that the proposed protocol is SAFE under OFMC and CL-AtSe against active and passive attacks.This section further analyzes the security of the proposed protocol against relevant attacks.Proposition 1The proposed protocol is secure against the stolen-smartcard attack.In this attack,Aattempts to retrieve Ui’s and GWN’s confidential information after extracting information from the smartcard using the mechanism given in [36,37]. Generally, Uiuses low-entropy identity and password, which are guessable in polynomial time. Therefore,Aattempts not only to extract confidential information but also to guess Ui’s identity and password. However, this attack is not feasible in our protocol, owing to the following:(1)Assume thatAknows the smartcard information ⟨Bi, ei, fi, gi, SCNi, BK()⟩ of the legal user Ui, whereBi=BK(H(fngi)),ei=h(IDi∥PWi∥Bi),fi=di⊕h(IDi∥PWi),andgi=Li⊕h(PWi⊕IDi). Note that diis unknown toA. According to Assumption 6,Acannot computefi=di⊕h(IDi∥PWi)without knowing h(IDi∥PWi). Similarly,Acannot compute Liusing giwithout knowing ⟨IDi, PWi⟩. Since IDiand PWiare shielded by the hash function in ⟨gi, fi⟩,Ais not able to extract the required information due to non-invertibility of h(). However,Acan guess ⟨IDi, PWi⟩ if ⟨gi, fi⟩ is known. Note that the computation of ⟨gi, fi⟩ is based on ⟨XGWN, IDi, PWi⟩, which are unknown toA. According to Assumption 7, the probability of guessing ⟨XGWN, IDi, PWi⟩ is approximately equal to1212n+1024,which is negligible where the length of the secret key of GWN is 1024 bits.Biand eiare protected due to the hash function, whereBi=BK(H(fngi)),andei=h(IDi∥PWi∥Bi). Therefore,Acannot extract Ui’s information using ⟨Bi, ei⟩. Note that guessing Ui’s fingerprint fngiis hard [8]. Hence,Acannot guess fngi. On the other hand,Acannot verify the guessed IDiand PWiaccording to Assumption 4.The above shows that the attacker cannot extract or guess any confidential information of Uior GWN from a smartcard. Therefore, our protocol is secure against a stolen-smartcard attack.□The proposed protocol is secure against the off-line user-identity guessing attack.To violate the user-anonymity,Amay attempt to extract or guess Ui’s IDieither from the smartcard information or from the public messages. However, forAto extract or guess the identity IDiis not feasible because of the following:(1)In Proposition 1, we have illustrated thatAcannot derive or guess IDifrom the smartcard information.During protocol execution, assume thatAhas intercepted the login message ⟨M1, M2, M3, T1, SCTi, EIDj⟩, whereSCTi=SCNi⊕h(T1),M1=IDi*⊕h(Li*∥T1),M2=Ki⊕h(di*∥T1),M3=h(di*∥Ki∥T1),andEIDj=IDj⊕h(IDi∥Ki∥T1). To derive IDiusing M1, the correctLi*is required, which is not possible. On the other hand, IDiis protected by h() in EIDj. Hence,Acannot extract it, since the probability of guessing of IDiwould be1212n+128,which is negligible.During the execution of Steps 1 and 2 of Section 4.5, GWN and Uiforward M4 and M5, respectively, through an unreliable channel, whereM4=h(IDi∥di∥T1)andM5=h(di∥IDi∥Ki∥T1). Therefore,Amay guess or extract IDiusing ⟨M4, M5⟩. Note that M4 and M5 are protected by a non-invertible hash function h(), howeverAis unable to extract IDifrom ⟨M4, M5⟩; he or she may attempt to guess IDi. The probability of guessing IDiusing M4 and M5 would be approximately126n+1024and126n+1024+128,respectively, which are negligible.During the execution of the protocol, GWN forwards ⟨IDGWN, M6, M7, M8, T2⟩ to Sjthrough an unreliable channel. Assume thatAhas intercepted this message, whereM6=h(IDi′∥IDj′∥IDGWN∥Xj′∥Ki′∥T2),M7=IDi′⊕h(IDGWN∥Xj′∥T2),andM8=Ki⊕h(IDi′∥Xj′). In order to derive IDiusing M7,Aneeds confidential information Xj. The identity IDiis protected by h() in M6 and M8, soAcannot retrieve IDi. IfAwants to verify the identity guessed using M6 and M8, he or she has to know ⟨IDj, Xj, Ki⟩ and ⟨Ki, Xj⟩, which is not feasible.Therefore,Acannot extract Ui’s IDiusing the public messages MSG5 and MSG6. The above discussion demonstrates that our protocol can withstand the off-line identity-guessing attack. Therefore, our protocol preserves user-anonymity.□The proposed protocol is secure against the off-line sensor-node-identity guessing attack.Reminiscent of the off-line user-identity guessing attack,Amay attempt to derive or guess the identity IDjof the sensor node Sjin off-line mode. In order to do so,Aintercepts the public messages of the protocol during execution. Note that IDjis not incorporated into the smartcard; therefore,Acannot get IDjfrom a stolen-smartcard. However, neither canAextract or guess IDjfrom public messages, because(1)Assume thatAintercepted EIDjfrom the public channel and tries to extract or guess IDj, whereEIDj=IDj⊕h(IDi∥Ki∥T1). Note thatAneeds ⟨IDi, Ki⟩ to derive IDj. Moreover, it is infeasible forAto guess IDj, owing to negligible probability, is approximately equal to1212n+128,where the length of the random nonce is 128 bits.Assume thatAcollects M6 from the intercepted message MSG4, whereM6=h(IDi′∥IDj′∥IDGWN∥Xj′∥Ki′∥T2). Since IDjis protected by h(),Acannot extract it. Moreover, the probability of guessing IDjusing M6 is negligible.In MSG5 and MSG6, IDjis involved in the computation of the session key. As the session key is unknown, it is infeasible forAto derive or guess IDjusing MSG5 and MSG6.The above demonstrates that the proposed protocol is secure against the off-line sensor-node-identity guessing attack. Therefore, our protocol preserves sensor node anonymity.□The proposed protocol is secure against the replay attack.In cryptography, resisting the replay attack is quite hard, remaining one of the most challenging issues. In our protocol, the attacker may attempt to forge old public messages without any modification of the protocol participants (such as user, gateway node, and sensor node). In general, the timestamp method is used to resist replay attacks; however maintaining time synchronization across large networks is quite intricate. It should be noted that WSN can be applied to a specific target region, thus reducing the time-synchronization problem. So, the timestamp technique can be applied for GWN and Sj. we have employed the timestamp technique in GWN and Sj, where GWN and Sjcheck the validity of the timestamps before computing any security parameters. IfAforges previous messages of the protocol participants, the protocol closes the connection owing to the invalid timestamp.Still, maintaining time synchronization in large networks is challenging. Notably, the users access services from any-where, far from the network infrastructure. Therefore, the timestamp method is not appropriate for resisting replay attacks involving user. Since the protocol does not use the timestamp method between the user and the gateway node,Amay attempt to launch a replay attack, which will fail because:(1)Assume thatAreplays the old messageMSG1=〈M1,M2, M3, T1, SCTi, EIDj⟩ to GWN without any modification.It is confirmed that the replay message must be authenticated by GWN. According to our protocol, GWN transmitsMSG2=〈M4〉to Ui, GWN and Sj. Assume thatAinterceptsMSG2=〈M4〉from the public channel.Ahas to compute a valid M5, which is reliant on the identity IDi, confidential parameter di, and the random number Ki. We earlier illustrated thatAhas no way to derive ⟨IDi, Ki, di⟩. SinceAdoes not know these piece of information, computation of a valid M5 is not feasible. IfAtransmitsM5′to GWN after guessing the required parameters, GWN terminates the connection becauseM5′is invalid.□The proposed protocol is secure against user and sensor node untraceability attacks.In this attack,Aintercepts two messages from two different sessions and checks whether they are same. If so,Abelieves that these two messages belong to the same user. However,Acannot trace Uiafter intercepting one or more public messages. Assume thatAintercepts ⟨M1, M2, M3, T1, SCTi, EIDj⟩, whereSCTi=SCNi⊕h(T1),M1=IDi*⊕h(Li*∥T1),M2=Ki⊕h(di*∥T1),M3=h(di*∥Ki∥T1),andEIDj=IDj⊕h(IDi∥Ki∥T1). Note that the computation of ⟨M1, M2, M3, T1, SCTi, EIDj⟩ is reliant on the timestamp and a random number. Since the timestamp and random number are different in each session, the login messages of each session are also different. It is worth noting that the rest of the messages, such as ⟨MSG2, MSG3, MSG4, MSG5, MSG6⟩, are different in each session too, due to the random numbers and the timestamps. Therefore, our protocol resists user and sensor node untraceability attacks.□The proposed protocol is secure against the off-line password guessing attack.Resembling the off-line identity-guessing attack,Acan guess a user’s password in polynomial time. In Proposition 1, we have demonstrated thatAcannot guess Ui’s password PWiusing smartcard information. Notably, the public messages of our protocol are independent from PWi. Therefore, guessing or extracting PWifrom the public messages is infeasible in our protocol.□The proposed protocol provides strong protection against the user-impersonation attack.In this attack,Afirst intercepts the login message and then attempts to make another, forged login message. However,Ais unable to launch the user-impersonation attack in our protocol. Assume thatAintercepts the login message ⟨M1, M2, M3, T1, SCTi, EIDj⟩, whereSCTi=SCNi⊕h(T1),M1=IDi*⊕h(Li*∥T1),M2=Ki⊕h(di*∥T1),M3=h(di*∥Ki∥T1),andEIDj=IDj⊕h(IDi∥Ki∥T1). It is confirmed thatAcan generate a fresh random nonceKiaand timestampT1a. However,Aneeds ⟨IDi, Li⟩ and ⟨IDi, IDj⟩ to compute M1 and EIDj, respectively. Similarly,Arequires dito compute ⟨M2, M3⟩. We illustrated above thatAis unable to extract ⟨IDi, IDj, di⟩ based on the protocol description. Therefore, our protocol provides protection against the user-impersonation attack.□The proposed protocol provides strong protection against the gateway node impersonation attack.Resembling the user-impersonation attack,Amay attempt to impersonate GWN after intercepting authentication messages during protocol execution. In order to do so,Aneeds to compute ⟨M4, IDGWN, M6, M7, M8, T2⟩, whereM6=h(IDi′∥IDj′∥IDGWN∥Xj′∥Ki′∥T2),M7=IDi′⊕h(IDGWN∥Xj′∥T2),andM8=Ki⊕h(IDi′∥Xj′).Aneeds ⟨IDi, IDj, Xj⟩ to compute M6, ⟨IDi, Xj⟩ to compute M7, and ⟨IDi, Xj⟩ to compute M6, M7, and M8, respectively. Since ⟨IDi, IDj, Xj⟩ are unknown, it is infeasible to compute another correct but forged authentication message. Therefore, the protocol can provide security against the gateway node impersonation attack.□The proposed protocol protects the sensor node impersonation attacks.Similar to the gateway node impersonation attack,Amay try to impersonate Sjafter intercepting the authentication messages. To do so,Aneeds to generateMSG5=〈M9,M10, T3⟩ to impersonate Sj, whereSKj=h(IDi**∥IDj∥Ki**∥Kj),M9=h(SKj∥Xj∥Kj∥T3),andM10=Ki**⊕Kj. Thus,Aneeds ⟨IDi, IDj, Xj, Ki⟩ to computeMSG5=〈M9,M10, T3⟩. SinceAhas no knowledge of the information ⟨IDi, IDj, Xj, Ki⟩, it is infeasible to perform the sensor node impersonation attack.□The proposed protocol is secure against the privileged-insider attack.If an insider of the system obtains the user’s password in some way, she or he can utilize it in a privileged-insider attack to crack other systems in which the user has registered him or herself using the same identity and password. In general, users often employ the same password and identity for a set of servers. According to reports in the literature, most security systems are vulnerable to the insider attack. Therefore, it is an important attack against password-based authentication protocols. During user registration in our protocol, Uisubmits only IDias a registration message; public messages are independent of Ui’s password. Therefore, an insider has no way to obtain Ui’s password.□The proposed protocol is secure against the session key computation attack.In an authenticated session key generation protocol, the session key is typically used to encrypt confidential information during message transmission between entities over unreliable networks. The main feature of a session key is freshness, which means that in each session the session key must be different. In our protocol, Ui, GWN, and Sjnegotiate a session keySKi=SKGWN=SKj=h(IDi∥IDj∥Ki∥Kj)that relies on the confidential information ⟨IDi, IDj, Ki, Kj⟩ that are unknown toA. Therefore,Acannot compute the session key without knowing ⟨IDi, IDj, Ki, Kj⟩. It is also notable that the session key in the protocol holds the freshness property because of the random numbers ⟨Ki, Kj⟩.□The proposed protocol is secure against the known session-specific temporary information attack.In this attack, assume thatAknows short-term confidential information, such as random numbers ⟨Ki, Kj⟩ and attempts to compute the session key. The session key of our protocol isSKi=SKGWN=SKj=h(IDi∥IDj∥Ki∥Kj). Note that the session key relies not only reliant on the random numbers ⟨Ki, Kj⟩ but also depends on ⟨IDi, IDj⟩. As we have described earlier,Ahas no way to compute ⟨IDi, IDj⟩. Therefore, the protocolprovides security against this attack.□The proposed protocol achieves the session key verification property.The negotiated session key is verified during protocol execution. In Step 6 of the authentication phase, GWN verifies the session key SKjgenerated by Sjby checking whetherM9′=M9holds. After that, Uiverifies whetherM11*=M11holds to verify the session key SKGWN, which is generated by GWN. Therefore, the proposed protocol provides the session key verification property.□The proposed protocol preserves mutual authentication.In light of the fact that the public messages pass over an unreliable communications medium, such as the Internet, mutual authentication between participants must be provided. During the execution of our protocol, each participant authenticates every other. In Step 1 of the authentication phase, GWN verifies Ui, and, in the next step, Uiverifies GWN. In Step 5, Sjverifies the authenticity of Uiand GWN, and GWN verifies Sjin Step 6. Finally, Uiverifies GWN and Sjin Step 7.□The proposed protocol detects unauthorized logins.Practically, the user may unintentionally enter wrong information at the smartcard reader during login. As a result, the protocol may execute additional computation and thus increase network congestion. Therefore, detection of wrong user information must be provided at the initial stage of the login phase, so that the terminal cannot generate a login message without verifying the user’s legitimacy.The probability of providing the wrong biometric information is comparatively less than providing the wrong password information. However, if Uiprovides the wrong fingerprintfngiw,the conditionBi*=Biwould not satisfy, whereBi*=BK(H(fngiw)). Assuming that Uienters the correct fingerprint, but inputs the wrong passwordPWiw,the smartcard would deny the user’s login request, becauseei*≠ei,whereei=h(IDi∥PWiw∥Bi).□The proposed protocol offers the post-deployment phase.A sensor node in the target field may become damaged in some way and require replacement. In addition, the target field may sometimes need to be expanded. SA should deploy the required sensor nodes to expand the target field. In order to provide this facility, the protocol offers a post-deployment phase.□

@&#CONCLUSIONS@&#
