@&#MAIN-TITLE@&#
A splicing-driven memetic algorithm for reconstructing cross-cut shredded text documents

@&#HIGHLIGHTS@&#
Develop a splicing-driven memetic algorithm to reconstruct cross-cut shredded text documents.Design a comprehensive cost function to evaluate solutions and to guide individual search.Design novel reproduction operators to effectively utilize the adjacency information of shreds.Propose an elitism-based local search strategy to further enhance efficiency.Obtain good reconstruction performance in terms of the solution quality and convergence speed.

@&#KEYPHRASES@&#
Reconstruction of cross-cut shredded text documents (RCCSTD),Memetic algorithm,Evolutionary computation,Information recovery,Global optimization,

@&#ABSTRACT@&#
Reconstruction of cross-cut shredded text documents (RCCSTD) plays a crucial role in many fields such as forensic and archeology. To handle and reconstruct the shreds, in addition to some image processing procedures, a well-designed optimization algorithm is required. Existing works adopt some general methods in these two aspects, which may not be very efficient since they ignore the specific structure or characteristics of RCCSTD. In this paper, we develop a splicing-driven memetic algorithm (SD-MA) specifically for tackling the problem. As the name indicates, the algorithm is designed from a splicing-centered perspective, in which the operators and fitness evaluation are developed for the purpose of splicing the shreds. We design novel crossover and mutation operators that utilize the adjacency information in the shreds to breed high-quality offsprings. Then, a local search strategy based on shreds is performed, which further improves the evolution efficiency of the population in complex search space. To extract valid information from shreds and improve the accuracy of splicing costs, we propose a comprehensive objective function that considers both edge and empty row-based splicing errors. Experiments are carried out on 30 RCCSTD scenarios and comparisons are made against previous best-known algorithms. Experimental results show that the proposed SD-MA displays a significantly improved performance in terms of solution accuracy and convergence speed.

@&#INTRODUCTION@&#
Although paperless offices have been spread out over the last decades, printed documents are still necessary due to the storage or identification requirements. Subsequently, shredders are commonly used to destroy the sensitive documents. In some cases, the shredding might happen by accident, and thus reconstructing the documents can avoid the losses. Sometimes criminals use the same way to destroy evidence by purpose, which is related to forensic science. In addition, this area also attracts the attention of archeologists to recover ancient documents. The original materials for reconstruction could be hand torn, hand cut or machine cut. The focus of this paper is on the reconstruction of cross-cut shredded text documents (RCCSTD) problem, in which documents are cut into rectangular shreds of equal size and shape by shredders [32,37,41].In the literature, two related problems have been studied in the field of document reconstruction, namely, restoration of hand torn paper documents (RHTPD) and reconstruction of strip shredded text documents (RSSTD). Both of them possess some differences from the RCCSTD problem. In RHTPD, each piece has its unique shape. In this case, geometric information could be utilized for reconstruction. To solve this problem, polygonal approximation was used by Justino et al. in [16] to reduce the complexity. As for the RSSTD, the original documents are cut into thin strips. The effect of adopting MPEG-7 descriptors to describe the content strip was showed in [39]. To enhance the performance, Prandtstetter and Raidl [33] tried to use a variable neighborhood search approach with a semi-automatic system in the optimization process.The RCCSTD considered in this paper is similar to the RSSTD, but the cutting is more fine-grained that only small rectangular shreds are provided. Particularly, the RSSTD can be considered as a simplified special case of the RCCSTD. Since the RSSTD problem has been proved to be nondeterministic polynomial (NP) complete [15], we here could conclude that the RCCSTD problem is also NP-complete. Therefore, NP algorithms have been studied to find the near-optimal solutions [18,19]. More specifically, evolutionary algorithms (EAs) have gained successes in various NP-complete optimization fields such as resource allocation [12], vehicle routing [13], wireless sensor networks [44] and text feature selection [22]. In the literature of RCCSTD, Raidl and Hu [35] applied genetic algorithm (GA) with a solution archive to avoid duplicate solutions as well as to maintain the diversity of population. Subsequently, with the help of variable neighborhood search [25], GA was extended to a memetic algorithm in [36]. The variable neighborhood search was also seen as a global improvement procedure, as reported in [34].The literature works adopt general-purpose EAs for solving RCCSTD, which does not fully adapt to the problem structure. Differently, we design a novel algorithm, the splicing-driven memetic algorithm (SD-MA), specifically for tackling the problem. The term “splicing-driven” is used since, in the proposed algorithm, both the definition of objective and the design of operators are based on the principle of “splicing”. Memetic Algorithm (MA) stands for that we adopt the combination of an evolutionary approach and a local improvement procedure [26,30,24,29,15]. In the proposed SD-MA, the construction of each solution is based on genes, which corresponds to that the document in RCCSTD is reconstructed by shreds. The genetic operators and local search strategies in SD-MA are designed for the purpose of effectively splicing the shreds. Specifically, the splicing-driven crossover utilizes the adjacency information in the sequences, extracts the correctly positioned links and reuses them in the offspring. Subsequently, four mutation operators are designed, namely, slide on line (SOL), swap within line (SWL), slide through line (STL) and swap between lines (SBL). In addition to increasing the diversity of population, all these operators correspond to some misleading situations that usually happen during the search process of this problem. In the selection, we develop a comprehensive objective function that considers both edge and empty row-based splicing errors. Finally, because the performance of EAs often deteriorates rapidly as the dimensionality of the problem increases [17], the algorithm further embeds a local search strategy based on row-oriented elitism. Inspired by the random grouping strategy used in EAs for large-scale optimization, in the proposed local search, the most competitive rows of shreds are utilized to further improve the solution quality.To test the performance of SD-MA, 30 scenarios from ten different documents in two languages are used. It is shown that the proposed algorithm exhibits a better performance than the compared best-known algorithm in terms of solution accuracy, significance tests and convergence speed. In addition, our investigation experiment indicates that the crossover, mutation and local search operators used in the proposed memetic algorithm are all effective.In what follows, the formal model of RCCSTD problem and a comprehensive objective function are defined in detail. Subsequently, Section 3 describes the implementations of SD-MA. In Section 4, experimental results are presented. Finally, conclusions including an outlook for the topic are drawn in Section 5.Before defining the cost function, a formal model of RCCSTD is formulated. Based on [32], this problem can be expressed as follows. Given a set of rectangular shreds S={1, 2, …, n} with the same size and identified numbers, which contains the text of original document. Note that these shreds must appear exactly once in the solution. The correct orientation of each shred is assumed to be known, for which the related pattern recognition technique has been reported in [21]. A standard solution in this problem is expressed as a matrix, whose elements represent the shreds in set S. The aim of search is to find an optimal assignment of shreds with the lowest cost. For simplicity, in the following description, the cost functions in the horizontal and vertical directions are separately defined. The horizontal function Hi,jshows the cost made by positioning shred i left to shred j. Analogously, the vertical function Bi,jreturns the cost value when shred i is placed on the top of j.An appropriate cost function is crucial in solving RCCSTD problem because the costs are utilized as the fitness values of individuals in the optimization process. If the function is not sophisticatedly defined that the incorrect solution in some scenarios has a lower cost value than the correct one does, the search individuals would be guided to a wrong direction. Due to the various standards in text documents, it is challenging to define a perfect cost function. Considering the most possible cases, we define a comprehensive cost function as follows.Since the majority of text documents are black texts on the white background, we take the gray-scale images (ranging from 0 to 255) as input. To make it clear, the edges of shreds are represented by vectors. Suppose Airepresents the right edge of shred i and Bjrepresents the left edge of shred j. Then we have:(1)Ai=[a1i,a2i,a3i,…,ahi],aki∈[0,255]Bj=[b1j,b2j,b3j,…,bhj],bkj∈[0,255]where h is the length of edge.The edge splicing cost function makes use of the pixel information contained by the above edge pair of two shreds. The function can either contain the “non-blank edge cost” when neither of these two edges is blank, or the “blank edge cost” otherwise. These two situations are illustrated in Figs. 1 and 2, and the corresponding functions are defined as follows. The “non-blank edge cost function” adopts the idea in [33]. When considering the cost of connecting two pixels in a line, the information of the pixel pairs above and below to the current pixel pair is included. It is proved that the use of neighborhood information enhances the consistency in reconstructing the text. The costdi,jwhen shred j is positioned next to shred i is defined as:(2)di,j=∑k=3h−2pi,jkwherepi,jkis the boolean difference at the kth point:(3)pi,jk=1,ifp′i,jk≥τ0,otherwise(4)p′i,jk=|0.7(aki−bkj)+0.1(ak+1i−bk+1j)+0.1(ak−1i−bk−1j)+0.05(ak+2i−bk+2j)+0.05(ak−2i−bk−2j)|The threshold value τ should be carefully defined, which has a great influence on the computing results.On the other hand, the “blank edge cost function” utilizes the length of blank space generated by connecting two shreds. In general, the blank space in a routine text document has a standard range, which helps to detect whether or not two shreds with blank edges are positioned correctly. The costbi,jwhen shred j is positioned next to shred i is defined as:(5)bi,j=0,if(ci+dj)∈standardrangeh,otherwisewhere ciand djrepresent the blank spaces on shred i and j, respectively. An illustration of ciand djis provided in Fig. 2.Different from the above edge splicing cost that considers the pixel information on the edges of shreds only, another cost function named “empty row splicing cost” is proposed here, which looks at more macroscopic information. Fig. 3shows a typical example that two shreds are connected by mistake but the edge splicing cost is relatively low. To avoid this situation, an “empty row” is defined as a row in the shred whose pixel values are all zero. Intuitively, a difference in the empty rows for two shreds implies that the two shreds can hardly be aligned together in the correct solution. More formally, the cost function between shreds i and j is defined as:(6)fi,j=∑k=1h(eki⊕ekj)(7)eki=1,ifrowkofshrediisblank0,otherwisewhereekirepresents the truth value of that the kth row of shred i is blank.To compute the overall cost of a solution, the splicing costs along the horizontal and vertical directions need to be added up. In the horizontal direction, the edge and empty row-based splicing costs are comprehensively combined based on the defined situations. Specifically, the horizontal cost when positioning shred i left to shred j is defined as:(8)Hi,j=di,j+fi,j,ifci+dj=0bi,j+fi,j,otherwisewhere ciand djrepresent blank spaces on shreds i and j respectively.Then, in the vertical direction, since the text is not aligned according to columns, the “empty column splicing cost” (analogous to the empty row splicing cost) is invalid. In this occasion, the vertical cost is simpler which only considers the edge splicing error:(9)Bi,j=di,j,ifci+dj=0bi,j,otherwiseFig. 4shows a solution to reconstruct shreds a–f, where the full and dotted lines represent the horizontal and vertical costs, respectively. The overall cost is defined as:(10)Cost=Ha,b+Hb,c+Ba,d+Hd,e+Bb,e+He,f+Bc,fTo handle and reconstruct these shreds, a stochastic optimization algorithm is desired. In the previous methods, the importance of optimization is always ignored and general optimization approaches are directly adopted. In this paper, we develop a splicing-driven memetic algorithm (SD-MA) with novel crossover, mutation operators and an elitism-based local search strategy for this problem.GA [14] has been proved efficient in solving many optimization problems [2,31,9]. Nevertheless, its performance deteriorates rapidly in some situations, especially when the search space is complex. To tackle this problem, MA was first proposed by Moscato and Norman in [27], which is also a population-based meta-heuristic search approach. Generally, MA can be regarded as a combination of a population-based global search and a local improvement procedure [20]. The main advantage gained from the use of local search is that the space of possible solutions is reduced to the subspace of local optima [1]. With the help of a properly developed local search operator, the quality of individuals can be efficiently enhanced. In the second generation of MA, multiple individual learning strategies are adopted and adaptively selected for local refinements [30,24,29,15].This paper focuses more on the genetic operators of SD-MA that we specifically design two initialization methods, a new recombination operator and four mutation operators for the RCCSTD problem. Considering the local improvement procedure, a single individual learning strategy is utilized by SD-MA. Therefore, the proposed algorithm belongs to the first generation of MA.As mentioned above, a solution with n shreds is represented by an x×y matrix, whose elements stand for the shreds in RCCSTD problem and labeled with indices (x and y denote the numbers of rows and columns in the shredded document, respectively). Thus, each individual in SD-MA is represented by such a label matrix. To generate competitive individuals in the initial step, apart from the traditional random building method (RBM), a greedy building heuristic (GBH) is proposed and used. A good initial heuristic can help supply more effective genes and hereafter increase the performance of the whole algorithm. In this step, 40% of the individuals in initial population are created by GBH while the other 60% are generated by RBM.In general, a text document is laid out such that there is a blank margin on the left of the page. This way, it is very likely that those shreds with blank left margins are on the leftmost column in the final solution. GBH first chooses a shred with the left blank margin randomly and place it at the top left corner of the solution. Subsequently, the initial solution is built row by row using a greedy strategy to select shreds. The greedy strategy utilizes a heuristic based on the evaluation of cost function, which is the sum of the horizontal and vertical cost values generated by connecting the shred to the already processed left and top shreds, if exist. Here two special cases are: shreds on the first row of solution only consider the horizontal costs of combining them with their left neighbors, while the shreds on leftmost column only concern the vertical costs of splicing them with their top neighbors. Note that the algorithm developed in [33] also utilizes a greedy initialization method. But since the algorithm is developed for the one-dimensional RSSTD problem, it considers only the horizontal information in the initialization. In order to handle the two-dimensional RCCSTD problem, the proposed GBH method further takes the vertical information into consideration.RBM is widely adopted by various EAs in order to increase the diversity of initial individuals. We first fill the elements of the individual matrix in sequence, and then permutates the elements in a completely random way. This way, the generated individuals are not only random but also feasible to the problem.Although it is very unlikely that the initial population finds the optimal solution, those initial solutions may have correctly arranged shreds and links. The members with those shreds turn out to be more competitive in the evolving population and be more likely to be chosen as parents in the following crossover operators, owing to the effect of selection. As an ideal result of recombining individuals, an offspring with more correctly arranged shreds should be generated.To achieve this aim, we study different genetic sequencing operators and find that they emphasize different factors during the recombination. Some of them focus on the order, such as the order crossover [6], while some others highlight the position information such as the partially mapped crossover (PMX) [10] and cycle crossover [28].Considering that a solution with more correct links is likely to provide more available information of the document, we here adopt the idea of the enhanced edge recombination (EER) in [38], which emphasizes the adjacency information in the sequences. However, although EER is an efficient recombination operator in solving the traveling salesman problem (TSP), it is unable to be directly applied in RCCSTD problem due to the differences in dimension and link direction. In this paper, a novel crossover operator is proposed and named “EER-2D”. Next, we first introduce the operation of EER and then describe our extended version, the EER-2D.In EER, “edge table” is defined as a list structure to store the adjacency information extracted from parent individuals. Taking a sequence [bdeac] as an example, it contains the connections [bd, de, ea, ac, cb]. Based on this structure, the generation of offspring proceeds as the following steps: (1) Select the initial member from one of the parents. (2) Choose a subsequent member according to the edge table and already processed members. (3) Repeat step 2 until a valid solution is completed. The word “enhanced” in EER operator refers to the strategy that the links appear in both parents are labeled with minus and have higher priority to get emersion in the offspring.Fig. 5shows an example of parents, edge table and the reproduced offspring. Suppose element a is selected randomly to start breeding the offspring. Element a has links to b, c and e. Since link “a–b” appears in both parents and is labeled with minus in the edge table, it is chosen to get emersion in the offspring. Element d is then selected (note that element a can no longer be selected since it can only appear once in the offspring), and so forth. This process continues until the offspring is completed.Considering the differences between RCCSTD and TSP, we extend the EER to two-dimensions and propose a new recombination operator named EER-2D. On one hand, the recombination of RCCSTD is associated with both horizontal and vertical directions. Therefore, there should be two edge tables in EER-2D, namely, “horizontal edge table” and “vertical edge table”. Links on two directions are added to the respective edge tables. As a result of using two edge tables, two shreds/genes can be selected during the recombination. If the two shreds are not the same, a selection priority is defined as:1)The shred from the horizontal table has higher priority in the first row while vertical result has higher priority in the first column.Two shreds have the same priority in the other positions, and hence one of them is chosen in a random fashion.On the other hand, the graph in the TSP problem is undirected while it is directed in the RCCSTD problem. Particularly, link “a–b” and link “b–a” possess the same cost in TSP. However, these two links indicate opposite meanings in RCCSTD: the former link indicates that shred a is left to shred b; the latter link means shred a is right to shred b. In this case, adjacency information in the two edge tables of EER-2D is not as sufficient as that in the original EER. To ensure enough adjacency information to generate the offspring, a third genetic individual is considered in addition to the two parents. The rule in EER operator is still adopted, links with two or more appearances are labeled with minus and have higher priority to be chosen.To sum up, EER-2D incorporates two edge tables in the horizontal and vertical directions and introduces three parent individuals to improve the performance of recombination in two-dimensional structure. Fig. 6shows an example of parents, offspring and the edge tables in EER-2D. First, element a is selected randomly to start breeding the offspring. Second, element d is inserted based on the links in the horizontal edge table, and so forth element c is inserted. Then, element e is chosen because the link “a–e” is in the vertical edge table. Next, element f is chosen by the links in two directions. This process continues until the offspring is completed.The SD-MA uses a parameter pc, namely the probability of crossover, to control the performing of EER-2D. Particularly, within probability pc, three individuals are selected to breed an offspring; otherwise, an individual is randomly selected and copied to the offspring. Afterwards, the mutation operation is executed.Mutation introduces new genetic materials to prevent the algorithm from converging too fast and prematurely. The appropriate designed mutation operators can additionally help to remove the incorrect and misleading links in this problem. Based on this consideration, we propose four mutation operators, namely, SOL, SWL, STL and SBL. For each offspring generated by the above EER-2D, within a mutation probability pm, one of the four operators is randomly selected to mutate the offspring.In many cases, a small difference in the costs is caused by the sliding of a small set of genetic sequences. In the SOL operator, mutation makes the selected gene segment slide to a random position on its current line. The length and position of the segment are chosen by random. An example of SOL operator is showed in Fig. 7, where shreds i and j slide to the head of the second row.The basic idea of SWL operator is to amend the reverse pairs within the same row. Through a SWL operator, two shreds on the same line are chosen by random and exchanged. As shown in Fig. 8, positions of shreds i and j are exchanged.Distinct from the horizontal SOL operator, STL operator is carried out vertically. It is designed to focus on the rows. In the STL operator, a randomly chosen row slides to a random position and the other rows in the solution move accordingly. An example of STL operation is given in Fig. 9, where the first row is slid to the bottom.SBL is the simplest but also the most flexible in these four operators. The swap of two random shreds from different rows helps to improve the population diversity. As shown in Fig. 10, shreds i and j from different rows are chosen by random and exchanged.For the SOL and SWL operators that focus on a single row at each time, since the quality of some rows of the individual are more likely to be worse than the others, we define a parameter pnas the possibility of selecting the nth row to undergo the mutation. Considering that adaptive strategy is proved to be efficient in many evolutionary algorithms [43,42,11], a simple adaptive strategy is designed here to adjust the pn:(11)pn=kn∑n=1hkn(12)kn=kn+1,iffitafterbetterthanfitbeforeandpn<2xkn−1,iffitafterworsethanfitbeforeandpn>1xkn,otherwisewhere fitbefore and fitafter represent the fitness of solution before and after this mutation operator, respectively, x is the total number of rows. If the mutation performed on the nth row results in improved fitness of the offspring, pnof selecting this row is improved. Note that fitafter is calculated in the selection operator, but the calculation of fitbefore consumes additional fitness evaluations (FEs), which need to be counted in the algorithm. For STL and SBL, the rows are chosen by random.During the evolution process, finding a correct solution needs the cooperation of a large amount of genetic individuals during hundreds of generations. In order to speed up this evolution process as well as to improve the effectiveness of finding the correct solution, a local search procedure is further embedded in the algorithm. Named “elitism-based local search”, this procedure utilizes the rows with the most competitive fitness to improve the current population.Note that finding correctly arranged rows is a subproblem of RCCSTD and is relatively simple to deal with. Rows with the lowest horizontal costs (which have been calculated in Eq. (8) during the fitness evaluation) are put into use. These rows are named “elitism-rows” in our local search strategy. SD-MA maintains an archive of elitism-rows during the evolution. Each elitism-row is identified by its first element and it will be updated if a better row beginning with the same element appears. The individual learning procedure contains the following three steps:1)Randomly choose one row in the current individual and replace it with the elitism-row adopting the same leading element. Thus, a temporary elitism-individual has been constructed in this step.In the temporary elitism-individual, some of the shreds might appear more than once while some others are not included. Obviously, this kind of individuals is infeasible for the problem. To make them become feasible, some repeated shreds on the unselected rows are randomly replaced by the unused shreds. In this way, a feasible elitism-individual is built.The current individual is replaced by the feasible elitism-individual if the latter has a better fitness.To make it easier to understand, Fig. 11shows an example of the individual improvement. Shreds a and d lead two rows, respectively, in the current individual. Suppose the second row of the individual is selected and hence the fourth elitism-row with leading shred d is chosen to be inserted in the current individual. However, there are two shreds c in the temporary elitism-individual. To make this individual available, the shred c appeared in the first row is replaced by shred f in order to obtain the feasible elitism-individual.To improve the effectiveness of the local search, in SD-MA, the above individual learning is executed every Iilgenerations and only to the top Pilindividuals in the current population, where Iilis the interval of individual learning and Pilis the proportion of individuals in the population that are selected for the individual learning.In this paper, a splicing-driven memetic algorithm is designed specifically for solving the RCCSTD problem. To keep the initial population competitive, GBH and RBM operators are both adopted. After that, the recombination operator named EER-2D is proposed to breed NI high-quality offsprings in every generation. Four mutation operators, namely, SOL, SWL, STL and SBL are also designed to enhance diversity as well as to remove misleading links. Finally, an elitism-based local search strategy is executed to further improve the quality of population. To make it clearer, the whole procedure of the proposed algorithm is showed in Algorithm 1. Note that four places in the algorithm consumes fitness evaluations, namely, initialization (Line 5 of Algorithm 1), the adaptation of the possibility parameter pnfor SOL and SWL (Line 20), selection (Line 26) and local search (Line 33).Algorithm 1The splicing-driven memetic algorithm1:FEs=0; (FEs is the current number of fitness evaluations.)2:G=0;   (G is the current number of generations.)3:Use GBH and RBM to generate initial individuals;4:Evaluate the fitness value of each individual;5:FEs=FEs+NP;6:Build the archive of Elitism−rows;7:while stopping criterion is not satisfied do8:G=G+1;9:fori=1 toNIdo10:ifrand(0, 1)<pcthen11:Select three individuals randomly;12:Recombine the selected individuals to breed an offspring;13:else14:Copy a random individual to the offspring;15:end if16:ifrand(0, 1)<pmthen17:Select one of the four mutation operators randomly;18:if SOL or SWL is selected then19:Evaluate the current offspring;20:FEs=FEs+1;21:end if22:Mutate the offspring by the selected mutation operator;23:end if24:end for25:Evaluate the NI new individuals;26:FEs=FEs+NI;27:Update the pnof each row;28:Update the archive of Elitism−rows;29:Select the best NP individuals from the old and new population;30:Update the population by the NP individuals;31:ifG mod Iil=0 then32:Improve the top Pilindividuals by local search;33:FEs=FEs+Pil·NP;34:end if35:end while

@&#CONCLUSIONS@&#
