@&#MAIN-TITLE@&#
The abstract domain of Trapezoid Step Functions

@&#HIGHLIGHTS@&#
The domain of Trapezoid Step Functions is introduced for the static analysis on continuous functions׳ values.The domain is a (proper) refinement of the Interval Valued Step Function Domain.A constructive abstraction procedure is provided that deals with floating point precision issues.

@&#KEYPHRASES@&#
Abstract domain,Abstract interpretation,Continuous functions,Embedded software,Static analysis,

@&#ABSTRACT@&#
The Trapezoid Step Functions (TSF) domain is introduced in order to approximate continuous functions by a finite sequence of trapezoids, adopting linear functions to abstract the upper and the lower bounds of a continuous variable in each time slot. The lattice structure of TSFis studied, showing how to build and compute a sound abstraction of a given continuous function. Experimental results underline the effectiveness of the approach in terms of both precision and efficiency with respect to the domain of Interval Valued Step Functions (IVSF).

@&#INTRODUCTION@&#
Embedded software is made up of discrete (that is, the program) and continuous (that is, the physical environment) components. The program receives inputs from the physical environment through sensors that are usually modeled by volatile variables. Embedded software often deals with safety critical systems, like flight controllers. The reliability of these systems is crucial: even a single bug can result in a disaster, and this is a relevant challenge for formal verification methods. Static analysis is aimed at over-approximating the concrete semantics of a program in a computable way to prove properties that are satisfied by all possible executions. In the context of embedded software, safety properties are particularly important, and it is necessary to precisely approximate both the discrete and the continuous system.On one hand, there is a large literature on the static analysis of discrete programs. On the other hand, these approaches do not perform well when they are applied to continuous environments. For instance, in the context of the abstract interpretation framework [1,2], the Interval domain [1] abstracts continuous systems with the minimal and the maximal values a sensor can return at any time. This approach is definitely too rough for the static analysis of embedded programs. Bouissou and Martel [3] proposed the Interval Valued Step Functions (IVSF) domain for approximating the behavior of a function in a given interval of time (i.e, a step) with the minimal and the maximal values the function could achieve during that period of time.In this work (that extends [4]) we go one step further by introducing the Trapezoid Step Functions (TSF) domain. TSFabstracts the values of a function in a given time slot with two linear functions, tracking in this way linear relationships between the time and the output value. Our work is inspired by the evolution of numerical domains. Since the Interval domain is not precise enough in many contexts, various relational domains (e.g., Polyhedra [5] and Octagons [6]) have been introduced. In a similar way, our domain, instead of tracking the minimal and the maximal values of a function in a given time slot, tracks two linear functions that approximate values of the function as a linear multivalued function [7,8]. The two linear functions, together with the two vertical lines that delimit the time slot, form a trapezoid. We approximate the function with a finite number of trapezoids, one for each step.Consider, for instance, Fig. 1. It compares the 4-steps abstraction off=sin(x)by TSF(on the left) and by IVSF(on the right) in the interval[0,2π]. These plots make clear that in general TSFbetter approximates the shape of the function using trapezoids rather than the rectangles obtained with IVSF.In Fig. 2we can see the abstraction of the same function (sin(x)) with the same number of steps (4) on a restricted domain ([0,π/2]). This scenario is quite different from Fig. 1, but also in this case the plots show that TSFis quite more precise than IVSF.Of course, with a suitable choice of the time steps, the precision improvement obtained by using trapezoids further increases, as depicted in Fig. 2. Moreover, if the width of steps is not fixed, TSFcan be seen as a refinement of IVSFthat yields a more accurate function representation, as depicted in Fig. 3.The main contributions of this paper are:•the formal definition of TSFand its lattice operators,the introduction of a sound abstraction function that, given a continuous and derivable function, builds up its abstraction in TSF, andthe discussion of some experimental results and the comparison with the ones obtained by IVSF.The paper is structured as follows. The rest of this section introduces a motivating example and recalls some basic concepts of abstract interpretation. Sections 2 and 3 formalize the domain and the abstraction function. In Section 4 we present some experimental results when applying TSFto the abstraction of different functions, and how our results compare with IVSF. Section 5 discusses the related work and Section 6 concludes.Our motivating example concerns a special case of hybrid system, where we have a discrete system (an embedded program) which takes a continuous environment as input.Consider the program in Fig. 4. This is the code of an integrator, a quite common component of embedded programs. It has been inspired by [9] and it is the example used in [3] in order to show the main features of IVSF. This code integrates a function (whose values are provided through the volatile variable x) using the rectangle method on a sampling step h. We assume that the function we integrate issin(2πt), and that the input data are given by a sensor (hence the volatile variable x) at a frequency of 8KHz. This scenario is particularly interesting for the analysis of numerical precision, since the sensor will produce the sequence of values[0,22,1,22,0,−22,−1,−22]on x. Therefore, in a perfect arithmetic computation the summation of these values multiplied by h will be equal to zero after8×iiterations∀i∈N. Nevertheless, in a real system this summation would produce some approximate values because of floating point approximation. This code is particularly interesting to test the precision of abstract domains since it propagates the approximation error of our abstract domain at each iteration of the while loop, and therefore it is a good candidate to test the precision of TSF.Abstract interpretation [1,2] is a framework to define and prove the soundness of abstractions. Usually, concrete states are composed by sets of elements (e.g., all the possible computational states, or a set of continuous functions), that are approximated by a unique element (also referred to as an abstract state) in the abstract domain. Formally, the concrete domain℘(D)forms a complete lattice〈℘(D),⊆,∅,D,∪,∩〉. Similarly, the abstract domainAhas to form a lattice〈A,≤A,⊥A,⊤A,⊔A,⊓A〉as well.11This can be weakened into a partial order where over-approximations of the concrete least upper bound and greatest lower bound exist.The concrete and abstract domains are related by a concretizationγAand an abstractionαAfunctions. The abstract domain is a sound approximation of the concrete domain ifγAandαAform a Galois connection. When abstract domains do not satisfy the ascending chain condition, a widening operator∇Ais required in order to guarantee the convergence of the fixed point computation.In this section, we first introduce the concrete domain. Then we formalize the lattice structure of our abstract domain. Finally, we introduce a widening operator that is necessary for ensuring the convergence of the analysis on this domain.In this way, we provide a complete definition of an abstract domain that can be used not only to abstract single functions (as we did in the experimental results), but also to abstract a set of functions (e.g., to take into account some rounding approximations).The concrete domainDis defined as the powerset of continuous functions inR+→R(i.e., the setC+):D=℘(C+)Since in the scenario of embedded programs the input variable represents the time, the functions׳ domain isR+instead ofR.Let us first introduce the key idea behind our domain. Given a function f and a finite set of ordered indices{ti}0≤i≤N, we approximate the values of f in a step[ti,ti+1]by a trapezoid whose (i) two parallel sides are vertical, in correspondence of tiandti+1, and (ii) the other two sides are in the formf−(x)=m−x+q−andf+(x)=m+x+q+and approximate lower and upper values of f inside[ti,ti+1]. For instance, Fig. 5depicts a trapezoid defined on the step[0,3]withf−(t)=0.33t+1andf+(t)=−0.17t+3.5as lower and upper sides, respectively.Formally, given a step[ti,ti+1], a single trapezoid is defined by two linear functions, and each of these two functions is defined by two real numbers representing the slope and intercept. Therefore, the pair of sides of each trapezoid is defined by a tuplev=(m−,q−,m+,q+), wherem−,q−,m+,q+∈R∪{−∞,+∞}, which represents the two linesf−(x)=m−x+q−andf+(x)=m+x+q+. We denote byf−andf+the lower and the upper side, respectively. TSFcan be seen as a generalization of IVSF, whose two horizontal sides are parallel, i.e., withf+(x)=q+andf−(x)=q−.Note that the two lines of a trapezoid in TSFcan also go to∞. In our domain, this is represented byq−=−∞orq+=+∞.22The numerical order relationship≤is extended to consider−∞and+∞.Following the standard notation on step functions [3], consider a generic set V of values. These values could be simple numbers (integer, reals, etc.) but also more complex structures like intervals or tuples. In our domain, a value will be composed by two lines, the upper (f+) and the lower (f−) side of trapezoids. Then, we represent a step function from time to V as a conjunction of constraints of the form “ti:vi” such thatti∈R+∧vi∈V. This means that the step function switches toviat time ti. Fort∈[ti,ti+1)the function respects the constraints represented by valuevi. Whent=ti+1, the abstract value of the function switches “abruptly” tovi+1. We consider only finite conjunctions of constraints, otherwise the abstract operations of our domain would not be computable. A finite sequence of constraintsf=t0:v0∧t1:v1∧⋯∧tN:vNrepresents the step function f such that∀t∈R+:f(t)=viwithi=max({j∈[0,N]:tj≤t}). We use the compact notationf=⋀0≤i≤Nti:vi, withN∈N∧∀i∈[0,N]:(ti∈R+∧vi∈V). V is the set of tuples{(m−,q−,m+,q+):m−,q−,m+,q+∈R∪{−∞,+∞}}. To lighten up the notation, a quadruplevi=(mi−,qi−,mi+,qi+)denotesfi−(t)=mi−t+qi−andfi+(t)=mi+t+qi+. We will alternatively denote a step value asvi=(mi−,qi−,mi+,qi+)orvi=(fi−,fi+).For example, the step function h with two stepst0=0,t1=3with values, respectively,v0=(1,−1,2,1),v1=(0,3.5,13,4)will be written ash=(0:(1,−1,2,1))∧(3:(0,3.5,13,4)). The graphical representation of h is depicted in Fig. 6, where we can see the two trapezoids composing the step function. On the upper and lower sides of the trapezoids we reported the equations of the corresponding lines.However, different abstract values may represent exactly the same step function. For example, the conjunctions(0:(0,0,1,1))∧(4:(0,0,1,1))and(0:(0,0,1,1))∧(7:(0,0,1,1))define the same step function. To avoid that, we adopt the notion of normal form defined in [3]:1.the switching times tiof a conjunction are sorted and different (iff=⋀0≤i≤N{ti:vi}thent0<t1<⋯<tn<...<tN);two consecutive constraints cannot have equal values (eachvimust be different fromvi+1, that is∀i∈[0,N−1],vi≠vi+1)∀v=(m−,q−,m+,q+), ifq−=−∞thenm−=0; and ifq+=+∞thenm+=0.Given two normalized conjunctions, we define the same equality test as in [3]:⋀0≤i≤N{ti:vi}=⋀0≤j≤M{uj:wj}⟺N=M∧∀i∈[0,N]:ti=ui∧vi=wiThe normalization process induces an equivalence relation≡defined byf≡g⇔Norm(f)=Norm(g).We impose two constraints on abstract elements:(1)At each step, the two linesfi+andfi−either coincide or they do not intersect. Formally:(i)∀i∈[0,N−1]:fi−(ti)≤fi+(ti)∧fi−(ti+1)≤fi+(ti+1),fN−(tN)≤fN+(tN)∧(mN−≤mN+)wheremN−andmN+denote the slopes offN−andfN+, respectively.This assumption is not restrictive, since we can always split a step with intersecting sides into two smaller steps with not intersecting sides through the Refine operator defined in Section 2.6.Two consecutive steps of a step function must have at least one point in common. Formally:∀i∈[0,N−1],[fi−(ti+1),fi+(ti+1)]∩[fi+1−(ti+1),fi+1+(ti+1)]≠∅This means that the interval of values att=ti+1identified byviand the one identified byvi+1at the same input t must have a non-empty intersection. This constraint is needed because otherwise the concrete functions represented by the abstract element would not be continuous, and it would be abstracted by a bottom value in our domain.In Fig. 7we can see an example of an abstract state which violates this constraint. In particular, at t=3 we can see that the interval of values identified by the left trapezoid is [2, 3]. The interval identified by the right trapezoid, on the other hand, is [3.5, 5]. Since[2,3]∩[3.5,5]=∅, this abstract state is not valid and it collapses to bottom. This is a sound approximation, since there is no continuous function that may satisfy this constraint.The elements (that is, states) of our abstract domain, denoted byD♯, are (possibly normalized) finite conjunctions of constraintsf=⋀0≤i≤N{ti:vi}(withN∈N∧∀i∈[0,N]:(ti∈R+∧vi∈V)) which satisfy the constraints (1) and (2) above.Note that the abstract states of TSFrefer to the entire domainR+. Since the conjunctions we consider are finite, this means that the last trapezoid lacks its right side (it is not closed): the upper and lower sides extend (on the right) to infinity. Of course, if we restrict the domain to a finite interval, we should remove the constraint on the slopes of the last step. Fig. 8depicts the restriction of the abstract state of Fig. 6 to the Interval domain [0, 10].The abstract step function f defined by⋀0≤i≤N{ti:vi}, wherevi=(fi−,fi+)=(mi−,qi−,mi+,qi+), represents the set of continuous functions that are bounded by the linesfi−(t)=mi−t+qi−andfi+(t)=mi+t+qi+for any timet∈[ti,ti+1]. The concretization function γ is thus defined by:γ(⋀0≤i≤N{ti:vi})={g∈C+|∀i∈[0,N],∀t∈[ti,ti+1],g(t)∈[fi−(t),fi+(t)]}where ifdom(f)=R+thentN+1=+∞, whereas ifdom(f)=[0,k], with k constant, thentN<tN+1=k.Fig. 9depicts an example of an abstract state defined on the domain [0, 5] with 4 steps (note that heretN+1=5). In this figure we can see three possible concrete functions (f1=x3−7x2+12x−2,f2=ln(x+1)andf3=sin(x)) that are all approximated by such abstract state.The definition of an abstraction is not as direct as the concretization. As in the case of the polyhedral domain [5], we cannot define the best one: it is always possible to increase the quality of the abstraction by increasing the number of steps. Thus, for now, we only give a criterion (the same as [3]) for a function α to be a safe abstraction (later, in Section 3, we will provide a constructive definition of a sound abstraction function).As an abstract step functionf∈D♯can be seen as a multivalued function, we will make use of the following notation:fort∈[tj,tj+1],f(t)={v:fj−(t)≤v≤fj+(t)}.Let us now define the lower- and upper-functions for a given set of continuous real functions. LetYbe a set of continuous functions (Y∈D). We define two functionsY̲andY¯to be the inf- and sup-functions ofY:Y̲=λt.inf{y(t):y∈Y}andY¯=λt.sup{y(t):y∈Y}. The same way, we define the lower- and upper-functions of a Trapezoid Step Function. Forf∈D♯, the real-valued step functionsf̲andf¯aref̲=λt.fi−(t)andf¯=λt.fi+(t)where, in both cases,i=max({j∈N:tj≤t}). These four functions are used to define the α-Validity Condition.Definition 1α-Validity ConditionA functionα:D→D♯satisfies the α-Validity Condition (α-V.C.) if and only if for allY∈D, it holds that∀t∈R+,α(Y)̲(t)≤Y̲(t)≤Y¯(t)≤α(Y)¯(t)We now formulate the theorem that guarantees the soundness of the abstraction.Theorem 2If α satisfies the α-Validity Condition, then for everyY∈D,Y⊆γ(α(Y)).LetYbe a subset of continuous functions andf=α(Y)∈D♯. We have to prove thatY⊆γ(f). Since α satisfies the α-Validity Condition, we know that∀t∈R+,∀g∈Y,g(t)∈[f−(t),f+(t)]. Let us take ag∈Y. g is a continuous function that verifies∀t∈R+,g(t)∈[f−(t),f+(t)], thusg∈γ(f). Therefore, we have thatY⊆γ(f)□.The partial order⊆♯onD♯is defined pointwise, that is,f⊆♯gif for every possible input t, the set of values assumed by f in this point is a subset of the set of values assumed by g at the same point. Formally,f⊆♯g⇔∀t∈R+:f(t)⊆g(t).To define the partial order on step functions, we first define a partial order on single steps. Letvi=(fi−,fi+)andwj=(gj−,gj+)be the values of two steps on the same domain[a,b]withb≠+∞, or[a,+∞]. Then(1)vi⊑[a,b]wj⇔∀t∈[a,b]:fi−(t)≥gj−(t)∧fi+(t)≤gj+(t)⇔∀t∈[a,b]:[fi−(t),fi+(t)]⊆[gj−(t),gj+(t)]⇔[fi−(a),fi+(a)]⊆[gj−(a),gj+(a)]∧[fi−(b),fi+(b)]⊆[gj−(b),gj+(b)]vi⊑[a,+∞]wj⇔[fi−(a),fi+(a)]⊆[gj−(a),gj+(a)]∧(mi−≥mj−)∧(mi+≤mj+)wheremi−,mi+,mj−,mj+aretheslopesoffi−,fi+,gj−,gj+,respectively.In other words,viis smaller thanwjif the area of the trapezoid identified byvi(in the given interval) is contained in the area of the trapezoid identified bywj(in the same interval).Now we can give an effective condition for testing whetherf⊆♯g. Letf=⋀0≤i≤N{ti:vi}andg=⋀0≤j≤M{uj:wj}be two abstract states, then(2)f⊆♯g⇕∀(i,j)∈[0,N]×[0,M]:[a,b]=[ti,ti+1]∩[uj,uj+1]≠∅⇒vi⊑[a,b]wjThe condition (2) considers all intersections between steps from the two abstract states, that is, all pairs of steps(ti,uj)from f and g that have a non-empty intersection ([ti,ti+1]∩[uj,uj+1]≠∅). To check if two steps have an intersection ([ti,ti+1]∩[uj,uj+1]≠∅), we can use the conditionuj≤ti+1∧uj+1≥ti, and the intersection will be[max(ti,uj),min(ti+1,uj+1)]. For each intersection, we then compare the two values (vi,wj) in that interval.If each step value of f is smaller than the value of every intersected step of g (with respect to their intersection on the domain), thenf⊆♯g.Lemma 3Soundness of the partial orderIff,g∈D♯are normalized, thenf⊆♯g⇔∀t∈R+,f(t)⊆g(t)We distinguish the two directions:•(⇒) Letf=⋀0≤i≤N{ti:vi}andg=⋀0≤j≤M{uj:wj}, be such thatf⊆♯g, and let t be∈R+. Then there existi∈[0,N]andj∈[0,M]such thatt∈[ti,ti+1]∧t∈[uj,uj+1]. Thus,[ti,ti+1]∩[uj,uj+1]≠∅, sof(t)=[fi−(t),fi+(t)]⊆[gj−(t),gj+(t)]=g(t)by definition of⊑[a,b].(⇐) Letf,g∈D♯be such that∀t∈R+,f(t)⊆g(t). Leti,j∈[0,N]×[0,M]be such that[a,b]=[ti,ti+1]∩[uj,uj+1]≠∅, and letx∈[a,b]. Since∀t∈R+,f(t)⊆g(t), then we also have∀x∈[a,b]:f(x)⊆g(x), that is∀x∈[a,b]:([fi−(x),fi+(x)]⊆[gj−(x),gj+(x)]). Then we have thatvi⊑[a,b]wjfor each possible pair (i, j) by the second line of Eq. (1), andf⊆♯gby Eq. (2).□We can see an example of the partial order relationship between two abstract states f and g on the domain [0, 15] in Fig. 10. The abstract state f is represented with straight lines, the abstract state g with dashed lines. f is defined on the step list {0, 4, 7, 11} while g is defined on the step list {0, 5, 10}. Then the comparison is made on the following intervals: [0, 4], [4, 5], [5, 7], [7, 10], [10, 11], [11, 15]. Since in each of these intervals we have that the straight lines lie within the area defined by the dashed lines, we obtain thatf⊆♯g.The top element of the domain is defined by⊤♯=0:(0,−∞,0,∞)(that is, the step function with only one step with valueR), while⊥♯is a special element such thatγ(⊥♯)=∅∧∀f∈D♯,⊥♯⊆♯f.We define a Refine operator, which, given an abstract state of TSFand a set of indices, adds these indices to the step list of the state. The concretization of the abstract state remains the same after the application of a Refine operator, since the valuesviare not modified. This operator will be useful to make two abstract states directly comparable, by making them defined on the same step list.Consider an abstract statef=⋀0≤i≤N{ti:vi}whereT={ti:0≤i≤N}and a set of indicesS={sj:0≤j≤M}. LetR={rk:∀k∈[0,P],(rk∈(T∪S)∧rk<rk+1)}be the set of all the indices contained in T and S, ordered and without repetitions (thereforeP=N+M−|T∩S|). The Refine operator on this state is defined byRefine(f,S)=⋀0≤k≤P{rk:vk^}wherevk^=vmax{i:ti≤rk}. Intuitively, you can see that this operator does not change the abstract information of the state. In fact we can enunciate the following lemma:Lemma 4RefinementGiven a normalized abstract state f, for any set of indices S, it holds thatf≡Refine(f,S).In the Appendix section.□We can see an example of the Refine operator in Fig. 11. The step list of the original abstract state is [0, 5, 11], while the set of indices I is [2, 6, 9, 14]. On the left we depict the original abstract state, on the right its refined version with respect to I (the vertical lines are dashed in correspondence with the indices of I).The Refine operator will be used when dealing with two abstract states together (for example, in the least upper bound operator) to refine both states through the set of indices of the other state. For example, if f and g are the two abstract states being considered, the preliminary step is to refine f with the steps of g, and to refine g with the steps of f. In this way, we obtain two abstract states defined on the same set of indices (that is, the union of the two original step lists).Notice that the abstract state resulting from a refinement operation is, in general, not normalized, because it violates the second condition (i.e., two consecutive constraints cannot have equal values). This is not a problem, since the refinement is used as a preliminary step of various operations (glb, lub,…), and normalization is applied on their final result.Given two elements x and y of the abstract domain, the greatest lower bound operator defines the greatest elementz=x∩♯ythat under-approximates both x and y. In TSF, this means that we have to create a sequence of trapezoids that are (i) as vast as possible and (ii) contained in both the given sequences of trapezoids.Letf′=⋀0≤k≤N{xk:vk}andg′=⋀0≤j≤M{uj:wj}be two abstract states defined on the step listsV={xk:k∈[0,N]}andU={uj:j∈[0,M]}, respectively (note thatN+1=|V|andM+1=|U|, that is, the number of steps of an abstract state corresponds to the cardinality of its step list). Letmin(l1(t),l2(t),[a,b])be an operator which compares the linesl1(t)andl2(t)in the domain range[a,b]and returns the one which is always below the other one, under the assumption that the two lines do not intersect in such range. Sincel1(t)andl2(t)are straight lines, it suffices to compare their values in t=a and t=b. Letmax(l1(t),l2(t),[a,b])be the opposite operator, which returns the line always above. Let StepList(f) be a function which, given an abstract state f, extracts its step list. Then, we can write the formal definition of the greatest lower bound off′andg′(i.e.,f′∩♯g′)as the result of the algorithm depicted in Fig. 12:An informal description of this algorithm is as follows:Step 1 (lines 1–3 of the algorithm):In order to make the two abstract statesf′,g′directly comparable, we refine them on the same step list, creating two new abstract statesf,g. Letf=Refine(f′,U)andg=Refine(g′,V)be these two new states. By Lemma 4, these refined states are equivalent tof′andg′, so the greatest lower bound off,gis also the greatest lower bound off′,g′.LetT={ti:i∈[0,P−1]}(whereP=|V∪U|=|T|) be the step list of f and g. Let(fi−,fi+),(gi−,gi+)be the values (i.e., lower and upper sides) off,gin the generic step[ti,ti+1]. We will split each step[ti,ti+1]into sub-steps, with respect to intersections of the sides of the two trapezoids (one from f, one from g, lines 9–21). This applies also for the last steps. If there is no intersection, we leave the step unchanged (line 26). Each step[ti,ti+1]will then generate one (or more) steps inf∩♯g, depending on the intersections of the sides in such step. The goal is to obtain sub-steps in which the sides of the two trapezoids do not intersect each other in any point inside the sub-step range.By the first constraint on abstract elements, we know that, inside a step, the upper and lower side of a trapezoid do not intersect. In fact, the two sides could have an extreme in common (the value at tior atti+1) or they could be the same line, but they surely do not have an intersection point inside[ti,ti+1], otherwise they would violate the first constraint (Eq. 2.2). For this reason, we know for sure thatfi−,fi+do not intersect each other, and the same holds forgi−,gi+. The possible intersections inside(ti,ti+1)(extremes excluded) are then: (1) betweenfi−andgi−, (2) betweenfi+andgi+, (3) betweenfi−andgi+, and (4) betweenfi+andgi−.In cases 1 and 2 (intersection betweenfi−,gi−or betweenfi+,gi+, lines 9–21), we split the step in sub-steps with respect to the intersection point. Note that we could obtain two or three sub-steps: if onlyfi−,gi−intersect each other (lines 17–18) then we have two sub-steps (and the same happens if the only intersection regardsfi+,gi+, lines 20–21 – see Fig. 13(d) – but if there are two intersections (one betweenfi−,gi−and the other betweenfi+,gi+, lines 12–14 – see Fig. 13(e) – then we obtain three sub-steps.In cases 3 and 4 (intersection betweenfi−,gi+– Fig. 13(b)) or betweenfi+,gi−(Fig. 13(c), lines 7–8), instead of splitting the step with respect to the intersection point, we immediately return⊥♯as result of the∩♯operation. In fact, assume thatfi−,gi+have an intersection (the same reasoning holds if the intersection is betweenfi+,gi−). Then, at one extreme of the step (i.e., at tiorti+1), the lower side of the trapezoid of f (fi−) is greater than the upper side of the trapezoid of g (gi+). This means that, at such point, the two states have no value in common since the areas of the trapezoids do not intersect: the lowest value assumed by the continuous functions abstracted by f is greater than the greatest value assumed by the continuous functions abstracted by g. The result of the greatest lower bound must therefore be⊥♯.If the step[ti,ti+1]does not contain any intersection, two cases apply:•If[fi−(ti),fi+(ti)]∩[gi−(ti),gi+(ti)]=∅∨[fi−(ti+1),fi+(ti+1)]∩[gi−(ti+1),gi+(ti+1)]=∅(Fig. 13(a), lines 22–23) then we return⊥♯, because in this case at one extreme of the step (i.e., at tiorti+1) the lowest value of one state is greater than the greatest value of the other one.Otherwise, we do not need to split the step (line 25), since we are in the case sketched by Fig. 13(f).We know for sure that, in each of the sub-steps generated by the algorithm: (i) the two states have some values in common (i.e., the areas of the trapezoids have a non-empty intersection) at each point of the sub-step; (ii) inside the sub-step the four sides of the two trapezoids derived from f and g do not have any intersection. Then, for each sub-step it is easy to compute the value of the corresponding trapezoid of the result (f∩♯g): the lower side will correspond to the greatest of the two lower sides off,gin the sub-step, while the upper side will correspond to the lowest of the two upper sides off,gin the sub-step. In Fig. 13(d), (e) and (f) we can see the result of this procedure in three different cases (step split into two substeps, step split into three substeps, step not split, respectively). The gray area represents the resulting trapezoids off∩♯g. We add the newly generated sub-steps to the result at line 26 (at the end of each iteration of the loop).At the end of the computation (lines 28–32) we normalize the resulting abstract state using Norm (line 31). It could happen that the intervals identified by the two sides of two consecutive steps do not intersect at the border between the two steps (for an example, see Fig. 14, where the straight lines represent the trapezoids of f, the dashed lines represent the trapezoids of g and the darkened areas represent the trapezoids off∩♯g). For this reason, we check if the second constraint is satisfied (that is, we are not in the situation of Fig. 14). If the check fails, we return⊥♯as result of the glb operation (lines 28–31). In fact, this means that the two multivalued functions f and g do not have any possible value in common at that border and thus their lower bound in the TSFdomain does not exist.In conclusion, the intersectionf∩♯gcreates a new step function whose value is at every time t the intersectionf(t)∩g(t). If this intersection is empty in at least one point, we cannot return a continuous abstract function and then we definef∩♯gas⊥♯, the bottom element ofD♯.Lemma 5∩♯maintains the constraint satisfactionLet f and g be two abstract states which both respect the constraints enunciated inSection 2.2and which are defined on the same set of indicesT={ti:i∈[0,N]}(if this is not the case, we can apply the Refine operator). Letf∩♯g=hbe the result ofAlgorithm 12. Then, h respects the two constraints too.In the Appendix section.□Letf,gbe two abstract states and leth=f∩♯gbe the result ofAlgorithm 12. Then, h is the greatest lower bound of f and g, i.e.:1.h⊆♯f∧h⊆♯gk⊆♯h∀klower bound of f and gIn the Appendix section.□Given two elements x and y of the abstract domain, the least upper bound operator defines the least element z that over-approximates both x and y. In TSF, this means that we have to create a sequence of trapezoids that are as narrow as possible and that, at the same time, contain the two given sequences of trapezoids.Letf′=⋀0≤k≤N{xk:vk}andg′=⋀0≤j≤M{uj:wj}be two abstract states. In order to define the least upper bound off′andg′, we use an algorithm very similar to the one presented for the glb in Section 2.7. First, we refinef′andg′on the same step list, obtainingf=Refine(f′,U)andg=Refine(g′,V)where V and U are the step list off′andg′, respectively. Then, for each step of f and g we look at the two trapezoids and check if there are intersections either between the two lower sides (fi−,gi−) or between the two upper sides (fi+,gi+). We split the step with respect to such intersections; if there are none, the step remains unsplit. In each of these new steps, we are sure that neither the upper sides nor the lower sides intersect each other. So, the resulting trapezoid for each new step is made by the greatest of the upper sides and the lowest of the lower sides. The algorithm is depicted in Fig. 15. For some examples, see Fig. 16.The algorithm is very similar to the one introduced for the glb, with the following differences:•min and max are reversed, since here we keep the lowest line betweenfi−,gi−and the greatest line betweenfi+,gi+in order to over-approximate fiand gi;we never return⊥♯because the lub between two values is always possible and it also satisfies, by construction, the constraints of Section 2.2.Letf,gbe two abstract states which both respect the constraints enunciated in Section 2.2 and which are defined on the same set of indicesT={ti:i∈[0,N]}(if it is not the case, we can apply the Refine operator). Letf∪♯g=hbe the result of Algorithm 15. Then, the abstract state h satisfies the two constraints too.In the Appendix section.□∪♯is a least upper bound operator. Letf∪♯g=hbe the result ofAlgorithm 15. Then, h is the least upper bound of f and g, i.e.:1.f⊆♯h∧g⊆♯h.h⊆♯k∀kupper bound of f and g.In the Appendix section.□The dual operator of Refine is Compact. This operator reduces the number of steps contained in an abstract state, and it is useful in order to keep it below a given threshold and make the analysis convergent (throughout the widening which exploits this operator). Compact works by merging a pair of steps into a single one, and by repeating the same procedure until the threshold is reached. While Refine leaves the precision of an abstraction unchanged, the Compact operator induces some loss of precision, since it merges together some steps.Letf=⋀0≤i≤N{ti:vi}be an abstract state, and let M be the threshold to reach, withM<N+1. The algorithm (i) chooses the step with the minimum width (wi=ti+1−ti), (ii) merges it with the next one, and (iii) repeats (i) and (ii) iteratively until the threshold M is reached. We choose the step to be merged as the smallest one (i.e., the one with the smallest width), but this choice is arbitrary: alternative solutions are possible (for example considering the similarity of values of successive steps) and can be supported by our approach as well. Another possibility would be to minimize the difference between the slopes and intercepts of corresponding lines, that is, the following quantity:(|mi+−mi+1+|)+(|qi+−qi+1+|)+(|mi−−mi+1−|)+(|qi−−qi+1−|)As for the creation of the merged step, letAi,Bibe the two extremes (the left and right ones, respectively) offi+in[ti,ti+1], and letAi+1,Bi+1be the two extremes offi+1+in[ti+1,ti+2]. Then the upper sidef′+of the merged step will have the slope of the side linking AiandBi+1. If the pointP=max(Bi,Ai+1)is above such side, the intercept will be such that the side covers exactly P, otherwise the original intercept of the side linking AiandBi+1is kept, as depicted in Fig. 17. The same applies symmetrically for the lower side: we consider the minimum between the two points atti+1and we check if such point is below the side linking the two extremes at tiandti+2.A slightly different process is required if the selected step is next to last (that is, i=N), since in such case we cannot rely onti+2. For the upper side, we considerfN+and we increase its intercept if one of the extremes offN−1+in[tN−1,tN]is greater than such side. The same procedure applies symmetrically for the lower side.In addition, we can specify a list of steps which we do not want to remove from the state. Let T be the step list of the abstract state f, and letX⊆Tbe the step list of f that have to be preserved. Obviously, if M is the number of steps we want in the resulting abstract state,|X|≤Mholds. Then,g=CompactX(f,M)is an abstract state obtained by compacting f to M steps, and discarding only steps coming fromT\X. The algorithm presented above can be applied in this case as well by considering only the steps inT\Xwhen selecting the steps to remove.It is worth stressing that the Compact operator as defined above is likely to be non-deterministic, since there might be many steps having the minimal width; the same holds for other selection criteria, and that in general it is not confluent, i.e., the non-determinism actually leads to computing different results. Note also that the single compaction steps composing the Compact operator do not enjoy any associativity property; that is, even when compacting the very same steps, if these are compacted using a different ordering (e.g., left-to-right vs right-to-left) a different final result would be obtained. Following all the observations above, more precise results can be obtained either by a different choice of the steps to be merged, or by compacting many consecutive steps in a single operation, rather than one at a time, according to suitable heuristics.Lemma 9Soundness of CompactLetf∈D♯andM∈N. Ifg=Compact(f,M), thenf⊆♯g.In the Appendix section.□The widening operator is parameterized on (i) kS, corresponding to the maximum number of steps allowed in an abstract state, (ii)kM,kQ, corresponding to the maximum value allowed for the slope and intercept of trapezoid sides respectively, and (iii)kI,kL, corresponding to the increment constants for the slope and intercept respectively. All these parameters have to be positive. Thanks to these parameters, we can tune the widening operators at different levels of precision and efficiency.The widening operator∇D♯is then defined as follows:∇D♯:(D♯,D♯)→D♯f∇D♯g={⊤♯if|U|>kSfifg⊆♯fCompactU(hMQ,kS)otherwisewhere U is the step list of the abstract state f.We distinguish three cases:|U|>kS:f exceeds the maximum number of steps allowed in an abstract state, kS, and we return⊤♯.We have reached a stable iterate, and we simply return f.We return the compacted version of hMQ, keeping all the steps U of f (we know that|U|≤kS, otherwise we would have returned⊤♯). In this way, we are sure that U will be a subset of the step list of the result (f∇D♯g). The abstract state hMQis built as follows. Let f be defined on the step list U, and g be defined on the step list V. Letf′=Refine(f,V)be the refined version of f with the addition of the indices of g, andg′=Refine(g,U)the refined version of g with the addition of the indices of f. Thenf′andg′are defined on the same step listT=U∪V. So we have thatf′=⋀0≤i≤N{ti:vi=(fi−,fi+)}andg′=⋀0≤i≤N{ti:wi=(gi−,gi+)}. We define hMQashMQ=⋀0≤i≤N{ti:zi=(hi−,hi+)}where(hi−,hi+)are defined as follows:hi−(x)={gi−(x)iffi−=gi−−∞if(mgi−≤−kM)∨(qgi−≤−kQ)∨(mfi−≤−kM)∨(qfi−≤−kQ)(gi−)•(x)otherwisehi+(x)={gi+(x)iffi+=gi++∞if(mgi+≥kM)∨(qgi+≥kQ)∨(mfi+≥kM)∨(qfi+≥kQ)(gi+)°(x)otherwiseand(gi−)•(t)=(mMINi−−kI)×t+(qMINi−−kL)(gi+)°(t)=(mMAXi++kI)×t+(qMAXi++kL)mMINi−=min(mfi−,mgi−)qMINi−=min(qfi−,qgi−)mMAXi+=max(mfi+,mgi+)qMAXi+=max(qfi+,qgi+)The computation is symmetric for the lower and upper side, so let us focus onhi+(x). For each step tioff′andg′we consider three distinct cases:•fi+=gi+: the side is the same inf′andg′, so we keep it unchanged.(mgi+≥kM)∨(qgi+≥kQ)∨(mfi+≥kM)∨(qfi+≥kQ): the slope (or the intercept) of the side of one abstract state (g′orf′) exceeds the threshold kM(kQ), so we move the side to+∞.Otherwise, we keep the maximum slope and intercept between their values infi+andgi+and then we increase them both by a predefined constant quantity (kIfor the slope, kLfor the intercept).Intuitively, the convergence is guaranteed by the combination of:•the application of compact with the parameter kS;the parameters kMand kQthat limit the maximal values allowed for the slope and the intercept of a line, respectively. If a certain line exceeds one of these two values, then it goes to±∞, stopping its possible growth in that direction;the •and○operators, that shift a side down (•) and up (○) for a predefined amount respectively. In particular, referring to○, the maximum slopemMAXi+between the ones offi+andgi+is increased by kI, while the maximum interceptqMAXi+between the one offi+andgi+is increased by kL. kIand kLare positive values and ensure that we will reach the convergence in a finite number of steps.Since the normalization may interact to prevent the termination of the iterative sequence, a normalization step is not performed at each step. Therefore, the result of a widening operation might need to be normalized, like in the case of the widening for reduced product [10]. It should be worth noting that an alternative approach may be considered where the semantic nature of abstract elements is preserved, so that the result of the widening will not depend on the synctactic representation considered. For the case of the domains of Octagons, this has been done in [11].For the soundness of this operator we refer to the definition of [12,13], through the two properties of covering and termination.Lemma 10Correctness of∇D♯The widening operator∇D♯is correct, that is, it respects the properties of covering and termination:1.Covering:∀f,g∈D♯:f⊆♯(f∇D♯g)∧g⊆♯(f∇D♯g).Termination: for every ascending chain{fj}j≥0, the ascending chain defined asg0=f0;gj+1=gj∇D♯fj+1stabilizes after a finite number of terms.In the Appendix section.□Notice that the widening operator defined above is just one of the (many) possible widening operators that may be defined onD♯. As a valuable alternative, we might adopt a partitioning on the left argument, as in [14,15]. The advantage of limiting the step list by refraining from adding new ones is that there would be no need of replacing the whole element by⊤♯as we do when the number of steps is greater than kS. It would be interesting as a future work to investigate the tradeoff between efficiency and accuracy of different widening operators on TSF.Theorem 11Let[D♯]be the set of equivalence classes ofD♯wrt the normalization operator. Then([D♯]∪{⊥♯},⊆♯,⊥♯,⊤♯,∪♯,∩♯)is a lattice.By Lemma 3 we get that⊆♯is a partial order, by Lemma 8 that∪♯is the least upper bound operator, by Lemma 6 that∩♯is the greatest lower bound operator.□We also proved the correctness of the widening operator∇D♯in Lemma 10. Therefore, we have defined and proved the correctness of the basic operators required to define an abstract domain in the abstract interpretation framework [1,2]. The basic operators defined are all that is needed when simply approximating the value of a continuous function that can be read by the program. Notice however that the concrete semantics for imperative programs might require more operators than those defined above. E.g., the computation of expressions and assignments is modelled by affine images and preimages, while conditional tests are modelled by constraint addition or the so-called filters.In this section, we show how to compute the approximation of continuous functions in IVSFand TSF. We consider IVSFas well since [3] did not define its abstraction function, because they relied on a particular type of ODE solver [16]. In the rest of this section, we restrict our attention onC+2functions, as for IVSFwe handle with functions׳ concavity and convexity. However, this restriction may be relaxed yielding to a less precise abstraction in the general case: if the function is not inC+2in a given interval, in that step it can be safely abstracted by(0,h,0,k)if the image of f is bounded in[h,k], and by(0,−∞,0+∞)otherwise. Notice that by ”precision” of an abstract representation we mean its total area on a given (finite) interval: when the area is smaller, the abstract representation is more precise.For both domains IVSFand TSFwe consider two different approaches: when the step width is constant and fixed, and when we automatically determine the step distribution. Note that we abstract only one concrete function; this approach can be generalized to the abstraction of a finite set of concrete functions C by computing the abstraction of each function in the set and then returning the least upper bound of all the resulting abstract states.In the following subsections, we will denote by:•f∈C+2– the continuous function we want to abstract;f′,f″– its first and second derivatives;F0′– the set containing the points of the domain wheref′(x)=0(the minimum and maximum points of the function), that is,F0′={t:f′(t)=0};F0″– the set containing the points of the domain wheref″(x)=0(the inflection points), that is,F0″={t:f″(t)=0};G0′[a,b]– the set containing the maximum and minimum points of f restricted to the domain interval[a,b], that is,G0′[a,b]={f(t):t∈([a,b]∩F0′)};G0″[a,b]– the same set but for the inflection points, that is,G0″[a,b]={f(t):t∈([a,b]∩F0″)}.Given a fixed step width w, suppose that[a,b]is a generic interval (b−a=w∧a=k×w∧b=(k+1)×w∧k≥0,w>0).M=max({f(a),f(b)}∪G0′[a,b])is the maximum point of the function in the interval[a,b], extremes included, andm=min({f(a),f(b)}∪G0′[a,b])is the minimum point of the function in the interval[a,b], extremes included. The best abstraction in IVSFof this step is the interval[m,M]. To build the abstraction of the function f, we repeat this procedure for each step of the abstract state.For the IVSFabstract domain, we cannot find a priori the best way to split the domain of f into sub-intervals. We could use different techniques, for example:•splitting in correspondence of the inflection points of the function, andsplitting in correspondence of the intermediate point between each pair of minimum/maximum points.Once chosen a technique for splitting the domain in steps, we can apply the procedure introduced in Section 3.1 to compute the abstraction of each single step.In TSFa very good trade-off between complexity and precision of the abstraction can be achieved by splitting the domain in correspondence of (i) the maximum and minimum pointsF0′, and (ii) the inflection pointsF0″, in order to split the function into its convex and concave parts.Assume that[a,b]is a generic sub-interval obtained using this schema. Then the two sides which compose the value of such step are the following ones (see Fig. 18):(1)The side l1 linking the pointsP=(a,f(a))andQ=(b,f(b))(the points of f in correspondence of the extremes of the interval[a,b]).The side l2 which has the same slope as l1 and is tangent to f inside[a,b]. Since we already know the slope of this side, we just need to compute its intercept. The procedure is the following one:(a)Find the pointxR∈[a,b]where the first derivative of f is equal to the slope of l1:f′(xR)=ml1. This point can be computed by bisection in[a,b]. Notice that this point is unique because, after splitting, the interval does not contain any inflection point.Let R be the point with coordinates(xR,f(xR)). Then l2 is the side that goes through the point R and with slope equal to the one of l1 (ml2=ml1). The intercept is computed as follows:ql2=f(xR)−ml2×xR.Note also that the abstraction procedure introduced above can be further refined so that TSFis always as precise as IVSFby splitting the steps where the upper or lower side intersects the tangent at points of zero derivative. In the case of thesin(x)function, this leads to the abstraction depicted in Fig. 3.Also in the case of TSFwe can define the abstraction on a fixed step width. Suppose that[a,b]is a generic interval determined by a fixed width w. First of all, we split the interval into sub-intervals, following the schema introduced in Section 3.3. Then for each sub-interval, we compute the upper and lower sides as specified in Section 3.3. Finally, we have to “join” these sub-intervals into a single one (with range[a,b]) through the Compact operator (see Section 2.9).Observe that the abstraction function of IVSFis less restrictive than the one of TSF, since TSF׳s abstraction needs the second derivative of the function to know the inflection points.Unfortunately, the abstraction technique presented in Section 3.3 is theoretically sound but it might be not computable on a finite precision machine, due to the rounding issues of floating point representation. The abstraction function depends on various values: the stationary points (F0′), the inflection points (F0″), the pointxr∈[a,b]such thatf′(xR)=ml1. Even knowing exactly all the points inF0′andF0″by mathematical analysis, we may not be able to precisely represent them in a machine (e.g.,2).In this section, we introduce a refinement of the basic abstraction function proposed in Section 3.3 to enforce the soundness of the resulting abstraction function in a floating point computation. In this scenario, only a bounded domain is considered.For each real value a, we denote bya<anda>the interval floating number representation such thata<≤a≤a>.Like in Section 3.3, we split the domain in steps with respect to the stationary points (F0′) and the inflection points (F0″). We consider as splitting points the setS={t<,t>:t∈F0′∪F0″}.For each step[t<,t>], leta1=min{(f(t<))<,(f(t))<,(f(t>))<}anda2=max{(f(t<)>,(f(t))>,(f(t>))>}. Then, we can abstract the function f in the step[t<,t>]by(0,a1,0,a2).Let us consider now a step[a>,b<], wherea≠bare consecutive elements in S. Let us refer to the scenario depicted in Fig. 19(the other cases can be treated similarly). The two sides which compose the value of such step are the following ones:1.Consider the segment l1 linking the points(a>,(f(a))>)and(b<,(f(b))>)(the overapproximations of the points of f in correspondence of the extremes of the interval[a>,b<]). Let m be the slope of l1 (dotted line in the figure). The upper side will be the segment passing through(a>,f(a)>)with slopem>.Consider the segment l2 which has as slopem<and is tangent to f inside[a>,b<]. We need to compute its intercept. The procedure is the following one:(a)Find the pointxR∈[a>,b<]where the first derivative of f is equal tom<:f′(xR)=m<. This point can be computed by bisection in[a,b].Let R be the point with coordinates((xR)>,(f(xR))<). Then the lower side is the segment passing by R and with slope equal tom<. The intercept is computed as follows:(f(xR))<−m<×(xR)>.

@&#CONCLUSIONS@&#
