@&#MAIN-TITLE@&#
The intelligent memory allocator selector

@&#HIGHLIGHTS@&#
Our solution is an intelligent memory allocator selector for operating systems.The solution selects an efficient and fastest memory allocator for each process.The approach reduces memory fragmentation, and increases system performance.Our solution is a dynamic and efficient solution to memory fragmentation problem.

@&#KEYPHRASES@&#
Memory fragmentation,Memory allocator,Garbage collection,Virtual machine,

@&#ABSTRACT@&#
Memory fragmentation is a serious obstacle preventing efficient memory usage. Garbage collectors may solve the problem; however, they cause serious performance impact, memory and energy consumption. Therefore, various memory allocators have been developed. Software developers must test memory allocators, and find an efficient one for their programs. Instead of this cumbersome method, we propose a novel approach for dynamically deciding the best memory allocator for every application. The proposed solution tests each process with various memory allocators. After the testing, it selects an efficient memory allocator according to condition of operating system (OS). If OS runs out of memory, then it selects the most memory efficient allocator for new processes. If most of the CPU power was occupied, then it selects the fastest allocator. Otherwise, the balanced allocator is selected. According to test results, the proposed solution offers up to 58% less fragmented memory, and 90% faster memory operations. In average of 107 processes, it offers 7.16±2.53% less fragmented memory, and 1.79±7.32% faster memory operations. The test results also prove the proposed approach is unbeatable by any memory allocator. In conclusion, the proposed method is a dynamic and efficient solution to the memory fragmentation problem.

@&#INTRODUCTION@&#
Memory fragmentation is a serious obstacle preventing efficient usage of memory. It appears in time while program is allocating and deallocating memory, shown in Fig. 1. In the last situation of the figure, there are 9 blocks of free memory; however, even 4 blocks of memory cannot be allocated due to fragmentation.Memory fragmentation can be split into two types: external and internal fragmentation. From operating system perspective, external fragmentation describes fragmentation between processes. Hence, internal fragmentation occurs inside of the processes.In modern computers, external fragmentation was solved utilizing paging, detailed in Section 2.1[1–3]. Internal fragmentation was solved utilizing memory compaction of garbage collectors (Section 2.2). However, due to serious performance impact, memory and energy consumption [4–6], it is an inefficient solution. Even further, some garbage collectors do not support memory compaction; thus, they do not prevent memory fragmentation, such as Android KitKat and predecessors [7]. Therefore, internal fragmentation is still a challenging problem in this area.For avoiding disadvantages of garbage collectors, memory allocators were developed for general purpose [8–12], multi-threaded processes [13], network applications [14], object oriented programming languages [15,16], video-on-demand servers [17], etc.Modern operating systems assign a default memory allocator to every process. If this memory allocator was insufficient for the application then software developers should determine and add the most efficient and fastest memory management algorithm for their applications [18]. However, if the developer had no knowledge about memory allocators then the application would lose performance and memory. Instead of forcing developer to select a memory allocator, operating system should determine memory management algorithm for each process to accomplish the best performance and efficiency.In this work, we propose an intelligent memory allocator selector (IMAS) that dynamically decides the best memory allocator for each process. The IMAS tests each process separately with various memory allocators. After the testing, it selects an efficient memory allocator. It also adopts to the operating system (OS) conditions. If OS runs out of memory then the IMAS selects the most memory efficient memory allocator for new processes. If processes consume most of the CPU power then it selects the fastest memory allocator. Otherwise, the balanced memory allocator is selected.The IMAS has a test system, which logs CPU performance values and memory fragmentation ratios. These test results are used to select efficient memory allocator for processes. Therefore, they can be used for comparison between memory allocators and the IMAS. Tests have been done in a regular personal computer during its daily activity. 107 processes have been fully tested during our tests. According to test results, the IMAS provides up to 58% less fragmented memory than default memory allocator of OS. In average of 107 processes, the IMAS is 7.16±2.53% memory efficient. For CPU performance, the IMAS is up to 90% faster; and in average, it is 1.79±7.32% faster.Test results prove our claims, the IMAS minimizes memory fragmentation by selecting an efficient memory allocator for each process. Therefore, memory management is done in faster and more efficient way.The rest of the paper is organized as follows: Section 2 recalls the previous works. Section 3 presents details of the proposed solution. Section 4 gives the test results and discussion. Finally, Section 5 concludes the paper.In modern computers, processes live in virtual address space, which is isolated from real address space [1]. In virtual address space, process thinks that it has all of the memory (except kernel memory), shown in Fig. 2.The memory address in virtual address space, called logical address, translated to real address utilizing memory management unit (MMU), shown in Fig. 3. MMU uses segmentation and paging to translate logical address to physical address.Paging unit splits whole memory into the pages, shown in Fig. 4[1–3]. It maps only occupied pages into the physical memory. In physical memory, each page can be in different places and different order. Therefore, external memory fragmentation does not occur.Garbage collection (GC) is an automatic memory management system [19]. By the aid of GC, allocated memory areas do not need to be deallocated by the developer. GC does the deallocation automatically.In unmanaged programming languages (C, C++, Pascal etc.), memory pointers are volatile and GC cannot change them. However, in managed programming languages (Java, C# etc.), virtual machine (VM) manages the memory operations; therefore, pointers can be changed easily [20,21]. Utilizing GC and VM, memory fragmentation can be prevented by compacting memory regions, shown in Fig. 5[22].However, GC and VM operations cause serious performance penalties. In the first place, managed language code is not compiled into machine code. Instead, it is compiled into intermediate code [23]. The intermediate code is compiled into machine code during execution of the program. This compilation operation costs memory, CPU power, and energy consumption [4]. Furthermore, programs using GC run 70% slower when two times more memory supplied [5]. The programs need three times more memory for running 17% slower. Also, GC operations consume up to 40 times more energy than explicit memory allocators [6].In conclusion, GC and VM may prevent memory fragmentation; however, this returns as significant performance impact, memory and energy consumption. Therefore, this solution cannot be considered as an efficient method for memory fragmentation.The intelligent memory allocator selector (IMAS) has been developed under 32-bit Ubuntu Linux (version 12.04) OS. It is selected because of being open source and more suitable for developing system applications than Windows. Furthermore, it is prevalent server and embedded system OS; therefore, most servers and embedded systems will take advantage of the IMAS.The purpose of the IMAS is choosing a decent memory allocator for each process. Therefore, it has a collection of memory allocators for testing with every process. Some of the essential memory allocators are selected into the collection for testing the IMAS. These memory allocators are the default memory allocator of the OS, hoard, thread-caching malloc (TCMalloc), and jemalloc. Hoard was developed for parallel running applications [13]. Google has been developing TCMalloc and using for Chrome internet browser [10]. Firefox and facebook have been using jemalloc for firefox browser and facebook server applications, respectively [24,11].These allocators are tested for memory operation performance and memory fragmentation. When all memory allocators were tested, the IMAS categorizes the fastest, the most memory efficient and the balanced libraries for the process. The fastest library is the least time consuming library during memory operations. The most memory efficient library is the library with minimum memory fragmentation. The balanced library is the fastest and also the most memory efficient one. According to the OS conditions, the IMAS uses the appropriate library. When average CPU load was greater than or equal to 75%, the IMAS chooses the fastest library for new process. If available memory of the system is lower than average memory usage of the process then the most memory efficient library is loaded. For other situations, the IMAS loads the balanced library. Therefore, according to the system load, the IMAS selects the best memory allocator for the processes.The IMAS needs to replace memory allocator of processes for loading appropriate memory allocator. Therefore, it hooks memory allocation functions, which are malloc, calloc, realloc, memalign, posix_memalign, valloc, pvalloc, free, mallopt, malloc_usable_size, cfree. Also, pthread_create and pthread_exit functions need to be hooked due to some memory allocators do some operations before creation and destruction of threads. The functions are briefly explained in Table 1.The imas.so is a shared object (dynamic link library), responsible part of the IMAS for hooking. It injects itself into every process utilizing possibilities of Linux OS [25]. Therefore, it is loaded before every other library, and its functions are loaded before the default memory allocator of the process. Thus, the IMAS hooks memory functions.Algorithm 1The imas.so initialization.1:ifis_process_excluded()then2:load_malloc_library(system_library);3:return;4:end if5:6:perf_res=load_performance_results();7:/⁎ Average memory used by the fastest library ⁎/8:avg_mem[0]=perf_res.summary[perf_res.result[0]].avg_mem;9:/⁎ Average memory used by the most memory efficient library ⁎/10:avg_mem[1]=perf_res.summary[perf_res.result[1]].avg_mem;11:cpu_load=get_cpu_load();12:free_ram=get_free_ram();13:14:ifperf_res.test_modethen15:malloc_library=perf_res.next_library;16:else ifcpu_load≥75andfree_ram≥avg_mem[0]then17:malloc_library=perf_res.result[0];18:else ifcpu_load<75andfree_ram<avg_mem[1]then19:malloc_library=perf_res.result[1];20:else21:malloc_library=perf_res.result[2];22:end if23:load_malloc_library(malloc_library);24:25:ifperf_res.test_modethen26:imas_perf_init();27:imas_perf_test_mode=perf_res.test_mode;28:end ifWhen the imas.so loaded with the process, it does initialization, shown in Algorithm 1. It checks if the process is excluded by the IMAS. Some programs are not compatible with some memory allocators; therefore, a function has been implemented for excluding these programs. If the process is excluded, it loads system memory allocator and exits from initialization. Otherwise, previously saved performance results are loaded. Afterwards, five-minute CPU load and free memory of the system are retrieved. According to CPU load and available memory size, the IMAS loads appropriate memory allocator for the process. If the system is overloaded and there is enough memory for the process, the IMAS loads the fastest memory allocator for the process, shown at lines 16–17 in Algorithm 1. However, if the system is not overloaded and there is not enough memory to run the process; the IMAS loads the most memory efficient library, shown at lines 18–19. In other cases, the IMAS loads the balanced memory allocator for the process. If the IMAS is in test mode, it loads next library for testing, shown at lines 14–15, and initializes the test mode, shown at line 25.Algorithm 2Hooked malloc function of the imas.so.Require: Size (size) of the will be allocated memory areaEnsure: Pointer (p) of the allocated memory area1:PERF_TYPE(TYPE_MALLOC);2:PERF_BEGIN(NULL);3:p=imas_malloc(size);4:PERF_END(p);Hooked realloc function of the imas.so.Require: Previous memory area pointer (ptr), and size (size) of the new memory areaEnsure: Pointer (p) of the reallocated memory area1:PERF_TYPE(TYPE_REALLOC);2:PERF_BEGIN(ptr);3:p=imas_realloc(ptr, size);4:PERF_END(p);Hooked memalign function of the imas.so.Require: Alignment value (alignment), and size (size) of the will be allocated memory areaEnsure: Pointer (p) of the allocated memory area1:PERF_TYPE(TYPE_MEMALIGN);2:PERF_BEGIN(NULL);3:p=imas_memalign(alignment, size);4:PERF_END(p);Hooked free function of the imas.so.Require: Pointer (ptr) of the memory areaEnsure: Frees the memory area1:PERF_TYPE(TYPE_FREE);2:PERF_BEGIN(ptr);3:imas_free(ptr);4:PERF_END(NULL);PERF_BEGIN macro.Require: Pointer (ptr) of the preallocated memory areaEnsure: Gets and stores preliminary performance values1:ifimas_perf_test_modethen2:ifptr≠NULLthen3:allocated_size[0]=imas_malloc_usable_size(ptr);4:end if5:6:start=get_time();7:end ifPERF_END macro.Require: Pointer (ptr) of the allocated memory areaEnsure: Calculates performance values and writes them into the log file1:ifimas_perf_test_modethen2:end=get_time();3:4:ifptr=NULLandtype=TYPE_REALLOCthen5:allocated_size[0]=0;6:end if7:8:ifptr≠NULLthen9:allocated_size[1]=imas_malloc_usable_size(ptr);10:end if11:12:time_diff=end - start;13:allocated_memory_size=allocated_size[1] - allocated_size[0];14:write_to_log(type, time_diff, allocated_memory_size);15:end ifIf performance test mode is enabled, the imas.so tests the malloc, realloc, memalign, and free functions from the aspects of performance and memory fragmentation. Because of other hooked functions (except thread functions) call these functions, it is enough doing tests for only the functions.Algorithms of the functions are given in Algorithms 2–5. As seen in the algorithms, PERF_ macros are doing the performance tests, given in Algorithms 6 and 7. C macros were used for avoiding function calls and better performance measurement. For better understanding, think macros as functions, and their source codes are printed directly in where they are used.PERF_TYPE macro defines the test type, which will be used by other macros for categorizing tests. PERF_BEGIN stores the preallocated memory area size, and gets the system time, given in Algorithm 6. After the memory operation, PERF_END gets the system time and calculates the passed time during the operation, shown at lines 2–12 in Algorithm 7. It calculates allocated memory size for calculating memory fragmentation later, shown at line 13. Finally, it logs results by using another thread for avoiding performance impact on memory operations during tests. The thread runs in every 5s, and writes average performance results, allocated memory size, and processes heap size into the log file.The heap size is fetched from the OS by using virtual memory map of the process [26]. For example, abbreviated virtual memory map of gnome calculator is given in Fig. 6. Some rows have been omitted due to space limits. In the map, heap memory can be clearly seen, and its size can be calculated by subtracting end address from start address. However, some memory allocators do not show the heap memory like this. So, the heap size is calculated by using other memory areas, whose path names are either nothing or [heap]. Also, these areas should be readable and writable private areas (rw-p). Later, the heap size will be compared with the allocated memory size for calculating the memory fragmentation.Algorithm 8Process logs function of the imasd.Require: Path (path) of the will be processed log fileEnsure: Processes the log file and updates the performance results for regarding process1:file=open(path);2:process_path=read_string(file);3:malloc_library=read_integer(file);4:perf=read_perf(file);5:perf_avg=average_perf(perf);6:count=malloc_mem=heap_mem=0;7:8:whilenot EOF(file) do9:mem=read_integer(file);10:malloc_mem=average(malloc_mem, mem, count);11:mem=read_integer(file);12:heap_mem=average(heap_mem, mem, count);13:count=count + 1;14:end while15:16:close(file);17:delete(path);18:19:perf_res=load_performance_results(process_path);20:smr=perf_res.summary[malloc_library];21:time=get_time();22:23:ifsmr.count<MAX_TEST_AMOUNTthen24:iftime−smr.time≥MIN_TIME_TO_RETESTthen25:smr.sec=average(smr.sec, perf_avg.sec, smr.count);26:mem_frag=(heap_mem - malloc_mem) / heap_mem;27:smr.mem_frag=average(smr.mem_frag, mem_frag, smr.count);28:smr.avg_mem=average(smr.avg_mem, heap_mem, smr.count);29:smr.count=smr.count + 1;30:smr.time=time;31:perf_res=analyze(perf_res);32:end if33:end if34:35:perf_res=select_next_test_library(perf_res, malloc_library);36:save_performance_results(process_path, perf_res);The logs saved by the imas.so are processed by the IMAS Daemon (imasd). The imasd is a daemon process, which always runs. It is the brain of the IMAS. It processes the test logs, and determines the fastest, the most memory efficient, and the balanced libraries. Also, it decides the test mode, and chooses the next test library for each process.Main function of the imasd scans test logs directory in every 5s, and sends unprocessed logs to the process logs function, given in Algorithm 8. The function opens the log file, and reads the process path, tested memory allocator library, and CPU performance values, shown at lines 1–4. Then, it averages the CPU performance values. The rest of the log file consists of memory allocator and heap memory sizes. The function reads sizes, and calculates averages by using average function. Afterwards, it closes and deletes the log file.The average function is generally implemented like Eq. (1). However, huge memory sizes can easily lead to integer overflow and miscalculation of the average. Therefore, the approach shown in Eq. (2) is used for average calculation.(1)average←(average⁎count)+additioncount+1(2)average←average⁎(countcount+1)+additioncount+1The function loads previously saved performance results, shown at line 18 in Algorithm 8. The results holds performance summary for each memory allocator library. The summary consists of the last test time, test count, and averages of CPU performance value, memory fragmentation ratio, heap size. It also holds test mode, the next test library, and the fastest, the most memory efficient, the balanced memory allocator libraries.If test count of the memory allocator library is less than maximum test amount, and time passed after the last test time is greater then minimum time for retesting then the log file is processed, shown at lines 23–33 in Algorithm 8. The function calculates the averages of CPU performance value, memory fragmentation ratio, heap memory size by adding values from the log file.(3)heap_memory−malloc_memoryheap_memoryMemory fragmentation is calculated by using Eq. (3). The malloc_memory variable holds the size of the memory without any blank area. However, the heap_memory variable holds the heap size of the process, which contains blank (wasted) memory areas. These areas are generally caused by memory fragmentation. Thus, the equation calculates the wasted memory percentage, which may also mean memory fragmentation percentage.Algorithm 9analyze function of the imasd.Require: Performance results (perf_res) that will be analyzedEnsure: Selects the fastest (perf_res.result[0]), the most memory efficient (perf_res.result[1]), and the balanced (perf_res.result[2]) memory allocator libraries1:sorted_libs_fastest=sort_desc_by_perf(perf_res);2:sorted_libs_mem_eff=sort_desc_by_mem_frag(perf_res);3:perf_res.result[0]=sorted_libs_fastest[MALLOC_LIB_END];4:perf_res.result[1]=sorted_libs_mem_eff[MALLOC_LIB_END];5:6:perf_res.result[2]=0;7:for i=0 to MALLOC_LIB_END do8:for j=0 to MALLOC_LIB_END do9:ifi=sorted_libs_fastest[j]then10:ranked_libs_fastest[i]=j + 1;11:end if12:ifi=sorted_libs_mem_eff[j]then13:ranked_libs_mem_eff[i]=j + 1;14:end if15:end for16:17:x=ranked_libs_fastest[perf_res.result[2]];18:x=x+ ranked_libs_mem_eff[perf_res.result[2]];19:y=ranked_libs_fastest[i] + ranked_libs_mem_eff[i];20:21:ify>xthen22:perf_res.result[2]=i;23:else ify=xthen24:ifranked_libs_mem_eff[i]>ranked_libs_mem_eff[perf_res.result[2]]then25:perf_res.result[2]=i;26:end if27:end if28:end forThe function analyzes the performance results utilizing the analyze function, given in Algorithm 9. The analyze function selects the fastest, the most memory efficient, and the balanced libraries. It sorts the libraries by CPU performance and memory fragmentation, shown at lines 1–2 in Algorithm 9. It sorts in descending order; therefore, the last elements of the arrays are the fastest, and the most memory efficient libraries. Also, the array index shows rankings of the libraries. The balanced library is determined utilizing the rankings, calculated at lines 8–15 in Algorithm 9. The most ranked library is the balanced library, given at lines 17–22. However, sometimes ranks can be equal. In this situation, the more memory efficient library is selected, given at lines 23–26.Algorithm 10imasd function for selecting the next test library.Require: Performance results (perf_res) and the last tested memory allocator library (malloc_library)Ensure: Determines the next test library (perf_res.next_library)1:perf_res.test_mode=false;2:for i=0 to MALLOC_LIB_END do3:malloc_library=(malloc_library + 1) for % (MALLOC_LIB_END + 1);4:smr=perf_res.summary[malloc_library];5:ifsmr.count<MAX_TEST_AMOUNTthen6:iftime−smr.time≥MIN_TIME_TO_RETESTthen7:perf_res.next_library=malloc_library;8:perf_res.test_mode=true;9:return;10:end if11:end if12:end forFinally, the process logs function selects the next test library, given in Algorithm 10, and saves performance results. The selection of the next test library starts from the last tested memory allocator library. If there is a memory allocator library that fulfils the requirements then it is selected; otherwise, the test mode is disabled.

@&#CONCLUSIONS@&#
Existing operating systems assign a predetermined (default) memory allocator to all processes. Default memory allocator cannot be sufficient for all processes. It may work good for some; however other processes may need another memory allocator. When the default memory allocator failed for a process, it leads to memory fragmentation and performance loss. For fixing this problem, each software developer has to search, test, and evaluate memory allocators for finding an efficient memory allocator. If developer does not know about memory allocators then the program will be left in the hands of operating system, and suffer.The purpose of this study is developing a novel memory management system for making operating systems more intelligent to select an efficient memory allocator for each process. Even for different OS conditions, like excessive memory or CPU usage, the IMAS selects the appropriate memory allocator. Therefore, the proposed solution makes applications and OS more efficient on both memory and CPU usage.Applications should be improved constantly; and bugs should be eliminated. For speedy improvements and increasing the usage of the IMAS, our future work will be distributing the IMAS as open source through the author׳s GitHub repository [27]. Also, new memory allocators will be added for better selection process. In order to identify unnecessary memory allocators, online statistics collection feature will also be developed.System applications are hard to develop and maintain. Linux OS gives opportunities like hooking memory allocation functions, and helps to development process. However, Windows OS does not give opportunities like this, and it is much harder to port IMAS to Windows platform. For the future work, this porting operation may be done.