@&#MAIN-TITLE@&#
On the compression of search trees

@&#HIGHLIGHTS@&#
Space-efficient representation for non-decreasing sequences of integers.Efficient support for random access and searches.Proved performance in main and secondary memory.Results competitive with the state of the art.Applications to several domains: posting lists, sparse bitmaps, geographic data, etc.

@&#KEYPHRASES@&#
Data structure,Compression,Integers,Random access,Search,

@&#ABSTRACT@&#
LetX=x1,x2,…,xnbe a sequence of non-decreasing integer values. Storing a compressed representation of X that supports access and search is a problem that occurs in many domains. The most common solution to this problem uses a linear list and encodes the differences between consecutive values with encodings that favor small numbers. This solution includes additional information (i.e. samples) to support efficient searching on the encoded values. We introduce a completely different alternative that achieves compression by encoding the differences in a search tree. Our proposal has many applications, such as the representation of posting lists, geographic data, sparse bitmaps, and compressed suffix arrays, to name just a few. The structure is practical and we provide an experimental evaluation to show that it is competitive with the existing techniques.

@&#INTRODUCTION@&#
The storage of ordered sets of integers is a fundamental problem in computer science that has applications in many domains. When space is not an issue these sets can be stored in arrays, which support random access and efficient searches. However, space is a constraining factor in most domains, and the compression of these sets can save a considerable amount of space. As compression techniques are usually based on variable length encoding, random access and efficient searches become challenging.Common solutions to this problem rely on the fact that differences between consecutive values in a sequence are often small numbers, and encode these differences with encodings that favor small numbers. In order to efficiently support random access and searches, these schemes are forced to store sampled absolute values. These samples can be thought as an index built on top of the data that requires more space the higher the sampling rate. As the sampling rate is a parameter that provides a space–time trade-off, these solutions are called parametric.In this paper we propose a (non-parametric) compressed representation for non-decreasing sets of integers that does not require us to build an index on top of the data, and still offers efficient support for random access and searches. In this sense our method is similar to a recent proposal by Teuhola (2011), but the techniques are different and of independent interest. LetX=x1,x2,…,xnbe a sequence of non-decreasing integer values, we propose a compressed representation of X that, in logarithmic time, supports:•access(X,i): retrieve the value at position i in X.search(X,t): retrieve the position of the left-most stored value greater or equal than t.1Note that we can also return the value stored in that position, thus solving the membership variant of the problem.1This structure has applications in the representation of posting lists, which are one of the two main components of the ubiquitous inverted index (Baeza-Yates & Ribeiro-Neto, 1999; Witten, Moffat, & Bell, 1999). A basic primitive operation for these indexes is to find the intersection of posting lists, which provides a solution to handle multi-word queries. Although this primitive operation can be supported through sequential merging of the lists, some of the most efficient approaches to solve intersection queries (Hwang & Lin, 1972; Demaine, López-Ortiz, & Munro, 2000; Barbay & Kenyon, 2002; Baeza-Yates, 2004) take advantage of the fact that some lists are much shorter than the others, and make use of random access and search capabilities.As another application, the partial sums problem can be thought of as a particular instance of this problem. In the partial sums problem we are given a sequence of n non-negative values,Y=y1,y2,…,yn, and we have to support the following operations:•sum(Y,i): retrieve the sum of all the values up to position i.search(Y,t): retrieve the smallest i such thatsum(Y,i)⩾t.Note thatX=x1,x2,…,xncan be defined as a sequence of partial sums of values in the sequenceY=y1,y2,…,yn, so thatxi=∑j=1iyj. In this way,sum(Y,i)reduces toaccess(X,i)andsearch(Y,t)reduces tosearch(X,t). Partial sums can be applied, for example, to represent Rank/Select dictionaries (Okanohara & Sadakane, 2007).The article is organized as follows. In Section 2 we survey the main solutions to this problem and describe their basic properties. In Section 3 we describe our new solution to this problem. Section 4 discusses some applications, and presents an experimental evaluation of our solution both in general and for each particular application. Finally, Section 5 concludes the paper with some brief remarks and avenues for future research.

@&#CONCLUSIONS@&#
