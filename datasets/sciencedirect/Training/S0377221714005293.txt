@&#MAIN-TITLE@&#
Minmax regret 1-facility location on uncertain path networks

@&#HIGHLIGHTS@&#
We propose an algorithm to compute the minmax regret.We solve the minmax 1-facility location problem on uncertain path network.Our algorithm improves the previous work.We discover new observations on the problem.

@&#KEYPHRASES@&#
Algorithms,Path networks,Uncertainty,Facility location,Minmax regret,

@&#ABSTRACT@&#
Let P be an undirected path graph of n vertices. Each edge of P has a positive length and a constant capacity. Every vertex has a nonnegative supply, which is an unknown value but is known to be in a given interval. The goal is to find a point on P to build a facility and move all vertex supplies to the facility such that the maximum regret is minimized. The previous best algorithm solves the problem inO(nlog2n)time andO(nlogn)space. In this paper, we present anO(nlogn)time andO(n)space algorithm, and our approach is based on new observations and algorithmic techniques.

@&#INTRODUCTION@&#
Facility location problems on networks have received considerable attention over a few decades. The problems are normally concerned with networks where the information (e.g., the vertex and the edge weights) are known precisely. However, data in practice often involve uncertainty and may change with the time. Recently facility locations problems in uncertain environments have been studied, e.g., Averbakh and Bereg (2005), Averbakh and Berman (1997, 2000a, 2000b, 2003), Bhattacharya and Kameda (2012), Bhattacharya, Kameda, and Song (2012a, 2012b), Chen and Lin (1998), Cheng et al. (2013), Conde (2007, 2008), Kouvelis and Yu (1997), Puerto, Rodríguez-Chía, and Tamir (2009) and Yu, Lin, and Wang (2008). One approach that is often used to model the uncertainty is the worst-case analysis in which one is looking for a solution that performs reasonably well for all possible scenarios (where a scenario is a specific realization of all uncertain parameters of the problem). There are many optimization criteria in the worst-case analysis. In particular, the minmax regret optimization aims at obtaining a solution that minimizes the maximum deviation, over all possible scenarios, between the value of the solution and the optimal value of the corresponding scenario, e.g., Averbakh and Berman (1997, 2000b), Bhattacharya and Kameda (2012), Bhattacharya et al. (2012a, 2012b), Cheng et al. (2013), Kouvelis and Yu (1997) and Yu et al. (2008). In other words, the minmax regret optimization seeks to minimize the worst-case loss in the objective function value that may occur because the solution is chosen without knowing which scenario will take place.In this paper, we consider the minmax regret 1-facility location problem on uncertain path networks where the vertex weights are uncertain. The problem was proposed recently by Cheng et al. (2013) and anO(nlog2n)time andO(nlogn)space algorithm was given in Cheng et al. (2013). By discovering more observations, we present anO(nlogn)time andO(n)space algorithm in this paper. Shortly after the preliminary version of this paper appeared in Wang (2013), Cheng et al.’s algorithm (Cheng et al., 2013) was independently improved toO(nlogn)time andO(nlogn)space in their journal paper (Higashikawa et al., 2014).As discussed in Cheng et al. (2013), the problem is motivated by an earthquake evacuation problem due to the Tohoku-Pacific Ocean Earthquake that happened in Japan on March 11th, 2011. For example, suppose we have a highway that connects many cities and we want to find a location on the highway to build an evacuation facility such that when earthquake happens we can evacuate people in all these cities to the facility as soon as possible. The number of people in each city is uncertain due to different time periods (e.g., weekdays, weekends, days, nights, holidays). We formally introduce the problem below, and some notations are borrowed from Cheng et al. (2013).LetP=(V,E)be a path graph, with the vertex setV={v1,…,vn}and the edge setE={e1,…,en-1}, such thateiconnectsviandvi+1for each1⩽i⩽n-1. Each edgee∈Ehas a positive weightl(e). Each vertexvi∈Vhas a weightwi(e.g., the number of evacuees), which is unknown but is known in a given intervalwi-,wi+with0⩽wi-⩽wi+. Let c be a constant representing the capacity of each edge, which is the maximum number of evacuees passing any point in any unit time. Letτbe a positive constant representing the time required for traversing a unit distance of every evacuee. LetΣbe the Cartesian product of all intervals[wi-,wi+]for1⩽i⩽n. Every elements∈Σis called a scenario that is a feasible assignment of weights to the vertices of P. For any scenarios∈Σ, for each1⩽i⩽n, we denote bywi(s)the weight of the vertexviin the scenario s, andwi-⩽wi(s)⩽wi+.As in Cheng et al. (2013), we embed the path P on a real line L (e.g., the x-axis) such that each vertexvi∈Vis associated with the coordinatexi=x1+∑j=1i-1l(ej)for each2⩽i⩽n. For each pointx∈L, with a little abuse of notation, we also use x to denote the coordinate of the point. We use P to denote the set of points x on L withx1⩽x⩽xn. For any pointx∈P, letPL(x)={t∈P|t<x}andPR(x)={t∈P|t>x}. Suppose we build a facility at a locationx∈P. Consider any scenarios∈Σ. We useTL(x,s)to denote the minimum time for the evacuees onPL(x)to move to x; similarly, letTR(x,s)denote the minimum time for the evacuees onPR(x)to move to x. Note that if x is at a vertexvi∈V, then we assume the evacuees atvican complete evacuation in no time. As discussed in Cheng et al. (2013), by Kamiyama, Katoh, and Takizawa (2006),TL(x,s)andTR(x,s)can be expressed as follows.TL(x,s)=maxvi∈PL(x)(x-xi)·τ+1c·∑j=1iwj(s)-1,TR(x,s)=maxvi∈PR(x)(xi-x)·τ+1c·∑j=inwj(s)-1.Note that ifPL(x)=∅,TL(x,s)=0, and ifPR(x)=∅,TR(x,s)=0.As in Cheng et al. (2013) and Higashikawa et al. (2014), in this paper we consider the case wherec=1. We should point out that Cheng et al. (2013) claimed that any algorithm works forc=1can also work for any other values of c (our preliminary version (Wang, 2013) cited their claim). However, it was found that the claim was not correct (Higashikawa et al., 2014), and therefore, their algorithms (Cheng et al., 2013; Higashikawa et al., 2014) only work for the casec=1and so does the algorithm in this paper.But we can ignore the-1from the above formulas when designing the algorithm. Hence, as in Cheng et al. (2013), we simply use the following definitions forTL(x,s)andTR(x,s).TL(x,s)=maxvi∈PL(x)(x-xi)·τ+∑j=1iwj(s),TR(x,s)=maxvi∈PR(x)(xi-x)·τ+∑j=inwj(s).As in Cheng et al. (2013), for convenience of discussion, for each1⩽i⩽n, we define a functionfLi(x,s)onx>xiand a functionfRi(s,x)onx<xias follows.fLi(x,s)=(x-xi)·τ+∑j=1iwj(s),fRi(x,s)=(xi-x)·τ+∑j=inwj(s).Hence, we haveTL(x,s)=maxvi∈PL(x)fLi(x,s)andTR(x,s)=maxvi∈PR(x)fRi(x,s).LetT(x,s)denote the minimum time for all evacuees on P to move to x. Thus,T(x,s)=max{TL(x,s),TR(x,s)}. Denote byxopt(s)a point on P such thatT(x,s)is minimized whenx=xopt(s), and one may considerxopt(s)as an optimal location for the scenario s. For any point x on L, letR(x,s)=T(x,s)-T(xopt(s),s), and we callR(x,s)the regret of x in the scenario s. Intuitively,R(x,s)is the regret (i.e., the opportunity loss) caused by choosing the location x instead of the optimal locationxopt(s). Finally, the maximum regret of x is defined asRmax(x)=maxs∈ΣR(x,s). In other words,Rmax(x)is the worst-case opportunity loss for choosing the location x.Our minmax regret problem is to choose a location x on L such that the maximum regretRmax(x)is minimized, and the minimizedRmax(x)is called the minmax regret.In this paper we present an algorithm ofO(nlogn)time andO(n)space for the problem, which improves theO(nlog2n)time andO(nlogn)space algorithm (Cheng et al., 2013).Our algorithm makes use of the critical observation given in Cheng et al. (2013) that there are a set S of2nscenarios such that for any point x on L, the “worst-case” scenario forRmax(x)must be in S. This implies that instead of considering the infinitely many scenarios ofΣfor computingRmax(x), we only need to consider the scenarios in S. The algorithm has two main steps. The first step is to compute the optimal positions for all scenarios in S. AnO(nlog2n)time algorithm is given in Cheng et al. (2013) for the step. By finding new properties on the optimal solutions of these scenarios, we are able to compute all optimal solutions inO(nlogn)time by an even simpler algorithm. The second step is to compute the minmax regret. This step also takesO(nlog2n)time in Cheng et al. (2013). Our algorithm runs inO(nlogn)time andO(n)space. The high level scheme of our approach is binary search, whose efficiency hinges on solving the following sub-problem in linear time: Given any point x on L, compute the valuesTL(x,s)andTR(x,s)for all scenarioss∈S. A straightforward method can computeTL(x,s)andTR(x,s)inO(n)time for each scenario s, and thus solves the sub-problem inO(n2)time. By discovering some interesting observations, we present anO(n)time algorithm for the sub-problem. It should be noted that our algorithm itself is very simple but it is more challenging to observe the crucial properties behind the scene.In the following, we discuss some basic observations in Section 2. In Section 3, we compute the optimal locations for all scenarios in S. Section 4 computes the minmax regret. Section 5 concludes the paper and discusses some possible future work.We discuss some observations that will be useful for our algorithm. Most of these observations have been discovered in Cheng et al. (2013) and we sketch them in this section for completeness of this paper.Our goal is to find a location x to minimize the maximum regretRmax(x)=maxs∈ΣR(x,s). Consider any point x on P and any scenarios∈Σ. To computeR(x,s), we need to knownxopt(s)first. Recall thatxopt(s)is the value of x such thatT(x,s)=max{TL(x,s),TR(x,s)}is minimized whenx=xopt(s). To determinexopt(s), we discuss some properties ofTL(x,s)andTR(x,s).Recall thatTL(x,s)=maxvi∈PL(x)fLi(x,s). For each1⩽i⩽n, the functionfLi(x,s)defines in the plane an open half-line of slopeτwith (but excluding) the (left) endpoint(xi,∑j=1iwj(s))(e.g., see Fig. 1).TL(x,s)is the upper envelope of the n half-lines defined by the functionsfLi(x,s)fori=1,…,n. Sinceτ>0,TL(x,s)is a strictly increasing function of x (e.g., see Fig. 1). Similarly, eachfRi(x,s)defines an open half-line of slope-τwith (but excluding) the (right) endpoint(xi,∑j=inwj(s)), andTR(x,s)is the corresponding upper envelope, which is strictly decreasing. SinceT(x,s)=max{TL(x,s),TR(x,s)},T(x,s)is a unimodal function of x in the sense that there exists a valuex∗such thatT(x,s)is strictly decreasing on(-∞,x∗]and increasing on[x∗,+∞)(e.g., see Fig. 2). Note that the abovex∗isxopt(s). These properties are already given in Cheng et al. (2013). We also have the following observation.Observation 1For any scenarios∈Σ,T(x,s)is the upper envelope of the functionsfLi(x,s)andfRi(x,s)fori=1,…,n.For any point x, to compute the maximum regretRmax(x), a straightforward approach is to enumerate all scenarios inΣto computeR(x,s)for every scenarios∈Σ. However, since there are infinitely many scenarios inΣ, the approach does not work. Below, we use a difference approach.A scenario s is the worst-case scenario for the location x ifRmax(x)=R(x,s), and we denote it bys(x). Clearly, if we knows(x), then we can computeRmax(x)=R(x,s(x)). Cheng et al. (2013) provided a way to determine a set S of at most2nscenarios such thats(x)must be in S for any x, as follows.For each1⩽i⩽n, letsLibe the scenario where the weightwj(sLi)of the vertexvjiswj+for each j with1⩽j⩽i, andwj(sLi)=wj-for each j withi+1⩽j⩽nifi<n. Symmetrically, for each1⩽i⩽n, letsRibe the scenario wherewjsRi=wj-for each j with1⩽j⩽i, andwj(sRi)=wj+for each j withi+1⩽j⩽nifi<n. LetSL=sLi|1⩽i⩽nandSR={sRi|1⩽i⩽n}. LetS=SL∪SR. The following lemma has been proved in Cheng et al. (2013).Lemma 1Cheng et al. (2013)For any point x on L, there exists a worst-case scenario for x in S.In light of Lemma 1, we haveRmax(x)=maxs∈SR(x,s). Hence, to computeRmax(x), instead of considering all scenarios ofΣ, we only need to consider the2nscenarios in S. For eachs∈S, to computeR(x,s), we need to know the optimal locationxopt(s). Cheng et al. (2013) presented anO(nlog2n)time algorithm for computingxopt(s)for all scenarioss∈S, and in Section 3 we describe anO(nlogn)time algorithm.In this section, we present anO(nlogn)time andO(n)space algorithm for computingxopt(s)for all scenarioss∈S, which improves theO(nlog2n)time algorithm in Cheng et al. (2013). Our improvement is due in a large part to certain monotonicity properties of the valuesxopt(s)given in Lemma 2.Lemma 2For any two scenariossLiandsLi+1ofSLwith1⩽i⩽n-1, ifxi+1⩽xoptsLi, thenxi+1⩽xoptsLi+1⩽xoptsLi; otherwise,xoptsLi⩽xoptsLi+1⩽xi+1.We only prove the case wherexi+1⩽xoptsLisince the proof for the other case wherexi+1>xoptsLiis very similar.According to the definitions of the two scenariossLiandsLi+1, for each vertexvj, ifj≠i+1, the weights ofvjin the two scenarios are the same, but for the vertexvi+1,wi+1sLi=wi+1-andwi+1sLi+1=wi+1+. By Corollary 1 in Cheng et al. (2013),xi+1⩽xoptsLi+1holds. Below, we provexoptsLi+1⩽xoptsLi. To this end, it is sufficient to show thatTLx,sLi+1>TRx,sLi+1for anyx>xoptsLi. The details are given below.Consider any valuex>xoptsLi. SinceTL(x,s)is strictly increasing andTR(x,s)is strictly decreasing for any scenario s, according to the definition ofxoptsLi, we haveTLx,sLi>TRx,sLi.According to the definitions ofsLiandsLi+1,fLjt,sLi+1⩾fLj(t,sLi)for anyj⩾i+1and anyt>xj(more precisely,fLjt,sLi+1=fLj(t,sLi)+wi+1+-wi+1-), andfLjt,sLi+1=fLj(t,sLi)for anyj⩽iand anyt>xj(e.g., see Fig. 3). Due tox>xoptsLi⩾xi+1, we obtainTLx,sLi+1⩾TLx,sLi.Similarly,fRjt,sLi+1⩾fRj(t,sLi)for anyj⩽i+1and anyt<xj, andfRjt,sLi+1=fRj(t,sLi)for anyj⩾i+2and anyt<xj(e.g., see Fig. 3). Sincex>xoptsLi⩾xi+1, none of the functionsfRjt,sLi+1forj⩽i+1is defined ont=x. Therefore, we obtainTRx,sLi+1=TRx,sLi.The above shows thatTLx,sLi>TRx,sLi,TLx,sLi+1⩾TLx,sLi, andTRx,sLi+1=TRx,sLi. Hence, we conclude thatTLx,sLi+1>TRx,sLi+1.□Lemma 2 implies the following monotonicity property ofxoptsLi. Suppose initiallyx2⩽xoptsL1; as the index i increases,xoptsLimoves monotonically “backward” to the left until at some momentxi+1>xoptsLihappens, after whichxoptsLimoves monotonically “forward” to the right. This monotonicity property turns out to be quite useful to our algorithm.Similarly, we have the following lemma forSR, which implies a monotonicity property ofxopt(sRi)(the indices are considered from right to left).Lemma 3For any two scenariossRiandsRi+1ofSRwith1⩽i⩽n-1, ifxi⩽xoptsRi+1, thenxi⩾xoptsRi⩾xoptsRi+1; otherwise,xoptsRi+1⩾xoptsRi⩾xi.The proof is symmetric to that for Lemma 2 by considering the indices from right to left, and we omit the details.□Based on Lemmas 2 and 3, we present our algorithm for computingxopt(s)for alls∈Sas follows. We first computexopt(s)for alls∈SL, by using Lemma 2.Our algorithm will computexoptsLiin the index orderi=1,2,…,n. We assume we already have a data structure D that can compute the valuesTL(x,s)andTR(x,s)whenever needed for any x ands∈SL. Initially, to determinexoptsL1, we compute the valuesTLx,sL1andTRx,sL1forx=x1,x2,…in the (forward) order to find the smallest indexi1such thatTLxi1,sL1⩾TRxi1,sL1. As discussed in Cheng et al. (2013),xoptsL1∈[xi1-1,xi1]and can be determined in constant time. Next, we computexoptxL2. Assumex2⩽xoptxL2. By Lemma 2,x2⩽xoptxL2⩽xopt(xL1), we only need to search the portions ofTLx,sL2andTRx,sL2forx2⩽x⩽xoptsL1. To this end, we compute the valuesTLx,sL2andTRx,sL2by using D forx=xi1,xi1-1,…in the (backward) order to find the first indexi2such thatTL(xi2,sL2)⩾TR(xi2,sL2)andTLxi2-1,sL2<TRxi2-1,sL2. As discussed in Cheng et al. (2013),xoptsL2∈[xi2-1,xi2]and can be determined in constant time.In general, assumexoptsLjhas been computed andxj+1⩽xoptsLj. Further, assumexoptsLjis known in the interval[xij-1,xij]. To computexoptsLj+1, by Lemma 2, we havexj+1⩽xoptsLj+1⩽xoptsLj. We compute the valuesTLx,sLj+1andTRx,sLj+1by D forx=xij,xij-1,…in the (backward) order to find the first indexij+1such thatTLxij+1,sLj+1⩾TRxij+1,sLj+1andTL(xij+1-1,sLj+1)<TR(xij+1-1,sLj+1). Again,xoptsLj+1∈[xij+1-1,xij+1]and can be determined in constant time.We continue the same procedure until the first time we have computedxoptsLkwithxoptsLk<xk+1for an index k. We also have the interval[xik-1,xik]that containsxoptsLk. By Lemma 2,xoptsLk⩽xoptsLk+1⩽xk+1. Hence, to computexoptsLk+1, we need to search the portions ofTLx,sLk+1andTRx,sLk+1forxoptsLk⩽x. To this end, we compute the valuesTLx,sLk+1andTRx,sLk+1by D forx=xik-1,xik,…in the (forward) order to find the first indexik+1such thatTLxik+1,sLk+1⩾TRxik+1,sLk+1andTLxik+1-1,sLk+1<TRxik+1-1,sLk+1. Again,xoptsLk+1∈[xik+1-1,xik+1]and can be determined in constant time. Next, we computexoptsLk+2. We have the following observation.Observation 2xoptsLk+1<xk+2holds.By Lemma 2, we havexoptsLk⩽xoptsLk+1⩽xk+1. Due toxk+1<xk+2, the observation simply follows.□Due to the above observation, we can computexoptsLk+2in the similar way asxoptsLk+1. We continue this procedure to computexopt(sLj)forj=k+2,k+3,…,n. Note that similar observation as Observation 2 always holds (i.e.,xopt(sLj)<xj+1for any j withk+1⩽j⩽n-1). The algorithm stops whenxopt(sLn)is computed.To analyze the running time, suppose any needed valuesTL(x,s)andTR(x,s)in the above algorithm can be computed inO(TD)time by using the data structure D; then we have the following lemma.Lemma 4The valuesxopt(s)for all scenarioss∈SLcan be computed inO(n·TD)time.It is sufficient to show that the number of calls to D isO(n)in the entire algorithm.We still use k to denote the smallest index withxoptsLk<xk+1. By the monotonicity property in Lemma 2,xoptsLiis moving monotonically to the left fori=1,2,…,k, andxoptsLiis moving monotonically to the right fori=k+1,k+2,…,n. When we computexoptsLifori=1,…,k, the x values for computingTLx,sLiandTRx,sLiare monotone decreasing. Therefore, when computing the valuesxoptsLi’s fori=1,…,k, the total number of calls on D isO(n). Analogously, when computing the valuesxoptsLi’s fori=k+1,…,n, the total number of calls on D is alsoO(n). The lemma thus follows.□It remains to design the data structure D, which is given in the following lemma.Lemma 5InO(n)time andO(n)space, we can build a data structure D that can compute inO(logn)time (i.e.,TD=O(logn)) any valueTL(x,s)orTR(x,s)needed in our algorithm for computingxopt(s)for alls∈SL.WithO(nlogn)time preprocessing, Cheng et al. (2013) propose a data structure that can computeTL(x,s)andTR(x,s)for any x ands∈SLinO(logn)time, by using persistent data structures (Driscoll, Sarnak, Sleator, & Tarjan, 1989). Below, we give a simple solution with onlyO(n)preprocessing time, without using the persistent data structures.We first discuss an observation on our algorithm that makes the design of our data structure easier. In our algorithm for computingxopt(s)for alls∈SL, when we are computingxoptsLi, for any1⩽i⩽n, we need to computeTLx,sLiandTRx,sLifor certain values of x. AfterxoptsLiis computed, we will never need to computeTLx,sLiandTRx,sLifor the scenariosLiagain. Note that the corresponding algorithm in Cheng et al. (2013) does not have such a property.Our data structure D has two partsDLandDR.DLis for computingTL(x,s)andDRis for computingTR(x,s). Below, we only discussDLsinceDRis very similar.DLconsists of a sequence of treesDLifori=1,2,…,n, whereDLiis used for computingTLx,sLifor any x. Thanks to the observation discussed above, at any moment during the algorithm, we only need to maintain one tree in the above sequence (in contrast, because the corresponding algorithm in Cheng et al. (2013) does not have such a property, they have to maintain all these trees in a persistent data structure). Specifically, initially we construct the treeDL1. Then, for each1⩽i⩽n-1, the treeDLi+1is obtained by updating the treeDLiinO(logn)time (DLiis thus destroyed). Below, we first describe the treeDL1and then show how to updateDL1to obtainDL2. The tree is similar to that given in Cheng et al. (2013) (without being made persistent). We briefly discuss it here to make the paper self-contained.We first discuss some observations on how to computeTL(x,s). Consider any scenario s and any value x withxj-1<x⩽xjfor certain j. Recall that the functionsfL1(x,s),fL2(x,s),…,fLj-1(x,s)are defined on x whilefLj(x,s),fLj+1(x,s),…,fLn(x,s)are not, andTL(x,s)=max1⩽t⩽j-1fLt(x,s). Also recall thatfLt(x,s)=(x-xt)·τ+∑h=1twh(s). Hence, we can obtain the followingTL(x,s)=x·τ+max1⩽t⩽j-1(∑h=1twh(s)-xt·τ).DL1is a balanced binary search tree in which the leaves ofDLfrom left to right store the values∑h=1twhsL1-xt·τfort=1,2,…,n. For each1⩽t⩽n, letat=∑h=1twhsL1-xt·τ, which is stored in the t-th leaf. For each node v (either a leaf or an internal node), it also stores a valuemax(v), which is equal to the maximum value stored in the leaves of the subtree rooted at v. The treeDL1can be easily constructed inO(n)time in a bottom-up manner. Given any valuex=xj,TLx,sL1can be computed inO(logn)time, as follows. According to our above discussion, we haveTLxj,sL1=xj·τ+max1⩽t⩽j-1at. With standard techniques, by following the pathPjinDL1from the root to the j-th leaf, we find a minimum set V of nodes whose subtrees contain the leaves exactly from the first leaf to the(j-1)-th one. Specifically,V=v|v∉Pjand v is the left child of a node in Pj} (e.g., see Fig. 4). Clearly,|V|=O(logn)and can be found inO(logn)time. An easy observation is that the largest valuemax(v)among all nodesv∈Vis exactlymax1⩽t⩽j-1at. Hence,TLxj,sL1is equal toxj·τplus the above largest valuemax(v)ofv∈V. Thus, we can computeTLxj,sL1inO(logn)time.Next, we show how to updateDL1inO(logn)time to obtain the treeDL2, which is for computingTLx,sL2for the scenariosL2. According to the definitions of the two scenariossL1andsL2, comparing withsL1, the weight of the vertexv2insL2increases byw2+-w2-while the weights of all other vertices are the same. Hence, all the values∑h=1twhsL1-xt·τfort=2,3,…,nstored in the leaves ofDL1except the leftmost leaf should increase byw2+-w2-. We cannot afford to change each of these values explicitly since that would needΩ(n)time. To obtain anO(logn)time performance, we use the following approach. For each node v in the tree, we maintain an additional value, called the supplement value and denoted bysup(v). InDL1,sup(v)=0for each node v. Hence, inDL1, for any1⩽t⩽n, it holds thatat+∑v∈Ptsup(v)=∑h=1twhsL1-xt·τ, wherePtis the path from the root ofDL1to the t-th leaf.We updateDL1to obtainDL2in the following way. LetP2be the path from the root ofDL1to the second leaf. First, for the second leaf v, we increasesup(v)byw2+-w2-. Then, for each node v that is not inP2but is a right child of a node ofP2, we increasesup(v)byw2+-w2-. Note that the above can be done inO(logn)time. Now consider the t-th leaf of the new tree, for any1⩽t⩽n, and letPtbe the path from the root to the leaf. It is easy to see thatat+∑v∈Ptsup(v)=∑h=1twhsL2-xt·τ. In other words, if we followPtfrom the root to aggregate the supplement valuesup(v), once we arrive the t-th leaf, we have the value∑h=1twhsL2-xt·τready. Next, we update the valuesmax(v)for certain nodes v as follows. If a node v has a child whose supplement value has been increased above (note that v is necessarily onP2), then itsmax(v)may also need to be updated. To this end, for each internal nodev∈P2, we simply setmax(v)to bemax{max(u)+sup(u),max(w)+sup(w)}, where u and w are the two children of v. Note that we do not need to update the max value of the second leaf. This finishes our update onDL1and the new tree isDL2. Clearly,DL2can be obtained inO(logn)time.Consider any internal node u onDL2and suppose the leftmost (resp., rightmost) leaf in the subtree rooted at v is the l-th (resp., r-th) leaf. LetPube the path from the root to the node u. Based on our construction,max{∑h=1twhsL2-xt·τ|l⩽t⩽r}is exactly equal to the valuemax(u)+∑v∈Pusup(v). Hence, given anyx=xj, by usingDL2, we can compute the valueTLx,sL2in a similar way as before, and the only difference is that we need to aggregate the supplement valuessup(v)during traversing the tree from the root. Specifically, to computeTLx,sL2for anyx=xj, letPjbe the path ofDL2from the root to the j-th leaf. We start from the root and traverse the pathPjto the j-th leaf. During the traversal, consider any nodev∈Pj. We maintain a valueA(v), which is equal tosup(v)if v is the root andA(v.parent)+sup(v)otherwise (wherev.parentis the parent of v inPj). If v has a left child u that is not inPj, we let the valuemax(u)+sup(u)+A(v)be in a set M (M=∅initially). If v is the j-th leaf, then we put the valueA(v)+max(v)in M and finish the traversal. After the traversal, M hasO(logn)values, and the maximum value of M is equal tomax{∑h=1twhsL2-xt·τ|1⩽t⩽j-1}. Therefore,TLxj,sL2is equal to the maximum value of M plusxj·τ. Hence,TLxj,sL2can be computed inO(logn)time.Similarly, we can obtain the treeDL3by updatingDL2inO(logn)time. In general, for any1⩽i⩽n-1, if we already have the treeDLi, we can obtainDLi+1inO(logn)time by updatingDLisuch that we can computeTLx,sLi+1for anyx=xjinO(logn)time.The lemma thus follows.□Combining Lemmas 4 and 5, the valuesxopt(s)for all scenarioss∈SLcan be computed inO(nlogn)time. Using the similar algorithm and Lemma 3, we can also compute the valuesxopt(s)for all scenarioss∈SRinO(nlogn)time. We conclude this section with the following theorem.Theorem 1The valuesxopt(s)andT(xopt(s),s)for all scenarioss∈S=SL∪SRcan be computed inO(nlogn)time andO(n)space.Our goal is to determine an optimal locationx∗such thatRmax(x)=maxs∈ΣR(x,s)is minimized atx=x∗, whereR(x,s)=T(x,s)-T(xopt(s),s). Again, by Lemma 1,Rmax(x)=maxs∈SR(x,s), which also implies thatRmax(x)is the upper envelope of the functionsR(x,s)for alls∈S.Consider any scenario s. SinceT(xopt(s),s)is a constant value andT(x,s)is a unimodal function,R(x,s)is also a unimodal function. Therefore,Rmax(x)is the upper envelope of a set of unimodal functions, which is also unimodal. To determine an optimal solutionx∗, it is sufficient to determine the lowest point of the unimodal functionRmax(x). Due to the unimodality ofRmax(x), we will use binary search to find its lowest point.The high-level scheme of our algorithm for findingx∗is a binary search on the valuesx1,x2,…,xn. For each valuexkconsidered in the binary search, we compute the valueRmax(xk). To this end, we present anO(n)time algorithm in Section 4.1 that can compute the valuesTL(x′,s)andTR(x′,s)for alls∈S, for anyx′, after which we can determine the valueRmax(x′)in additionalO(n)time since we already know the valuesT(xopt(s),s)for alls∈Sby Theorem 1. Based on the function that gives the valueRmax(xk), we can also determine which direction to do binary search in a standard way (Megiddo, 1983, 1984). The binary search will end up with eitherx∗=xifor somexior an interval(xi,xi+1)such thatx∗∈(xi,xi+1). In the latter case, we finally determinex∗in additionalO(n)time by linear programming (Megiddo, 1983, 1984) as follows. Note that for any scenario s, the valueTL(x,s)forx∈(xi,xi+1)are given by the same functionfLj(x,s)for some j, and similar observation holds forTR(x,s). We find the functions giving the values in the interval(xi,xi+1)forTLx,sLi,TRx,sLi,TL(x,sRi), andTR(x,sRi), fori=1,…,n. This can be done inO(n)time by the same algorithm in Section 4.1. Denote by F theO(n)functions computed above. Hence,x∗is the x-coordinate of the lowest pointp∗of the upper envelope of the functions in F. Note that every function of F defines a half-line that spans the interval(xi,xi+1). Hence, although each function of F is a half-line,p∗is also the lowest point of the upper envelope of the lines that contain the half-lines of F, and thusp∗can be computed inO(n)time by linear programming (Megiddo, 1983, 1984).In this section, we present anO(n)time algorithm for computingT(x′,s)for alls∈S, for anyx′. In other words, our goal is to compute the valuesTLx′,sLi,TRx′,sLi,TLx′,sRi, andTRx′,sRi, fori=1,…,n. We only discuss our algorithm for computingTLx′,sLifori=1,…,nsince the algorithms for the other three cases are quite similar. Further, for each1⩽i⩽n, the functionfLjx′,sLithat gives the valueTLx′,sLiis also determined by the algorithm.For any1⩽i⩽j⩽n, we defineα(i,j)=∑k=ijwk+-wk-. AfterO(n)time preprocessing, given any i and j with1⩽i⩽j⩽n, we can obtain the valueα(i,j)in constant time. We omit the preprocessing details and below we assume we have done the preprocessing. For convenience, we letα(i,j)=0ifi>j.Letx′be any value withx1⩽x′⩽xn. We first determine the index i such thatxi-1<x′⩽xi. Thus, for any scenario s, only functionsfLt(x′,s)with1⩽t⩽i-1are defined onx=x′, and any functionfLt(x,s)withi⩽t⩽ndoes not define onx=x′. We compute the valueTLx,sL1, which can be done inO(n)time, e.g., by computingfLjx′,sL1for each j with1⩽j⩽i-1.Let k be the index such thatTLx′,sL1is given by the functionfLkx′,sL1, e.g.,TLx′,sL1=fLkx′,sL1. Hence,k⩽i-1. The following lemma will be useful later.Lemma 6Consider a functionfLt(x,s)and a scenariosLj. If1⩽t,j⩽i-1, thenfLtx′,sLj=fLtx′,sL1+α(2,m)withm=min{t,j}. This impliesfLtx′,sLt=fLtx′,sLjift⩽j⩽i-1.Consider any t and j with1⩽t,j⩽i-1. First of all, sincexi-1<x′⩽xi,t⩽i-1, andj⩽i-1, both functionsfLtx,sL1andfLtx,sLjare defined onx=x′. Comparing with the scenariosL1, the weight of each vertexvhfor2⩽h⩽jincrease bywh+-wh-in the scenariosLj, and the weights of all other vertices are the same as before. According to their definitions, we obtain thatfLtx′,sL1=fLtx′,sLj+α(2,t)ift⩽j, andfLtx′,sL1=fLtx′,sLj+α(2,j)ift⩾j. The lemma thus follows.□With the valueTLx′,sL1, the following lemma shows how to computeTLx′,sLjfor2⩽j⩽k.Lemma 7Ifk⩾2, for any scenariosLjwith2⩽j⩽k,TLx′,sLj=TLx′,sL1+α(2,j).Assumek⩾2. Consider any scenariosLjwith2⩽j⩽k. We first prove a claim thatfLkx′,sLj⩾fLtx′,sLjfor any1⩽t⩽i-1.Due toTLx′,sL1=fLkx′,sL1, it holds thatfLkx′,sL1⩾fLtx′,sL1for any1⩽t⩽i-1. Consider any t with1⩽t⩽i-1. By Lemma 6, we havefLtx′,sLj=fLtx′,sL1+α(2,m), wherem=min{j,t}. Sincej⩽k,fLkx′,sLj=fLkx′,sL1+α(2,j)holds by Lemma 6. Clearly,α(2,j)⩾α(2,m)⩾0due tom⩽j. Therefore, we obtain thatfLkx′,sLj⩾fLtx′,sLj.The above claim implies thatTLx′,sLj=fLkx′,sLj. SincefLkx′,sLj=fLkx′,sL1+α(2,j)by Lemma 6 andTLx′,sL1=fLkx′,sL1, the lemma follows.□Suppose the valueTLx′,sLi-1has already been computed; the following lemma shows how to obtainTLx′,sLjfori⩽j⩽n.Lemma 8For any scenariosLjwithi⩽j⩽n,TLx′,sLj=TLx′,sLi-1.Recall that for any scenario s only the functionsfLt(x,s)with1⩽t⩽i-1are defined onx=x′. Consider any scenariosLjwithi⩽j⩽n. Comparing withsLi-1, the weight of each vertexvtinsLjincreases bywt+-wt-for anyi⩽t⩽j, and all other vertex weights do not change. Since the above vertex weight increase only affect the functionsfLtx,sLjfort⩾iand none of these functions is defined onx=x′, the valueTL(x′,s)does not change fors=sLi-1ands=sLj. A more formal proof is given below.Letk′be the index such that the valueTLx′,sLi-1is given byfLk′x′,sLi-1, i.e.,TLx′,sLi-1=fLk′x′,sLi-1. Note thatk′⩽i-1. Hence,fLk′x′,sLi-1⩾fLtx′,sLi-1for any1⩽t⩽i-1. In the scenariosLj, the weights of the verticesvtfor1⩽t⩽i-1are the same as those insLi-1. Therefore,fLtx′,sLi-1=fLtx′,sLjfor any1⩽t⩽i-1. Thus,fLk′x′,sLj⩾fLtx′,sLjfor any1⩽t⩽i-1. We obtain thatTLx′,sLj=fLk′x′,sLj. Due tofLk′x′,sLj=fLk′x′,sLi-1andTLx′,sLi-1=fLk′x′,sLi-1, we haveTLx′,sLj=TLx′,sLi-1.□Based on the preceding two lemmas, we can easily computeTLx′,sLjforj=2,…,kinO(n)time, and computeTLx′,sLjforj=i,…,ninO(n)time provided that we know the valueTLx′,sLi-1.It remains to computeTLx′,sLtfort=k+1,…,i-1, for which we present anO(n)time algorithm below. Note that our algorithm itself is simple (see the pseudocode Algorithm 1), but it is not easy to discover the observations behind the scene. Our algorithm will compute a solution index listK={k1,k2,…,kd}with the following properties:Property 1k1=kandk1⩽k2⩽⋯⩽kd⩽i-1.For any j with1⩽j⩽d-1,fLkjx′,sLkj<fLkj+1x′,sLkj+1andfLkjx′,sL1⩾fLkj+1x′,sL1.For any j with1⩽j⩽d-1, for any t withkj⩽t<kj+1, eitherfLtx′,sLt⩽fLkjx′,sLkjorfLtx′,sL1<fLkj+1x′,sL1. Ifkd≠i-1, then for any t withkd⩽t⩽i-1,fLtx′,sLt⩽fLkdx′,sLkd.If we already have such a solution index list K, the lemma below provides a way to compute the valuesTLx′,sLtfork+1⩽t⩽i-1inO(n)time.Lemma 9For any scenariosLtwithk+1⩽t⩽i-1, ifkj<t⩽kj+1for some1⩽j⩽d-1, thenTLx′,sLt=maxfLkjx′,sLt,fLkj+1x′,sLt; ifkd≠i-1andkd<t, thenTLx′,sLt=fLkdx′,sLt.Consider any scenariosLtwithk+1⩽t⩽i-1. Recall thatTLx′,sLt=max1⩽m⩽i-1fLmx′,sLt. To simplify the notation, we usefm(st)to representfLmx′,sLt. Hence,TLx′,sLt=max1⩽m⩽i-1fm(st).We assumet⩽kdsince the caset>kdcan be proved in a much simpler way by the same techniques. Let j be the integer such thatkj<t⩽kj+1. To prove the lemma, it is sufficient to show thatmax{fkj(st),fkj+1(st)}⩾fm(st)for any m with1⩽m⩽i-1. To this end, there are three cases depending on the value ofm:1⩽m<kj,kj⩽m<kj+1, andkj+1⩽m⩽i-1. Below, in each case, we will show that eitherfm(st)⩽fkj(st)orfm(st)⩽fkj+1(st)holds.First of all, due tokj<tand by Lemma 6, the following holds(1)fkj(st)=fkj(skj).1.If1⩽m<kj, we assumekh⩽m<kh+1for someh<j. Note thatm<tholds in this case. See Fig. 5. By Lemma 6, we havefm(st)=fm(sLm). By Property 3 of the solution index list K, we have eitherfm(sm)⩽fkh(skh)orfm(s1)<fkh+1(s1).(a)Iffm(sm)⩽fkh(skh), then by Property 2 of K, sinceh<j, we can obtainfkh(skh)<fkh+1(skh+1)<⋯<fkj(skj). Thus, we havefm(st)=fm(sm)<fkj(skj). Sincefkj(st)=fkj(skj)by Eq. (1), we obtainfm(st)<fkj(st).Iffm(s1)<fkh+1(s1), then sincem<kh+1, we havefm(sm)=fm(s1)+α(2,m)andfkh+1(sm)=fkh+1(s1)+α(2,m), and thusfm(sm)<fkh+1(sm). Note thatfkh+1(sm)⩽fkh+1(skh+1). Further, due tokh+1⩽kj,fkh+1(skh+1)<fkj(skj)holds by Property 2 of K. Recall thatfm(st)=fm(sLm). Hence, we obtainfm(st)=fm(sLm)<fkj(skj)=fkj(st)by Eq. (1).Ifkj⩽m<kj+1, then by Property 3 of K, eitherfm(sm)⩽fkj(skj)orfm(s1)<fkj+1(s1).(a)Iffm(sm)⩽fkj(skj), then sincefm(st)⩽fm(sm)always holds by Lemma 6 regardless of whetherm⩽torm>t, we havefm(st)⩽fkj(skj)=fkj(st)by Eq. (1).Iffm(s1)<fkj+1(s1), then sincet⩽kj+1, we havefkj+1(st)=fkj+1(s1)+α(2,t)by Lemma 6. Also,fm(st)=fm(s1)+α(2,min{t,m}). Sincefm(s1)<fkj+1(s1)andα(2,min{t,m})⩽α(2,t), we havefm(st)⩽fkj+1(st).Ifkj+1⩽m⩽i-1, for simplicity of discussion, we assumem<kdand the casem⩾kdcan be proved very similarly but in a much simpler way. Letkh⩽m<kh+1for someh>j. Note thatt⩽kj+1⩽kh⩽m. See Fig. 6.First of all, we claim thatfm(st)⩽fkh(st). We prove the claim below.Indeed, by Lemma 6, we can obtainfm(sm)=fm(st)+α(t+1,m)andfkh(skh)=fkh(st)+α(t+1,kh). According to Property 3 of K, eitherfm(sm)⩽fkh(skh)orfm(s1)<fkh+1(s1).(a)Iffm(sm)⩽fkh(skh), then sinceα(t+1,m)⩾α(t+1,kh)(due tokh⩽m), we obtainfm(st)⩽fkh(st).Iffm(s1)<fkh+1(s1), then by Property 2 of K,fkh+1(s1)⩽fkh(s1). Thus, we obtainfm(s1)⩽fkh(s1). Due tot⩽kh⩽m, we havefm(st)=fm(s1)+α(2,t)andfkh(st)=fkh(s1)+α(2,t). Hence,fm(st)⩽fkh(st)holds.Therefore, the claimfm(st)⩽fkh(st)is proved.(a)Ifj+1=h, the above provesfm(st)⩽fkj+1(st).Ifj+1<h, we claim thatfkh(st)⩽fkj+1(st). Indeed, sincet⩽kj+1⩽khin this case, by Lemma 6,fkh(st)=fkh(s1)+α(2,t)andfkj+1(st)=fkj+1(s1)+α(2,t). By Property 2 ofK,fkh(s1)⩽fkj+1(s1). Therefore,fkh(st)⩽fkj+1(st)and the claim is proved. Sincefm(st)⩽fkh(st), we obtainfm(st)⩽fkj+1(st).In any case above, we have shown thatfm(st)⩽max{fkj(st),fkj+1(st)}holds. The lemma thus follows.□Suppose we have a solution index list K. After we compute the valuesfLkjx′,sL1forj=1,…,dinO(n)time, by Lemma 9 we can compute the valuesTLx′,sLtfor allk+1⩽t⩽i-1inO(n)time (with the help of Lemma 6).It remains to compute the solution index list K, for which we present a simple linear time algorithm as follows. We assume the valuesfLtx′,sL1fort=1,…,i-1have been computed inO(n)time.Our algorithm will consider the indices incrementally fromt=k+1tot=i-1. A stack A is maintained during the algorithm to store a sequence of indices. Initially A contains only one index k, and after the algorithm finishes the index list in A from bottom to top is exactly K. Algorithm 1 summarizes the pseudocode. For each t withk+1⩽t⩽i-1, the algorithm proceeds as follows. Letkjbe the index on the top of the current stack A. We first compare the two valuesfLtx′,sL1andfLkjx′,sL1. Note that both values have been computed. IffLtx′,sL1>fLkjx′,sL1, then we popkjout of A and consider the next top index on A (this is consistent with Property 3 of K and we ignore the detailed discussion on this). We claim that the stack A will never be empty because the index k is at the bottom of A. Indeed, recall thatTLx′,sL1=fLkx′,sL1by the definition of k. Hence,fLkx′,sL1⩾fLmx′,sL1for any1⩽m⩽i-1, and in particular,fLtx′,sL1⩽fLkx′,sL1. Therefore, k will never be popped out of A. IffLtx′,sL1⩽fLkjx′,sL1, we further compare the two valuesfLtx′,sLtandfLkjx′,sLkj. By Lemma 6,fLtx′,sLt=fLtx′,sL1+α(2,t)andfLkjx′,sLkj=fLkjx′,sL1+α(2,kj). Hence, bothfLtx′,sLtandfLkjx′,sLkjcan be computed in constant time. IffLtx′,sLt>fLkjx′,sLkj, then we push t on the top of A and setkj+1=t(this is consistent with Property 2 of K); otherwise, we ignore t (this is consistent with Property 3 of K) and proceed ont+1. Aftert=i-1is considered, we terminate the algorithm and the index list in the stack A is our solution index list K. The running time of the algorithm isO(n)because once an index is popped out of A it will never be considered again.Algorithm 1Computing the solution index listK={k1,…,kd}Input: The index k, the valuex′, the scenariosL1, the weight intervalswi-,wi+Output: The solution index listK={k1,…,kd}1 do preprocessing for answeringα(·,·)queries;2 fort←1toi-1do3determine the functionfLtx,sL1and compute the valuefLtx′,sL1;4 end5 initialize a stack A and push k into A;6 fort←k+1toi-1do7m←the top index inA;8whilefLtx′,sL1>fLmx′,sL1do9pop m out of A;10m←the top index inA;11end12fLtx′,sLt←fLtx′,sL1+α(2,t);13fLmx′,sLm←fLmx′,sL1+α(2,m);14iffLtx′,sLt>fLmx′,sLmthen15push t on the top of A;16end17 end18 return the index list in A from bottom to top as K;We conclude this section with the following theorem.Theorem 2The optimal positionx∗for the minmax regret problem and the optimal maximum regretRmax(x∗)can be computed inO(nlogn)time andO(n)space.In this paper, we presented anO(nlogn)time andO(n)space algorithm for the minmax regret 1-facility location problem on uncertain path networks. Very recently some other problem variations have been introduced and algorithms for them have been proposed. Li, Xu, and Ni (2014) studied the problem for finding two facilities and gave anO(n3logn)time algorithm. Ni, Xu, and Dong (2014) developed anO(n1+klog1+logkn)time algorithm for finding k facilities for a general value of k, and Arumugam, Augustine, Golin, and Srikanthan (2014) gave two algorithms for the same problem with time complexitiesO(kn2logkn)andO(kn3logn), respectively. Higashikawa, Golin, and Katoh (2014) investigated the problem for finding a 1-facility on a tree network and proposed anO(nlog2n)time algorithm. It would be interesting to see whether the techniques presented in this paper can be used for solving these problem variations.

@&#CONCLUSIONS@&#
