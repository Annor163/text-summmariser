@&#MAIN-TITLE@&#
Efficient algorithm for finding the exact minimum barrier distance

@&#HIGHLIGHTS@&#
Introduction of fast algorithm for the exact values of minimum barrier distance, MBD.Comparison of the novel algorithm with its approximate versions.Experimental comparison MBD induced segmentations with other segmentation algorithms.

@&#KEYPHRASES@&#
Image processing,Distance function,Distance transform,Minimum barrier,Path strength,Segmentation,Fuzzy Connectedness,Fuzzy distance,

@&#ABSTRACT@&#
The minimum barrier distance, MBD, introduced recently in [1], is a pseudo-metric defined on a compact subset D of the Euclidean spaceRnand whose values depend on a fixed map (an image) f from D intoR. The MBD is defined as the minimal value of the barrier strength of a path between the points, which constitutes the length of the smallest interval containing all values of f along the path.In this paper we present a polynomial time algorithm, that provably calculates the exact values of MBD for the digital images. We compare this new algorithm, theoretically and experimentally, with the algorithm presented in [1], which computes the approximate values of the MBD. Moreover, we notice that every generalized distance function can be naturally translated to an image segmentation algorithm. The algorithms that fall under such category include: Relative Fuzzy Connectedness, and those associated with the minimum barrier, fuzzy distance, and geodesic distance functions. In particular, we compare experimentally these four algorithms on the 2D and 3D natural and medical images with known ground truth and at varying level of noise, blur, and inhomogeneity.

@&#INTRODUCTION@&#
The distance transform, DT, mappings [1–8] have been widely used as the effective tools for analyzing object morphology and geometry [9–11]. The valueDT(x)of a distance transform map at a point x from the domain C of DT is usually defined as a (possibly signed) distance of x from a fixed target setB⊂C, the distance measured with respect to some fixed (possibly generalized) metric on C. Most commonly, C is a bounded subset of the Euclidean spaceRnand DT is defined in terms of the Euclidean distance. For the rectangular shape digital domains C, a fast algorithm for finding the approximate values of the Euclidean distance transform was introduced by Rosenfeld and Pfaltz [12]. An algorithm for computing the exact values of such transform in linear time for the n-dimensional images was described in [13,14] and elaborated on in [15]. Such algorithms for the 2-dimensional images were also presented in [16,17].The distance transforms used in the image processing commonly take into account the image data [6,18–20]. Most of the distance notions used in such setting define the distance between two points in the image’s scene as the minimum cost of a path connecting such points, where the path cost functions depend on the image intensity and differ for different methods. Such defined distance measures include the connection value (a variant of Rosenfeld’s degree of connectivity [21–23]), which allows for an equivalent characterization of topological watersheds, leading to an efficient Watershed (WS) segmentation algorithm [24,25], as well as the geodesic distance (see e.g. [26]). Moreover, the degree of connectivity, on the basis of which the Fuzzy Connectedness (FC) algorithms are defined, can be also treated as the distance measure defined in the same form. (See e.g. [27,28,20].) Falcão et al. [20] proved that for a general class of the path cost functions, called smooth, including the three examples mentioned above, the related distance transform can be found via Dijkstra’s algorithm. For the case of FC, this was further elaborated in [29], including the discussion of the related results from the papers [30,31].The subject of this paper is the study of the distance transform for the minimum barrier distance, MBD, and of the segmentation algorithms associated with it. The MBD for an image f is defined from the path cost function, called barrier strength, in a manner described above, where the barrier strength of a path constitutes the length of the smallest interval containing all values of f along the path. However, the barrier strength path cost function is not smooth in the sense defined in [20]. In fact, the naturally defined Dijkstra’s algorithms for barrier strength path cost function do not need to return the exact values for MBD. Nevertheless, the output of such algorithms approximate MBD, as proved in [1] and shortly described in what follows.Section 2 introduces a general framework for constructing the generalized distance mappings. We represent within this framework: the Minimum Barrier Distance, geodesic distance, fuzzy distance, as well as the distance notions that stand behind two popular segmentation algorithms, Fuzzy Connectedness (FC) and Watershed (WS). We also discuss, how the generalized distance mappings can be used to naturally define an image segmentation via seeds competition. In the case of FC theory, this gives the Relative Fuzzy Connectedness (RFC) objects. In Section 3 we introduce the new algorithm, that calculates the MBD in polynomial time. We also discuss, how this new algorithm relates to the standard Dijkstra’s algorithm, which can be used to calculate the other distance notions mentioned above.In Section 4 we present our experimental results. In particular, in Section 4.1 we compare different versions of the algorithms that compute MBD (approximately and exactly) with respect to the execution time and accuracy. In Sections 4.2 and 4.3 we compare the segmentation algorithms corresponding to MBD with the segmentation algorithms corresponding to other distance transforms, that is, with Fuzzy Connectedness, and these corresponding to the geodesic and fuzzy distances. The comparison is quantitative (stability to noise, blur, and the choice of seed points) and qualitative.In this section we review the constructions of the generalized distance mappings (or generalized metrics) on a set C, which we define as symmetric functionsd:C2→[0,∞]that satisfy the triangle inequality. (We allow possibility thatd(c,c)>0for somec∈C.) The construction encompasses the Minimum Barrier Distance as well as several other popular distance mappings used in imaging. We notice that any generalized distance can be used to naturally define an image segmentation via seeds competition forc∈C. In particular, two popular segmentation algorithms, Relative Fuzzy Connectedness (RFC) and Watershed (WS), fall into this category.Most of the theoretical results that follow are independent of image processing interpretation and are presented in a general graph-theoretical setting. Nevertheless, we point out to the image processing applications at each step of our exposition.In this paper a digital image is identified with its intensity (or attribute) functionf:C→Rℓ, where C is its domain (whose elements will be referred to as spels, short for space elements) and the valuef(c)of f atc∈Crepresents image intensity (anℓ-dimensional vector, each component of which indicates a measure of some aspect of the signal, like tissue property or color) at the spel c. It is assumed that image domain comes with an adjacency relation, that decides which pairs of spels are adjacent. An image domain C together with its adjacency structure is referred to as a scene. In the experimental sections we will concentrate on the images on the rectangular scenesC=∏i=1k{1,…,ni},k=2,3, with either 4-adjacency, in 2D, or 6-adjacency, in 3D.By a graph we understand a pairG=〈C,E〉with C representing a finite set of its vertices and E the set of its edges G, where an edge connecting c and d from C is identified with an unordered pair{c,d}. In the image processing applications, we concentrate on the graphs associated with the imagesf:C→Rℓin which the vertices are the spels (the elements of C) and the set E of edges coincides with the adjacency relation of the image’s scene.A path in a graphG=〈C,E〉is any sequenceπ=〈π(0),π(1),…,π(k)〉of vertices such that{π(i),π(i-1)}∈Efor everyi∈{1,2,…,k}. A pathπ=〈π(0),π(1),…,π(k)〉is from s to c whenπ(0)=sandπ(k)=c. A family of all paths in G from ans∈Sto c is denoted byΠS,c. We will also writeΠs,cforΠ{s},c.Now, assume that with any pathπin G we have associated its cost: a numberλ(π)⩾0treated as the “length” ofπ. (The examples of such functionsλare given below.) With any suchλwe associate a mappingdλ:C2→[0,∞](which need not be a generalized distance) defined asdλ(c,d)=min{λ(π):πisapathinGfromctod}.In what follows we work mostly with the connected graphs, that is, such that for any vertices c and d there is a path in G from c to d. In such case, all values ofdλare finite.In general,dλneed not be a generalized distance. However, it must be under the assumptions of the following easy fact.Proposition 1Assume that for every pathπ=〈π(0),π(1),…,π(k)〉(i)λ(π)=λ(〈π(k),π(k-1),…,π(0)〉), andλ(π)⩽λ(〈π(0),…,π(i)〉)+λ(〈π(i),…,π(k)〉)for every0⩽i⩽k.Thendλis symmetric and it satisfies the triangle inequality.Since all path length functions we consider here (except for the auxiliary mapβw-) satisfy the assumptions of Proposition 1, all considered functionsdλare the generalized metrics.In the standard examples, the mappingsλare defined in terms of graph’sG=〈C,E〉weight functions: either vertex weightw:C→[0,∞)or edge weightw:E→[0,∞). In image processing, such weight functions are defined in terms of the intensity functionf:C→Rℓ. (See Section 4 for more on the weight mappings.)For an edge weight mapw:E→(0,∞), where the valuew({c,d})is a (geodesic) distance from c to d, and the path length functionΣ(〈π(0),π(1),…,π(k)〉)=∑i=1kw({π(i-1),π(i)}), the resulted functiondΣis the geodesic metric. (For the length one pathπ=〈π(0)〉, the formula is interpreted asΣ(π)=0.)For a vertex weight mapw:C→[0,∞), associated edge weight mapwˆ:E→[0,∞)defined aswˆ(c,d)=w(c)+w(d)2, and the path length functionΣ^(〈π(0),π(1),…,π(k)〉)=∑i=1kwˆ({π(i-1),π(i)}), the resulted functiondΣ^is the fuzzy distance. (For the length one pathπ=〈π(0)〉, the formula is interpreted asΣ^(π)=0.) Clearly the fuzzy distance is a pseudo-metric, that is, it is symmetric and satisfies the triangle inequality (as the assumptions of Proposition 1 hold forλ=Σ^); moreover,dΣ^(c,c)=0for everyc∈C. (However,dΣ^(c,d)can be equal 0 forc≠d.) See [6,19] for more on the fuzzy distance.This is defined for an affinity weight mappingκ:E→[0,M](usually withM=1) interpreted: the closer the value ofκ({c,d})is to M, the stronger the vertices c and d are connected. The standard Fuzzy Connectedness strength of a pathπ=〈π(0),π(1),…,π(k)〉is defined asμ(π)=mini=1,…,kκ({π(i-1),π(i)}), that is, the weakest link ofπ; the value ofμ(〈π(0)〉)is interpreted as M. The Fuzzy Connectedness path length is defined asλ(π)=M-μ(π)=maxi=1,…,kw({π(i-1),π(i)}), wherew({c,d})=M-κ({c,d}); that is,λ(π)is the biggest w-length of a link inπ. Then the Fuzzy Connectedness distance mapdλbecomesdλ(c,d)=M-μ(c,d), whereμ(c,d)=max{μ(π):π∈Πc,d}is the standard FC connectivity strength. Note, that this distancedλis also a pseudo-metric. For more on this subject see [27,28]. Compare also [24,25,30].This is defined for the vertex weight mappingw:C→[0,∞), where the valuew(c)is interpreted as an elevation at c. Then, for the path length functionλ=βw+defined asβw+(〈π(0),π(1),…,π(k)〉)=maxi=0,…,kw(π(i)),the related distance functiondλ=dβw+is usually referred to as the connection value and it leads to the Watershed (WS) segmentation algorithm [24,25]. The connection value related mapdλis a generalized metric; however, it is not pseudo-metric, sincedλ(c,c)can be greater than 0. In what follows we will use also the dual path length functionλ=βw-defined asβw-(〈π(0),π(1),…,π(k)〉)=mini=0,…,kw(π(i)).Notice that ifM=maxc∈Cw(c)and the weight function v is defined asv(c)=M-w(c), then the mappingdβw-∗=M-dβv+satisfiesdβw-∗=max{βw-(π):isapathinGfromctod}.In particular, an algorithm that calculatesdβv+can be also used to finddβw-∗.This is defined for the vertex weight mappingw:C→[0,∞). The path length functionλ=βw, referred to as the barrier strength, is defined for a pathπ=〈π(0),π(1),…,π(k)〉asβw(π)=βw+(π)-βw-(π)=maxi=0,…,kw(π(i))-mini=0,…,kw(π(i)).The related Barrier Distance mapdλ=dβwis a pseudo-metric [1].Let d be a generalized distance on C. For ac∈Cand a non-emptyW⊂Cdefined(c,W)=min{d(c,w):w∈W}. For any two non-empty setsS⊂CandT⊂Cof seeds, S indicating the object and T indicating the background, we associate the objectPd(S,T)={c∈C:d(c,S)<d(c,T)}.Of course, we would expect that(ST)Pd(S,T)contains S and is disjoint with T.This is guaranteed only for a proper choice of the seed sets S and T. In particular, if d is a metric (e.g., geodesic), then (ST) holds precisely when S and T are disjoint. For the pseudo metric d (like the case of FC and MBD), (ST) holds precisely when the numberd(S,T)=min{d(s,T):s∈S}is greater than 0.For the Fuzzy Connectedness pseudo metricdλ, as defined above, the objectPd(S,T)is precisely the Relative Fuzzy Connectedness, RFC, object. The Watershed object is also often defined asPd(S,T)(with respect to the distancedβw+). Similarly, the delineated objects for the geodesic, fuzzy, and MB distances we define asPd(S,T)for their respective distance functions. In either case, the segmentation into k-objects, indicated by the seed setsS1,…,Skcan be defined as{Pd(Si,Ti):i=1,…,k}, where the setTiis equal to(S1∪⋯∪Sk)⧹Si.Letλbe an arbitrary path cost function on a graphG=〈C,E〉. We assume that the cost of an empty path is infinite:λ(∅)=∞. Also, for any pathπ=〈π(0),π(1),…,π(k)〉and c connected by an edge withπ(k),π∧cis a concatenation path〈π(0),π(1),…,π(k),c〉.Notice, that for the path cost functions we consider, the value ofλ(π∧c)can be calculated from the value ofλ(π)inO(1)time. (More precisely, in the case of the barrier distance, we need to use the values ofβ-(π)andβ+(π)to findβ-(π∧c)andβ+(π∧c)inO(1)time.) Therefore, for the complexity considerations, we will assume that the values ofλ(〈r〉), as well as that ofλ(π∧c)usingλ(π), can be found inO(1)time.Algorithm 1Dijkstra’s algorithmDA(λ,R)Input: Path cost functionλon a graphG=〈C,E〉, non-emptyR⊂C.Output: For everyc∈C, a pathπcfrom anr∈Rto c andL(c)=λ(πc).Auxiliary: Ordered queue Q: if c precedes d in Q, thenL(c)⩽L(d).begin1: For allc∈C⧹Rinitializeπc=∅andL(c)=∞;2: For allr∈Rinitializeπr=〈r〉andL(r)=λ(πr), push allr∈Rto Q;3: whileQ is not empty do4:  Pop d from Q;5:for everyc∈Cconnected by an edge to ddo6:  Calculateℓ=λ(πd∧c)usingL(d);7:ifℓ<L(c)then8:Putπc=πd∧c,L(c)=ℓ, place c to an appropriate place in Q;9:end if10:end for11: end while12: Return pathsπcand numbersL(c)=λ(πc);endConsider the version of the Dijkstra’s algorithm presented as Algorithm 1. The algorithm always stops and, for the connected graphs, the returned pathsF={πc:c∈C}form a forest rooted at R (i.e., any path in F starts at anr∈Rand F contains any initial segment of a path in F). It is easy to see that ifλis the path cost function for geodesic, Fuzzy Connectedness, or watershed distance, then the algorithmDA(λ,R)returnsλ-minimal paths, that is, having the property thatdλ(c,R)=λ(πc)for everyc∈C. (All these path cost functions are smooth, in the sense of [20].) On the other hand, for the barrier strength cost functionλ=βw, this is not the case, as could be seen on the graph from Fig. 1. Indeed, the two pathsπ1=〈s,a,d,s〉andπ2=〈s,b,d,s〉between s and c have the barrier weightsβw(π1)=.8-.4=.4andβw(π2)=.8-.5=.3, and sodβw(s,c)=βw(π2)=.3. However, the initial restrictionπ=〈s,b,d〉ofπ2is notdβw-optimal for d (asβw(π)=.7-.5=.2, whiledβw(s,d)=βw(〈s,a,d〉)=.5-.4=.1<βw(π)), which is impossible for the Dijkstra’s algorithm.Even for the good cases, when Algorithm 1 returnsλ-optimal paths, it seems that to find the objectPdλ(S,T)={c∈C:dλ(c,S)<dλ(c,T)}it is necessary to run DA twice:DA(λ,S)to computedλ(·,S)andDA(λ,T)to computedλ(·,T). To avoid this, in the experiments we used a modificationDA∗(λ,S,T)ofDA(λ,W)withW=S∪Tobtained by replacing the condition “ℓ<L(c)” in line 7 with “either λ(πdˆc)<λ(πc) orℓ=L(c)andπc(0)∈Sandπd(0)∈T.”The additional condition insures, that for the path of same strength, the algorithm favors those that initiate at T.IfF={πc:c∈C}is a forest returned byDA∗(λ,S,T), then the objectPdλ∗(S,T)={c∈C:πc(0)∈S}is uniquely defined, in a sense that any two forests returned byDA∗(λ,S,T)(which may be different, subject to possible differences in order of processing the vertices from Q) lead to the same setPdλ∗(S,T). Moreover,Pdλ∗(S,T)containsPdλ(S,T)and is disjoint withPdλ(T,S); in other words,Pdλ∗(S,T)is a union ofPdλ(S,T)and some of the vertices from the “boundary” set{c∈C:dλ(c,S)=dλ(c,T)}. All these facts onPdλ∗(S,T)were rigorously proved in [29] for the FC case, showing, in particular, thatPdλ∗(S,T)is the Iterative Relative Fuzzy Connectedness, IRFC, object studied earlier. The arguments presented in [29] easily generalize to the case of a general path cost function.Letφ(c,d)=min{βw+(π):π∈Πc,d}-max{βw-(π′):π′∈Πc,d}, that is,φ(c,d)=dβw+(c,d)-dβw-(c,d).Clearly,φ(c,d)⩽dβw(c,d), that is,φgives a lower bound for the MBDdβ. The equation need not hold, asφ(s,d)=0<.1=dβw(s,d)for the example from Fig. 1. Nevertheless, for image induced graphs, the mapφapproximates the MBD, as proved in [1] and explained in more details in Theorem 1. The additional advantage of usingφas an approximation of MBD is that its values can be easily computed by the following algorithm introduced in [1].Algorithm 2AMBDappr({s})Input: A vertex weight map w on a graphG=〈C,E〉, ans∈C.Output: A mapφ(·,{s}).begin1: RunDAβw+,{s}and recorddβw+(c,{s})=βw+(πc)for everyc∈C;2: RunDAβv+,{s}, wherev=M-wandM=maxc∈Cw(c),and recorddβw-(c,{s})=M-βv+(πc)for everyc∈C;3: Return mapφ(c,{s})=dβw+(c,{s})-dβw-(c,{s});endThe following theorem is a variant of a theorem proved in [1]. It specifies an upper bound of a difference between MBD andφ.Theorem 1LetG=〈C,E,w〉be a vertex weighted graph of a rectangular k-D image and letε=max{|w(x)-w(y)|:x,y∈Care(3k-1)-adjacent}. Then for everyc,d∈Cthere exists a pathπ∈Πc,dwith the range indβw-(c,d)-ε,dβw+(c,d)+ε. In particular,0⩽dβ(c,d)-φ(c,d)⩽2ε, that is,φapproximates the MBD with at most2εerror.The proof of the theorem translates the discrete MBD to the continuous case and uses the fact that in the continuous case the distanceφcoincides with MBD. This last fact is based heavily on a version of Alexander’s lemma (see e.g. [32, p. 137]), a deep topological result.Unfortunately, the numberφ(·,S)returned byAMBDappr(S)well approximates the MBD distancedβw(c,S)only when S is a singleton. Thus, for larger sets S, to findφ(·,S)usingAMBDapprwithin2εerror, it is necessary to runAMBDappr({s})for everys∈Sto find mapsφ(·,{s})and, at the end, computeφ(·,S)asmins∈Sφ(·,{s}). Then, the approximation given by Theorem 1 still holds. However, such a procedure essentially increases the computational complexity of findingφ(·,S).Of course, the forest{πc:c∈C}returned by the algorithmDA(βw,R)gives an upper boundβw(πc)of MBD mapdβw(c,R). However, there is no known theoretical result giving an upper bound for the error for the differenceβw(πc)-dβw(c,R). Nevertheless, all three measures,φ(c,s),dβw(c,s), andβw(πc), are experimentally compared, see Section 4.1.The proof of correctness of the main algorithm presented in this section,AMBD, is a bit involved. However, an idea behindAMBDis relative simple and can be already seen in its simpler version, presented here as the algorithmAMBDsimple(S). Therefore, we start here with the discussion ofAMBDsimple(S).For a vertex weight map w on a graphG=〈C,E〉and ana∈Rdefine a modified vertex weight mapwaaswa(c)=w(c)providedw(c)⩾aandwa(c)=∞otherwise.Theorem 2The pathspcreturned byAMBDsimple(S)indeed satisfyβw(pc)=dβw(c,S). Moreover, ifn=|C|, the size of C, and we assume thatO(|E|)=n, thenAMBDsimple(S)stops after at mostO(n2lnn)operations.In addition, if the range of w is a subset of a fixed set of sizem⩽n, then there exists a small modification ofDA(βw+,S)such thatAMBDsimple(S)requires at mostO(m2n)operations.AMBDsimple(S)Input: A vertex weight map w on a graphG=〈C,E〉, non-emptyS⊂C.Output: For everyc∈Ca pathpcfrom S to c withβw(pc)=dβw(c,S).begin1: Initialize:U=max{w(s):s∈S}; forc∈C,pc=∅andβw(pc)=∞;2: Push all numbers from{w(c)⩽U:c∈C}to a queue Q, each only once;3: whileQ is not empty do4:  Pop a from Q; runDA(βv+,S)withv=wa, returningπc’s &βv(πc)’s;5:for everyc∈Cdo6:ifβv(πc)<βw(pc)then7:Putpc=πcand update the value ofβw(pc)toβv(pc);8:end if9:end for10: end whileendNotice that if there exists a pathπfrom S to c with the range in[a,∞), then the pathπcreturned byDA(βv+,S)withv=waalso has this property. This immediately implies correctness of the algorithm.The first complexity estimate follows from the fact that the complexity of the standard form ofDA(βw+,S)isO(nlnn), while we run it at most n-many times. The second complexity estimate follows from the fact that, under the assumption, there is a form ofDA(βw+,S)that runs inO(mn)time, as shown in [29] (compare discussion below), and that in this case the loop is executed at most m times.□Notice that in image processing it is very common that indeed m is a lot smaller than n, in which case the complexity ofAMBDsimplebecomesO(n). However, the constants in this estimate are significant, soAMBDsimpleruns many times (of orderO(m)) slower thanDAβw+,S.As it can be seen, an idea behind the algorithmAMBDsimpleis that for everyc∈Cwe consider all possible lower boundsβw-(π)among the pathsπ∈ΠS,cand, for each such lower bound a, we find a pathaπminimizingβw+; thenβw-minimizer ofΠS,cis found among suchaπ’s. This idea is also present in the algorithmAMBD, though in its dual form: we consider all possible upper boundsβw+(π)among the pathsπ∈ΠS,cand, for each such upper bound b, we find a pathbπmaximizingβw-; aβw-minimizer ofΠS,cis one of thebπ’s with the smallestβw-value. The main difference betweenAMBDsimpleandAMBDis in how we choose “all possible one-sided bounds:” in the case ofAMBDsimplewe consider for this purpose alla∈W,a⩽U. InAMBDthis process is considerably more subtle.More precisely,AMBDcan be considered as a Dijkstra’s algorithm for findingπc∈ΠS,cwith the minimal value ofβw-(πc), in which “ill-advised order” of the queue Q is used: instead of ordering Q according to the values ofβw-of already found paths, we order it according the values ofβw+of such paths. Although this order would be suboptimal if we were only to find theβw--optimal paths, this allows us: (1) to consider as “all possible upper bounds ofπ∈ΠS,c” only the upper bounds of the paths examined during the execution of the algorithm; (2) while considering such an upper bound, say b, to examine all pathsπ∈ΠS,cwithβw+(π)⩽b, to choose among such paths one, saybπ, with the largest lower bound, and to update our current bestβw-estimatepcamongπ∈ΠS,ctobπ, if appropriate.Algorithm 4AMBD(S)Input: A vertex weighted graphG=〈C,E,w〉, non-emptyS⊂C.Output: For everyc∈Ca pathpcfrom ans∈Sto c such that the numberβw(pc)is the minimum barrier distance from S to c.Auxiliary: For everyc∈Ca pathπcfrom S to c beingβw--optimal.A priority queue Q: if c precedes d in Q then eitherβw+(πc)<βw+(πd)orβw+(πc)=βw+(πd)andβw-(πc)⩾βw-(πd).begin1: For everys∈Sinitialize:ps=πs=〈s〉andβw-(πc)=βw+(πc)=w(s);2: For everyc∈C⧹Sput:pc=πc=∅,βw-(πc)=-∞, andβw+(πc)=∞;3: Push alls∈Sto Q;4: whileQ is not empty do5:  Pop c from Q;6:for everyd∈Cconnected by an edge to cdo7:  SetL-←βw-(πc∧d)=min{βw-(πc),w(d)};8:  SetL+←βw+(πc∧d)=max{βw+(πc),w(d)};9:ifL->βw-(πd)then10:Setπd←πc∧d,βw-(πd)←L-,βw+(πd)←L+,βw(πd)←L+-L-;11:Remove d from Q, if needed; place d into (a right place) in Q;12:ifβw(πd)<βw(pd)then13:Setpd←πd;14:end if15:end if16:end for17: end whileendThe proof of the complexity (but not of the correctness) ofAMBD(S), presented in Theorem 3, requires the assumption that the graph’s degree (i.e., the largest number of edges connected to a single vertex) is small,O(1), with respect to the size n of the set C of graph’s vertices. This assumption is essentially always true for the graphs associated with images. Moreover, we make some additional assumptions about the structure of the queue Q it utilizes. Actually, the algorithm works correctly if Q has a simple structure of a double linked list. However, in such structure the insertion of a vertex, as in the line 11 ofAMBD, would requireO(n)operation. Therefore, we will consider two other structures for Q. The first is a binary heap that allows insertion and deletion of any element inO(lnn)time [33]. However, for the graphs associated with image processing, the set Z of possible values of a weight function w is usually restricted to a fixed set of a modest size, most frequently of a formZ={i/D:i=0,1,…,m}for m not exceeding212=4096. In this case, Q can be defined as an array of buckets indexed by the setV={〈β+,β-〉∈Z2:β+⩾β-}and ordered as described in the algorithmAMBD. This is, essentially, the structure described in [29]. Each bucket with an index〈β+,β-〉∈Vconsists of the pointers to vertices c for whichβw+(πc)=β+andβw-(πc)=β-. An advantage of Q to be represented in such an array format is that this allowsO(1)-time insertion into Q and deletion from Q of any element c with a fixed label〈z,ℓ〉. Emptying Q in the priority order from the largest to the smallest vertex in V, as done when executing line 5 of the algorithm, may requireO(|V|)=O(m2)operations during the complete execution ofAMBDsimple(S). For large images,O(m2)is usually considered as smaller thanO(n), favoring the array of buckets implementation. However, in our implementations, includingAMBDsimple(S), we use Dijkstra’s algorithm with the binary heap queue structure.Theorem 3On the correctness and complexity ofAMBD(S)Correctness: AfterAMBD(S)terminates, we haveβw(pc)=dβw(c,S)for allc∈C.Complexity: Let n be the size of the graph and m be the size of a fix set Z, containingW={w(c):c∈C}. The algorithm computational complexity is either(BH)O(mnlnn), if we use binary heap as Q, or(LS)O(m(n+m)), if we use as Q a list structure described above.a vertex d can be popped from the queue, line 5, at most m times.To see this property, notice that with an ith appearance of d in Q we associate, in line 11, a pathπdifrom S to d. For d to appear in Q for the(i+1)-st time, we must have executed the line 11, meaning thatβw-πdi+1>βw-πdi. This means that〈βw-πdi〉iis a strictly increasing sequence of numbers from W. So, the sequence cannot have more than m elements and (∗) is proved.Now, in the case of (BH), (∗) implies that the loop can be executed at mostmn-times, meaning that the algorithm’s complexity isO(mnlnn).In the case of (LS), the true execution of the loop isO(mn). However, in addition, we may needO(m2)operations for searching, in line 4, for the top of the queue. This gives complexityO(mn)+O(m2)=O(m(n+m)).□Before we prove the correctness ofAMBD(S), it might be useful to follow the execution ofAMBD({s})for the graph from Fig. 1. In this example, we use the convention thatβw+(∅)=∞andβw-(∅)=-∞. After the execution of lines 1–3, we haveπs=ps=〈s〉, and this state does not change, so we will not list it below. The state of the remaining variables is listed as follows, where index i represents the time just before the ith execution of line 4 (so state 1, is just after the initialization).1:πx=px=∅forx∈{a,b,c,d}andQ=〈s〉;2:πa=pa=〈s,a〉,πb=pb=〈s,b〉,πc=pc=∅,πd=pd=∅,Q=〈a,b〉(βw+(πa)=.5<.7=βw+(πb));3:πa=pa=〈s,a〉,πb=pb=〈s,b〉,πc=pc=∅,πd=pd=〈s,a,d〉,Q=〈d,b〉(βw+(πd)=.5<.7=βw+(πb));4:πa=pa=〈s,a〉,πb=pb=〈s,b〉,πc=pc=〈s,a,d,c〉,πd=pd=〈s,a,d〉,Q=〈b,c〉(βw+(πb)=.7<.8=βw+(πc));5:πa=pa=〈s,a〉,πb=pb=〈s,b〉,πc=pc=〈s,a,d,c〉,pd=〈s,a,d〉,πd=〈s,b,d〉,Q=〈d,c〉(βw+(πd)=.7<.8=βw+(πc));6:πa=pa=〈s,a〉,πb=pb=〈s,b〉,πc=pc=〈s,b,d,c〉,pd=〈s,a,d〉,πd=〈s,b,d〉,Q=〈c〉;7:πa=pa=〈s,a〉,πb=pb=〈s,b〉,πc=pc=〈s,b,d,c〉,pd=〈s,a,d〉,πd=〈s,b,d〉,Q=∅;Pop c from Q; Setj←j+1andM¯[j]=βw+(πc).Let〈M‾[j]〉jbe the array recorded during the execution of the algorithm. Then, by the order imposed on Q, it is non-decreasing (i.e.,M¯[k]⩽M¯[k+1]for all allowable indices k).For any real number M define the setsΠM={π∈Π:βw+(π)⩽M}andΠ<M={π∈Π:βw+(π)<M}. We prove that for everyM∈Wthe following property holds. This will finish the proof, since (•) forM=maxWis precisely the desired correctness of the algorithm.(•)Let k be the largest index withM¯[k]⩽M. Then, for everyd∈CwithΠS,d∩ΠM≠∅, after the kth execution of the loop 5–16 we have(a)πdmaximizesβw-onΠS,d∩ΠM, andpdminimizesβwonΠS,d∩ΠM.To see (a), for everym∈Wandℓ=1,2,…consider the property:(aℓm)For everyd∈C, if there exists aπ∈ΠS,d∩ΠMof length⩽ℓsuch thatβw-(π)⩾mandπmaximizesβw-onΠS,d∩ΠM, thenπdalso maximizesβw-onΠS,d∩ΠM.We need to show that (aℓm) holds for everym∈Wandℓ=1,2,…. To prove this, forμ∈Wconsider the statement:(aμ)The property (aℓμ) holds for everyℓ=1,2,….By the power of recursion, it is enough to prove that for everym∈W: if (aμ) holds for everyμ>mwithμ∈W, then (am) is also true.So, fix anm∈Wand assume that (aμ) holds for everyμ>mwithμ∈W. We must show (am), that is, that (aℓm) holds for everyℓ=1,2,…. This will be proven by induction onℓ.Clearly,aℓmholds forℓ=1, since in this case we need only to consider d from S and thenπdmust be equal〈d〉, what is insured in line 1. So, assume that for someℓ=1,2,…the propertyaℓmholds. We need to proveaℓ+1m. To seeaℓ+1m, fix aπ=〈c0,…,cℓ〉∈ΠS,dmaximizingβw-onΠS,d∩ΠM, for whichβw-(π)⩾m. We need to show thatπdmaximizesβw-onΠS,d∩ΠM.Ifμ=βw-(π)>m, then this maximization is insured by (aμ). So, assume thatβw-(π)=mand letπ′=〈c0,…,cℓ-1〉. Notice that forc=cℓ-1,(∗)πcmaximizesβw-onΠS,c∩ΠM.Indeed, ifβw-(π′)>m, then for anyπ″maximizingβw-onΠS,c∩ΠM(which may have length greater thanℓ) we haveβw-(π″)⩾βw-(π′)>m. Thus, (∗) is insured by (aμ). On the other hand, ifβw-(π′)=m, then (∗) is insured byaℓm.Finally, notice that, by (∗), vertex c, together with the pathπc, must have been placed into Q prior to kth execution of the loop 5–16 (through the execution of either line 3 or line 11). Therefore, for somek′⩽k, this c, with the same pathπc, is popped from Q and after the consecutive execution of the lines 10–11 we must haveβw-(πd)=max{βw-(πc),w(d)}⩾m=βw-(π). This means, thatπdmaximizesβw-onΠS,d∩ΠM, finishing the proof of (a).We prove part (b) by induction along the increasing order of W. So, letM∈Wbe such that (b) holds for everyM′∈Wsmaller than M. By the power of induction, it is enough to prove that (b) holds for M. So, fix ad∈CwithΠS,d∩ΠM≠∅and letπbe a path minimizingβwonΠS,d∩ΠM. Let p be equal the value ofpdafter the kth execution of the loop 5–16. Clearlyp∈ΠS,d∩ΠM. To finish the proof, it is enough to show that p minimizesβw, that is, thatβw(p)⩽βw(π).IfM′=βw+(π)is less than M, then, by the inductive assumption, for somek′<k, after thek′th execution of the loop 5–16 we haveβw(pd)⩽βw(π). Clearly, the value ofβw(pd)cannot increase during the algorithm’s execution, so after the kth execution of the loop 5–16 stillβw(p)=βw(pd)⩽βw(π), that is, p minimizesβwonΠS,d∩ΠM. Therefore, in what follows we can assume thatβw+(π)=M.IfΠS,d∩Π<M=∅, then, by part (a), for somek′⩽k(withM¯[k′]=M), during thek′th execution of the loop 5–16,πdbecomes a maximizer ofβw-onΠS,d∩ΠM. Thenβw+(πd)=M, sinceπd∉Π<M. Thus, the execution of lines 12–14 during the same execution of the loop insures that, from this point on,pdalso minimizesβwonΠS,d∩ΠM. So, in what follows we can assume thatΠS,d∩Π<M≠∅.SinceΠ<M≠∅, there exists anM′∈W(the largest number in W smaller than M) such thatΠM′=Π<M. In particular,ΠS,d∩ΠM′≠∅. By the inductive assumption, (•) holds forM′. So, letk′be the largest index withM¯[k′]⩽M′and let andπ′be the pathπdimmediately after thek′th execution of the loop 5–16. Then,π′maximizesβw-onΠS,d∩ΠM′. Letm′=βw-(π′).Next, notice thatm′<βw-(π). Indeed, the inequalitym′⩾βw-(π)would implyβw(π′)⩽M′-m′<M-βw-(π)=βw(π), contradicting the fact thatπminimizesβwonΠS,d∩ΠM. Therefore, the maximum ofβw-onΠS,d∩ΠMis strictly greater than the maximum ofβw-onΠS,d∩ΠM′. So, by (a), there exists ak″∈(k′,k]such that during thek″th execution of the loop 5–16, the condition on line 9 is satisfied. In particular, directly after the execution of the line 10,m′⩽βw-(πd)⩽M, implying that after the execution of lines 12–14,βw(pd)⩽M-m′=βw(π). In particular,βw(p)⩽βw(π), finishing the proof.□The algorithmsAMBDsimple(S)andAMBD(S)have the same computation efficiency, when measured in terms of the worst case scenario. So, why do we bother with a more complicated versionAMBD(S)? Actually, it is easy to argue that the execution time ofAMBD(S)is never worse than that ofAMBDsimple(S)and, in most cases,AMBD(S)is more efficient. To see this, letδbe the degree of the graph (for the images,δ=4in 2D andδ=6in 3D), putU=max{w(s):s∈S}, and letμbe the size of the setWU={w(c)⩽U:c∈C}. InAMBDsimple(S)algorithm, theβw-strength of a path from S to c is checked always (often unnecessarily) betweenμ- andδμ-many times.On the other hand, the number of similar checks inAMBD(S)for each spel may be considerably smaller thanμ. Certainly, this is the case for each seed. But also, if a spel c is connected to ans∈Swith a large valueνofβw-(meaning that the sizeμcof the set{w(d)∈[ν,w(s)]:d∈C}is smaller thanμ), then theβw-strength of c will be updated at mostδμcmany times, an improvement fromδμ.Also, it is good to mention here that, for some seed sets S and T, the resulted MBD objectP(S,T)remains unchanged upon small changes of sets S and T. More specifically, this is the case for the seed pairs〈s,t〉∈S×Tthat are essentially separated in the barrier sense, that is, when for anyβw-optimal path p from s to t,βw-(p)<min{w(s),w(t)}⩽max{w(s),w(t)}<βw+(p). Of course, this robustness for the seed choice is not as potent as the robustness of RFC; however, it is considerable better than for the segmentations associated with the geodesic or fuzzy distances.All experiments presented in this section were conducted on a computer HP Proliant ML350 G6 with 2 Intel X5650 6-core processors (2.67Hz) and 104GB memory.In these experiments we have compared four different versions of the algorithms returning MBD: the novel exact MBD algorithmAMBD(S), the interval Dijkstra’s algorithmDA(βw,S)approximating MBD from above, theAMBDappr(S)executed once for each seed point, which approximates MBD from below with an error⩽2ε(see Theorem 1), andAMBD★appr(S)executed only once even for multiple seeds. The aim for these experiments was to evaluate the practical usefulness of each of these algorithms and to use this information to decide which of them to use in the next set of experiments, comparing MBD with other distance measures.For the experiments we used 2D images from the grabcut dataset [35], converted to gray scale by using the mean of the three color band values. The images come with the true segmentations. The examples of the images are given in Fig. 2. Their sizes range from 113,032 pixels (for284×398image) to 307,200 (for640×480image), while the intensity range of the images is[0,255]. The experiments were conducted as follows. For each numbers=1,…,25, the following procedure was repeated 100 times: (1) extract a random image from the subset of the images in the grabcut database; (2) generate randomly the set S of s-many seed points in the image; and (3) run each of the four MBD algorithms on this image with the chosen set S. The averages, for each value of s and each of the algorithms, of the execution time and error in computed distance values are presented in Figs. 3 and 4, respectively. See also Fig. 5.Based on the presented results, we concluded that the algorithmsAMBD★appr(S)andAMBDappr(S)are not worth pursuing any further: the first one because of its high computing time cost in the presence of multiple seeds, while the second because its higher level of errors, in comparison with the remaining two algorithms.The experimental performance of the other two algorithms was better than theoretically insured worst case scenarios: (1) The time performance of the exact MBD algorithmAMBD(S)seems to be independent of the number of seeds and is only a bit worst than the execution time of the linear time algorithmsAMBD★appr(S)andDA(βw,S). As expected (Theorem 3), we see in Fig. 6that, in practice, the execution time ofAMBD(S)depends on the image size in a linear manner. (2) The error level ofDA(βw,S)is clearly smaller than that of the other two algorithms approximating MBD. Moreover,DA(βw,S)is the most efficient in terms of the computing time.As a result, in the remaining experiments we used only two MBD algorithms:AMBD(S)andDA(βw,S).In this section, we compare the segmentations, as described in Section 2.2, associated with the following distance functions (see Section 2.1) for the 2D gray-scale digital imagesf:C→[0,∞)obtained from the grabcut dataset, see Fig. 2.•The exact MBD computed withAMBD(S), wherew(c)=f(c).An approximate MBD computed withDA(βw,S), wherew(c)=f(c).The geodesic distance computed withDA(Σ,S), where, for adjacentc,d∈C,w(c,d)=|f(c)-f(d)|.The fuzzy distance computed withDA(Σ^,S), wherew(c)=f(c).The Fuzzy Connectedness computed withDA(w,S), where, for adjacentc,d∈C,w(c,d)=M-κ(c,d)=|f(c)-f(d)|.We start with comparing how the execution time of these algorithms depends on the image size. The summary of our results is displayed in Fig. 6. The algorithms were executed on the small subimages of the images in Fig. 2. For each side length between 1 and 316, a square centered subset of the original images was extracted. A single seed point was placed in the center pixel in the small images. By this procedure, the frequency representation does not depend on image size as would be the case if the images were upsampled or downsampled.Notice that, according to these experiments, the execution time ofAMBD(S)depends on the image size in a linear manner, in agreement with Theorem 3.In these experiments, the seed sets were chosen in the images via erosion of different magnitude of the known true segmentations, see e.g. [34]. Such choice allows varying the seed sets in a more controlled manner, as compared to the alternative of operators specifying seeds interactively or the random seed choice, and thereby we can study the influence of seed sets on results also in a controlled manner. However, there is a concern that such choose may favor the distance measures similar to the Euclidean distance. Although this concern does not seem to be present in our experiments, presented in Fig. 7, we restricted this approach only to the presented small study to avoid any possible bias. (But see also Section 4.3.)In these experiments, involving the images from Fig. 2, the user defined seeds are used. Four different users have placed seed points in the object and background of each image. A sample of such choice is shown in Fig. 8.Fig. 9shows boxplots, where the central mark of the box is the median and the edges of the box represent the 25th and 75th percentiles. The whiskers extend to the most extreme data points not considered outliers, which are marked by plus-signs. Four different users have provided object and background seed points for all 17 images. These seed points are used to compute the object for the five different distance function.The images are degraded by Gaussian smoothing withσvalues between 1 and 10. Fig. 10shows the averaged Dice coefficient results and the execution times for the images with added indicated level of smoothing.In the experiments presented in Fig. 11the images were degraded by the additive Gaussian noise with zero mean and varianceσas indicated on the horizontal axis. The figure shows the averaged Dice coefficient results and the execution times for the images with indicated level of noise.Finally, Figs. 12 and 13show the similar results for the images with added noise followed by the indicated level of smoothing and for the images with added smoothing followed by the indicated level of noise, respectively.The experiments presented in this section show that the quality of the segmentations associated with both versions of MBD algorithms compare favorably with those associated the other three methods. This is particularly well visible in the case of blurred images. But the same pattern is also present at the lower level of noise. In the case of the exact MBD distance algorithm, the price of this improvement is a (slightly) higher execution time. (Though, this disadvantage quickly decreases, as a function of level of applied smoothing.) Therefore, if the execution time is an issue, the approximate MBD algorithmDA(βw,S)is the best performer, unless the image is very noisy.In the last experiment, presented in this section, we compared the performance of the five algorithms on the 3D T1-weighted MRI image of the brain, shown in Fig. 14.The presented experiments were performed on the image that has been slightly blurred. We added blur, since the segmentation results performed on the original image were so close to the ground truth for all five algorithms, that there was no basis to differentiate between them.The seeds were chosen by erosion, with respect to the ground truth. However, to avoid a concern expressed in Section 4.2.1, the erosion was done in an asymmetric manner: increasing radius of the structuring element (with origin located at the border of the structuring element). More specifically, an asymmetric erosion of the ground truth object P of radius r was defined as the set of all spelsc=〈c1,c2,c3〉∈Csuch that the (structuring) setS(c,s)={〈d1,d2,d3〉∈C:ci⩽di⩽ci+rfori=1,2,3}is a subset of P.The results of the experiments are presented in Fig. 15. They show that, in a 3D medical image, the quality of the MBD based segmentations is at least as good (the case of FC) or clearly better (geodesic and fuzzy distances) then those produced by the other methods. This advantage increases, with the decrease of the seed sets.

@&#CONCLUSIONS@&#
In this paper we introduced a new efficient algorithm,AMBD, that computes the exact values of the Minimum Barrier Distance transform, introduced by the authors in [1]. We provided a detailed proof thatAMBDindeed returns the exact MBD and that its execution time is, in the worst case scenario, of orderO(n2lnn),nbeing the size of the image. Moreover, the experimental results indicate that, in practice, the execution time ofAMBDis actually linear with respect to n, and comparable to the execution time of the standard Dijkstra’s algorithm.We also investigated an algorithmDA(βw,S)which is faster thanAMBD(has, provably, the same complexity as Dijkstra’s algorithm) but returns only approximate values of MBD. The presented experiments show that the quality of the output ofDA(βw,S)is remarkably similar to that ofAMBD.Finally, we experimentally compared the segmentations associated with both versions of MBD algorithms with that associated with geodesic distance, fuzzy distance, and Fuzzy Connectedness. The segmentation results associated with MBD compare favorable with the other three methods. In particular, MBD is considerable more robust to smoothing than the other algorithms. The same can be also observed when the lower level of noise is added.