@&#MAIN-TITLE@&#
TSP Race: Minimizing completion time in time-sensitive applications

@&#HIGHLIGHTS@&#
Minimizing time from receipt to complete implementation is often the real goal.Parallelizing implementation with computation can significantly speed completion.Break-even speed ratios can be well-estimated.Simple heuristics used with CIP can beat direct application of complex heuristics.

@&#KEYPHRASES@&#
Computation-implementation parallelization,Heuristic,TSP,TSP race,

@&#ABSTRACT@&#
In this paper, we present an approach for parallelizing computation and implementation time for problems where the objective is to complete the solution as soon after receiving the problem instance as possible. We demonstrate the approach on the TSP. We define the TSP race problem, present a computation-implementation parallelized (CIP) approach for solving it, and demonstrate CIP’s effectiveness on TSP Race instances. We also demonstrate a method for determining a priori when CIP will be effective. Although in this paper we focus on TSP, our general CIP approach can be effective on other problems and applications with similar time sensitivity.The classical traveling salesman problem (TSP) is to find the shortest tour through a set of points and back to the start; it is named after the situation of a traveling salesman who needs to visit a set of cities and then return home.Consider a case where two traveling salesmen are given the same large set of points and are each challenged to finish a tour before the other. The first traveling salesman follows a traditional approach, computing an optimal tour upfront before starting to travel. The second one, on the other hand, makes a quick start. Each time he travels to a node, he simultaneously computes the next node to visit while traveling. One could imagine this traveling salesman driving from city to city with a laptop open on the passenger seat calculating where to go next. The second traveling salesman can be expected to travel longer due to the less-global nature of his decision-making; however he has the advantage of not investing much time in computing beforehand. Because of this trade-off, it might not be a trivial task to determine which traveling salesman will be the winner. We refer to this setting of TSP, with the objective of minimizing total completion time, as TSP Race. The statement of TSP Race is as follows: Given an instance of TSP, finish visiting all nodes and return to the start as soon as possible. In this paper, we introduce an approach to this problem exemplified by the second traveling salesman.We refer to the approach of the second traveling salesman, who embeds part of his computation time into his travel time, as a computation-implementation parallelized (CIP) approach. The idea of CIP is generalizable to other problems where computation and implementation need not occur fully sequentially, and where it can be beneficial to compute later parts of a solution in parallel with implementing earlier parts. Most of the current literature on optimization problems focuses on minimizing the computation time to find an optimal (or heuristically good) solution, or on maximizing the quality of a solution (as measured by its implementation, e.g., the length of a TSP tour). However, if minimizing the time between receipt of the problem and completion of the solution is important and the computation time is comparable to the implementation time, conventional methods are not necessarily efficient. The reason is that the implementation resources stay idle during the computation phase, and vice versa.In this paper, to introduce and show the effectiveness of CIP we implement it on the TSP Race problem. The rest of this paper is organized as follows. In Section 2, we discuss the TSP applications that are compatible with the TSP Race setting. We are unaware of any previous work on TSP Race, but in Section 3, we present a brief review of general solution approaches to TSP. In Section 4, a general procedure of computation-implementation parallelization is introduced for TSP Race. In Section 5, we discuss methods to partition the graph, present computational results to compare them, and demonstrate the effectiveness of our approach. In Section 6, we develop a parameter selection mechanism for the parallelization approach. In Section 7, we present some final remarks.Our main motivation to design CIP approaches is to address time-sensitive applications in which total time from obtaining an instance to completing the implementation of a solution is an important objective to optimize. Among such applications, CIP is most appropriate for those where computation time is comparable to implementation time. (Otherwise, if computation time is relatively small then one could quickly compute the best solution and then implement it, and if implementation time is relatively short compared to computation time then one could compute a feasible solution as quickly as possible and then implement it.)Because computation time (and sometimes implementation time) are a function of current technology, the exact set of problems where CIP is appropriate will necessarily vary over time. Currently, there are a variety of current optimization problems where we believe CIP can be a useful approach. Divisible load problems (Marchal, Yang, Casanova, and Robert, 2005; Veeravalli and Barlas, 2002) are well-fitted to CIP. One example is the scheduling of large-scale jobs to parallel processors in areas such as telecommunications and medical imaging (Davis and Burns, 2011), image processing and computer vision (Veeravalli and Barlas, 2002), etc. Minimizing the completion time in multiprocessor systems can help to increase the utilization of the workstations. Arc therapy in cancer treatment is another potential application for CIP. A patient is scanned (receipt of the instance), an optimized radiation treatment plan is created (computation), and then the solution is carried out (implementation), all while the patient lies on the table. In some specific methods, computation time constitutes a significant portion of the total completion time (Bzdusek et al., 2009; Otto, 2008; Zhang et al., 2010); moreover, because even small movements of a patient can create error in the radiation plan, minimizing the time between receipt of an instance and finishing the implementation of a solution is important. (Çavdar, 2014) describes a vehicle loading and routing problem in which heuristic solutions for a parcel delivery vehicle routing problem are heuristically computed, and then the corresponding packages are loaded onto each delivery truck. The time to compute heuristic solutions and the time to implement them at the facility (i.e., load the packages onto the trucks as determined by the heuristic) are comparable, and using a CIP approach can help improve the quality of the delivery routing solutions.In this paper, we introduce CIP by focusing on applications of TSP where a TSP Race model is appropriate and a CIP approach could produce better overall solutions. The Traveling Salesman Problem: A Computational Study by Applegate, Bixby, Chvatal, and Cook (2007) gives an elaborate list of applications for TSP. Because of the current computation speed of fast processors combined with the quality of modern TSP algorithms, computation time to find good solutions can be small. Therefore, we suggest using our approach on problems where there are large number of nodes over a small area (so that optimization will take longer, and travel times will be shorter). Potential physical examples include small-scale manufacturing TSPs (e.g., producing customized chips), data management (e.g., unsorted database query retrieval), and laser and X-ray applications (crystallography, manufacturing of crystal art with a laser). Virtual TSPs may also provide examples where CIP is beneficial. For example, when simulating pick paths to determine the quality of potential warehouse designs, a simulation might repeatedly solve new TSPs to find a sequence of lines for every simulated order pick. The computation time of these TSPs is comparable to the implementation time (the time it takes to simulate the order pick), and the CIP approach could significantly speed up such simulations.However, we need to note that although these applications are good candidates for implementing CIP, they may not necessarily benefit from this approach. As we show in Section 6, a break-even analysis that depends on the specific implementation and computation speeds of each system may be required to determine when using CIP would likely lead to an improvement.

@&#INTRODUCTION@&#


@&#CONCLUSIONS@&#
