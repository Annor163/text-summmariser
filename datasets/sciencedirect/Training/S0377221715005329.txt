@&#MAIN-TITLE@&#
A real-time order acceptance and scheduling approach for permutation flow shop problems

@&#HIGHLIGHTS@&#
Proposed a new Real-Time strategy for solving Flow Shop Scheduling Problems.Designed a set of benchmark to test the performance of the approach.The algorithm is compared with the traditional Right Shifting strategy.Numerical results show that the approach improves financial return.A case study is provided to show the applicability of the proposed approach.

@&#KEYPHRASES@&#
Real-Time multiple-order scheduling,Flow shop scheduling,Random order arrival,Genetic algorithm,Memetic algorithm,

@&#ABSTRACT@&#
The Permutation Flow Shop Scheduling Problem (PFSP) is a complex combinatorial optimization problem. PFSP has been widely studied as a static problem using heuristics and metaheuristics. In reality, PFSPs are not usually static, but are rather dynamic, as customer orders are placed at random time intervals. In the dynamic problem, two tasks must be considered: (i) should a new order be accepted? and (ii) if accepted, how can this schedule be ordered, when some orders may be already under process and or be in the queue for processing? For the first task, we propose a simple heuristic based decision process, and for the second task, we developed a Genetic Algorithm (GA) based approach that is applied repeatedly for re-optimization as each new order arrives. The usefulness of the proposed approach has been demonstrated by solving a set of test problems. In addition the proposed approach, along with a simulation model, has been tested for maximizing the revenue of a flow shop production business under different order arrival scenarios. Finally, a case study is presented to show the applicability of the proposed approach in practice.

@&#INTRODUCTION@&#
The Permutation Flow Shop Scheduling Problem (PFSP) is one of the challenging scheduling problems that occurs in the manufacturing industries. A conventional PFSP considers how to process n jobs on m machines. Each job has predefined tasks that are processed by a specific set of machines through a specific processing order. In solving PFSPs, makespan minimization is a common and popular measure of performance. The time difference between the start of the first job in the first machine, and the end of the last operation in the last machine, can be defined as makespan. In order acceptance and scheduling problems, the objective is to maximize the number of accepted orders, while minimizing the order completion times. PFSPs can be categorized as either single-order or multiple-order. In this research, we assume each order contains a certain number of jobs. The basic difference between a single-order and a multiple-order problem is that in a single order problem the decision maker has to determine an effective schedule for a single order (a given set of jobs in the order) on a set of machines with known sequence of operations and processing times. Whereas, in a multiple-order problem, the decision maker has to face a stream, or pool, of orders which are scheduled on a set of machines, where the scheduler has the option of accepting or rejecting the arriving orders (Slotnick, 2011). Besides, the single-order problem is static and the multiple-order problem is either static or dynamic. In a multiple-order static problem, the order arrival times and due dates are known well in advance. For static problems, either single or multiple-order, it is expected to solve a problem only once. However, in dynamic multiple-order problems, it is assumed that the order arrivals continue with time (on a real-time basis), and the problem is to select a set of orders that would be feasible for processing within the available shop capacity, and to determine an effective schedule for the jobs of those selected orders over a given period of time. In this case, the order selection must be done immediately after the arrival of any new orders, and the job schedule must be updated, if any order is accepted.Single-order PFSPs have been widely studied in the literature. First, in 1954, Johnson (1954) introduced the flow shop problem as an interesting scheduling problem and proposed a simple algorithm that guaranties the optimal solution for a two machines static flow shop problem, and for a special case with a three machine problem, in polynomial time. For solving PFSPs with three or more machines, many researchers used exact techniques such as mixed integer programming (Selen & Hott, 1986), and Branch and Bound (B&B) algorithms (Ignall & Schrage, 1965). However, as the single-order PFSP is NP Hard (when the number of machines is three or more) (Garey, Johnson, & Sethi, 1976), researchers have focused on heuristic techniques (Ruiz & Maroto, 2005). Among recent heuristics, Nawaz et al.’s (Nawaz, Enscore, & Ham, 1983) NEH algorithm is regarded as one of the best constructive heuristics for solving static PFSPs. However, it still deviates by up to 7 percent from the known optimum for some problems (Ruiz & Maroto, 2005; Taillard, 1990; Zobolas, Tarantilis, & Ioannou, 2009). This heuristic is based on the idea that longer jobs in the sequence should be processed as early as possible in the schedule. To improve the solution quality of PFSPs, researchers have switched their attention to metaheuristics, such as the Simulated Annealing (SA) algorithm (Ogbu & Smith, 1990; Osman and Potts, 1989), Cuckoo search algorithm (Dasgupta & Das, 2015), Genetic Algorithms (GAs), including Hybrid GAs (Murata, Ishibuchi, & Tanaka, 1996; Rahman, Sarker, & Essam, 2013; Ruiz, Maroto, & Alcaraz, 2006; Tseng & Lin, 2009; Zobolas et al., 2009), Ant colony algorithms (Rajendran & Ziegler, 2004), particle swarm optimizations (Tasgetiren, Liang, Sevkli, & Gencyilmaz, 2007), tabu search (Grabowski & Wodecki, 2004), and differential evolution (Onwubolu & Davendra, 2006). From the computational results provided in the literature, the hybrid metaheuristics, in general, show promising performance.Many manufacturing firms receive a stream of orders (or a certain pool of orders) from which certain orders may be accepted and scheduled with respect to the available production capacity (Slotnick, 2011). If a firm either accepts a new order without checking its feasibility for on-time completion, or cannot schedule all the accepted orders for on-time completion, it will produce a poor production plan that would lead to reduced revenue (Guerrero & Kern, 1988). The order acceptance/rejection problem has been studied mainly in a single machine environment as a static problem, where the order arrival times are known well in advance (Lewis & Slotnick, 2002; Rom & Slotnick, 2009; Slotnick & Morton, 1996, 2007). A brief review of the single machine static acceptance/rejection problem is provided here. Slotnick and Morton (1996) proposed an integer programming algorithm with the objective of maximizing the profit. Lewis and Slotnick (2002) applied dynamic programming for a multi-period job selection process where job rejection involves future loss of customer. Slotnick and Morton (2007) later extended the problem of (Lewis & Slotnick, 2002; Slotnick & Morton, 1996) for limited capacity. In their work, a branch and bound algorithm was proposed to deal with order acceptance decisions and several heuristics were used to sequence the jobs to minimize weighted tardiness. Rom and Slotnick (2009) extended the previous approach of order acceptance and scheduling decision with lateness penalties (Lewis & Slotnick, 2002; Slotnick & Morton, 1996) and weighted tardiness (Slotnick & Morton, 2007). They proposed a GA which minimized weighted tardiness, and it performed well with respect to a previously proposed heuristic (Slotnick & Morton, 2007), even though it took more time in computation. Nobibon and Leus (2011) considered a problem where a company has to select orders from a pool of firms planned orders, as well as any other demanded orders. Wang, Zhu, and Cheng (2015) studied a subcontracting price scheme for the static order acceptance and scheduling problem in a single machine environment. The multi-order static problem has also been studied in a multiple machines environment (Chen, Mestry, Damodaran, & Wang, 2009; Pourbabai, 1989; Roundy et al., 2005; Wang, Huang, Hu, & Cheng, 2015; Wang, Xie, & Cheng, 2013a, 2013b). Wang et al. (2013a) developed a modified artificial bee colony algorithm for solving the order acceptance problem in two machine static multiple-order PFSPs. Wang et al. (2013b) proposed a B&B algorithm and a heuristic to solve the order acceptance problem in two machine static multiple-order PFSPs. Xiao, Zhang, Zhao, and Kaku. (2012) studied a static multiple-order PFSP with order acceptance and weighted tardiness problems. Lin and Ying (2015) proposed a multi-initiator SA for the same problem, and the experimental results showed that the proposed algorithm outperforms Xiao et al. (2012)’s approach. In both studies, each order contained a single job and at the beginning of the planning period, the firm received a pool of candidate orders with known arriving times, order compositions, and due dates. Wang, Huang et al. (2015) proposed a Lagrangian relaxation technique based exact algorithm, and two heuristics to solve the order acceptance problem in a static multiple-order two identical parallel machine problem. Chen et al. (2009) addressed static order arrival in a job shop environment by using a mixed integer programming approach for smaller problems, and a B&B algorithm with Lagrangian bounds and approximate branching features for larger problems. Pourbabai (1989) developed a model to identify potential orders, order splitting considering due dates, and job set up, and scheduled jobs using a dispatch rule based on order availability and due dates on a multiple machine environment where the machines are grouped into cells (group technology concept). Roundy et al. (2005) considered a job shop environment, in which an order is accepted, if it can in any way be inserted into the current schedule. They developed both a single machine heuristic, as well as meta-heuristics (tabu search, GA, SA), to solve the problem.There are a few studies that have considered dynamic order arrival in a single machine environment. Wester, Wijngaard, and Zijm (1992) studied the relationship between three different order acceptance strategies: order acceptance based on the knowledge of previously accepted orders, order acceptance based on the total workload of all accepted orders, and order acceptance based on the aggregated load profile of accepted orders, and scheduling jobs to maximize the utilization of capacity. In this case, the authors found that using knowledge of the current production schedule when generating new schedules because of new order arrivals, was superior over the other two approaches. Duenyas and Hopp (1995) considered that order arrival and processing times were stochastic. In that study, an arriving order was only rejected if it was beyond the customer's tolerance limits. Later, Duenyas (1995) extended the work ofDuenyas and Hopp (1995) to consider customer quoted due dates.The next level of complexity is dynamic order arrival in a multiple machine environment, which is closer to the research presented in this paper. There is no doubt that this topic is much more complex and has more synergies with practical situations. Nandi and Rogers (2004) proposed simulation based order acceptance and scheduling decisions for two product types (regular and urgent), with profit maximization as the objective in a four stage hybrid flow shop environment. The order acceptance was done by pair look simulation (based on the total contribution in companies profit, if an order arrives and whether it is accepted or rejected), and scheduling was done by minimizing the amount of slack per operation remaining. Rogers and Nandi (2007) used a simulation tool to maximize the profit with a fixed capacity in a four stage hybrid flow shop. The scheduling was done by using dispatching rules (first come first serve rule, earliest due date, minimum slack per operation remaining). Moreira and Alves (2009) also used simulation to investigate multiple decision making (order acceptance, due date adjustment, order releasing and scheduling) in a job shop environment to improve lateness penalties and workload performance. Scheduling was generated by using both the earliest due date rules and also the first come first serve rules. Tang, Liu, and Liu (2005) proposed a neural network that integrated six priority rules, for the hybrid dynamic flow shop problem with the objective of minimizing the average flow time, average number of tardy jobs, and average tardy time. In that work, jobs arrival (each order containing a single job) was assumed to follow a Poisson distribution. Kang, Duffy, Shires, Smith, and Novels (2014) developed an integrated approach, based on the concept of advanced planning and scheduling, with a closed looped methodology for Lean-scheduling of practical dynamic semiconductor and cable manufacturing environments.Pinedo (2012) criticized that most of the theoretical models for multiple machine scheduling made an assumption of scheduling an n set of jobs in an m set of machines, while in an actual manufacturing environment, the jobs of an order may be processed at any specific time, because orders may be placed by the customers at any point in time, i.e. new orders arrive in the system randomly. Machine and resource availabilities also change with time (Schmidt, 2000). The static single-order and static multiple-order PFSPs thus ignore the status of the manufacturing shop floor. In addition, each order has customer or manufacture specified due dates, within which it should be processed and delivered to a customer. Considering all these conditions, it may be feasible to accept all the orders that arrive at a manufacturing firm. On the other hand, frequent order rejection will diminish a Company's goodwill. So an effective approach is necessary to deal with this situation. Although the order acceptance/rejection decisions and scheduling decisions are interdependent, in multiple machine environments where orders arrive dynamically, almost all previous research considered the order acceptance/rejection decision and scheduling decisions separately.In this research, we have considered a real-time multiple-order PFSP, where the orders are placed with a flow shop at random time intervals. In this case, each individual order can be thought of as being similar to a static single-order PFSP, but with no prior knowledge about the order compositions, due dates and arrival time. Each order has a customer or manufacturer specified due date (or delivery date). If the inter-arrival time of orders is greater than the makespan (calculated under a static single-order PFSP scenario) of the previously accepted orders, then the schedule generated for their static single-order PFSPs can be implemented without any alteration. However the situation is different when their processing times overlap. In such cases, it may not be feasible to accept all the arrival orders while satisfying production capacity and due date constraints. The production scheduler has to make two decisions: (i) is it possible to accept a new order? (ii) if the processing time of a new order overlaps with the other orders; how should the order be scheduled? The first decision depends on the orders already accepted, orders under process, and the availability of resources to process the new order. The second decision can be made in two ways. (i) Each order can be assumed as a static single-order PFSP and the order can block the machines for the time slot equal to their makespan. Each new accepted order should then be scheduled immediately after finishing the orders currently under process. That means new orders will be scheduled by shifting them to the right of the schedule. Such an approach is known as the Right Shifting (RS) strategy. (ii) This strategy intends to utilize any free machines, instead of blocking all machines for a certain period of time that is equal to the makespan of each individually accepted order. For example, the current order or orders may finish processing in the first machine, or the first couple machines while a new order has been accepted. The newly arrived order can then start processing in the first machine. After processing in the first machine, the second or third machine may not be available immediately. In that case, the order may have to wait in a queue until the following machine is free. But the immediate start of an order has the benefit of finishing the order early, as well as of increasing the chance of accepting upcoming orders by the same facility. This advantage can be taken by rescheduling the order while considering the individual machine availability constraints.In this paper, a GA based Memetic Algorithm (MA) for rescheduling an order in real-time has been developed. We introduce this as the Real-Time (RT) strategy. There is no standard benchmark available for the real-time multiple-order PFSPs. For experimentation, we have chosen 40 instances of 10 machine PFSPs from the standard Taillard's benchmark (Taillard, 1993). We then generated random inter-arrival times and due dates for arriving orders. To judge the quality of the solutions, we compare with the upper and lower bounds of possible solutions. The experimental results show the benefits of the proposed algorithm. As a consequence of the variability in the inter-arrival times of new orders and their due dates, and production capacity, it may not be feasible to accept all arriving orders. However, it may be profitable to accept some tardy orders, with an agreed tardiness penalty, if they are completed within a given tardiness limit. To examine the possibility of accepting tardy orders, we have developed a simulation model for experimenting with different level of tardiness limits. This approach shows interesting results. Finally, to demonstrate the usefulness of the developed approaches in practice, we have presented a brief case study of a Sanitaryware production system. The proposed approaches will provide numerous advantages over the existing methodologies, such as better production capacity utilization, higher financial return, higher organization satisfaction, higher customer satisfaction and real-time decision making.This paper is organized as follows: after the Introduction, the problem definition and necessary assumptions have been provided in Section 2. Section 3 describes the proposed algorithm for solving single-order PFSPs, as well as two new strategies for real-time multiple-order order acceptance and scheduling for a Permutation Flow Shop. Section 4 provides an experimental study for static single-order and real-time multiple-order PFSPs. In Section 5, a simulation model has been presented for studying the influence of tardiness in accepting new orders. A case study on a Sanitaryware production system has been presented in Section 6. In the final section, conclusions are given.In this section, the static single-order and the real-time multiple-order PFSPs are briefly defined.In this problem, it is assumed that a single-order contains a set of finite jobs n that are to be processed in a finite set of m machines with the same processing sequence. The processing time pi, jof job j (j = 1,2,3, … , n) on each machine i (i = 1,2,3, … , m) is known in advance. Here, π = (π1, π2, … , πn) is the permutation of n jobs and C(i,j) represents the completion time of job j on machine i. The competition time of the last job on the last machine (i.e., makespan) can be calculated as follows.(1)Makespan,Cmax(π)=C(m,n)So the objective is to identify a job sequence, π* so that(2)Cmax(π*)≤Cmax(π)∀π∈Πwhere, Π is the set of all feasible job sequences, and π* is the best schedule achieved by the algorithm. C(m, n) is the completion time of the nth job in the mth machine.The following assumptions are made for the single-order PFSPs.•The processing time of each job on each machine is known well in advance.Each machine can process only one job (of an order) at a time.Each job should follow the same predefined processing sequence of machines.No interruption of processing is allowed.Inventory costs of work-in-process and finished goods are not considered.Set up and transportation costs are negligible.In practice, production occurs on a continuous basis and new orders are received while processing other orders on hand. However, in most cases, without prior knowledge new orders are placed by customers on a real-time multiple-order basis.In defining Real-Time multiple-order PFSPs, the following assumptions are made.•The order arrives randomly (no prior knowledge of arrival time).Each order may contain multiple jobs (similar to a single-order PFSP).The composition of each order is not known in advance.The due date of each job is provided by the customer.The manufacturer has the right to accept or reject any new order.The completion of an accepted order, within the given due date, will have a positive impact on productivity.An order in process cannot be interrupted.Once an order is accepted, it cannot be later rejected.There may be a financial benefit for early completion, and a penalty may be imposed for tardiness.The order processing flow diagram for Real-Time multiple-order PFSPs is presented in Fig. 1. In it, orders from customers are received by the system. The management then decides whether to accept or reject the new order. If a new job is accepted, it must be scheduled while considering the current jobs of the order/orders in the system, shop capacity, and the due dates of all of the accepted orders waiting for processing. This means that some of the jobs of an order waiting for processing may be rescheduled. If the machines are available, an order may be processed immediately after being accepted. Otherwise the order waits in the queue according to the generated schedule. After the completion of each order, it is delivered to the appropriate customer. Alternatively, if a new order cannot be completed by meeting its due date, then it should be rejected. A rejected order leaves the system immediately.The parameters and performance measures for real-time multiple-order PFSPs are as follows.h – index for an orderi – index for a job in an order hj – index for a particular machinepijh– processing time of job i (of order h) on machine jnh– number of jobs in order hm – number of machines in the flow shopCmaxh– makespan for order hCcomh– completion time for order hdh– customer specified due dates (or delivery time)Th– tardiness of order hH – number of orders that arrive in one production shiftSjh– the starting time of the first job of order h on machine jFjh– the finishing time of the last job of order h on machine jThe makespan of an individual order, h, can be determined as the makespan of an equivalent static single-order PSFP, which isCmaxh. The completion time for that order,Ccomh, can be expressed as(3)Ccomh=S1h+Cmaxhwhere, the start time of the first job of the first order (start of production shift) isS11=0(4)Sothecompletiontimeforthefirstorderisequaltoitsmakespan,Ccom1=Cmax1The tardiness of an order is then:(5)Th=Ccomh−−dh,h=1,2,3,…,Handdh≥0(6)OrderhisacceptedonlyifTh≤0,orelseitisrejectedIn any machine, the (h+1)th order cannot be started until the hth order has been finished. In this case, the following condition must be satisfied.(7)Sjh+1≥Fjh∀h,jThe objective of the real-time multiple-order PSFP, is to maximize the number of accepted orders (in order to maximize productivity), for a given period of time, while satisfying the constraints described above.Before we propose a solution approach for real-time multiple-order PFSPs, we will consider the solution approaches used for single-order PFSPs. Although heuristics and metaheuristics are both popular, metaheuristics have been found to be relatively better performing algorithms for single-order PSFPs. In this research, we first developed a Genetic Algorithm (GA) based Memetic Algorithm (MA) approach for solving single-order PFSPs with an objective of minimizing the makespan of a single-order. We later extended the algorithm for dealing with real-time multiple-order PFSPs. The extended algorithm helps to reduce the completion time of each order (with respect to the production capacity constraints and due dates) and increases the number of accepted orders (reduces the number of rejected orders).GA is a popular stochastic global search algorithm for finding either optimal or near optimal solutions for complex optimization problems. GA starts with a set of initial solutions, known as its population, and the solutions are then altered using the search operators (such as crossover and mutation), until its stopping criteria are met. The individual solutions are represented what is known as a chromosome. The details of the chromosome, search operators, and parameters used for the GA in solving static PFSPs, are briefly discussed below.In a GA, chromosomes can be represented by binary, integer or real numbers. For PFSP, using an integer representation of the job sequences representation is most popular. Traditionally, the initial population in GA is generated randomly. But in PFSP, random initialization may not help to achieve a quality solution within reasonable times. We have proposed to have certain non-random individuals in the initial population, where those individuals are generated by using the NEH heuristic and Johnson's algorithm. In the first case, some individuals are generated by randomly swapping two jobs from the NEH heuristic's solution. In the second case, because more than two machine flow shop problems can be divided into multiple two machine flow shop problems, and these problems can be optimally solved by Johnson's algorithm, a certain percentage of the initial population is generated using both this and the previous method. The rest of the individuals are randomly generated.Traditional tournament selection is used to select parents from the selection pool. We also replaced parents directly with their offspring. In a heavily constrained combinatorial optimization problem, it is common to produce many duplicate individuals, which can cause stagnation in local optima. To solve this problem, in every generation, newly generated random individuals replace any duplicate ones. It is important to note that different sequences may have the same fitness value (Ruiz et al., 2006), so by duplication we strictly mean the same job sequence. Also, if the evaluation process stagnates into the same solution for some generations, a restart scheme (Rahman et al., 2013; Ruiz et al., 2006; Zobolas et al., 2009) has been implemented. For this, if the makespan stagnates for a certain number of generations, all members are classified into three sections, best 5 percent, middle 85 percent and worst 10 percent. The middle group is replaced by newly generated individuals through shift mutations of the top section. In this algorithm, an elitism strategy has been used to save and pass the fittest individuals from one generation to its next.Similar Order Crossover (SJOX) (Ruiz et al., 2006) and shift mutation (Murata et al., 1996; Ruiz et al., 2006; Zobolas et al., 2009) have been selected as the reproduction operators, as they performed well in earlier experiments. In SJOX, the job sequence from each parent is inspected one by one. The same job in the same position from each parent is directly inserted into both offspring. Next, each offspring copies all of the other jobs from one of the parents up to a randomly chosen crossover point. For example offspring 1 inserts jobs directly from parent 1 and offspring 2 inserts jobs directly from parent 2. Finally, the missing jobs from each offspring are selected from the other parent and are inherited in the relative same job sequence of that parent. That is to say, offspring 1 inherits the missing job elements from offspring 2 and offspring 2 inherits the missing job elements from offspring 1. In shift mutation, a randomly selected job is inserted into a randomly selected position in the job sequence. Between these two points, each job is moved to its adjacent position in the job sequence.To achieve a quality solution within a reasonable amount of time, it is common to integrate a local search method within a GA. In the current algorithm, we have applied three stage local search methods. They are insertion neighborhood, gap filling, and a job shifting process. The individual which is selected for local search, initially goes through the insertion neighborhood search process, then through the gap filling process and finally through job shifting.•Insertion neighborhood search: In PFSPs, insertion neighborhood performs satisfactorily as a local search (Osman and Potts, 1989; Ruiz et al., 2006; Taillard, 1990). For it, each job permutation has (n − 1)2 neighbors. So it checks each pair position, and if a better sequence is found, it then replaces the current best sequence. The process continues until all of the jobs have been selected and evaluated.Gap filling: In PFSPs, no inter-job gap is allowed in the first machine. But due to precedence constraints, there may be some gaps on the rest of the machines. The job schedule can be improved if these gaps can be minimized or removed. From preliminary experiments, it has been observed that if in a job sequence an inter-job gap exists in the last machine, or the last couple of machines, the makespan of that sequence can often be improved by placing a job from the right of the gap location, into that gap. The process for this is: the total processing times for all jobs in the schedule is calculated and then the job which has the least total processing time is selected. The selected job is then placed in the gap. If such a movement improves the schedule then the new solution is accepted. If not, then the job whose total processing time is the second best in the schedule is tried. The trial is limited up to three times for each gap. After the gap identification, job selection and insertion, if the makespan improves then the new schedule is accepted.Job shifting: The makespan can often be minimized if the jobs with (a) longer processing time at the lower right-hand-side (last few machines) of the schedule, and (b) shorter processing time at the upper left-hand-side (first or first few machines) of the schedule, can be shifted from the right hand side to the left hand side in the schedule as much possible. To do this, the ratio of processing times (processing time in the last machine and the processing time in the first machine) for all of the jobs in the sequence is calculated. Then if any of the three last jobs have one of the three highest ratios, then those jobs are then placed as early as possible in the sequence.In real-time multiple-order PFSPs, two important tasks are: (i) how to decide which orders are to be accepted or rejected and (ii) how to schedule the jobs in each order with respect to the available capacity. There have been a few studies where order acceptance/rejection decisions in multiple machine layouts (flow shop and job shop) have previously been considered. First, Nandi and Rogers (2004) proposed an order acceptance mechanism where an arriving order is accepted or rejected by comparing the profit of the current orders. Rogers and Nandi (2007) proposed an order acceptance/rejection rule that was based on the total workload (total processing time of each job in all machines), or the workload in the busiest machines. Moreira and Alves (2009) proposed order acceptance rules based on workload and negotiable due dates. After accepting an order, a scheduling was then generated by simple dispatching rules, namely least slack per remaining operations (S/OPN) (Nandi & Rogers, 2004; Rogers & Nandi, 2007), earliest due dates (EDD) (Moreira & Alves, 2009; Rogers & Nandi, 2007), and first come first serve rules (FCFS) (Moreira & Alves, 2009; Rogers & Nandi, 2007). In these papers, the order acceptance/rejection decisions and the scheduling decisions were made separately and sequentially. However, the overall system performance can be improved by integrating these two related problems. In this research, we first propose a heuristic based approach for the order acceptance/rejection decision. This approach is then integrated with the scheduling decisions. The integrated process thus selects a set of jobs that would be both feasible to process within the processing capacity, and that would do so by the customer specified due dates.The order acceptance/rejection decision is made when an order arrives to the manufacturing system. The decision depends on the start time, available shop capacity within the time window, completion time, and the due date of each order. An arriving order will only be accepted if it can be processed and completed by its specified due date. So a trial schedule has to be generated to make the acceptance/rejection decision.The algorithm for the order acceptance/rejection decision can be described as follows.Assume O represents the total number of orders arriving in a production shift andCcomiis the completion time (time to complete) of the ith order and diis the due date of that order. Also assume that Tiis the tardiness of that order. The completion time,Ccomi, is calculated based on the scheduling algorithm that will be discussed later in this paper.1. Initialize the Orders and the Production Shift starts.Set order number, o = 12. Repeat until (o = O)A. CalculateCcomifor an order i.B. Accept the order, if Ti≤ 0 (Ccomi<= di).C. Else Reject.D. Set, o = o + 1.[End of the step 2 Loop].[End of the algorithm].It may not be possible to process all new orders, immediately after their arrival, due to the machine availability constraints. If an order arrives at a time when at least the first machine is free, the order may start processing without interrupting the other orders being processed. If the first machine is not free when a new order arrives, or the order has to wait for processing on other machines, the scheduling or rescheduling of some or all of the accepted jobs (based on the conditions of that time) may be able to improve the system utilization. In this paper, we attempt to schedule or reschedule using two strategies, which are referred to as Right Shifting strategy and Real-Time multiple-order strategy.In this approach, each accepted order is first considered as a single-order PFSP and the sequence of jobs is then generated by minimizing the makespan using a MA. Note that MA is a variant of GA that includes additional local search techniques. The accepted order is placed in the queue and it will start processing as soon as the first machine is free. In this case, the sequence of the jobs will follow the best job sequence of its single-order PFSP. Note that any number of accepted orders can be placed in the queue, and that each order contains a number of jobs. After processing a job of a particular order in one machine, it may need to wait for processing on the next machine, as the processing of an earlier order may not be completed by that time. That means, the job may need to shift to the right of the schedule and so may require more time than its single-order makespan for completion. To demonstrate the process, a simple example with a Gantt chart is shown in Fig. 2.In this example, we consider a 3 machine flow shop with 2 orders (say orders M and N). These orders (consisting of 5 jobs each) have different arrival times and due dates. In Fig. 2, the Gantt chart in the upper left hand corner represents order M. The single-order Makespan for order M is 30 and the job sequence is 2-5-3-4-1. The due date for order M is 48. Assume that order N arrives after 20 units of time from the start of order M and has due date 58. The single-order makespan for order N is also 30 and the sequence of jobs is 2-5-3-4-1. The Gantt chart, in the upper right hand corner, of Fig. 2 represents order N. When order N arrives, order M is still in process. In the worst case scenario, order N can only start processing after completely processing order M. In that case, the sequence of jobs are taken from the best static schedule for order N, which gives the completion time of order N of 60 (=30 + 30) as shown in the lower left Gantt chart. Note that this is later than the delivery time. This scenario refers to the upper bound of the problem and will be referred to later. However, the overall processing time can be reduced by applying a simple strategy. For example, order N can start processing as soon as machine-1 is free from order M. However, when the first job of order N is completed on machine-1, machine-2 may not be available for processing order N. So the start time in machine-2 must be shifted to the right to generate a feasible schedule. Such shifting is known as the Right Shifting (RS) strategy. This process provides the completion time of 56 for order N (lower right corner in Fig. 2). This is basically a tighter upper bound than the worst case scenario discussed above. Further, as the given due date is 58, order N can now be accepted.The algorithm with the Right Shifting (RS) strategy can be described as follows.Let N be the total number of orders that arrive in a production shift. Also assume c is the current time of the clock and the due date of the nth order is dn. The algorithm must then determine the single-order makespan of the nth order (Cmax)n. For this, the start time of that order is Sn, the completion time is (Ccomp)n, and its tardiness, Tn. It must also calculate ti, which is the clock time when the first job of the ith order will start to be processed in the first machine. Also assume that Nacptis the number of accepted orders per production shift.The algorithm starts at the beginning of the Production Shift, when the initial order arrives.I. Set n = 1, Nacpt= 0, and clock t1= 0II. Repeat until n = N (up to the end of the production shift).A. update the clock, tn= c, and Sn= cB. Use MA to find the single-order makespan for the schedule of the job setof the current order.C. Revise the makespan (Cmax)nof the order depending on the currentsystem state:a. If the nth order overlaps with the (n − 1)th accepted order, right shiftthe jobs of the nth order.b. Else, the makespan (Cmax)nis unchanged.c. Calculate the completion time,D. With respect to completion time, (Ccomp)n= Sn+ (Cmax)na. Calculate Tn,as Tn= (Ccomp)n− dnb. Store the completion time, (Ccomp)n, and the tardiness, Tnc. If Tn≤ 0i. Accept the order.ii. Nacpt= Nacpt+ 1d. Else, Reject the order.E. Set n = n + 1[End of step II Loop]IV. Store, Nacpt(total number of accepted order in one production shift).[End of Algorithm]In this approach, similarly to the RS strategy, the new order is started as soon as the first machine is available. However, instead of using the best static schedule of order N and shifting any job of an order to the right due to machine unavailability, the jobs of order N are rescheduled while considering the machine availability/unavailability constraints. As shown in Fig. 3, order M has a makespan of 30 and its sequence is 2-5-3-4-1. Order N is processed in the first machine immediately after order M is completed in that machine. However, the new sequence of jobs for order N is generated while taking into consideration that some machines are available for only certain time windows (in this case, there is a strict lower bound for the starting time). For convenience of explanation, we refer to this process as Real-Time multiple-order strategy. Note that the static schedule is generated assuming all machines are unconditionally available. As a result, the new sequence of jobs from RT may differ from the single-order schedule. After rescheduling with the RT strategy, the completion time for order N is 55 and the job sequence is 5-1-4-3-2. Note that in this case the completion time with RT is shorter than it was for RS.The MA based Real-Time (RT) strategy can be described as follows.Let the total number of orders that arrive in a production shift be N, and also assume that the number of accepted orders per production shift is Nacpt. Assume that c is the current time of the clock, the start time of that order is Sn, and that the due date of the nth order is dn. The algorithm must then determine the makespan of the nth order (Cmax)n, the completion time (Ccomp)n, and its tardiness, Tn. It must also calculate ti, the clock time when the first job of the ith order will start to be processed in the first machine.When the initial order arrives at the beginning of the Production Shift, the following algorithm starts.I. Set n = 1, Nacpt= 0, and clock t1= 0II. Repeat until n = N (up to the end of the production shift).A. update the clock, tn= c, and Sn= cB. Considering any machine availability/unavailability constraints, use MAto generate a schedule for the job set of the current order.C. Evaluate Tnwith respect to its completion time, (Ccomp)n:a. calculate the completion time, (Ccomp)n= Sn+ (Cmax)nb. calculate, Tn= (Ccomp)n− dnc. Save completion time, (Ccomp)nand tardiness, Tnd. if Tn≤ 0.i. Accept the orderii. Nacpt= Nacpt+ 1e. Else, Reject the order.D. Set n = n + 1[End of step II Loop]III. Save, Nacpt(total number of accepted orders in one production shift).[End of Algorithm]We first implemented a MA for solving static PFSPs. That algorithm was coded in C++ and ran on a personal computer with an Intel core i7, 2.80 GHz processor and 4 GB RAM. For the single-order PFSPs, 120 standard benchmark problems from Taillard (1993) were tested to judge the performance (by minimizing the makespan) of the MA, by analyzing those results.The parameters were chosen based on our earlier study (Rahman et al., 2013). The population size was set to 100. The first member in each initial population was constructed by the NEH (Nawaz et al., 1983) algorithm, another 40 percent of the individuals were generated from the modified NEH (Nawaz et al., 1983) algorithm, 10 percent of the individuals were produced from the modified Johnson's Algorithm (Johnson, 1954), and the remaining individuals were generated randomly. The selection pool size was limited to 5. The crossover probability was 90 percent and mutation probability was 60 percent. If the solution did not improve for 10 generations, then the restart mechanism was applied to escape from the local optimum. The local search process was applied to 30 members in each generation. The results of 10 independent runs were recorded and analyzed.

@&#CONCLUSIONS@&#
