@&#MAIN-TITLE@&#
An enhancement of return address stack for security

@&#HIGHLIGHTS@&#
Design a method to protect the return address stack from stack smashing attacks.Our approach does not need source code and hardware support.Relative performance overhead is only between 3.47% and 8.59%.

@&#KEYPHRASES@&#
Stack smashing attack,Buffer overflow,Memory pointer corruption attack,Return address stack,Binary rewriting,

@&#ABSTRACT@&#
Stack smashing is one of the most popular techniques for hijacking program controls. Various techniques have been proposed, but most techniques need to alter compilers or require hardware support, and only few of them are developed for Windows. In this paper, we design a Secure Return Address Stack to defeat stack smashing attacks on Windows. Our approach does not need source code and hardware support. We also extend our approach to instrument a DLL, a multi-thread application, and DLLs used by multi-thread applications. Benchmark GnuWin32 shows that the relative performance overhead of our approach is only between 3.47% and 8.59%.

@&#INTRODUCTION@&#
With the rapid growth of computer system, more and more issues have been concerned. One of the most concerned issues is security. Stack smashing attacks, which exploit buffer overflow vulnerabilities [18,12,31,7,30] to hijack the program control from attacked applications, are the most widely used type of attacks. Due to careless programmers, vulnerabilities [28,29] exist all the time. Diverse techniques have been proposed to thwart stack smashing attacks, such as static analysis and dynamic detection. However, they are not as useful as we thought because most of them must alter compilers [34,33,10,8,11,22,32,1,20] and recompile source code, or require hardware support [35,34,13,9] to execute specialized instructions. Another reason is that most of them are built only for Linux. However, Windows is still the most popular operating system today, and there are more applications that contain buffer overflow vulnerabilities. Therefore, we need to protect those applications from stack smashing attacks on Windows.There is a class of techniques [26,34,23,8,25,2,32] which creates a safe area to backup return addresses to prevent stack smashing attacks. The safe area is called private stack, canary stack, or return address repository, etc. For consistency, we call it return address stack throughout this paper. These techniques revise the prologue and epilogue of each protected function. The revised function prologue will store copies of the return address into return address stack, and the revised function epilogue will restore the return address on stack with copies of them. Obviously, these techniques should guarantee that the return address stack is absolutely secure because attackers may attempt to modify the contents of the return address stack to hijack the program control. In general, these techniques set return address stack as read-only mode most of the time to protect it. The only situation that the return address stack becomes writable is in the revised function prologue when it is pushed into return address stack. In this paper, all we considered is outside the box by showing that only setting return address stack as read-only is not secure enough if the return address stack is dynamically allocated.Our approach is based on Binary Rewriting, so we can protect applications from stack smashing attacks without source code and hardware support. Hence, we only focus on those techniques that use Binary Rewriting. We classify them into two groups according to the way they allocate return address stack: (1) static allocation [26,23] and (2) dynamic allocation [25,2]. The first group statically allocates a return address stack like adding a new section called return address stack into Portable Executable (PE) or Executable and Linking Format (ELF) file. Therefore, the return address stack is already created before running the protected application. The second group dynamically allocates a return address stack at the beginning of the protected application. In this way, the return address stack is certainly located in the heap. We discovered that there is a potential security risk if the return address stack is dynamically allocated. Because the second group dynamically allocates an area to be the return address stack, it must have an Entry Pointer of the return address stack in order to pass the address to the revised function prologue and epilogue of each protected function. However, the second group only keeps eyes on protecting the return address stack but fail to protect Entry Pointer of the return address stack. For this reason, we can launch a Memory Pointer Corruption Attack to hijack the program control from protected applications by modifying Entry Pointer of the return address stack even if they are under protection. The detail of Memory Pointer Corruption Attack will be explained in the next section.In this paper, we design a Secure Return Address Stack to protect the return address stack and entry pointer of the return address attack from stack smashing attacks on Windows. Our approach does not need source code and hardware support because we combine DLL Injection with Dynamic Binary Rewriting to implement it. Moreover, we also extend our approach to instrument a DLL, a multi-thread application, and DLLs used by multi-thread applications. Benchmark GnuWin32 shows that the relative performance overhead of our approach is only between 3.47% and 8.59%.The rest of this paper is organized as follows. In Section 3, we describe our approach and implementation. We evaluate our approach in Section 4. Section 5 describes a drawback, a limitation, and two potential security issues for instrumenting a multi-threading application. In Section 6, we survey related works of stack smashing attacks, and a conclusion will be given in Section 7.

@&#CONCLUSIONS@&#
