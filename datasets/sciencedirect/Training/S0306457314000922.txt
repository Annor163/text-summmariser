@&#MAIN-TITLE@&#
On planning sightseeing tours with TripBuilder

@&#HIGHLIGHTS@&#
The formal problem of planning a tourist visit as a fully-automatic two-step process.An unsupervised method for mining common patterns of movements of tourists.A comprehensive evaluation of TripBuilder.

@&#KEYPHRASES@&#
Recommender systems,Trajectory mining,Sightseeing tours,

@&#ABSTRACT@&#
We propose TripBuilder, an unsupervised framework for planning personalized sightseeing tours in cities. We collect categorized Points of Interests (PoIs) from Wikipedia and albums of geo-referenced photos from Flickr. By considering the photos as traces revealing the behaviors of tourists during their sightseeing tours, we extract from photo albums spatio-temporal information about the itineraries made by tourists, and we match these itineraries to the Points of Interest (PoIs) of the city. The task of recommending a personalized sightseeing tour is modeled as an instance of the Generalized Maximum Coverage (GMC) problem, where a measure of personal interest for the user given her preferences and visiting time-budget is maximized. The set of actual trajectories resulting from the GMC solution is scheduled on the tourist’s agenda by exploiting a particular instance of the Traveling Salesman Problem (TSP). Experimental results on three different cities show that our approach is effective, efficient and outperforms competitive baselines.

@&#INTRODUCTION@&#
Tourists approaching their destination for the first time have to deal with the problem of planning a sightseeing itinerary that covers the most subjectively interesting attractions, and fits the time available for their visit. Precious information can be nowadays gathered from many digital sources, e.g., travel guides, maps, institutional sites, travel blogs. Nevertheless, the users still need to choose the preferred PoIs, guess how much time is needed to visit them and to move from one attraction to the next one. In this paper we discuss TripBuilder, an unsupervised system helping tourists to build their own personalized sightseeing tour. Given the target destination, the time available for the visit, and the user’s profile, our system recommends a time-budgeted tour that maximizes user’s interests and takes into account both the time needed to enjoy the attractions and to move from one PoI to the next one. Moreover, the knowledge base feeding TripBuilder recommendation model is entirely and automatically extracted from publicly available Web services, namely, Wikipedia, Flickr and Google maps.We observe that an increasing number of tourists share on social networks their travel photos. Unofficial estimates state that Flickr, one of the most popular photo-sharing platforms, collected about 518 million of public photos in 2012.2http://www.flickr.com/photos/franckmichel/6855169886/.2Each photo comes with very useful information such as: tags, comments and likes from Flickr social network, number of views, information about the user, timestamp, GPS coordinates of the place where the photo was taken. This allows us to roughly reconstruct the movements of users and their interests by analyzing the time-ordered sequence of their photos. However, the process of recognizing relevant PoIs given such set of photos is not trivial due to the noise present in the data. User tags are in many cases missing, wrong, or irrelevant for our purposes (e.g., me and Ann, travel to Europe, Easter 2012). Moreover, information available may be sparse and characterized by a skewed distribution.Fortunately, in Wikipedia,3http://www.wikipedia.org.3we can find that most entities of interest for tourism are described in a dedicated page from which we can extract: the (multilingual) name of the PoI, its precise geographic coordinates, the categories to which the PoI belongs according to a weak but robust ontology (i.e., the PoI is a church, a square, a museum, a historical building, a bridge, etc.). By spatially joining and re-conciliating tourists’ photo albums and related information from Flickr with relevant PoIs data extracted from Wikipedia pages, we can derive a knowledge base that represents the behavior of people visiting a given city.4Thereinafter, we will consider cities as the destination targets of our users, although our technique is general and scale-independent.4In this knowledge base the popularity of a PoI is estimated from the number of visitors that shot photos there, while from the timestamps of the first and last photos taken in a PoI we estimate the average time spent for the visit. Finally, we exploit the Wikipedia categories of the PoIs visited by a given tourist to build her user profile. For example, when a user takes many pictures of churches and museums, we can infer a preference for cultural/historical attractions. Analogously, we can aggregate this information at the level of itinerary to build a profile for each frequent visiting pattern.We address the problem of planning the visit to the city as a two-step process. First, given the profile of the user and the amount of time available for the visit, we formalize and address the TripCover problem: choosing the set of itineraries across the PoIs that best fits user interest and respects the given time constraint. Then, the selected itineraries are joined in a sightseeing itinerary by means of a heuristic algorithm addressing the Trajectory Scheduling Problem (TrajSP), a particular instance of Traveling Salesman Problem (TSP). The formalization of TripCover as an instance of the Generalized Maximum Coverage (GMC) problem can be found in Brilhante, Macedo, Nardini, Perego, and Renso (2013), while (Brilhante, Macedo, Nardini, Perego, & Renso, 2014) demos the capabilities of the TripBuilder application.5http://tripbuilder.isti.cnr.it/.5In this paper, we extend the previous research with the following relevant and original contributions:•we detail our unsupervised method for mining common patterns of movements of tourists in a given geographic area. To this purpose we use: (i) Flickr, to gather public photos (and their metadata), (ii), Wikipedia to gather information regarding PoIs in the given city, (iii) Google maps to estimate the time needed to move from a PoI to the next one in the sightseeing itinerary. The resulting knowledge base stores PoIs, their popularity, the time needed in average to visit them, the categories for which each PoI is relevant, and the patterns of movement of tourists that visited them in the past. In order to assess our system, we report about the building of a knowledge base covering three Italian cities, which are important for tourism and guarantee variety and diversity in terms of size and the richness of public user-generated content available: Rome, Florence, and Pisa. The resulting knowledge base, available for download to favor the reproducibility of results, is analyzed and its characteristics are here discussed;we adopt the result discussed in Brilhante et al. (2013) where TripCover is defined and an approximate algorithm is proposed to compute the set of trajectories in the knowledge base that best fits user interests given a time budget. In this paper, we address the subsequent step that consists in processing this set of trajectories to build a schedule of the complete sightseeing itinerary over the tourist’s agenda. To this end, we define TrajSP as a variation of the TSP problem. It aims at finding the shortest path crossing all the trajectories in the TripCover solution. We investigate the TrajSP problem and its peculiarities, which are exploited to devise an efficient and effective heuristic algorithm;finally, we report on several new experiments to evaluate effectiveness and efficiency of all the components of our system and show that our solution outperforms competitive baselines. In particular, we assess TripBuilder performance in providing budgeted sightseeing itineraries made up of actual PoI patterns tailored to the specific preferences of the tourist.The paper is structured as follows: Section 2 introduces the TripCover problem and the approximation algorithm used to solve it. Moreover, the TrajSP problem is defined and addressed in Section 3. Section 4 details the unsupervised method that builds the knowledge base, while Section 5 presents the experiments we perform to assess the effectiveness and the efficiency of our solution. Finally, Section 6 discusses related work and Section 7 draws the conclusions of the work.LetP={p1,…,pN}be the set of PoIs in our city. Each PoI p is univocally identified by its geographic coordinates, a name, a radius specifying its spatial extent, and a relevance vector,vp→∈[0,1]|C|, measuring the normalized relevance of p w.r.t a set of categories C.Symmetrically, let u be a user from the setU, andvu→∈[0,1]|C|the preference vector stating the normalized interest of u for the categories inC. The preference vector can be explicitly given by the user, or implicitly learned. Without loss of generality, in this paper we assume to know in advance the categories C, the relevance vectorsvp→, and the preference vectorsvu→for all PoIs and users.Definition 1User-PoI InterestGiven a PoI p, its relevance vectorvp→, a user u, and the associated preference vectorvu→, we define the User-PoI Interest function as a the following functionΓ(p,u):P×U→[0,1]:Γ(p,u)=α·sim(vp→,vu→)+(1-α)·pop(p)wheresim(vp→,vu→)=vp→·vu→||vp→||||vu→||is the cosine similarity between the user preference and the PoI relevance vectors,pop(p)is a function, ranging from 0 to 1, measuring the popularity of p, andα∈[0,1]is a parameter controlling how much user preference and popularity of PoIs have to be taken into account.Given a user u and the PoIsP, the PoI historyHuof u is the temporally ordered sequence of m points of interest visited by u. Each PoI p ofHuis annotated with the two timestamps indicating the start time and the end time of the visit:Hu=〈(p1,[t11,t21]),…(pm,[t1m,t2m])〉We can notice that having the start time and the end time we have an implicit representation of the time the user u has spent for her visit of p.Definition 3TrajectoryGiven a PoI HistoryHuand a time threshold δ, we define a trajectoryTuany subsequence ofHu〈(pk,[t1k,t2k]),…,(pk+i,[t1(k+i),t2(k+i)])〉such that:i⩾1t1k-t2(k-1)>δ,ifk>1t1(k+i+1)-t2(k+i)>δ,if(k+i)<mt1(k+j)-t2(k+j-1)⩽δ,∀js.t.1⩾j⩽i.Let John Smith be a tourist who visited the city of Rome for two-days. John Smith’s PoI history consists in the temporally ordered sequence of PoIs visited in the two days. As an example:HJohnSmith=〈 (Colusseum, Tue[09.00,10.30]), (Roman forum, Tue[11.00,12.00]), (Spagna square, Tue[14.30,17.30], (St. Peter’s Church, Wed[10.00–11.00]), (Vatican Museum, Wed[11.10,15.00]), (Trevi Fountain, Wed[16.30,17.00]), (Navona Square, Wed[17.20,18.00]), (via Veneto, Wed[18.35,20.00])〉.By using a threshold of 5h as trajectory splitting criterium, fromHJohnSmithwe obtain the following two trajectories:TJohnSmith1=〈(Colusseum,Tue[09.00,10.30]), (Roman forum, Tue[11.00,12.00]), (Spagna square, Tue[14.30,17.30]〉TJohnSmith2=〈(St. Peter’s Church, Wed[10.00–11.00]), (Vatican Museum, Wed[11.10,15.00]), (Trevi Fountain, Wed[16.30,17.00]), (Navona Square, Wed[17.20,18.00]), (via Veneto, Wed[18.35,20.00]〉The time interval between the visits to Spagna square and St. Peters Church is in fact the only interval larger than the given threshold.□By applying the same temporal splitting criterium to all the PoI histories of usersUwe obtain the setS={S1,…,SM}of relevant trajectories. Note thatSresults from a set-union operation disregarding timestamps. Finally, letρ(p):P→Rbe an estimate of the time needed to visitp,τ(pi,pj):P×P→Ran estimate of the time a user needs to move frompitopj, andz→=(z1,…,zM)be the total traveling time associated with each of the M trajectories inS, obtained by exploitingτ(·,·). We are now ready to formulate the TripCover problem, i.e., the problem of generating an optimal personalized itinerary given tourist’s preferences and her budget in term of available time to spend in the city.TripCover(B): Given a tourist u, a set of PoIsP, a time budget B, a set of trajectoriesS, an User-PoI Interest function Γ, a cost functionρ(p)and a vectorz→. Find a subset of trajectoriesS∗ofSthat(1)maximize∑i=1|S|∑j=1|P|Γ(pj,u)yij(2)suchthat∑i=1|S|∑j=1|P|ρ(pj)yij+∑i=1|S|zixi⩽B(3)∑i=1|S|yij⩽1,∀j∈{1,…,|P|}(4)∑i=1|S|xi⩾∑i=1|S|yij,∀j∈{1,…,|P|}whereyij=1ifPoIjintrajectoryiisselected;0otherwise.xi=1iftrajectoryiisselected;0otherwise.Without loss of generality, we assume∀S′∈S,∑p∈S′Γ(p,u)>0. In fact, if this would not hold for a given user u and some trajectories, these trajectories could be filtered out. The TripCover(B) problem as formulated in (2) is an instance of the Generalized Maximum Coverage (GMC) problem that is proven to be NP-hard (Cohen & Katzir, 2008). The constraint (2) and (3) ensure the time budget is satisfied, and each selected PoI is associated with only one trajectory, respectively. Moreover, (4) guarantees a selected trajectory if a PoI is selected. In particular, given a tourist u, TripCover(B) can be captured by the GMC formulation in the following way: (i) the bins in GMC represent the collectionSof trajectories; (ii) the profit functionΓ(p,u)and the cost functionρ(p)are bins-independent. They only depend on p and u. The TripCover(B) problem is thus NP-hard. An efficient greedy approximation algorithm for solving the GMC problem that achieves an approximation ratio ofe/(e-1)+∊,∀∊>0is proposed in Cohen and Katzir (2008). We thus adapted this algorithm, whose source code has been kindly provided us by the authors, in order to take into account TripCover(B) specific constraints.Once the solution of a given TripCover instance is computed, the trajectories inS∗need to be scheduled on the user agenda. To this purpose, we model trajectory scheduling as a Traveling Salesman Problem (TSP) aimed at finding the shortest path crossing all these trajectories. In the classic TSP, the goal is to find the shortest path connecting a given set of geographical points. Here, the task is different as it is defined over a setS∗of disjoint trajectories, i.e., trajectories not sharing any PoI. We consider these trajectories as bi-directional paths representing tourists’ behaviors that must be preserved in the final solution. Therefore we have to connect trajectories in a single sightseeing tour by only considering their terminal PoIs (endPoIs).In the following, we formally define our trajectory scheduling problem (TrajSP), we propose a local-search based algorithm to efficiently address it and, finally, we describe the simple approach used to schedule the final sightseeing tour on the user agenda.Trajectory Scheduling Problem. LetS∗⊆Sbe a set of disjoint trajectories,P∗the set of endPoIs, andE=(eij)the endPoIs matrix whereeij=1if i and j are endPoIs of the same trajectory ofS∗,0otherwise. Moreover, let C be the symmetric cost matrix wherecijis the time needed to move from endPoI i to endPoI j. TrajSP is defined as follows:TrajSP: Given the set of endPoIsP∗, the endPoIs matrix E, and the cost matrix C, find the tourP^that:(5)minimize∑i=1|P∗|∑j=i+1|P∗|cijηij(6)such that∑i=1k-1ηik+∑j=k+1|P∗|ηkj=1,∀k∈{1,…,|P∗|}(7)∑i,j∈Sηij+eij⩽|S|-1,(S⊂P∗,|S|>2),i<j(8)ηij⩽1-eij,∀i,ji≠jwhereηij=1if endPoIiisconnectedtoendPoIj,0otherwise.In the above formulation, only the costs between different trajectories’ endPoIs have to be considered for minimizing cost (5), while (6) and (7) impose constraints on the degree of each endPoI and on sub-tour elimination, respectively (Rajesh Matai & Mittal, 2010). Note that the degree constraint in (6) is set to 1 since each endPoI already has one fixed connection to the next PoI of the associated trajectory. The last constraint in (8) ensures that two endPoIs of the same trajectory are never connected together in the solution.Although the number of possible solutions for TrajSP is lower than whose of the corresponding TSP formulation,6We have exactly(k-1)!∗2(k-1)solutions for k trajectories in the case of TrajSP, and(2k-1)!/2for the corresponding TSP formulation considering the two endPoIs of each trajectory.6finding the exact solution to TrajSP is still infeasible even for instances involving a small number of trajectories (we have about 82 billions of possible solutions with only 12 trajectories). Hence, we address TrajSP by proposing a Local Search heuristics that starts from a (given or random) tourP^connecting all trajectories inS∗, and then applying local changes toP^by means of 2-OPT or 3-OPT strategies (Rajesh Matai & Mittal, 2010).We now introduce an interesting property of the TrajSP problem that allows us to formalize how 2-OPT or 3-OPT strategies have to be applied. Given endPoI i, lete(i)=jbe the other endPoI of the same trajectory. Obviouslye(j)=iholds as well. Since we start from a tour connecting all the trajectories, each endPoI i is connected to bothe(i)and to an endPoI d of another trajectory inS∗. Let denote withn(i)the connected endPoI d. Note that only the link between endPoIs i andn(i)can be modified, since the path between i ande(i)is fixed by definition.We now introduce a basic local-change operationop(i,k)over two endPoIsi,k, such thatk≠e(i). The local-change operation works by adding link(i,k)and removing links(n(i),i)and(n(k),k). It is clear that the application ofop(·,·)leads to a non-admissible solution for TrajSP, since we remove two links of the tour while we add only one. We thus need to perform some additional changes to reconnect the two endPoIs that remain disconnected. The result below formalizes how such changes aimed at restoring the feasibility of the current solution have to be done. In particular, given two endPoIsi,k, it states that we can apply 2-OPT or 3-OPT strategies chosen according to the value ofl(i,k), a function returning the minimum number of endPoIs connections between i and k.Lemma 1Given a tourP^and a local-change operationop(i,k)performed over two endPoIsi,ksuch thatl(i,k)>1, ifl(i,k)is even, then a 2-OPT strategy needs to be applied to produce a feasible tour, a 3-OPT strategy otherwise.Given two endPoIsi,k,l(i,k)can be either even or odd. First, supposel(i,k)is even. It means that the minimum number of connections between the endPoIs i and k is even. As a consequence, starting from the link(n(i),i)(crossed line), by walking anti-clockwise from i to k, we arrive at(e(k),k)(solid line), or from(i,e(i))(solid line) by walking clockwise, we arrive at(k,n(k))(crossed line) as shown in Fig. 1(a).Operationop(i,k)removes(n(i),i)and(n(k),k). Moreover, it adds(i,k)(see Fig. 1(b)). Note that, at this point the tour is disconnected. To have a feasible tour, we need to add the new link(n(i),n(k))that joins the two disconnected endPoIs. Because this process adds two links(i,k),(n(i),n(k))and removes two other links(n(i),i),(n(k),k), it corresponds to applying a 2-OPT strategy.We now study the casel(i,k)is odd. Starting from(i,n(i)), leads us to(k,n(k))(crossed line). Moreover, from(i,e(i))we arrive at(k,e(k))(solid line). This configuration is shown in Fig. 1(c). Applyingop(i,k)to this particular case generates a different configuration (see Fig. 1(d)), i.e., one sub-tour (i.e., a closed path) from i to k, and one path fromn(i)andn(k). To merge the sub-tour and the path, we need to remove one link from the sub-tour and connect it to the path, e.g.,n(i)andn(k). So, we can remove(e(i),n(e(i)). We then need to add(e(i),n(i))and(n(e(i)),n(k))to obtain a tour crossing all the endPoIs. Because we add three new links and remove three other ones, we applied a 3-OPT strategy.□Local search algorithm. From the above discussion, it is easy to devise a local search algorithm that iteratively optimizes a given tour by applying 2-OPT or 3-OPT strategies and stops after a fixed number of iterations or when it converges to a locally optimal solution.Scheduling the tour on the user agenda. Given the sightseeing tourP^computed for a given user and a time budget by our local search TrajSP algorithm, we schedule it on the user agenda by splitting the tour into the desired number m of slots (e.g., days). The solution involves identifying a starting endPoI in the tour and assigning the successive PoIs inP^to the current slot until the slot is filled and the next slot is considered. The choice of the starting endPoI can be done in two different ways: either by removing the most “expensive” connection (e.g., in terms of traveling time) between two endPoIs of the tour or by taking into account the closest endPoI to a given spatial position (e.g. user’s hotel).Fig. 2depicts an overview of the TripBuilder architecture. The component related to “Data Collection” retrieves relevant data from Flickr, Wikipedia, and Google Maps. The second component called “Data Processing” extracts the knowledge used to devise relevant PoIs and model users’ visiting behaviors from data provided by the “Data Collection” component. Given a budget B, the third component “Covering” deals with the exploitation of the models and the knowledge base to compute the solution to the TripCover(B) problem. The result is a set of trajectories in the chosen city on the basis of user interests and time budget that are finally scheduled on the user agenda by the fourth component “Scheduling”.In order to assess TripBuilder we generate – in a complete unsupervised process – a knowledge base covering three Italian cities which are important from a sightseeing point of view and guarantee variety and diversity in terms of size and richness of public user-generated content available for download: Rome, Florence, and Pisa. The generation of the knowledge base for each of the cities is a multi-steps process that we are going to detail in the following.PoIs. The first step is to identify the set of PoIs in the target geographical region. Given the bounding boxBBcitycontaining the city of interest, we download all the geo-referenced Wikipedia pages falling within this region. We assume each geo-referenced Wikipedia named entity, whose geographical coordinates falls intoBBcity, to be a fine-grained Point of Interest. For each PoI, we retrieve its descriptive label, its geographic coordinates as reported in the Wikipedia page, and the set of categories the PoI belongs to. Categories are reported at the bottom of the Wikipedia page, and are used to link articles under a common topic. They form a hierarchy, although sub-categories may be a member of more than one category. By considering the set C of categories associated with all the PoIs, we generate the normalized relevance vector of each PoI. We then perform a density-based clustering to group in a single PoI sightseeing entities which are very close one to each other.7Consider for example the beautiful marble statues in the Loggia dei Lanzi in Florence which are only a few meters far one from each other but have a distinct dedicated page in Wikipedia.7Clustering very close PoIs is important since a tourist in a given place can enjoy all the attractions in the surroundings even if she do not take photos to all of them. Moreover, it aims at reducing the sparsity that might affect trajectory data. To cluster the PoIs we use DBScan (Ester, Peter Kriegel, Sander, & Xu, 1996). To build our dataset, we set 1 as the minimum number of points and 200m as ∊. Finally, we obtain the relevance vector for the clustered PoIs by considering the occurrences of each category in the members of the clusters and by normalizing the resulting vector. At the end of this first step we have the setP={p1,…,pN}of PoIs and the relevance vectorvp→∈[0,1]|C|for each of these PoIs in a fully automatic way by exploiting Wikipedia as an external source of knowledge.Users and PoI histories. As second step we need a method for collecting usersUand the long-term itineraries crossing the discovered PoIs. We query Flickr to retrieve the metadata (user id, timestamp, tags, geographic coordinates, etc.) of the photos taken in the given areaBBcity. The assumption we are making is that photo albums made by Flickr users implicitly represent sightseeing itineraries within the city. To strengthen the accuracy of our method, we retrieve only the photos having the highest geo-referenced accuracy given by Flickr.8http://www.flickr.com/services/api/flickr.photos.search.html.8This process thus collects a large set of geo-tagged photo albums taken by different users withinBBcity. We preliminary discard photo albums containing only one photo. Then, we spatially match the remaining photos against the set of PoIs previously collected. We associate a photo to a PoI when it has been taken within a circular buffer of a given radius having the PoI as its center. To build our dataset, we empirically set it to 100m this radius. Note that in order to deal with clustered PoIs, we consider the distance of the photo from all constituent members: in the case the photo falls within the circular region of at least one of the members, it is assigned to the clustered PoI. Moreover, since several photos by the same user are usually taken close to the same PoI, we consider the timestamps associated with the first and last of these photos as the starting and ending time of the user visit to the PoI. The PoI visiting timeρ(p)is then estimated by computing for each PoI the average of these times. Moreover, the popularity of each PoI is computed as the number of distinct users that take at least one photo in its circular region. The above process allows us to generate the set of usersU, their PoI history, and estimate for the popularity and visiting time of each PoI. Finally, the preference vector for each user is built by summing up and normalizing the relevance vectors of all the PoIs occurring in her PoI history.Trajectories. In order to build the setSof trajectories we split users’ PoI histories as detailed in Definition 2. To choose the splitting threshold δ, we derive the users’ wisdom-of-crowds behavior by analyzing the inter-arrival time of each pair of consecutive photos taken in different PoIs. Therefore, for each city we compute the distribution of probability of the inter-arrival timeP(x⩽δ)of pairs of consecutive photos. Then, we devise the time threshold δ such thatP(x⩽δ)=0.9. Fig. 3(a) shows the distributions of probability of inter-arrival times, i.e.,P(x⩽δ), for all the pairs of consecutive photos in each dataset. Results show that while for Rome and Florence the resulting δ is about 5 and 6h respectively, for the smallest city of Pisa it decreases to about 3h.Traveling time estimation. An important aspect of TripBuilder is that we recommend sightseeing tours fitting the available time budget and not just the set of PoIs to be visited. The sightseeing tour building step should therefore consider not only the PoI visiting timeρ(p)but also the timeτ(·,·)needed to move between consecutive PoIs in the itinerary. Since measuring intra-PoI moving time from the photo albums resulted to be inaccurate for not popular PoIs, we resort to an external service. Given a pair(pi,pj)of PoIs in a trajectory, we estimateτ(pi,pj)by querying Google Maps for the walking time between the PoIs. Naturally, this is an approximation since several variations may happen: the user having a car, using public transportation, taking a taxi. However, our method is parametric to these aspects, and the system can be easily adapted to consider the different choices. Moreover, most PoIs in our sightseeing cities are actually at walking distances.Datasets statistics.Table 1shows the main characteristics of the three datasets. The second column reports the number of PoIs for each of the three cities. Note that these numbers refer to the result of the clustering phase, while the number of entities extracted from Wikipedia is 124, 1022, and 671 for Pisa, Florence and Rome, respectively. Furthermore, columns “Users” and “Photos” report the number of distinct users and photos retrieved from Flickr. Finally, column “Trajectories” reports the number of trajectories crossing at least two PoIs, while column “Traj. per PoI (avg.)” reports the average number of trajectories crossing each PoI.Fig. 3(b)–(d) show three plots regarding the characteristics of the three datasets that have been made available for download to favor the reproducibility of experiments.9Interested readers can download the datasets from the URL: https://github.com/igobrilhante/TripBuilder.9A general consideration common to all the three figures regards the skewness of the distributions that are plotted in log–log scale. In particular, Fig. 3(b) reports the distribution of trajectory length expressed in term of the number of crossed PoIs. We can see that the slope of the three curves is very similar, only absolute values vary as expected. Note that the most frequent trajectory length in the plot is just 1. These are obviously noisy trajectories, corresponding to the cases in which we can match only one single PoI to a photo album. These spurious trajectories are maintained in the datasets only for their contribution to the measure of PoI popularity, but do not belong to the setSof trajectories used by TripBuilder.Fig. 3(c) shows the distribution of PoI popularity in the three cities involved. Even in this case we can note strong similarities in the distributions, although the curves of Rome and Florence cross in the tail. This happens for a peculiarity in these two datasets: while we have more users and photos for Rome than for Florence, the opposite holds for the number of PoIs reported in the X axis.The last plot reported in Fig. 3(d) shows the popularity of categories associated with the PoIs. Even in this case we have a power-law distribution with a few very popular categories and most categories associated with relatively few PoIs. Wikipedia categories form in fact a (weak) hierarchy, and the most general topics are associated with many pages, while sub-categories are relevant only for precisely identified subsets of homogeneous PoIs.Finally, Table 2report the top-3 most popular PoIs and categories in Pisa, Florence and Rome. We also report three examples per city of trajectories extracted from the dataset. Note that a popular PoI in Florence and Pisa is the baptistery which is entitled, in both cities, to Saint John the Baptist.

@&#CONCLUSIONS@&#
In this paper, we comprehensively discussed TripBuilder, our unsupervised framework for recommending personalized sightseeing tours. TripBuilder addresses the problem of planning the visit to a city of touristic interest as a two-steps process. First, given the profile of the user and the amount of time available for the visit, the set of itineraries across the PoIs that best fits the user interests and respect the time constraint is chosen. This is done by solving the TripCover problem by means of an approximation algorithm. Then, the selected trajectories are joined in a sightseeing itinerary by means of a local search algorithm addressing TrajSP, a particular instance of the Traveling Salesman Problem. TripBuilder generates the budgeted sightseeing tours by composing popular trajectories performed by real tourists as mined from Flickr Photo albums. Moreover, since both PoIs characteristics and user preferences are mapped into the same categorization automatically extracted from Wikipedia, it is able to personalize the recommended itinerary and even consider the popularity of each PoIs as estimated from the number of photos available for it.We experimented TripBuilder with data collected for three cities different for their size and the amount of user-generated content available for download. The process exploited to mine such content from Flickr, Wikipedia and Google Maps and to build the TripBuilder knowledge base has been detailed, and an analysis of the data collected has been provided. We evaluated our framework by considering the performance of the algorithms proposed to address both the TripCover and the TrajSP problems. The proposed solutions resulted to outperforms the baselines in terms of all the metrics adopted for assessment. Our solution suggests itineraries that better match user preferences. Moreover, such itineraries present higher visiting time and, consequently, lower intra-PoI movement time than the baselines. Furthermore, we assessed the performance of our TSP-based local search heuristic to schedule a set of trajectories into the user agenda. Finally, the tests conducted to demonstrate the efficiency of TripBuilder show that it computes a four-day personalized sightseeing tours of Rome in about 3s thus confirming that our approach can be fruitfully deployed in online applications.