@&#MAIN-TITLE@&#
Space subdivision to speed-up convex hull construction in E3

@&#HIGHLIGHTS@&#
Algorithm for computing the convex hull of a set of points in E3 we are proposed.The algorithm is based on spherical space subdivision.The algorithm eliminates as many input points as possible before the convex hull calculation.Experimental results show that the proposed algorithm achieves a better time complexity in comparison with other algorithms in E3.

@&#KEYPHRASES@&#
Convex hull,Space subdivision,Points reduction,Points distribution,Approximated angle,Initial convex polyhedron,

@&#ABSTRACT@&#
Convex hulls are fundamental geometric tools used in a number of algorithms. This paper presents a fast, simple to implement and robust Smart Convex Hull (S-CH) algorithm for computing the convex hull of a set of points in E3. This algorithm is based on “spherical” space subdivision. The main idea of the S-CH algorithm is to eliminate as many input points as possible before the convex hull construction. The experimental results show that only a very small number of points are used for the final convex hull calculation. Experiments made also proved that the proposed S-CH algorithm achieves a better time complexity in comparison with other algorithms in E3.

@&#INTRODUCTION@&#
A convex hull is a fundamental construction not only in computational geometry and mathematics. It has numerous applications in various fields such as collision detection, mesh generation, shape analysis, cluster analysis, metallurgy, crystallography, cartography, image processing, sphere packing and point location. There are many other problems which can be reduced to the convex hull, e.g. halfspace intersection, Delaunay triangulation, Voronoi diagram, etc. Fast convex hull algorithms are useful for interactive applications, such as collision detection in computer games and path planning for robotics in dynamic environments.A subsetS⊆R3is convex if and only if for any two pointsp, q∈ S the line segment with endpointspandqis contained in S. The convex hullCH(S)of a set S is the smallest convex set containing S. The convex hull of a set of points P is a convex polyhedron with vertices in P.Many algorithms for calculation of the convex hull in 3D have been developed over the last several decades. Chand and Kapur [1] developed the Gift Wrapping algorithm, and Preparata and Hong [2] developed a recursive algorithm, which is based on Divide & Conquer. Clarkson and Shor [3] introduced an incremental insertion algorithm, where the points are processed one by one with respect to the currently constructed convex hull. Barber et al. [4] developed an efficient convex hull algorithm, which is called QuickHull. Hybrid algorithm, which is based on QuickHull and Gift Wrapping algorithms, is presented in [9]. The time complexity of some of the convex hull algorithms is presented in Table 1.Several parallel algorithms for convex hull construction were proposed. Chow [12] presented a parallel convex hull algorithm that runs at O(log3n) time complexity. Amato and Preparata [13] designed an O(log2n) time algorithm using n processors, where n is the number of input points. Reif and Sen [14] proposed a randomized algorithm for three dimensional convex hulls that runs at O(log  n) time using a Divide & Conquer approach on O(n) processors. Amato et al. [15] gave a deterministic O(log3n) time algorithm for a convex hull in RdusingO(nlogn+nd/2)work. Gupta and Sen [11] proposed a fast parallel convex hull algorithm that is output-size sensitive.There are several convex hull algorithms modified for GPU applications. Gao et al. [17] developed a two-phase convex hull algorithm in three dimensions that runs on the GPU. Stein et al. [10] proposed a parallel algorithm based on QuickHull approach.Other algorithms are based on a probabilistic approach [18]. Precision of convex hull algorithm with regard to physical floating point representation is solved as well, e.g. in [16].In this section, we introduce a new Smart Convex Hull (S-CH) algorithm based on space subdivision for construction of the convex hull in E3. The main idea of this algorithm is to eliminate as many input points as possible using an algorithm with O(N) complexity based on space subdivision, and a ``standard'' convex hull algorithm with O(nlog n) is used for the remaining points, where n ≪ N. We use “spherical” space subdivision based on 3D sectors for efficient elimination of points not contributing to the final convex hull.This section is organized as follows. Section 2.1 presents the first step of the S-CH algorithm, which is an inner convex polyhedron construction followed by the location of points inside the initial convex polyhedron. In Section 2.2, we describe how to perform the division of points into non-overlapping 3D pyramidal shape sectors.Section 2.3 presents reduction of the suspicious points. The calculation of a convex hull from the selected points with a standard convex hull algorithm is made in Section 2.4.At the beginning of the proposed S-CH algorithm, we need to find the extremal points in all axes, i.e. points with maximum and minimum x, y or z coordinates. The time complexity of this step is O(N). For our purpose, we do not need the exact extremal points, because extremal points close enough are sufficient. This means that we do not have to search extremes through all the input points, but we can search only random sample points. According to experiments made, approx. 10% of all points are sufficient. This simplification does not cause any problems for future calculations and we save computational time as well and the complexity of this step is O(N) only. Therefore, we generally get six distinct extremal points or less.Now we can create a convex polyhedron using these points, see Fig. 1. Note that the extremal points are determined using the above presented estimation. We assume that the volume of the final object is nonzero, so the convex polyhedron will not be degenerated. One very important property of this polyhedron is that any point lying inside cannot be a point on the convex hull. Thus, we can perform a fast and simple initial test for a point inside/outside the polyhedron and discard many points.The location test of a point inside a polyhedron can be performed as follows. Each face of the polyhedron is an oriented plane with a normal vector oriented outside of the polyhedron. Then we can calculate:(1)Fi(x)=aix+biy+ciz+di=niTx+di=0,wherexis a point andFi(x)=0is the implicit equation of a plane with index i having the normal vectorni=(ai,bi,ci). If Fi(x) < 0 for at least onei∈{0,1,…,7},then pointxlies outside of the polyhedron and has to be further processed. Otherwise, pointxlies inside of the polyhedron and can be eliminated.In the second step of the S-CH algorithm, only the points, which lie outside of the initial polyhedron, will be further processed. Firstly, we perform the division of 3D space into several non-overlapping “pyramidal shape” sectors, i.e. we are using an “approximated spherical” subdivision. A center point and both angles (azimuth φ and zenith θ) are used in this subdivision. The center pointCis defined as the average of all vertices of the initial polyhedron.Division of space can be performed as a uniform spherical subdivision in both angles, where azimuth φ ∈ [0, 2π) and zenith θ ∈ [0, π]. However, using this, we would have to calculate the exact angles and, moreover, an explosion of small and singular triangles would occur at the both poles. Therefore, we use a simplified calculation of approximated angle. As a result of this simplification, the sectors are not uniformly distributed in the spherical coordinate space, but are uniformly distributed on the faces of a cube, see Fig. 2. Now, when calculating the azimuth and zenith, we have to locate the exact third of the octant, where the point is located and then calculate the intersection with the given face. Calculation of the intersection is easy, because all faces are axes aligned, i.e.x=±1ory=±1orz=±1. Finally, we have to determine a table of neighbors for each sector. Note that the neighboring sector can lie on another face of the cube. This means that adjacency of sectors can be determined across the edge of a cube or the vertex of a cube.Now we are able to calculate the exact index of a sector to which the given point belongs.For each sector with index i, one maximal pointRimaxis determined. This point equals a point where is a maximum distance between the center pointCand all points in a sector. The initial pointsRimaxare lying on the faces of the initial polyhedron. These points can be calculated as an intersection point of the axis of a sector and the face of the initial polyhedron.For each new point we have to check whether the distance from this point to the center pointCis greater than the distance fromRimaxto the center pointC. If this is true, then we have to replace pointRimaxwith a processed point, add this point into the sector with index i and recalculate the test planes, see Fig. 3. Otherwise we continue with the next step.In the next step, we check whether the processed point lies over or under the test planes.Firstly, we determine the projection of the actual point to the face of the unit cube. Then we can compare coordinates of this projection with the projection of maximal pointRimaxand based on the result, we choose one of four options, see Fig. 4. Now we have to use the five planes which are defined by maximal pointsRimaxof the actual sector and neighboring sectors (hatched green) and perform a test for a point over/under the plane. If the point is under all five planes, we can discard it, because such a point cannot be part of the convex hull. Otherwise we add this point into the sector with index i.We can gain some extra speed-up if the input dataset is pre-sorted according to the distance from the center pointC. In such a case we start by processing the farthest points from the input dataset. It leads to fast determination of maximal pointsRimaxand more points from the input dataset can be eliminated. Moreover, the next step, which is described in Section 2.3, does not need be performed.The pre-sorted input dataset can speed-up the reduction steps. However, the sorting algorithms have the time complexity O(N log  N), which is higher than the time complexity of reduction steps O(N). Therefore, it is not beneficial to sort the input dataset.We have already divided all suspicious points into sectors. We gave pointsRimaxsome initial values before starting to divide points into non-overlapping sectors and we used these pointsRimaxto check whether to add or eliminate a point. Values of pointsRimaxhave changed during the division process; hence we have to recheck all suspicious points using the final values of pointsRimax. We minimize the number of suspicious points, which are input for the final convex hull construction, using this step. Final sets of suspicious points for input datasets with different distributions of points are shown in Fig. 5.It should be noted that the reduction test eliminates the vast majority of given points. In case that the majority of points are close to the surface of the corresponding convex hull then the performance of reduction steps will decreases as only few points will be reduced.After performing the previous steps, we use any known algorithm for calculation of the convex hull. The set of input points for this algorithm equals suspicious points. The number of suspicious points is extremely low in comparison of the number of the original points; thus the time needed for determining the convex hull is insignificant compared to the time needed for reduction of the original input points. Therefore, this step is more or less independent of the choice of a convex hull algorithm. In our approach we used the library MIConvexHull,11This library is available at https://miconvexhull.codeplex.com/.which is based on the QuickHull algorithm.QuickHull uses a Divide & Conquer approach. This algorithm performs the following steps:1.Find three points (for example, points with minimum and maximum x coordinates and a point with a minimum y coordinate) which are bound to be part of the convex hull.Divide the set into two subsets of points by a plane formed by the three points. This step will be processed recursively.On one side of the plane, determine the point with the maximum distance from the plane. The three points found before along with this one form a pyramid.In the next step, the points lying inside of the pyramid can be ignored.Repeat the previous two steps on the three planes formed by the pyramid.Repeat this procedure until no points are left. Then the recursion has come to an end.It can be seen that the S-CH algorithm is quite simple. In the following experimental results will be presented.

@&#CONCLUSIONS@&#
