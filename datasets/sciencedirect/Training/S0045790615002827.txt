@&#MAIN-TITLE@&#
Integer-based accurate conversion between RGB and HSV color spaces

@&#HIGHLIGHTS@&#
Conversion algorithm between 24-bit RGB and integer HSV is proposed.The algorithm is as accurate as the classical real-valued one.Performance measurement results show a speed gain of about two times.The resulting HSV color can be packed into 48 bits.Floating-point variables and Lookup tables are not used.

@&#KEYPHRASES@&#
HSV,RGB,Integer algorithm,Color space conversion,

@&#ABSTRACT@&#
This paper introduces a new fast integer-based algorithm to convert the RGB color representation to HSV and vice versa. The proposed algorithm is as accurate as the classical real-valued one. The use of only integer operations increases performance and portability. Performance measurement results show a speed gain of about two times when compared with the classical C++ language implementation on PC platforms. Lookup tables are not involved, thus the memory usage is minimal. The resulting HSV color can be packed into 48 bits. The proposed method can safely replace the commonly used floating-point implementation.

@&#INTRODUCTION@&#
The Hue Saturation Value (HSV) color space was created by Alvy Ray Smith in 1978 [1]. Initially, it was designed to improve a color picking interface in computer graphics software. The HSV model is a popular tool for color mixing since it is well consistent with human color perception. Furthermore, the HSV color space is often used in image processing and computer vision fields.HSV space is well proven in image segmentation. Ganesan et al. used HSV color histogram for segmentation of region of interest in satellite images [2]. Liu et al. developed a method of fog level detection in highspeed road traffic based on image HSV color histogram [3]. Feng et al. proposed online method for rare colored capsule detection based on RGB and HSV color space [4].Several works apply HSV for skin detection. Rahman et al. combined HSV and YCbCr color spaces in a new human skin detection method [5]. Bhowmick et al. applied HSV and YCbCr mixed color space for skin color segmentation in hand gesture recognition method for English alphabets [6]. Chaudhary and Gupta used HSV in dynamic color space switching system for skin pixel segmentation [7].HSV components are often used as feature vectors for image retrieval and classification. Rashno et al. proposed a feature extraction schema that includes color features in RGB and HSV domain [8]. Raja et al. used colors from HSV model as low level features in robust indoor/outdoor scene classifier [9]. Archana et al. applied HSV in multiple face detection method with accuracy of 93% [10].Fast RGB to HSV conversion algorithm is required for video processing. Wang and Zhao developed robust image chroma-keying method using HSV colors [11]. Chernov et al. proposed underwater video enhancement method based on HSV color space [12]. Guo et al. adjusted S and V channels in order to improve visibility and fidelity of underwater images [13].The use of HSV rather than RGB space is beneficial in texture analysis. Paschos [14] demonstrates that perceptually uniform spaces, such as HSV and L*a*b*, outperform nonuniform RGB. He concludes, according to experimental results, that HSV could be a superior color space, compared to RGB, for color texture analysis. In noisy conditions the HSV performs better than the L*a*b*.The HSV model is designed as a transform of the RGB space. Practically, the only way to obtain the color in HSV is to convert it from RGB first. Therefore, characteristics of theH,S, and V components are dependent on the transformation algorithm. The classical conversion formulas, proposed by Smith [1], assume computations on real (not integer) numbers. Otherwise, the result would not have the expected precision. This causes the consideration for theH,S,Vto be real numbers as well. The conversions have a classical implementation in programming languages with floating-point variables involved. As a reference of such implementation, the source code [15] from the GIMP editor (GNU Image Manipulation Program) is recommended by the authors.In most cases, the classical floating-point realization is sufficient. However, there is a branch of algorithms that aims to improve the performance and portability of the color space conversions. A reasonable way in such improvement is to use integer (fixed-point) arithmetic and data types. Note, that the terms fixed-point and integer are practically identical in this context and used as synonyms in this paper.Kabi et al. switched from floating-point to fixed-point arithmetic in order to reduce power consumption, time and market price of handheld devices for the application of speech-based emotion recognition [16]. Dobashi et al. proposed a fixed-point tone mapping operation (TMO) as a replacement for a floating-point TMO in order to reduce a computational cost for generating a low dynamic range (LDR) image from a high dynamic range (HDR) image [17].The main practical reasons motivating the usage of the integer instead of floating-point arithmetic are performance and portability. For most processors, integer arithmetic is faster and well-suited to optimize hardware implementations like FPGA and allow for nice embedded system realizations. In addition, the integer-based algorithm is able to be run on hardware without an FPU (Floating-Point Unit or math coprocessor).The integer data types for both RGB and HSV color schemes are preferable in many applications. The integer-based representation is generally more robust. Following good programming practices, the float and double types should not be used where exact results are required. This rule is applicable for many pixel manipulation applications, where floating-point representation is redundant. However, the straightforward change to integer types in the classical implementation is impossible without precision loss.Liu et al. [18] proposed a fast algorithm for color space conversion based on fixed-point calculations on digital signal processors (DSPs). In the publication, the following conversion methods are included: YCbCr (luminance, chrominance-blue, and chrominance-red) to RGB, RGB to HSV, and YCbCr to HSV. The authors replaced floating-point multiplications with fixed-point shifts, 16-bit fixed-point multiplications, and additions. They used supporting small-sized (225 bytes and 256 bytes) lookup tables (LUT) in order to compensate for rounding error and to realize the 16-bit fixed-point multiplication. According to the experimental results, the authors achieved the error in acceptable range, maximum equal to 3. At the same time, they significantly improved computational speed, about 10 times faster on a fixed-point DSP and about 1.41 times faster on a personal computer (PC).This paper introduces an integer-based algorithm to convert color representation from RGB to HSV and vice versa. The proposed algorithm is as accurate as the classical one. Each color from the RGB space has a unique equivalent in the HSV space. All HSV and RGB components in the proposed conversions are integer numbers. The use of floating-point variables is excluded entirely. The implementation of the proposed algorithm is fast, which is important for real-time image processing applications. Performance measurement results show a speed gain of about two times when compared with the classical implementation [15] on PC platform. Lookup tables are not involved. Therefore, the memory usage is minimal. The proposed algorithm can safely replace the classical one. If the floating-point data types are still needed for complex math operations, the HSV channels can be type-casted afterward.This paper is organized as follows. In Sections 2 and 3 the theoretical background about RGB and HSV models, respectively, is given. In Section 4 the classical real-valued conversion algorithm is explained. The proposed integer-based algorithm is presented in Section 5. The performance analysis is done in Section 6. The experimental results are shown in Section 7. Finally, the paper is concluded in Section 8.The RGB model encodes a color using three components: red (R), green (G), and blue (B). It is an additive color scheme that employs the principle of human eye functionality, i.e., sensitivity of three types of cones in retina to specific light spectra [19]. Thus visible colors can be reproduced by adding various intensities of red, green, and blue lights. The concept of RGB mixing is widely utilized in display and camera devices that makes this color model essential for most computer graphics applications.RGB space can be visualized in the form of a cube in a three-dimensional Cartesian coordinate system (Fig. 1). The black color is in the axis origin while the white color is located in the diagonally opposite corner. The rest of the vertices represent primary colors (red, green, and blue) and secondary colors (cyan, yellow, and magenta).The standard 24-bit RGB format is required for the proposed integer algorithm. In the 24-bit RGB pixel, all components have 8-bit depth. The total number of possible colors in this case is28·28·28=16,777,216. The components are interpreted as unsigned integers in range[0,255], which is exactly the value range of a single byte.Typically, the pixels of raw images are given in this format. However, in the classical conversion algorithm, RGB channels are required to be floating-point numbers in range[0,1], which causes the type-casting and division operations. In the proposed algorithm, the channels are processed as in the basic 24-bit format. The order of the components is not important since both algorithms process them independently.The RGB scheme has a number of disadvantages. It is not intuitive for human interpretation. The luminance and chrominance properties are not separated. The Euclidean distance cannot be applied for correctly capturing color differences [20]. All the components are highly correlated with each other and in addition it is highly sensitive to illumination changes and noise.The HSV model defines color in terms of three components: hue (H), saturation (S), and value (V). It is an approximately uniform perceptual color space [14] that correlates well with human color sensation. In uniform spaces, the measured color difference (Euclidean distance) is proportional to human perception of such difference. In comparison, the RGB is not uniform.The hue component (H) represents a true color, e.g., red, yellow, green, cyan, blue, magenta, etc. Its pure values contain primary colors, secondary colors, and linear mixtures between adjacent pairs of them. As a physical measure, the hue is related to the wavelength of light.The saturation component (S) represents color purity. It gives a measure of how much the true color is diluted by white. Low percentage of the S channel produces grayish color while high percentage produces deep color. Decreasing S (desaturation) corresponds to increasing whiteness.The value component (V) is an analog of brightness. It measures the departure of the true color from black i.e. zero energy. Decreasing V (devaluation) corresponds to increasing blackness.HSV color space was designed as a deformation of the RGB color cube. In other words, the HSV is a different coordinate system describing the RGB model (Fig. 2). The HSV is geometrically represented as a hexagonal cone (hexcone). The term hexcone was used by Smith in his original paper [1].The central vertical axis (the gray axis) of the hexcone corresponds to the main diagonal of the color cube. It contains achromatic colors (grays). Value (V) varies along the gray axis from black at minimum to white at maximum. At least one ofR,G, or B equals V, and none is larger.The horizontal cross-sections of the hexcone are hexagons of different sizes. As value (V) changes, the sizes of the hexagons are also changed. Each one is larger than the preceding one when moving from black to white. The cross-section that corresponds to black color degrades to a point.The Hue (H) and saturation (S) pair specifies a point in the hexagon. The hue (H) is a circular quantity. It is visualized by the angle around the gray axis. According to the classical layout [1],0°is red,60°is yellow,120°is green,180°is cyan,240°is blue, and300°is magenta. The saturation (S) is the distance from the gray axis along the horizontal axis. It is a relative quantity. The maximum S corresponds to the longest possible distance at the given H. A point with the maximum S lies on the boundary of the hexagon. Hue (H) is undefined and saturation (S) is equal to 0 along the gray axis.Each H and S pair belongs to one of the six sectors of the hexagon. The sector can be defined by H (as angle), or by dominance ofR,G, and B components. In Table 1the properties of all six sectors are presented. The sector number (I) is important for the conversions. H is derived as its fraction plus the sector offset. The hue fraction (F) is the partial value of H inside the sector. The sector offset is the integer amount of edges (counted counter-clockwise) multiplied by the edge length (E). Therefore, H is computed asH=(E·I+F)/r, where r is a scaling factor for adjusting the range.The ranges of the components vary in different realizations. Since hue (H) is angular, it is often expressed in degrees[0,360]. Another convenient representation, that is suitable for all components, is percentage (from 0% to 100%). In Smith’s work [1], as well as in the classical implementation [15], each of the components is in the range[0,1]. In this paper, when the real-valued algorithm is considered, theH,S, and V are also assumed to be in the interval[0,1]. Such assumption, simplifies the hue formula toH=(I+F)/6, forE=1andr=6. A constant scaling factor in different realizations can be ignored without loss of generality.Smith in his paper [1] presented transformation algorithms for forward and backward conversions between the RGB and HSV models.The forward conversion (from RGB to HSV) requires the following steps:1.Find maximum (M) and minimum (m) ofR,G, and B.M=max(R,G,B)m=min(R,G,B)AssignV=M.Calculate delta (d) between M and m.d=M-mIf d is equal to 0 then assign S with 0 and return. H is undefined in this case.Calculate S as a ratio of d and M.S=dMCalculate H depending on what are M and m.H=16·G-Bd,ifM=Randm=B1+R-Bd,ifM=Gandm=B2+B-Rd,ifM=Gandm=R3+G-Rd,ifM=Bandm=R4+R-Gd,ifM=Bandm=G5+B-Gd,ifM=Randm=GThe conversion involves ordering ofR,G, and B components, i.e. finding the minimum, and maximum of them. If they are equal, then it is the achromatic case when saturation (S) is 0 and hue (H) is undefined. Value (V) is always equal to the maximal RGB component. The formula for saturation isS=max(R,G,B)-min(R,G,B)max(R,G,B). The formula for hue (H) includes computation of its fraction part and summation with appropriate sector offset. The fraction of hue is computed asF=mid(R,G,B)-min(R,G,B)max(R,G,B)-min(R,G,B). The middle component and sector offset are determined according to previously found maximum (M) and minimum (m). Finally, H is divided by 6 in order to change the range to[0,1].The backward conversion (from HSV to RGB) can be done by the following steps:1.If S is equal to 0 then assign allR,G, and B with V and return.Multiply H by 6.H=6·HDetermine the hue sector index (I) by taking the largest previous integer (floor) of H.I=⌊H⌋=floor(H)Determine the hue fraction (F) by subtracting I from H.F=H-ICalculate values (M,N, and K) of RGB components.M=V·(1-S)N=V·(1-S·F)K=V·(1-S·(1-F))AssignR,G, and B with appropriate valuesM,N, and K, ordered according to I.RGB=VKM,ifI=0NVM,ifI=1MVK,ifI=2MNV,ifI=3KMV,ifI=4VMN,ifI=5Both the forward and backward conversions are realized in the well-known implementation [15].In this section the proposed algorithm is explained in detail. First, the overview of the problem is given, and then the solution is presented.The most challenging part of the integer-based algorithm is the computation of S and H while keeping the possibility to recover the originalR,G, and B. The S component, in the classical conversion, is computed as a ratio of delta (d) and V. The real-valued formula for H contains fractional partF=(mid(R,G,B)-min(R,G,B))/d. Both formulas require one division operation.The well-known technique to increase the accuracy of the integer division is to shift the dividend left by a certain number of bits. This improves accuracy but does not guarantee lossless backward conversion. Generalization of the problem gives a fractionx=⌊a/b⌋and recovering of numeratory=x·b, where all numbers are integers. In the integer division the remainder is discarded, therefore in generaly≠a.The analysis of ranges for all variables gives a clue to make a proper division and reconstruction formula. The range of d is[1,255]. The special cased=0is handled separately (step 4 of the classical forward conversion, see Section 4). V is equal tomax(R,G,B), therefored⩽V⩽255. Hence, assuming reduced fractions, there are19,820unique values ofS=d/V(the number was computed numerically). This is a theoretical count of all meaningful values of S that can be obtained from 24-bit RGB.In order to perform accurate integer-based conversions related to S, the following pair of equations is proposed:(1)S=d·216-1V=(d≪16)-1V(2)d=S·V216+1=((S·V)≫16)+1All the coefficients were found experimentally by the authors. For arbitrary d and V from given ranges, Eq. (1) produces equivalent results for integer values as the classical formulas for real values. One criteria for correctness is the amount of unique values. Eq. (1) produces19,820unique saturations (S) which is equal to the nominal evaluation (claimed earlier). Furthermore, Eq. (2) always recovers original d from given S and V. This is essential for lossless backward conversion.According to Eq. (1), the smallest value of S is 257 (ford=1andV=255). The largest value of S is65,535(ford=1andV=1), which is perfectly fit to 16 bits (2 bytes).The logic behind the computation of the fractional part of H is similar to that for saturation (S). The amount of unique values ofF=(c-m)/d, wherec=mid(R,G,B)andm=min(R,G,B), is19,821. The following equations related to F are proposed:(3)F=(c-m)≪16d+1(4)c=((F·d)≫16)+mEq. (3) produces the correct amount of unique F for the given ranges. The original c is recovered without errors by Eq. (4).The smallest integer-based value of F is 1 (forc=mandd=1). The largest value of F is65,537(forc-m=1andd=1). The hexagon edge length (E) is equal to largest F (E=65,537). Therefore, the maximum value of an integer-based H is6·E=393,222which requires 19 bits. Since one byte is a minimum addressable piece of data in the system, and there is usually no 24-bit data type in programming languages, it is reasonable to store H in a 32-bit integer variable. For half of the hexagon sectors (I=1,3,5), F must be inversed (F=E-F) in order to fit the classical color layout.Computation of V is straightforward. Since it is equal to the maximum of R, G, and B, the type can be changed to 8-bit integer without additional changes of the classical algorithm.In order to summarize this proposal, the following pseudo code listing represent the integer-based forward conversion algorithm (from RGB to HSV):1.Find the maximum (M), minimum (m) and middle (c) ofR,G, and B.M=max(R,G,B)m=min(R,G,B)c=mid(R,G,B)Assign V with M.V=MCalculate the delta (d) between M and m.d=M-mIf d is equal to 0 then assign S with 0 and return. H is undefined in this case.Determine sector index (I).I=0,ifM=Randm=B1,ifM=Gandm=B2,ifM=Gandm=R3,ifM=Bandm=R4,ifM=Bandm=G5,ifM=Randm=GCalculate integer-based saturation (S).S=(d≪16)-1VCalculate the fractional part of hue (F).F=(c-m)≪16d+1Inverse F for specific sectors (1, 3, and 5), by subtracting F from the edge length constant (E).ifI=1orI=3orI=5thenF=E-FCalculate the final integer-based hue (H).H=E·I+FThe pixel depth of resulting HSV color is 48 bits. V is stored in 8 bits (1 byte), S in 16 bits (2 bytes), and for the H component at least 19 bits are required, therefore in most systems 24 bits (3 bytes) must be reserved for H.The listing for the proposed backward conversion algorithm (from HSV to RGB) is the following:1.If S or V is equal to 0 then assign allR,G, and B with V and return.Calculate delta (d).d=((S·V)≫16)+1Calculate m, the minimal value ofR,G, and B.m=V-dDetermine the hue sector index (I) using the hexagon edge length constant (E).I=0,ifH<E1,ifH⩾EandH<2E2,ifH⩾2EandH<3E3,ifH⩾3EandH<4E4,ifH⩾4EandH<5E5,ifH⩾5ECalculate the fractional part of hue (F).F=H-E·ICalculate the middle component (c).c=((F·d)≫16)+mAssignR,G, and B according to the sector index (I).RGB=Vcm,ifI=0cVm,ifI=1mVc,ifI=2mcV,ifI=3cmV,ifI=4Vmc,ifI=5Note, that steps 1 and 5 in the forward algorithm can be merged for the sake of optimization, as well as steps 4 and 7 in the backward case. See a C++ implementation [21] as an example.In this section a comparative performance analysis of both algorithms is presented. The performance is estimated by counting the basic operations and theoretical CPU clock cycles they take to execute. The C++ implementations of the integer-based [21] and classical [15] algorithms are analyzed.In general, it is difficult to make a realistic estimation of algorithm performance when taking into account all varieties of platforms. Results may vary a lot if the algorithm is running on embedded system, FPGA, or desktop computer. However, it is possible to make rough assumptions according to optimization guide for modern (x86 family) CPUs [22]. Such rough analysis is presented in this section. It is not claimed to be full. There are many uncertain factors in CPU architecture like instruction pipelining, branch prediction (if-else statement) and compiler optimizations.The key factor for this analysis is the presence and characteristics of floating-point unit (FPU) in hardware. If floating-point operations are slow, then the use of the integer-based algorithm is obviously more beneficial. In modern processors the operations with floating-point variables are almost as fast as with integers. But, even on modern hardware, the integer operations are preferable in many cases.The number of operations for all algorithms is presented in Table 2. The last row shows the memory usage, i.e. how many bytes are required to execute certain algorithm for one color pixel. The proposed algorithm requires less memory than the classical one. 14 and 19 bytes less for forward and backward conversions respectively.All counting is done for the worst scenario, i.e. non-achromatic colors, deepest if-else nesting. Plus and minus operators are assumed to be equivalent.For the floating-point variables, the theoretical operation costs [22, p. 33] are the following: addition takes 3–6 clock cycles, multiplication 4–8 clock cycles, and division 14–45 clock cycles. Floating-point comparisons are inefficient when the floating-point stack registers are used.When dealing with the 24-bit RGB colors, the software that uses the real-valued algorithm cannot avoid performing lots of type castings between integer and float types. This can be very time consuming when taking into account the number of pixels and color components. Integer to float conversion takes 4–15 clock cycles [22, p. 41]. Typically, the conversion from float to integer takes no less than 50–100 clock cycles [22, p. 42]. The reason is that the C/C++ standard specifies truncation so the floating-point rounding mode has to be changed to truncation and back again.According to the optimization guide [22, p. 31], simple integer operations such as addition, subtraction, comparison, bit operations and shift operations are very fast. They take only one clock cycle on most microprocessors. Integer multiplication takes 3–4 clock cycles.The bottleneck of the proposed algorithm is the integer division operation which is very slow. It can take as many as 40–80 clock cycles [22, p. 31]. Other operations are relatively cheap and their amount does not differ much from the classical algorithm.The integer-based backward conversion is obviously faster than the floating-point based. It performs fewer multiplications. Integer multiplication is cheaper than the float one. In addition, the classical backward algorithm implementation contains the expensive float to int cast.Summarizing all the listed facts, the use of integer-based implementation may be theoretically beneficial even on x86 family processors. Slow integer divisions are compensated by eliminating the need of conversions between integer and float variables. Other operations, like comparisons and multiplications are faster to do with integers as well. These estimations are verified by practical tests in the next section.

@&#CONCLUSIONS@&#
While developing the proposed algorithm, the main requirement was to provide a lossless conversion from the 24-bit RGB to HSV without the use of floating-point variables. This significantly increases performance and portability. The known integer-based algorithms either introduce small errors or use lookup tables in order to compensate it. After analysis of the existing methods, the authors accepted the challenge to develop a better solution. The result is presented in this paper.The proposed algorithm is absolutely accurate. All the measured errors during the experiments were equal to 0. Lookup tables are not involved. There are no floating-point variables inside the conversion function, only integer and bit operations. As a result, about two times average performance gain, in comparison with the classical implementation, was achieved. The memory usage was minimized. The integer-based HSV color can be packed into 48 bits (6 bytes), which is less than 3 floats (3·32=96bits or 12 bytes).More significant performance gain is expected on embedded system, especially where floating-point math is not implemented in hardware. In future it is planned to port the proposed algorithm into different architectures including DSP and FPGA.