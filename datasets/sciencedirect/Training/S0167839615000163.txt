@&#MAIN-TITLE@&#
Analysis-suitable adaptive T-mesh refinement with linear complexity

@&#HIGHLIGHTS@&#
We present a new algorithm for the adaptive refinement of T-meshes.The algorithm preserves Analysis-Suitability and produces nested T-spline spaces.Any two generated meshes have an analysis-suitable overlay.We prove linear complexity of the refinement algorithm.

@&#KEYPHRASES@&#
Isogeometric analysis,T-splines,Analysis-suitability,Nestedness,Adaptive mesh refinement,

@&#ABSTRACT@&#
We present an efficient adaptive refinement procedure that preserves analysis-suitability of the T-mesh, that is, the linear independence of the T-spline blending functions. We prove analysis-suitability of the overlays and boundedness of their cardinalities, nestedness of the generated T-spline spaces, and linear computational complexity of the refinement procedure in terms of the number of marked and generated mesh elements.

@&#INTRODUCTION@&#
T-splines (Sederberg et al., 2003) have been introduced as a free-form geometric technology and are one of the most promising features in the Isogeometric Analysis (IGA) framework introduced by Hughes et al. (2005), Cottrell et al. (2009). At present, the main interest in IGA is in finding discrete function spaces that integrate well into CAD applications and, at the same time, can be used for Finite Element Analysis. Throughout the last years, hierarchical B-Splines (Scott et al., 2014; Kuru et al., 2014) and LR-Splines (Dokken et al., 2013; Johannessen et al., 2014) have arisen as alternative approaches to T-Splines for the establishment of an adaptive B-Spline technology. While none of these strategies has outperformed the other competing approaches until today, this paper aims to push forward and motivate the T-Spline technology.Since T-splines can be locally refined (Sederberg et al., 2004), they potentially link the powerful geometric concept of Non-Uniform Rational B-Splines (NURBS) to meshes with T-junctions (referred as “hanging nodes” in the Finite Element context) and, hence, the well-established framework of adaptive mesh refinement. However, Buffa et al. (2010) have shown that T-meshes can induce linear dependent T-spline blending functions. This prohibits the use of T-splines as a basis for analytical purposes such as solving a partial differential equation. In particular, the mesh refinement algorithm presented by Sederberg et al. (2004) does not preserve analysis-suitability in general. This insight motivated the research on T-meshes that guarantee the linear independence of the corresponding T-spline blending functions, referred to as analysis-suitable T-meshes. Analysis-suitability has been characterized in terms of topological mesh properties in 2d (Li et al., 2012) and, in an alternative approach, through the equivalent concept of Dual-Compatibility (da Veiga et al., 2012), which allows for generalization to three-dimensional meshes.A refinement procedure that preserves the analysis-suitability of two-dimensional T-meshes was finally presented by Scott et al. (2012). The procedure first refines the marked elements, producing a mesh that is not analysis-suitable in general, and then computes a refinement which is analysis-suitable and generates a T-spline space that is a superspace of the previous one. This second refinement involves heuristic local estimates on how much refinement is needed to achieve the desired properties. Hence, the reliable theoretical analysis of the algorithm is very difficult and so is the analysis of corresponding automatic mesh refinement algorithms driven by a posteriori error estimators. Such analysis is currently available only for triangular meshes (Carstensen et al., 2014; Cascon et al., 2008; Stevenson, 2007), but is necessary to reliably point out the advantages of adaptive mesh refinement.In this paper, we present a new refinement algorithm which provides1.the preservation of analysis-suitability and nestedness of the generated T-spline spaces,a bounded cardinality of the overlay (which is the coarsest common refinement of two meshes),linear computational complexity of the refinement procedure in the sense that there is a constant bound, depending only on the polynomial degree of the T-spline blending functions, on the ratio between the number of generated elements in the fine mesh and the number of marked elements in all refinement steps.This paper is organized as follows. We define the refinement algorithm along with a class of admissible meshes in Section 2. In Section 3, we prove that all admissible meshes are analysis-suitable. Section 4 proves essential properties of the overlay of two admissible meshes, and in Section 5 we prove nestedness of the T-spline spaces corresponding to admissible refinements. Section 6 shows linear complexity of the refinement procedure, and conclusions and an outlook to future work are finally given in Section 7. Sections 3, 4 and 6 independently rely on the definitions and results of Section 2, Section 5 also makes use of the definitions from Section 4.This section defines the new refinement algorithm and characterizes the class of meshes which is generated by this algorithm. The initial mesh is assumed to have a very simple structure. In the context of IGA, the partitioned rectangular domain is referred to as index domain. This is, we assume that the physical domain (on which, e.g., a PDE is to be solved) is obtained by a continuous map from the active region (cf. Section 3), which is a subset of the index domain. Throughout this paper, we focus on the mesh refinement only, and therefore we will only consider the index domain. For the parametrization and refinement of the T-spline blending functions, we refer to Scott et al. (2012).Definition 2.1Initial mesh, elementGiven positive numbersM,N∈N, the initial meshG0is a tensor product mesh consisting of closed squares (also denoted elements) with side length 1, i.e.,G0:={[m−1,m]×[n−1,n]|m∈{1,…,M},n∈{1,…,N}}.The domain partitioned byG0is denoted byΩ¯:=⋃G0.The key property of the refinement algorithm will be that refinement of an element K is allowed only if elements in a certain neighbourhood are sufficiently fine. The size of this neighbourhood, which is denoted(p,q)-patch and defined through the definitions below, depends on the size of K and the polynomial bi-degree(p,q)of the T-spline blending functions.Definition 2.2LevelThe level of an element K is defined byℓ(K):=−log2⁡|K|,where|K|denotes the volume of K. This implies that all elements of the initial mesh have level zero and that the bisection of an element K yields two elements of levelℓ(K)+1.Definition 2.3Vector-valued distanceGivenx∈Ω¯and an element K, we define their distance as the componentwise absolute value of the difference between x and the midpoint of K,Dist(K,x):=abs(mid(K)−x)∈R2.For two elementsK1,K2, we define the shorthand notationDist(K1,K2):=abs(mid(K1)−mid(K2)).Definition 2.4Given an element K and polynomial degrees p and q, the(p,q)-patch is defined byGp,q(K):={K′∈G|Dist(K′,K)≤Dp,q(ℓ(K))},whereDp,q(k)={2−k/2(⌊p2⌋+12,⌈q2⌉+12)ifkis even,2−(k+1)/2(⌈p2⌉+12,2⌊q2⌋+1)ifkis odd.Note as a technical detail that this definition does not require thatK∈G.RemarkIn a uniform even-leveled mesh,⋃Gp,q(K)is obtained by extending K by a face extension length (cf. Definition 3.4) above and below and by an edge extension length to the left and to the right (Fig. 1). In a uniform odd-leveled mesh,⋃Gp,q(K)is obtained by extending K by a face extension length to the left and to the right and by an edge extension length above and below. The(p,q)-patch will be used to enforce a local quasi-uniformity of the mesh. Throughout the rest of this paper, we assumep,q≥2. This guarantees that neighboring elements of K (elements that share an edge or vertex with K) are always inGp,q(K), and that nested elementsKˇ⊆Kˆhave nested(p,q)-patchesGp,q(Kˇ)⊆Gp,q(Kˆ).In the subsequent definitions, we will give a detailed description of the elementary bisection steps and then present the new refinement algorithm.Definition 2.5Bisection of an elementGiven an arbitrary elementK=[μ,μ+μ˜]×[ν,ν+ν˜], whereμ,ν,μ˜,ν˜∈Randμ˜,ν˜>0, we define the operatorsbisectx(K):={[μ,μ+μ˜2]×[ν,ν+ν˜],[μ+μ˜2,μ+μ˜]×[ν,ν+ν˜]}andbisecty(K):={[μ,μ+μ˜]×[ν,ν+ν˜2],[μ,μ+μ˜]×[ν+ν˜2,ν+ν˜]}.Note thatbisectxadds an edge in y-direction, whilebisectyadds an edge in x-direction.Given a meshGand an elementK∈G, we denote bybisect(G,K)the mesh that results from a level-dependent bisection of K,bisect(G,K):=G∖{K}∪child(K),withchild(K):={bisectx(K)ifℓ(K)is even,bisecty(K)ifℓ(K)is odd.We introduce the shorthand notationbisect(G,M)for the bisection of several elementsM={K1,…,KJ}⊆G, defined by successive bisections in an arbitrary order,bisect(G,M):=bisect(bisect(…bisect(G,K1),…),KJ).We will now define the new refinement algorithm through the bisection of a supersetclosGp,q(M)of the marked elementsM. In the remaining part of this section, we characterize the class of meshes generated by this refinement algorithm.Algorithm 2.8ClosureGiven a meshGand a set of marked elementsM⊆Gto be bisected, the closureclosGp,q(M)ofMis computed as follows.Algorithm 2.9RefinementGiven a meshGand a set of marked elementsM⊆Gto be bisected,refp,q(G,M)is defined byrefp,q(G,M):=bisect(G,closGp,q(M)).Figs. 2, 3 and 4illustrate three successive applications of Algorithm 2.9 withp=q=3. In each case, only one element K is marked. In the first case, the patch of K is as fine as K and hence no additional refinement is necessary. In the second case, one additional iteration of Algorithm 2.8 is needed to computeclosGp,q({K}). In the third case, the algorithm stops after three iterations.In the subsequent definitions, we introduce a class of admissible meshes. We will then prove that Algorithm 2.9 preserves admissibility.Definition 2.11(p,q)-admissible bisectionsGiven a meshGand an elementK∈G, the bisection of K is called(p,q)-admissible if allK′∈Gp,q(K)satisfyℓ(K′)≥ℓ(K).In the case of several elementsM={K1,…,KJ}⊆G, the bisectionbisect(G,M)is(p,q)-admissible if there is an order(σ(1),…,σ(J))(this is, if there is a permutation σ of{1,…,J}) such thatbisect(G,M)=bisect(bisect(…bisect(G,Kσ(1)),…),Kσ(J))is a concatenation of(p,q)-admissible bisections.A refinementGofG0is(p,q)-admissible if there is a sequence of meshesG1,…,GJ=Gand markingsMj⊆Gjforj=0,…,J−1, such thatGj+1=bisect(Gj,Mj)is a(p,q)-admissible bisection for allj=0,…,J−1. The set of all(p,q)-admissible meshes, which is the initial mesh and its(p,q)-admissible refinements, is denoted byAp,q. For the sake of legibility, we write ‘admissible’ instead of ‘(p,q)-admissible’ throughout the rest of this paper.This definition refers to the understanding of ‘admissible meshes’ in FE analysis. It does not match the definitions of admissible meshes from da Veiga et al. (2013), Li and Scott (2014).Proposition 2.13Any admissible meshGand any set of marked elementsM⊆Gsatisfyrefp,q(G,M)∈Ap,q.The proof of Proposition 2.13 given at the end of this section relies on the subsequent results.Lemma 2.14Local quasi-uniformityGivenK∈G∈Ap,q, anyK′∈Gp,q(K)satisfiesℓ(K′)≥ℓ(K)−1.Forℓ(K)=0, the assertion is always true. Forℓ(K)>0, consider the parentKˆof K (i.e., the unique elementKˆ∈⋃Ap,qwithK∈child(Kˆ)). Since K results from the bisection ofKˆ, we also have thatd(K):=Dist(K,Kˆ)={(2−(ℓ(Kˆ)+4)/2,0)ifℓ(Kˆ)is even(0,2−(ℓ(Kˆ)+3)/2)ifℓ(Kˆ)is odd={(0,2−(ℓ(K)+2)/2)ifℓ(K)even,(2−(ℓ(K)+3)/2,0)ifℓ(K)odd.SinceGis admissible, there are admissible meshesG0,…,GJ=Gand somej∈{0,…,J−1}such thatK∈Gj+1=bisect(Gj,{Kˆ}). The admissibilityGj+1∈Ap,qimplies that anyK′∈Gjp,q(Kˆ)satisfiesℓ(K′)≥ℓ(Kˆ)=ℓ(K)−1. Since levels do not decrease during refinement, we get(1)ℓ(K)−1≤min⁡{ℓ(K′)|K′∈GjandDist(Kˆ,K′)≤Dp,q(ℓ(Kˆ))}≤min⁡{ℓ(K′)|K′∈GandDist(Kˆ,K′)≤Dp,q(ℓ(Kˆ))}=min⁡{ℓ(K′)|K′∈GandDist(Kˆ,K′)≤Dp,q(ℓ(K)−1)}≤min⁡{ℓ(K′)|K′∈GandDist(K,K′)+d(K)≤Dp,q(ℓ(K)−1)}.One easily computesDp,q(ℓ(K)−1)−d(K)>Dp,q(ℓ(K)), which concludes the proof.  □Corollary 2.15LetK∈G∈Ap,qandU¯p,q(K):={x∈Ω¯|Dist(K,x)≤Dp,q(ℓ(K))},thenGp,q(K)={K′∈G||K′∩U¯p,q(K)|>0}.This is a consequence of Lemma 2.14 in the strong version (1) that involves a bigger patch of K.  □Proof of Proposition 2.13Given the meshG∈Ap,qand marked elementsM⊆Gto be bisected, we have to show that there is a sequence of meshes that are subsequent admissible bisections, withGbeing the first andrefp,q(G,M)the last mesh in that sequence. SetM∼:=closGp,q(M)and(2)L¯:=max⁡ℓ(M∼),L̲:=min⁡ℓ(M∼)Mj:={K∈M∼|ℓ(K)=j}forj=L̲,…,L¯GL̲:=G,Gj+1:=bisect(Gj,Mj)forj=L̲,…,L¯.It follows thatrefp,q(G,M)=GL¯+1. We will show by induction over j that all bisections in (2) are admissible.For the first stepj=L̲, we know{K′∈M∼|ℓ(K′)<L̲}=∅, and by construction ofM∼that for eachK∈M∼L̲holds{K′∈Gp,q(K)|ℓ(K′)<ℓ(K)}⊆M∼. Together withℓ(K)=L̲follows for anyK∈M∼L̲that there is noK′∈Gp,q(K)withℓ(K′)<ℓ(K). This is, the bisections of allK∈M∼L̲are admissible independently of their order and hencebisect(GL̲,M∼L̲)is admissible.Consider an arbitrary stepj∈{L̲,…,L¯}and assume thatGL̲,…,Gjare admissible meshes. Assume for contradiction that there isK∈Mjof which the bisection is not admissible, i.e., there existsK′∈Gjp,q(K)withℓ(K′)<ℓ(K)and consequentlyK′∉M∼, becauseK′has not been bisected yet. It follows from the closure Algorithm 2.8 thatK′∉G. Hence, there isKˆ∈Gsuch thatK′⊂Kˆ. We haveℓ(Kˆ)<ℓ(K′)<ℓ(K), which impliesℓ(Kˆ)<ℓ(K)−1. Note thatK∈GbecauseMj⊆M∼⊆G. Moreover, fromK′⊂KˆandK′∈Gjp,q(K)it follows with Corollary 2.15 thatKˆ∈Gp,q(K). Together withℓ(Kˆ)<ℓ(K)−1, Lemma 2.14 implies thatGis not admissible, which contradicts the assumption.  □In this section, we give a brief review on the concept of Analysis-Suitability, using the notation from da Veiga et al. (2013). We prove that all admissible meshes (in the sense of Definition 2.12) are analysis-suitable and hence provide linearly independent T-spline blending functions. In this paper, we omit the definition of the T-spline blending functions and details on their linear independence. We refer the reader to Li et al. (2012), da Veiga et al. (2012) and, in particular for the case of non-cubic T-splines (da Veiga et al., 2013).Definition 3.1Active nodesConsider an admissible meshG∈Ap,q. The set of vertices (nodes) ofGis denoted byN. We define the active regionAR:=[⌈p2⌉,M−⌈p2⌉]×[⌈q2⌉,N−⌈q2⌉]and the set of active nodesNA:=N∩AR.To each active node T, we associate local index vectorsx(T)andy(T)that are defined below, depending on the mesh in the neighbourhood of T. These local index vectors are used to construct a tensor-product B-splineBT, referred to as T-spline blending function.Definition 3.2SkeletonWe denote by hSk (resp. vSk) the horizontal (resp. vertical) skeleton, which is the union of all horizontal (resp. vertical) edges. Note thathSk∩vSk=N.Definition 3.3Global index setsFor any y in the closed interval[⌈q2⌉,N−⌈q2⌉], we setX(y):={z∈[0,M]|(z,y)∈vSk},and for anyx∈[⌈p2⌉,M−⌈p2⌉],Y(x):={z∈[0,N]|(x,z)∈hSk}.Note that in an admissible mesh, the entries{0,…,⌈p2⌉−1,M−⌈p2⌉+1,…,M}are always included inX(y)(and analogously forY(x)).(See da Veiga et al., 2013, Section 2.1.) We denote byT⊂NAthe set of all active nodes with valence three (i.e., active nodes that are endpoints of exactly three edges) and refer to them as T-junctions. Following the literature (Li et al., 2012; da Veiga et al., 2012), we adopt the notation ⊥, ⊤, ⊢, ⊣ to indicate the four possible orientations of the T-junctions. T-junctions of type ⊣ and ⊢ (⊥, ⊤, respectively) and their extensions are called horizontal (vertical, resp.). For the sake of simplicity, let us consider a T-junctionT=(t1,t2)∈Tof type ⊣. Clearly,t1is one of the entries ofX(t2). We extract fromX(t2)thep+1consecutive indicesi−⌊p/2⌋,…,i⌈p/2⌉such thati0=t1. We denoteextep,q(T):=[i−⌊p/2⌋,i0]×{t2},extfp,q(T):=]i0,i⌈p/2⌉]×{t2},extp,q(T):=extfp,q(T)∪extep,q(T),whereextep,q(T)is denoted edge-extension,extfp,q(T)is denoted face-extension andextp,q(T)is just the extension of the T-junction T.(See da Veiga et al., 2013, Definition 2.5.) A mesh is analysis-suitable if horizontal T-junction extensions do not intersect vertical T-junction extensions.The main result of this section is the following theorem.Theorem 3.6All admissible meshes (in the sense ofDefinition 2.12) are analysis-suitable.We prove the theorem by induction over admissible bisections. We know that the initial meshG0is analysis-suitable because it is a tensor-product mesh without any T-junctions. Consider a sequenceG0,…,GJof successive admissible bisections such thatG0,…,GJ−1are analysis-suitable. Without loss of generality we shall assume that elements are refined in ascending order with respect to their level, i.e., forGj+1=bisect(Gj,Kj), we assume that0=ℓ(K0)≤…≤ℓ(KJ−1). There is such a sequence for any admissible mesh; see the proof of Proposition 4.3. We have to show thatGJis analysis-suitable as well.We denoteK:=KJ−1=[μ,μ+μ˜]×[ν,ν+ν˜]∈GJ−1, and we assume without loss of generality thatℓ(K)is even. The assumption that elements are refined in ascending order with respect to their level implies that no element finer than K has been bisected yet, i.e.,(3)max⁡ℓ(GJ)=ℓ(K)+1.Denote by(4)Gu|k:={K′∈⋃Ap,q|ℓ(K′)=k}∈Ap,qthe k-th uniform refinement ofG0. ThenGu|ℓ(K)+1is a refinement ofGJ, in particular(5)hSk(GJ)⊆hSk(Gu|ℓ(K)+1)=hSk(Gu|ℓ(K)),sinceℓ(K)is even. SinceGJis admissible, all elements inGJp,q(K)are at least of levelℓ(K)and hence(6)hSk(GJ)∩U¯p,q(K)⊇hSk(Gu|ℓ(K))∩U¯p,q(K),and(7)∀K˜∈GJp,q(K):size(ℓ(K˜))≤size(ℓ(K))with the level-dependent size(8)size(ℓ(K)):=(μ˜,ν˜)={(2−ℓ(K)/2,2−ℓ(K)/2)ifℓ(K)even,(2−(ℓ(K)+1)/2,2−(ℓ(K)−1)/2)ifℓ(K)odd.Together, (5) and (6) read(9)hSk(GJ)∩U¯p,q(K)=hSk(Gu|ℓ(K))∩U¯p,q(K).Consider a T-junctionT∈TJ∖TJ−1that is generated by the bisection of K. Then T is a vertical T-junction on the boundary of K, and with (7) followsextp,q(T)⊆{μ+μ˜/2}×[ν−2−ℓ(K)/2⌈q2⌉,ν+ν˜+2−ℓ(K)/2⌈q2⌉].Consider an arbitrary horizontal T-junctionT˜=(t1,t2)∈T. We will prove thatextp,q(T˜)does not intersectextp,q(T). From (5) we conclude thatextp,q(T˜)⊆hSk(Gu|ℓ(K)), and (9) implies that the vertexT˜is not in the interior of the(p,q)-patch of K and not on its top or bottom boundary, i.e.T˜∉]μ−2−ℓ(K)/2⌊p2⌋,μ+μ˜+2−ℓ(K)/2⌊p2⌋[×[ν−2−ℓ(K)/2⌈q2⌉,ν+ν˜+2−ℓ(K)/2⌈q2⌉].See Fig. 5for a sketch. Assume without loss of generality thatT˜is on the left side of K, this is,(10)t1≤μ−2−ℓ(K)/2⌊p2⌋.Iftype(T˜)=⊢, then the edge-extensionextep,q(T˜)points towards K in the sense that∀(x,t2)∈extp,q(T˜):x−t1≤2−ℓ(K)/2⌊p2⌋≤(10)μ−t1⇔∀(x,t2)∈extp,q(T˜):x≤μ<μ+μ˜/2.This means thatextp,q(T˜)does not intersectextp,q(T). See Fig. 6for an illustration.Iftype(T˜)=⊣, then there is an odd-level elementK′on the right side ofT˜, and two finer even-level elements on the left side. Since there are no elements inGJwith a level higher thanℓ(K)+1, which is odd, the two elements on the left side ofT˜have at most levelℓ(K), and henceℓ(K′)≤ℓ(K)−1. Consequently,K′∉GJp,q(K), and the length of the intersection of the face extensionextfp,q(T˜)with the(p,q)-patch of K is at most2−ℓ(K)/2(⌈p2⌉−1)≤2−ℓ(K)/2⌊p2⌋. This leads to the same result as the previous case and is illustrated in Fig. 6. SinceT˜was chosen arbitrary,GJis analysis-suitable. This concludes the proof.  □Corollary 3.7All admissible meshes provide T-spline blending functions that are non-negative, linearly independent, and form a partition of unity (da Veiga et al., 2013, 2014). Moreover, on each elementK∈G∈Ap,q, there are not more than2(p+1)(q+1)T-spline basis functions that have support on K (da Veiga et al., 2014, Proposition 7.6).This means that on each element, each T-Spline function communicates only with a finite number of other T-spline functions, independent of the total number of functions. This is an important requirement for sparsity of the linear system to be solved in Finite Element Analysis, in the sense that every row and every column of a corresponding stiffness or mass matrix is a sparse vector.This section discusses the coarsest common refinement of two meshesG1,G2∈Ap,q, called overlay and denoted byG1⊗G2. We prove that the overlay of two admissible meshes is also admissible and has bounded cardinality in terms of the involved meshes. This is a classical result in the context of adaptive simplicial meshes and will be crucial for further analysis of adaptive algorithms (cf. Assumption (2.10) from Carstensen et al., 2014).Definition 4.1OverlayWe define the operatorMin⊆which yields all minimal elements of a set that is partially ordered by “⊆”,Min⊆(M):={K∈M|∀K′∈M:K′⊆K⇒K′=K}.The overlay ofG1,G2∈Ap,qis defined byG1⊗G2:=Min⊆(G1∪G2).Proposition 4.2G1⊗G2is the coarsest refinement ofG1andG2in the sense that for anyGˆbeing a refinement ofG1andG2, andG1⊗G2being a refinement ofGˆ, it follows thatGˆ=G1⊗G2.ProofG1is a refinement ofG2if and only if for eachK1∈G1, there isK2∈G2withK1⊆K2, which is equivalent toG1=G1⊗G2. Given thatG1⊗Gˆ=Gˆ=G2⊗GˆandG1⊗G2=(G1⊗G2)⊗Gˆ, we haveG1⊗G2=(G1⊗G2)⊗Gˆ=Min⊆(G1⊗G2∪Gˆ)=Min⊆(Min⊆(G1∪G2)∪Gˆ)=Min⊆(G1∪G2∪Gˆ)=Min⊆(G1∪Min⊆(G2∪Gˆ))=Min⊆(G1∪G2⊗Gˆ)=Min⊆(G1∪Gˆ)=G1⊗Gˆ=Gˆ.□Proposition 4.3For any admissible meshesG1,G2∈Ap,q, the overlayG1⊗G2is also admissible.ProofConsider the set of admissible elements which are coarser than elements of the overlay,M:={K∈⋃Ap,q|∃K′∈G1⊗G2:K′⫋K}.ThenG1⊗G2is the coarsest partition ofΩ¯into elements from⋃Ap,qthat refines all elements occurring inM. Note also thatMsatisfies(11)∀K,K′∈⋃Ap,q:K∈M∧K⊆K′⇒K′∈M.Forj=0,…,J=max⁡ℓ(M)andG¯0:=G0, set(12)Mj:={K∈M|ℓ(K)=j}andG¯j+1:=bisect(G¯j,Mj).Claim 1For allj∈{0,…,J}holdsMj⊆G¯j.This is shown by induction over j. Forj=0, the claim is true because all admissible elements with zero level are inG0. Assume the claim to be true for0,…,j−1and assume for contradiction that there existsK∈Mj∖G¯j.Since K has not been bisected yet,G¯jdoes not contain anyK′withK′⊂K. Consequently, there existsK′∈G¯jwithK⊂K′and henceℓ(K′)<ℓ(K)=j. From (11) followsK′∈Mℓ(K′)∈M, andℓ(K′)<jimplies thatK′has been refined in a previous step. This yieldsK′∉G¯j, which is the desired contradiction.Claim 2For allj∈{0,…,J}, the bisection(12)is admissible.ConsiderK∈Mjfor an arbitrary j. By definition ofM, there existsK′∈G1⊗G2⊆G1∪G2withK′⫋K. Without loss of generality, we assumeK′∈G1. SinceG1∈Ap,q, there is a sequence of admissible meshesG0=G1|0,G1|1,…,G1|I=G1andi∈{0,…,I−1}such thatG1|i+1=bisect(G1|i,{K}). The fact thatG1|i+1∈Ap,q(and that levels do not decrease during refinement) implies(13)min⁡ℓ(G1p,q(K))≥min⁡ℓ(G1|ip,q(K))≥ℓ(K)=j.Assume for contradiction that there isK˜∈Gjp,q(K)withℓ(K˜)<ℓ(K)=j. This impliesK˜∉M(otherwiseK˜would have been bisected in a previous step). Moreover, (13) and Corollary 2.15 yield that there isK˜′∈G1p,q(K)withK˜′⊂K˜and henceK˜∈Min contradiction toK˜∉Mfrom before. This proves Claim 2.The proven claims showMj=G¯j∖G¯j+1for allj=0,…,Jand hence for the admissible meshG¯J+1that there is no coarser partition ofΩ¯into elements from⋃Ap,qthat refines all elements inM. This property defines a unique partition and henceG1⊗G2=G¯J+1∈Ap,q.□Lemma 4.4For allG1,G2∈Ap,qholds#(G1⊗G2)+#G0≤#G1+#G2.By definition, the overlay is a subset of the union of the two involved meshes, i.e.,(14)G1⊗G2=Min⊆(G1∪G2)⊆G1∪G2.Define the shorthand notationG(K):={K′∈G|K′⊆K}. To prove the lemma, it suffices to show∀K∈G0,#(G1⊗G2)(K)+1≤#G1(K)+#G2(K).Case 1.G1(K)⊆(G1⊗G2)(K). This implies equality and hence#(G1⊗G2)(K)+1=#G1(K)+1≤#G1(K)+#G2(K).Case 2. There existsK′∈G1(K)∖(G1⊗G2)(K). Then(G1⊗G2)(K)=(G1⊗G2)(K)∖{K′}and hence#(G1⊗G2)(K)=#((G1⊗G2)(K)∖{K′})≤(14)#((G1∪G2)(K)∖{K′})≤#(G1∖{K})+#G2(K)=#G1(K)−1+#G2(K).□This section investigates the nesting behavior of the T-spline spaces corresponding to admissible meshes. In order to prove that nested admissible meshes induce nested spline spaces, we make use of Theorem 6.1 from Li and Scott (2014). Before presenting the theorem, we briefly introduce necessary notations.Definition 5.1Refinement relationFor any partitionsG1,G2ofΩ¯, we introduce the refinement relation “⪯”, which is defined using the overlay (see Section 4),G1⪯G2⇔G1⊗G2=G2.Corollary 5.2Denote the skeleton of a meshGbySk(G):=hSk(G)∪vSk(G). Then for rectangular partitionsG1,G2ofΩ¯holds the equivalenceG1⪯G2⇔Sk(G1)⊆Sk(G2).Definition 5.3Extended meshGiven a rectangular partitionGofΩ¯, denote byextp,q(G)the union of all T-junction extensions in the meshG. Then the extended meshGextis defined as the unique rectangular partition ofΩ¯such thatSk(Gext)=Sk(G)∪extp,q(G).Definition 5.4Mesh perturbationGiven a partitionGofΩ¯into axis-aligned rectangles, we define byPtb(G)the set of all continuous and invertible mappingsδ:Ω¯→Ω¯such that the corners(0,0),(M,0),(M,N),(0,N)are fixed points of δ andδ(G)={δ(K)|K∈G}is also a partition ofΩ¯into axis-aligned rectangles.This definition differs from the definition of perturbations given in Li and Scott (2014), which we found difficult to reproduce in a formal manner. The subsequent Proposition 5.5 shows that our definition includes the understanding of perturbations from Li and Scott (2014).RemarkForδ∈Ptb(G), the perturbed meshδ(G)has the skeletonSk(δ(G))=δ(Sk(G)). Hence, global index vectors can be defined according to Definition 3.3, and since all T-junctions inδ(G)are of axis-parallel types (⊢,⊥,⊣, or ⊤), we can also apply Definition 3.4 for T-junction extensions in the perturbed mesh. Note in particular that the perturbation δ does not in general map T-junction extensions to the corresponding extensions in the perturbed mesh, i.e., if T is a T-junction inG, thenextδ(G)p,q(δ(T))≠δ(extGp,q(T)).Proposition 5.5For any rectangular partitionGofΩ¯, there is someδ⁎∈Ptb(G)such that any two T-junction face extensions inδ⁎(G)are disjoint.In the context of Li and Scott (2014), this means thatδ⁎(G)has no crossing vertices and no overlap vertices.ProofIf all T-junction extensions inGare pairwise disjoint, thenδ⁎is the identity map. If there exist T-junctionsT1,T2inGwith intersecting face extensions, thenT1andT2are either both vertical or both horizontal T-junctions. Assume w.l.o.g. thatT1andT2are vertical T-junctions. Since their (vertical) face extensions overlap, both T-junctions have the same x-coordinatet0. LetT1=(t0,t1)andT2=(t0,t2), and assumet1<t2. There existst1.5witht1≤t1.5≤t2such that at least one of the open segments{t0}×(t1,t1.5)and{t0}×(t1.5,t2)does not intersect with the vertical skeletonvSk(G). Assume that{t0}×(t1,t1.5)∩vSk(G)=∅and defineΩ¯x=t0:={(x,y)∈Ω¯|x=t0}andGx=t0:={K∈G|K∩Ω¯x=t0≠∅}.Let h be the length of the shortest edge inG, and setε:=h/2. We defineδT1T2byδT1T2(x,y)={(x,y)if(x,y)∈⋃(G∖Gx=t0)(x−ε,y)ifx=t0andy<t1(x+ε,y)ifx=t0andy>t1.5(x+ε(2y−t1−t1.5)t1.5−t1,y)ifx=t0andt1≤y≤t1.5and elsewhere by horizontal linear interpolation, which is illustrated in Fig. 7. The mapδT1T2then satisfies the following properties.1.δT1T2is inPtb(G).The T-junction extensions ofδT1T2(T1)andδT1T2(T2)do not intersect.δT1T2does not lead to intersecting of T-junction extensions that did not intersect in the unperturbed meshG.Theorem 5.6(SeeLi and Scott, 2014, Theorem 6.1.) Given two analysis-suitable meshesG1andG2, if for allδ∈Ptb(G2)holds(δ(G1))ext⪯(δ(G2))ext,then the T-spline spaces corresponding toG1andG2are nested.The main result of this section is the following.Theorem 5.7Any two meshesG1,G2∈Ap,qthat are nested in the senseG1⪯G2satisfy for allδ∈Ptb(G2)(δ(G1))ext⪯(δ(G2))ext.ProofAccording to Corollary 5.2, we have to show thatextp,q(δ(G1))∪Sk(δ(G1))⊆extp,q(δ(G2))∪Sk(δ(G2)).We prove this forG2being an admissible bisection ofG1. The claim then follows inductively for all admissible refinements ofG1. LetK∈G1∈Ap,qandG2:=bisect(G1,K)∈Ap,q. Since “⪯” denotes an elementwise subset relation, it is preserved under the mapping δ. Thus, fromG1⪯G2followsδ(G1)⪯δ(G2)and consequentlySk(δ(G1))⊆Sk(δ(G2)). It remains to prove thatextp,q(δ(G1))⊆extp,q(δ(G2))∪Sk(δ(G2)).Denote byT1andT2the set of T-junctions inG1andG2, respectively. Assume w.l.o.g. thatℓ(K)is even, and consider an arbitrary T-junctionTδin the meshδ(G1). Since δ is continuous and invertible, there is a one-to-one correspondence between the T-junctions inG1andδ(G1), i.e., there isT∈T1withδ(T)=Tδ, and T andTδare of the same type (⊢, ⊥, ⊣, or ⊤).Case 1.T∉K. Then T is still a T-junction after bisecting K, i.e.,T∈T2. Consequently,Tδis also a T-junction inδ(G2).Case 1a. T is a vertical T-junction. Sinceℓ(K)is assumed to be even, its bisection does not affect the horizontal skeleton, i.e.,hSk(G1)=hSk(G2)and hencehSk(δ(G1))=hSk(δ(G2)). Consequently, the T-junction extensions of T andTδare preserved,extG1p,q(T)=extG2p,q(T)andextδ(G1)p,q(Tδ)=extδ(G2)p,q(Tδ)⊆extp,q(δ(G2)).Case 1b. T is a horizontal T-junction. We will show that the corresponding T-junction extension in the perturbed mesh is preserved, i.e.,extδ(G1)p,q(Tδ)=extδ(G2)p,q(Tδ).Assume for contradiction thatextδ(G1)p,q(Tδ)≠extδ(G2)p,q(Tδ). The bisection of K generates a vertical edgeEK⊇vSk(G2)∖vSk(G1), and we denoteEKδ:=δ(EK)⊇vSk(δ(G2))∖vSk(δ(G1)).Obviously,EKδintersects withextδ(G1)p,q(Tδ), otherwise the T-junction extension would be the same inδ(G2). GivenK=[μ,μ+μ˜]×[ν,ν+ν˜], we define the half-open domainKho:=]μ,μ+μ˜[×[ν,ν+ν˜], which is the rectangle K without its vertical edges. ThenEK⊂Khoand henceEKδ⊂Khoδ:=δ(Kho). Together, we have thatextδ(G1)p,q(Tδ)intersects withKhoδ. Since the bisection of K is admissible, we know from the proof of Theorem 3.6 thatextG1p,q(T)does not intersect withKhoin the unperturbed meshG1. Define the T-environmentU¯(T):=⋃K′∈G1Kho′∩extp,q(T)≠∅K′,as the union of allK′∈G1such thatextp,q(T)intersects the corresponding half-openKho′. ThenU¯(T)is a rectangular domain that does not intersect withKho. Since for eachK′⊆U¯(T), the imageδ(K′)is a rectangle and since δ is continuous,δ(U¯(T))is a rectangular domain that does not intersect withKhoδ. Moreover, since all edges and vertices inU¯(T)are continuously mapped intoδ(U¯(T)), we haveU¯(Tδ)⊆δ(U¯(T)). Together, we get thatU¯(Tδ)does not intersect withKhoδ, henceextδ(G1)p,q(Tδ)does not intersect withKhoδ, which is the desired contradiction.Case 2.T∈K. In Section 2, we assumed thatp,q≥2. This implies that all neighbors of K are inG1p,q(K)and that K is in the patch of all those neighbors as well. SinceG1is admissible, the level of a neighbor of K is eitherℓ(K)orℓ(K)+1. Sinceℓ(K)is even, T must be a vertical T-junction, andTδis a vertical T-junction as well. Since T is on the boundary of K, and the bisection of K generates a vertical edge, T is not a T-junction anymore inG2. HenceTδis a vertex, but not a T-junction inδ(G2). The T-junction extensionextp,q(Tδ)hence only exists inδ(G1). Consider the edge extension ofTδ.Case 2a.extep,q(Tδ)⊆vSk(δ(G2)). There is no problem with that.Case 2b.extep,q(Tδ)⊈vSk(δ(G2)). Then there exists someT˜δ∈extep,q(Tδ)which is a T-junction inδ(G2), such thatextep,q(Tδ)⊂extδ(G2)p,q(T˜δ)⊆extp,q(δ(G2)).Cases 2a and 2b hold analogously for the face extensionextfp,q(Tδ). Together, we haveextp,q(Tδ)⊆extp,q(δ(G2))∪vSk(δ(G2)),which concludes the proof.  □The combination of Theorems 5.6 and 5.7 reads as follows.Corollary 5.8For any two meshesG1,G2∈Ap,qthat are nested in the senseG1⪯G2, the corresponding T-spline spaces are also nested.This section is devoted to a complexity estimate in the style of a famous estimate for the Newest Vertex Bisection on triangular meshes given by Binev et al. (2004) and, in an alternative version, by Stevenson (2007). The estimate reads as follows.Theorem 6.1Any sequence of admissible meshesG0,G1,…,GJwithGj=refp,q(Gj−1,Mj−1),Mj−1⊆Gj−1forj∈{1,…,J}satisfies|GJ∖G0|≤Cp,q∑j=0J−1|Mj|,withCp,q=(3+2)(4dp+1)(4dq+2)anddp,dqfromLemma 6.4below.Theorem 6.1 shows that, with regard to possible mesh gradings, the refinement algorithm is as flexible as successive bisection without the closure step. However, this result is non-trivial. Given a meshG∈Ap,qand an elementK∈Gto be bisected, there is no uniform bound on the number of generated elements#(refp,q(G,{K})∖G). This is illustrated by the following example.Consider the casep=q=2and the initial meshG0given throughM=3andN=4. Mark the element in the lower left corner of the mesh and compute the corresponding refinementG1; repeat this step k times. Then there exists an elementKkinGksuch that#(ref1,1(Gk,Kk)∖Gk)≥k. This is illustrated in Fig. 8.Example 6.3The large constantCp,qis not observed in practice. Forp=q=3, we constructed for eachJ∈{1,…,2000}a sequenceG0,G1,…,GJwithGj+1=bisect(Gj,Kj)andKj∈Gjof uniform random choice. The ratio|GJ|/Jwas below 6 (see Fig. 9), instead of the theoretical upper boundC3,3≈6042from Theorem 6.1. We applied this procedure forp,q=2,…,9. The results are listed in Fig. 10. In Fig. 11, we listed similar results forJ∈{1,…,100}, always marking the element in the lower left corner. In that case, the observed ratios are higher, but still orders of magnitude below the corresponding theoretical bounds.We devote the rest of this section to proving Theorem 6.1.Lemma 6.4GivenM⊆G∈Ap,qandK∈refp,q(G,M)∖G, there existsK′∈Msuch thatℓ(K)≤ℓ(K′)+1andDist(K,K′)≤2−ℓ(K)/2(dp,dq),with “≤” understood componentwise and constantsdp:=(1+2−1/2)p+1+542,dq:=(1+2)q+32+2.The coefficientDp,q(k)from Definition 2.4 is bounded byDp,q(k)≤((p+2)2−1−k/2,(q+2)2−(k+1)/2)for allk∈N.Hence forK˜∈G∈Ap,q, anyK˜′∈Gp,q(K˜)satisfies(15)Dist(K˜,K˜′)≤2−ℓ(K˜)/2(p+22,q2+1).The existence ofK∈refp,q(G,M)∖Gmeans that Algorithm 2.9 bisectsK′=KJ,KJ−1,…,K0such thatKj−1∈Gp,q(Kj)andℓ(Kj−1)<ℓ(Kj)forj=J,…,1, havingK′∈MandK∈child(K0), with ‘child’ from Definition 2.6. Lemma 2.14 yieldsℓ(Kj−1)=ℓ(Kj)−1forj=J,…,1, which allows for the estimateDist(K′,K0)≤∑j=1JDist(Kj,Kj−1)≤(15)∑j=1J2−ℓ(Kj)/2(p+22,q2+1)=∑j=1J2−(ℓ(K0)+j)/2(p+22,q2+1)<2−ℓ(K0)/2(p+22,q2+1)∑j=1∞2−j/2=(1+2)2−ℓ(K0)/2(p+22,q2+1)=(2+2)2−ℓ(K)/2(p+22,q2+1).The estimateDist(K0,K)≤2−2−ℓ(K0)/2(1,2)and a triangle inequality conclude the proof.  □Proof of Theorem 6.1(1) ForK∈⋃Ap,qandK˜∈M:=M0∪⋯∪MJ−1, defineλ(K,K˜)byλ(K,K˜):={2(ℓ(K)−ℓ(K˜))/2ifℓ(K)≤ℓ(K˜)+1andDist(K,K˜)≤21−ℓ(K)/2(dp,dq),0otherwise.(2)Main idea of the proof.|GJ∖G0|=∑K∈GJ∖G01≤(4)∑K∈GJ∖G0∑K˜∈Mλ(K,K˜)≤(3)∑K˜∈MCp,q=Cp,q∑j=0J−1|Mj|.(3)For allj∈{0,…,J−1}andK˜∈Mjholds∑K∈GJ∖G0λ(K,K˜)≤(3+2)(4dp+1)(4dq+2)=Cp,q.This is shown as follows. By definition of λ, we have∑K∈GJ∖G0λ(K,K˜)≤∑K∈⋃Ap,q∖G0λ(K,K˜)=∑j=1ℓ(K˜)+12(j−ℓ(K˜))/2#{K∈⋃Ap,q|ℓ(K)=jandDist(K,K˜)≤21−j/2(dp,dq)}︸B.Since we know by definition of the level thatℓ(K)=jimplies|K|=2−j, we know that2j|⋃B|is an upper bound of #B. The rectangular set⋃Bis the union of all admissible elements of level j having their midpoints inside a rectangle of size22−j/2dp×22−j/2dq.An admissible element of level j is not bigger than2−j/2×2(1−j)/2. Together, we have|⋃B|≤2−j(4dp+1)(4dq+2),and hence#B≤(4dp+1)(4dq+2). The claim is shown with∑j=1ℓ(K˜)+12(j−ℓ(K˜))/2=∑j=1−ℓ(K˜)12j/2<2+∑j=0∞2−j/2=22−12−1=3+2.(4)EachK∈GJ∖G0satisfies∑K˜∈Mλ(K,K˜)≥1.ConsiderK∈GJ∖G0. Setj1<Jsuch thatK∈Gj1+1∖Gj1. Lemma 6.4 states the existence ofK1∈Mj1withDist(K,K1)≤2−ℓ(K)/2(dp,dq)andℓ(K)≤ℓ(K1)+1. Henceλ(K,K1)=2ℓ(K)−ℓ(K1)>0. The repeated use of Lemma 6.4 yieldsj1>j2>j3>…andK2,K3,…withKi−1∈Gji+1∖GjiandKi∈Mjisuch that(16)Dist(Ki−1,Ki)≤2−ℓ(Ki−1)/2(dp,dq)andℓ(Ki−1)≤ℓ(Ki)+1.We repeat applying Lemma 6.4 asλ(K,Ki)>0andℓ(Ki)>0, and we stop at the first index L withλ(K,KL)=0orℓ(KL)=0. Ifℓ(KL)=0andλ(K,KL)>0, then∑K˜∈Mλ(K,K˜)≥λ(K,KL)=2(ℓ(K)−ℓ(KL))/2≥2.Ifλ(K,KL)=0becauseℓ(K)>ℓ(KL)+1, then (16) yieldsℓ(KL−1)≤ℓ(KL)+1<ℓ(K)and hence∑K˜∈Mλ(K,K˜)≥λ(K,KL−1)=2(ℓ(K)−ℓ(KL−1))/2≥2.Ifλ(K,KL)=0becauseDist(K,KL)>21−ℓ(K)/2(dp,dq), then a triangle inequality shows21−ℓ(K)/2(dp,dq)<Dist(K,K1)+∑i=1L−1Dist(Ki,Ki+1)≤2−ℓ(K)/2(dp,dq)+∑i=1L−12−ℓ(Ki)/2(dp,dq),and hence2−ℓ(K)/2≤∑i=1L−12−ℓ(Ki)/2. The proof is concluded with1≤∑i=1L−12(ℓ(K)−ℓ(Ki))/2=∑i=1L−1λ(K,Ki)≤∑K˜∈Mλ(K,K˜).□

@&#CONCLUSIONS@&#
