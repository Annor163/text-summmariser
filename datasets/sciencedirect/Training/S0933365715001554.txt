@&#MAIN-TITLE@&#
User-defined functions in the Arden Syntax: An extension proposal

@&#HIGHLIGHTS@&#
We studied the rationale behind the Arden Syntax concepts related to functions.We confronted the Arden Syntax model with some functional programming models.We propose an extension that allows an author to safely define and use functions.We give examples of possible Arden Syntax constructs augmented with functions.

@&#KEYPHRASES@&#
Programming languages,Artificial intelligence,Expert systems,Medical informatics,Clinical decision support systems,

@&#ABSTRACT@&#
BackgroundThe Arden Syntax is a knowledge-encoding standard, started in 1989, and now in its 10th revision, maintained by the health level seven (HL7) organization. It has constructs borrowed from several language concepts that were available at that time (mainly the HELP hospital information system and the Regenstrief medical record system (RMRS), but also the Pascal language, functional languages and the data structure of frames, used in artificial intelligence). The syntax has a rationale for its constructs, and has restrictions that follow this rationale. The main goal of the Standard is to promote knowledge sharing, by avoiding the complexity of traditional programs, so that a medical logic module (MLM) written in the Arden Syntax can remain shareable and understandable across institutions.ObjectivesOne of the restrictions of the syntax is that you cannot define your own functions and subroutines inside an MLM. An MLM can, however, call another MLM, where this MLM will serve as a function. This will add an additional dependency between MLMs, a known criticism of the Arden Syntax knowledge model. This article explains why we believe the Arden Syntax would benefit from a construct for user-defined functions, discusses the need, the benefits and the limitations of such a construct.Methods and materialsWe used the recent grammar of the Arden Syntax v.2.10, and both the Arden Syntax standard document and the Arden Syntax Rationale article as guidelines. We gradually introduced production rules to the grammar. We used the CUP parsing tool to verify that no ambiguities were detected.ResultsA new grammar was produced, that supports user-defined functions. 22 production rules were added to the grammar. A parser was built using the CUP parsing tool. A few examples are given to illustrate the concepts. All examples were parsed correctly.ConclusionsIt is possible to add user-defined functions to the Arden Syntax in a way that remains coherent with the standard. We believe that this enhances the readability and the robustness of MLMs. A detailed proposal will be submitted by the end of the year to the HL7 workgroup on Arden Syntax.

@&#INTRODUCTION@&#
The Arden Syntax is a knowledge-encoding standard, started in 1989, and now in its 10th revision, maintained by the health level seven (HL7) organization. It has a well-thought set of constructs; however, the lack of functions forces the repetition of code. This is usually perceived in software development as error-prone and inelegant. A call to another MLM can be used as a function call, but this is too cumbersome for a simple calculation. For example, an author can write a conversion from Fahrenheit to Celsius more naturally using a function. However an addition of function constructs must not transform the Arden Syntax into a traditional programming language, which was one of the original design goals, explained in the rationale for the Arden Syntax [1]. This article only gives the main concepts involved in the addition of functions, without many technical details. A detailed proposal will be made this year to the HL7 organization. Adding features to a computer language is a quite subjective matter; computer languages are made for humans, not computers. This article therefore cites several sources to promote its proposals, but does not provide any formal proof of the benefits of the additional constructs.To study implementation issues, we used the Arden Syntax Standard documents, and also the rationale for the Arden Syntax [1]. Several sources cited by the Rationale for the Arden Syntax were studied also to verify that the addition of user-defined functions is not contradictory with the goals and the general philosophy of the Arden Syntax.We give a few common concepts around functions that will serve in the discussion about the proposal. Functions have a mathematical definition, and the implementation in computer languages of functions often deviates from this definition, mostly because of implementation constraints. A computer execution model based on computable functions can represent constructs that are as powerful as constructs that use a computer execution model based on Turing's abstract machine [2]. Several constructs of computable functions, described in Alonzo Church's paper [3] defining the “lambda calculus” have inspired some of the most advanced computer languages (Lisp, ML, Haskell, for example). Most computer languages deviate from this theoretical functional model, for practical or implementation reasons. The deviations concern mostly the modifications and actions that a function is allowed to make (modify global variables, send messages, etc.). The languages that adhere to the functional model are called functional languages, and are taught in advanced computer science courses. Languages with functions that make modifications outside of their definition are called “impure”, whereas languages that don’t are called “pure”. Furthermore, functions must be distinguished from subroutines. A “pure” function takes arguments, and produces a result, that is returned to the caller. Nothing else is changed, and the result is reproducible. An “impure” function can read and modify variables outside of its definition, and perform actions (like writing to a database, or printing). Therefore two calls to such a function with the same arguments can return different values. A subroutine doesn’t return a value, and exists only to access and modify outer variables and perform actions. An action or a modification made by a called subroutine or “impure” function to something outside of its definition is called a side-effect. Side-effects are not part of functions in the mathematical sense. The basic usage of functions (i.e. without the many powerful but complex features of functional languages) is now commonly taught to medical students, not necessarily via programming languages, but rather through the use of spreadsheet computer applications [4]. A full usage of functions as a computing model can be difficult to understand and use, and some functional constructs will be contradictory with the goal of ease of use of the Arden Syntax.The rationale for the Arden Syntax is an interesting document for the Arden Syntax, as it paves the way to further additions to the language, and even encourages them. It gives to future authors clear guidelines for the development of extensions, by exposing the general philosophy and backgrounds of the approach. In light of these explanations, it appears that several languages influenced the Arden Syntax, and a balance has been maintained between ease of learning and possibilities of language constructs. In every revision of the Arden Syntax that followed the initial version of 1992, the standard evolved, operators and syntactic constructs were added to handle lists, data and control flow with more ease, mainly (the interested readers should refer to the documents of the standard for the detailed list, that is very long):•In v. 2: Operators to sort, index and extract lists,interfacekeyword to use external functions.In v. 2.5: Structured data, with theobjectdata type, and the possibility toincludeother MLMs.In v. 2.6: Localization enhancements.In v. 2.8: Operators to add and remove elements from lists, to better control the sorting of lists with theusingconstruct, addition of theswitch-caseconstruct.In v. 2.9: Support for fuzzy sets, with a newfuzzydatatype, and its support in many operators.In v. 2.10: No language constructs were added, the additions concerned the XML encoding of MLMs.In light of these continuous evolutions, the proposition of adding user-defined functions had to be coherent with the progresses made by the Arden Syntax standard. We used the article “Rationale for the Arden Syntax” as a guide for the implementation of functions in the Arden Syntax. We then compared this source with several current implementations of languages, whether functional or not. We then weighted the possible additions with the constraints expressed in [1], especially the ease of learning, to retain or reject some constructs. As described in [1], the Arden Syntax borrows many constructions from functional languages, namely APL [5], J [6] and also the ML language [7] (of course the main influences of the language are the HELP system [8] and the RMRS's rule system [9]). The syntax reflects this in several constructs. For example, a built-in function can be applied to a list, something that could not be expressed as clearly in the other languages in 1989 (whereas nowadays such constructs are expected of a modern language). It is interesting to describe the influence of the APL language in this context. APL was first a mathematical notation invented in 1957 by Pr. Kenneth E. Iverson at the Harvard University, later released as a book [5]. This language was the language of choice to perform complex calculations involving lists and matrices, being an “Array based language”. The usage of APL however necessitated special keyboards and special displays. This led Pr. Iverson to invent the J language, a successor to APL that used the ASCII character set only. The APL and J implementation of array processing as language elements had an influence on several other now well-known languages like MATLAB [10] and R [11]. The Arden Syntax can be considered an array-based language (in a reduced form, because it operates only on unidimensional arrays). As the authors explained it in paragraph 6.4 [1], they studied these functional languages (APL, J and ML) to avoid as much as possible the use of gotos and loops, and to define thewhereconstruct of the language, that allows the selection of data and the application of weighting functions to categorical data. However, the syntax does not allow the user to define his own formulas, and instead a call to another MLM must be made, which is impractical for simple formulas. Nearly all languages nowadays allow the use of functions, and physicians use formulas regularly in spreadsheet calculations, for example. In the rationale document [1] there is no opinion that formally discourages the introduction of user-defined functions or subroutines; the authors just evoke this matter in paragraph 6.2: “Experience so far has shown that the lack of loops, gotos, and subroutines has not limited MLM authors”.In the current standard, an MLM can be used as if it was a function, using thecallstatement. This approach has several problems, some of them pointed very early by Musen [12].-Fragmentation of the knowledge: the modular approach, when the called MLM can be reused by several MLMs, is the ideal case. However the called MLM, even if not written for sharing, but only to be used as a local formula, becomes nevertheless available to other MLMs. This pollutes the list of MLMs, and promotes duplication of code, as MLM authors will avoid the call to another MLM for just a simple formula. On the other hand, if for example institution X writes an MLM A that computes a simple formula, and institution Y uses it by calling it from its MLM B, any significant change to MLM A will break the inference made in MLM B. Having the formula directly inside MLM B will prevent this case. One of the initial objectives for the Arden Syntax was to have “modular independent knowledge bases” [1], where everything is included in the MLM.The call to an MLM is an “impure” function call. The called MLM can make actions, before returning a value. The possible actions include modifying the patient database, possibly triggering other MLMs. This has also implications in the management of transactions: if the executions of MLMs happen in separate transactions, in the case of an error some database modifications might have been carried out by the called MLMs, inside successful transactions, therefore preventing the correct rollback to previous values.The MLM's frame-like structure requires the use of an entire frame structure for every MLM, with the repetition of the information contained in thelibraryandmaintenanceslots. This adds at least 20 additional lines; this is clearly an inadequate approach when the function is only 2 or 3 lines long, and from the same institution, for the same MLM.Recursive calls (an MLM calling itself, either directly or indirectly via another MLM) are not forbidden in the current standard. This is acknowledged (in part) in the rationale document [1] at paragraph 6.2: “By letting MLMs call each other through nesting or by passing data through the clinical database, MLMs are Turing-complete, but this is not the focus of the Arden Syntax”.Theinterfacekeyword can be used to declare functions that can be called via thecallstatement. However such calls are reserved to functions written in another programming language, system functions and libraries. Conceptually the call is the same as a call to another MLM, except that the possible actions are even less restricted than the actions that can be carried out by another MLM, as virtually anything that is possible in the system is allowed. Functions called by theinterfacekeyword are of course non-standard, and therefore discouraged for knowledge sharing.The grammar of the Arden Syntax is currently written in Backus-Naur form (BNF) in the HL7 documents. As stated in the standard, the grammar can be entered in a “look ahead, left to right rightmost derivation” (LALR) parser. We used the CUP LALR parser from Princeton University (now maintained by the Technische Universität München) [13]. We entered each new production rule individually and ran the CUP tool to detect conflicts and either rewrote or removed any rule that caused a conflict (typically Shift/Reduce conflicts). We then ran the parser on several test constructs, and also on the examples given in this article.

@&#CONCLUSIONS@&#
While changing the Arden Syntax can be a controversial matter, after such a long existence of the standard, the lack of user-defined functions is not in favor of the Arden Syntax when new users compare the Syntax with other current languages. A controlled introduction of functions could correct this negative experience, and enhance the expressiveness and clarity of the Arden Syntax, while preserving its design rationale. The introduction of functions can be made coherently with the philosophy of the language, and its grammar. We believe this would be a benefit for the sharing of knowledge written in the Arden Syntax. A detailed proposal will be submitted by the end of the year to the HL7 workgroup on Arden Syntax. The experts in the workgroup will then discuss if the addition of user-defined functions remains in the philosophy and goals of the Arden Syntax, and if it is a worthwhile addition to the standard.