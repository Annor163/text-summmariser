@&#MAIN-TITLE@&#
Solving the shortest path tour problem

@&#HIGHLIGHTS@&#
We address the shortest path tour problem (SPTP).Two innovative solution methods for the SPTP are defined and implemented.An extensive computational phase is performed on a large class of instances.A comparison with the state-of-art algorithm to solve the SPTP is also carried out.The proposed approaches outperform remarkably the existing solving method.

@&#KEYPHRASES@&#
Network flows,Shortest path,Structure path constraints,Labeling method,

@&#ABSTRACT@&#
In this paper, we study the shortest path tour problem in which a shortest path from a given origin node to a given destination node must be found in a directed graph with non-negative arc lengths. Such path needs to cross a sequence of node subsets that are given in a fixed order. The subsets are disjoint and may be different-sized. A polynomial-time reduction of the problem to a classical shortest path problem over a modified digraph is described and two solution methods based on the above reduction and dynamic programming, respectively, are proposed and compared with the state-of-the-art solving procedure. The proposed methods are tested on existing datasets for this problem and on a large class of new benchmark instances. The computational experience shows that both the proposed methods exhibit a consistent improved performance in terms of computational time with respect to the existing solution method.

@&#INTRODUCTION@&#
The shortest path tour problem(SPTP)is a variant of the shortest path problem(SPP)and appeared for the first time in the scientific literature in Bertsekas’s dynamic programming and optimal control book [2].TheSPTPhas been recently studied by Festa in [13]. The paper of Festa is the first systematic contribution for solving theSPTP. The author proved that the problem belongs to the complexity class P. The polynomial Karp-reduction of theSPTPto the single-source single-destinationSPPinvolves the construction of an expanded graph in which different algorithms for theSPPwere tested and compared on pseudo-randomly generated instances. The results presented in [13] showed that Dijkstra’s algorithm outperforms all the competitor algorithms.Applications of theSPTParise for example in the context of the manufacture workpieces, where a robot has to perform at least one operation selected from a set of S types of operations. In such case, the problem may be modeled as aSPTPin which operations are associated with nodes of a directed graph and the time needed for a tool change is represented by the distance between two nodes (see [13]).The main scientific contribution of this paper consists in analyzing some basic theoretical properties of theSPTP, in designing a dynamic programming-based algorithm(DPA)for solving it, and showing how an ad hoc algorithm for acyclic graphs may be used to solve theSPTPafter efficiently reducing it to a classicalSPPthrough the method referred to as modified graph algorithm(MGA).The remainder of the paper is organized as follows. The problem is formally described in Section 2. The state-of-the-art algorithm to address theSPTPis presented in Section 3. Some properties concerning the reducibility of the problem to a classicalSPPand the relevant consequences in terms of solvability are described in Section 4. A dynamic programming algorithm is illustrated in Section 5. Computational results and the analysis of the performance of the proposed algorithms are presented in Section 6. The paper ends with some concluding remarks stated in Section 7.Consider a directed graph G=(N,A) defined by a set of nodes N≔{1,…,n} and a set of arcs A≔{(i,j)∈N×N: i≠j}, where ∣A∣=m. A non-negative length cijis assigned to each arc (i,j)∈A. Let F(i)≔{j∈N: (i,j)∈A} and B(i)≔{j∈N: (j,i)∈A} be the forward star and backward star associated with each node i∈N, respectively. Moreover, let S denote a certain number of node subsets T1,…, TSsuch that Th∩Tk=∅,h, k=1,…, S,h≠k.Given two nodes i1, iπ∈N,i1≠iπ, the pathPi1,iπfrom i1 to iπis defined as a sequence of nodesPi1,iπ={i1,…,iπ}such that (ij,ij+1)∈A,j=1,…, π−1. Observe that ij, j=1,…, π, represents the node index occurring in position j in pathPi1,iπ. A pathPi1,iπis said to be elementary whether il≠ij, l, j=1,…, π and l≠j. We refer to the length of pathPi1,iπasl(Pi1,iπ)representing the sum of the lengths of the arcs connecting consecutive nodes inPi1,iπ, i.e.,l(Pi1,iπ)=∑j=1π-1cj,j+1.TheSPTPaims at finding a shortest pathPs,dfrom origin node s∈V to destination node d∈V in the directed graph G, such that it visits successively and sequentially the following subsets Tk, k=0,…, S+1, such that T0={s} and TS+1={d}. Note that sets Tk, k=1,…, S, must be visited in exactly the same order in which they are defined.Consequently, a pathPi1,iπis said to be a feasible solution for theSPTPif:(1)∃g0,g1…gS+1∈[1,π]:g0<g1<⋯<gS+1,ig0∈Pi1,iπ∩T0,ig1∈Pi1,iπ∩T1,…,igS+1∈Pi1,iπ∩TS+1.Conditions (1) mean that an increasing sequence of natural numbers exists such that the corresponding nodes of the pathPi1,iπbelong to the ordered sequence of subsets T0, T1,…, TS+1. A small instance of theSPTPis depicted in Fig. 1, where N={s=1, 2, 3, 4, 5, 6, d=7}, S=2,T0={s=1}, T1={3}, T2={2, 4}, T3={d=7}. The shortest path from node 1 to node 7 isP1,7={1,3,7}with length 5, while the shortest path tour between the same origin and destination nodes is P1,7={1, 3, 2, 3, 7} with length 11. Such path is not elementary, since it passes twice through node 3.The state-of-the-art consists of the expanded graph method proposed by Festa in [13], and referred to asEGAin the sequel. A brief description of how theEGAworks is given in the following.TheEGArelies on a polynomial-time reduction algorithm that transforms anySPTPinstance defined on a single-stage graph G into a single-source single-destinationSPPinstance defined on a multi-stage graph G′=(V′,A′) with S+2 stages, each replicating G, and such that V′={1,…, (S+2)n} and ∣A′∣=(S+1)m. More precisely, the reduction algorithm performs the following operations:i.V′≔{1,…, (S+2)n}; A′≔∅;at each iteration, an arc(a,b) is added to A′. In particular, for each stage k∈{0,…, S}, for each node v∈{1,…, n}, and for each adjacent node w∈FS(v), (a,b)=(v+kn,w+(k+1)n) with length cvw, if w∈Tk+1; (a,b)=(v+kn,w+kn) with length cvw, otherwise.Since ∣A′∣=(S+1)m, the computational complexity of the reduction algorithm is O(Sm).1For bounding the computational complexity of an algorithm, several asymptotic notations are used [6]. If n is the input size, the computational complexity of an algorithm f(n) is O(g(n)), if there exist positive constants a and n0 such that 0⩽f(n)⩽ag(n) for all n⩾n0.1Once the multi-stage graph G′ is obtained, to solve the resultingSPPany shortest path algorithm can be applied. By applying Dijkstra’s algorithm that uses a binary heap for storing temporary node labels, the overall worst case computational complexity ofEGAis O(∣A′∣log∣V′∣+∣V′∣log∣V′∣), which is dominated by O(∣A′∣log∣V′∣), that is O(Smlogn).In this section, we will focus on some basic properties related to the reducibility of anySPTPinstance into a single-source single-destinationSPPinstance.Given an instance of theSPTPon a directed graph G=(N,A) the following definition is applied.Definition 1Let G(a)=(N(a),A(a),c(a)) be a weighted directed graph obtained from G in such a way that:•N(a)=⋃k=0S+1Tk;A(a)=⋃k=0SAk(a), whereAk(a)≔{(i,j)∈Tk×Tk+1:i∈Tkandj∈Tk+1};c(a):A(a)↦Z+is a function that associates an integer non-negative numbercij(a)to each arc (i,j)∈A(a), wherecij(a)≔l(Pi,j)is the length of a shortest path from node i∈Tkto node j∈Tk+1 on graph G.The following property holds for the arc set A(a).Property 1Let G(a)be the weighted directed graph associated with an instance of theSPTP, then ∣A(a)∣⩽n(n−2).Solving aSPTPinstance may be performed by finding a shortest path in G(a). Indeed, the following property holds.Property 2Every pathPs,d(a)from s to d in G(a)defines aSPTPsolution in G with the same cost, and vice versa.Such a property derives from the construction of graph G(a) given in Definition 1.The optimal cost of anySPTPinstance is equal to the cost of the shortest path from node s to node d computed on G(a), as shown in the following property.Property 3The cost of a shortest pathPs,d(a)in G(a)is equal to the cost of an optimalSPTPin G.Such property can be proved by contradiction. From Property 2, it follows that the shortest pathPs,d(a)in G(a) corresponds to a feasible path tourPs,d∗in G. Hence, suppose that a shortest path tour Ps,ddifferent fromPs,d∗exists in G, such thatl(Ps,d)<lPs,d∗. This means that a feasible pathPs,d(a)′exists in G(a), associated with Ps,d, whose cost is less than the cost of the shortest pathPs,d(a). This conclusion contradicts the initial assumption.□The framework of the proposedMGAis sketched in Algorithm 1:Algorithm 1Modified graph algorithmStep 1 (Initialization)Compute a shortest path from each node i∈Tkto each node j∈Tk+1, k=0,…, S.Step 2 (Graph Construction)Build the digraph G(a)=(N(a),A(a)) as detailed in Definition 1.Step 3 (Topological enumeration of N(a))Step 4 (Shortest Path Computation)Letl(P1,i)denote the length of the shortest path from node s=1 to node d=i, and p(i) denotethe predecessor node of i inP1,i.Setl(P1,1)≔0,p(1)≔1anditerationMGA≔0.for allj=2,…, ∣N(a)∣ dol(P1,j)=mini∈N(a):(i,j)∈A(a){l(P1,i)+cij}. Update p(j) with the value of i whereby the minimum ofl(P1,j)occurs.Update the number of iterations asiterationMGA=iterationMGA+1.end forThe worst case computational complexity ofMGAis O(n3).In order to evaluate the computational complexity of the proposed algorithm, it is useful to observe that the total number C of shortest paths to be computed in Step 1 is given by:C=∑i=0S|Ti||Ti+1|.Note that C=O(n2) and the worst case arises when S=2 and|Ti|=n-22,i=1,2. In this latter case, Step 1 reduces to computing a shortest path between each pair of nodes i, j∈N(a) such that i∈T1 and j∈T2 and can be solved in the worst case in O(mn+n2logn) by applying Dijkstra’s algorithm with Fibonacci’s heap. As already underlined, the complexity of Step 2 is O(Sm). Step 3 is performed in O(∣N(a)∣)=O(n), while the theoretical complexity of the shortest path problems in acyclic graphs is linear in the number of arcs, so that the complexity of Step 4 in Algorithm 1 is O(∣A(a)∣), which is O(n2). Since m=O(n2), it follows that the problem can be solved in the worst case in O(n3).□In this section, we describe a dynamic programming algorithm(DPA)to solve theSPTP.DPAhas been designed by considering theSPTPas an extension of the weight constrained shortest path problem, where the resource riassociated to a path Ps,ifrom node s to node i represents the index of the last set Tk, k=0,…, S+1, visited along the path and the resource consumption of an arc is label-dependent.Recent scientific literature on the study of the classical weight constrained shortest path problem includes among others a paper of Dumitrescu and Boland [10], where the authors propose several alternative algorithms, including an exact method based on the weight-scaling approach, later improved by the same researchers in [11]. In 2009, Muhandiramge and Boland [19] designed a method to find simultaneous solution of Lagrangean dual problems interleaved with preprocessing. Dynamic programming approaches for the weight constrained shortest path problem and the shortest path problem with resource constraints have been proposed in [1,12,20].In our case, viewing theSPTPas an extension of the weight constrained shortest path problem, to each path Ps,ifrom node s to node i is associated a label yi. It stores information about the length of the path and the resource consumption along the path, that is, yi=(l(Ps,i),ri). With reference to the same network depicted in Fig. 1, label y2 associated with the subpath P1,2={1, 3, 2} takes the following form: y2=(6, 2). Similarly, subpath P1,3={1, 2, 3} has label y3=(2, 1).It is worth observing that more than one path Ps,imay exist to reach node i starting from node s. This means that several labels yi=(l(Ps,i), ri) can be associated with each node i and they are stored in the set D(i).LetPs,i′andPs,i″be two distinct paths from node s to node i and letri′andri″denote the resource consumption along pathPs,i′andPs,i″, respectively.From the definition of resource consumption, it follows that for the pathPs,i′a sequence of natural numbersg0′,g1′…gri′′exists such thatg0′<g1′<⋯<gri′′andig0′∈Ps,i′∩T0,…,igri′′∈Ps,i′∩Tri′. Similarly, for the pathPs,i″it is possible to find a sequence of natural numberg0″,g1″…gri″″such thatg0″<g1″<…<gri″″andig0″∈Ps,i″∩T0,…,igri″″∈Ps,i″∩Tri″.Suppose thatri′⩾ri″, there exists a pathPi,d‴such that the path resulting from the concatenation ofPs,i″withPi,d‴, sayP^s,d=Ps,i″⊕Pi,d‴, is a feasible solution for theSPTP. The following result holds.Lemma 2IfPs,i″⊕Pi,d‴is a feasibleSPTPsolution, thenPs,i′⊕Pi,d‴is also a feasibleSPTPsolution.SincePs,i″⊕Pi,d‴is a feasibleSPTPsolution, there exists a sequence of natural numbersgri″+1‴,…,gS+1‴such thatgri″+1‴<⋯<gS+1‴andigri″+1‴∈Pi,d‴∩Tri″+1,…,igS+1‴∈Pi,d‴∩TS+1.Owing to the feasibility of pathPs,i″⊕Pi,d‴andri′⩾ri″, it is possible to extract the subsequencegri′+1‴,…,gS+1‴from the sequencegri″+1‴,…,gS+1‴, such thatgri′+1‴<⋯<gS+1‴andigri′+1‴∈Pi,d‴∩Tri′+1,…,igS+1‴∈Pi,d‴∩TS+1. Consequently,Ps,i′⊕Pi,d‴is a feasible path for theSPTP.□Let us assume thatlPs,i′<lPs,i″. It follows that pathPs,i″can be discarded.Lemma 3IflPs,i′<lPs,i″, thenlPs,i′⊕Pi,d‴<lPs,i″⊕Pi,d‴, thus from pathPs,i″it is not possible to generate the optimalSPTPsolution.Lemma 3 can be proved by contradiction. Thus, for the purpose of contradiction, let us assume thatlPs,i′⊕Pi,d‴⩾lPs,i″⊕Pi,d‴. Such an expression can be rewritten as follows:lPs,i′+lPi,d‴⩾lPs,i″+lPi,d‴. It follows thatlPs,i′-lPs,i″⩾0. This means thatlPs,i′⩾lPs,i″, contradicting the assumption.□Lemma 3 suggests us to define a dominance relation between labels. In particular the following results can be drawn.Definition 2Letyi′=lPs,i′,ri′andyi″=lPs,i″,ri″be two labels associated with pathsPs,i′andPs,i″, respectively. IflPs,i′<lPs,i″andri′⩾ri″, thenyi″is dominated byyi′and pathPsi″can be discarded.Letyi′=lPs,i′,ri′andyi″=lPs,i″,ri″be two labels. Such labels are said to be equivalent iflPs,i′=lPs,i″andri′=ri″.Starting from labelys0=(0,0)associated with the origin node s, the solution space is explored in order to obtain efficient solutions for each node. Through the algorithm iterations, a labelyj″=lPs,j″,rj″is generated starting from a labelyi′=lPs,i′,ri′using the following updating rules:(2)lPs,j″=lPs,i′+cij;(3)rj″=ri′+1,ifri′+1⩽S+1andj∈Tri′+1;ri′,otherwise.At the end of the algorithm, D(j), j∈N, is an efficient set, that is, it contains efficient and feasible solutions. In addition,ld∗=lPs,d∗:y∗=lPs,d∗,S+1∈D(d)represents the length of the optimal solution of the shortest path tour from node s to node d.Let L be the set storing the labels associated with the partial paths to be processed, the steps of the proposed labeling method are depicted in Algorithm 2.An upper bound on l(Ps,d), named hmax, may be obtained by considering that, in the worst case, a tour contains S+1 subpaths, each of them involving n−1 arcs having the maximum cost.Therefore it results that(4)l(Ps,d)⩽hmax⩽(S+1)(n-1)cmax,cmax=max(i,j)∈Acij.Algorithm 2Multidimensional labeling algorithmStep 1 (Initialization)Set:Ps,s0≔{s},ys0≔0,rs0withrs0≔0, anditerationDPA≔0.Set:L≔ys0,D(s)≔ys0,D(j)≔∅,∀j∈N,j≠s.Step 2 (Label Selection)Select and delete from L a labelyi′.Update the number of iterations asiterationDPA=iterationDPA+1.Step 3 (Label Extension)for all (i,j)∈AdoSet:P¯s,j≔Ps,i′∪{j}.l(P¯s,j)≔lPs,i′+cij.ifri′<S+1thenSet:k¯≔ri′+1.ifj∈Tk¯thenSetr¯j≔k¯.elseSetr¯j≔ri′.end ifelseSet:r¯j≔ri′.end ifSety¯j≔(l(P¯s,j),r¯j).ify¯jis not dominated by any labelyj′belonging to D(j) thenRemove from D(j) and from L all labelsyj′that are dominated byy¯j.Addy¯jto D(j) and to L.end ifend forStep 4 (Termination check)ifL=∅ thenSTOPelseGo to Step 2.end ifIn view of the relation (4), the following property stands.Theorem 4The computational complexity ofDPAis O(S2n3cmax).The number of iterations performed by the algorithm depends on the total number B of different labels generated. There are at most O(B)=O(Shmax) different labels. Each label may be replicated on different nodes, but it is expanded at most∑i∈N∣F(i)∣=mtimes, and each expansion requires O(1) times, then the total number of performed iterations is:O(Bm)=O(S2nmcmax).Since O(m)=O(n2), the resulting overall complexity is O(S2n3cmax) in the worst case.□The running time of Algorithm 2 could be improved by considering a pruning strategy based on the path length. Letlibe the least length from node i to node d and let UB be the length of a feasible solution for theSPTP. A labelyi′can be discarded iflPs,i′+l̲i>UB. In addition, whenever a feasibleSPTPsolutionPs,d′is found such thatlPs,d′<UB, then UB is updated.In this section, we discuss and compare the computational results obtained with theDPA,MGAandEGA. The experiments were carried out on a PC equipped with one Intel Core X5680 Processor@3.33GHz, with 50Gbyte RAM. All algorithms were coded in java.The main goal of these experiments is to study the behavior of the proposed algorithms (i.e.,DPA,MGA) and compare them with the state-of-the-art algorithm (i.e.,EGA). A computational analysis is outlined to show how the performance ofDPAandMGAare affected by network topology and characteristics, i.e., number and size of subsets Tk, k=0,…, S+1. In all the test problems, the following setting is used: s=1 and d=n. Details related to the basic shortest path algorithms used inside the proposed methods are given below.As far as the construction of G(a) in theMGAis concerned, the Floyd–Warshall algorithm [15] is used to compute the length of the shortest path between all node-pairs of G. Observe that graph G(a) is built explicitly withinMGA. The shortest path solutions inEGAis provided by Dijkstra’s algorithm [7] with binary heaps [17]. It is worth observing that forEGAan iteration corresponds to process the node just selected from the heap, while forMGAandDPAan iteration is defined implicitly inside the corresponding algorithmic sketches.Given that the performance ofDPAis strongly influenced by an Upper Bound (UB) on the minimum cost, a feasible solution is found heuristically by selecting a node sequence {1,i1,i2,…,iS,n} starting from the source node 1 and ending with the destination node n, and such that ik∈Tk, k=1,…, S. The length of the path associated with this sequence is evaluated as the shortest path cost obtained by applying Dijkstra’s algorithm between two consecutive nodes in the sequence.The collected computational results are reported in Tables A.1–A.9 reported in the Appendix. For each instance and each algorithm, the number of iterations and the execution times are detailed. The column headings of such tables are defined as follows: “Test” denotes the instance name; “Time” denotes the computational time in milliseconds (ms) required by each one of the proposed algorithms in order to find the optimalSPTPsolution; “Iterations” denotes the overall number of iterations performed by each of the designed algorithm; “FW Time” denotes the Floyd–Warshall running time performed byMGAon G and required to construct G(a); “SpTime” indicates the running time required byEGAto compute the shortest path on the expanded graph; the running time required byEGAto build the expanded graph is reported in column “EgTime”. Due to the use of java as programming language, the running time required byDPA,MGAandEGAare averaged over 30 runs, executed for eachSPTPinstance.Three classes of networks are considered: grid random, fully random, and fully dense networks. The rationale of this choice is motivated by the fact that these networks are well recognized and used extensively to assess the behavior of the solution algorithms for the classicalSPPand some of its variants (see for example, [4,5,16,9,8]). For all test networks, the arc lengths are chosen according to a uniform distribution in the range from [1,1000].Such problems are generated by using the Gridgen generator written by Bertsekas [3]. Problem sizes are outlined in Table 1. Both square (Gτ, with τ=1, 2, 3) and rectangular grid networks (Gτ, with τ=4, 5, 6) are designed. The nodes are arranged in a planar grid. Nodes s and d are placed at the corners. Each pair of adjacent nodes are connected in both directions. Sets Tk, k=1,…, S, are generated by randomly selecting one node at a time and placing it into Tkup to achieve the corresponding size.A set of nine networks of different size and density (i.e., the number of arcs over the number of nodes) is designed. These networks, named Rτ, τ=1,…, 9, in the sequel, are generated by using the public domain Netgen program [18]. Table 2reports the sizes of the random networks. For each problem, the number of nodes, the number of arcs, and the density are provided.Three fully dense networks are generated by using the Compligen generator written by Bertsekas [3]. Each of these problems, referred to as Cτ, τ=1, 2, 3, in the sequel, includes all the possible n(n−1) arcs. The number of nodes is set equal to 100 for C1, 300 for C2, and 500 for C3.For each network of the type described above, a set ofSPTPs is built by varying the number of node subsets S, and the size of ∣Tk∣, k=1,…, S, for a given S. More precisely, let n′=n−2 be the number of nodes in the original network from which the source and destination nodes are discarded, four instances of theSPTPare obtained by setting S inS={5,10,15,20}. For each value of S, threeSPTPs are designed by varying ∣Tk∣ in the setTS=|TS|lower≔N′3S,|TS|middle≔N′2S,|TS|upper≔N′S.More generally, it is:TS=ρN′S:ρ∈13,12,1,where ρ represents the consistency of sets Tk, k=1,…, S, associated with S. Observe that|TS|=3for eachS∈S, and it will be referred to as|T|in the sequel. In this way, a set of 12 benchmark instances remains associated with each original network.In what follows, we use the notationtypeS|T|to identify eachSPTPinstance. Indeed,R158refers to the fully random problem R1, with S=5 node subsets T1,…,T5, such that ∣T1∣=…=∣T5∣=8, and ∣T0∣=∣T6∣=1. TheSPTPinstances are available for download at the following URL: http://uweb.deis.unical.it/guerriero/benchmark-instances-for-sptp. In addition, computational experiments were carried out on the instances defined by Festa in [13] and provided by the same author.We look at several statistics to evaluate the performance of the proposed algorithms on a large number of different-sized test problems. The statistics we will consider are defined below:(a)n-Average execution time: mean value of the overall execution times related to theSPTPinstances associated with a network with a given topology (grid random, fully random, fully dense), and a given number n of nodes.S-Average execution time: mean value of the average execution times associated with a set ofSPTPinstances defined by all the networks with a given topology (grid random, fully random, fully dense), and a given value of S.S-Average iteration number: computed as for the S-Average execution time with respect to the number of iterations.ρ-Average execution time: average execution time computed with respect to a given consistency value, for a given S and for all the networks with a given topology (grid random, fully random, fully dense).In this section, the behavior of the proposed methods is studied for the set ofSPTPs based on grid random networks. Computational results are detailed in Tables A.1–A.2 of the Appendix. Generally, the computational results show how the performances of the proposed algorithms seem to be affected by the structure of the networks, expressed by means of the number of nodes n, and densityδ=mn. In general, the computational effort increases with n.This trend is well highlighted in Fig. 2, where the n-Average execution times are plotted as a function of the number of nodes. The n-Average time ofMGAincreases more quickly thanDPAas long as n increases beyond 1250. Since the most computational part ofMGAis represented by Floyd–Warshall algorithm, that is involved in construction of G(a), the reported computational times ofMGA, that is, the times required by Floyd–Warshall, grow according to the computational complexity O(n3). Therefore, for grid networks with large value of n, that is, n greater than 1250, the time required byMGAis more expensive than the one implied byDPA. On the other hand, since paths Ps,din grid network with a large number of nodes n contain a large number of intermediate nodes (at least gx+gy−1 nodes in a gx×gygrid), then the possibility to meet several sets Tk, k=1,…, S, could increases with n. Therefore, the convergence ofDPAtowards the optimalSPTPsolution does not deteriorate with the increase of n in the same manner as it occurs forMGA.The same trend occurs if iteration numbers are considered instead of average times (see Tables A.1–A.2 of the Appendix).Figs. 3 and 4help to explain the differences underlined so far. In case ofDPA, the more high the value of S becomes, the more increase in the execution time occurs. This is motivated by the theoretical computational complexity ofDPAthat increases explicitly more than linearly with S.On the contrary, the theoretical computational complexity ofMGAvaries implicitly with S, depending on whether it is building G(a) or finding the shortest path on G(a). More precisely, the increase of S reduces the cardinality of sets Tk, k=1,…, S, and thus the number of arcs of G(a). In fact,|A(a)|=O(ρn)2S; therefore, the time to build G(a) is reduced also as well as the time for finding the shortest path on G(a). Observe that for square grid random network-basedSPTPinstances there exists a value of S from whichMGAoutperformsDPA.Table 3brings out clearly the difference in the relationship between the S-Average iteration number performed by each algorithm and the number S of sets. Such a table shows that the average number of iterations performed byDPAincreases with S, while it decreases forMGA. In effect, the number of labels generated byDPAfor each node increases with S, and then the number of iterations also increases. As mentioned earlier, the running time ofMGAdecreases with the increase of S.The impact of ρ on the performance of the solving algorithms emerges in Figs. 5 and 6. They show how the average execution times vary with respect to the values of ρ. More precisely, for a given S the time performance ofDPAdecreases significantly with the values of ρ. The rationale of such a behavior can be explained by taking into account that large value of ρ, that is large size of Tkwith k=1,…, S, makes easier to improve the resource labels and also generate new labels with increasing resources allowing to remove a large number of dominated labels from L, so that the algorithm converges quickly to the optimal solution. This is specially true for large values of S. ForMGAan opposite trend is observed. The occurrence of increasing value of ρ for a given S, that is increasing size of sets Tkwith k=1,…, S, affects the construction of G(a) by enlarging the size of N(a), and increases also the number of arcs belonging to A(a) and connecting pairs of disjoint nodes of N(a). Moreover, the running time to find the shortest path on G(a) grows with the size of Tk, that depends directly on ρ for a given S. Therefore, the more the performance ofMGAdeteriorates with the increase of ρ, the lower are the values of S.The computational results collected for the grid random network-basedSPTPs indicate thatDPAbehaves the best. In particular, on the rectangular grid networksDPAis on average 7.95 times faster thanMGA. A similar behavior can be observed for the square grid random networks where the average execution time ofDPAis 2.13 times faster than the average time required byMGA.The behavior observed for grid random networks remains confirmed in case of fully random networks. Fig. 7shows how the n-Average execution time, for bothDPAandMGA, increases with n, even if the slope related toDPAis clearly higher that the one corresponding toMGA. The cost of an iteration ofDPAis greater than the computational effort required to execute an iteration ofMGA. Fully random graphs are expected to contain Ps,dpaths with less and less arcs as δ increases for a fixed number of nodes n. Furthermore, the cost of the single iteration ofDPAclearly grows with δ. On the other hand, for sufficiently small n, the cost of Floyd–Warshall algorithm that is involved in construction of G(a) is limited, andMGAoutperformsDPA; note that this happens for both fully random and grid random networks, with a number of nodes n⩽1250. Definitively, the computational results collected on fully random networks confirm thatDPAcan outperformMGA, but only for sufficiently large n.Fig. 8shows clearly how the S-Average time ofDPAincreases with S, while the average performance ofMGAseems not be influenced by the values of S. Table 4indicates that the average number of iterations ofDPAincreases more than linearly with S, while the average number of iterations ofMGAdecreases less than linearly with S. The rationale is the same highlighted for the grid random network-basedSPTPs.Finally, the impact of ρ on the performance of both algorithms is numerically underlined by looking inside Tables A.3–A.5, and globally depicted in Figs. 9 and 10.In particular, Fig. 9 shows the impact of ρ on the performance ofDPAfor a given S. The increase of ρ enlarges the size of Tk, where k=1,…, S, so that the improvement of the resource labels becomes easier. In case ofMGAthe trend is opposite as follows from Fig. 10. In such a case, the execution times ofMGAincrease with ρ, so the performance ofMGAdecreases with ρ. More precisely, the size of Tk, with k=1,…, S, increases with ρ, and the impact of such an increase has an effect on the computational complexity ofMGA.The computational results collected for the fully random network-basedSPTPs indicate thatMGAoutperformsDPA. More precisely,MGAis on average 13.81 times faster thanDPA.Concerning experiments on fully dense networks, since n assumes the smallest value with respect to that occurring in grid and fully random networks, then the computational time required by Floyd–Warshall is very limited compared to the one implied in an iteration ofDPA. Therefore, the performance ofMGAis clearly better thanDPA. Figs. 11 and 12show how the n-Average execution time and the S-Average execution time ofDPAquickly increases with n, while they have a very slow increase in case ofMGA.Table 5brings out that the S-Average number of iterations ofDPAincreases monotonically and more than in a linear way with S, while it decreases less than linearly with S in case ofMGA. Table A.6 gives numerically evidence of the above considerations.The trend of the ρ-Average execution time forDPAandMGAis coherent with the dependence already observed for the test problems based on grid and fully random network-basedSPTPs, as confirmed by Figs. 13 and 14. The rationale of these behaviors is implied into the nature of the computational complexity ofDPAandMGAthat is emphasized by this type of networks.The computational results summarized and discussed on fully dense network-basedSPTPs show thatMGAclearly outperformsDPA. In fact,MGAis on average 814.02 times faster thanDPA.In this section, for each set of test problems, the best performing algorithm selected betweenDPAandMGAis compared with the algorithm devised by Festa in [13]. In particular, the comparison involves the average computational times and the number of iterations performed by the best algorithm betweenDPAandMGA, andEGA.The performance ofEGAwith respect toMGAis affected by the topology of graph G′ that is not necessarily acyclic, unlike G(a) that is acyclic and explicitly built withinMGA. The computational results obtained by testingEGAon the considered three random datasets are reported in Tables A.7–A.9. In order to assess the behavior ofEGAon these test problems, let us to consider them separately.The computational results obtained by testingEGAon the first set of theSPTPinstances based on grid random networks underline that the best algorithm betweenDPAandMGAoutperformsEGA. In particular,DPAis on average 28.27 and 18.19 times faster thanEGAon the rectangular and square grid random networks, respectively.MGAperforms better thanEGAwith an average time reduction by a factor of 21.94 on fully random network-basedSPTPinstances. Finally,MGAclearly outperformsEGAon fully dense random network-basedSPTPinstances by a factor of 301.13.As for the datasets provided by Festa in [13], namedTFin the sequel, they refer to the same three network topologies already defined. Tables 6–8report the characteristics of theSPTPinstances belonging toTFand defined on the basis of grid random networks GTF, fully random networks RTFand fully dense networks CTF, respectively. Observe that these networks are designed by using the generator described in [14]. The source and destination nodes are randomly selected among all the nodes, according to a uniform distribution. Each node of the networks belongs to a set Tk, where k=0,…, S+1. Moreover, theSPTPinstances in theTFdatasets are generated for each network and value of S specified in the last column of Tables 6–8. For a detailed description of how such instances are generated, the reader is referred to [13].The computational results collected on the instances ofTFcan be found in Tables 9–11. They show that the best performing algorithm isMGA, even on the grid network-based instances. This behavior is coherent with the trend analyzed in Section 6.3. The rationale lies in the fact that theSPTPinstances ofTFhave a very small number of nodes, thus the running time ofMGAis slower than that required byDPA.In comparison withEGA, one may observe thatMGAis on average 2051.50 times faster thanEGAon grid network-based instances, 3415 times faster in case of fully random network-based instances, and 3213.46 times faster in case of fully dense network-based instances. This behavior may be explained by observing that theSPTPinstances ofTFare designed in such a way that the size of expanded graph built in the method proposed in [13] grows linearly with S since for each of the S node subsets it replicates the original graph, whereas working on the modified graph G(a) determines considerable improvements in performance.

@&#CONCLUSIONS@&#
This paper exhibits the results of the study concerning a variant of theSPP, called the Shortest Path Tour Problem(SPTP), in which the shortest path from a given origin node to a given destination node flows through a given number of node subsets ordered according to a given sequence. We provide two competitive solving algorithms. The former is based on an explicit reduction of theSPTPinto an instance of theSPP, the latter on a dynamic programming method where theSPTPis considered as an extension of the resource constrained shortest path problem. Some basic properties are highlighted and an extensive computational analysis of both the proposed methods is carried out on new large size benchmark instances, and the dataset considered in [13]. The numerical results show that the performance of the proposed algorithms depends mainly on the structure of the networks. More precisely, the dynamic programming-based algorithm(DPA)outperforms the modified graph-based algorithm(MGA)on theSPTPinstances that are generated from grid random networks, while the latter is more competitive than the former as long as fully random and fully dense networks are involved. This appears from the computational results obtained with the new datasets. The numerical experiments carried out on theTFdataset show that the most efficient proposed algorithm outperforms clearly the state-of-the-art solution strategy [13]. The obtained results also suggest that these methods could be extended to address other variants of the classicalSPP, which represent a new and challenging research area.