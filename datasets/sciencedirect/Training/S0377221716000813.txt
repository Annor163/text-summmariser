@&#MAIN-TITLE@&#
Column generation based approaches for a tour scheduling problem with a multi-skill heterogeneous workforce

@&#HIGHLIGHTS@&#
We solve a real-life employee scheduling problem with a large number of constraints.We show how an efficient dynamic program can be used to generate valid plannings.We show that our method is efficient for solving real-life instances.We experimentally compare the effectiveness of a greedy heuristic with a diving heuristic.

@&#KEYPHRASES@&#
Employee scheduling,Integer programming,Branch-and-price,Heuristics,

@&#ABSTRACT@&#
In this paper, we address a multi-activity tour scheduling problem with time varying demand. The objective is to compute a team schedule for a fixed roster of employees in order to minimize the over-coverage and the under-coverage of different parallel activity demands along a planning horizon of one week. Numerous complicating constraints are present in our problem: all employees are different and can perform several different activities during the same day-shift, lunch breaks and pauses are flexible, demand is given for 15 minutes periods. Employees have feasibility and legality rules to be satisfied, but the objective function does not account for any quality measure associated with each individual’s schedule. More precisely, the problem mixes simultaneously days-off scheduling, shift scheduling, shift assignment, activity assignment, pause and lunch break assignment.To solve this problem, we developed four methods: a compact Mixed Integer Linear Programming model, a branch-and-price like approach with a nested dynamic program to solve heuristically the subproblems, a diving heuristic and a greedy heuristic based on our subproblem solver. The computational results, based on both real cases and instances derived from real cases, demonstrate that our methods are able to provide good quality solutions in a short computing time. Our algorithms are now embedded in a commercial software, which is already in use in a mini-mart company.

@&#INTRODUCTION@&#
Employee scheduling is an important issue in retail (see Kabak, Ülengin, Aktas, Önsel, & Topcu, 2008), as personnel wages account for a large part of their operational costs. This problem raises considerable computational difficulties, especially when certain factors are considered, such as employee availability, fairness, strict labor rules, highly variable work demand, mixed full and part-time contracts, etc. Since the seminal work of Dantzig (1954), a large quantity of research papers have developed models and methods to assist managers and planners in their employee scheduling tasks (more than 300 papers published between 2004 and 2012 were surveyed in Van Den Bergh, Beliën, De Bruecker, Demeulemeester, & De Boeck (2012)). For a comprehensive literature review of classical studies on this problem, we refer to (Ernst, Jiang, Krishnamoorthy, & Sier, 2004).In this paper, we study a real-life multi-activity tour scheduling problem with highly heterogeneous employees and flexible working hours. Given a fixed set of employees, the objective is to construct their work schedule or planning that minimizes the distance to the ideal coverage of the demand. Numerous complicating factors described in the literature are taken into account and, to the best of our knowledge, this paper is one of the first attempts (in parallel with Restrepo, Gendron, & Rousseau, 2015) to combine days-off scheduling, shift scheduling, shift assignment, activity assignment, pause and lunch break assignment.Several features of our problem are still considered as major issues in the recent literature (Van Den Bergh et al., 2012): individual constraints and flexibility of employees, integrated days-off, shift scheduling and assignment (Lequy, Bouchard, Desaulniers, Soumis, & Tachefine, 2012a) and multi-activity assignment (Lequy, Desaulniers, & Solomon, 2012b; Quimper & Rousseau, 2010; Restrepo, Lozano, & Medaglia, 2012). Although the lunch break assignment between two timeslots is taken into account in most research papers, pause assignment during activities themselves remains a gap in the academic literature (see Thompson & Pullman, 2007). To our knowledge, only (Widl & Musliu, 2014) deals with both types of breaks at the same time.Although integer linear programming (ILP) models exist for this family of problems, they cannot be used directly to solve large scale problems with many constraints. Therefore, several works propose heuristics based on those ILP models to reduce their computational burden. Heuristic methods can be obtained by applying a hierarchical decomposition (see e.g. Hojati & Patil, 2011). First, good shifts are computed, and then employees are assigned to the shifts in a second phase. Unfortunately, this technique cannot be applied directly to our problem, where each employee can change activity during his shift and has his very specific features such as availabilities, skills and pre-assignments. When the time horizon is large, and the problem can be solved for a smaller time horizon (typically one week) without risking infeasibilities for the planning, an interesting approach (Stolletz & Zamorano, 2014) is to use a rolling horizon heuristic, where the problems related to smaller time horizons are solved in an iterative manner. In our problem, the total number of worked hours for each employee is fixed, which may lead such method to unfeasible schedules.Many algorithms for solving such employee scheduling problems are based on the column-generation approach (see for example Eitzen, Panton, & Mills, 2004). Recent papers address shift or tour scheduling problems with branch-and-price methods. Boyer, Gendron, and Rousseau (2014); Côté, Gendron, and Rousseau (2013) and Restrepo et al. (2015) use branch-and-price to solve very general multi-activity shift scheduling problems. Their approaches rely on the description of shifts using a context-free grammar. Another recent work on the subject was realized by Brunner and Stolletz (2014). They use an ad-hoc branch-and-price method to solve a tour scheduling problem. The main ingredients of their approach are the use of variables related to day-shifts, which are recombined in the master problem, and stabilization strategies to reduce the number of column generation iterations. Another recent work (Dohn & Mason, 2013) uses branch-and-price in the context of employee-scheduling. They use a nested dynamic programming approach, which is well-suited to the structure of their problem.Our approach is also based on a branch-and-price algorithm. However, the problem settings do not allow us to use directly the algorithms from Boyer et al. (2014); Côté et al. (2013); Restrepo et al. (2015). In our problem, each employee is different, the time horizon is much larger than the ones in Boyer et al. (2014); Côté et al. (2013), and many constraints restrict the construction of the shifts. This leads to a prohibitively large pricing problem solution time. Since our aim is to handle real-life instances, we had to use a heuristic version of the branch-and-price, where some constraints are treated heuristically in the subproblem. The hierarchical structure of our shifts called for an ad-hoc specific nested dynamic program (like Dohn & Mason, 2013), which proves to be much more efficient than a straightforward dynamic programming approach.An important practical requirement is to find a good solution in a short amount of time (a few seconds for 100 employees). To respect this time limit, we designed a greedy algorithm based on our dynamic program. Also, a diving heuristic is proposed for cases when we have several minutes of computational time. Our algorithms have been implemented and are now embedded in a commercial software. They are able to find feasible solutions with good quality in a small or reasonable time for all test cases that were provided by our industrial partner. Our algorithms are now in use in a mini-mart company.In Section 2, we describe formally our problem. Our column generation framework is presented in Section 3, followed by the nested dynamic program used to solve the pricing problem in Section 4. Our heuristic algorithms based on column generation are presented in Section 5, while computational experiments on real and generated instances are reported in Section 6.The problem consists in scheduling a fixed workforce to maximize the fit to a given time-varying demand. The planning horizon consists ofDconsecutive days. Each day is divided into the same number of successive time periods of equal length (15 minutes in this paper). SetTrepresents the different time periods in the discrete planning horizon. The set of heterogeneous employees is denoted byE.The whole set of activities that employees can carry out is divided into two distinct groups: production activitiesA,related to work demands, and pause activitiesP,related to non-productive activities. In our retail context, a production activity can represent, for example, the welcome desk, a cash desks line or a meat counter. Each employeee∈Ehas a set of production activitiesA(e,t)that he/she can perform at time period t. SetP(e,t)contains a pause if employee can take it at time period t; this set is empty otherwise. The beginning and the length of a pause are strictly constrained by the personalized pause policy of the company agreement. An employee e is unavailable at time period t ifA(e,t)∪P(e,t)=∅. In this case, the planning computed for employee e cannot contain any activity at time t. Note that if an employee is unavailable the entire day, then a day-off has to be scheduled. Some employees may be pre-assigned to activities for certain time periods. In this case, finding a schedule that respects this pre-assigned tasks is a part of the problem.The work demand DEa, trepresents the ideal number of employees needed to realize production activity a in the best possible conditions during time period t (see the representation given in Fig. 1). Satisfying exactly the demand is not mandatory : in most cases it is not possible. In this case, either an under-coverage, or an over-coverage is produced. Furthermore, if over-coverage (respectively under-coverage) exceeds the given threshold OVa, t(respectively UNa, t), then it becomes critical and indicates that too many (respectively too few) employees have been assigned to activity a during time period t.Our objective is to construct a feasible team schedule that minimizes the sum of the over-coverage and under-coverage costs for the whole planning horizon and all production activities.A feasible solution follows a hierarchical structure (see Fig. 2). For each level of the hierarchy, there is an associated set of constraints. This flexible structure does not rely on the use of a pre-computed day-shift or individual planning library, since the number of possibilities is far too large.•A team schedule consists of a set of|E|valid employee plannings.An individual planning for employee e is a set of successive day-shifts and days-off over a week. Two consecutive day-shifts are separated by a rest break.A day-off represents a special day when employee e does not participate in any activity. Deciding whether or not an employee takes a day-off is part of the optimization process (but some days-off are mandatory if the employee is unavailable).A day-shift consists of one timeslotor two timeslots separated by a lunch break.A timeslot is a non-empty sequence of tasks where different activities are carried out successively and continuously. Two consecutive tasks cannot be related to the same activity. The set of possible beginning times of all timeslots of employee e is denoted asBe. This set contains disjoint intervals, some of them are for the first timeslot of a day, others are for the second.A task is a time interval where a single activity a is performed over contiguous time periods. Activity a can be either a production activity or a pause.For a given day, an employee works from 8.00 AM to 12.30 AM during his first timeslot, then takes a one-hour lunch break, and finally does his second timeslot from 2.00 PM to 5.00 PM. During the first timeslot, three tasks are performed : from 8.00 to 9.00 in activity a, then from 9.00 to 11.00 in activity b, and finally from 11.00 to 12.30 in activity c. His second timeslot is devoted to the single task with activity b. According to the pause policy, a single pause is assigned from 9:00 AM to 9.15 AM during the first timeslot.In this paper, we take into account constraints that we have encountered in real-life customer contexts. Each employee has his own set of planning constraints and each constraint has its own parameters.At each level of the team schedule hierarchy, duration and numerical constraints have to be satisfied. In Table 1, we list these constraints grouped by levels of the hierarchy. Note that duration of entities possibly include breaks (pauses and lunches), whereas working time equals to the “net duration” that excludes the breaks. Furthermore, an important feature in this problem is that each employee has a target of weekly working time LEethat must be met exactly.We stress the fact that each employee is different: he/she has his own skills, potential pre-assignment and availability for each time period, etc. A day-shift designed for an employee e is not likely to be valid for another employee e′.There are numerous pause assignment policies in practice. In this work, we use the following rules. First, pauses are not included in the working time. There is at most one pause assigned per timeslot. The pause is assigned if and only if the duration of the timeslot is at least four hours (including the pause duration). A pause must be located in the second third of its timeslot, and its duration is exactly one time period. Some pauses can be initially set at some time periods as pre-assignment constraints.In our settings, each pause is positioned inside an existing task k. The two parts of task k before and after the pause are considered as a unique task, i.e. the two constitute a single task with one beginning and one end. Note that pauses are different from lunch breaks in our models: a lunch break separates the day-shift into two timeslots.The Dantzig–Wolfe decomposition (Dantzig & Wolfe, 1960) is well adapted to our scheduling problem, since it consists of disjoint subproblems (one per employee) that are linked by demand constraints. Similar to Dantzig (1954), the subproblem for employee e consists in designing a valid individual planning respecting the specific set of constraints of employee e, but disregarding the requirements dealing with the others plannings. The master problem combines the employee plannings (columns) to minimize the total cost of over-coverage and under-coverage.Another version of the set-covering model for the tour scheduling was proposed by Stolletz (2010). Instead of using variables representing plannings, the author uses (day-)shift variables that are combined in the master problem to form valid plannings. Our problem settings do not allow easy recombinations of shifts: all employees are different and therefore each planning is associated to exactly one employee, and the total number of working periods in a planning is a fixed parameter. In our model, we keep the original planning variables, similar to what is done in Dantzig (1954).LetX(e)denote the set of individual plannings (or columns) for employee e andC(e)its column index set:X(e)={Xc}c∈C(e). Each column Xcis represented by a vector[xc,a,t]t∈T,a∈Awhere:xc,a,t={1ifemployeeisassignedtoactivityaattimeperiodtinplanningc,0otherwise.A binary variable qc,c∈C(e),e∈E,determines whether individual planning Xcis chosen for employee e. Continuous variables ova, t, una, t,ova,tcrit,anduna,tcrit,t∈T,a∈A,represent, respectively, over-coverage, under-coverage, critical over-coverage, and critical under-coverage of the demand of activity a at time period t.The cost function is piecewise linear and its structure is represented in Fig. 3. It depends on slack variables related to demand constraints. For a given solution{qc:c∈C(e),e∈E},for a given production activity a and a time period t, the coverage of the demand can be computed asDEa,t−∑cxc,a,tqc. We distinguish over-coverage ova, t(resp. under-coverage una, t) from critical over-coverageova,tcrit(resp. critical under-coverageuna,tcrit) that occurs when the over-coverage (resp. under-coverage) is greater than OVa, t(resp. UNa, t). When critical over/under-coverage is reached, a larger unit cost has to be paid.The master problem can be formulated as follows:(1)min∑a∈A∑t∈TCOa·ova,t+COacrit·ova,tcrit+CUa·una,t+CUacrit·una,tcrit(2)s.t.∑e∈E∑c∈C(e)xc,a,tqc−(ova,t+ova,tcrit)+(una,t+una,tcrit)=DEa,t∀t∈T,∀a∈A(3)∑c∈C(e)qc=1∀e∈E(4)una,t≤UNa,t,∀t∈T,∀a∈A(5)ova,t≤OVa,t,∀t∈T,∀a∈A(6)qc∈{0,1}∀e∈E,∀c∈C(e)(7)una,t,ova,t∈R+∀t∈T,∀a∈A(8)una,tcrit,ova,tcrit∈R+∀t∈T,∀a∈AThe piecewise objective function (1) minimizes the total cost of over-coverage and under-coverage over the planning horizon and production activities. Constant valuesCOa∈R+andCUa∈R+represent, respectively, the unitary costs of over-coverage and under-coverage for production activity a. Constant valuesCOacrit∈R+andCUacrit∈R+represent respectively the costs of critical over-coverage and under-coverage for production activity a. Critical over-coverage and critical under-coverage have larger costs:CUa<CUacritandCOa<COacrit.Constraints (2) link the decision variables and calculate the gap between the produced work and the work demand DEa, tfor each time period and each production activity. Constraints (3) assign exactly one individual planning to each employee e.The pricing problem decomposes into|E|independent subproblems (one for each employee). Let[πa,t]t∈T,a∈Abe the dual values related to master problem constraints (2) and[πe]e∈Ebe the dual values related to master problem constraints (3). The subproblem for employee e consists in finding a feasible individual planning (denoted by vectorX=[xa,t]t∈T,a∈A) with the minimum reduced cost. We use variables xa, t, which will be used to construct the constant column descriptors xc, a, tin the master problem. Recall thatX(e)denotes the set of individual planning (or columns) for employee e. The subproblem for employee e can be stated as follows.(9)min−πe−∑t∈T∑a∈A(e,t)πa,txa,t(10)s.t.X∈X(e)Acceleration techniques are key elements for the efficiency of our column generation approach. Several papers list strategies for this purpose (see e.gDesrosiers & Lübbecke, 2005), and more specifically for employee scheduling problems in Brunner and Stolletz (2014) and Maenhout and Vanhoucke (2010). We used the following strategies.1.Instead of adding one column with the best reduced cost, we add to the restricted master problem several negative reduced cost columns at each iteration. Practically speaking, at each iteration of the column generation method, we add the best column found for each employee if it has a negative reduced cost. This means that at most|E|columns are added at each iteration. This method dramatically decreases the number of column generation iterations.After solving a restricted master problem, if the number of variables exceeds a given threshold (more than 5000 columns in practice), then we delete all variables with a reduced cost exceeding10−12.The lagrangian lower bound is computed at each iteration to stop the algorithm earlier if this bound and the solution value of the restricted master are equal. The lagrangian lower bound is computed as follows. Let OPT(RMP) be the optimum of the current reduced master problem and RC(SPe) be the best reduced cost of a variable generated by subproblem e at the current iteration. The lagrangian lower bound is equal toOPT(RMP)−∑e∈ERC(SPe).We have also tried to apply dual price smoothing stabilization (Wentges, 1997) in order to accelerate column generation. However, it did not have a clear positive impact on the solution time. Note that (Brunner & Stolletz, 2014) reports very good speed-ups from stabilized column generation in a branch-and-price algorithm for a similar shift scheduling problem. We conjecture that the explanation for this different stabilization impact comes from the presence of the total working time constraint in our variant of the problem. Preliminary experiments showed that the dual price smoothing stabilization improves a lot the column generation solution time once this constraint is removed.We also tried to solve only one pricing subproblem at each step (by considering only one employee), or to add only the column of best reduced cost among all subproblems. In both cases, the method was less efficient. This can be explained by the fact that solving the master problem takes a large amount of time. Moreover, several subproblems are solved in parallel, which helps reducing the time spent to solve all subproblems.A pricing subproblem corresponds to finding the best individual planning for one employee according to his set of constraints. In this section, we discuss two possible ways from the literature to formulate this problem. Then we present our nested dynamic programming algorithm.The pricing subproblem can be formulated as a resource-constrained shortest path problem (RCSPP) in a directed acyclic graph (DAG). In this DAG, each arc is characterized by a cost to use it and a set of resource consumptions while each node is characterized by a position in time and an amount of resource consumption already used for each resource. The objective is to find a path from a source node to a sink node that minimizes the overall cost and satisfies the resource consumption bounds. In Engineer, Nemhauser, and Savelsbergh (2008), the authors present an exact dynamic programming algorithm based on relaxations and alternated forward and backward searches to solve shortest path problems involving a huge number of local resource constraints. This algorithm is much more efficient when only upper bounds are considered. When both lower and upper bounds co-exist, the dominance relations, used to reduce enumeration, are weaker. Another recent work (Lozano & Medaglia, 2012) propose an exact method capable of handling large-scale networks in a reasonable amount of time.In our problem, we have a large number of lower and upper bounds for the resource consumption, and some arc costs are negative. This weakens considerably the dominance rules used in the solution methods for the resource-constraint shortest path problem. Preliminary experiments confirmed that this approach was not efficient for our problem.The structure of individual plannings makes the subproblem suitable for a solution method that uses context-free grammars, like it is done in Boyer et al. (2014); Côté et al. (2013) for a shift scheduling problem (horizon with a single day) and in Restrepo et al. (2015) for a tour scheduling problem (horizon of 7 days). Namely, for each employeee∈Ewe can define a grammar which describes the set of all valid plannings for e. Based on this grammar, a directed acyclic hyper-graph (called graph with or-nodes and and-nodes in (Boyer et al., 2014)) can be constructed. Every unit flow in this hyper-graph defines a feasible individual planning for e. So the search for an individual planning with the best reduced cost can be done using a dynamic programming algorithm that seeks a min cost unit flow in the hyper-graph.We have performed preliminary experiments with this approach and obtained the following results. A considerable number of bound constraints (presented in Table 1) and a long time horizon result in a huge hyper-graph. Therefore, the construction of this hyper-graph takes a large amount of time, making it impossible to embed the grammar-based dynamic program in a fast heuristic. Moreover, even if the graph is constructed, this algorithm takes too much time to be called at every column generation iteration to solve the subproblem.Therefore, we designed a nested dynamic programming algorithm. In order to reduce its running time, we heuristically remove some states, as it is explained below.The specific structure of our problem leads to the following observations.•There are a large number of resource constraints, but only a subset of them are active at a given node.Many paths share identical subpaths. Due to the hierarchical structure of the planning, the best day-shift for a given day is likely to be used in many non-dominated partial solutions.This led us to design an alternative approach based on a nested dynamic program. A relevant and similar approach is described by Dohn and Mason (2013) to find the best individual plannings in a nurse rostering problem by using 3 levels and 2 segmentations. We call segmentation the phase where levels k andk−1are combined. If the number of levels is z, then the number of segmentations should bez−1. In the first segmentation, the method combines day-shifts to design the best feasible sequence, this sequence is completed at the end with days-off to find the best feasible blocks of workdays. In the second segmentation, it combines the block of workdays to get the best individual planning.We have adapted the nested method to the specific features of our problem by using 5 levels and 4 segmentations (Fig. 4). For each employee e, we build an individual planningXc∈X(e)by combining day-shifts constituted by one or several timeslots, themselves composed of tasks. To manage easily path dominance rules and symmetries, the dynamic programming algorithm is segmented into several sub-problems according to the hierarchical structure of the planning. At each level, the design of a given entity consists in combining the valid entities of the level immediately below.The bottom-up presentation of the method consists in calculating the best reduced costs of the following entities: task, timeslot, day-shift and individual planning.For an employeee∈E,let αe(b, f, a) be the reduced cost of the task in which the employee starts activitya∈Aat period b, and finishes it at period f. Note that this task is valid for the employee, if it respects the duration bounds and employee skills and pre-assignments. We set the reduced cost of an invalid task to+∞. Then, the formula for the reduced cost calculation is:(11)αe(b,f,a)={−∑t=bfπa,t,if{f−b+1}∈[DKea−,DKea+],a∈A(e,t),∀t∈[b,f];+∞,otherwise.For an employeee∈E,letβ¯e(b,f,n,a)be the best reduced cost of a partial timeslot, which starts at period b, finishes at period f, contains a sequence of n consecutive tasks, the first of which does not perform activity a. The following recursion formula is used for the reduced cost calculation:β¯e(b,f,n,a)={mina′≠a{αe(b,f,a′)},ifn=1;minf′∈[b,f−1],a′≠a{αe(b,f′,a′)+β¯e(f′+1,f,n−1,a′)}otherwise.We denoteβ¯e(b,d,n,−)the best reduced cost without imposing the constraint on the first task activity:β¯e(b,f,n,−)=mina∈Aβe(b,f,n,a).Let nowβ^e(b,f)be the best reduced cost of a complete timeslot, which starts at period b and finishes at period f. Note that this timeslot is valid for the employee, if its starting time is inBe,it respects the completion and duration bounds, and the bounds on the number of tasks it contains. We set the reduced cost of an invalid timeslot to+∞. Then, the formula for the reduced cost calculation is:(12)β^e(b,f)={minn∈[NOeb−,NOeb+]{β¯e(b,d,n,−)},ifb∈Be,f∈[FOeb−,FOeb+],+∞,otherwise.Note that at this moment the pause policy may not be respected, as until now pauses are not included in timeslots. After calculating valuesβ^,every timeslot without a pause and lasting more than four hours is replaced by one timeslot with a pause. For practical purposes, this is done in a greedy manner: we put the pause to a period in the second third of the timeslot such that its reduced cost is minimized. The pause replaces the corresponding work period such that the duration of timeslot is not increased. Note that this greedy approach for inserting pauses makes the whole dynamic programming procedure heuristic (sub-optimal solutions may be generated).If a pre-assigned pause is contained inside a timeslot, and it is not positioned in the second third of it, such a timeslot is declared invalid, and its cost is set to+∞. The same happens if the employee cannot take any pause (P(e,t)is empty for all time moments in the second third of the timeslot).Let βe(b, f) be the best reduced cost of a timeslot, which starts at period b, finishes at period f, and respects the pause policy. Let ℓ(b, f) be this timeslot’s working time, which can be uniquely determined from its duration (f−d+1) according to the pause policy.For an employeee∈E,letδeκ(d,b,f,ℓ)be the best reduced cost of a day-shift of day d that starts at period b, completes at period f, contains κ timeslots and ℓ working periods. A valid day-shift should satisfy starting, completion, working time bounds and the daily pre-assignments. Let set Ωedcontain the set of valid triples (b, f, ℓ):Ωed={(b,f,ℓ):b∈[BDed−,BDed+],f∈[FDed−,FDed+],ℓ∈[LDed−,LDed+],f−b+1≤DDed+}.The formula for the day-shift containing one timeslot is:(13)δe1(d,b,f,ℓ)={βe(b,f),if(b,f,ℓ)∈Ωed,ℓ=ℓ(b,f);+∞,otherwise.The formula for the day-shift containing two timeslots separated by a lunch break is:(14)δe2(d,b,f,ℓ)=minf′,b′{βe(b,f′)+βe(b′,f),if(b,f,ℓ)∈Ωed,ℓ=ℓ(b,f′)+ℓ(b′,f),{b′−f′−1}∈[RDed−,RDed+],ℓ(b,f′)≥TDedorℓ(b′,f)≥TDed;+∞,otherwise.The best reduced cost δe(d, b, f, ℓ) of a day-shift with one or two timeslots can now be computed :δe(d,b,f,ℓ)=min{δe1(d,b,f,ℓ),δe2(d,b,f,ℓ)}.In this step, we seek the best combination of day-shifts and days-off that designs a valid individual planning for employee e given its total working time LEeand its number of day-shifts in[NEe−,NEe+]. This is also called a tour scheduling problem for a single employee.For an employeee∈E,letη¯e0(d,n,ℓ)be the best reduced cost of a partial employee planning for the first d days, which contains n day-shifts and ℓ working periods, and ends with a day-off. Let alsoη¯e1(d,f,n,ℓ)be the best reduced cost of a partial employee planning for the first d days, which contains n day-shifts and ℓ working periods, and ends at period f with a day-shift. These reduced costs are calculated using the following recursions. We setη¯e0(0,0,0)=0,all other valuesη¯e0(0,f,ℓ)are set to+∞. Also we setη¯e1(d,f,n,ℓ)=+∞if d ≤ 0 orf∉[FDed−,FDed+].The formula forη¯e0(d,n,ℓ)is the following:η¯e0(d,n,ℓ)=min{η¯e0(d−1,n,ℓ),minf{η¯e1(d−1,f,n,ℓ)}}The formula forη¯e1(d,f,n,ℓ),f∈[FDed−,FDed+],is:(15)η¯e1(d,f,n,ℓ)=min{η^e0(d,f,n,ℓ),minf′∈[FDe,d−1−,FDe,d−1+]{η^e1(d,f′,f,n,ℓ)}},whereη^e0(d,f,n,ℓ)is the best reduced cost with the condition that the employee had a day-off on dayd−1,andη^e1(d,f,f′,n,ℓ)is the best reduced cost with the condition that the employee had a day-shift of dayd−1finishing at time f′.η^e0andη^e1are computed as follows:η^e0(d,f,n,ℓ)=minb∈[BDed−,BDed+],ℓ′∈[LDed−,LDed+]{η¯e0(d−1,n−1,ℓ−ℓ′)+δe(d,b,f,ℓ′)},(16)η^e1(d,f′,f,n,ℓ)=minb∈[max{f′+REe−,BDed−},BDed+],ℓ′∈[LDed−,LDed+]×{η¯e1(d−1,f′,n−1,ℓ−ℓ′)+δe(d,b,f,ℓ′)}.During this step, the algorithm deals also with the maximum number of successive day-shifts without day-off. In recursion (15),η¯e1(d,f,n,ℓ)should be writtenη¯e1(d,f,n,m,ℓ),where m is the number of consecutive day-shifts ending at day d such thatm≤MEe+. However, we decided to omit the full recursion for the sake of simplification.The best reduced cost ηeof an individual planning for employee e can be computed using the following formula:ηe=minn∈[NEe−,NEe+]{η¯e0(D,n,LEe),minf∈[FDD−,FDD+]η¯e1(D,f,n,LEe)}.Our pricing algorithm is already a heuristic because of the simplified handling of the pauses. We now introduce a slight restriction of the state space, which also makes the method heuristic. As was mentioned above, the nested dynamic programming algorithm takes too much time because of a large number of states. In order to accelerate the algorithm, we heuristically delete some states. Namely, the set of states {δe(d, b, f, ℓ)}∀d, b, f, ℓ is reduced to the set of states {δe(d, b, ℓ)}∀d, b, ℓ in the following way:δe(d,b,ℓ)=minf∈[FDed−,FDed+]δe(d,b,f,ℓ).Letf*(d,b,ℓ)=argminfδe(d,b,f,ℓ). Then the formula (16) is changed toη^e1(d,f′,f,n,ℓ)=minb∈[max{f′+REe−,BDed−},BDed+],ℓ′∈[LDed−,LDed+]:f*(d,b,ℓ′)=f×{η¯e1(d−1,f′,n−1,ℓ−ℓ′)+δe(d,b,f,ℓ′)}.At the end of the column generation method, the obtained solution may be non-integer. To get a good integer solution, we use an enumerative branch-and-price like method. By abuse of language, we will use the term branch-and-price even if the pricing subproblem is solved heuristically. Our branch-and-price is not always able to terminate within the time limit. Since our algorithms are designed for practical use, we also propose two different heuristics to find good solutions in less time.Our branching scheme consists in fixing a variable xc, a, tfor all candidate columns Xcrelated to a given employee e. In the formulation, this branching is accomplished as follows:•xc,a,t=0forbids employee e to be assigned to activity a at time period t. We delete all columns Xc,c∈C(e),in which activity a is performed during period t. In the pricing subproblem for employee e, the corresponding transition is forbidden.xc,a,t=1assigns employee e to production activity a at time period t. We delete all columns Xc,c∈C(e),in which activity a is not performed at period t. The subproblem for employee e is modified by assigning a very large negative cost to the corresponding transition.When branching, we choose the triplet (employee e, production activity a and time period t) which is the most fractional, i.e. for which|0.5−∑c∈C(e)xc,a,tqc|is minimum (where qcis determines whether individual planning Xcis chosen for employee e, as defined above). We use a depth-first strategy to explore the search tree. We tried different strategies (sometimes mixed together): branching on the slack variables (under or over-coverage variables), or branching on entities (forcing/forbidding an employee to work during a given day or time-slot). However, we do not have convincing results which show an advantage of these strategies over the scheme above.The time allowed at each node of the branch-and-bound tree was limited to one hour. In rare cases, this results in premature termination of column generation at some nodes. In that case, our heuristic branch-and-price continues and carries out its branching strategy.The heuristic dynamic programming algorithm for the subproblem makes our branch-and-price algorithm also heuristic. This means that theoretically there exist test instances for which the solution found is not optimal even after termination of the branch-and-price. However, for our test instances that are solved both by the branch-and-price and the MIP solver applied to the compact formulation, the obtained solution values are equal.The diving heuristic is an algorithm in which the branch-and-price tree is searched partially (see Joncour, Michel, Sadykov, Sverdlov, and Vanderbeck, 2010 for details). As usually done in diving heuristics, we use a different branching strategy for the diving, as the goal here is not to have a balanced search tree, but a good feasible solution quickly. As suggested in Joncour et al. (2010), at each node, after the termination of column generation, we select and fix a columnXc′,i.e. we select a complete planning for employee e′ such thatc′∈C(e′). After that, all columns Xc,c∈C(e′),are excluded from the problem, demands DEa, tare updated according to the fixed partial solution. Then, the subproblem for employee e′ is not called in descendant nodes.As no backtracking occurs, the method stops after at most|E|nodes. In our algorithm, we select the column related to the variable with the largest value in the solution of the master problem.To obtain a fast heuristic, we introduce the time limit for column generation at each node of the diving heuristic. When this time limit is reached, we use the current master solution values for fixing the next column, even if this solution is not optimal.When the time limit is set to a handful of seconds, the diving heuristic may not be able to terminate. We propose a simple heuristic based on our pricing subproblem to find good solutions in a small amount of time. In this heuristic, the employee plannings are still computed by our dynamic program, but the plannings are individually generated one by one and added iteratively to the solution. Here, the objective function of the subproblems is based on the residual work demand REa, t, which corresponds to the remaining work demand, taking into account the individual plannings already in the current partial solution. Each time an individual planning is computed, the residual work demand REa, tis updated, and the method is run again with the remaining set of employees.At initialization, REa, thave the same value as the work demand DEa, tand they are updated each time a planning is added or deleted in the team schedule. In the objective function of the subproblem for employee e, the costπ^a,tof variable xa, t, which determines whether activity a is performed during time period t, is calculated by the relation:(17)π^a,t={−REa,t/DEa,t−1ifREa,t≥0−REa,t/DEa,totherwiseThe greedy heuristic is presented formally in Algorithm 1. The first iteration is complete when the first complete solution is constructed. Then we perform additional iterations in which, for each employee, the current individual planning is deleted from the solution and another planning is computed based on the updated residual work demand. Initial employees sorting, objective function costs and the number of iterations are parameters of the algorithm.Despite our efforts, we did not find a particular sorting algorithm for employees that gave better results than others on average. So we use Algorithm 1 several times with different random orders on the employees, and keep the best result found. Empirical tests suggest that after three iterations, the solution is usually not improved anymore.Our four methods, solving MIP compact model by a commercial solver, the branch-and-price algorithm, the diving heuristic, and the greedy heuristic have been tested on both real data coming from a customer and randomly generated data. The MIP compact model is described in the electronic supplement.Our customer data comes from a company of mini-marts. All instances are defined over one week divided into 15 minutes periods. In the customer data, almost 10% of employees work only on Saturday, while the others may work at most five days. Around 70% of the employees can only perform one type of production activity. Most of the employees have a small flexibility in their schedule: general beginning and finishing time of timeslots can be shifted by one hour (for instance, the first timeslot of a day-shift starts between 8.00 AM and 9.00 AM for a given employee, but this range can be different for another day).The cost coefficients in the objective function are the following: over-coverageCOa=1,critical over-coverageCOacrit=2,under-coverageCUa=2,critical under-coverageCUacrit=5. For a work demand of DEa, t, critical over-coverage occurs when strictly more thanOVa,t=DEa,t+1employees are assigned to production activity a at time period t, while critical under-coverage occurs when strictly less thanUNa,t=⌈DEa,t/2⌉employees are assigned to the activity. We use a representative set of twelve customer data. They have a different number of employees|E|,and a different number of production activities|A|.We ran different methods on the customer data: the greedy heuristic (Section 5.3), dive120, dive600 and dive1800 (the diving of Section 5.2 with the cumulated column generation time limit of 120, 600 and 1800 seconds, respectively) and the branch-and-price algorithm (Section 5). In the method diveT, we limit the column generation time at each node toT/|E|seconds. As the diving requires at most|E|nodes for a new solution, diveT lasts at most T seconds (plus additional time for initialization of the different nodes). The best solution found by heuristics dive120, dive600 and dive1800 is used for the initialization of the branch-and-price. The time reported for the branch-and-price does not include the time spent by the heuristic. All tests were run using a standard PC of the experimental platform “Plafrim” (see Acknowledgment) with 4 gigabits of memory over four cores (four subproblems are solved in parallel). All methods were implemented in Java and IBM Cplex 12.6 was used for solving the MIP and the linear master problems.Tables 2and 3summarize the results obtained (respectively the objective function value of the solution found, and the execution time) with our customer data. In column “LBLagr”, we report the Lagrangian lower bound (see Section 3.3) computed at the root node of the B&P. Recall that|E|is the number of employees, and|A|the number of production activities. Column “LBTriv” is a trivial lower bound computed in the following way. Let L be the cumulated working time of the team (measured in time periods):L=∑e∈ELEe. Let also D be the cumulated demand (measured in time periods):D=∑t∈T∑a∈ADEa,t. If D ≥ L then the solution value cannot be less thanLBTriv=mina∈A{CUa}×(D−L). If D < L then the solution value cannot be less thanLBTriv=mina∈A{COa}×(L−D). The trivial lower bound is quite far from the Lagrangian bound for the customer data instances with 5 activities.The running time of the greedy heuristic is very small, even for instances with 45 employees. The difference between the value of the greedy solution and the optimal one can be large. However, recall that simple constructive heuristics may fail to find feasible shifts, since assigning too much or too few hours at the beginning of the week may not allow to find a solution that respects all bound constraints. Moreover, the piecewise linear cost function will take a large value even if most of the working demand is fulfilled.The diving heuristics are much more effective to find near optimal solutions for these instances. The relative gap of the dive120 heuristic with the branch-and-price is greater than 10% only for two instances (A3_2 and A5_6). It may happen that the diving gives better results when a smaller computing time is set (A3_5, A3_9 and A5_1). However, different experiments, not reported here, showed that giving more time to the diving heuristic at each node generally improves the result.The branch-and-price method terminates for five instances out of twelve within 24 hours of computation time. For three instances the bounds are tight at the root node, for two instances the root ”lower bound” was improved (recall that the pricing is performed heuristically), for one instance the initial upper bound was improved, and for one instance both bounds were improved by branch-and-price. For five instances out of the remaining six, branch-and-price improves the upper bound before hitting the time limit. Note that when the MIP solver is able to find an optimal solution, its value is equal to the solution value found by the heuristic branch-and-price.Over the twelve instances, the compact method gives optimal solutions for the four smallest ones. Feasible solutions were found within 24 hours for all instances, except for the two largest ones. Actually, the higher the number of employees is, the lower is the quality of the found solution. Furthermore, we note that the MIP solver is outperformed by the heuristic dive120 in terms of execution time and quality of the solution.Experiments show that our algorithms have a good behavior on confidential customer data. In order to allow a fair comparison with our methods, and push further the analysis, we have designed a random data generator based on our customer data experience. The setting of parameters is performed using four following inputs: the number of employees|E|,the number of production activities|A|,the flexibility index of employees F and the under-coverage index G.The planning horizon is fixed to 7 days, and time periods have a length of 15 minutes. All employees are multi skilled, i.e. they can work in all production activities. Costs of over-coverage (COa,COacrit) and under-coverage (CUa,CUacrit) and related thresholds (UNa, t, OVa, t) are fixed as in the customer data. Flexibility index F of employees affects all employee planning constraints, limiting the accessible time periods. The higher this index is, the higher is the number of allowed time periods for a given employee. For example, all first timeslots must start between[[8.00−R1,8.30+R2]]where R1, R2 are random values uniformly distributed in {0, 15, ..., F*15}. Under-coverage index G takes a value between 0 and 4 and determines the work demand DEa, t. To create a work demand, a team with(|E|+G)employees is initialized and planned in a random order with an initial random work demand. Obtained plannings are thus used to define the work demand DEa, tthat corresponds exactly to the work capacity of the(|E|+G)employees. We then randomly remove G employees in the team in such a way that the work demand could not be covered by the final team of employees: results will present under-coverage. Note that there exists a solution of value zero ifG=0.Tables 4–6sum up the results obtained with the generated data. The results are reported in the same way as those obtained for the customer cases. It transpires from our results that the structure of the data strongly impacts the algorithms behavior. As one would expect, the computing time depends on the number of employees to schedule, and the number of production activities. Flexibility is also a difficulty factor: it increases the number of possible shifts, and makes the dynamic program slower.The tests on generated data confirm the conclusion drawn on the customer data. We observe that the “lower bound” obtained at the root node of the heuristic branch-and-price still has a very good value, i.e. it is often close or equal to the optimal solution or the best solution found, and the final absolute gap is small, except for the instances with a large size, and a large flexibility (dst8, dst10, and dst16).The greedy heuristic is fast and the quality of the planning is good but rarely optimal. The diving heuristic gives results that are close to those of the branch-and-price in most cases (the results are even optimal for small data). Similar to what happens with the customer instances, giving more time at each node of the diving clearly improves the results on average, although it may happen (dts7) that better results are obtained when less time is allowed.A specificity of generated data instances is that the trivial lower bound is very close to the Lagrangian one and the optimal solution. Moreover, the bounds are equal for most of the instances. When this is the case, it is quite easy to find an optimal dual solution π (optimal Lagrangian multipliers) for the column generation algorithm. However, even when an optimal dual solution is known, it takes a large number of iterations to find an optimal primal solution of the linear relaxation of the master problem. This fact explains why known stabilization techniques such as dual smoothing do not improve convergence of column generation. They are aimed at stabilizing around the best dual solution. This does not help in our case as the optimal dual solution is already known.

@&#CONCLUSIONS@&#
