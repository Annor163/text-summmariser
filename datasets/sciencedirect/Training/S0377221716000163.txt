@&#MAIN-TITLE@&#
Two-agent scheduling in a flowshop

@&#HIGHLIGHTS@&#
Address the two-agent flowshop problem to minimize the weighted sum of some criteria.It is shown that the problems under study are intractable.Two approximation algorithms based on Johnsons rule and linear programming.Optimal algorithms for some practical and meaningful special cases.

@&#KEYPHRASES@&#
Scheduling,Competitive agents,Flowshop,Approximation algorithm,

@&#ABSTRACT@&#
In this paper we study two-agent scheduling in a two-machine flowshop. The cost function is the weighted sum of some common regular functions, including the makespan and the total completion time. Specifically, we consider two problems, namely the problem to minimize the weighted sum of both agents’ makespan, and the problem to minimize the weighted sum of one agent’s total completion time and the other agent’s makespan. For the first problem, we give an ordinary NP-hardness proof and a pseudo-polynomial-time algorithm. We also analyze the performance of treating the problem using Johnson’s rule and propose an approximation algorithm based on Johnson’s rule. For the second problem, we propose an approximation algorithm based on linear programming relaxation of the problem. Finally, we show that some simple algorithms can be used to solve special cases of the two problems.

@&#INTRODUCTION@&#
In recent years there has been significant interest in multi-agent scheduling, in which each agent owns a family of jobs and seeks to optimize its own goal associated with its family of jobs. Scheduling problems involving multiple agents competing for a common processing resource often arise in real practice in which negotiation is needed. For example, consider a machine that is subject to preventive maintenance at regular times. A number of maintenance tasks have to be performed on the machine in given time windows, each of which is specified by a release date and a due date. Suppose that the maintenance department (call it agent B) is charged with performing the maintenance tasks on the machine, while the production department (call it agent A) is responsible for scheduling a set of jobs on the machine for processing. The maintenance tasks must be scheduled within their respective time windows, while the jobs are to be scheduled on the machine when it is free (i.e., not undergoing maintenance) to process jobs so that a given objective function is optimized (Leung, Pinedo, & Wan, 2010). In telecommunication services, the problem is to do with satisfying the service requirements of individual agents, which compete for the use of a commercial satellite to transfer voice, image, and text data for their clients (Schultz et al., 2002). The problem is to fulfill the requirements of various integrated services. Two models are distinguished in the extant literature on multi-agent scheduling. One is to deal with the weighted sum problem, which seeks to optimize the weighted sum of the agents’ objectives (see Baker & Smith, 2003). The other is to solve the constrained optimization problem, which seeks to optimize one agent’s objective, subject to the other agent’s objective not exceeding a given limit (see Agnetis, Mirchandani, Pacciarelli, & Pacifici, 2004). In this paper we focus on the weighted sum problem of two-agent scheduling in a two-machine flowshop.The multi-agent scheduling problem was first introduced by Baker and Smith (2003) and Agnetis et al. (2004). Baker and Smith (2003) study the problem of minimizing a linear combination of the objective functions of two or more agents on a single machine. They consider minimizing an aggregate scheduling objective function under which the jobs belonging to different agents are evaluated based on their individual criteria. Agnetis et al. (2004) study constrained optimization and Pareto optimization of two-agent scheduling in various machine settings. Studying single-machine scheduling with multiple agents, Agnetis, Pacciarelli, and Pacifici (2007) consider objective functions that are the maximum of regular functions, including the number of tardy jobs and the total weighted completion time. Cheng, Ng, and Yuan (2006) consider multi-agent single-machine scheduling, where each agent’s objective function is to minimize the total weighted number of its tardy jobs. In addition, Cheng, Ng, and Yuan (2008) study multi-agent single-machine scheduling where the objective functions of the agents are of the max-form. Ng, Cheng, and Yuan (2006) study the problem of minimizing the total completion time of one agent, subject to the number of tardy jobs of the other agent cannot exceed a given limit. Leung et al. (2010) extend the models in Agnetis et al. (2004) to the identical parallel-machine setting with two agents, where the jobs of the two agents may have distinct release dates and preemption is allowed.Mor and Mosheiov (2010) discuss the problem of minimizing the maximum earliness cost or the total (weighted) earliness cost of one agent, subject to an upper bound on the maximum earliness cost of the other agent. Nong, Cheng, and Ng (2011) study the problem to minimize the total cost comprising the maximum weighted completion time of one agent and the total weighted completion time of the other agent. Wan, Vakati, Leung, and Pinedo (2010) consider scheduling models with controllable job processing times on a single machine or two identical parallel machines, where the processing times of the jobs of one agent are compressible at additional costs. Liu, Zhou, and Tang (2010) consider two-agent single-machine scheduling with position-dependent processing times. Mor and Mosheiov (2011), Li and Yuan (2012), and Fan, Cheng, Li, and Feng (2013) consider multi-agent scheduling on a single batching machine. Oron, Shabtay, and Steiner (2015) study various two-agent scheduling problems on a single machine with equal job processing times.Flowshop scheduling has attracted much research attention since Johnson (1954) pioneered this line of research. However, multi-agent scheduling in the flowshop setting has received little research as of now. Agnetis et al. (2004) are probably the first researchers who study two-agent scheduling in the two-machine flowshop. Considering the problem in which both agents seek to minimize their makespan, they show that simple as it is the problem is NP-hard. Lee, Chen, Chen, and Wu (2011) consider two-agent two-machine flowshop scheduling to minimize the total completion time of one agent with no tardy jobs for the other agent. They develop a branch-and-bound algorithm and a simulated annealing heuristic algorithm for the problem. Most recent development of this topic can be found in the first volume of Agnetis, Billaut, Gawiejnowicz, Pacciarelli, and Soukhal (2014) and Perez-Gonzalez and Framinan (2014).In this paper we study two-agent scheduling in a two-machine flowshop to minimize the weighted sum of both agents’ objectives. We analyze the complexity of the problems under study and provide approximation algorithms for the general cases of the problems. For the intractable problems, we identify some polynomially solvable special cases. It should be noted that the purposes of studying special cases of the problems are two-folds: (i) It is meaningful from a theoretical point of view to give a boundary on the problems in P and those in NP. For example, when certain restrictions are imposed on the processing times of the jobs, a problem becomes polynomially solvable, while when the restrictions are slightly changed, the problem remains NP-hard. (ii) While some of the special cases are hypothetical, some other cases are very practical, e.g., jobs of the same type have the same processing time. This is observed in real practice of semiconductor manufacturing where a facility typically produces fewer than ten distinct circuit types at a time.The rest of the paper is organized as follows: In Section 2 we introduce some notation and a dominant structure for all the problems studied in this paper. In Section 3 we consider the problem to minimize the weighted sum of both agents’ makespan. We show that the problem is NP-hard and provide a pseudo-polynomial dynamic programming algorithm to solve it. We also provide approximation algorithms based on Johnson’s rule and analyze their worst-case error bounds. In Section 4 we consider the problem to minimize the weighted sum of one agent’s makespan and the other agent’s total completion time. We give an approximation algorithm based on linear programming relaxation of the problem. Furthermore, we prove that some simple algorithms can be used to solve special cases of the two problems. Finally, we conclude the paper and suggest topics for future research in Section 5.There are two agents, namely A and B, each of which has to schedule its own family of nonpreemptive jobs in a two-machine flowshop. The job families of agents A and B are denoted byJA={J1,…,JnA}andJB={J1,…,JnB},respectively. Associated with each jobJiXare two processing timespi1Xon machine M1 andpi2Xon machine M2, where X ∈ {A, B}. For convenience, we also usepi1Xandpi2Xto represent the first and the second operation of jobJiX,respectively. All the jobs are available for processing from time zero onwards. The problem is to find a schedule that minimizes the weighted sum of the two agents’ cost functions, i.e.,γA+αγB,where α (α > 0) is a given constant representing the decision maker’s relative preference between the two agents, and γAand γBdenote the objective functions of agent A and B, respectively. We denote the problem byF2∥γA+αγB.Let σ denote a feasible schedule of all the jobs ofJ=JA⋃JB. Setn=|J|,wheren=nA+nB. The starting time and the completion time of jobJiXon Mjin σ are denoted bysijX(σ)andCijX(σ),respectively. ThenCi1X(σ)≤si2X(σ)always holds for each job. We consider two of the most commonly used criteria in flowshop scheduling, namely the makespanCmaxXand the total completion time∑Ci2X(σ). For the objective∑Ci2A(σ)+α∑Ci2B(σ),the two-agent problem is equivalent to problem F2||∑wiCi2(σ) by dealing with α as the weight of the jobs of agent B. Hence, we consider the following two problems:•F2∥CmaxA(σ)+αCmaxB(σ).F2∥∑Ci2A(σ)+αCmaxB(σ).For ease of exposition and when there is no risk of confusion, we use X-job to denote a job of agent X, the index setN(JX)={1,…,nX}to denote the jobs setJX={J1X,…,JnXX},X ∈ {A, B}, and similarly for the other sets of jobs and their indices. We also use the following notation:•i denotes the i-job Ji,i∈N(J),and pijdenotes the processing times of i on Mjforj=1,2.X¯denotes an agent that is different from agent X, X ∈ {A, B}, i.e.,X¯=AifX=B,andX¯=BifX=A.sijandsijXdenote sij(σ) andsijX(σ)forj=1,2,respectively.Cij,CijX,CmaxX,and∑CijXdenote Cij(σ),CijX(σ),CmaxX(σ),and∑CijX(σ)forj=1,2,respectively. Especially, Ci,CiX,and∑CiXdenote Ci2(σ),Ci2X(σ),and∑Ci2X(σ),respectively.In this section we consider the case with the simplest objective function, i.e., Cmax . We first analyze the complexity of the problem. We then provide an approximation algorithm based on Johnson’s rule for the problem and analyze its worst-case error bound. Finally, we consider two polynomially solvable special cases.We first show that even this simple case of the problem is NP-hard by performing a reduction from the following well-known NP-complete problem (Garey & Johnson, 1979).Partition. Given k positive integersu1,…,ukwith∑i=1kui=2Q,is there a subset S of the index set{1,…,k}such that∑i∈Sui=Q?Theorem 3.1ProblemF2∥CmaxA+αCmaxBis NP-hard even if there is only one B-job andα=1.The decision version of the problem is clearly in NP. For a given instance of Partition withu1,…,ukand Q, we construct an instance of the decision version of problemF2∥CmaxA+CmaxBas follows:There are a total ofk+1jobs, among whichnA=kjobs belong to agent A with processing timespi1A=ϵon the first machine andpi2A=uion the second machine fori=1,…,k,whereϵ=12k+1. Agent B has only one job with processing timep1B=Q−(k−1)ϵon the first machine andp2B=ϵon the second machine. The threshold value is given asY=3Q+4ϵ.The above construction can be completed in polynomial time. Next we show that the Partition instance has a feasible solution if and only if there exists a feasible schedule σ for the scheduling instance such thatCmaxA(σ)+CmaxB(σ)≤Y.Given a feasible solution S for the Partition instance, we can define a feasible schedule σ for the scheduling instance as follows: On the first machine, sequence all the A-jobs before the B-job; On the second machine, sequence the A-jobs of{JiA|i∈S}before the B-job and the others after the B-job.Note that the A-jobs can be processed from time ϵ on the second machine in σ. By∑i∈Spi2A=Q,we have that the completion time of the B-job in σ isCmaxB(σ)=max{∑i=1kpi1A+p1B,ϵ+∑i∈Spi2A}+p2B=Q+2ϵ,where∑i=1kpi1A+p1B=Q+ϵis the completion of the B-job on the first machine andϵ+∑i∈Spi2A=Q+ϵis the completion time of the A-jobs of{JiA|i∈S}on the second machine. The completion time of the A-jobs isCmaxA(σ)=CmaxB(σ)+∑i=1,i∉Skpi2A=2Q+2ϵ.Then the objective value of σ for the scheduling instance isCmaxA(σ)+CmaxB(σ)=3Q+4ϵ=Y.Conversely, suppose that there is a feasible schedule σ for the scheduling instance withCmaxA(σ)+CmaxB(σ)≤Y. Let S1 be the set of A-jobs sequenced before the B-job on the second machine in σ. SetS2={1,…,k}∖S1. That is, the A-jobs of S2 are sequenced after the B-job on the second machine. We now show that ⟨S1, S2⟩ is a solution for the Partition instance.Note that the total processing time of all the jobs on the second machine is∑i=1kpi2A+p2B=2Q+ϵ. We can claim that the last job in σ is an A-job on the second machine. In fact, if the last job on the second machine is the B-job, the completion time of the B-job is at least2Q+ϵ. Then the objective value of σ isCmaxA(σ)+CmaxB(σ)≥2Q+ϵ+∑i=1kpi2A=4Q+ϵ>Y,a contradiction.It follows from the claim thatCmaxA(σ)≥2Q+ϵ. Byp1B=Q−(k−1)ϵandp2B=ϵ,we have thatCmaxB(σ)≥Q−(k−2)ϵ. SinceCmaxA(σ)+CmaxB(σ)≤Y,we have that(1)CmaxB(σ)≤Y−CmaxA(σ)≤Y−(2Q+ϵ)=Q+3ϵand(2)CmaxA(σ)≤Y−(Q−(k−2)ϵ)=2Q+(k+2)ϵ.From (1) and (2) and the claim, on the second machine, the total processing times of the A-jobs of S1 and S2 in σ, respectively, are∑i∈S1pi2A=∑i∈S1ui≤⌊CmaxB−p2B⌋≤⌊Q+2ϵ⌋=Qand∑i∈S2pi2A=∑i∈S2ui≤⌊CmaxA(σ)−CmaxB(σ)⌋≤⌊2Q+(k+2)ϵ−(Q−(k−2)ϵ)⌋=⌊Q+2kϵ⌋=Q.The last equality in the above formulas follows fromϵ=12k+1. Therefore∑i∈S1ui=Q. Consequently, ⟨S1, S2⟩ is a solution to the Partition instance.□We next provide a pseudo-polynomial-time algorithm for problemF2∥CmaxA+αCmaxB. The corresponding (single-agent) flowshop scheduling problem F2||Cmax  is well known and polynomially solvable by Johnson’s rule (Johnson, 1954). Johnson’s rule can be stated as follows:Johnson’s rule (JR): Sequence job Jibefore job Jjif min {pi1, pj2} < min {pi2, pj1}. If there is equality, either sequence is optimal.In fact, Johnson’s rule can be implemented in an easier way (Lee, 1999) as shown in the following: Divide all the jobs into two disjoint subsets, namely S1 and S2, whereS1={Ji:pi1≤pi2}andS2={Ji:pi1>pi2}. Process the jobs in S1 in nondecreasing order of pi1 and jobs in S2 in nonincreasing order of pi2. Sequence jobs in S1 first, followed by S2.We next establish a critical dominance property that reduces an instance of problemF2∥CmaxA+αCmaxBessentially to a partitioning problem. First, we extend an optimality property developed by Johnson (1954) to our problem.Lemma 3.2For problemF2∥CmaxA+αCmaxB,there exists an optimal schedule in which the processing order of all the jobs is the same on both machines.For any feasible schedule σ, if the processing sequences on the two machines are different, then the first jobs out of sequence will be scheduled as follows:σ(M1)=α(1)Jiβ(1)Jjγ(1),σ(M2)=α(2)Jjβ(2),where α(i), β(i), and γ(1) are partial schedules,i=1,2,andα(1)=α(2). Since Jjstarts on M2 after Jjfinishes on M1 and{Ji}⋃{Jk|k∈β(1)}∈{Jk|k∈β(2)},we can make the processing sequence of the jobs on M1 asσ′(M1)=α(1)JjJiβ(1)γ(1)without loss of time. By making successive interchanges and starting from the left of σ, we can obtain the required schedule.□Note that single-agent two-machine flowshop scheduling with nonsimultaneous machine available times t1 and t2, denoted by F2, tj||Cmax , can still be solved in polynomial time. We have the following result, which can be proved by adding one job with processing times 0 on M1 andt2−t1on M2 (Lee, 1997).Lemma 3.3Problem F2, tj||Cmaxcan be solved by using Johnson’s rule to sequence the jobs, where tj denotes the available time of Mj,j=1,2.LetJ1andJ2be two disjoint subsets ofJandJ=J1⋃J2. If eitherJ1contains all the A-jobs andJ2consists of B-jobs only, orJ1contains all the B-jobs andJ2consists of A-jobs only, we call〈J1,J2〉a feasible partition of all the jobs ifJ2is not empty. We establish the following dominance property for problemF2∥CmaxA+αCmaxB.Theorem 3.4For problemF2∥CmaxA+αCmaxB,there exists an optimal scheduleσ=(σ(1),…,σ(k),σ(k+1),…,σ(n))such that the jobs corresponding to the indices{σ(1),…,σ(k)}are sequenced according to Johnson’s rule, and the remaining jobs are also sequenced according to Johnson’s rule, where Jσ(k)is the last completed job of one of the agents and σ(k) is the index of the kth job in σ.Suppose thatσ=(σ(1),…,σ(k),σ(k+1),…,σ(n))is an optimal schedule for problemF2∥CmaxA+αCmaxB. Without loss of generality, assume that Jσ(k) is the last A-job. Then the makespan of agent A is Cσ(k). From Lemma 3.2, we can partition all the jobs into two sets according to Jσ(k). It is clear that, in any optimal schedule, the jobs of{σ(1),…,σ(k)}should be sequenced according to Johnson’s rule. Otherwise, we can re-arrange the jobs by Johnson’s rule such that the completion time of the jobs on M1 is unchanged and the makespan of agent A is either smaller or unchanged. Similarly, the jobs after Jσ(k) should be processed according to Johnson’s rule by Lemma 3.3.□Refer to a schedule that corresponds to a partition〈J1,J2〉with the property specified in Theorem 3.4 as a Johnsonian schedule. In such schedule, the jobs ofJ1andJ2are sequenced according to Johnson’s rule, respectively. Now assume that all the jobs have been re-indexed according to Johnson’s rule. Next, we restrict our attention to the Johnsonian schedules which is associated with a partition〈J1,J2〉in this subsection.LetJS(J1)andJS(J2,t1,t2)denote the makespans of the two agents in Johnsonian schedules, wheret1=∑i∈N(J1)pi1andt2=JS(J1). That is, t1 is the available time of M1 and t2 the available time of M2 for the jobs ofJ2. IfJ1contains all the A-jobs, from Theorem 3.4, we have thatCmaxA=JS(J1)andCmaxB=JS(J2,t1,t2),and vice versa.Given a feasible schedule, each job must go through one machine and then a second one, i.e., si2 ≥ Ci1. Letli=si2−Ci1be the exact time interval between the first operation and the second operation of the same job,i=1,…,n. Setl=min{li:i∈N(J2)},which measures the maximum distance that the second operations of the jobs inJ2can move forward together.DefinefiX(t1,t2,s,l)as the minimum makespan of agentX¯under a Johnsonian schedule in the form〈J1,J2〉for the first i jobs{J1,…,Ji},subject to the conditions that (1) the completion time of the jobs inJ1on M1 and M2 is t1 and t2, respectively. In fact,CmaxX=t2=JS(J1); (2) s is the starting time of the jobs inJ2on M2; and (3) l measures the maximum time interval that the second operations of the jobs inJ2can move forward together. Note that the variable t1 is also the starting time ofJ2on M1. However, the variable t2 is just the earliest possible time to processJ2on M2. The starting processing time ofJ2is the variable s. Obviously,t2≤s≤fiX(t1,t2,s,l). We call a four-dimensional vector(fiX,t1,t2,s,l)to be a state, which corresponds to the above Johnsonian schedule for jobs{J1,…,Ji}. To create a schedule with state(fiX,t1,t2,s,l)by adding a single job Jiin a previous state, namely,(fi−1X,t1′,t2′,s′,l′),we make the following decisions:(i)add job Ji toJ1. After adding the contribution from the previous state, the makespan of the present schedule becomes•fiX(t1,t2,s,l)=fi−1X(t1′,t2′,s′,l′)+pi1,ifmax{t1′+pi1,t2′}+pi2≤s′,wheremax{t1′+pi1,t2′}is the starting time of Jion M2.This case means thatl′=0(i.e., although M2 is idle in(t2′,s′),the second operations ofJ2cannot move forward any more in the previous schedule because there exists a jobr∈N(J2)withCr1=sr2). It follows that the makespan of the present schedule is increased by pi1 when Jiis assigned in previous schedule;fiX(t1,t2,s,l)=fi−1X(t1′,t2′,s′,l′)+max{pi1,max{t1′+pi1,t2′}+pi2−s′},ift2′<s′<max{t1′+pi1,t2′}+pi2.The same isl′=0in this case and the completion time ofJ2on M2 is increased by at least pi1. Due to the processing of Ji, all the jobs ofJ2have to move backmax{t1′+pi1,t2′}+pi2−s′on M2. Therefore, the makespan of the present schedule is increased bymax{pi1,max{t1′+pi1,t2′}+pi2−s′};fiX(t1,t2,s,l)=fi−1X(t1′,t2′,s′,l′)+max{pi1−l′,pi2},ift2=s′.From the definition of l′ and the first operations ofJ2move back pi1, the second operations ofJ2have to move back at leastpi1−l′. Therefore, the makespan of the present schedule is increased bymax{pi1−l′,pi2}.add job JitoJ2. Note thatJ2consists ofX¯-jobs only, soi∈N(JX¯). After adding the contribution from the previous state, the makespan of the present schedule becomes•fiX(t1,t2,s,l)=max{fi−1X(t1′,t2′,s′,l′),∑k=1ipi1}+pi2,wheremax{fi−1X(t1′,t2′,s′,l′),∑k=1ipi1}is the starting time of Jion M2.Summing up the above discussion, we devise the following dynamic programming algorithm for any given X ∈ {A, B}.Algorithm DP1Initialization:f0X(0,0,0,0)=0The recursive function:fiX(t1,t2,s,l)=min{fi−1X(t1−pi1,t2′,s−pi1,0)+pi1,ift2≤s′,fi−1X(t1−pi1,t2′,s′,0)+max{pi1,t2−s′},ift2′<s′<t2,fi−1X(t1−pi1,t2′,s′,l′)+max{pi1−l′,pi2},ift2′=s′,max{fi−1X(t1,t2,s′′,l′′),∑k=1ipi1}+pi2,ifJi∈JX¯,wheret2=max{t1′+pi1,t2′}+pi2,s=max{s′+pi1−l′,t2},l=s−(s′+pi1−l′),s=s′+max{∑k=1ipi1−fiX(t1,t2,s′′,l′′),0},andl=min{l′′,max{fi−1X(t1,t2,s′′,l′′)−∑k=1ipi1,0}}.The optimal value is given bymin{t2+αfnB(t1,t2,s,l),fnA(t1,t2,s,l)+αt2:t1≤P1,t2≤s≤P1+P2,l≤P2},whereP1=∑i=1npi1andP2=∑i=1npi2.The corresponding optimal schedule can be found by backtracking. There are n phases in Algorithm DP1. Note thatl=0if t2 ≠ s and l > 0 ift2=s. Since t1 ≤ P1,t2≤s≤P1+P2,and l ≤ P2, there are at mostO(P1(P1+P2)2)states in the ith phase. Each valuefiX(t1,t2,s,l)is determined in O(n) time. Then the recursion requiresO(nP1(P1+P2)2)time. The running time to find the optimal value is at mostO(P1(P1+P2)2). Hence, the overall time complexity of the algorithm isO(nP1(P1+P2)2). Thus we have the following result.Theorem 3.5ProblemF2∥CmaxA+αCmaxBcan be solved inO(nP1(P1+P2)2)time, whereP1=∑i=1npi1andP2=∑i=1npi2.Since problemF2∥CmaxA+αCmaxBcan be solved by Algorithm DP1 in pseudo-polynomial time, it is NP-hard in the ordinary sense only.To illustrate the Algorithm DP1, the following somewhat extreme example is worked out. Consider job setJ={J1,J2,J3}with the following parameters:Job123M1242M2352whereJA={J1,J2}andJB={J3}. Setα=1. Note that the jobs have been indexed according to Johnson’s rule. For ease of exposition, we use the state(fiX,t1,t2,s,l)to explain the process of iteration. There are three phases and the algorithm generates a state set in every phase. The initial state is (0, 0, 0, 0, 0). The state sets are calculated as follows:F1={(5,2,5,5,0)︸〈J1;∅〉,(5,0,0,2,0)︸〈∅;J1〉}F2={(11,6,11,11,0)︸〈J1,J2;∅〉,(11,2,5,6,0)︸〈J1;J2〉,(12,4,9,9,3)︸〈J2;J1〉,(11,0,0,3,0)︸〈∅;J1,J2〉}F3={(∖24,∖8,∖13,∖13,∖0)︸〈J1,J2,J3;∅〉,(24,6,11,11,3)︸〈J1,J2;J3〉,(20,4,7,8,0)︸〈J1,J3;J2〉,(∖25,∖6,∖11,∖11,∖3)︸〈J2,J3;J1〉,(17,2,4,5,0)︸〈J3;J1,J2〉}where the state over the brace corresponds to a job partition under the brace (e.g.,J1={J1,J2}andJ2={J3}in ⟨J1, J3; J2⟩), and the states withJ2=∅and the larger makespan under the same last four variables (see the states with strikethrough inF3) are removed from the present state set. Then, the optimal value ismin{f3A(t1,t2,s,l)+t2:(f3A,t1,t2,s,l)∈F3}=21,and the optimal schedule is (J3, J1, J2).Remark 3.6Our approach by partitioning all the jobs into two groups and applying Johnson’s rule to each group is an extension of the classical work of Johnson. This study may serve as a stepping stone for further analysis of larger, more complicated flowshop scheduling problems with this type of objective function. For example, similar to the analysis of the above algorithm for the two-agent problem, the m-agent problem can also be solved in pseudo-polynomial time for a given m. For an arbitrary m, we can show that the m-agent problem is strongly NP-hard by a reduction from 3-Partition (Garey & Johnson, 1979).We first analyze the worst-case error bound of applying Johnson’s rule to problemF2∥CmaxA+αCmaxB. Johnson’s rule may generate a schedule for the problem with very poor performance because the objective function consists of two parts that correspond to the two agents. Furthermore, the weighted parameter α plays an important role in the objective function. Consider the following example: There are three jobsJ1A,J1B,andJ2Bwith processing times 2, 1, and 3 on M1 and 2, u, and 1 on M2, respectively, where u > 2 is a positive integer. Letα=1u. Applying Johnson’s rule to schedule the above three jobs, we obtain a feasible schedule(J1B,J1A,J2B)with the objective valueCJR=u+3+1u(u+4)=u+4+4u. However, the optimal schedule is(J1A,J1B,J2B)with the objective valueC*=4+1u(u+5)=5+5u. Therefore, we haveCJRC*=u+4+4u5+5u,which approaches infinity asα=1uapproaches zero. For the special case whereα=1,we have the following result.Theorem 3.7For problemF2∥CmaxA+CmaxB,Johnson’s rule is a 2-approximation algorithm and the bound is tight.Let CJRbe the objective value of a feasible schedule σ obtained by applying Johnson’s rule and σ* be an optimal schedule. Note that σ has the minimum makespan, so we have Cmax (σ) ≤ Cmax (σ*), where Cmax (σ) and Cmax (σ*) are the makespan of σ and σ*, respectively. Hence, CJR≤ 2Cmax (σ) ≤ 2Cmax (σ*) ≤ 2C*. The following example shows that the bound is tight. There are totally two jobsJ1AandJ1Bwith processing times 0 and 1 on M1 and u and 1 on M2, respectively, where u is a positive integer. Applying Johnson’s rule to schedule the jobs, we obtain a schedule(J1A,J1B)with the objective valueCJR=u+u+1=2u+1. However, the optimal schedule is to scheduleJ1Bfirst, followed byJ1A,with the objective valueC*=2+u+2=u+4. Hence,CJRC*=2u+1u+4approaches 2 as u approaches infinity.□For the general problem, we provide the following approximation algorithm and analyze its worst-case error bound.Algorithm H1Step 1.Use Johnson’s rule to schedule the jobs and let the resulting schedule be σ1.Schedule the jobs inJBby Johnson’s rule, followed by scheduling the jobs inJAagain by Johnson’s rule. Denote the schedule asσ2=(σ′,σ′′),where σ′ contains all the B-jobs and σ′′ contains all the A-jobs.Choose the minimum objective value schedule σ between σ1 and σ2.For problemF2∥CmaxA+αCmaxB,Algorithm H1is an approximation algorithm with a worst-case ratio(1)CH1/C*≤(1+1α)for α > 1,CH1/C*≤(1+α)for α < 1,where CH1 denotes the objective value obtained by applying Algorithm H1.Suppose σ* is an optimal schedule. SinceC*=CmaxA(σ*)+αCmaxB(σ*),CmaxB(σ*)≤1αC*. We distinguish the following two cases based on the locations ofJnAAandJnBBin σ*.Case 1. The last job is a B-job. Consider σ1, which has the minimum makespan. If the last job in σ1 is also a B-job, we haveCmaxA(σ1)<CmaxB(σ1)≤CmaxB(σ*). Combining the above results, we haveCH1≤CmaxA(σ1)+αCmaxB(σ1)≤1αC*+C*=(1+1α)C*.If the last job in σ1 is an A-job, we haveCmaxB(σ1)<CmaxA(σ1)≤CmaxB(σ*). Similarly, we haveCH1≤(1+1α)C*.Case 2. The last job is an A-job. Note that all the B-jobs are scheduled by Johnson’s rule before all the A-jobs in Step 2, we haveCmaxB(σ2)≤CmaxB(σ*). Assume there is no idle time between any two A-jobs on M2 in σ2. Otherwise, we can remove the idle time by moving the A-jobs before the idle time back on M2 without loss of time.Let L be the makespan of the schedule obtained by using Johnson’s rule to schedule all the A-jobs and we haveL≥∑i∈N(JA)pi2AandL≤CmaxA(σ*). Now we show thatL≥CmaxA(σ2)−CmaxB(σ2).LetSiA(σ2)denote the start time of the A-jobs on Miin σ2,i=1,2. Since M2 is always busy from timeS2A(σ2)to timeCmaxA(σ2),soCmaxA(σ2)−S2A(σ2)=∑i∈N(JA)pi2A. Therefore, whenCmaxB(σ2)=S2A(σ2),we haveCmaxA(σ2)−CmaxB(σ2)=∑i∈N(JA)pi2A≤L. WhenCmaxB(σ2)<S2A(σ2),which together with the fact thatCmaxB(σ2)≥S1A(σ2)implies thatL=CmaxA(σ2)−S1A(σ2)≥CmaxA(σ2)−CmaxB(σ2).Combining the above results, we haveCmaxA(σ2)−CmaxB(σ2)≤L≤CmaxA(σ*). It follows thatCmaxA(σ2)−CmaxA(σ*)≤CmaxB(σ2)≤CmaxB(σ*)≤1αC*.HenceCH1≤CmaxA(σ2)+αCmaxB(σ2)≤CmaxA(σ2)−CmaxA(σ*)+CmaxA(σ*)+αCmaxB(σ*)≤1αC*+C*=(1+1α)C*.Result (1) follows for α > 1.To prove (2), consider an auxiliary problem that is the same as problemF2∥CmaxA+αCmaxB,except that the processing time becomespij′=αpijfori=1,…,n,j=1,2,and the objective becomes1αCmaxA+CmaxB,where α < 1. For notational convenience, denote our problem as P and the auxiliary problem as AP. We can show that AP is equivalent to P by proving that a schedule is a feasible solution to P if and only if it is a feasible solution to AP. Based on the symmetry of the objective function and1α>1,result (1) holds for problem AP. That is, Algorithm H1 is an approximation algorithm for AP with a worst-case ratioCH1/C*=(1+11α)=(1+α),where α < 1. Hence, result (2) holds.□Since the general problem discussed above is intractable, we consider the following two special cases whose optimal schedules can be found in polynomial time.Case 1. For eachi∈N(J),pi1 ≥ pi2, i.e., the flowshop is first-operation-maximal.Case 2. There is a fixed number of job types and the jobs of the same type have the same processing time.In view of Lemma 3.2, we focus on feasible schedules in which each machine processes all the jobs in the same order. We consider the first special case and denote it by1−max. We use the following insight on the structure of the optimal schedule to design an algorithm to solve problemF2|1−max|CmaxA+αCmaxB.Lemma 3.9For problemF2|1−max|CmaxA+αCmaxB,there exists an optimal schedule in the formσ=(σ1,σ2)that has the following properties:(a)σ1contains all the X-jobs and part ofX¯-jobs, and σ2contains the remainingX¯-jobs. The jobs are processed in nonincreasing order of pi2in σ1and σ2, respectively;The X-jobs andX¯-jobs are processed in nonincreasing order of pi2in σ, respectively.Notice that Johnson’s rule yields a job sequence in nonincreasing order of pi2, so Theorem 3.4 implies result (a).Consider an optimal schedule σ. Suppose to the contrary that σ does not satisfy (b). Then there exists a pair of X-jobs Jiand Jjwith pi2 > pj2 that are scheduled as follows:σ(M1)=α(1)Jjβ(1)Jiγ(1),σ(M2)=α(2)Jjβ(2)Jiγ(2),where α(1) and α(2) contain the same jobs but not necessarily in the same processing order, and the same for β(k) and γ(k),k=1,2. In the following interchange about Jiand Jj, the completion times of the jobs in α(i) and γ(i) are unchanged,i=1,2. We rearrange job Jjin σ′ with the completion times Ci1(σ) on M1 and Ci2(σ) on M2, respectively, i.e.,Cj1(σ′)=Ci1(σ)andCj2(σ′)=Ci2(σ). The remaining jobs (including the jobs in β(1) and Ji) move forward by pj1 on M1 and pj2 on M2. Since pj1 ≥ pj2 and pi2 > pj2, we can obtain a new schedule σ′ asσ′(M1)=α(1)β(1)JiJjγ(1),σ′(M2)=α(2)β(2)JiJjγ(2)without loss of time. By making successive interchanges of such job pairs, we can obtain the required schedule. Result (b) follows.□Step 1.For eachk=0,1,…,nA,schedule the jobs ofN(JB)⋃{1,…,k}in nonincreasing order of pi2, followed by scheduling the jobs{k+1,…,nA}again in nonincreasing order of pi2. Denote the resulting schedule asσk′.For eachl=0,1,…,nB,schedule the jobs ofN(JA)⋃{1,…,l}in nonincreasing order of pi2, followed by scheduling the jobs{l+1,…,nB}again in nonincreasing order of pi2. Denote the resulting schedule as σ′′l.Choose the minimum objective value schedule σ amongσk′and σ′′l,k=0,1,…,nAandl=0,1,…,nB.Algorithm O1solves problemF2|1−max|CmaxA+αCmaxBin O(nAnB) time.Denote the case in which pi1 ≤ pi2 for eachi∈N(J)as2−max. Note that by re-defining the B-job as having processing timep2B=Q+ϵon the second machine and the threshold value asY=5Q+4ϵin Theorem 3.1, we can show that problemF2|2−max|CmaxA+αCmaxBis NP-hard, too, even if the jobs are agreeable, i.e., for any pair of jobsi,j∈N(J),pi1 ≤ pj1⇔pi2 ≤ pj2.Suppose that the fixed number of job types is m andp¯idenotes the processing time of ith job type fori=1,…,m. We next show that Algorithm DP1 solves the second special case as stated in Theorem 3.11.Theorem 3.11The optimal schedule for problemF2∥CmaxA+αCmaxBwith a fixed number of job types can be obtained byAlgorithm DP1in polynomial time.Note that the time complexity of Algorithm DP1 depends heavily on the cardinality of the states, which depends on the number of different values of the variables t1, t2, s, and l.Since there is m job types and the jobs of the same type have the same processing time, assumep¯1<⋯<p¯m,so the values of the variables t1, t2, s, and l are in the form{k1p¯1+⋯+kmp¯m:ki≤n,i=1,…,m}.Hence, the number of differential values of each variable is at most O(nm). The total number of states is at most O(n4m) in each phases. It follows that the overall time complexity of Algorithm DP1 isO(n4m+1). Hence, problemF2∥CmaxA+αCmaxBwith m job types is polynomially solvable for a fixed m.□In this section we address problemF2∥∑CjA+αCmaxB. The NP-hardness of problem F2||∑Cjimmediately implies that our problem is also NP-hard in the strong sense. As a result, we provide an approximation algorithm. First we introduce a very useful property for our problem as follows:Lemma 4.1For any feasible schedule for problemF2∥∑CjA+αCmaxB,the processing sequence of all the jobs on either machine can be made the same as that of the other machine without loss of time.The proof of Lemma 4.1 is analogous to that of Lemma 3.2, so we omit it. In view of Lemma 4.1, we restrict our attention to the feasible schedules in which each machine processes all the jobs in the same sequence in the sequel.Note that any feasible schedule should satisfyCi≥Cj+piorCj≥Ci+pjfor all jobs Jiand Jjwith i ≠ j. For the one-machine scheduling problem, Queyranne (1993) shows that the convex hull of the feasible completion time vectors is completely described by the following linear inequalities:∑i∈SpiCi≥12(∑i∈Spi)2+12∑i∈Spi2,forallS⊆N(J).Based on linear programming formulations with completion time variables, Schulz (1996) presents polynomial-time approximation algorithms for the problem to minimize the total weighted completion time in various scheduling environments. He also extends this technique to flowshop problems by introducing new linear inequalitiesCij≥Ci(j−1)+pijfori=1,…,nandj=2,…,m,where m is the number of machines. Based on these results, we can formulate problemF2∥∑CjA+αCmaxBas the following linear programming relaxation (LP):min∑i∈JACi2+αCBs.t.∑i∈SpijCij≥12(∑i∈Spij)2+12∑i∈Spij2,forallS⊆N(J)andj=1,2,Ci2≥Ci1+pi2,fori∈J,CB≥Ci2,fori∈JB,Cij≥0,andCB≥0,fori∈Jandj=1,2.The nonnegative variable CBmeasures the objective value of agent B. Although the number of constraints in the first set of constraints in LP is exponential, there is a polynomial-time separation algorithm for such constrains (Queyranne, 1993). So LP can be solved in polynomial time. Based on the above linear programming relaxation of the problem, we propose the following heuristic for problemF2∥∑CjA+αCmaxB.Let(C12LP,…,Cn2LP,CBLP)be an optimal solution for LP and assumeC12LP≤⋯≤Cn2LP. It follows thatCBLP=max{Ci2LP|i∈N(JB)}.Algorithm H2Step 1.Find an optimal solution to LP by using the ellipsoid method.Re-index the jobs such thatC12LP≤⋯≤Cn2LP. Schedule the jobs in the same order(J1,…,Jn)on the two machines without unforced idle time.For problemF2∥∑CjA+αCmaxB,AlgorithmH2is an approximation algorithm with a worst-case ratio3−2n+1,where n is the number of jobs.LetCijH2be the completion time of Jion Mjin the schedule obtained by Algorithm H2 and CH2 be the corresponding objective value. ThenCH2=∑i∈N(JA)Ci2H2+αmax{Ci2H2|i∈N(JB)}. Let CLP be the objective value of LP and C* be the optimal value of our problem. ThenCLP=∑i∈N(JA)Ci2LP+αCBLP≤C*,whereCBLP=max{Ci2LP|i∈N(JB)}. We prove the theorem by showing thatCi2H2≤(3−2n+1)Ci2LPfori=1,…,n.First we prove the following inequalities:(3)Ci2H2≤(2−2n+1)Ci2LP+∑k=1ipk2,i=1,…,n.For each subsetS={1,…,i}andj=1,we have∑k=1ipk1Ck1LP≥12(∑k=1ipk1)2+12∑k=1ipk12.Noting thatCi1LP≤Ci2LPfori=1,…,nandC12LP≤⋯≤Cn2LP,we havepi1Ci2LP≥pi1Ci1LP≥12(∑k=1ipk1)2+12∑k=1ipk12−∑k=1i−1pk1Ck1LP≥12(∑k=1ipk1)2+12∑k=1ipk12−∑k=1i−1pk1Ci2LP.It follows that2Ci2LP≥∑k=1ipk1+∑k=1ipk12∑k=1ipk1≥∑k=1ipk1+∑k=1ipk1∑k=1ipk12(∑k=1ipk1)2≥∑k=1ipk1+1n∑k=1ipk1.Since the jobs are processed on M1 without idle time,Ci1H2=∑k=1ipk1. Therefore,(4)Ci1H2≤2nn+1Ci2LP=(2−2n+1)Ci2LP,i=1,…,n.AssumeC02H2=0. Clearly,Ci2H2=max{Ci1H2,C(i−1)2H2}+pi2fori=1,…,n. The proof of (3) is completed by making induction on i. From (4), we haveC12H2=max{C11H2,C02H2}+p12=(2−2n+1)C12LP+p12. Now, assume that (3) holds up toi−1(2 ≤ i ≤ n), i.e.,C(i−1)2H2≤(2−2n+1)C(i−1)2LP+∑k=1i−1pk2. Then we haveCi2H2≤max{(2−2n+1)Ci2LP,(2−2n+1)C(i−1)2LP+∑k=1i−1pk2}+pi2≤(2−2n+1)Ci2LP+∑k=1ipk2.Based on the inequalities in (3) andCi2LP≥∑k=1ipk2,we haveCi2H2≤(3−2n+1)Ci2LP.□In this section we investigate the following special cases of the problem whose optimal schedules can be found in polynomial time.Case 1.min{pi1|i=1,…,n}≥max{pi2|i=1,…,n},i.e., the first machine dominates the second.Case 2.max{pi1|i=1,…,n}≤min{pi2|i=1,…,n},i.e., the second machine dominates the first.We denote the case wheremin{pi1|i=1,…,n}≥max{pi2|i=1,…,n}asM1dom→M2and the case wheremax{pi1|i=1,…,n}≤min{pi2|i=1,…,n}asM2dom→M1. In view of Lemma 4.1, we focus on feasible schedules in which each machine processes all the jobs in the same order.Consider the first special case. We solve this case by solving two no-wait flowshop problems, i.e., the operation of each job has to be processed without interruption between M1 and M2. First, we give a useful property as follows:Lemma 4.3For problemF2∥∑CjA+αCmaxBsatisfying conditions of Case 1, there exists an optimal schedule in which all the B-jobs are consecutively processed.Consider an optimal schedule σ. Suppose that there exists a pair of B-jobs Jiand Jjscheduled as follows:σ(M1)=α(1)Jjβ(1)Jiγ(1),σ(M2)=α(2)Jjβ(2)Jiγ(2),where β(1) and β(2) contain the same A-jobs but not necessarily in the same processing order. From the special conditions of Case 1, we can make the processing sequences of the jobs asσ′(M1)=α(1)β(1)JjJiγ(1)andσ′(M2)=α(2)β(2)JjJiγ(2)without loss of time. By making successive interchanges of such job pairs, we can obtain the required schedule.□In view of Lemma 4.3, we propose a polynomial-time algorithm to solve problemF2|M1dom→M2|∑CjA+αCmaxBas follows:Algorithm O2Step 1.For eachk=0,1,…,nA,schedule the jobs in{1,…,k}in nondecreasing order of pi1, followed by scheduling the jobs inJBin any order except selecting the last job with the minimum pj2, and finally schedule the jobs in{k+1,…,nA}again in nondecreasing order of pi1. Denote the resulting schedule as σk.Choose the minimum objective value schedule σ among σk,k=0,1,…,nA.For problemF2|M1dom→M2|∑CjA+αCmaxB,an optimal schedule is obtained by AlgorithmO2inO(nA2lognA)time.By Lemma 4.3, there exists an optimal schedule in the formσ=(σ1,σ2,σ3)such that σ2 contains all the B-jobs only. Let Γkbe a set of(σ1k,σ2,σ3k)withσ1kconsisting of the A-jobs{1,…,k}andσ3kconsisting of the remaining A-jobs. For a givenk∈{0,1,…,nA},we prove the theorem by showing that the σkobtained by Algorithm O2 is optimal among the schedules in Γk.Given a scheduleσ^in Γkand in view of the conditionM1dom→M2,the makespan of agent B isCmaxB=∑i=1kpi1A+∑i=1nBpi1B+pσ^(k+nB)2B,whereσ^(k+nB)is the index of the(k+nB)th job inσ^,i.e., the last B-job inσ^. Given that∑i=1kpi1A+∑i=1nBpi1Bin the above equation is a constant and is independent of the sequence of the jobs, a schedule in which the last B-job having the minimum processing time on M2 minimizes the makespan of agent B.The completion time of the A-jobσ^(i)inσ^is given byCσ^(i)2A=∑j=1ipj1A+pσ^(i)2A,fori≤k,Cσ^(i)2A=∑j=1ipj1A+∑i=1nBpi1B+pσ^(i)2A,fork<i≤nA.Therefore, the total completion time of agent A is∑i=1nACi2A=∑i=1k(∑j=1ipj1A+pσ^(i)2A)+∑i=k+1nA(∑j=1ipj1A+∑i=1nBpi1B+pσ^(i)2A)=∑i=1nA∑j=1ipj1A+∑i=1nApσ^(i)2A+(nA−k)∑i=1nBpi1B.Note that∑i=1nApσ^(i)2A+(nA−k)∑i=1nBpi1Bis a constant for a given k and is independent of the sequence of the jobs, and minimizing∑i=1nA∑j=1ipj1Aimplies that the A-jobs are processed in nondecreasing order ofpi1A. So the schedule σkobtained by Algorithm O2 has the minimum objective value among the schedules in Γk.□For problemF2|M2dom→M1|∑CjA+αCmaxB,we can obtain an optimal schedule by modifying Algorithm O2 as follows: For eachk=0,1,…,nA,schedule the jobs of{1,…,k}in nondecreasing order of pi1, followed by scheduling the jobs inJBin any order except selecting the first job with the minimum pj1, and finally schedule the jobs{k+1,…,nA}again in nondecreasing order of pi1.Theorem 4.5ProblemF2|M2dom→M1|∑CjA+αCmaxBcan be solved in polynomial time.

@&#CONCLUSIONS@&#
In this paper we study two-agent scheduling problem in a two-machine flowshop. The cost function is the weighted sum of some common regular functions, including the makespan and the total completion time. For the problem to minimizeCmaxA+αCmaxB,we give an ordinary NP-hardness proof and a pseudo-polynomial solution algorithm. We analyze the performance of treating the problem using Johnson’s rule and propose an approximation algorithm based on Johnson’s rule. For the problem to minimize∑CjA+αCmaxB,we propose an approximation algorithm based on linear programming relaxation of the problem. Furthermore, we consider some polynomially solvable special cases of the two problems.We show that problemF2|1−max|CmaxA+αCmaxBis polynomially solvable, whereas the corresponding problemF2|2−max|CmaxA+αCmaxBis NP-hard as a straightforward conclusion of Theorem 3.1 by re-definingp2B=Q+ϵandY=4Q+4ϵ. Future research may consider extending the two-agent model to other machine settings, e.g., open shop and job shop, and study other cost functions such as those related to due dates.