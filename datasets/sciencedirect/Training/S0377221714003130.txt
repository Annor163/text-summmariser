@&#MAIN-TITLE@&#
The shortest-path problem with resource constraints with

@&#HIGHLIGHTS@&#
New dynamic programming labeling algorithm for SPPRC.Relevant for solving arc-routing problems (CARP) with branch-and-price.Handling loop elimination for two independent task sets.Some knowingly hard CARP instances were solved to optimality for the first time.

@&#KEYPHRASES@&#
Constrained shortest paths,Cycle elimination,Capacitated arc-routing problem,

@&#ABSTRACT@&#
In many branch-and-price algorithms, the column generation subproblem consists of computing feasible constrained paths. In the capacitated arc-routing problem (CARP), elementarity constraints concerning the edges to be serviced and additional constraints resulting from the branch-and-bound process together impose two types of loop-elimination constraints. To fulfill the former constraints, it is common practice to rely on a relaxation where loops are allowed. In a k-loop elimination approach all loops of length k and smaller are forbidden. Following Bode and Irnich (2012) for solving the CARP, branching on followers and non-followers is the only known approach to guarantee integer solutions within branch-and-price. However, it comes at the cost of additional task-2-loop elimination constraints. In this paper, we show that a combined(k,2)-loop elimination in the shortest-path subproblem can be accomplished in a computationally efficient way. Overall, the improved branch-and-price often allows the computation of tighter lower bounds and integer optimal solutions for several instances from standard benchmark sets.

@&#INTRODUCTION@&#
In thiAlgorithms paper, we extend the works of Irnich and Villeneuve (2006) and Bode and Irnich (2012). The first paper considered k-cycle elimination for shortest-path problems with resource constraints (SPPRC, Irnich & Desaulniers, 2005, chap. 2). The elementary SPPRC (ESPPRC) is the subproblem of many column-generation formulations of routing problems. Since the ESPPRC isNP-hard in the strong sense (Dror, 1994), early column-generation approaches solved the SPPRC, i.e., the corresponding non-elementary problem, or SPPRC with 2-cycle elimination (see, e.g. Houck, Picard, Queyranne, & Vemuganti, 1980, 1999), which are both relaxations, with the consequence that the lower bounds computed by the column-generation master program often deteriorate. The elimination of k-cycles, i.e., cycles with up to k edges, can be seen as a mean to gradually strengthen the linear relaxation of the column-generation master program while keeping the computational effort acceptable. Both from a practical and a worst-case point of view, k-cycle elimination is computationally attractive because there exist pseudo-polynomial labeling algorithms (Irnich & Villeneuve, 2006). Applied to the vehicle-routing problem with time windows some knowingly hard instances were solved for the first time. Nowadays, it seems that approaches based on solving ESPPRC (e.g. Jepsen, Petersen, Spoorendonk, & Pisinger, 2008) or ng-path relaxations (Baldacci, Mingozzi, & Roberti, 2011a) are superior due to the extremely tight lower bounds produced. However, when routes become very long, solving even very few ESPPRC subproblems can become extremely time consuming (see e.g. Desaulniers, Lessard, & Hadjar, 2008).We apply loop-elimination for solving the capacitated arc-routing problem (CARP) with the branch-and-price algorithm of Bode and Irnich (2012). The CARP is the basic multiple-vehicle arc-routing problem. It has applications in waste collection, postal delivery, winter services and more (Corberán & Prins, 2010; Dror, 2000). For a general overview on exact algorithms for the CARP we refer to the survey (Belenguer, Benevent, & Irnich, 2014, chap. 9). In the paper (Bode & Irnich, 2012), the first full-fledged branch-and-price algorithm for the CARP was presented. It can be characterized by the idea of exploiting sparsity of the underlying CARP network. The advantage of sparse networks is that new CARP tours can be priced out efficiently using the sparse network only (see also Letchford & Oukil, 2009). Bode and Irnich (2012) discussed that the sparse network however comes at the cost of a more intricate branching and they developed an effective branching scheme based on follower and non-follower constraints. It means that for every two required edges e ande′, one determines whether or not these two edges are serviced by the same vehicle and with no other intermediate service in between. Follower constraints, i.e., two edges e ande′have to be serviced consecutively, can be enforced by network modifications so that these constraints preserve the structure of the pricing subproblem. However, non-follower constraints, i.e., two edges e ande′must not be served consecutively, can only be implemented efficiently as a task-2-loop elimination constraint: The trick is to associate the same task to both edges e ande′(see also Irnich & Desaulniers (2005, chap. 2) for a discussion of tasks and task cycles). Hence, this branching scheme seemed limited to the case that an SPPRC subproblem with 2-loop elimination is employed (the term loop refers to cycles w.r.t.services edges; a 2-loop is the repetition of the same service). Moreover, Bode and Irnich (2012) showed that pricing relaxations based on k-loop elimination can produce better column-generation lower bounds. However, a key question remained unclear: How can the branching scheme with branching on followers/non-followers be combined with k-loop elimination fork⩾3.A positive answer will be given here because we can show that a combined(k,2)-cycle elimination accomplishes the above problem. More precisely, k-loops w.r.t.tasks associated with services on required edges and 2-loops w.r.t.tasks implied by non-follower constraints can be handled by a labeling approach presented here. Note that the companion paper (Bode & Irnich, in press) studies several alternative relaxations including, e.g., extensions of the afore-mentioned ng-path relaxations. Its focus is the empirical comparison of these relaxations, the analysis of the impact of possible acceleration techniques, and the overall comparison of the different branch-and-price algorithms. Please note that the article at hand and the paper (Bode & Irnich, in press) were originally one long technical report (submitted and available online on our website in November 2012). Due to its length the paper was not publishable so that we decided to split it into two parts. We (re)submitted both parts in April 2013 when a new paper by Bartolini, Cordeau, and Laporte (2013) became online available. Therefore, we consider results presented here and in Bartolini et al. (2013) as developed independently; the computational results section however compares also explicitly with their (very good) results.The contribution of this paper is therefore twofold: First, we provide the theoretical foundation of a labeling algorithm allowing the combined(k,2)-loop elimination. This includes the definition of labels, the derivation of an effective dominance procedure, and a worst-case analysis. Second, we run the different branch-and-price algorithms for the CARP resulting from choosing different values of k, i.e., fork=2,3, and 4. It will be apparent that the controlled variation of k is beneficial when it comes to a comparison concerning the trade-off between the strength of a column-generation formulation and the computational burden for its resolution.We expect that the branch-and-price-based approach, presented in this paper here, applies also for solving other vehicle-routing problems (VRP) defined on a sparse networks: Examples are the capacitated general routing problem (typically defined on a sparse graph Pandi & Muralidharan (1995) and some variants of the VRP defined on street networks (e.g., Nasiri & Letchford, 2013)).The remainder of this paper is structured as follows. Section 2 presents the new labeling algorithm and its theoretical analysis for SPPRC with combined(k,2)-loop elimination. Section 3 presents computational results for using the respective relaxations as subproblems in a branch-and-price for the CARP. The paper ends with final conclusions in Section 4.A general discussion of SPPRC solution approaches including a detailed discussion of dynamic programming labeling algorithms, at the moment the generally best performing methods, can be found in Irnich and Desaulniers (2005, chap. 2). Solution approaches tailored to ESPPRC are presented in Feillet, Dejax, Gendreau, and Gueguen (2004), Boland, Dethridge, and Dumitrescu (2006), Righini and Salani (2006, 2008).The SPPRC is defined over a digraphG=(V,A)with node set V and arc set A. A start or origin nodes∈Vis given. For notational convenience we assume that G is simple so that arcs(i,j)∈Acan be uniquely identified by their end nodes i and j. The last node of a path P, i.e., its end node is denoted byv(P)∈V. The extension of a pathP=(s,…,v(P))along an arc(i,j)requiresv(P)=iand results in a new pathP′=(P,j)=(s,…,v(P)=i,j). Resource extension functionsf=(fij)(i,j)∈A(REFs) handle the update of resources accumulated/consumed along the path. Thus, if pathP=(s,…,i=v(P))has associated resourcesr(P)(generally a multi-dimensional vector) then its extensionP′=(P,j)along arc(i,j)has resourcesfij(r(P)). Finally, multi-dimensional intervals[aj,bj]for all nodesj∈Vare given.In standard SPPRC, the problem is to compute a minimum-cost feasible path ending at each destination nodet∈V. In case of non-decreasing REFs, a pathP′=(P,j)is feasible (w.r.t.resources) ifr(P′)∈[av(P′),bv(P′)]holds and the predecessor path P is also feasible. Then, for solving SPPRC, one typically computes, for each node, a set of paths{P1,…,Pq}with{r(P1),…,r(Pq)}forming the Pareto-optimal resource values. The particular importance of non-decreasing REFs is stressed in Desaulniers et al. (1998, chap. 3), Irnich and Desaulniers (2005, chap. 2), Irnich (2008).In the CARP pricing subproblem, the networkG=(V,A)consists of the node set V defined by the CARP instance. The arc set A contains two types of arcs:•Service arcs(i,j)and(j,i)correspond to proving service to a required edge{i,j}. These arcs consume a positive amountqij>0of the vehicle’s capacity and have a (reduced) costc̃ijserv(not restricted in sign).Deadheading arcs(i,j)and(j,i)correspond to traversing an arbitrary edge{i,j}without providing service. These arcs consume nothing from the vehicle’s capacity, i.e.,qij=0. Even with valid inequalities present in the column-generation master program, their (reduced) costc̃ijcan be guaranteed to be non-negative (for details see Bode & Irnich, 2012).Bode and Irnich (2012) explained how the column-generation restricted master program (RMP) provides with its dual solution the reduced costsc̃ijservandc̃ij. Summing up, the resourcesr(P)in the CARP case consumed along a path P are given byr(P)=(q(P),c̃(P)), whereq(P)is restricted to integer values0,1,…,C(C is the capacity of the vehicle) andc̃(P)is the accumulated reduced costs.The outline of a generic labeling approach for solving SPPRC is presented in Algorithm 1. Herein, each path P is represented by a labelL(P), i.e., a data structure that allows the reconstruction of the associated path via labels of the predecessor path, provides additional information such as the resource consumptionr(P), and allows to invoke a dominance algorithm. The setUis the set of unprocessed labelsL(P), i.e., paths P that are not extended along all arcs(v(P),j)∈Aof the forward star of nodev(P). The setLcontains those labels that need to be kept.Algorithm 1Generic SPPRC Dynamic Programming Labeling AlgorithmDepending on the path selection rule in the path extension step, different label processing procedures result such as label setting and label correcting algorithms. The invocation of a dominance algorithm is optional in the sense that otherwise the algorithm enumerates all feasible paths starting at nodes. Dominance is however crucial in the design of efficient labeling algorithms, and we devote Section 2.3 for the detailed presentation of this basic component. In general, the intension of the dominance algorithm is to identify those paths that do not need to be extended, i.e., one or several other paths still allow finding (Pareto-) optimal paths. It can be applied at any time in the course of the algorithm and might be delayed to a point where several new paths with identical end node have been generated and stored inU. Any reasonable strategy for invoking the dominance algorithm will optimize the tradeoff between the computational effort and the risk that a path is extended before one finds out that it is dominated.In the presence of additional path-structural constraints (such as cycle- or loop-elimination constraints discussed in Section 2.2, see also Section 2.2 of Irnich & Desaulniers (2005, chap. 2)), the setLmust generally include additional labels for paths that are not necessarily Pareto-optimal. It this case, a final filtering step is needed to identify a Pareto-optimal subset. Efficient algorithms for that purpose can be found in Bentley (1980).In the column-generation context, a task is something (such as visiting a node, edge or arc) that needs to be performed by a column (a vehicle route or a schedule etc.). Generally, a task is associated with a set-partitioning or covering constraint of the master program, and it can be found at one or several nodes and arcs of the network. The work by Irnich and Villeneuve (2006) mainly addresses k-cycle elimination where every node of the subproblem’s network represents an individual task (implied by standard node-elementarity constraints).The paper at hand, however, addresses the more general case that an arbitrary sequenceTijof tasks (including empty sequences) is associated with every arc(i,j)∈A. Then, feasible pathsP=(v0,v1,…,vp)are those where the joint task sequenceT(P)≔(Tv0,v1,Tv1v2,…,Tvp-1vp)does not contain a task-k loop. It is important to highlight that the literature distinguishes between k-cycles and k-loops. The term k-cycle is traditionally used in the context of unique tasks associated with nodes. A 2-cycle is a cycle of length two such as(i,j,i), and a k-cycle is any cycle of length k or smaller. In contrast, a 2-loop is a repeated task(a,a)for any taska∈T. A 2-loop can result from a subpath(i,j,i)where both arcs(i,j)and(j,i)(or an edge{i,j}in the undirected case) have the task sequenceTij=Tji=(a). However, the same task-2-loop results for (sub) pathP=(v0,v1,…,vp)if arc(v0,v1)has a task sequence(…,a)ending with task a, arcs(v1,v2),…,(vp-2,vp-1)have an empty task sequence (also called deadheading), and arc(vp-1,vp)has a task sequence(a,…)starting with task a. In general, fork>2a task-k-loop is task-cycle of lengthk-1or smaller.The rationale behind these seeming confusing definitions is that 2-cycle elimination and task-2-loop elimination can be handled with almost identical algorithmic approaches: Dominance rules require that only a best and a second-best path with different last task need to be kept inL(see Algorihm 1). The dominance rules were first presented by (Houck et al., 1980) for 2-cycle elimination in the node-routing context and by (Benavent, Campos, CorberÃ¡n, & Mota, 1992) for task-2-loop elimination and the CARP.This section contains new theoretical results for labeling procedures that simultaneously consider two sets of tasks for which loop freeness must be guaranteed. In our CARP application, paths are desired to be k-loop-free w.r.t.tasksTEinduced by route’s elementarity constraints. Here, we would likek>2to be as large as possible (of course there is the trade-off between strength of the relaxation and effort for pricing). Moreover, one needs paths to be exactly 2-loop-free w.r.t.the tasksTBinduced by non-follower constraints resulting from branching.Generalizing, we will derive results for a combined(k1,k2)-loop elimination for the tasks setsT1andT2. For simplicity, we abbreviate paths feasible w.r.t.both tasks setsT1andT2as(k1,k2)-loop-free paths. In particular, we suppress the prefix ‘task-’.It is rather simple to define attribute updates and extension rules for(k1,k2)-loop elimination. The crucial part for an effective labeling algorithm is however the definition of a dominance relation. Straightforward approaches allow dominance only between paths that have identical sequences of the lastk1-1tasks ofT1and the lastk2-1tasks ofT2. This is rather easy, but turns out to be ineffective due a possible number ofO(|T1|k1-1·|T2|k2-1)labels at the same node and otherwise identical state (all resources except for cost; identical load in the CARP case). Irnich and Villeneuve (2006) discuss this point for node-k-cycle elimination in detail. Therefore, the decisive point is the development of effective dominance rules guaranteeing a small number of labels.Such an effective dominance rule, based on the one for node-k-cycle elimination proposed by Irnich and Villeneuve (2006), does not only compare pairs of paths. Instead, several paths together may be needed to dominate another path. In the following, we will distinguish between paths and labels. Paths are represented by labels, but labels contain additional attributes needed to efficiently test for domination. Moreover, paths can mutually dominate each other, while we will make sure that dominance is uni-directional among labels. This can be achieved using a unique identifier (an ID) for each label, which breaks ties whenever two labels with identical resources are compared (for a more detailed discussion of that point see Irnich & Villeneuve (2006, p. 393f)).The dominance principle says that labelsL(P1),…,L(Pg)(g⩾1) representing pathsP1,…,Pgdominate a labelL(P)representing path P if1.P1,…,Pgand P share the same end nodev(P1)=⋯=v(Pg)=v(P).Every feasible completion Q of P, i.e.,(P,Q)is a feasible path, must also result in a feasible path(Pj,Q)for at least one pathPj,j∈{1,…,g}.The cost of(Pj,Q)must not exceed the cost of(P,Q)for allj∈{1,…,g}.As a consequence, the labelL(P)does not need to be considered in a labeling algorithm because it can never produce a better feasible extension to the destination node than possible with at least one extension of the labelsL(P1),…,L(Pg). It is however crucial that the labelsL(P1),…,L(Pg)are kept.The second condition (2.) is typically replaced by a (sufficient) condition that is easier to check, involving resource consumptions and task loops. In fact, all pathsP1,…,Pgmust have resources not larger than the resources of P, i.e.,(1)r(P1),…,r(Pg)⩽r(P),which is in the CARP case equivalent toq(P1),…,q(Pg)⩽q(P)andc̃(P1),…,c̃(Pg)⩽c̃(P), while feasibility regarding tasks loops is not checked via resources.The fundamental idea for(k1,k2)-loop elimination is to efficiently encode the set of possible extensions of a path. For this purpose, letE(P)denote the set of loop-free extensions of the path P.E(P)solely considers task loops and not resource consumptions. The second condition (2.) above is fulfilled forP1,…,Pgand P if (1) and(2)⋃i=1gE(Pi)⊇E(P)holds. We will now describe how to encode this condition in order to handle two sets of tasks efficiently.Recall that there are two sets of tasksT1andT2for which loop freeness has to be ensured. LetSbe the set of all(k1,k2)-loop-free paths, i.e.,k1-loop-free w.r.t.tasks inT1andk2-loop-free with respect to tasks inT2. LetP,Q∈Sbe two feasible paths, where the end nodev(P)of P is identical with the start node of Q. Then, the concatenation(P,Q)is also a path inSif and only if both(T1(P),T1(Q))isk1-loop-free and(T2(P),T2(Q))isk2-loop-free. This condition holds if(T1(P),T1(Q))=(…,tk1-11,…,t21,t11,s11,s21,…,sk1-11,…)fulfillstp1≠sq1forallp+q⩽k1and(T2(P),T2(Q))=(…,tk2-12,…,t22,t12,s12,s22,…,sk2-12,…)fulfillstp2≠sq2forallp+q⩽k2.The relevant entries ofT1(Q)andT2(Q)are the firstk1-1andk2-1entries, and we denote these byTk11(Q)andTk22(Q), respectively. We assume in the following that both sequencesTk11(Q)andTk22(Q)always contain exactlyk1-1andk2-1elements, respectively, where missing tasks are represented by a ‘·’. (Here we remind the reader about the notation that forh=1orh=2the termTh(without subscript) refers to the set of all tasks,Tijhis the task sequence associated to an arc(i,j), andTkh(Q)is the (k-1)-tuple describing the sequence of the firstk-1tasks in a path Q possibly extended with succeeding·.)We are able to express the above condition asTk11(Q)≠(·,…,·,tp,i1,·,…,·)forallpwith1⩽p+i⩽k1andTk22(Q)≠(·,…,·,tp,i2,·,…,·)forallpwith1⩽p+i⩽k2,where i refers to the ith position in the right-hand-side vector, andtp,i1andtp,i2have the valuetp1andtp2, respectively. The lastk1-1entries ofT1(P), i.e.,tp1withp∈{1,…,k1}, and the lastk2-1entries ofT2(P), i.e.,tp2withp∈{1,…,k2}have to be compared withTk11(Q)andTk22(Q), respectively. It follows that any extension Q of path P is infeasible ifTk11(Q)orTk22(Q)matches with the respective tuple (still ‘·’ refers to an unspecified entry).These infeasible extensions can be represented by set forms, a concept introduced first in Irnich and Villeneuve (2006): The tuples on the right hand side of the above inequality are in fact set forms. The finite union of such set forms defines the self-hole setH(P)of a path P.Example 1For(4,2)-loop elimination in the CARP context, i.e.,k1=4,k2=2andT1=TE,T2=TB, let path P haveTE(P)=(…,a,b,c)andTB(P)=(…,α). It means that the last three required edges serviced were the edgesa,b, and c. In addition, we are in a branch of the branch-and-price search tree where a non-follower constraint is active, e.g., say for the edges c and f, imposing that they have the new identical taskαassigned in order to prevent c and f being serviced consecutively.Then, any extension Q produces a feasible path w.r.t.loop elimination if(T4E(Q),T2B(Q))≠(·,·,·)(α),(a,·,·)(·),(b,·,·)(·),(·,b,·)(·),(c,·,·)(·),(·,c,·)(·),(·,·,c)(·).Equivalently, the self-hole set of P isH(P)=(·,·,·)(α)∪(a,·,·)(·)∪(b,·,·)(·)∪(·,b,·)(·)∪(c,·,·)(·)∪(·,c,·)(·)∪(·,·,c)(·),where each set form encodes the set of task sequences matching the respective pattern.For example, if a pathQ1produces the task sequenceT4E(Q1)=(d,a,b)andT2B(Q1)=(β)then there is no match withH(P), and the extension(P,Q1)is feasible w.r.t.loop elimination. In contrast, for a pathQ2with task sequenceT4E(Q2)=(d,e,c)there is a match with(·,·,c)(·)so that(P,Q2)is infeasible.The representation ofH(P)as the union of set forms is quadratic ink1andk2, i.e., up tok1(k1-1)2+k2(k2-1)2different set forms are necessary to describe all infeasible extensions of path P.Now we consider a dominance situation where (1) and (2) are fulfilled for dominating pathsP1,…,Pgand a dominated path P. By de Morgan’s law, we get(3)⋃i=1gE(Pi)⊇E(P)⇔⋂i=1gH(Pi)⊆H(P)so that the condition (2) for loop-free extensions can be equivalently stated with the help of self-hole sets. The point is now that any intersection of the self-hole sets, resulting on the right hand side, can be calculated and represented as a union of set forms again. The following theorem summarizes the result:Theorem 1LetP1,P2,…,Pgand P be different paths ending at the same nodev(P1)=…=v(Pg)=v(P)withr(P1),…,r(Pg)⩽r(P), and (3)is fulfilled.Then path P is dominated, i.e., any feasible completion Q of P results in at least one feasible path(Pj,Q)(for onej∈{1,2,…,g}}) withr(Pj,Q)⩽r(P,Q). (Note: Feasibility refers to both being(k1,k2)-loop free and feasible w.r.t.resource constraints.)(Example 1 continued) LetP′be another path withTE(P′)=(a,d)(just two edges serviced alongP′) andTB(P′)=(β). The self-hole set ofP′isH(P′)=(·,·,·)(β)∪(a,·,·)(·)∪(·,a,·)(·)∪(d,·,·)(·)∪(·,d,·)(·)∪(·,·,d)(·)Then, the intersection of the self-hole sets isH(P)∩H(P′)=(a,·,·)(α)∪(·,a,·)(α)∪(d,·,·)(α)∪(·,d,·)(α)∪(·,·,d)(α)∪(a,·,·)(β)∪(b,·,·)(β)∪(·,b,·)(β)∪(c,·,·)(β)∪(·,c,·)(β)∪(·,·,c)(β)∪(a,d,·)(·)∪(a,·,d)(·)∪(b,a,·)(·)∪(b,d,·)(·)∪(b,·,d)(·)∪(a,b,·)(·)∪(d,b,·)(·)∪(·,b,d)(·)∪(c,a,·)(·)∪(c,d,·)(·)∪(c,·,d)(·)∪(a,c,·)(·)∪(d,c,·)(·)∪(·,c,d)(·)∪(a,·,c)(·)∪(·,a,c)(·)∪(d,·,c)(·)∪(·,d,c)(·)The computation of the intersection of two unions of set forms, as in the above example, requires two algorithmic components: First, set forms need to be tested for inclusion. For example,(a,·,b,e)(α)is included in(·,·,b,·)(α), while(a,e,b)(·)is not included in(a,·,c)(·). It can be shown similarly as for node-k-cycle elimination that this test requires onlyO(k1+k2)time and space (Irnich & Villeneuve, 2006, p. 398).Second, proper intersections of set forms need to be computed. For two set forms s and t, the intersections∩tis empty if different entries are specified at the same position. For example,s=(a,b,·)(α)andt=(a,c,b)(α)result ins∩t=∅. Moreover, by definition, the intersection is empty if an infeasible loop is created, e.g., the intersection of(a,b,·)(α)and(·,b,a)(·)is empty because it induces the 3-loop(a,b,a)w.r.t.tasksT1. In contrast, the set forms(a,b,·)(α,·)and(·,b,d)(·,·)have non-empty intersection(a,b,d)(α,·). Here again, the computation including loop detection requires onlyO(k1+k2)amortized time and space. As a result, the computation of the intersection of two self-hole sets, say with p and q set forms each, requiresO((k1+k2)pq)amortized time and space; see Irnich and Villeneuve (2006, p. 398) for details.With the above definition of the intersection of two set form, we are able to formally define the intersection of two hole setsH1andH2. Algorithm 2 is similarly stated in Irnich and Villeneuve (2006, p. 398). Note that the first loop is included for the purpose of accelerating the subsequent steps, i.e., to produce fewer set forms s and t in the preliminary result set H having s included in t or vice versa. Such included set forms are eliminated in the last loop. Overall complexity of Algorithm 2O(kpq), where p and q is the number of set forms in the respective hole set.Algorithm 2Intersection of hole setsIn order to know the overall time complexity, it is important to quantify the maximum number of elements present in an intersection of two collections of set forms. The next paragraph will give an answer.For node-k-cycle elimination, any collection of set forms resulting from the intersection of self-hole sets does not contain more than(k-1)!2different set forms. This result is stated in Irnich and Villeneuve (2006, p. 399) for node-k-cycle elimination. Notice that in node-k-cycle elimination all paths ending at the same node share an identical last task (corresponding to that node), which therefore can be omitted. Task-k-loop elimination, however, must ensure that there are at leastk-1other tasks before a task is repeated. Therefore, in both cases, recording onlyk-1elements is sufficient to encode all relevant dominance information, which results in the stated complexity.The result for combined(k1,k2)-loop elimination in SPPRC is the following:Theorem 2For combined(k1,k2)-loop elimination, the maximum number of different set forms needed to represent any intersection of self-hole setsH(P1)∩H(P2)∩⋯∩H(Pl)of any set of l paths isω(k1,k2)≔(k1-1)!2·(k2-1)!2·(k1-1)+(k2-1)k1-1. This boundω(k1,k2)is tight.A proof of this theorem and all other theoretical results is included in the Appendix. The following example shows how to construct instances where the bound is indeed tight.Example 3Consider a combined(3,2)-loop elimination. Moreover, letP1,P2, andP3be three paths with no tasks in common. Thus,H(P1)=(·,·)(α)∪(a,·)(·)∪(b,·)(·)∪(·,b)(·)H(P2)=(·,·)(β)∪(c,·)(·)∪(d,·)(·)∪(·,d)(·)H(P3)=(·,·)(γ)∪(e,·)(·)∪(f,·)(·)∪(·,f)(·)giving rise toH(P1)∩H(P2)∩H(P3)=(a,d)(γ)∪(b,d)(γ)∪(c,b)(γ)∪(d,b)(γ)∪(c,f)(α)∪(d,f)(α)∪(e,d)(α)∪(f,d)(α)∪(a,f)(β)∪(b,f)(β)∪(e,b)(β)∪(f,b)(β).These are twelve set forms which is the maximum number(k1-1)!2·(k2-1)!2·k1-1+k2-1k1-1=(3-1)!2·(2-1)!2·(3-1)+(2-1)3-1=4·1·3=12.The paragraph above presented results on the number of set forms in an intersection of an arbitrary number of paths. The question considered in this paragraph is about the maximum number of paths P with identical state (resource vector except for cost; for the CARP, with identical loadq(P)). Let a collection ofgpathsP1,…,Pgwith identical state ending at a nodei=v(P1)=⋯=v(Pg)be given. The corresponding labels can be sorted in a unique way using the IDs of the labels so that the following ordering is given:L(P1)≺domL(P2)≺dom⋯≺domL(Pg),To be precise, we defineL(P1)≺domL(P2)so that both paths end at the same nodev(P1)=v(P2),P1dominatesP2with respect to resource consumption, i.e.,r(P1)⩽r(P2), and in case of identical resourcesr(P1)=r(P2)the IDs control that the relation≺domis antisymmetric, i.e.,L(P1)≺domL(P2)impliesL(P2)⊀domL(P1). (For this reason we distinguish between paths and labels.) For the above pathsP1,P2,…,Pgthe dominance relation also means that, e.g.,L(Pg)is dominated by all other labelsL(P1),L(P2),…,L(Pg-1). It follows for the intersections of the self-hole sets of the dominating labels (L(P1)dominatesL(P2),L(P1)andL(P2)dominateL(P3)etc.) thatI1≔H(P1)⊇I2≔H(P1)∩H(P2)⊇⋯⊇Ig≔⋂i=1gH(Pi).holds. Irnich and Villeneuve (2006) have shown that a pathPtcan be discarded ifIt=It-1holds. The reason is thatIt=It-1impliesH(P1)∩…∩H(Pt-1)⊆H(Pt)so that conditions (3) hold. Therefore, the maximum length of a properly decreasing chain of intersections of self-hole sets is a bound on the maximum number of labels to consider with identical state.Theorem 3A collection ofgdominating pathsP1≺domP2≺dom…≺domPgending at the same node is given. Let the intersections of the corresponding self-hole setsH(P1),H(P2),…,H(Pg)form a properly decreasing chain, i.e.,H(P1)⊋H(P1)∩H(P2)⊋⋯⊋⋂i=1gH(Pi). Then, the lengthgof the properly decreasing chain is bounded byγ(k1,k2)=[k1+k2-1]·(k1-1)!2·(k2-1)!2·(k1-1)+(k2-1)k1-1.Note that the boundγ(k1,k2)is generally not tight as already shown for node-k-cycle elimination (Irnich & Villeneuve, 2006, p. 400f).For the special case of a combined(k,2)-loop elimination, the bound isγ(k,2)=(k+1)·(k-1)!2·k=(k-1)!·(k+1)!. In particular, we get the boundsγ(3,2)=2·24=48andγ(4,2)=6·120=720. For the CARP, it follows that the maximum number of labels to be kept at a nodev∈Vis bounded by(C+1)γ(k,2).As in Irnich and Villeneuve (2006), the new labeling approach will store the intersection of the self-hole sets of all dominating labels as the so-called running-hole set, i.e.,Hrun(P)≔⋂i=1gH(Pi)wheneverL(P)is dominated byL(P1),…,L(Pg). The labelL(P)can be discarded ifHrun(P)⊆H(P)because this is equivalent toIg=⋂i=1gH(Pi)=H(P)∩Ig=:Ig+1.For the labeling algorithm, it means that the running-hole set is stored within the label for bookkeeping already identified dominance relations. Whenever one or several new labels are created (by the path extension step, see Section 2.1), they are compared for dominance with the existing (old) labels that are already present at the same node. If a new labelL(P)dominates an existing labelL(P′), i.e.,L(P)≺domL(P′), the running-hole set ofP′is replaced byHrun(P′)≔Hrun(P′)∩H(P). Conversely, if an old labelL(P′)dominates a new labelL(P), i.e.,L(P′)≺domL(P), the running-hole set of P is replaced byHrun(P)≔Hrun(P)∩H(P′). Additional algorithmic tricks (to improve on the average run time) for storing the intersection and checking the above condition were discussed in Irnich and Villeneuve (2006, p. 399).As mentioned before, in the CARP case the only resources are load and cost. The number of possible states associated with any nodei∈Vis always bounded by the capacity (C+1states0,1,…,C).Letchford and Oukil (2009) developed a tailored SPPRC labeling algorithm for the CARP that has a very attractive worst-case time complexity ofO(CD(n,m)), whereD(n,m)is the complexity of Dijkstra’s algorithm on a digraph with n nodes and m edges. Using the Fibonacci-heap data structure, the best known bound isD(n,m)=m+nlog(n)(Ahuja, Magnanti, & Orlin, 1993).Letchford and Oukil (2009) modify the label selection rule (for choosing the next path P to be extended) in the following way:1.In an outer loop over possible valuesq=0,1,2,…,Cof the load resource paths P withq(P)=qare extended.The extension is split into two parts, the extension along all deadheading arcs first and the extensions along all service arcs second.The first extension (deadheading) produces only labels with identical loadq. All extensions can be handled together using a Dijkstra-type of labeling. Note that for the CARP, the only relevant resource is cost whenever load is fixed. By pre-assigning minimum-cost labels at all nodes, the time complexityD(n,m)can be reached.The latter extensions (service) produce not more thanO(2m)new labelsL(P), all with loadq(P)>q.The overall complexity of all extensions is therefore dominated by the complexity of the Dijkstra algorithm. Taking the outer loop over all load values into account implies an overall complexity ofO(CD(n,m)).In the presence of loop-elimination constraints, up toγ(k1,k2)labelsL(P)with identical loadq(P)=qmight exist as a consequence of Theorem 3. Therefore, the number of labels to extend can also grow by factorγ(k1,k2).Whenever a newly created label dominates another one w.r.t.resources, the update of the running-hole sets of the latter requires onlyO((k1+k2)ω(k1,k2))time. Note that dominance compares pairs of labels so that the overall factor is bounded byO((k1+k2)ω(k1,k2)γ(k1,k2)2). This is a constant wheneverk1andk2are fixed.We have the following final result:Theorem 4For fixed k, labeling for the CARP with combined(k,2)-loop elimination can be performed inO(CD(n,m))time, whereCis the vehicle capacity andD(n,m)the time of performing the Dijkstra algorithm.This section reports computational results of the branch-and-price algorithm for the CARP first presented in Bode and Irnich (2012) when(k,2)-loop free relaxations fork∈{2,3,4}are used. We quantify the impact of the different(k,2)-loop free relaxations on the computation time and the overall best lower bound achieved at the end of the branch-and-price. The branching scheme presented in Bode and Irnich (2012) consists of three levels of branching decisions: First branching on non-even node degrees, and second branching on edges with fractional edge flow. Both decisions have no impact on the structure of the pricing problem. The third decision is branching on follower information, whenever the information if two edges are serviced consecutive is fractional. This branching rule, however, modifies the network of the underlying graph of the pricing problem. In particular, it requires a second task set to be handled in the SPPRC labeling algorithm that solves the pricing subproblem.For the branch-and-price, no initial upper bound is given and the node selection rule in branch-and-bound is best-bound first. Note that the same formulation of the (restricted) master problem is used as in Bode and Irnich (2012), while for the pricing subproblem the following modifications are made: Whenever possible, the simple k-loop elimination pricing is used. If, however, any non-follower constraints is active, the simple k-loop elimination pricing is replaced by(k,2)-loop elimination pricing. Moreover, we use standard heuristic pricing procedures and acceleration techniques for exact pricing as presented in the companion paper (Bode & Irnich, in press). The two acceleration techniques applied are bounding with the 2-loop elimination relaxation and bi-direction labeling; for details we refer to Mingozzi, Bianco, and Ricciardelli (1997), Baldacci, Mingozzi, and Roberti (2011b, 2011a), Righini and Salani (2006).The computational study uses two standard benchmark sets from the literature: The first benchmark set egl was introduced by Eglese and Li (1992) and can be downloaded from http://www.uv.es/∼belengue/carp/. This set consists of 24 instances based on the road network of Cumbria. The first 12 instances have 77 nodes and 98 edges, whereas the remaining 12 instances are larger and have 140 nodes and 190 edges. Instances with the same graph size further differ in the number of required edges and the vehicle capacity. The second benchmark set bmcv consisting of 100 instances is obtained from the road network of Flanders, Belgium (Beullens, Muyldermans, Cattrysse, & van Oudheusden, 2003). These instances range from 26 to 97 nodes and 35 to 142 edges, where only a subset of the edges is required. The instances were kindly provided by Muyldermans (2012) and the transformed instances into the standard format can be downloaded from http://logistik.bwl.uni-mainz.de/Dateien/bmcv.zip. These instances comprise four subsets, where the underlying graph for individual instances of subset C and E is identical, but the vehicle capacity is 300 for the C set and 600 for the E set. The same holds for the subsets of instances named D and F.All computations were performed on a standard PC with an Intel©Core™ i7-2600 at 3.4GHz processor with 16GB of main memory. The algorithm was coded in C++ (MS-Visual Studio, 2010) and the callable library of CPLEX 12.2 was used to iteratively reoptimize the RMP. A hard time limit of four hours for computation has been set for the column-generation and branch-and-price algorithms.To shorten the notation, we will skip the second entry in(k,2)so that, in the following, k-loop is a shortcut for(k,2)-loop-free. Since a comprehensive study of linear relaxation results for k-loop elimination with and without activated acceleration techniques are presented in Bode and Irnich (2012), Bode and Irnich (in press), this section focuses on integer results obtained when the branch-and-bound ends (either with an optimal solution or when the given time limit is reached). Tables 1–5present the integer results for the egl and bmcv instances. The header entries in all tables have the following meaning:instancename of the instance(for egl instances the prefix egl- is omitted for the sake of brevity)ubbestoroptthe best known upper bound (not underlined) or the optimum (underlined) reported in Beullens et al. (2003) or Bartolini, Cordeau, and Laporte (2012)lbrootlower bound that results from solving the linear relaxationlbtreelower bound provided by the branch-and-price algorithm within the time limit of four hours; (rounded up to the next integer)‘OPT’ indicates that the instance is solved to proven optimality within four hoursif the value oflbtreematches the best known upper bound the gap was closed, but no integer optimal solution was computed within the time limittimecomputation time in seconds; if the time limit is reached it is indicated by 4hB&Bnodesreport the number of solved branch-and-bound nodeslbownbestor newopt̲best lower bound over all relaxations tested here; underlined if optimality gap is closedlbknownbestbest lower bounds round to a multiple of five reported in Beullens et al. (2003) or Bartolini et al. (2012)lbBCLbestor newopt̲best lower bounds reported in Bartolini et al. (2013); underlined if optimality gap is closedThe following additional information is given for the respective relaxation:Numlbownbestnumber of instances for which the best lower boundlbownbestwas reachedNum optnumber of integer optimal solutionsavg timeaverage time for branch-and-price (with maximum time 4h)avg%gapaverage gap computed as(ubbest-lbtree)ubbest×100Lower bounds written in bold indicate that this bound is a new best bound exceeding the best known lower bounds from the literature. The upper boundsub=11529for the instance egl-e4-c andub=4650for the bmcv instance E11 (written in bold also) result from new best integer solutions found with branch-and-price.For the egl-instances, average lower bound values increases with increasing k: The average gap for 2-loop relaxation is0.54, while it is0.46and0.43for 3-loop and 4-loop, respectively. There are four exceptions (e4-a, s3-a, s3-b and s4-a) where 2-loop relaxation results in better lower bound when the time limit of four hours is reached. Regarding the computation time, 2-loop relaxation performs better for the group of smaller instances (egl-e), while the two optimal solutions in the second group (egl-s) are computed fastest with 4-loop relaxation. Overall, three new best lower bounds are obtained for e2-b, e3-b and e4-c with 3-loop and 4-loop relaxation.For the subsets D and F of bmcv instances, 2-loop relaxation gives the best results both regarding bounds and computation times, meaning that the number of best lower bounds and optimal integer solutions is the highest. Moreover, on average the computation times and the gap is also smaller compared to 3-loop or 4-loop. However, for the subsets C and E with smaller vehicle capacity, results are different: While the number of best lower bounds is still highest with 2-loop relaxation, 3-loop produces for the subset C the same number of integer solutions and the same average gap. Moreover, the average computation time decreases for 3-loop. Within the subset E, 4-loop relaxation results in more best lower bounds and obtains more integer solutions than 2-loop. Moreover, the average computation time and gap are also smaller for 4-loop than for 2-loop.Overall, we are able to obtain 19 new best lower bounds out of 33 previously unsolved bmcv instances (5 for subset C, 4 for subset D, 6 for subset E and 4 for subset F). Thereof, 15 instances (C04, C19, C21, C24, D08, D14, D19, E11, E16, E19, E20, E24, F04, F08 and F12) are solved to optimality for the first time. Bartolini et al. (2012) mentioned that the objective value is always a multiple of five. Using this fact, optimality can be proven also for instances D23 and F23.In comparison to the recent results presented by Bartolini et al. (2013) (developed in parallel to our algorithm), their approach produces some impressive results: They improve five lower bounds for the egl instances where we improve three. Interestingly, the algorithms are complementary, since improvements of both approaches are made on seven different instances. For the bmcv instances, they improve the lower bounds for 11+8+5+5=29 instances, where we improve 4+6+4+4=18. Moreover, they deliver 6+7+4+5=22 optimality proofs, while we prove optimality in 4+5+4+4=17 cases.At the end, 12 egl instances and 10 bmcv instances remain open.

@&#CONCLUSIONS@&#
We have presented a new dynamic programming labeling algorithm for handling combined task-(k1,k2)-loop elimination (withk1,k2⩾2) in SPPRC for situations where loops with respect to two different task sets must be avoided. Compared to standard SPPRC without loop elimination, the proposed dominance relation is still efficient in the following sense: Labels need to be extended by additional attributes (the so-called set forms), where each set form hask1+k2entries and not more thanω(k1,k2)=(k1-1)!2·(k2-1)!2·(k1-1)+(k2-1)k1-1different set forms need to be stored. While in standard SPPRC there is at most one label per state, the maximum number of labels with identical state cannot exceedγ(k1,k2)=[k1+k2-1]·(k1-1)!2·(k2-1)!2·(k1-1)+(k2-1)k1-1. Even if these values grow fast withk1andk2, for fixedk1andk2, the boundsω(k1,k2)andγ(k1,k2)are constants. Together with the presented update procedures for the attributes these constants guarantee that, for fixedk1andk2, the worst-case computational complexity for solving standard SPPRC and SPPRC with combined task-(k1,k2)-loop elimination is identical.We have applied the new labeling algorithm for SPPRC with combined task-(k,2)-loop elimination for solving pricing subproblems in a branch-and-price algorithm for the CARP. It was known from the work of Bode and Irnich (2012) that task-k-loop elimination can significantly improve bounds of the linear relaxation of the column-generation master program. However, branching, i.e., a genuine branch-and-price was not possible due to the branching rule implying 2-loop elimination constraints on a new task set. The new results using the SPPRC subproblem relaxation with task-(k,2)-loop elimination allow for a comparison of overall computation times and lower bounds when the branch-and-price algorithm terminates. Using standard benchmark set, we have shown that the approach is competitive: Several new best lower bounds were presented and some knowingly hard instances were solved to proven optimality for the first time.This section contains proofs of the worst-case complexity results for combined(k1,k2)-loop elimination as introduced in Section 2.3. Note that the proofs follow similar ideas as discussed in the first article on k-cycle elimination (focused on node-routing applications) and we refer the reader to this (Irnich & Villeneuve, 2006) for a more detailed motivation.Theorem 1For combined(k1,k2)-loop elimination, the maximum number of different set forms needed to represent any intersection of self-hole setsH(P1)∩H(P2)∩⋯∩H(Pl)of any set of l paths isω(k1,k2)≔(k1-1)!2·(k2-1)!2·(k1-1)+(k2-1)k1-1. This boundω(k1,k2)is tight.DefineI1(s),I2(s)of an arbitrary set formss=(s11,…,sk1-11)(s12,…,sk2-12)withsi1∈T1∪{·}andsj2∈T2∪{·}asI1(s)≔{i∈{1,…,k1-1}|si1=·}andI2(s)≔{j∈{1,…,k2-1}|sj2=·}Let theI(s)=(I1(s),I2(s))be the type of an arbitrary set form s. To shorten the notation we will writeI=(I1,I2)instead ofI(s)=(I1(s),I2(s)). We denote bynk1,k2(I)the maximum number of different set forms that can be generated from a set form of type I by intersection with arbitrarily chosen self-hole sets.nk1,k2is defined on all subsetsI=(I1,I2)⊆({1,…,k1-1},{1,…,k2-1}). The following recurrences are valid fornk1,k2:nk1,k2(∅,∅)=1nk1,k2(I)=∑i∈I1(k1-i)nk1,k2(I1⧹{i},I2)+∑j∈I2(k2-j)nk1,k2(I1,I2⧹{j})∀I1⊆{1,…,k1-1}andI2⊆{1,…,k2-1}andI≠(∅,∅)The first equation is clear. The second equation is implied by the intersection operation. For each position l there are eitherk1-lork2-ldifferent possibilities to place an element of the self-hole set at this position. This recurrence is solved bynk1,k2(I)=|I1|!∏i∈I1(k1-i)|I2|!∏j∈I2(k2-j)|I1|+|I2||I1|.This can be seen by induction on the cardinality of I. ForI=(∅,∅)this givesnk1,k2(∅,∅)=1, which is correct. Now assume, that the above equality is true for all subsets with cardinalityI-1.nk1,k2(I)=∑i∈I1(k1-i)nk1,k2(I1⧹{i},I2)+∑j∈I2(k2-j)nk1,k2(I1,I2⧹{j})=∑i∈I1(k1-i)(|I1|-1)!∏l∈I1⧹{i}(k1-l)|I2|!∏m∈I2(k2-m)|I1|+|I2|-1|I1|-1+∑j∈I2(k2-j)|I1|!∏l∈I1(k1-l)(|I2|-1)!∏m∈I2⧹{j}(k2-m)|I1|+|I2|-1|I1|=∑i∈I1(|I1|-1)!(k1-i)∏l∈I1⧹{i}(k1-l)|I2|!∏m∈I2(k2-m)|I1|+|I2|-1|I1|-1+∑j∈I2|I1|!∏l∈I1(k1-l)(|I2|-1)!(k2-j)∏m∈I2⧹{j}(k2-m)|I1|+|I2|-1|I1|=∑i∈I1(|I1|-1)!∏l∈I1(k1-l)|I2|!∏m∈I2(k2-m)|I1|+|I2|-1|I1|-1+∑j∈I2|I1|!∏l∈I1(k1-l)(|I2|-1)!∏m∈I2(k2-m)|I1|+|I2|-1|I1|=∏l∈I1(k1-l)∏m∈I2(k2-m)∑i∈I1(|I1|-1)!|I2|!|I1|+|I2|-1|I1|-1+∑j∈I2|I1|!(|I2|-1)!|I1|+|I2|-1|I1|=|I1|!∏l∈I1(k1-l)|I2|!∏m∈I2(k2-m)|I1|+|I2|-1|I1|-1+|I1|+|I2|-1|I1|=|I1|!∏l∈I1(k1-l)|I2|!∏m∈I2(k2-m)|I1|+|I2||I1|The above expression proves that we can get at most(k1-1)!2·(k2-1)!2·(k1-1)+(k2-1)k1-1different elements in the intersection. To show that this bound is tight we choose anyk¯=k1+k2different pathsP1,…,Pk¯with disjoint predecessor tasks on both task-sets. Then the intersection of the corresponding self-hole sets consists of exactly(k1-1)!2·(k2-1)!2·(k1-1)+(k2-1)k1-1elements.Theorem 2A collection ofgdominating pathsP1≺domP2≺dom…≺domPgending at the same node is given. Let the intersections of the corresponding self-hole setsH(P1),H(P2),…,H(Pg)form a properly decreasing chain, i.e.,H(P1)⊋H(P1)∩H(P2)⊋⋯⊋⋂i=1gH(Pi). Then, the lengthgof the properly decreasing chain is bounded byγ(k1,k2)=[k1+k2-1]·(k1-1)!2·(k2-1)!2·(k1-1)+(k2-1)k1-1.Every new element of the chain is a result of the intersections made before with one new intersection with a self-hole setH(Pi). From Theorem 2 we know that there are at maximum(k1-1)!2·(k2-1)!2·(k1-1)+(k2-1)k1-1different set forms in such an intersection. Every set form has(k1-1)+(k2-1)entries which results in[(k1-1)+(k2-1)](k1-1)!2·(k2-1)!2·(k1-1)+(k2-1)k1-1different entries in total. For the computation of the intersection there are two possible operations:1.A new set form is generated, where a previously free entry·is specified by an elementt1∈T1ort2∈T2. There exists at most[(k1-1)+(k2-1)]·(k1-1)!2·(k2-1)!2·(k1-1)+(k2-1)k1-1possible entries to specify.On the other hand, a set form can be deleted. This can happen at most(k1-1)!2·(k2-1)!2·(k1-1)+(k2-1)k1-1times.