@&#MAIN-TITLE@&#
Atomic routing in a deterministic queuing model

@&#HIGHLIGHTS@&#
New model for atomic dynamic routing games (bottleneck and makespan/sum objective).Polynomial time algorithms for computing maximum and quickest dynamic flows.Greedy-type methods compute Nash equilibria in the dynamic game with sum objective.Dynamic minimum bottleneck flows and ”narrowest paths” are NP-hard to compute.Nash equilibria for bottleneck objective may not exist, test and decision are NP-hard.

@&#KEYPHRASES@&#
(I) Game theory,(B) Routing,Dynamic atomic unsplittable flows,Equilibria,Optimal solutions,Complexity,

@&#ABSTRACT@&#
The issue of selfish routing through a network has received a lot of attention in recent years. We study an atomic dynamic routing scenario, where players allocate resources with load dependent costs only for some limited time.Our paper introduces a natural discrete version of the deterministic queuing model introduced by Koch and Skutella (2011). In this model the time a user needs to traverse an edgeeis given by a constant travel time and the waiting time in a queue at the end ofe. At each discrete time step the firstueusers of the queue proceed to the end vertex ofe, whereuedenotes the capacity of the edgee. An important aspect of this model is that it ensures theFIFOproperty.We study the complexity of central algorithmic questions for this model such as determining an optimal flow in an empty network, an optimal path in a congested network or a maximum dynamic flow and the question whether a given flow is a Nash equilibrium.For the bottleneck case, where the cost of each user is the travel time of the slowest edge on her path, the main results here are mostly bad news. Computing social optima and Nash equilibria turns out to beNP-complete and the Price of Anarchy is given by the number of users.We also consider the makespan objective (arrival time of the last user) and show that optimal solutions and Nash equilibria in these games, where every user selfishly tries to minimize her travel time, can be found efficiently.

@&#INTRODUCTION@&#
Routing by independent users in a network can be viewed as a non-cooperative game, where selfish players choose their routes through the network (see e.g.  [1,2]). From the game-theoretic point of view one can expect the routes chosen by the users to form a Nash equilibrium   [3] or a strong equilibrium  [4], which, in general, does not constitute an overall optimal solution (see  [5]). The highest ratio of the social objective of a (strong) Nash equilibrium to the optimal objective is called (strong) Price of Anarchy and gives a measure for the maximum lack of performance that arises due to selfish behaviour (see  [6–8]).The issue of selfish routing has received a lot of attention in the recent years, from both the theory as well as the networking communities. Most of the work in the literature has been on static routing, where a user induces load on all edges of her path simultaneously. Recently dynamic models have gained more attention (see  [9,10]). Here, each user travels through the network, and at any point in time she only adds load to the edge she is currently using.We consider a natural discrete version of the deterministic queuing model introduced by Koch and Skutella  [11]. Here, each edge has a constant travel time and a capacity that states the number of users who can leave an edge per time unit, while the others have to wait until the next point in time. The users leave the edge in the same order as they entered it (FIFOproperty). In the case that multiple users enter the edge at the same time different tie breaking rules are discussed. The goal is to find a flow with minimum travel time. In a game-theoretic context of a dynamic congestion game, each user chooses a path s.t. her personal travel time is minimized.Most of our work is on bottleneck problems where the cost of a user is the most expensive resource on her path. There are several applications which motivate this model in the dynamic setting (for more applications of bottleneck games we refer to Banner and Orda  [12]).In the transport of living cargo (livestock) within the European Union there are numerous regulations regarding travel times and resting periods, see  [13]. In particular, there are upper limits for the travel times between two stops. At every stop, livestock need to be fed/watered and inspected. In this setting, the links of the network do not correspond to physical roads but rather to aggregated travel routes between two replenishing points, so that a feeding/watering stop is mandatory after the traversal of every arc. The total time spent on a link, i.e., the constant travel time plus the time in the waiting queue, reflects the (aggregated) travel time, where the waiting time in a queue is due to congestion, e.g. at loading docks. Different types of vehicles have different effects on the congestion. Since for instance in extreme weather livestock suffer during transport and waiting, the bottleneck value on a path through the network can be viewed as an indicator of the risk for the animals. Due to the mandatory stops after every link, in fact the maximum travel time of a link is more appropriate here than the total travel time. Even though the links correspond to aggregated routes, still typical rules of traffic networks such as regulations about the right of way apply (e.g. major roads/minor roads, left-before-right-rule). This motivates the study of local tie-breaking rules when users enter a link simultaneously.A second application occurs in routing in all-optical networks. Whenever more than one data packet arrives at a network node at the same time and multiple packets are destined for the same output, blocking occurs. In general, packets are processed in a first-in-first-out (FIFO) matter at every node, but there is also local priority ordering of the input ports associated with the node. Instead of dropping all but one packet, the current state-of-the-art technology uses fibre delay lines (FDLs) to delay the light, where packets circle until they can be forwarded, see e.g.  [14–16]. For more information about all-optical networks we refer to standard textbooks such as  [17]. There is a natural correspondence to waiting in an FDL and users spending time in the waiting queue in our model. The optical information deteriorates both on the links and in the fibre delay lines, but can be regenerated when the packet is finally forwarded. Since optical regeneration components are expensive (and somewhat slow), the FDLs are typically not equipped with this technology. The overall goal of a “good” routing is to minimize the maximum time between two nodes, the bottleneck value.A related application occurs in (not necessarily all-optical) communication networks. As mentioned in  [12], due to limited size of transmission buffers, there is an interest for the users who are sending data through the network to minimize the utilization of the most utilized buffer in order to avoid deadlocks and reduce packet loss. While Banner and Orda  [12] considered the situation that a user permanently uses capacity on her chosen path, we consider a dynamic setting where this capacity is released once the data has left the link.In a game-theoretic context, each message is sent by a selfish user who attempts to minimize the bottleneck value only on her path. If information from different edges enter a single node and a single edge with low capacity afterwards tie-breaking rules are needed to decide which user’s information is processed first. In the networks considered here, the purifier acts on the information from one channel after the other and the order of the messages in one channel remains as it was before.For other applications of (static) bottleneck games we refer to  [12].

@&#CONCLUSIONS@&#
In this paper we investigated atomic dynamic routing games for a deterministic queuing model for sum and bottleneck objectives. We showed that quickest flows and Nash equilibria in the sum version can be computed efficiently, while the computation of narrowest paths/flows or Nash equilibria in the bottleneck version areNP-hard. Our work raises several challenging questions: first, what conditions ensure that Nash equilibria exist in the bottleneck case and when can such an equilibrium be computed efficiently? Second, how can the model be modified in such a way that in the atomic case more problems become tractable (and still the model can be considered “realistic”)?Here we give the proofs from Section  6 that have been omitted before. The first lemma establishes some basic properties of dynamic flows in the deterministic queuing model.Lemma 12For any dynamic flowfin the deterministic queuing model with time horizonTand any edgee∈E, and moment in timet≥0, it holds that the difference between flow entering edgeeup to timet−τeand flow leaving the edge up to timetis given by the size of the waiting queue after timet, that is,(A.1)∑θ=0t−τefeα(θ)−∑θ=0tfeω(θ)=max{feq(t)−ue,0}≥0.At the end (time horizonT) flow that entered edgeealso left the edge, i.e.,(A.2)∑θ=0Tfeα(θ)=∑θ=0Tfeω(θ).The amount of flow leaving the outgoing edges fromv∈Vafter timet+τemust be at least as high as the amount of flow enteringvafter timet. More precisely(A.3)∑e∈δ+(v)∑θ=t+τeTfeω(θ)−∑e∈δ−(v)∑θ=tTfeω(θ)≥0.ProofLetfbe a dynamic flow in the deterministic queuing model with time horizonT,e∈E,t≥0. An easy calculation yields:(A.4)∑θ=0t−τefeα(θ)=∑θ=τetfeα(θ−τe)=∑θ=0tfeα(θ−τe)=(3)∑θ=0tfeq(θ)−max{0,feq(θ−1)−ue}=∑θ=0tfeq(θ)−∑θ=0tmax{0,feq(θ−1)−ue}=∑θ=0tfeq(θ)−∑θ=0t−1max{0,feq(θ)−ue}=∑θ=0tfeq(θ)−∑θ=0tmax{0,feq(θ)−ue}+max{feq(t)−ue,0}.Iffeq(θ)>ue, then we have:feq(θ)−max{0,feq(θ)−ue}=feq(θ)−(feq(θ)−ue)=ue=min{ue,feq(t)}=(4)feω(θ).On the other hand, iffeq(θ)<ue, thenfeq(θ)−max{0,feq(θ)−ue}=feq(θ)=min{feq(θ),ue}=(4)feω(θ).Using the above two calculations in (A.4) now yields the first claim of the lemma.We proceed with the second claim. After the last time step the waiting queue has to be empty. So we must have thatfeq(T)≤ue. Furthermore, any flow entering after timeT−τecannot reach the terminal vertex up to timeT. Sofeα(θ)=0forθ>T−τe. Using these two properties in (A.1) implies the second claim.For the last claim, observe that for any vertexv∈V∖{s,t}:(∗)0=excessf(v,t)=(5)∑e∈δ−(v)∑θ=0tfeω(θ)−∑e∈δ+(v)∑θ=0tfeα(θ)≤(A.1)∑e∈δ−(v)∑θ=0tfeω(θ)−∑e∈δ+(v)∑θ=0t+τefeω(θ).So, for all0≤t≤Tthis implies that0=excessf(v,T)=(5)∑e∈δ−(v)∑θ=0Tfeω(θ)−∑e∈δ+(v)∑θ=0Tfeα(θ)=(A.2)∑e∈δ−(v)∑θ=0Tfeω(θ)−∑e∈δ+(v)∑θ=0Tfeω(θ)=∑e∈δ−(v)∑θ=0t−1feω(θ)−∑e∈δ+(v)∑θ=0t+τe−1feω(θ)︸≥0by(∗)+∑e∈δ−(v)∑θ=tTfeω(θ)−∑e∈δ+(v)∑θ=t+τeTfeω(θ)≥∑e∈δ−(v)∑θ=tTfeω(θ)−∑e∈δ+(v)∑θ=t+τeTfeω(θ).This settles the claim.□With the lemma from above we show that the capacity of any dynamic cut is an upper bound for the flow value of any flow in the dynamic queuing model as stated in Theorem 7.Theorem 13For any dynamic flowfin the deterministic queuing model and any dynamic cutX(both with time horizonT) we have:val(f)≤U(X).ProofFirst, note that(A.5)∑e∈δ+(t)∑θ=ξt+τeTfeω(θ)−∑e∈δ−(t)∑θ=ξtTfeω(θ)=0,sinceξt=T+1and hence there are in fact no summands left.For any dynamic flowfin the deterministic queuing model and any cutXwith timesξvforv∈V, whereξs=0, we have:0≤val(f)=−excessf(s,T)=∑e∈δ+(s)∑θ=0Tfeω(θ)−∑e∈δ−(s)∑θ=0Tfeω(θ).We usefeω(θ)=0fore∈δ+(s)andθ<τe, add Eq. (A.3) for allv∈V∖{s,t}together with the equation from above for vertext:≤∑v∈V(∑e∈δ+(v)∑θ=ξv+τeTfeω(θ)−∑e∈δ−(v)∑θ=ξvTfeω(θ))≤∑e∈Ee=(u,v)∑θ=ξu+τeTfeω(θ)−∑e∈Ee=(u,v)∑θ=ξvTfeω(θ)≤∑e∈Ee=(u,v)∑θ=ξu+τeξv−1feω(θ)≤∑e∈Ee=(u,v)max{ξv−ξu−τe,0}ue=U(X).□The next goal is to show that a temporally repeated flow in the flow over time model can be converted to a flow in the deterministic queuing model with the same flow value. A general version of the algorithm can be seen in Algorithm 1.Some explanations for the algorithm are given in the following remark:Remark 1•Te: The algorithm computes inflow ratesXPfor all pathsP∈Pefor every edgee. For better reading, rates from previous iterations are denoted byX, rates that are currently computed and stored for later iterations are denoted byY. For all timestwhere one of the entries from(XP)P∈Pechanges or a path becomes inactive atewe store an entry(t;(XP)P∈Pe)in a listTesorted by the time in an increasing order. So, starting at timetall pathsP∈Pehave flow valuesXPthat state how many units of flow are available to be sent along edgeeper time unit until the next time in the listTe. For simplification of notation we define the following: if for timetflow values for some pathsP∈Peare missing, i.e., we have an entry(t,(XP)P∈P′)for some strict subsetP′⊂Pe, then they are set to the previous flow value forPinTe, i.e., the flow value forPfor the maximum timet′≤tfor which there is a flow value for pathPor to 0 if there is no such value. So we can assume that all entries we remove ofTehave the form(t,(XP)P∈Pe), even if we only added(t,(XP)P∈P′)for some subsetP′⊆PetoTebefore. During the algorithm we add entries(t,YP)toTe. This is done under the constraint that an entry with the same flow value has not been added before. That means we only add the entry, if the flow value forPfor the maximum timet′≤tfor which there is a flow value for pathPdiffers from the current valueYP. Furthermore, the list never contains a time twice.Note that flow starting at timeT+1−τP(v,t)added toTefore=(v,w)∈Ein Step 1 cannot reach the terminal vertextup to the time horizonT. We show in Lemma 15 that the total amount of flow entering an edgeein pathPin the temporally repeated flow up to timetis also allocated toPateup to timet. Hence, there is no unit of flow available for allocation at edgeeat timeT+1−τP(v,t).*1 in Step 2: The graphG′=(V,E′)that consists of the edges from the pathsPof the path decomposition of a maximum temporally repeated flowfˆis acyclic. This follows from the fact that the maximum temporally repeated flow is obtained via a flow decomposition of a minimum cost flow (see e.g.,   [34]). Since we assumed that all travel times are strictly positive, a cycle in the decomposition would contradict the optimality of the minimum cost flow. Thus, we can assume that the vertices inG′are numbered according to a topological sorting, and that in Step 2 the edges are considered in the order of the topological sorting of their starting vertices.*2 in Step 7: The maximum time spanθ˜Pthe flow valuefPof pathPcan be utilized can be computed as follows: if the amount of flow available per timeXPis at least as high as the flow valuefP, i.e.,XP≥fP, then this value can be utilized for the whole time interval, i.e.,θP=θ. Otherwise,XP<fP. Then the length of the time interval is decreased to some valueθP. The minimum amount of flow (fPθP) allocated during the interval (of lengthθP) cannot exceed the amount of flow available (WP+θPXP) during that interval. This yieldsθP=⌊WPfP−XP⌋in that case. Furthermore, we know by step 6 thatfP≤XP+WP. WithXP<fPwe getθ˜P=WPfP−XP≥1.The maximum time spanθ˜ethe capacityucan be utilized can be computed as follows: if the amount of flow available per timeXe=∑P∈Pe′XPis at least as high as the capacityu, i.e.,Xe≥u, then this value can be utilized for the whole time interval, i.e.,θe=θ. Otherwise,Xe<u. Then the length of the time interval is decreased to some valueθe. The minimum amount of flow (uθe) allocated during the interval (of lengthθe) cannot exceed the amount of flow (∑P∈Pe′(WP+θeXP)) available during that interval. This yieldsθe=⌊∑P∈Pe′WPu−Xe⌋in that case. Furthermore, we know by step 6 thatu≤∑P∈Pe′(XP+WP). Soθ˜e≥1.Thenθ˜=min{θe,θP∣P∈Pe′}.For the last edgeein a pathPthere is no subsequent edgeeP. So, the amount is stored for the terminal vertextinstead.Lemma 14The integer program in Step  7  of the algorithm has a solution, which can be computed in time풪(m).ProofFor the ease of notation we writebP=XP+⌊WPθ⌋. First we show that the program is feasible, i.e.,∑P∈Pe′fP≤u≤∑P∈Pe′bP. The second inequality follows directly from the definition ofu≤∑P∈Pe′bP. To see the first inequality we distinguish between two cases. Letu=ue. By definition we havefP≤fˆP. A temporally repeated flow meets the capacity constraints of the network, i.e.,∑P∈PefˆP≤ue. So, we get∑P∈PefP≤ue=u. Now, letu=∑P∈Pe′bP. To see the first inequality we partitionPe′=P1∪P2s.t.fP=fˆP≤bPforP∈P1andfP=bPforP∈P2. Then∑P∈Pe′fP=∑P∈P1fˆP+∑P∈P2bP≤∑P∈Pe′bP=u.The integer program is feasible and can be written in the following form:∑P∈Pe′YP=u,fP≤YP≤bPfor allP∈Pe′,YP∈N, where all data is integral. It is easy to see that the corresponding matrix is totally unimodular (see e.g.,   [35]). Hence, a solution can be computed efficiently. Furthermore, a solution can also be given explicitly by assigning the minimum value to the all paths and distributing the remaining amount of flow arbitrarily among the paths without violating the upper bounds. In fact, this can be done in linear time풪(m).□The following lemma states that the algorithm transforms a maximum temporally repeated flow to a flow in the deterministic queuing model which sends the same amount of flow within the same time horizon.Lemma 15The dynamic flow in the deterministic queuing model with time horizonTconstructed by Algorithm  1  has the same flow value as the maximum temporally repeated flow with time horizonTused as input for the algorithm.ProofFirst we show that the algorithm is well-defined in the sense that every step can be carried out. We show some properties by induction on the number of edges in a pathPconsidered so far in the for-loop of Step 2. To that end letT˜e={t1,…,tμ}be the set of all times added to the listTefor edgee=(v,w)during the algorithm withti<ti+1fori∈{1,…,μ−1}. We show by induction ontwitht+1∈T˜ethe following statements:(1)The algorithm allocates at leastdP,e,t=fˆP⋅min{t+1−τP(s,v),T+1−τP}units of flow to pathPat edgee=(v,w)∈Pup to timet, which is the amount the temporally repeated flowfTwith time horizonTroutes along pathPat edgee. In particular, it allocatesFP=fˆP(T+1−τP)units of flow toPat edgeeup to timeT−τP(v,t).At a start of the while-loop, the listTein Step 6 of the algorithm consists of at least one timetα<T+1−τP(v,t)where the flow rateXPor the amount of flow in the bufferWPis greater than zero. Furthermore, it consists of time (T+1−τP(v,t)).The lower bound computed in Step 6 fulfilsfP>0and the solution of the integer program in Step 7 fulfilsYP>0.τP(s,v)is the smallest time inT˜eand there is some amount of flow available for allocation at that time, i.e.,XP+WP>0for these variables at that time.Induction start (for the edges): We start with the first edgee=(s,u)of pathP. ThenT˜eincludes timesτP(s,s)=0andT+1−τP>0. Since there is never a smaller time added toTe, 0 is the smallest time inT˜e. The induction on the time starts with the first timetwitht+1∈T˜e, i.e.,t=t1−1=−1. At that time no flow is sent in both models and hence there is also no iteration and nothing to show. At the start of the iteration for edgee=(s,u)(at timet1) the bufferWPis set to the total amount of flowFPthat has to be allocated toPate. The amount in the buffer is reduced in Step 11 by the amount allocated to pathP.For the induction step (for the time) at the first edges consider some timet=ti+1−1withti+1∈T˜e,i∈{1,…,μ−1}and the iteration from timetiup to timet=ti+1−1. LetD≥0be the amount of flow that has already been allocated toPateup to timeti−1. If allFPunits of flow have already been allocated to pathPup to timeti−1, then we are done, since statement (1) is satisfied and no more iteration of the while-loop is executed in the algorithm. Otherwise, the if-condition in Step 10 was not satisfied in the previous iteration that ended at timeti−1. So, we consider timetiinTeat the start of the while-loop. The amount of flow in the buffer at that time is positive, i.e.,WP>0. Sincet=ti+1−1, there is also timeT+1−τP=tμ≥ti+1=t+1>tin the setTe, which shows (2). We have to show that at leastdP,e,ti+1−1=fˆPti+1units of flow are allocated toPateup to timeti+1−1. By induction hypothesis ontwe know thatD≥dP,e,ti−1=fˆPtiunits of flow have already been allocated toPateup to timeti−1. IfWP≥fˆP, then alsoYP≥fP=fˆP>0(showing (3)) and hence, at leastfPunits of flow are allocated toPateper time. So, in total at leastdP,e,ti−1+fˆP(ti+1−1+1−ti)=fˆPti+1=dP,e,ti+1−1units of flow are allocated toPateup to timeti+1−1. OtherwiseWP<fˆP. ThenD>FP−fˆPand less thanfˆPunits of flow remain to be allocated. ThenYP=fP=WP>0(showing (3)) and hence, at leastWPunits of flow are allocated toPateper time. So, in total at leastFP≥dP,e,ti+1−1units of flow are allocated toPateup to timeti+1−1. In particular,FPunits of flow are allocated toPateup to timeT+1−τPand hence, no larger time is added toT˜e.Induction step (for the edges): Consider pathPat some edgee=(v,w)∈E∖δ+(s). By induction hypothesis one, for the previous edgee′=(u,v)inPbeforeewe havet1′=τP(s,u)as the smallest andtμ′′=T+1−τP(u,t)as the largest time in the setT˜e′by (4). Furthermore, the firstYP>0units of flow are made available for allocation forPateat timeτP(s,v). Hence, for the induction start at a time smaller thanτP(s,v)there is nothing to show.For the induction step (for the time) at the edgeeconsider some point in timet=ti+1−1withti+1∈T˜e,i∈{1,…,μ−1}and the iteration from timetiup to timet=ti+1−1. LetD≥0be the amount of flow that has already been allocated toPateup to timeti−1and consider timetiinTeat the start of the while-loop. If allFPunits of flow have already been allocated to pathPup to timeti−1, then we are done, since statement (1) is satisfied and no more iteration of the while-loop is executed in the algorithm. Otherwise, the if-condition in Step 10 was not satisfied in the previous iteration that ended at timeti−1(or the current iteration is the first one).If the flow rate satisfiesXP>0during the iteration starting at timeti, thenTeincludes timetiwithXP>0as claimed. OtherwiseXP=0. Then, the last iteration for pathPat the previous edgee′ended before timeti−τe′, since otherwiseYP′>0units of flow would have been made available for timetiin that iteration (by (3)). So, by induction hypothesis,FPunits of flow have been allocated toPateup to timeti−1−τe′. Hence, they are available for allocation ateup to timeti−1. Since they have not been allocated toPateso far, the remaining amount is stored in the buffer, i.e.,WP>0. So, we always haveXP+WP>0at the start of the while-loop. WithfˆP>0this implies thatfP>0. Since the integer program always has a feasible solution we haveYP≥fP>0. This shows (3).By induction hypothesis on the timetwe know thatD≥dP,e,ti−1units of flow have already been allocated toPateup to timeti−1. By induction hypothesis onewe know that at leastdP,e′,t−τe′=dP,e,tunits of flow have been allocated to the previous edgee′inPbeforeeup to timet−τe′and hence are available for allocation toPateup to timet. IfD≥dP,e,t, then we are done.Otherwise,D<dP,e,t. But we know by the argumentation above that the amount of flow available for allocation toPateup to timetis at leastdP,e,t. Hence, at least the missingdP,e,t−Dunits of flow are available for allocation up to timet, i.e., in the algorithm we haveθXP+WP≥dP,e,t−Dwithθ=ti+1−ti=t+1−ti. IfXP+WP≥fˆP, we are also done, because then at leastfP=fˆPunits of flow are allocated by the algorithm per time betweentiandt, i.e., in total at leastdP,e,ti−1+fˆPθ=fˆP(ti−τP(s,v)+θ)=fˆP(t+1−τP(s,v))=dP,e,tunits of flow up to timet.Else, we havefP=XP+WP<fˆP. Then all units of flow that have been made available forPateup to timeti(at leastdP,e,tiunits of flow), except for thosefPunits above, have already been allocated toP. Ifti=t, thenD+XP+WPis exactly the amount of flow available for allocation forPateup to timet. We already know that (by induction hypothesis one) it is at leastdP,e,t. Since it is allocated in the current iteration we are done.Otherwise, we haveti<t, i.e.,ti<t<ti+1. Since there is no time in the listT˜ein between andYP≥fP=XP+WP, the buffer is empty at timeti+1≤t. Since the inflow rateXPdoes not change (otherwise there would be another time inT˜e) we haveWP=0at timeti. Hence,fP=XPandWP=0during the whole interval. So,D+(t+1−ti)XPis exactly the amount of flow available for allocation forPateup to timet. We already know that (by induction hypothesis one) it is at leastdP,e,tand no unit of flow is stored in the buffer. Hence,dP,e,tunits of flow are allocated to pathPat edgeeup to timetby the algorithm.□Next we give an example of the algorithm.Example 5Consider the instance from Fig. A.10for the maximums–t-flow problem with time horizonT=17in the deterministic queuing model.In the flow over time model, a maximum temporally repeated flow routes for exactlyT+1−τP1=11time unitsfˆP1=4units of flow along pathP1=(s,v1,v3,t)(solid (red)), i.e., in totalFP1=11⋅4=44units, forT+1−τP2=10time unitsfˆP2=5units of flow along pathP2=(s,v2,v3,t)(dashed (blue)), i.e., in totalFP2=10⋅5=50units, and for exactlyT+1−τP3=11time unitsfˆP3=3units of flow along pathP3=(s,v2,t)(dash-dotted (green)), i.e., in totalFP3=11⋅3=33units, which gives a flow with flow value ofval(fT+1)=127.The algorithm works as stated in the following table. It states the following information: the active path denoted byPjfor somej, the amount of flowXPjavailable per time unit during the current interval, the lower boundfPfor the flow value of pathPjand the for the capacityuof the edge computed by the algorithm, the initial lengthθand the real lengthθ˜of the current time interval. If the length of the interval is reduced, a new point in time is added to the current listTei. There is an entryYPjfor the solution of the integer program, the subsequent edgeePinPaftereand the entry added to the listTePjof that edge. The last entries state the amount of flowWPjin the buffer at the end of the iteration and the amount of flowF˜Pjthat still has to be allocated toPate.The algorithm iterates over all edges (every iteration is a block in the table). The first line of every block states the current edgeeiand the starting conditions for the current iteration. For the source the pathsPjtraversing the edge have some flow in the butterWPjat the beginning, otherwise the buffer is empty. Then the important data for every iteration over the time is stated explicitly in the middle lines of each block. If there is more than one active path, then for one time there are multiple lines, one for each path. The most important column is the 10th (add toTePj), where Step 8 of the algorithm adds new times and flow values to the list of the upcoming edgeePjof pathPj. In the last line of each block the iteration ends becauseF˜Pj=0and additional times at which no more flow is sent are added to the list. See Table A.1.Some entries in the table for the listTePjseem to be missing. That is because the algorithm only adds entries in step 8 if they differ from the previous entry in the list. Since the flow rates do not change, no new time step is necessary.The result is shown in Fig. A.10 on the right. Note that listTefor edgeeis drawn near the start vertex ofefor space reasons. So there are entries from different edges in the list of one vertex (e.g., vertexv2). All flow units arrive at vertextup to time 17. By the previous lemma this is an upper bound for the flow value in the deterministic queuing model. So the flow value is maximum.⊲With the lemma above we get the following result:Theorem 16LetfTbe a maximum temporally repeated flow with time horizonT. Then Algorithm  1  transformedfTinto a maximum flow in the deterministic queuing model in polynomial time.ProofSince Lemma 15 holds for the terminal vertext, the flow value of the flow constructed by the algorithm (which gives the distribution of the flow to the edges for every vertex) is exactly the same as the flow value of the temporally repeated flow which was used as an input. Hence, starting with a maximum temporally repeated flow will give a flow with flow value equal to the capacity of a dynamic cut. Since this is an upper bound for the flow value in the deterministic queuing model, the resulting flow is maximum in this model.In total we have to consider every vertexvtwice for every path traversing it (when it becomes active and inactive again). Since there are at mostmpaths in the path decomposition for the temporally repeated flow in total we have at most풪(mn)operations on the listsTefore∈E. If we store every list by means of a balanced data structure we can insert and remove entries in풪(logn)time. This yields a total complexity of풪(mnlogn).□Here we summarize the negative results for the sum objective mentioned in the paper.First we give an example of a game with sum-objective, which has no Nash equilibrium. Note that this is only a slight modification from Example 2, which had no Nash equilibrium in the game with bottleneck objective.Example 6Consider the graphG=(V,E)from Fig. B.11withk=6weighted users and the travel times and capacities as given in the figure near the edges as an instance of a dynamic routing game with sum objective. Commodities are denoted by(si,ti)for useri∈{1,2,3,4,5,6}with priorityi, where the first two users are the main users, while the other four users are auxiliary users.Note that the auxiliary users from commodity 3 to 6 do not have a choice on which route to take. Their purpose is to slow down the other users. So they are called blocking users. The users from commodities 1 and 2 have two path choices each, because the outer paths have a capacity smaller than their weight. Then there are four strategy profiles left which are drawn as graphs in the right of Fig. B.11.Whenever both of the main users choose their left paths (upper left strategy profile), then the lower user arrives at vertexv4(filled) at the same time as the left blocking user from commodity 3. Since the blocking users has an inferior priority, the blocking user is slowed down by one time unit. This is enough to reach vertexv1of the upper main user’s path at the same time (4) as the blocking user from commodity 5 does. Since the edge(v1,v2)has capacity 2 and the total load entering the edge at time 4 is given by 3, one of the users arrives at vertexv2at time 5 and the other one at time 6. The main user from commodity 1 arrives at vertexv1at time 5, i.e., one time unit after the other two users. Hence, these users are allowed to leave edge(v1,v2)before her. Since user 1 has weight 2 equal to the capacity of the edge, she arrives at vertexv2one time step after the two blocking users left the edge, i.e., at time 7. So, she arrives at vertexvat time 8 and at the terminal at time 9, while the main user from commodity 2 reaches both vertices one unit in time earlier.Hence, the user from commodity 1 changes to the upper right path (upper right strategy profile). Here, the blocking users arrive at vertexv5at the times 3 and 4 and at vertexv6at times 4 and 5, while the main user arrives at vertexv5at time 5 and at vertexv6at time 6 without being affected by the blocking users. So, both main users arrive at vertexvat time 7. Since the user from commodity 1 has a higher priority, she arrives at the terminalt1,2at time 8, one time unit earlier than in her old path. So, this change is an improvement for her, while the travel time of the main user from commodity 2 is increased by one time unit. Hence, this user is unsatisfied with her path and changes to the lower right path (lower right strategy profile), which results in the same case as when both users took the left paths. Continuing with this behaviour shows that there is no Nash equilibrium for this instance.The analysis above also shows that there is always a path of length 8 for both of the main users and there is never a path with smaller travel time. Hence, we can assume that there is always a path for the user 1 with travel time 8 and never a path with a smaller travel time. If we remove the user from commodity 1, then every path of user 2 has the minimum travel time and, hence, gives a Nash equilibrium. We need these statements later in the proof of Theorem 19.⊲Here we show that theQuickest Flowproblem is hard to solve with a reduction similar to the one in the proof of Theorem 1 in the bottleneck case.Theorem 17TheQuickest Flowproblem isNP-complete in the strong sense in the two commodity case, even if all users are unweighted.ProofWe use the same reduction from3-SATas for the bottleneck case. The instance of3-SATis given by a set of Boolean variablesX={x0,…,xη−1}, andρclauses(Cj)j=1,…,ρcontaining exactly three literals.We construct an instance ofQuickest Flowas we did forNarrowestFlowin Theorem 1. While the definitions are not repeated here, the illustration can be seen in the right part of Fig. B.12, which is nearly the same as in the bottleneck case. One difference is, that the edges with travel times greater than one do not have to be replaced by consecutive edges with travel time equal to one here. Furthermore, we do not need local priorities for the edges for the makespan objective.Note that in a flow with makespan≤T, the edges connecting the gadgets can only be used by the first user. Hence, any user from the second commodity can only traverse a single gadget. Since every clause is connected to the second terminal vertext2by a single edge and a total amount ofρusers have to be routed for the second commodity, a flow with makespan≤Thas to route a single unit of flow along each clause vertex. Furthermore, no user in this flow can be slowed down by another user, since every path has capacity 1, free travel timeTand all users traversing a subpath of the path arrive at the common vertices at the same time.With these observations it is easy to show that there is a flow with makespan≤Tiff there is a feasible truth assignment.Letfbe a feasible flow with makespanT. Then, a single unit of flow routes froms1tot1without meeting another user. We set the variablexito true if this unit routes in theith gadget along the lower path and we set the variablexjto false if it routes in thejth gadget along the upper path. Then the users from the second commodity route along the vertices from the upper path in gadgetiand along vertices from the lower path in gadgetj. From these vertices one unit of flow is routed to each of the clause vertices and afterwards to the sink. Since at least one vertex in the path of a gadget of the corresponding variable is connected to a clause it is contained in. In any clause there is one vertex that is set to true by the flow. So, the flow induces a truth assignment.On the other hand, given a truth assignment, we route the user from the first commodity in theith gadget along the lower path, if the variablexi,i∈I, in the truth assignment is true and we route the user in thejth gadget along the upper path, if the variablexj,j∈J, is false. At least one vertex in this path inside a gadget of the corresponding variable is connected to a clause the variable is contained in. In any clause there is one variable that is set to true. So, for the second commodity we route one unit of flow along a shortest path along a vertex in the upper path of each gadgeti∈Ior one unit along a shortest path along a vertex in the lower path of each gadgetj∈Jtowards each clause vertex to which no unit of flow from the second commodity was already routed to. This gives a feasible flow and no two units of flow use the same edge. Hence, the makespan of this flow is given byT.□The following lemma only states technical facts from the previous proof that are needed to prove Theorem 19.Lemma 18For the instance built in the proof ofTheorem  17   the following statements hold true:•There is a flow for allkusers (one user for commodity  1  and the remaining users for commodity  2) with makespan value equal toTiff there is a feasible truth assignment for the underlying3-SATproblem. Otherwise, the makespan value is at leastT+1.If we allocate the worst priority to the user from the first commodity and the makespan of the flow is larger thanT, then the travel time of the user from the first commodity is at leastT+1.All paths have travel time at leastT, even if the number of users is changed.If the single user from commodity  1  is removed, then there is always a flow with travel timeT, which can be computed easily.ProofResults (1) and (3) follow directly from the proof above.For the second statement we only have to note that if there is no feasible truth assignment, then the path of the user from the first commodity always intersects with the path of a user from the second commodity at the same time. Since the user from the first commodity has the lower priority, her travel time is increased by one and, hence, it is at leastT+1.For the last statement consider the instance built in the proof of Theorem 17 with only the users from commodity 2. Then no edge is blocked by the user from commodity 1 any more. The only goal is to send one user of commodity 2 to each of theρclause vertices. Since every clause contains one of the literals in the gadgets we just pick one out of each. Since there is a path from sources2to each of these literals, we just route one user to this literal, then to the corresponding clause vertex and from there to the terminalt2. This gives a flow for thek−1users of commodity 2 with makespan valueT, which is computed efficiently.□Here we show that the question whether a Nash equilibrium exists or not is hard to answer with a reduction similar to the one in the bottleneck case in the proof of Theorem 5.Theorem 19NashExistenceisNP-hardTheNashExistenceproblem isNP-hard in the strong sense in the multi-commodity case, even if the graph is acyclic.ProofNow the hardness is shown with a reduction similar to the one for the bottleneck case. Nevertheless we state the full construction here, because some travel times and capacities differ. An instance of3-SATis given by a set of Boolean variablesX={x0,…,xη−1}, andρclauses(Cj)j=1,…,ρcontaining exactly three literals. The idea behind the subsequent construction follows from two former results:We already know by Lemma 18 that the graphGDconstructed in the proof of Theorem 17, with one user routing for the first commodity, can be traversed with a travel time ofTiff the instance of3-SAThas a feasible truth assignment. Otherwise, the travel time is at leastT+1. On the other hand, without this user from the first commodity, the remainingk−1users can always route through the graph with makespan valueT(independently on the instance of the3-SATproblem).Furthermore, we have seen in Example 6 an instance with a graphGN, which has no Nash equilibrium if there is a single user routing for its first commodity. Additionally, there is always a path with travel timeTfor this user and never a path with smaller travel time. Without this user every feasible strategy profile of the other users gives a Nash equilibrium.We add both graphs in one supergraph. First we add a super sourcesand connect it to the sources1of the first commodity in both graphs via an edge with travel time 1. We add a super terminaltand connect the terminal of the first commodity inGNto this terminal via an edge with travel time 1. The capacities of all of these edges are set to 2. Next, we have to make sure that the user from the first commodity inGDalways suffers (i.e., has a makespan value ofT+6) if the flow has a makespan value higher thanT+5. To that end we need to extend the instance a little bit, by adding verticess3′,s4′,t2′,u,wandt1′and the following edges:Edge(s3′,t2)(s4′,t2)(t2,t2′)(t2′,w)(t1,u)(u,w)(w,t1′)(t1′,t)Travel timeTT+3121211Capacity122ρ12222The former users from commodity 2 inGDnow route froms2tot2′and are called clause users. We add an additional blocking user, who routes froms3′tot1′and one froms4′tot1′. The users from the first commodity in both graphs are merged to one user, who routes from the new super sourcesto the new super terminaltand is called the main user here. Note that she has weight 2. All other users from graphGNhave the same sources and terminals as before. The priorities of the users are chosen in such a way that the main user has highest priority, the user from the second commodity inGNhas second highest priority, the blocking users in this subgraph have priorities 3 to 6, the clause users have priorities 7 to6+η, and the two remaining blocking users froms3′ands4′have priorities7+ηand8+η, respectively. The actual values of the priorities are chosen arbitrarily. The whole illustration is shown in Fig. B.13.Claim 1. We have seen in Example 6, that in the graphGN, there is always a path for the user from commodity 1 with makespan value 8. Hence, there is always a path fromstotwith makespan valueT+9. But, then the user from the second commodity in this graph is not satisfied with her path.Claim 2. The user from commodity 1 never routes alongt2, since the capacity of edge(t2′,w)is 1 and her weight is 2.Claim 3. Iff the flow of the clause users in the subgraphGDhas makespan value≥T+1, i.e., the main user arrives at vertext1after timeT+1or a user from commodity 2 arrives at vertext2after timeT, then the user from commodity 1 cannot reach the terminal vertextbefore timeT+10.ProofIn the graphGDwith the modifications made above, all clause users arrive at vertext2at timeT, if none of them is slowed down before. At this time the user froms3′also arrives at vertext2. Since she has a lower priority, she has to wait for one time unit. Then she arrives at vertexwat timeT+4. The user from sources4′arrives at vertexwat timeT+3. The main user also traverses vertexwwhen routing throughGD. If she is not slowed down by any other user, then she arrives at vertexwat timeT+4. Since she has the best priority, she traverses the subsequent edge first at this point in time and arrives at the terminaltat timeT+9.If the main user was slowed down inside the graphGD, then she arrives at vertext1after timeT+1. Then she reaches the terminal after timeT+9.Otherwise, the main user is not slowed down insideGDand, if at least one of the clause users arrives at least one time unit later thanTatt2, then the user froms3′arrives at vertexwat timeT+3. The user from sources4′also arrives at vertexwat timeT+3. If both users arrive at the same time, then the user from sources4′has to wait for one time unit in the waiting queue. The main user arrives at vertexwat timeT+4. Since she enters edge(w,t1′)after the other two users, she leaves the edge after them, i.e., not before timeT+6. Then she enters the terminal not before timeT+10.⊲Main Claim. There is a feasible truth assignment for the3-SATinstance iff there is Nash equilibrium in the enhanced instance.ProofNow assume that there is a feasible truth assignment for the3-SATinstance. By Theorem 17 we can route the user from commodity 1 along a path fromstot1with travel timeT. The clause users can also be routed with travel timeTto the vertext2. Since they have a better priority than the blocking user froms3′, they reach their terminalt2′at timeT+1, which is best possible. By Claim 3 the main user traverses the edge(w,t1′)with travel time 1, since the blocking user from sources3′is slowed down by the clause users. Hence, the main user arrives at her terminaltat timeT+9, which is best possible. Without the user from the first commodity routing through the graphGN, there is also a Nash equilibrium in this graph. Hence, there is a Nash equilibrium for the enhanced instance.Assume conversely that there is no feasible truth assignment for the3-SATinstance. By Theorem 17 any flow with one user routing for the first commodity in the graphGDhas makespan value≥T+1. By Claim 3 the main user receives makespan value≥T+10up to the terminalt, when routing through the subgraphGD. Since there is always a path inGNwith travel timeT+9by Claim 1, she changes her path to this graph. By Example 6, there is no Nash equilibrium in this subgraph. Hence, there cannot be a Nash equilibrium in the enhanced instance.□