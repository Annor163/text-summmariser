@&#MAIN-TITLE@&#
Data structures and algorithms for high-dimensional structured adaptive mesh refinement

@&#HIGHLIGHTS@&#
Structured anisotropic refinement of high-dimensional domains.Recursive bisection of hyperrectangular mesh elements.Linearized kd-tree for storage of the hierarchical mesh decomposition.Examples and scalability studies of meshes in up to 6 dimensions.Complete scheme scales better thannlogn, although worst case isO(n2).

@&#KEYPHRASES@&#
Structured adaptive mesh refinement,Anisotropic mesh,High-dimensional,Hierarchical data structure,kd-tree,Morton order,2:1 balancing,

@&#ABSTRACT@&#
Spatial discretization of high-dimensional partial differential equations requires data representations that are of low overhead in terms of memory and complexity. Uniform discretization of computational domains quickly grows out of reach due to an exponential increase in problem size with dimensionality. Even with spatial adaptivity, the number of mesh data points can be unnecessarily large if care is not taken as to where refinement is done. This paper proposes an adaptive scheme that generates the mesh by recursive bisection, allowing mesh blocks to be arbitrarily anisotropic to allow for fine structures in some directions without over-refining in those directions that suffice with less refinement. Within this framework, the mesh blocks are organized in a linear kd-tree with an explicit node index map corresponding to the hierarchical splitting of internal nodes. Algorithms for refinement, coarsening and 2:1 balancing of a mesh hierarchy are derived. To demonstrate the capabilities of the framework, examples of generated meshes are presented and the algorithmic scalability is evaluated on a suite of test problems. In conclusion, although the worst-case complexity of sorting the nodes and building the node map index isn2, the average runtime scaling in the studied examples is no worse thannlogn.

@&#INTRODUCTION@&#
Structured adaptive mesh refinement (SAMR) is an active area of research within the scientific computing community [1]. By adjusting the resolution of the computational mesh dynamically to features in the solution or the computational domain, widely varying scales of resolution can be represented simultaneously. In effect, the computational efficiency of a simulation is improved, possibly by orders of magnitude, allowing for larger computations and/or shorter execution times due to a reduction in the number of gridpoints [2]. For problems in two and three dimensions, there are efficient algorithms and data structures available, relying on quad/octrees for structuring the mesh blocks [2–5]. However, extending quadtrees and octrees to higher dimensional trees is problematic since they yield a fan-out of2Dnodes at every branch, which leads to an exponential increase in the potential number of tree nodes to handle. The contribution of this paper is a framework capable of generating and propagating meshes of arbitrary dimensionality. Our approach is based on recursive bisection and generates far fewer mesh nodes compared to2D-trees of corresponding refinement.In order to construct a practical refinement scheme that works well even in higher dimensions, the framework presented in this paper is built on a structured block-based refinement strategy [1] allowing blocks to be refined anisotropically. The mesh nodes and their mutual relationships are maintained in a kd-tree[6]. With anisotropic refinement, a block is not restricted to be refined equally in all dimensions, potentially leading to a more efficient discretization in terms of the number of created blocks since mesh blocks are refined only in the dimensions in which they would benefit from finer resolution. The grid is refined successively by dividing blocks in half, dimension by dimension. If a block needs refinement in more than one dimension, this is done by subsequent division in several steps. This paper does not consider details regarding error estimation and how to determine when refinement/coarsening is required. For the anisotropic refinement strategy to be useful though, the error estimator must be able to detect the discretization error per dimension. An example of such an error estimator is given in [7].A kd-tree is a binary tree representation of a hierarchical subdivision of aD-dimensional hyperrectangle by recursive bisection [6,8–11]. The interior nodes of a kd-tree represent hyperplane cuts, aligned with the Cartesian coordinate axes, and the leaf nodes contain the actual data. In a general kd-tree, a cut can be placed anywhere along the split dimension of a block. However, by restricting the cuts to always be placed in the middle of the block (which we do by imposing a halving of the blocks on each refinement) the scheme is simplified significantly. Furthermore, implementations of kd-trees usually assign split dimensions to nodes cyclically, such that a node at tree level l is split in dimension (lmodD). In the implementation presented here, this restriction is relaxed and nodes are allowed to be split arbitrarily without any intermediate refinement in the other dimensions. Thus, blocks can become as elongated as is needed and in principle there is no restriction on the aspect ratio of the blocks.It is often motivated for reasons of efficiency and memory requirements that a pointer representation of a tree structure should be avoided. By storing locality information in each mesh node and structuring the nodes in a linear order according to this information, the internal structure of a tree is available implicitly and no pointers are needed for searching and navigating it [2–4,12]. With the leaf nodes stored in linear order (e.g. the Morton order space-filling curve [13]), tree search is replaced by binary search, which is further advantageous in terms of search complexity; a tree representing an adaptively refined mesh is potentially very unbalanced with a search complexity approachingO(n)in the number of leaf nodes, whereas binary search in the linear representation is alwaysO(log2n)[4]. This paper extends previous work by other authors [2,4] and builds upon linear Morton order trees. The data structures and algorithms are generalized to enable an extension to higher dimensionalities. However, the anisotropic node refinement does not map directly to an efficient consecutive order of elements solely from the locality information in the leaf nodes. In order to alleviate this, the linear tree representation is extended with a lightweight representation of the internal node structure (a node map index), corresponding to a hierarchical Morton order of nodes. The node map index is constructed at the same time as the nodes are sorted and stored in a compact array representation for efficient traversal.The remainder of this paper is organized as follows. In Section 2, some related work is discussed. A key concept in our implementation is the notion of location codes, which is described in Section 3. In Section 4 the construction of a hierarchical Morton order index is derived together with some implementation details. The algorithms for tree search are discussed in Section 5, followed by the adaptive mesh algorithms in Section 6. Finally, Section 7 gives some results of our implementation and Section 8 concludes the paper.

@&#CONCLUSIONS@&#
