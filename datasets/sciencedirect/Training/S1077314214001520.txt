@&#MAIN-TITLE@&#
On the family of shortest isothetic paths in a digital object—An algorithm with applications

@&#HIGHLIGHTS@&#
An algorithm to compute Family of Shortest Isothetic Paths (FSIP) is proposed.We make certain characterization of FSIP, which leads to the algorithm.Algorithm is discussed in detail with demonstration.We also show how FSIP can be used for shape analysis.Experimental results are given to demonstrate the effectiveness of FSIP.

@&#KEYPHRASES@&#
Shortest path,Isothetic path,Monotone path,Monotone polygon,Shape analysis,

@&#ABSTRACT@&#
The family of shortest isothetic paths (FSIP) between two grid points in a digital object A is defined to be the collection of all possible shortest isothetic paths that connect them. We propose here a fast algorithm to compute the FSIP between two given grid points inside a digital object, which is devoid of any hole. The proposed algorithm works with the object boundary as input and does not resort to analysis of the interior pixels. Given the digital object A with n boundary pixels, it first constructs the inner isothetic cover that tightly inscribes A inOnglogngtime, where g is a positive integer that denotes the unit of the underlying square grid. Then for any two points on the inner cover, it computes the FSIP inO(n/g)time, using certain combinatorial rules based on the characteristic properties of FSIP. We report experimental results that show the effectiveness of the algorithm and its further prospects in shape analysis, object decomposition, and in other related applications.

@&#INTRODUCTION@&#
Numerous variants of shortest path algorithms and their applications have been studied extensively over several decades under diverse algorithmic paradigms, such as graph theory, computational geometry, and operations research. Some of the major applications of shortest paths are networking, robotics, geographical information systems (GIS), VLSI design, resource allocation and collection, and traveling salesman problem (TSP) with neighborhoods [1,5,12,17,25,27,28]. Customization of these algorithms for such a wide range of applications and related constraint formulations need special attention, as evidenced in the related literature [6–9,16,22–24,26]. A comparative review of these algorithms is shown in Table 1, and some of these related to our work are briefly discussed below.In the domain of computational geometry and robot vision, a distance transform approach is proposed by Jarvis and Byrne [20] to find all paths from the goal location back to the start location. This results in shortest paths with respect to theL1distance metric, which assigns equal weights for movements in diagonal, horizontal, and in vertical directions. Since diagonal directions are allowed, theL1metric does not provide accurate solution to the problem. Zelinsky [30] uses path transform approach, which is an extension of distance transform planning. Two control points are selected in the work space of a robot, and path transforms for each of the control points are computed. The approach guarantees a solution if it exists. For computing the collection of all shortest paths inside a simple planar polygon from a given source vertex to all the other vertices, a linear-time algorithm was reported by Guibas et al. [18]. In the graph-theoretic domain, one of the fastest implementations of single-source shortest paths using Fibonacci heaps is due to Fredman and Tarjan [15], which has a running time ofO((|V|log|V|)+|E|), where V and E are the respective sets of vertices and edges. For planar graphs, Frederickson proposed the use of separators to obtainO(|V|log|V|)-time algorithm for solving shortest path problems [14]. In a planar graph with nonnegative edge-lengths, anO(|V|)-time algorithm for shortest paths is also known [19].Shortest paths are also found to be useful in image processing and computer vision. For example, different deformed templates, such as deforming contours, articulated objects, and smooth contours have been tracked in simple and complicated backgrounds using the idea of shortest path [11]. Nevertheless, the design of such algorithms still poses newer challenges in various emerging areas of image analysis and computer vision. This mandates further investigation of application-specific shortest-path problems in the framework of digital geometry.In an earlier work [13], the problem of finding a shortest isothetic path (SIP) inside a digital object A (without any hole) laid on a gridG(Section 2) was studied, such that the SIP lies entirely inside A and consists of moves along grid edges only. Although the problem looks somewhat analogous to certain problems of computational geometry, an efficient algorithmic solution for a digital object was awaited. For a given grid size, the above-mentioned algorithm runs inOnglogngtime, n being the number of pixels on the border of the digital object, A.A shortest isothetic path—whether monotone or not—between two points in a digital object is usually not unique. However, the family of shortest isothetic paths (FSIP) between two points is unique, since it is defined as the region containing the collection of all SIPs between them. As already mentioned above and also shown in Table 1, there exists a rich literature on shortest paths in different paradigms; however, determination of FSIP in a digital object, which is tunable with grid size, still remains open. The novelty of our work lies in the fact that it identifies the entire corridor between two given points of a digital object that envelops all shortest isothetic paths connecting the two points. For a digital object without any hole, the proposed algorithm needsO(nglogng)preprocessing time, followed byO(n/g)time for computing the FSIP between two points, where n is the number of pixels on the object boundary. Note that the pixel geometry of a digital object scanned along axis-parallel lines can be viewed as a planar grid graph, where the vertices correspond to the pixels, and the edges represent their connectivity in 4-neighborhood. Ifn0denotes the total number of pixels in the object, then the number of pixels on its boundary will beO(n0)unless the object is too elongated in one direction. We assume that the object is initially captured on a digital square grid of unity spacing (i.e., grid sizeg=1). For any grid sizeg⩾1, the proposed algorithm for computing FSIP is thus expected to run inO(n0/g)time. In contrast, the conventional shortest-path algorithms for planar graphs, if applied directly on the graph corresponding to the object, may requireO(n0)time.To start with, the definitions and terminologies related to FSIP are given in Section 2. Several interesting topological properties of FSIP are presented in Section 3. Based on these properties, the algorithm for computing the FSIP is designed, which has been described and demonstrated in Section 4. The nature of an FSIP depends on the complexity of its SIPs. As an introductory example, see Fig. 1(left) where a digital object, A, is shown, and two FSIPs for two pairs of points in A are shown in Fig. 1(middle, right). All SIPs between the two points in Fig. 1(middle) are monotone, and those in Fig. 1(right) are non-monotone. Details of experimental results and their applications to shape analysis and object segmentation are elaborated in Section 5. Concluding remarks are presented in Section 6.A digital object, A (henceforth referred to as an object), is a finite subset ofZ2, which consists of one or morek(=4or8)-connected components[21]. In this paper, we consider the object as a single 8-connected component. We need the following definitions in the context of our work.Definition 1GridThe background grid is given byG=(H,V), whereHandVrepresent the respective sets of (equi-spaced) horizontal grid lines and vertical grid lines. The grid size, g, is defined as the distance between two consecutive horizontal/vertical grid lines. A grid point is the point between intersection of a horizontal and a vertical grid line.An isothetic polygon has its vertices as grid points and its edges lying on grid lines. The inner isothetic cover of A is the maximum-area isothetic polygon P that tightly inscribes A (Fig. 1).Since P is an isothetic polygon, it has900and2700vertices, which are referred to as vertices of type 1 and type 3, respectively. All other grid points lying on the border of P are called edge points. The sequence of vertices of P is such that P always lies left of each edge during its traversal.Definition 3SIPAn (simple) isothetic pathπ(p,q)from a grid pointp∈Pto a grid pointq∈Pis a sequence of 4-connected grid points such that all the constituent points ofπ(p,q)are distinct and lie on or inside P. For two given points in P, a/the shortest isothetic path (SIP) has the minimum length over all isothetic paths between them. A SIP is said to be monotone if it consists of moves only in one or two (orthogonal) directions.The union of all possible SIPs between two given pointsp∈Pandq∈Pdefines their family of SIPs (FSIP), denoted byF(p,q). The setF(p,q)is equivalent to a (isothetic) region bordered by two SIPs between p and q, which are said to be its extremum SIPs. If we traverse the border ofF(p,q)from p to q such that each other SIP inF(p,q)lies to the left during the traversal, then that path of traversal is one of the two extremum SIPs, which is termed as the infimum SIP and denoted byπ(p,q)inf. Similarly, on traversing the border ofF(p,q)from q to p with each other SIP lying to the left during the traversal, we get the other extremum SIP, termed as the supremum SIP and denoted byπ(p,q)sup.The setF(p,q)is, therefore, bounded and well-defined by its two extremum SIPs, namelyπ(p,q)infandπ(p,q)sup. Fig. 1 shows a couple of typical examples. The crux of our algorithm is to findπ(p,q)infandπ(p,q)sup, which, in turn, defines the region that contains all the SIPs comprisingF(p,q). The numbers of grid points for all SIPs inF(p,q)are same, as they all have the minimum length. As a degeneracy, if there is exactly one SIP between p and q, thenF(p,q)contains only that SIP, which is alsoπ(p,q)infandπ(p,q)supcoincident with each other. Otherwise,F(p,q)will have distinctπ(p,q)infandπ(p,q)sup, which although can have partial overlaps. We need the following definitions to characterize such overlaps betweenπ(p,q)infandπ(p,q)sup, and hence to characterizeF(p,q)defined by them.Definition 5Convexity and ConcavityAn edge of P defined by two consecutive vertices of type 1 is termed as a convex edge, as it gives rise to a convexity. Similarly, an edge defined by two consecutive type 3 vertices gives rise to a concavity, and hence termed as a concave edge.A convex region C corresponding to a convex edge e is the maximum-area rectangle fully contained in P, having its one side as e, and the endpoints of the side opposite to e (i.e., its open side) lying on the sides of P preceding and following e.For example, in Fig. 2(left), the convex region is closed on three sides by the edges(vi-2,vi-1),(vi-1,vi), and(vi,vi+1), and open on the side defined by the horizontal line passing throughvi-2. In Fig. 2(right), the convex region is closed similarly on three sides by the edges as in Fig. 2(left), and it is open on the side defined by the nearest concave edge.Definition 7Convex Isothetic PolygonA convex isothetic polygon is an isothetic polygon whose intersection with any grid line is either empty or a single line segment [4].The convexity index,α, ofF(p,q)is defined as the number of convex isothetic polygons that it consists of.For example, for the FSIP shown in Fig. 1(middle),α=1; and for the one in Fig. 1(right),α=4.Definition 9BridgeA sub-path common toπ(p,q)infandπ(p,q)supinF(p,q)is called a bridge.Every two consecutive isothetic polygons inF(p,q)are connected by a bridge. Each bridge inF(p,q)passes through one or more concave edges, with its two endpoints coinciding with two type 3 vertices of those concave edges. Each SIP inF(p,q)passes through all the bridges inF(p,q).Bridges are of two types (Fig. 3), which admit the following characterization. If a bridge is non-monotone, then it is a U-bridge. If a bridge is monotone, then it is a Z-bridge only if it has the same monotonicity of its preceding and/or following regions; otherwise, it is a U-bridge. A Z-bridge never breaks the monotonicity of a SIP, whereas a U-bridge always breaks its monotonicity.Definition 10Monotone and Non-Monotone FSIPIfF(p,q)consists of monotone SIPs, then it is said be a monotone FSIP; otherwise, it is a non-monotone FSIP.It is easy to observe thatF(p,q)cannot contain both monotone and non-monotone SIPs, since the length of a non-monotone SIP between p and q is always greater than that of a monotone SIP between p and q.It is evident from Definition 4 thatF(p,q)may be conceived as an isothetic polygon, which is either simple or non-simple in the sense that it may have overlapping edges. The overlapping edges, in particular, give rise to bridges. LetR(p,q)denote the rectangle having p and q as two of its diagonally opposite corners. Then the location of the aforesaid isothetic polygon corresponding toF(p,q)has two possible topological cases, having a few combinatorial sub-cases, as explained below.1.F(p,q)⊆R(p,q).(a)F(p,q)is monotone.i. IfF(p,q)is simple, then it has no bridges (Fig. 4(left)).ii. IfF(p,q)is non-simple, then it has one or more Z-bridges but no U-bridges (Fig. 3(left)).These are proved in Lemmas 1 and 2.(b) IfF(p,q)is non-monotone, then it is always non-simple, has one or more U-bridge(s) (and may or may not contain any Z-bridge). This is proved in Lemma 2.IfF(p,q)⊈R(p,q), then it is non-monotone, non-simple, and has one or more U-bridges (may or may not contain any Z-bridge). This is evident from Fig. 3(right) and proved in Theorem 2.When a SIP lies outsideR(p,q), it passes through at least one U-bridge that lies outsideR(p,q). The algorithm proposed in Section 4, while computing the extremum SIPs by traversing along the two consecutive sides ofR(p,q), determines each such U-bridge lying outsideR(p,q)and the corresponding convex isothetic polygons ofF(p,q)connected by it. See, for example, the illustration in Fig. 3(right). Here the line of concavity is outsideR(p,q). Hence, for anyπ(p,q), there is a sub-path to the right side ofR(p,q). The union of all these sub-paths over all SIPs from p to q defines the portion ofF(p,q)lying outsideR(p,q). And all the sub-paths in this portion passes through the U-bridge lying outsideR(p,q). Detailed explanation is given in Section 4. We first have the following lemmas on a monotone SIP.Lemma 1If a SIPπ(p,q)is monotone, then it lies inR(p,q), and hence its length is given by the semi-perimeter ofR(p,q).Asπ(p,q)is monotone, its length is|π(p,q)|=abs(xp(g)-xq(g))+abs(yp(g)-yq(g)), where(xp(g),yp(g))and(xq(g),yq(g))denote the respective coordinates of p and q, measured in grid units. Ifπ(p,q)goes outsideR(p,q), then the sum of lengths of its horizontal (or vertical) sub-paths would be greater thanabs(xp(g)-xq(g))(orabs(yp(g)-yq(g))), wherein lies the contradiction. □F(p,q)is monotone if and only if any SIP between p and q is monotone.From Lemma 1, it is clear that if a SIP (between p and q) is monotone and another SIP is non-monotone, then the length of the latter would be greater than that of the former, which is a contradiction. Hence, either all SIPs inF(p,q)are monotone or all of them are non-monotone. □We have the following theorem on monotonicity ofF(p,q), considering its containment inR(p,q).Theorem 1FSIP monotonicityIfF(p,q)is monotone, then it lies inR(p,q). However, the conditionF(p,q)⊆R(p,q)does not guarantee the monotonicity ofF(p,q).By Lemma 2, it is clear thatF(p,q)is monotone if and only if all SIPs between p and q are monotone. By Lemma 1, all monotone SIPs always lie inR(p,q), which impliesF(p,q)lies inR(p,q).But the converse is not true, since a non-monotone FSIP may lie inR(p,q), as evident from the illustration in Fig. 4(right).□We have now the following theorem that explicates the necessary and sufficient condition of a non-monotone FSIP.Theorem 2FSIP non-monotonicityF(p,q)is non-monotone only if it has a U-bridge.IfF(p,q)is non-monotone, then eachπ(p,q)∈F(p,q)is non-monotone (Lemma 2) and hence consists of more than two directions. As explained above, the horizontal movements preceding and following a Z-bridge are in the same direction. So, the monotonicity breaks only due to U-bridge. □Further, when there exists exactly one SIP between p and q, thenπ(p,q)infandπ(p,q)supentirely coincide, andF(p,q)is just a single isothetic path. This is a very typical case, which occurs when p and q lie on the perimeter of P, and there is a Z-bridge between them, on which two or more lines of concavity are incident (Fig. 5).To characterize the FSIP now, we use the sequence of its constituent isothetic sub-polygons and bridges. We have the following theorems.Theorem 3FSIP sub-polygonsAll the sub-polygons inF(p,q)are simple convex isothetic polygons.F(p,q)consists of sub-polygons, connected by bridges (Theorem 2). It is easy to observe that each of these sub-polygons is simple, sinceF(p,q)is not simple only at bridges. To prove that a sub-polygonRiis a convex isothetic polygon, observe that the part ofπ(p,q)infand the part ofπ(p,q)supdefining the border ofRiare both monotone, since the sub-polygonRidoes not contain any bridge in general, and any U-bridge in particular. Hence, none of those parts ofπ(p,q)infandπ(p,q)suphas two consecutive vertices of type 3. This implies thatRihas no two consecutive vertices of type 3, whereforeRiis a convex isothetic polygon. □Eachπ(p,q)∈F(p,q)has the same sequence of bridges,B(p,q), and hence passes through the same sequence of (simple) convex isothetic polygons,R(p,q).We prove by induction. From Theorem 3,F(p,q)can be represented by a unique sequence of convex isothetic polygons, namelyR(p,q), intertwined by a unique sequence of bridges. LetB1be the first bridge inB(p,q). Then by Definition 9,B1is either not preceded by any polygon or connects the first two polygonsR1andR2inR(p,q). Letp1′be the point whereR1is incident onB1andh1be the horizontal line passing throughp1′. Let, w.lo.g., q be lying somewhere belowh1, as shown in Fig. 6. Then, in order to reach q, any SIP from p has to pass throughp1′and hence containB1.For the induction hypothesis, assume that eachπ(p,q)from p has passed throughR1,B1,R2,B2,…,Ri. We prove in the induction step thatπ(p,q)entersRi+1.Letpi-1″andpi′be the respective points at whichRiis incident onBi-1andBi. As shown in Fig. 6, ifvibe the vertical line perpendicular toBiand passing throughpi′, then after reachingpi′frompi-1″,π(p,q)has to move alongBi, since any other direction would result in more than two types of moves insideRi, thereby contradicting the minimum path length of a SIP. It cannot also move upwards alongvi, since the bridgeBiis not along that direction. So, it entersRi+1throughBi, whence the proof.□We have now the following theorem.Theorem 5Convexity indexThe convexity index ofF(p,q)isα=β-λ+1, whereβis the number of bridges inF(p,q), andλ=0when neither p nor q lies on a bridge,λ=1when either p or q lies on a bridge, andλ=2when p and q both lie on bridges.From Theorem 4, eachπ(p,q)∈F(p,q)passes throughβbridges. Each bridgeBiis either a U-bridge or a Z-bridge, and connects two convex isothetic polygons, namelyRiandRi+1. If p or q marks the start or end of a bridge, then there is no convex isothetic polygons preceding and following that bridge. So, it reduces the number of convex isothetic polygons byλ. As the sequence of these polygons and the sequence of bridges are both unique, the proof follows. □Algorithm Find-FSIP computesF(p,q)by finding its extremum SIPs. As shown in Algorithm 1, its input is the (ordered) list L containing vertices of P, two lexicographically sorted lists consisting of vertices and edge points (i.e., all grid points on the border of P), which are denoted asLx(x as primary key and y as secondary key) andLy(y as primary key and x as secondary key), andp,qas the start and the endpoints. The procedure Find-U-Bridges is used to find the sequence of U-bridges between p and q, and the pair of endpoints defining each bridge is stored in the array B (Step 1). Note that B is initialized with p and appended with q in Find-U-Bridges (Steps 8 and 18). For each ordered point pair(B[i],B[i+1])in B—excepting the first and the last pairs, the respective pointsB[i]andB[i+1]represent the end of a bridge and the start of the next bridge inπ(p,q)inf(Step 4); they also represent the same two bridges inπ(p,q)supin reverse order (Step 5). The first pair has p and the start point of the first bridge, and the last pair has the endpoint of the last bridge and q. B is used to find the extremum SIPs in the do-while loop of Find-FSIP (Steps 3–10).Step 6 of Find-FSIP uses the procedure Find-Region to compute the convex isothetic polygons bounded by the extremum SIPs (Theorem 3). It also finds the Z-bridges. While traversing the vertices ofπ(p,q)infandπ(p,q)supin succession, it identifies the overlapping line segments ofπ(p,q)infandπ(p,q)sup, which correspond to Z-bridges.A U-bridge appearing after a convex isothetic polygon is appended by the procedure Append-Bridge, in the setF(p,q)(Step 8). The first entry in B is p. So, the first U-bridge,B1, will appear after the first region,R1. The last entry in B is q. Thus, at the last iteration of the do-while loop of Find-FSIP, there will be no U-bridge after the last convex isothetic polygon in the sequence, i.e., Steps 7, 8 and 9 will not be executed. Otherwise, the U-bridge after the convex isothetic polygon, is appended by the procedure Append-Bridge in Step 8. If the U-bridge consists of more than two type 3 vertices, then all the vertices belonging to the U-bridge are appended inF(p,q)by Append-Bridge. The pointer gets incremented by two, and so it points to the end vertex of the last U-bridge (Step 9).Algorithm 1Find-FSIPIn the procedure Find-U-Bridges, the pointc1is determined as the corner point ofR(p,q), which appears in the anticlockwise traversal ofR(p,q)from p to q (Step 1).R(p,q)intersects P at different points. These intersection points onpc1‾andc1q‾are determined in Step 3 or in Step 5, depending on the location ofc1inR(p,q). The procedures Remove-Points (Step 6) and Find-Polychain (Step 7) are designed based on certain combinatorial rules explained in [13]. The procedure Remove-Points is used to remove some of the intersection points between P andR(p,q). The procedure Find-Polychain finds a polychain between two points, which gives a SIP. The vertices of P are indexed in increasing order, starting from p. If there are two consecutive vertices of type 13 (31) in the list of intersection points, then the vertex with greater (lower) index is discarded, since the line segment joining these two intersection points lies entirely outside P. For example, in Fig. 7, the verticesw1,w2,w3, andw4are the four intersection points, with type(w1,w2)=31 and type(w3,w4)=13. According to the aforesaid rules, herew1andw4are discarded. After applying this rule, all intersection points are considered in pair. The indices of pairs of intersection points are then checked to find whether they are in increasing or in decreasing order and whether the index falls within the indices of extreme two points in M, namelyM[1]andM[k], where k is the total number of intersection points. If it is not so, then the last point of first pair and the first point of next pair are discarded. Now, M contains only the intersection points such that its traversal produces movements along the borders ofR(p,q)and P alternately. That is, ifM[i]toM[i+1]describes a segment on the border ofR(p,q), thenM[i+1]toM[i+2]indicates a sequence of vertices along the border of P. The latter sequence may be reduced by using combinatorial rules (Procedure Apply-Rule in [13]) to get a tight polychain fromM[i+1]toM[i+2], when the sequence creates a convexity. LetM=〈p,w1,w2,…wk,q〉. Then(p,w1)is traversed alongR(p,q),(w1,w2)alongP,(w2,w3)alongR(p,q),(w3,w4)along P, and so on. During traversal along P, when the polychainC(p,q)enters a convex region, then it is reduced and made to pass along the open side of the convex region (Fig. 2(left)). If there are one or more concavities inside the convex region, then though the reduced polychain passes along the open side (i.e., along the line of concavity which is nearest to the convex edge), it would store the two concave vertices of the nearest concavity (Fig. 2(right)).Algorithm 2Find-U-Bridges(p,q)Once the polychainC(p,q)is obtained, U-bridges are extracted from it (Find-U-Bridges: Steps 9–17). i and j are initialized to ‘1’, and p is appended in B (Step 8). The two endpoints corresponding to each U-bridge are stored in B in sequence by traversingC(p,q). Whenever there are two or more consecutive vertices of type 3 inC(p,q)(Steps 10–17), then the two extreme type 3 vertices of the sequence are stored in B as the endpoints of the particular bridge. At the end ofB,qis appended (Step 18), and finally B is returned in Step 19.The procedure Find-Extremum is applied on each pair of points in B to find the convex isothetic polygon between every two consecutive bridges, which becomes a part ofF(p,q)(Theorem 3). The first four lines of Find-Extremum are similar to those in Find-U-Bridges. The extremum SIPs obtained at the two sides of a U-bridge are monotone (Theorem 3). The list of intersection points, M, is traversed and each extremum SIP moves alternately along the sides ofR(p,q)and along the border of P (Steps 6–17). Initially, i and m (indices for M andπrespectively) are initialized to ‘1’, and p is appended inπ(Step 5). If p is inside P, then the first movement is along the side ofR(p,q), and so, the first intersection point is appended inπ(Step 7). If p is on the border of P, then in some cases, the first movement will not be along a side ofR(p,q)but along the border of P up to the first intersection point. For simplicity, this case is not incorporated in the algorithm. If there is a corner point, then the corner point and the intersection point next to it are appended inπ, and reduction rules are applied (by Apply-Rule) if a convex region is created (Steps 8–14). The loop terminates on reaching the destination point (Steps 13–14).Algorithm 3Find-Extremum(r,s)The second movement is along the border of P between the two intersection points determined by the procedure Traverse (Step 8). The SIP moves along the border of P, and if it enters any convex region, then corresponding reduction rules are applied. The next intersection point is appended inπin Step 16. The variables i and m are incremented by 2 in Step 17, q is appended at the end ofπin Step 18, andπis returned by the procedure in Step 19.Fig. 8shows an illustration of Algorithm 1. Two points p and q, and their corresponding rectangle,R(p,q), are shown in Fig. 8(top-left). First,C(p,q)is determined using Find-Polychain (Fig. 8,top-middle). FromC(p,q), U-bridges are detected. Here, two U-bridges are there,u1andu2being the endpoints of the first U-bridge, andu3andu6of the second (Fig. 8, top-right). Two extremum SIPs are obtained from p tou1, which are shown in red (infimum) and in blue (supremum) (Fig. 8, bottom-left).The procedure Find-Region extracts the Z-bridgez1z2‾from the corresponding region and then the U-bridgeu1u2‾is appended. So, up to this point, we haveF(p,q)=R1∪z1z2‾∪R2∪u1u2‾(Fig. 8,bottom-left). Next, the two extremum SIPs betweenu2andu3are determined (Fig. 8 bottom-middle). The corresponding region does not contain any Z-bridge, and we getF(p,q)=R1∪z1z2‾∪R2∪u1u2‾∪R3. The next U-bridge consists of more than two vertices of type 3. All the segments between the two extreme points of the U-bridge are appended, and soF(p,q)gets enhanced toR1∪z1z2‾∪R2∪u1u2‾∪R3∪u3u4‾∪u4u5‾∪u5u6‾. The concluding portions of the extremum SIPs betweenu6and q are obtained in a similar manner (Fig. 8 bottom-right). There is no more U-bridges, since q is the destination. Hence, finally,F(p,q)=R1∪z1z2‾∪R2∪u1u2‾∪R3∪u3u4‾∪u4u5‾∪u5u6‾∪R4.Let n be the number of pixels on the boundary of the digital object, A. Since the inner isothetic cover P tightly inscribes A, the number of grid points (vertices and edge points) on the boundary of P isO(n/g)[3,2], where g is the grid size. All these vertices are stored in L inO(g)·O(n/g)=O(n)time, since the intersection of each grid edge with A is checked inO(g)time and the number of grid points visited is bounded byO(n/g). Subsequently, the listsLxandLyare constructed from L inO(nglogng)time. Thus, the total preprocessing time before applying Find-FSIP algorithm isO(nglogng).The algorithm Find-FSIP finds the U-bridges from the intersection points between P andR(p,q), which are less in number than the grid points comprising the border of P. To find the intersection points,LxandLyare accessed (Find-U-Bridges: Steps 3–5). To find the positions ofp,q, andc1in these lists, binary search is applied, which takesO(logng)time in total. Other intersection points lie consecutively from p toc1inLy, and fromc1to q inLx, and hence obtained by appropriate linear search inO(n/g)time. The procedure Remove-Points discards some of the intersection points fromMyandMxbased on combinatorial rules, which takesO(k)time, wherek(<n/g)is the number of intersection points. Note that g times k does not exceed the semi-perimeter ofR(p,q).The procedure Find-Polychain computes the polychainC(p,q)by traversing along (the borders of)R(p,q)and P. Traversal alongR(p,q)is done to add intersection points inC(p,q), which requiresO(k)time. Traversal along P—from one intersection point to the next—yields all the vertices of P lying among the intersection points. These vertices are added linearly inC(p,q)in a maximumO(n/g)time. During the traversal along P, reduction rules are applied by Apply-Rule on the corresponding parts ofC(p,q). The total time complexity for this is linear in the number of vertices ofC(p,q), which is at mostO(n/g). Hence, all U-bridges are computed and added in the FSIP inO(n/g)time in the worst case.The time taken by Find-Extremum is upper-bounded by the maximum possible length of an extremum SIP, which isO(n/g). The procedure Find-Region extracts the convex isothetic polygons and the Z-bridges by traversingπ(p,q)infandπ(p,q)sup. As explained in Section 4, the Z-bridges are obtained from the overlapping line segments inπ(p,q)infandπ(p,q)sup, using a linear pass on each, which needsO(n/g)time in worst case. The Append-Bridge procedure adds the isothetic convex polygons and the bridges inF(p,q), which also takesO(n/g)time in worst case. Thus, the worst-case time complexity to compute the FSIP isO(n/g). Hence, on considering the preprocessing time, the total worst-case time complexity becomesO(nglogng).

@&#CONCLUSIONS@&#
