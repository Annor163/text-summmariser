@&#MAIN-TITLE@&#
Efficient elementary and restricted non-elementary route pricing

@&#HIGHLIGHTS@&#
We propose an efficient algorithm for the SPPRC based on ng-routes relaxation.This algorithm is extended in order to solve the more difficult ESPPRC.We report for the first time experiments with ng-set sizes up to 64.We solve the ESPPRC for CVRP instances with up to 200 customers.We obtain new lower bounds and optimality proofs for several GVRP instances.

@&#KEYPHRASES@&#
Routing problems,Column generation,Non-elementary routes,Elementary routes,

@&#ABSTRACT@&#
Column generation is involved in the current most efficient approaches to routing problems. Set partitioning formulations model routing problems by considering all possible routes and selecting a subset that visits all customers. These formulations often produce tight lower bounds and require column generation for their pricing step. The bounds in the resulting branch-and-price are tighter when elementary routes are considered, but this approach leads to a more difficult pricing problem. Balancing the pricing with route relaxations has become crucial for the efficiency of the branch-and-price for routing problems. Recently, the ng-routes relaxation was proposed as a compromise between elementary and non-elementary routes. The ng-routes are non-elementary routes with the restriction that when following a customer, the route is not allowed to visit another customer that was visited before if they belong to a dynamically computed set. The larger the size of these sets, the closer the ng-route is to an elementary route. This work presents an efficient pricing algorithm for ng-routes and extends this algorithm for elementary routes. Therefore, we address the Shortest Path Problem with Resource Constraint (SPPRC) and the Elementary Shortest Path Problem with Resource Constraint (ESPPRC). The proposed algorithm combines the Decremental State-Space Relaxation technique (DSSR) with completion bounds. We apply this algorithm for the Generalized Vehicle Routing Problem (GVRP) and for the Capacitated Vehicle Routing Problem (CVRP), demonstrating that it is able to price elementary routes for instances up to 200 customers, a result that doubles the size of the ESPPRC instances solved to date.

@&#INTRODUCTION@&#
Since the work of Christofides, Mingozzi, and Toth (1981) on the Capacitated Vehicle Routing Problem (CVRP), column generation has become a widely applied technique for exactly solving different routing problems. Currently, it is involved in almost all of the current most efficient approaches to routing problems. These approaches use integer and mixed-integer programming formulations with variables associated with the set of all possible routes. These formulations are set partitioning based, and these constraints impose the selection of the route to serve each customer. We refer to this as SPP formulation. The resolution of its linear relaxation requires the use of column generation techniques. The pricing subproblem to be solved is the Elementary Shortest Path Problem with Resource Constraints (ESPPRC).The ESPPRC is a shortest path problem on a graph where the customers have an amount of resources that are consumed during a visit. The resource constraints require that the total of the resources consumed by any feasible solution does not exceed the existing limits. There may be edges with negative cost, and these edges may generate negative cycles, but because a feasible solution must be an elementary path, revisiting a customer is strictly forbidden.The ESPPRC is a difficult to solveNP-hard problem (Dror, 1994). In general, the current best performing algorithms have acceptable processing times when the optimal solution is a path with at most fourteen customers. We refer to Di Puglia Pugliese and Guerriero (2012) for a review of the approaches proposed throughout the last three decades. Most of the main ideas for the ESPPRC resolution can be found in their work and in the proceedings of Feillet, Dejax, Gendreau, and Gueguen (2004), Chabrier (2006), Righini and Salani (2006), Righini and Salani (2008) and Boland, Dethridge, and Dumitrescu (2006).Instead of solving the ESPPRC, the original work of Christofides et al. (1981) solves its relaxation, the Shortest Path Problem with Resource Constraints (SPPRC). This relaxation does allow revisiting a same customer in a route. The resulting non-elementary routes are often called q-routes. However, the resource constraints are the same as the ESPPRC, and therefore, every time a customer is visited, the relevant resource consumption is counted, and the total consumption must still respect the existing limits. A recent survey about the SPPRC can be found in Di Puglia Pugliese and Guerriero (2013).This relaxation has some interesting properties. First, as distinct from the original problem, it can be solved in pseudo-polynomial time using a dynamic programming algorithm. In addition, even relaxing the elementarity constraint, the SPP bounds found by its linear relaxation are usually strong, especially when there are few customers per route. Furthermore, to strengthen the bounds of the linear relaxation, Christofides et al. (1981) also demonstrated that size two cycles can be forbidden with almost no extra effort.However, even with the 2-cycle elimination restriction, the linear relaxation is still weak, a behavior that motivated researchers to seek better cycle elimination devices to turn the non-elementary routes closer to elementary routes, without dealing with the whole complexity of the ESPPRC. The work of Irnich and Villeneuve (2006) devised an algorithm that solves the SPPRC by forbidding cycles of an arbitrary size. This algorithm is significantly more complicated, resulting in a complexity that grows factorially with the size of the cycles being forbidden. On account of this, their method quickly becomes impractical. Eliminating cycles of size four or more is already too time consuming compared with the bound improvement obtained. Such behavior was verified in practice by Fukasawa et al. (2006) for the CVRP.Recently, Baldacci, Mingozzi, and Roberti (2011) proposed a compromise between routes and q-routes: ng-routes. These ng-routes are restricted non-elementary routes built accordingly to customer sets, ng-sets, which are associated with each customer and act like their “memory.” Therefore, when a path reaches a given customer, it “forgets” whether another customer was visited if it does not belong to the ng-set of the current customer. Moreover, the further extension is only allowed to customers that are not “remembered”. The ng-sets are usually composed of the closest customers and clearly with a larger size set the problem is harder to solve. This is due to the fact that the ng-routes generated are going to be increasingly closer to elementary routes.Although the SPPRC with ng-routes can be solved in pseudo-polynomial time for a fixed ng-set size, to the best of our knowledge, there is no work that solves this problem for ng-sets larger than 20. This finding is observed because of the exponential-sized data structure used by Baldacci et al. (2011) to speed up the algorithm.This work aims at efficiently solving the SPPRC with restricted non-elementary routes and the ESPPRC. The first improvement is obtained by adapting the Decremental State-Space Relaxation (DSSR) technique of Righini and Salani (2008) to the SPPRC with ng-routes. This technique was initially proposed for the ESPPRC, where the elementarity restriction is relaxed and the problem is then solved iteratively, rebuilding the restrictions as needed, until the optimal solution is found. The main difference of our algorithm is instead of relaxing the elementarity of the routes, we relax the restriction imposed by the ng-sets.Next, we accelerate this approach using completion bounds. Because an iteration of the DSSR is a relaxation for its next iteration, the completion bounds estimate lower bounds for completing the paths being built on a given iteration, and, given an upper bound for the optimal solution (which is usually equal to zero for pricing algorithms), it avoids the extension of paths that may exceed the known upper bound on the next DSSR iteration.These two techniques were already used together in the work of Pecin (2010). In that work, a column generation procedure that uses the ESPPRC as the pricing subproblem was proposed for the CVRP. Using the algorithm of Fukasawa et al. (2006), instances with up to 100 customers could be solved to optimality pricing only elementary routes.Finally, we demonstrate how our algorithm for the SPPRC with restricted non-elementary routes can be easily extended to generate only elementary routes. We also highlight the two new elements existing in our approach that allow us to double the size of the ESPPRC instances solved thus far.The proposed algorithms are then applied to the Generalized Vehicle Routing Problem (GVRP), where the customers to be visited are clusters of vertices. Each cluster has an associated demand and can contain one or more vertices. The demand of each cluster must be fully collected in exactly one vertex of the cluster. This problem is a generalization of the CVRP and the Traveling Salesman Problem (TSP), and, as in the classical CVRP, identical vehicles are given, and routes must start and end at the depot and the capacity of the vehicle must not be exceeded. We report experiments demonstrating that our algorithms are able to solve the SPPRC with ng-set sizes up to 64 and the ESPPRC for hard instances of both the GVRP and CVRP. The CVRP instances are solved through reducing them to GVRP instances. The results of the column generation algorithm also provide a clear idea of the gains in the lower bounds comparing the SPPRC with different ng-set sizes and also with the ESPPRC, as well as the time required for computing them. In addition, several new best lower bounds are identified for the GVRP, especially for large instances.This paper is organized as follows. Section 2 presents the ESPPRC and explains the required mathematical notation. The ng-route relaxation is described in Section 3. In Section 4, we explain the techniques used to solve the ng-route relaxation. In Section 5, we demonstrate how our algorithm can be used to obtain only elementary routes, and we highlight the main elements that allowed us to build a very efficient method for solving the ESPPRC. Section 6 presents the Generalized Vehicle Routing Problem formally. Section 7 reports the computational results for both the GVRP and CVRP. Finally, Section 8 presents some conclusions.LetG=(V,A)be a graph with arc set A and vertex set V, which is composed of the set of customersCplus a source vertex s and a destination vertex t, and letRbe a set of resources. For each arc(i,j)∈A, letcijbe the cost of the arc andwijrbe the consumption of the edge, for eachr∈R. For each pairi∈Candr∈Rletairandbirbe two non-negative values, such that the total resource consumption along a path from s to i must belong to the intervalair,bir. The ESPPRC aims to find a minimum cost elementary path from s to t that satisfies all resource constraints.The resources constraints can model different types of restrictions. For instance, most vehicle routing problems consider that the vehicles have a known capacity, and this capacity cannot be exceeded in a single route. Other problems have time windows, which require the route to visit a customer in a given interval of time. Moreover, one can also view the elementarity constraint as resource constraints, where each customer defines a binary resource and when a route visits a customer, it consumes all of the associated resource.In this work, we deal only with the capacity constraint, in addition to the obvious elementarity constraint. Thus, the customer set has an associated demand functiond:C→Z, and there is a global capacity limit Q, which no feasible solution may exceed. Because we apply our algorithm for routing problems, we can consider the source and the destination vertices as a single vertex called the depot and labeled 0. Therefore, the solution of the problem is a route instead of a path. This is straightforward because most of the applications for the ESPPRC involve a pricing routine embedded in a column generation scheme that solves some type of vehicle routing problem.Recently, the ng-route relaxation was introduced in the work of Baldacci et al. (2011) for the CVRP and the CVRP with Time Windows (CVRPTW), and it was later extended to the GVRP by Bartolini, Cordeau, and Laporte (2011), where it was used to solve transformed CARP instances. This new relaxation aims at obtaining a better compromise between efficiently priced non-elementary routes and obtaining good lower bounds.For each customeri∈C, letNi⊆Cbe a subset of customers that have a relationship with i. A possible representation for this relationship can be a neighborhood relationship, i.e.,Nicontains the nearest customers of i, including i. These sets are called ng-sets, and they contain the customers that customer i is able to “remember.” For instance, when a path P is being built, by the time it arrives at customer i, it has a setΠ(P)that represents its “memory” thus far. If customer i belongs to setΠ(P), the extension is forbidden. On the other hand, if i does not belong to setΠ(P), the extension is allowed and setΠ(P)is updated to “forget” the customers that customer i is not able to “remember,” i.e., the customers that do not belong toNi. It is clear that if a customer is “forgotten,” it can be used to form a cycle in future extensions of path P. At this point, we can conclude that the size of the ng-sets is an important factor in the quality of solutions because the larger the ng-sets are, the greater the smallest cycles that can appear in a path. The size of each ng-setNiis limited byΔ(Ni), which is a parameter defined a priori. Obviously, this size also changes the pricing complexity.LetP=(0,i1,…,ip-1,ip)be a path starting at the depot, visiting a sequence of customers and ending at customeripandC(P)be the set of customers visited by path P. The functionΠ(P)of prohibited extensions (the “memory”) of path P can be defined as follows.(1)Π(P)=ik∈C(P)⧹{ip}:ik∈⋂s=k+1pNis∪{ip}.Givend(P)=∑i∈C(P)dias the total demand serviced by path P andc(P)as the total cost of path P, letL(P)=(ip,d(P),Π(P),c(P))be a label associated with a path P, which ends at customerip. We say that a labelL(P)can be extended to a customerip+1ifip+1∉Π(P)andd(P)+dip+1⩽Q. After the extension, the customerip+1becomes the last customer of a new pathP′=(0,…,ip,ip+1)and a new labelL(P′)can be obtained from the labelL(P)by the following operations:(2)L(P′)=(ip+1,d(P)+dip+1,Π(P)∩Nip+1∪{ip+1},c(P)+cipip+1).These labels are computed using a forward dynamic programming algorithm and, in contrast to the q-route relaxation, it does not result in a pseudo-polynomial complexity. This algorithm is exponential on the size ofΔ(Ni), remaining pseudo-polynomial for fixedΔ(Ni). Furthermore, its efficiency depends on the use of some techniques to speed up its execution.To reduce the number of possible paths, a dominance rule is incorporated into the algorithm. Given the labels of two pathsL(P1)andL(P2), pathP1dominates pathP2if and only if every possible extension fromP2can be done fromP1with a lower or equal total cost. For this to be true, the following three conditions must hold:(i)d(P1)⩽d(P2),c(P1)⩽c(P2)andΠ(P1)⊆Π(P2).As discussed earlier, a basic ng-route relaxation implementation does not allow the use of large ng-sets, a limitation which weakens the quality of the lower bounds found. To address this issue, we provide an efficient implementation, adapting the Decremental State Space Relaxation for the ng-route relaxation. This technique was introduced by Righini and Salani (2008) to solve the ESPPRC. The original version of the algorithm helps reduce the number of labels to be managed during the dynamic programming algorithm that builds elementary paths. First, it relaxes the elementarity of the paths and, at each iteration, identifies which customers are being repeated on the best path found and then prohibits the repetition of these customers in subsequent iterations.The main difference of our algorithm is that instead of relaxing the elementarity of the paths, the new algorithm relaxes the ng-set of each customer, therefore relaxing the ng-route restrictions.We start by creating a(Q+1)×|C|dynamic programming matrixM, where each entryM(d,i)is a bucket containing labels representing paths that start at the depot and end at customer i with total demand equal to d. At first, we setM(di,i)with a single labelLi=(i,di,{i},c0i),∀i∈C, and all other entries with no label. Next, a forward dynamic programming is used to fill the matrixM, running fromd=1up tod=Q.Algorithm 1 presents the pseudocode of our basic dynamic programming procedure. When processing the bucketM(d,i), the algorithm iterates through all labelsL(Pj)belonging toM(d-di,j), for all customersj∈C, such thatd-di>0. As the basic ng-route relaxation algorithm, the extension fromL(Pj)to i can only be performed ifi∉Π(Pj). If this condition holds, a new label, sayL(Pi), is then created and it must be stored in the bucketM(d,i). Therefore, this is the right time to check for the dominance rule, which can be verified for all the labels inM(d′,i),∀d′⩽d. Surprisingly, we have found that the algorithm runs faster if the dominance rule is tested only for labels of the same bucket, i.e., for the labels from insideM(d,i). This comes from the fact that labels associated with paths using less capacity are unlikely to dominate others using higher capacity.In addition, Baldacci et al. (2011) described another way to improve the dominance rule. When the paths of the bucketM(d,i)are being computed, the algorithm uses a dominance list associated with the customer i, which stores the best costs for every possible configuration ofΠ(P)andd′<d, to do the dominance. This way, it is faster to check the list than to iterate through the dynamic programming matrix for eachd′<d. We do not use this technique because it is not scalable, as the size of the dominance list is exponential in the value ofΔ(Ni), reaching its size limit whenΔ(Ni)≈13.Algorithm 1 also presupposes the existence of procedure buildRoutes, which takes matrixMas a parameter and extracts the best routes from it.Algorithm 1Basic Dynamic Programming ng-Route Algorithm1: procedure DynamicProgramming(M,N)2:input: matrixMand ng-setsNi⊆C,∀i∈C.3:output: the best ng-routes with respect to ng-setsNi.4:M(d,i)←∅,∀i∈C,d∈{0,…,Q}5:M(di,i)←{(i,di,{i},c0i)},∀i∈C6:ford≔1,…,Qdo7:for alli∈Cdo8:ifd-di>0then9:for allj∈Cdo10:for allL(Pj)∈M(d-di,j)do11:ifi∉Π(Pj)then12:L(Pi)←(i,d,Π(Pj)∩Ni∪{i},c(Pj)+cji)13:insertLabel←true14:for allLPi′∈M(d,i)do15:ifL(Pi)dominatesLPi′then16:deleteLPi′17:else ifLPi′dominatesL(Pi)then18:insertLabel←false19:break20:ifinsertLabelthen21:M(d,i)←M(d,i)∪L(Pi)22:return buildRoutes (M)The adapted DSSR is an iterative algorithm and it works by relaxing the state space of the original ng-setsNi. At each iteration k, the algorithm uses the subsetsΓik⊆Nias a replacement forNi. These subsetsΓiktake the role ofNiin the definition of the functionΠ, described in Eq. (1), and in the creation of new labels, as shown in Eq. (2). Initially, the algorithm setsΓi0,∀i∈C, as an empty set and executes the basic dynamic programming Algorithm 1. As the best routes found by this dynamic programming are not necessarily ng-routes w.r.t. the original ng-setsNi, they cannot be considered as the result of the pricing without verifying their feasibility. This test is performed and theΓiksubsets are updated if necessary, as described hereafter. If at the end of iteration k some subsetΓikis updated, the dynamic programming algorithm is executed again with new subsetsΓik+1.Let a cycle of customers be defined as a sub-pathH=(i,…,j), wherei=j, and letH(P)be the set of all cycles of customers in the path P. To evaluate if the best routeRk∗found in the end of iteration k is an ng-route, the algorithm must check if there is no cycleH∈HRk∗which would not be allowed to be created if the original ng-setsNiwere being used. This happens only when the first customer j of cycle H (we also refer to it as the repeated customer of the cycle) is in allNl,∀l∈C(H), i.e., customer j is not “forgotten” by any other customer of the cycle. In this case, we designate such a cycle H as a forbidden cycle w.r.t the original ng-setsNi. If any such cycle H is found, we add the repeated customer j to subsetsΓlk+1,∀l∈C(H). This prohibits cycle H from appearing in any path obtained in the next iterations. More than that, this prohibits any cycleH′=(j,…,j)in whichC(H′)⊆C(H)from appearing in the next iterations. On the other hand, if no such forbidden cycle is found at the end of iteration k, then the best routeRk∗is an ng-route and the algorithm stops.Algorithm 2 reports the DSSR procedure. The input parameter of the algorithm is the original ng-setsNi,∀i∈C. The procedures with self-explanatory names selectBestRoute, isNGRoute and updateNGSets are responsible, respectively, for extracting the best route of a set of routes, determining if a given route is a valid ng-route with respect to ng-setsNiand to update the subsetsΓikto the next iteration. Algorithm 2 also uses the procedure dynamicProgramming, which is presented in Algorithm 1, to obtain ng-routes with respect to subsetsΓikpassed as input parameters.Algorithm 2Pure DSSR ng-Route Algorithm1: procedure DSSR(M,N)2:input: matrixMand ng-setsNi⊆C,∀i∈C.3:output: the best ng-routes with respect to ng-setsNi.4:Γi←∅,∀i∈C,ng←false,k←05:while not ngdo6:R←dynamicProgramming (M,Γ)7:Rk∗←selectBestRoute (R)8:if isNGRouteRk∗then9:ng←true10:else11:updateNGSetsN,Rk∗12:k←k+113:returnR14: procedureisNGRoute(R)15:for allH=(v,…,v)∈H(R)do16:forbiddenCycle←true17:for alll∈C(H)do18:ifv∉Nlthen19:forbiddenCycle←false20:break21:ifforbiddenCyclethen22:return false23:return true24: procedureupdateNGSets(N,R)25:for allH=(v,…,v)∈H(R)do26:forbiddenCycle←true27:for alll∈C(H)do28:ifv∉Nlthen29:forbiddenCycle←false30:break31:ifforbiddenCyclethen32:for alll∈C(H)doΓl←Γl∪{v}It is noteworthy to mention that if the best route found is indeed an ng-route, the algorithm can stop and return only this route. However, if the objective is to find a set of feasible solutions, the algorithm can also return this route together with any other route certified to be an ng-route. Furthermore, if the best route is not an ng-route and one needs to find any feasible solution, any route that is indeed an ng-route can be returned, even if the best route is not feasible. In this case, we consider it as being a heuristic run of the algorithm, not an exact one. This method is useful to quickly price routes on intermediate iterations of column generation algorithms, where there is no need to generate the optimal solution.To further speed up the algorithm, we calculate completion bounds during the DSSR in a similar manner as performed by Pecin (2010) for the elementary route. At the end of iteration k, the completion bounds are calculated for each customeri∈Cwith every capacityd∈{0,…,Q}, and then used at iterationk+1. As mentioned before, the completion bounds are used to estimate a lower bound on the value of a route during its creation, thus discarding any route that would not lead to a negative reduced cost. GivenTk∗(d,i), the value of the best path which starts at customer i and ends at the depot with total capacity exactly d, the completion boundsT^k(d,i)are calculated as shown in (3) and represent the value of the best path that starts at customer i and ends at the depot with total capacity less than or equal d.(3)T^k(d,i)=mind′⩽dTk∗(d′,i).It is important to observe that if the corresponding problem is represented by means of an undirected graph,Tk∗(d,i)can be obtained directly from the dynamic programming matrix. This is true because the value of the best path that starts at the depot and ends at customer i with total capacity exactly d has the same value asTk∗(d,i), as shown by Baldacci et al. (2011). The reason for this is that if the best forward path contains a cycle, then the best backward path may also contain this cycle and vice versa because at least one costumer belonging to this cycle must “forget” the customer that repeats. On the other hand, if the problem is represented using a directed graph, to obtain these values, the direction of the edges has to be reversed, as also shown by Baldacci et al. (2011). In this case, the last iteration of the DSSR algorithm has to be executed again before the calculation. This occurs because when a route is traversed in the opposite direction on an asymmetric graph, it does not generate the same cost.After calculating the completion bounds at the end of iteration k, they can be used at iterationk+1to avoid the extension of a given labelL(P)=(j,d(P),Π(P),c(P))to a customer i if the following conditions hold:(4)c(P)+cji+T^k(Q-d(P),i)⩾0.This equation calculates a lower bound on the value of the reduced cost of any route the labelL(P)can generate, becauseT^k(Q-d(P),i)is a lower bound on the value of the best path, which would close path P after it is extended to customer i. Obviously, if the value of Eq. (4) is greater or equal than zero, the labelL(P)cannot generate any route with a negative reduced cost, and therefore, it can be discarded.It is interesting to highlight that the completion bounds becomes stronger along the iterations of the DSSR, because iteration k is a relaxation of iterationk+1, i.e., given thatΓik⊆Γik+1,∀i∈C. These bounds can be used for other important parts of a branch-cut-and-price algorithm, such as route enumeration and variable fixing.Algorithm 3 reports the pseudocode for pricing ng-routes with DSSR and completions bounds. The procedures selectBestRoute, isNGRoute and updateNGSets have the same meaning as before and generateCompletionBounds is a new procedure that calculates the bounds as shown in (3). The procedure BoundedDynamicProgramming is a slight modification of procedure dynamicProgramming of Algorithm 1, that targets only inclusion of the completion bounds calculated as shown in (4).Algorithm 3DSSR with Completion Bounds ng-Route Algorithm1: procedure DSSRwithBounds(M,N)2:input: matrixMand ng-setsNi⊆C,∀i∈C.3:output: the best ng-routes with respect to ng-setsNi.4:Γi←∅,∀i∈C,ng←false,k←05:T^(d,i)←-∞,∀i∈C,d∈{0,…,Q}6:while not ngdo7:R←BoundedDynamicProgramming (M,Γ,T^)8:Rk∗←selectBestRoute (R)9:if isNGRouteRk∗then10:ng←true11:else12:updateNGSetsN,Rk∗13:generateCompletionBounds (M,T^)14:k←k+115:returnR16: procedure BoundedDynamicProgramming(M,Γ,T^)17:M(d,i)←∅,∀i∈C,d∈{0,…,Q}18:M(di,i)←{(i,di,{i},c¯0i)},∀i∈C19:ford≔1,…,Qdo20:for alli∈Cdo21:ifd-di>0then22:for allj∈Cdo23:for allL(Pj)∈M(d-di,j)do24:ifi∉Π(Pj)then25:if checkCompletionBound (T^,L(Pj),i) then26:L(Pi)←(i,d,Π(Pj)∩Ni∪{i},c¯(Pj)+c¯ji)27:insertLabel←true28:for allLPi′∈M(d,i)do29:ifL(Pi)dominatesLPi′then30:deleteLPi′31:else ifLPi′dominatesL(Pi)then32:insertLabel←false33:break34:ifinsertLabelthen35:M(d,i)←M(d,i)∪L(Pi)36: return buildRoutes (M)37: proceduregenerateCompletionBounds(M,T^)38:T^(d,i)←∞,∀i∈C,d∈{0,…,Q}39:T^(0,0)←040:fori∈Cdo41:ford≔1,…,Qdo42:T^(d,i)←min(M(d,i))43:ifT^(d-1,i)<T^(d,i)then44:T^(d,i)←T^(d-1,i)Even with the improvements described in Section 4.2, the exact ng-route pricing still requires a long time to be executed. Because of this, a simple but effective heuristic was developed to quickly price a large initial set of routes with negative reduced cost. It was based on the heuristic pricing done for the elementary route pricing by Pecin (2010). The purpose of this heuristic is to reduce the number of calls to the exact ng-route pricing. Therefore, the heuristic ng-route pricing is used as a hot-start for the exact ng-route pricing.The heuristic closely resembles the q-route pricing without eliminating any cycle. The main difference between the pricing algorithms is that when extending one path, the heuristic ng-route pricing respects the ng-setsNi. Its data structure is also a(Q+1)×|C|matrix, and each entry consists of just one label. For each customer and each capacity, this label is chosen as the best one with respect to the reduced costs. In addition, as the ng-setsNimust be respected, each label of the dynamic programming matrix must contain theΠsets for each customer and capacity.Notice that unlike the exact algorithms, the heuristic algorithms use neither the dominance rules nor the speed-up techniques (DSSR and completion bounds) described in Section 4. Nevertheless, they are responsible for obtaining approximately 90% of the routes during the column generation. Moreover, it is straightforward to verify that the resulting complexity of the algorithms isO(n2Q).To achieve elementarity, we change the definition of theΓiksets used in the DSSR algorithm. Instead of being a subset of theNisets, which are defined a priori and have a fixed sizeΔ(Ni), the algorithm usesΓik⊆C. In this case, it will allow the insertion of any customer of the instance. In addition, the algorithm is quite the same the one described in Section 4. The only difference is in the DSSR feasibility test, described as follows.The algorithm starts with emptiesΓl0,∀l∈C. At the end of each iteration k, it identifies all cycles on the best solution, and the repeated customer of each cycleH∈HRk∗is inserted on subsetsΓlk+1,∀l∈C(H). Thus, if cycleH=(i,…,j),i=j, is identified at the end of iteration k (that is, if cycle H belongs toHRk∗), the next DSSR iterations will not generate any path with a cycleH′=(i,…,j), in whichC(H′)⊆C(H). Note, however, that it is still possible to obtain a path that visits customer j more than once at iterationk+1, as this customer is not present in all subsetsΓlk+1. The algorithm stops when the best route does not contain any cycle, i.e. it is an elementary route, or its reduced cost is non-negative.The way the algorithm increases the state space along the DSSR iterations resembles the method used by Righini and Salani (2008), however the differences control better the growth of the number of labels, turning the algorithm capable of dealing with larger instances. The DSSR of Righini and Salani (2008) is performed prohibiting the customers which repeat on the best routeRk∗from repeating again in subsequent iterations until an elementary route is found. This is equivalent to inserting each repeated customer of each cycleH∈H(Rk∗)in all subsetsΓik+1, rather than just considering this inclusion in subsetsΓlk+1,∀l∈C(H).We noted in computational experiments that this more aggressive manner of increase of the state space is quite dangerous because the whole algorithm fails if the number of labels to be treated in the dynamic programming becomes critical. In contrast, the size of the largest subsetΓikhardly exceeded 20 in our algorithm, even for instances with 200 customers.Another important difference from our approach and that of Righini and Salani (2008) is the way we use the DSSR to calculate completion bounds at each iteration to accelerate the subsequent DSSR iterations. Computational results reveal that the use of completion bounds allow us to solve the column generation for CVRP instances that would not be solved in an acceptable time if they were not used.Furthermore, because the algorithm presented here aims to find only elementary routes, instead of using the heuristic pricing presented in Section 4.3, we implemented a heuristic pricing like the one described in Pecin (2010).The Generalized Vehicle Routing Problem (GVRP) can be defined as follows. LetG=(V,E)be a graph with vertex set V and edge set E. There is a special vertex 0 called the depot. The vertices are partitioned into disjoint sets, called clusters,C={C0,C1,…,Ct}, whereC0={0}contains only the depot. Given the cluster index setM={0,1,…,t}, letμ(i)∈Mbe defined, for each vertexi∈V, as the index of the cluster which contains i. There exists a demand functiond:M→Z+associated with all clusters, in which the depot has demandd0=0. These demands are to be serviced by a setKof identical vehicles with capacity Q, located at the depot. The edge setE={{i,j}|i,j∈V,μ(i)≠μ(j)}contains the edges between all pairs of vertices from different clusters. Associated with these edges, there exists a traversal cost functionc:E→Z0+. LetRbe the set of all possible closed routes starting and ending at the depot. The objective of the GVRP is to select a subset of k routes fromRthat: (i) minimizes the total traversal cost (ii) ensures that the demand from every cluster is serviced by a single vehicle on a single vertex from each cluster and (iii) ensures that the total demand serviced by each route does not exceed the vehicle capacity Q.The GVRP is a generalization of the Capacitated Vehicle Routing Problem (CVRP) and the Generalized Traveling Salesman Problem (GTSP). When all the clusters contain only one vertex, it is simply the CVRP. Similarly, when there is only one vehicle, it is simply the GTSP. It is clear that when both conditions are true, it is simply the Traveling Salesman Problem (TSP). In the view of this, it is easy to see that any solution for the GVRP can be directly used to solve these problems.This problem is stronglyNP-hard and has gained attention in the literature in recent years. To the best of our knowledge, the first published work to deal with this problem is Ghiani and Improta (2000), where a transformation to the Capacitated Arc Routing Problem (CARP) is presented to use the existing algorithms for the CARP. One instance was proposed and solved using this approach.Since then, few works have been published on the GVRP. Recently, the work of Bektaş, Erdoğan, and Røpke (2011) has proposed four formulations for the GVRP. After extensive experiments with these formulations, a branch-and-cut algorithm was devised using one of them, an undirected formulation with an exponential number of constraints. The reader may consult this paper for further details on these formulations.

@&#CONCLUSIONS@&#
The strength of the ng-route pricing is the ability of adjusting the size of the ng-sets in order to calculate a lower bound in a reasonable time, which is close as much as possible to the elementary route bound, and this property justifies an efficient implementation of the method. In this paper, we presented an efficient ng-route pricing algorithm for ng-set sizes up to sixty-four, a number at least three times greater than we know so far. Furthermore, we showed how our restricted non-elementary route pricing algorithm can be easily extended in order to price only elementary routes. We highlighted the two elements that allowed us to price elementary routes even for CVRP instances with 200 customers, a result which doubled the size of the ESPPRC instances solved so far. The first element is the way we adapt the Decremental State Space Relaxation (DSSR) technique of Righini and Salani (2008) for the ng-routes context, thus improving their way of increasing the state space along the DSSR iterations. The second is the combination of the DSSR technique with completion bounds, which are calculated in each iteration of the DSSR for the purpose of accelerating the next iteration.The final algorithm was tested for pricing elementary and restricted non-elementary routes to a set partitioning formulation for both GVRP and CVRP. For the first one, we could improve the lower bounds for up to 13 instances, since we also separated and added capacity and strengthened comb cuts.