@&#MAIN-TITLE@&#
Scheduling of no buffer job shop cells with blocking constraints and automated guided vehicles

@&#HIGHLIGHTS@&#
This paper addresses an extension of Block Job shop Scheduling problem taking AGV.Two integer non-linear programming (INLP) models are proposed.A two-stage heuristic combining improved timetabling and local search is developed.Four principles are proposed to guarantee the feasibility of the search.A set of benchmark tests is conducted to testify the effectiveness of the method.

@&#KEYPHRASES@&#
Job shop scheduling,Blocking,AGV,Disjunctive graph model,Local search,

@&#ABSTRACT@&#
The blocking job shop (BJS) problem is an extension of a job shop problem with no buffer constraints. It means that after a job is completed on the current machine, it remains on that machine until the next machine becomes available. This paper addresses an extension of the BJS problem, which takes into account transferring jobs between different machines using a limited number of automated guided vehicles (AGV), called a BJS–AGV problem. Two integer non-linear programming (INLP) models are proposed. A two-stage heuristic algorithm that combines an improving timetabling method and a local search is proposed to solve the BJS–AGV problem. A neighborhood structure in the local search is proposed based on a disjunctive graph model. According to the characteristics of the BJS–AGV problem, four principles are proposed to guarantee the feasibility of the search neighborhood. Computation results are presented for a set of benchmarking tests, some of which are enlarged by transportation times between different machines. The numerical results show the effectiveness of the proposed two-stage algorithm.

@&#INTRODUCTION@&#
The classical job shop (JS) scheduling problem is one of the hardest combinatorial optimization problems and has a broad engineering background [1–3]. With the development of manufacturing technology and demands, extensions of the JS problem have been considered. To reduce production expenses, just-in-time (JIT) manufacturing philosophies have been implemented, which maintain a limited amount of process inventory or buffer [4]. Buffer is defined as the amount of free machine space on which parts are allowed to wait, either after the completion of processing on a machine or on the next machine. These are called input and output buffers, respectively. JIT with limited buffers or no buffers has been investigated by many researchers [4,7,8,11–14]. When dealing with no buffer conditions, JS problems will be under blocking or no wait constraints depending on whether parts are allowed to wait on the machines [15]. The problem considered in this paper assumes blocking constraints.Scheduling with blocking constraints means that after a job has completed its current machine operation, it remains on the present machine until the next machine becomes available for processing. Most of the exist researches related to limited buffer or blocking are on flow shop scheduling [5–8]. Liu et al. [5] propose an effective hybrid algorithm based on particle swarm optimization for permutation flow shop scheduling problem with the limited buffer between consecutive machines to minimize make-span. Both Qian et al. [6] and Pan et al. [9] propose effective hybrid algorithm using differential evolution to deal with the same problem as Liu et al. [5]. Wang et al. [10,11] propose a novel hybrid discrete differential evolution algorithm and a hybrid modified global-best harmony search algorithm, respectively, for solving the blocking permutation flow shop scheduling with the makespan criterion. Liang et al. [12] present a dynamic multi-swarm particle swarm optimizer for solving the same problem as Wang et al. [10]. Pan et al. [13,14] also present three improved heuristics basing on two simple constructive heuristics and a mimetic algorithm, respectively. Job shop problems with blocking constraints (BJS) have been investigated by several researchers. Mascis et al. [15] studied the BJS problem and formulated it with an alternative graph and proposed several heuristic algorithms. Brucker et al. [16] propose a tabu search algorithm to solve the BJS problem for cyclical scheduling. GrÖflin et al. [17] and [18] address the BJS problem and the flexible blocking job shop (FBJS) problem, by taking into account the transfer time associated with moving a job from one machine to another, and sequence-dependent setup times between consecutive operations on a machine. AitZai [19] proposes a combination of a branch and bound algorithm with alternative graphs and develops two methods based on genetic algorithms to solve the BJS problem. Hayasaja et al. [20] describe a procedure for local modifications of the planned JS schedule under no buffer constraints. From GrÖflin et al. [17] and [18], the transportation time between different machines is shown to be a considerable element of the BJS problem. However, the source of transportation media is found to be sufficient ([17,18]). More applications related to the BJS problem have also been reported in the processing and logistics industries, such as scheduling for the manufacturing of concrete blocks by Grabowski et al. [21], steel-making by Pacciarelli et al. [22], chemical batch production by Romero et al. [23], container handling at a port by Chen et al. [24] and railway networks by D’Ariano et al. [25].In practical production, the source of transferring media is time restricted and uses robots or automated guided vehicles (AGV). It is convenient to use robots or AGVs as transferring media to transfer jobs between different machines, and in general, the number of the robots or AGVs is also restricted. Such situations have already appeared in flexible manufacturing systems (FMSs) and robotic cells (RCs). FMSs are highly automated production systems producing a wide variety of job types [26]. Blazewicz et al. [27] propose a dynamic programming approach to construct optimal machine and vehicle schedules. Corréa et al. [28] propose a hybrid method designed to solve the problem of dispatching and conflict free routing for automated guided vehicles (AGVs) in a FMS. Caumond et al. [29] use a mixed integer linear program (MILP) to find the optimal solutions for FMS scheduling problems with one vehicle. Zhang et al. [26] propose a model for a flexible job shop scheduling problem with transportation constraints and bounded processing times. A manufacturing cell consisting of a number of machines and material handling performed by one (or a few) robots or AGVs is called a robotic cell [30]. Robotic cells with no storage buffers between machines are widely used in practice and are called no wait or bufferless RCs [26]. Che et al. [31] address a multi-robot, 2-cycle problem in a no wait-RC and develop a polynomial algorithm to find the minimum number of robots for all feasible cycle times. Brauner et al. [32] describe a new class of equivalent one-machine, no wait-RC problems and propose new algorithm procedures to solve this RC problem. Ulusoy et al. [33] propose a genetic algorithm to schedule a flexible manufacturing system consisting of several machine centers and two identical automated guided vehicles to minimize make-span. Abdelmaguid et al. [34], Reddy et al. [35], Deroussi et al. [36], Chaudhry et al. [37] and Lacomme et al. [38] address this same problem and propose several heuristic algorithms. Zhang et al. [39] present a Pareto-based genetic algorithm that incorporates a local search module to solve a job shop scheduling problem with two new objective functions related to vehicles.To the best of our knowledge, no research has been performed on BJS problems that consider transferring jobs using a limited number of AGVs. Based the above discussion, this is an important problem. Brucker et al. [40] have already described cyclic job-shop problems with one robot and blocking. Therefore, this paper addresses the BJS–AGV problem with the objective of minimizing the make-span. Two integer non-linear programming (INLP) models are proposed to describe the BJS–AGV problem. A two-stage heuristic algorithm that combines an improved timetabling method and local search is proposed to solve the BJS–AGV. The improved timetabling method is proposed based on non-delay timetabling to find a feasible solution for the BJS–AGV. The neighborhood in the local search is the proposed base for a disjunctive graph model. According to the characteristics of the BJS–AGV problem, four principles are proposed to guarantee the feasibility of the neighborhood in the local search. Computation results are presented for a set of benchmarks, some of which are enlarged by transportation time between different machines. The results show the effectiveness of the proposed two-stage algorithm.This paper is organized as follows. Section 2 discusses the definition and assumptions of the BJS–AGV problem and describes the BJS–AGV problem using the two INLP models. Section 3 introduces the structure and procedure for the improved timetabling method to find a feasible solution. Section 4 introduces the theory and structure of the neighborhood in the local search to optimize the base in disjunctive graph model and the four principles that are necessary to guarantee the feasibility of the proposed neighborhood. Section 5 discusses a series of experimental tests and computational results, showing the effectiveness of the proposed two-stage heuristic algorithm. Finally, Section 6 discusses the conclusions of this paper.The classical job shop problem with no buffer constraints, transportation time and several AGVs can be described as follows: there is a set of n jobs (J={1,2,…,n}) required to be processed on a set of m machines (M={1,2,…,m}). The jobs are transferred between different machines by a set of V AGVs (V={1,2,…,v}). Each job has a specific processing route and has to be processed on each machine at most once. Each AGV can handle at most one job at a time. The processing of a job (Oij) on a machine is called a machine operation. Between the machine operation Oijprocessed on a machine Mkand after Oij+!when a part is processed on machine Ml, a transportation operation is performed by some AGV, resulting in a transportation time tkl. We assume that all transportation times are machine dependent and job independent. In addition, when an AGV moves from machine Mkto Mlwithout carrying a job, the empty moving timet′klis the same as tkl. Because of the no buffer constraint condition, a machine cannot begin any other operation until a downstream machine receives the semi-finished product that it just processed, which essentially means that the machine is blocked until it releases the product [20]. For each job, there is a waiting time after it is finished on the current machine until an AGV is available. Before the next machine is free, the AGV has to wait there. Once the next machine is free, the job can be unloaded onto that machine. Although this process is similar to the concept presented by Mascis et al. [15], here we focus only on blocking with swapping allowed. A swap is needed when there are two jobs in the cycle and the job on the AGV waiting for the current machine is blocked by the other. Additionally, another job is waiting for the AGV on the current machine. In this condition, two jobs in the cycle can unload onto the machine and load onto the AGV simultaneously. Fig. 1(a) shows the procedure of the swapping. In this research, a load/unload (L/U) station, which serves as the distribution/collection center for the jobs [35], is also considered. Four layout configurations are described here and are shown in Fig. 2. If the L/U station is considered, the AGV needs to transfer jobs from the load station to the machine where the first operation is to be performed and from the machine where the last operation was performed to return to the unload station. Fig. 1(b) shows how AGV transfers jobs to process on different machines between L/U station. The objective is to determine a feasible schedule that minimizes the exit time of the last job of the system (with the L/U station considered) or minimizes the completion time of the last job (make-span).IndicesJset of jobsset of machinesset of AGVsjth machine operation of job iprocessing time of jth machine operation of job iThe transfer time between two different machines k and k′1,if operationOijis required processing on machinek0,otherwiseprocessing start time for the jth machine operation of job iprocessing finish time for the jth machine operation of job itransfer start time for the transportation operation between oij−1 and oijtransfer finish time for the transportation operation between oij−1 and oij1,if transportation operation betweenOij−1andOijtransferred by AGVv0,otherwiseObjective function:(1)Minmax{Cij}(2)Minmax{Ctij}Subject to:(3)∑v=1Vxijv=1,∀i,j=1,2…n,(n+1)(4)Sij+Pij=Cij,∀i,j=1…n(5)Stij≥0,∀i,j=1(6)Stij≥Ci(j−1),∀i,j=2…n,(n+1)(7)Sij≥Stij+∑k=1Kαijk⋅tLk,∀i,j=1(8)Sij≥Stij+∑k=1K∑k'=1Kαi(j−1)k′⋅αijktk′k,∀i,j=2,3…n(9)Ctij=Stij+∑k=1Kαijk⋅tLk,∀i,j=1(10)Ctij=Stij+∑k=1K∑k'=1Kαi(j−1)k′αijk⋅tk′k,∀i,j=2,3…n(11)Ctij=Stij+∑k=1Kαi(j−1)k⋅tkU,∀i,j=n+1(12)xijv⋅xi′j′v⋅Stij−Si′j′−∑k′=1Kαi′j′k′⋅tk′L⋅Sti′j′−Sij−∑k=1Kαijk⋅tkL≤0,∀i,j,i′,j′,v,i≠i′,j=1,j′=1xijv⋅xi′j′v⋅Stij−Si′j′−∑k'=1Kαi′j′k′⋅tk′L⋅Sti′j′−Sij−∑k=1K∑k′=1Kαijk⋅αi′(j′−1)k′tkk′≤0,∀i,j,i′,j′,v,i≠i′,j=1,j′=2…nxijv⋅xi′j′v⋅Stij−Sti′j′−∑k'=1Kαi′(j′−1)k′⋅tk′U⋅Sti′j′−Sij−∑k=1K∑k′=1Kαijk⋅αi′(j′−1)k′tkk′≤0,∀i,j,i′,j′,v,i≠i′,j=1,j′=n+1(13)xijv.xi′j′v⋅Stij−Si′j′−∑k=1K∑k′=1Kαi′j′k′⋅αi(j−1)ktk′k⋅Sti′j′−Sij−∑k=1K∑k′=1Kαijk⋅αi′(j′−1)k′tkk′≤0,∀i,j,i′,j′,v,i≠i′,j=2…n,j′=2…n(14)xijv.xi′j′v⋅Stij−Sti′j′−∑k′=1Kαi′(j′−1)k′⋅tk′L−∑k=1Kαi(j−1)k⋅tLk.Sti′j′−Sij−∑k=1K∑k′=1Kαijk⋅αi′(j′−1)k′tkk′≤0,∀i,j,i′,j′,v,i≠i′,j=2…n,j′=n+1xijv.xi′j′v⋅Stij−Sti′j′−∑k′=1Kαi′(j′−1)k′⋅tk′L−∑k=1Kαi(j−1)k⋅tLk⋅Sti′j′−Stij−∑k=1Kαi(j−1)k⋅tkL−∑k′=1Kαi′(j′−1)k′tLk′≤0,∀i,j,i′,j′,v,i≠i′,j=n+1,j′=n+1(15)αijk⋅αi′j′k′⋅(Sij−Sti′(j′+1))(Si′j′−Sti(j+1))≤0,∀i,j,i′,j′,k,k′,i≠i′,j=1…n,j′=1…n(16)αijk⋅αi′j′k′⋅(Sij−Sti′(j′+1))(Si′j′−Sti(j+1))≤0,∀i,j,i′,j′,k,k′,i≠i′,j=1…n−1,j′=1…n−1αijk⋅αi′j′k′⋅(Sij−Ci′j′)(Si′j′−Sti(j+1))≤0,∀i,j,i′,j′,k,k′,i≠i′,j=1…n−1,j′=nαijk⋅αi′j′k′⋅(Sij−Ci′j′)(Si′j′−Cij)≤0,∀i,j,i′,j′,k,k′,i≠i′,j=n,j′=nEq. (3) ensures that each transportation operation is performed by only one AGV. Eq. (4) provides a relation between the start and finish times for each operation. For machine operations oi(j−1) and oijand transportation operations between oi(j−1) and oij, Eqs. (5) and (6) give the relations between the start time for the transportation operation and the finish time of oi(j−1). In Eq. (5), Sti1 refers to the transfer start time from the load station to the first machine for job i, and in Eq. (6), Sti(n+1) refers to the transfer start time from the last machine for job i to return to the unload station. Eqs. (7) and (8) give the relations between the start time for the transportation operation and the processing start time for oij. Eqs. (9)–(11) give the relations between the start and finish times for the transportation operation. Eqs. (12)–(14) provide restrictions so that no two transportation operations are performed by the same AGV at any time. Eqs. (15) and (16) provide restrictions so that no two machine operations are performed on the same machine at any time. When the L/U station is considered, the mathematic model is stated as follows:Model 1:Objective function: (2)s.t. (3), (4), (5), (6), (7), (8), (9), (10), (11), (12), (13), (14), (15)When the L/U station is not considered, the mathematic model is stated as follows:Model 2:Objective function: (1)s.t. (3), (4), (6), (8), (10), (13), (16)By summarizing the objectives and constraints, two integer non-linear mathematic (INLP) models are attained. Compared to the JS and JS-AGV problems, blocking (no buffer) constraints lead to more complex scheduling for both the machines and AGVs, corresponding to Eqs. (12)–(16), which makes solving these equations more difficult. In JS-AGV, after an operation finishes on a machine, and the AGV does not reach, it can be moved to the buffer on the machine to wait for the AGV, and the next operation can be processed on the machine. However in BJS–AGV, the finished operation has to wait for the AGV on current machine, which makes blocking, and the next operation cannot be processed until it leaves. So the start processing time of the next operation is related to leaving time of the previous operation on each machine. Fig. 3shows the meaning of the constraint, it can be seen that on machine k, operation j of job i is followed by operation b of job a, in this case the starting time of operation b is determined by the leaving time of operation j since the previous operation j cannot release its current machine before the AGV reaches to load it from the machine.Similarly, the BJS–AGV problem is also an NP hard problem, and thus, a two-stage heuristic algorithm that combines improved timetabling with a local search function is proposed to solve this problem. In the first stage, feasible solutions to the BJS–AGV problem are obtained from the improved timetabling method. In the second stage, the feasible solutions are optimized by a local search using a disjunctive model. The two INLP models are solved by Lingo 11 for use as a benchmark.Scheduling problems with blocking constraints are more difficult to solve than the classical job shop problem. In contrast to the classical job shop problem, a feasible partial schedule cannot always be extended into a feasible complete schedule [18]. Therefore any heuristic that incrementally builds up a solution (e.g., based on priority rules) runs the risk becoming infeasible. For the BJS, conventional method, such as meta-heuristics [41–43], particle swarm optimization [44] and [45], simulated annealing [46], genetic algorithm [47,48], cannot obtain a feasible solution directly, just several papers [15,49,50] have proposed dispatching rules or heuristic algorithms to provide a feasible solution quickly. However, these are not suitable for the BJS–AGV problem, and a new method is required to find a feasible solution to the BJS–AGV problem.To find an effective method to solve the BJS–AGV problem, a simple case is used. Table 1shows the processing routes and times for each operation and the transfer time between the different machines.To come to a solution (preferably an optimized one), this case is first solved using a Lingo base with the above model. The scheduling result is shown in Fig. 4.Because the BJS–AGV problem is an NP hard problem, when the scale of the case is medium or large, Lingo cannot provide a (global) optimal solution (see the computational results in Section 5). From the viewpoint of each job, the scheduling result is similar to that for a classical job shop problem with a no-wait constraint (NWJS). Therefore, in this paper, an improved timetabling method is proposed to solve the BJS–AGV based on non-delay timetabling.The authors in [51–53] have applied non-delay timetabling to solve the NWJS problem successfully. Therefore, this method provides a way to find a feasible solution for the NWJS problem. Before timetabling, a specific processing sequence needs to be given (∏(1),…,∏(n)), implying that the starting time t∏(1) ≦…≦t∏(n). Non-delay timetabling can be defined as follows ([51]):1.Set t∏(1)=0.Given the starting times t∏(1),…,t∏(n), for some k∈{1,…,n−1}, set the starting time t∏(k+1) to be as early as possible without violating any of the constraints.From this, it can be seen that the makespan obtained by non-delay timetabling is just an upper bound of the problem and can be further improved.Based on the main idea of non-delay timetabling, an improved timetabling heuristic has been developed to address the BJS–AGV problem. After given a processing sequence, the heuristic assigns the jobs (operations) to the machines based on non-delay timetabling and the given sequence. The heuristic always checks all the AGV and job statuses once a job finishes its current operation on a machine to judge whether an AGV is free and available at the current time point. At this time, the heuristic assigns jobs to be transferred to the next machine.Jobs are scheduled based on non-delay timetabling and the given sequence. If the L/U station is considered, the AGV transfers the jobs from the load station to the machine where the first operation takes place or from the machine where the last operation took place to the unload station. After the AGV unloads a job onto a machine, it can move to another machine or stay at current machine to pick up a load (job). Each AGV is checked to see if it is free and available at the demand time point. The phrase free and available means that the AGV is empty and has sufficient time to move between already scheduled machine transfers and on to the current machine in the timeline, such as the yellow time window shown in Fig. 4. A different AGV is used unless it is the first machine operation of a job. When machine operation Oijis rescheduled, if the transportation operation between Oijand Oi(j+1) begins at time point K and is transferred by AGV N in the last scheduling, the status of AGV N will not be checked at time point K. The main flow chart used for the improved timetabling for the BJS–AGV is given in Fig. 5.The procedure for improved timetabling of the BJS–AGV based on the flow chart is:Algorithm 1Improved timetabling heuristic for BJS–AGVStep 1: Provide a processing sequence ∏(1)…,∏(n) and schedule the job based on the sequence.Step 2: Checks and process each operation of current job; if this is the first operation of the job, go to step 3, else go to step 8.Step 3: Find the earliest time point to process the operation and finish, go to step 4.Step 4: If there is a free and available AGV to move the job to the next machine, go to step 5, else go to step 6.Step 5: Move the job to the next machine and return to step 2.Step 6: If the next time point of the current machine is free and machine blocking is in effect, return to step 4, else if it originates from step 3, go to step 7; if it originates from step 9, go to step 11.Step 7: Clear the current machine operation from the schedule and return to step 2.Step 8: If the machine is free when the job is assigned, go to step 9, else go to step 10.Step 9: Process the operation on the machine, go to step 12.Step 10: If the next time point of the AGV is free and AGV blocking is in effect, return to step 8, else go to step 11.Step 11: Clear the current and last machine and transportation operations from the schedule, return to step 2. For the current machine operation Oij, the last machine operation corresponds to Oi(j−1).Step 12: If the current operation is the last operation of a job, go to step 13, else go to step 4.Step 13: If all jobs are completed, exit, else return to step 2.When the L/U station is considered, two transportation operations are added to each job, starting from the load station and returning to the unload station after completing the machine operations. The main flow chart is similar to that seen in Fig. 5.After a feasible solution is obtained, this solution needs to be improved to find the optimal solution. In this paper, a local search operator is proposed for this purpose. The structure of the neighborhood in the local search here is proposed based on the disjunctive graph model.The classical job shop (JS) problem can be described by a disjunctive graph model. Subsequently, many researchers have successfully solved the job shop problem using a disjunctive graph model [38], [54] and [55]. A disjunctive graph G=(V, A, E) is defined as follows: V is {start, o11, o12, …, onn, end} the set of nodes representing all operations and start and end represent the dummy start and finish operations, respectively. A is the set of conjunctive arcs connecting the consecutive operations of the same job, and E is the set of disjunctive arcs connecting the operations to be processed by the same machine. Each arc(i, j)∈A is weighted with the processing time of each operation i. Each arc(i, j)∈E is weighted with the processing time depending on its orientation.Hurink and Knust [56] extend the disjunctive graph model to correspond to G=(V, C, DM, DR) to describe the classical job shop problem with transportation by a robot (JS-AGV). Lacomme et al. [38] extend it to several robots. Set C corresponds to set A and set DMcorresponds to set E. The variable DRis the set of disjunctive arcs connecting operations that must to be transferred similarly to E. Each arc(i, j)∈DRis weighted with the (empty) transferring time between the different machines depending on its orientation. Although the BJS–AGV problem can be described by the disjunctive graph model, the blocking constraint is difficult to represent. Fig. 6represents the disjunctive graph model link to the data in Tables 1 and 2(to make the graph clearer, the disjunctive arcs associated with set DRare omitted). When L/U stations are considered, the transportation operations shown in the red boxes appear.For the JS and JS-AGV problems, turning (all) undirected disjunctive arcs in E or DM∪DRinto directed conjunctive ones is referred to as a (complete) selection. Given a complete selection, the corresponding directed graph, Gs=(V, A, S) or Gs=(V, C, SM, SR), represents a feasible solution if it is acyclic. The longest path from the START node to the END node in Gswhose total weights represent the makespan is referred to as the critical path. Any operation on the critical path is called a critical operation. The critical path can be decomposed into a number of blocks. A block is the maximum sequence of adjacent critical operations that are processed on the same machine, called critical block. If Gscontains a positive cycle, it is an infeasible solution. Several types of infeasible solutions caused by machines or AGVs are shown in Fig. 7.For the BJS–AGV problem, the solution space is a subset of JS-AGV. However, even if a complete selection Gs=(V, C, SM, SR) is acyclic, it may result in an infeasible solution for the BJS–AGV problem, such as is shown in Fig. 8.In Fig. 8, the blue solid line does not consist of a cycle but is an infeasible solution for the BJS–AGV problem. The processing sequence on M3 is O11→O31, while transferring sequence on R1 is O31→O11. On machine 3, O31 could not be processed until O11 leaves the machine (transferred by R1), and for the AGV (R1), O11 could not be transferred before O31. The two contradictions lead the scheduling infeasible. Therefore, guaranteeing the feasibility of a solution for the BJS–AGV problem is considerable.To analyze the relations between the different machine and transportation operations for the BJS–AGV problem, this paper changes the disjunctive graph model to the viewpoint of each machine, based on GrÖflin [17], Fig. 6 is then be redrawn as Fig. 9.Compared to the traditional disjunctive graph, for the graph in Fig. 9, Sijand Cijrefer to the processing start and finish times for the machine operation Oij, respectively. The unit Sij→Cijis equivalent to the node Oijin set V, and the two conjunctive fold (dotted) lines connecting Ci1j1 to Si2j2 and Ci2j2 to Si1j1 are equivalent to the disjunctive arc between Oi1j1 and Oi2j2 in set E or DM(these two operations are processed on the same machine). The conjunctive lines connecting Sijto Cij, Cijto R and R to Sij+1 are equivalent to the conjunctive arc for set A or C. Additionally, the disjunctive arcs for set DRare omitted for brevity. In the new disjunctive graph, the routes of the AGV transferring operations between different machines are more clearly, which makes it more convenient to analysis how to guarantee the feasibility of AGV scheduling for BJS–AGV problem. The new graph can also point out the processing sequence of operations on each machine uniformly. Lets give the scheduling in Fig. 10as example. The AGV reaches M1 at time point 6 when M1 is free, it unload O11 on M1 and then moves to M2 empty. When AGV reaches M2 at time point 8 when O21 just finishes on M2, it transfers O21 to M3.To determine the reason for the infeasibility of the solution caused by using AGV(s) for the BJS–AGV problem, Figs. 7 and 8 are translated into the new disjunctive graph model in Fig. 11.In Fig. 11, R12 refers to the transportation operation between O31 and O32 when transferred by AGV 1 in the second position. From three figures above, it can be seen that for the BJS–AGV problem, the sequence of the (transportation) operations on the same AGV is stricter than for the JS-AGV problem. There is a greater relation to the sequence of (machine) operations processed on the same machine, which makes it difficult to find a feasible solution for the BJS–AGV problem. Based on the infeasible and feasible solutions described by the new graph model above, we summarize four principles used to guarantee the feasibility of AGV(S) scheduling for the BJS–AGV problem:(1).For the operations R→Sij→Cij→R′→Si(j+1)→Ci(j+1)→R″, if R, R′ and R″ are transferred by the same AGV, the sequence must be S(R)<S(R′)<S(R″).For operations R→Sij→Cij→R′ and operations R″→Si1j1→Ci1j1→R‴, if Oijand Oi1j1 are processed on the same machine and Oijis first and if R, R′, R″ and R‴ are transferred by the same AGV, the sequence must be S(R)<S(R″), S(R′)<S(R‴).For operations R→Sij→Cij→R′ and operations R″→Si1j1→Ci1j1→R‴, if Oijand Oi1j1 are processed on the same machine and Oijis first and if R′ and R″ are transferred by the same AGV, the sequence must be S(R′)<S(R″) or S(R′)=S(R″)+1. For example, the operations in the blue box in Fig. 7 are in accordance with S(R′)=S(R″)+1.When there are two AGVs, for all the units R→Sij→Cij→R′ and for the units R″→Si1j1→Ci1j1→R‴, if R and R″ are transferred by the same AGV and the same as R′ and R‴, but R is not transported on the same AGV as R′, for contacting R and R″, R′ and R‴, respectively (or inversed), there does not exist a cycle.In the four proposed principles, principles 2 and 3 relate to the (no buffer) blocking constraint, and principles 1 and 4 relate to the processing route of jobs, which does not consider blocking. For the JS and JS-AGV problems, principles 1 and 4 also require compliance. A discussion on guaranteeing the feasibility of machine scheduling is provided in following section.Hurink and Knust [56] present a theorem to define a suitable neighborhood for the JS-AGV problem base using the disjunctive graph model, which has been successfully applied by Lacomme et al. [38]. It is described as follows.TheoremLet S be a complete selection with a makespan Cmax(S) and let P be a critical path associated with S. If another complete selection S′ with a makespan Cmax(S′)<Cmax(S) exists, then in S′, at least two jobs of a block on P are processed in the opposite order as in S.For the BJS–AGV problem, the solution space is a subset of the JS-AGV problem, so the theorem is also suitable to define a neighborhood for the BJS–AGV problem. Based on this theorem, the main idea behind proposing the neighborhood is exchanging adjacent operations in the same critical block. The critical block is the machine-block or AGV-block. Assuming that two adjacent operations exist in the same AGV-block, a feasible neighborhood can be achieved if after exchanging the two operations the new neighborhood exists in accordance with the four proposed principles. Based on the obtained neighborhood, the scheduling scheme can be calculated by Algorithm 2. The main flow chart describing Algorithm 2 is shown in Fig. 12(without considering the L/U station).Algorithm 2The procedure to determine the scheduling schemeStep 1: Schedule the machine operations according to the obtained sequence. If the selected machine operation is the first machine operation of a job, go to step 2, else go to step 6.Step 2: If the machine is free and the prior machine operations are finished, go to step 3, else return to step 1.Step 3: Process the current machine operation on the machine and when finished, go to step 4.Step 4: If the selected AGV for the next stage is available, go to step 5, else block the machine to wait for the selected AGV.Step 5: Transfer the job to the next machine and return to step 1.Step 6: If the machine operation is transferred to and reaches the machine, go to step 7, else return to step 1.Step 7: If the machine is free and the previous machine operations are finished, process the current operation on the machine and go to step 8, else block the AGV and wait.Step 8: If the current machine operation is the last machine operation of a job, go to step 9, else go to step 4.Step 9: If all machine operations are finished, exit, else return to step 1.When the L/U station is considered, only two transportation operations added to each job, as in algorithm 1. The main flow chart is almost the same as in Fig. 12.Due to principle 4, when the number of AGVs is N, and the number of the units of R→Sij→Cij→R′ is M, there needs to be at mostAMNcalculations to check the feasibility of the obtained neighborhood. When the number of AGVs and units (machine operations) are large, it becomes very time consuming to check the feasibility of the neighborhood.If two adjacent operations are in the same machine-block, the neighborhood is obtained as follows in Fig. 13.In Fig. 13, the blue fold line represents the critical scheduling path from Fig. 4. If we exchange the sequence of O32 and O23 in the critical block, then the sequence of operations processed on machine 1 is O12, O23 and O32, and the (blue dotted) line between C32 and S23 is replaced by the (red dotted) line between C23 and S32. After obtaining the different sequence of machine operations, the sequence of transportation operations is rescheduled based on the AGV scheduling mechanism similar to Algorithm 1. The scheduling scheme is calculated by a method similar to Algorithm 2.However, simply swapping the two operations may lead to an infeasible solution because the resulting selection contains a positive cycle, as in Fig. 7. Some other operations may need to be rescheduled to obtain a feasible solution, as shown in Fig. 14. Because it is difficult to describe how to adjust an infeasible neighborhood caused only by (swapping) machine operations, as in Fig. 7, the transportation operations are omitted.Here, it is assumed that the blue fold line starting with S11 and ending with C33 represents the critical path of a feasible solution. To get a neighborhood, we exchange the position of O12 and O23 processed on machine 3 in the same critical block. This means that the blue (dotted) line from C12 to S23 is replaced by the red line from C23 to S12. However, a positive cycle appears after this change, which indicates an infeasible solution. In the positive cycle C23→S12→C12→S13→C13→S21→C21→S22→C22→S23→C23, only the (dotted) line between C13 and S21 can be changed (C23→S12 is the only change), and thus, the line C13→S21 is replaced by C21→S13 according to the sequence of other machine operations. If there are two or more changeable (dotted) lines in a positive cycle, randomly select one and replace it as above and repeat until there is no positive cycle. After that, the sequence of transportation operations is rescheduled, and the scheduling scheme is calculated.In each iteration, to optimize the initial feasible solution, a new neighborhood is obtained, and a new scheduling scheme is determined based on the new neighborhood. If the new scheduling scheme has a better objective function than before, the best solution for this case is defined as the current scheduling scheme.Two types of experiments are conducted to test the algorithms using well-known benchmarks. The first benchmark is suggested by Bilge and Ulusoy [57] and has been used by Ulusoy et al. [33], Abdelmaguid et al. [34], Reddy and Rao [35], Deroussi et al. [36], Chaudhry et al. [37] and Lacomme et al. [38]. It is composed of 40 cases. All the cases are made up of one LU station, four machines and two vehicles. Each case includes between 5 and 8 jobs and between 13 and 21 operations to be scheduled. We select 36 cases for use in the computations. The second benchmark is obtained from the following standard job shop benchmark problem: la01-40 by Lawrence [58], orb01-10 by Applegate et al. [59] and swv01-10 by Storer et al. [60]. We add to each case a randomly generated transfer time between the different machines that is uniformly distributed in the interval [1,25] (see Appendix).The two-stage algorithms are coded in C# and run on a PC with an Intel® Core™ 2 Quad 2.66 GHZ CPU and 2 GB of RAM.The parameters used in the two steps algorithms are as follows. In the first stage, the number of initial feasible solutions for each instance is defined to be 200. In the second stage, the number of iterations to find the neighborhood for each initial solution in the local search is defined to be 1000.When dealing with the first benchmark instances, two situations and two objective functions are proposed as follows:S1: the L/U station is not consideredS2: the L/U station is consideredO1: minimize the completion time of the last job (makespan)O2: minimize the exit time of the last job in the systemWe combine S1 with O1 and S2 with O2. Because there are no benchmark results available for the BJS–AGV problem, and to further evaluate the performance of the proposed two-stage algorithm, Lingo 11.0 is used to provide a comparison of solutions based on the integer non-linear programming model in Section 2. When dealing with S1, we test the instances with 1 AGV and 2 AGVs, respectively. The results obtained by Lingo and the proposed two-stage algorithm are within 4h and 5min, respectively. The results are shown in Table 2, where OPT refers to the best solution obtained by Lingo 11.0. STATUS refers to the best global or local solution obtained by Lingo 11.0. T-S-HEU refers to the best solution obtained by the proposed two-stage heuristic algorithms.When considering S2, due to the complexity of the BJS–AGV problem, a feasible solution was not able to be obtained by Lingo within 4h for two AGVs in many cases. Therefore, we test only the instances using a single AGV under S2. The results are as shown in Table 3.Based on the test experiments above, when dealing with the second set of benchmark cases, we use the proposed two-stage algorithm to test only the cases under S1 and O1. Considering the restriction provided by principle 4, we test cases with 1, 2 and 3 AGVs, respectively. The time limit for each run is 40min. The results are shown in Table 4. In the column labeled “Size”, 10×5 means there are 10 jobs and each job has 5 machine operation stages. The average time of finding the final solutions from the 200 initial ones of cases in different scales are listed in Table 5.As Tables 2 and 3 show, for small size instances, the results obtained by the proposed two-stage algorithm are equal to the global optimal solutions and are better than the local optimal solutions obtained by Lingo 11.0 after a few minutes. This proves that the proposed two-stage algorithm is a very useful method for a small size BJS–AGV problem. As for the enlarged large size instances, although the quality of the solutions is unknown, considering the complexity of the BJS–AGV problem, the proposed two-stage heuristic algorithm can provide feasible solutions in an acceptable time.To illustrate the robustness of the two-stage algorithm, we also select 20 instances to run the algorithm in new parameter setting combinations: In the first stage, the number of initial feasible solutions for each instance is defined to be 180. In the second stage, the number of iterations to find the neighborhood for each initial solution in the local search is defined to be 950. Table 6shows the make-span of instances under new parameters and the gap between new results (make-span) and the results listed in Table 4.Gap=New result−Result in Table4Result in Table4×100%Under different number of AGVs, the average gaps are equal to 1.25%, 1.33% and 1.47%, respectively. It shows robustness of the algorithm.This paper addresses the BJS–AGV problem with the objective of minimizing the make-span. Two integer non-linear programming (INLP) models are proposed to describe the BJS–AGV problem. A two-stage heuristic algorithm combining an improved timetabling method and a local search is proposed to solve the BJS–AGV. The neighborhood in the local search is proposed based on a disjunctive graph model. In iterations to find neighborhood, the algorithm can select two machine operations or two transportation operations to exchange, two different selections can optimize the initial solutions independently, which makes the neighborhood diversity, avoid falling into local optimal. According to the characteristics of the BJS–AGV problem, four principles are proposed to guarantee the feasibility of the neighborhood in the local search, making the algorithm efficient. To check the effectiveness of the proposed two-stage heuristic algorithm, a set of benchmark instances and selected enlarged instances are tested by the two-stage algorithm and Lingo 11.0. The results demonstrate the effectiveness of the proposed two-stage algorithm. As mentioned above, the good robustness in getting final solution (make-span), keeping diversity and efficient finding neighborhood to optimize solutions are the advantages of the proposed algorithm. The disadvantage of the proposed method is computational effectiveness. When the scale of the instance (case) or the number of AGV is large, it would be time consuming to solve.Travel time for a machine size of 5.m1m2m3m4m5m108231521m28015519m323150610m41556020m5211910200Travel time for a machine size of 10.m1m2m3m4m5m6m7m8m9m10m108121813122292120m2806172016451214m3126019879172413m4181719012549613m513208120101512214m61216751005231817m722494155021215m8951791223201419m9211224621181214011m10201413134171519110Travel time for a machine size of 15.m1m2m3m4m5m6m7m8m9m10m11m12m13m14m15m101517161317101525153917188m215014422721251320124192515m317140141922359231725232216m416414017117141781862458m513221917031421210171814810m61772211302174716211662m71021371420121421131616149m81525514217120248171841316m925139171241424024102242111m101520238107218240251519320m1131217181716131710250196149m129425618211618215190232017m13171923241416164241962301018m141825225861413213142010012m15815168102916112091718120

@&#CONCLUSIONS@&#
