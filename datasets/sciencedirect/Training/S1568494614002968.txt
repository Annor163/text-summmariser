@&#MAIN-TITLE@&#
Hybrid algorithms for the twin–screw extrusion configuration problem

@&#HIGHLIGHTS@&#
For the TSCP hybridization of algorithms improves performance.The hybrid algorithms can be classified into two main approaches. The first is to use PLS as a post-processing of the non-dominated set of solutions generated by TPLS, MOACO, or MOEA.In this case, we obtained rather large improvements over the non-hybrid search methods used in the first phase.The second main approach to hybridization was to seed the initial set of solutions to PLS, MOACO and MOEA, respectively.

@&#KEYPHRASES@&#
Twin-screw extruder,Multi-objective optimization,Hybrid algorithms,Ant colony optimization,Evolutionary algorithms,Pareto local search,

@&#ABSTRACT@&#
The twin-screw configuration problem (TSCP) arises in the context of polymer processing, where twin-screw extruders are used to prepare polymer blends, compounds or composites. The goal of the TSCP is to define the configuration of a screw from a given set of screw elements. The TSCP can be seen as a sequencing problem as the order of the screw elements on the screw axis has to be defined. It is also inherently a multi-objective problem since processing has to optimize various conflicting parameters related to the degree of mixing, shear rate, or mechanical energy input among others. In this article, we develop hybrid algorithms to tackle the bi-objective TSCP. The hybrid algorithms combine different local search procedures, including Pareto local search and two phase local search algorithms, with two different population-based algorithms, namely a multi-objective evolutionary algorithm and a multi-objective ant colony optimization algorithm. The experimental evaluation of these approaches shows that the best hybrid designs, combining Pareto local search with a multi-objective ant colony optimization approach, outperform the best algorithms that have been previously proposed for the TSCP.

@&#INTRODUCTION@&#
Twin-screw extruders are widely used by the plastic industry to prepare polymer blends, compounds and composites for increasingly more advanced applications. They contain two parallel intermeshing screws rotating inside a heated barrel. If both screws rotate in the same direction, these machines are known as co-rotating twin screw extruders. They often have a modular construction, i.e., a number of individual barrel and screw elements are available, enabling the assembly of geometrical configurations that are adapted to the characteristics of the material being processed [1].It is well known that the performance of co-rotating twin-screw extruders is strongly dependent on the operating conditions, on the screw geometry/configuration used and on the properties of the polymeric system. Screws are built by connecting along a shaft modular screw elements with different geometric characteristics and, consequently, different impact on the compounding process. Thus, when a new compounding process is to be implemented, the best screw configuration needs to be defined. This problem, known as twin-screw configuration problem (TSCP), consists in defining the location of a pre-defined number of screw elements along the screw axis in order to optimize the process. The latter is evaluated according to different performance measures, which from an optimization perspective correspond to the objectives to be optimized. As a result, the TSCP is a multi-objective optimization problem, that is, it is characterized by the simultaneous optimization of several, conflicting objectives.In recent years, an automatic process that links the optimization procedure to a modeling routine has been proposed and continuously improved. Initially, Gaspar et al. proposed a multi-objective evolutionary algorithm (MOEA) named reduced Pareto set genetic algorithm (RPSGA) [2] that was applied to solve the TSCP [3] in terms of the optimization of the processing conditions [4]. Teixeira et al. applied the same optimizer to the optimization of several screw configuration case studies dealing with reactive starch cationization [5]. This automatic procedure is only effective if the modeling routine is able to predict correctly the evolution of the different process performance measures (that is, the objectives to be optimized) along the extruder barrel (e.g., pressure, temperature, shear rate, residence time, viscous dissipation, average strain and dispersive and distributive mixing). This was achieved by a modeling routine [6], that takes into account the relevant physical phenomena and that is sensitive to changes in polymer properties, operating conditions and screw geometry/configuration. However, since this requires 1–3min to evaluate one screw configuration (measured on a single core of ing an AMD opteron TM 2116 dual-core processors running at 2.4GHz with 2MB L2 cache), it is important to develop efficient optimization algorithms in order to define adequate screw configurations within a reasonable computational time.Along these lines, several tests were performed in order to obtain an effective single objective iterative improvement algorithm. This algorithm was extended to several bi-objective case studies of the TSCP, by embedding it into the two phase local search (TPLS) [7] and Pareto local search (PLS) frameworks [8]. TPLS is based on a search model using a scalarized acceptance criterion (SAC), whereas PLS is based on a search model using a component-wise acceptance criterion (CWAC) [9]. In both cases, good results were obtained when compared with RPSGA. In another line of research, multi-objective ant colony optimization (MOACO) algorithms were adapted to tackle the TSCP, resulting in a final MOACO algorithm that was often superior to the other algorithms had been considered previously [10].All the algorithms developed so far for the TSCP rely on a single type of search method. Over the last years, the combination of various search methods into hybrid algorithms has received strong attention [11,12]. These combine components of different algorithmic ideas trying to obtain synergetic effects resulting in increased convergence speed and/or higher quality solutions. The probably most common approach to generate hybrid methods is to complement population-based metaheuristics with local search procedures [13–16] to increase convergence speed and to locally fine-tune solutions.In this paper, we examine whether the heuristic algorithms we have developed previously can be improved by hybridization. We examine various possibilities for hybridization. A first possibility is to post-process solutions generated by RPSGA, TPLS and MOACO by PLS. This hybridization is motivated by the high performance combinations of TPLS and PLS reached in other studies [9,17]. A second possibility is to seed RPSGA and MOACO by good initial solutions obtained from TPLS, trying to speed-up the convergence of these population-based methods. A common feature of all the hybrid algorithms we study is that they consist of two distinct phases. In a first phase, a starting set S of non-dominated solutions is generated, which, in a second phase is then improved by another search method. Our experimental study of these hybrid methods on various bi-objective case studies of the TSCP shows the usefulness of hybridization: for the same number of maximum screw evaluations, the hybrid methods find better approximations to the Pareto front. Our experiments also establish a combination of MOACO with PLS as the best performing hybrid strategy.This paper is structured as follows. Section “The twin-screw configuration problem” presents the TSCP. The metaheuristics studied in this work are explained in Section “Multi-objective algorithms”. In Section “Case studies” we identify the case studies and the results are discussed in Section “Results and discussion”. Finally, the main conclusions are presented in Section “Conclusions”.The TSCP consists in the definition of the sequence of a fixed number of screw elements along the screw axis, in order to maximize the relevant performance measures of a given compounding process. The set of available screw elements is composed by the following three types of geometries:1Conveying elements have a positive drag conveying capability; they are characterized by different pitches and lengths. A screw element with higher pitch has a higher conveying capability.Left handed elements create a backflow and thus impose a restriction to the axial progress of the polymer flow; they are generally used to induce melting and dispersive mixing, they are also characterized by pitch and length.Kneading blocks are sets of kneading disks that are assembled to form positive, neutral or negative staggering angles. Positive angles create conveying capability, while negative angles impose a restriction to the polymer flow. The former promotes distributive mixing, while the latter are used for dispersive mixing purposes.In Fig. 1, we give an example where a total of 14 screw elements must be located along the screw axis. They encompass 11 conveying elements, two kneading blocks and one left handed element.As the individual modules have different geometric characteristics and, consequently, dictate different polymer flow characteristics, the process performance will be different depending on their relative positions [18Teixeira et al., 2007,6]. There is no closed analytical form to compute the performance measure of the extrusion process for a given screw configuration; thus, this computation relies on simulation, which essentially requires numerical solutions to the balance equations describing the process. Earlier we developed an appropriate modeling routine that is able to predict satisfactorily the evolution of the different process performance parameters along the extruder [6].Next, we give a high-level process description. Table 1represents a possible screw configuration composed by 14 conveying elements with different lengths (30, 60 and 120mm) and pitches (20, 30, 45 and 60mm), one left handed element (with a pitch of −20mm) and two kneading blocks forming staggering angles of −45° and −60°. Fig. 2a depicts a co-rotating twin screw extruder with the screw configuration presented in Table 1. This machine comprises a screw feeder to feed the polymer at a pre-set rate, the screw modular barrel elements and a die to shape the final melt. Both barrel and die are heated to a set temperature by heater bands. Fig. 2a also shows the axial evolution of the computational pressure and temperature. The physical steps I–VI the material is typically subjected to as it progresses along the screw axis are identified in Fig. 2b [18Teixeira et al., 2007,6]. Initially the polymer will flow through conveying elements under starved conditions as a result of screw rotation and, consequently, without pressure (Fig. 2b, I). When the first restrictive screw element (that is, either a left handed element or a kneading block) is reached, the channel fills up (Fig. 2b, II) and heat transfer becomes more efficient. Eventually, a thin melt film surrounds the solid plug (Fig. 2b, III). Soon, the melt film near the active flanck of the screw will grow into a melt pool (Fig. 2b, IV). Eventually the solid bed will break, so that the surviving pellets become dispersed in polymer melt (Fig. 2b, V) and melting is quickly completed. Depending on the screw configuration, the melt can progress in a total or a partially filled channel, and consequently under or without pressure, respectively. Finally, the polymer is pushed through the die, and the extrudate is produced.In order to compare the performance of the hybrid and non-hybrid algorithms, we defined experiments that make use of the characteristics of a co-rotating twin screw extruder Leistritz LSM30.34 available at the University of Minho. The geometric characteristics (length and pitch) of the 16 individual screw elements available are described in Table 1. Taking into account the importance of restrictive elements in the process, four different numbers of screw elements where considered (Table 2): from one in instance TSCP1 to four in instance TSCP4. Note that KB-60 represents a set of kneading disks forming a backwards angle of 60°.As illustrated in Fig. 1, to guarantee enough conveying capability upstream, the position and geometry of the first two conveying elements are fixed. Thus, the aim is to define the location of 14 screw elements that optimize the performance of the compounding process. Table 3presents the objectives considered, the aims of the optimization (minimization or maximization) and the respective range of variation ([xmax, xmin]). Each of the combinations of two objectives defines one case study for the algorithms. Thus, we have a total of 12 TSCP instances to apply the algorithms and each of these instances corresponds to the combination of a specific number of screw elements and two objectives.As mentioned in Introduction Section, the modeling routine requires considerable computation time, in the range of one or more minutes on a modern CPU. Thus, even for small problems such as the ones with 14 screw elements that we consider in this paper, an exhaustive enumeration of the search space is not possible. In fact, assuming one minute per evaluation, an exhaustive enumeration would result in computation times of more than 150000 CPU years. Hence, heuristic algorithms are the main feasible way to tackle the TSCP. To limit the computation time of the heuristics, we use as a stop criterion for each algorithm 3000 evaluations of the modeling routine. Thus, the comparison of the algorithms is based on the same computational effort allocated to each algorithm.In this section, we describe the local search and the population-based heuristic algorithms that we explored in previous research efforts and that we used as our basis for the hybrid algorithms we study in this paper.The main idea underlying TPLS is to aggregate the objectives of the multi-objective problem into a sequence of single objective problems that are solved with effective local search methods [19,9]. The single objective problems are typically generated by using weighted sum aggregations and the sequence of single objective problems is obtained through modifications of the weights during the search process, which allows TPLS to search different areas of the Pareto front. Details about the construction of the weights adopted for this work can be found in [7]. The TPLS algorithm we apply is presented in Algorithm 1 in pseudo-code. It starts with an initial solution s, which is generated randomly (line 1). Then, s is improved by a stochastic local search [20] algorithm SLS1 (line 2) to find a solution that is as good as possible for the set of weights considered. The final solution s is added to the archive (line 3). Next, TPLS explores a sequence of aggregations applying an SLS algorithm SLS2, considering as initial solutions for each aggregation the best solution of the previous aggregation. All non-dominated solutions found in this process are added to the archive (lines 4–7). The algorithm stops when the maximum number of evaluations is reached and returns the filtered archive (lines 8–9) as a final approximation to the Pareto front.The TPLS algorithm we apply here is an iterative first-improvement algorithm that makes use of a two-exchange neighborhood that exchanges the position of two screw elements in the sequence and that uses the neighborhood restriction techniques as described in [7]. When running TPLS, both the final best solution found by the iterative improvement process and all non-dominated solutions that have been examined during the local search process are added to the archive.Algorithm 1TPLS algorithm1:s is a randomly generated solution2:s′ = SLS1(s)   /* First phase */3:Adds′ to Archive4:for all weight vectors λdo5:s=s′6:s′ = SLS2(s, λ)   /* Second phase */7:Add s′ to Archive8:end for9:Filter Archive10:return ArchivePLS uses dominance criteria for accepting neighboring candidate solutions into an archive that collects the current set of non-dominated solutions found so far [21,9]. PLS can be seen as a straightforward extension of iterative improvement algorithms from single objective problems to the multi-objective case. An outline of PLS is presented in Algorithm 2. The archive is initialized with a set of solutions S and for each solution s in the Archive an associated visited flag is set to false (line 1). At each step of PLS, a solution is first chosen uniformly at random among all still unvisited solutions in the archive (that is, among all solutions whose visited flag is false; line 3). Next, the neighborhood of the chosen solution s is examined and all neighboring solutions that are non-dominated with respect to s (line 4) are added to the archive with their visited flag set to false (line 5). At the end of the neighborhood examination, the visited flag of s is set to true (line 6). Before the next iteration, the archive is filtered by removing all dominated solutions (line 7). This process continues until either all solutions in the archive are visited or the limit of the number of screw evaluations is reached. When PLS is used as a stand-alone algorithm, it is typically initialized by one single solution; however, when hybridized with other algorithms, the initial set of PLS is the candidate set of solutions output by the other algorithm.Given the possibility of the exponential increase of the number of non-dominated solutions, a bounding technique has been used [22]. The main idea is to allow only one solution in a specific region of the objective space to be added to the archive. For this purpose, the objective space is divided into a grid according to a geometric sequence and only one solution is allowed to occupy each hypercube. This method limits the increase of the non-dominated solutions in the archive and prevents cycling, given that one solution will only enter into a hypercube if it dominates the solution already there in.PLS uses the same two-exchange neighborhood as TPLS; more details on the PLS algorithm can be found in [8].Algorithm 2PLS Algorithm1:Initialize Archive A, mark all s∈A as unvisited2:while termination condition not met do3:s← RandomChoice(A, unvisited)4:S′←neighborss′notdominatedw.r.t.s, mark all s′ as unvisited5:A←A∪S′6:mark s as visited7:Filter(A)8:end while9:returnAEvolutionary algorithms are based on the concept of natural evolution and use a set of solutions that, in each generation, will undergo selection, mutation and crossover operations, trying to improve the quality of the following generations of solutions [23]. In this study, we apply the reduced Pareto set genetic algorithm (RPSGA) proposed by Gaspar et al. [3] as a representative MOEA algorithm. RPSGA uses two populations: the main and an elitist population. The first population with n individuals stores the best individuals found in each iteration; the elitist population with 2n individuals applies the inver-over operator [24]. Additionally, an archive of non-dominated solutions is kept in order to avoid good solutions getting lost. The main steps of the RPSGA algorithm are illustrated in Algorithm 3.Algorithm 3RPSGA1:Initialize pe(external population) and Archive to empty set2:piis a randomly generated, initial population (internal)3:while termination condition not satisfied do4:Evaluate pi5:Evaluate individuals’ fitness considering clustering6:Copy best individuals to pe7:if external population full then8:pe← Clustering(pe)9:Copy best individuals of peto pi10:end if11:Select individuals for reproduction12:Apply Inver-over operator to selected pairs of individuals13:Add non-dominated solutions to Archive14:Filter Archive15:end while16:return ArchiveFirst, the algorithm generates an empty external population and archive (line 1) and randomly creates the internal population (line 2). At each iteration, the following steps are carried out. The solutions of the internal population are evaluated by the modeling routine (line 4); then, the fitness of each solution is calculated making using of the clustering technique (line 5) and a fixed number of best solutions are copied to the external population (line 6). If the latter is not full, the selection and inver-over operators are applied to individuals of the internal population to produce a new population (lines 11 and 12). The non-dominated solutions found are copied to the archive (line 13) and this is filtered to remove dominated solutions (line 14). If the external population becomes full, a clustering technique is applied to sort the individuals of the external population, and a pre-defined number of the best individuals are incorporated in the internal population by replacing the lowest fitness individuals (lines 8 and 9). More details on the algorithm can be found in [3].Ant colony optimization is a population-based algorithm that takes inspiration on real ants’ foraging behavior [25,26]. The main idea of ACO is to probabilistically construct solutions as a function of the concentration of pheromone on the ants trail and to iteratively reinforce the components of solutions with better performance. MOACO algorithms apply the mechanisms of ACO algorithms to tackle multi-objective problems. Algorithm 4 presents the outline of our MOACO algorithm. It starts by defining the initial pheromone value of each entry of the pheromone matrix and the initial values of pheromone limits. Then the main loop is repeated (lines 2–7) until some termination condition is met. First, the ants probabilistically construct solutions to the TSCP (line 3). Then, each solution is evaluated by the modeling routine (line 4) and all non-dominated solutions found in the current algorithm iteration are added to the archive; the archive is filtered by removing dominated solutions (line 5). Finally, the pheromone matrices will be updated (line 6) first by evaporating a part of the pheromone and then depositing pheromone on the solution components of elite solutions. This pheromone updating process will induce a search around the best solutions found so far.Algorithm 4MOACO for TSCP1:Initialize Initialize pheromone values matrices and Archive2:while termination condition not satisfied do3:Construct solutions4:Evaluate the solutions’ fitness5:Add nondominated solutions to Archive and Filter Archive6:Update pheromone trails7:end while8:Filter Archive9:return ArchiveIn our previous work, we tested various choices to be taken in a MOACO algorithm such as the number of ant colonies to be used, or specific settings of parameters [10]. Here, we use the best ACO configuration found previously: a set of 60 ants divided into three colonies, one pheromone matrix for each objective and the update of the matrices done by region. Details about this MOACO algorithm for the TSCP can be found in [10].Earlier, we studied separately the above four algorithms [3,8,7,10]. Here, we combine them by concatenating two of them. To do so, we follow two main approaches. The first is to improve the solutions generated by TPLS, MOACO, or MOEA by the PLS algorithm. The second is to first execute TPLS with very few scalarizations and then to use the non-dominated solutions that have been found as an initial population for the other algorithms.One natural choice is to apply PLS to post-process the solutions generated by other algorithms and this idea has been applied also in other researches. For example, the post-processing of solutions generated by TPLS is also known as the TPLS + PLS framework [17]. If MOEA or MOACO are used in the first phase, in what follows we refer to the resulting algorithms as MOEA+PLS and MOACO+PLS. When combined with PLS, the algorithms TPLS, MOACO and MOEA are stopped early to compare the solution quality reached by the hybrid algorithms with the pure strategies using the same computational effort. (TPLS is stopped after four scalarizations have been executed as described in more detail in the next subsection, while the MOACO and the MOEA algorithm are stopped after 1500 evaluations, allowing PLS a further 1500 evaluations until the termination criterion is reached.) Note that for TPLS, MOEA and MOACO an archive with all non-dominated solutions found during the search process is saved. Once these methods reach a certain number of evaluations, PLS is started, using as initial set of solutions, all non-dominated solutions existing in the archive. Note that the archive bounding used in PLS is not applied to filter the archive of non-dominated solutions given to it as input. However, when choosing a solution for neighborhood exploration, the rules of the archive bounding are used for selecting the right solution in each hypercube.The quality of the initial population can have a significant influence on the search performance of population-based algorithms. Therefore, a common goal in memetic algorithms [13] is to generate a high quality initial population, which is advantageous in the early iterations of MOEAs and MOACO algorithms. Here, we generate such a set of high-quality initial solutions by TPLS. In particular, TPLS is run with four pre-defined weights λ∈{0, 1/3, 2/3, 1}, which results in weight vectors (0, 1);(1/3, 2/3);(2/3, 1/3);(1, 0). TPLS stops once the best solution is found for each weight. It is straightforward to seed RPSGA with some initial solutions. This is done by including in the initial population all non-dominated solutions generated during the execution of TPLS; if the population cannot be filled with the non-dominated solutions generated by TPLS, it will be completed by solutions that are generated uniformly at random. Seeding a MOACO algorithm can be done by initializing the pheromone trails in a specific way. Our choice in the hybrid TPLS+MOACO algorithm is to update the respective pheromone matrices with an amount of pheromone corresponding to five times the solution's final quality before the actual start of the construction of solutions in the MOACO algorithm. In this way, the first solutions generated by MOACO already take into account information on the solutions found by TPLS. In other words, the TPLS solutions are used to bias the solution construction during the MOACO algorithm.Finally, we need to mention that there are actually two interpretations for the TPLS+PLS hybrid. The first is that PLS is used to post-process the non-dominated solutions generated by TPLS, while the same hybrid can also be seen as using TPLS to seed the PLS algorithm with high-quality initial solutions instead of using a single random solution as seed for PLS. Anyway, both interpretations lead to the same algorithm.

@&#CONCLUSIONS@&#
A main conclusion from our computational results is that for the TSCP hybridization of algorithms improves performance when compared to the underlying, non-hybrid search methods. The hybrid algorithms can be classified into two approaches. The first is to use PLS as a post-processing of the non-dominated set of solutions generated by TPLS, MOACO, or MOEA. In this case, we obtained rather large improvements over the non-hybrid search methods used in the first phase. The second approach to hybridization is to seed the initial set of solutions to PLS, MOACO or MOEA by the non-dominated solutions returned by TPLS. In this case, TPLS used only very few weight vectors to limit its computation time. Although seeding PLS, MOACO, and MOEA by TPLS solutions resulted in a better ranking of the hybrid algorithms than the individual search techniques, the relative improvements according to the EAF differences were rather small. Hence, the conclusion from our experimental analysis is that the post-processing of non-dominated sets by PLS is the most promising hybrid approach. Among these, MOACO+PLS performs best: it reaches the overall best ranking among the nine algorithms we compared and obtains the highest hypervolume on eight of the 12 instances. It also ranks statistically significantly better than all other competing algorithms, except MOEA+PLS.From the point of view of the twin-screw extrusion problem, we can conclude that the hybrid algorithms allow to potentially identify better screw configurations. Given that the hybrid algorithms obtained, for a same number of screw evaluations, better approximations to the Pareto front, we have also evidence that they are faster to reach high quality Pareto fronts than the non-hybrid ones. This is important as the computation time required to evaluate solutions is high.There are a number of possible directions for future research on the TSCP. First, we would like to improve the performance of the algorithms by trying to introduce recent improvements on the anytime behavior of PLS [31]. Such extensions will be crucial for adapting our algorithms to three and more objectives. Finally, we would also like to explore more advanced versions of the problem, where in a first step appropriate screw elements have to be chosen from a large set of available ones and then the chosen screw elements be sequenced in the second step. This more complex problem results in much larger search spaces and therefore it provides a significant challenge for future research.