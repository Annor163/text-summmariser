@&#MAIN-TITLE@&#
Fully abstract trace semantics for protected module architectures

@&#HIGHLIGHTS@&#
FormalisesA+I: an assembly language extended with protected module architectures – an isolation mechanism found in emerging processors.Presents two trace semantics forA+Iprograms and proves that both are fully abstract w.r.t. the operational semantics.Details which problems arise when considering readout and writeout labels in the trace semantics ofA+Iprograms.

@&#KEYPHRASES@&#
Fully abstract semantics,Trace semantics,Untyped assembly language,Protected modules architectures,Formal languages,

@&#ABSTRACT@&#
Protected module architectures (PMAs) are isolation mechanisms of emerging processors that provide security building blocks for modern software systems. Reasoning about these building blocks means reasoning about elaborate assembly code, which can be very complex due to the loose structure of the code. One way to overcome this complexity is providing the code with a well-structured semantics. This paper presents one such semantics, namely a fully abstract trace semantics, for an assembly language enhanced with PMA. The trace semantics represents the behaviour of protected assembly code with simple abstractions, unburdened by low-level details, at the maximum degree of precision. Furthermore, it captures the capabilities of attackers to protected code and simplifies the formulation of a secure compiler targeting PMA-enhanced assembly language.

@&#INTRODUCTION@&#
Emerging processors, such as the Intel SGX [1], provide isolation mechanisms as software security building blocks. These are used to withstand low-level attackers who, generally through injected assembly code, can read the whole memory space and can thus access secrets in memory, violate integrity constraints and so on. When these isolation mechanisms are in place, attackers cannot directly violate security properties of isolated software since the isolated memory is not accessible to them. Examples of these protection mechanisms are protected module architectures (PMAs) [1–7], which enforce security properties at process or lower levels (Ring −1). With PMA, the software to be secured is placed in a protected memory partition (a protected module) that shields it from the surrounding, potentially malicious code. The malicious code can neither read nor write the protected memory; it can only jump to specific addresses in protected memory in order to call functions of the protected code. Thus, PMA makes software more resilient against low-level attackers. However, this does not prevent an attacker from violating security properties of protected code by interacting with it.Describing the interaction between protected and unprotected code or (dually) of an attacker to protected code can be done by using contextual equivalence. However, while being precise, contextual equivalence is notoriously difficult to reason about [8]. An alternative characterisation of the behaviour of protected code has the form of fully abstract trace semantics. Such a semantics uses simple abstractions to represent the behaviour of protected assembly code, unburdened by low-level details, while remaining at the maximum degree of precision. Dually, it models the behaviour of attackers to protected code, since it captures precisely the capabilities of those attackers.The fully abstract trace semantics has the following benefits. Firstly, it allows contextual equivalence to be disregarded, since contextual and trace equivalences are proven to be equally precise. The full abstraction property ensures that traces express precisely all the capabilities of an attacker. Without the trace semantics, the capabilities of an attacker towards protected code are expressed by means of contexts: complex sequences of assembly instructions. With the trace semantics, the capabilities of that attacker are captured via the simple notion of traces, which provide a clearer abstraction than contexts.Secondly, the fully abstract trace semantics fulfils the claims of recent secure compilation works targeting PMA-enhanced assembly languages. Given two programs C1 and C2 written in a language L, indicate their compilation to an assembly language withC1↓andC2↓respectively. One way of proving the compilation scheme secure is formally stated asC1≃C2⟺C1↓≃C2↓[9]. The more complex direction of this proof isC1≃C2⇒C1↓≃C2↓, but it can be simplified by adopting a fully abstract trace semantics for the assembly language, as in the works of Agten et al. [10] and Patrignani et al. [11,12]. These works presented secure compilers to PMA-enhanced assembly code that depend on the assembly language having a fully abstract trace semantics such as one of those presented in this paper.Finally, the trace semantics allows some limitations of the aforementioned secure compilers to be forgone. Currently, securely-compiled function calls can have a number of parameters based on what the registers allow. To overcome this limitation (or to pass large data that does not fit in a register value), additional parameters can be spilled on the stack in unprotected memory. To allow this spilling, the trace semantics needs to capture reading and writing outside of the protected memory. While none of the previous did, the trace semantics of this paper considers both operations.This paper initially presents the PMA protection mechanism and informally describes how to devise a fully abstract trace semantics for PMA-enhanced assembly code (Section 2). Then it introducesA+I: an assembly language enhanced with PMA (Section 3). This paper then investigates how different operations across PMA boundaries are supported by trace semantics. It explores the design space of trace semantics forA+Iand presents two different fully abstract trace semantics for it (Section 4): one where cross-boundary operations are restricted to function calls (Section 4.1) and one where they are unrestricted (Section 4.2). This paper extends the authors’ previous work [13] by considering additional behaviour in traces in the form of protected code reading unprotected memory (whose complications are explained in Section 2.2). This paper then provides a general strategy to simplify the proof of full abstraction of the trace semantics (Section 5). Finally, it reviews related work (Section 6) and concludes (Section 7). Limitations of this work are threefold. Firstly, the trace semantics cannot express side-channel attacks. Secondly, the formalisation does not consider details of the architecture such as caches; yet this is a commonly found assumption [10,11,14,15]. Thirdly, the second trace semantics relies on an assumption on the partitioning of unprotected code that is not readily fulfilled by certain PMA implementations; Section 7 discusses this limitation.This section describes the PMA memory access control mechanism and the behaviour ofA+Icode (Section 2.1). Then it discusses the pitfalls to avoid in order to obtain a fully abstract trace semantics forA+Icode (Section 2.2).The assembly language is enhanced with a protected module architecture (PMA). This isolation mechanism enforces a fine-grained, program counter-based memory access control mechanism [2–7]. We review this mechanism from the work of Strackx and Piessens [6], upon which our results are based. The techniques presented in this paper can nevertheless be easily adapted to reasoning about other isolation mechanisms [2,3,5]. The protection mechanism provides a secure environment for running code that must be protected from the code it interacts with. This mechanism assumes that the memory is logically divided into a protected and an unprotected partition. The protected partition is further divided into a read-only code and a non-executable data section. The code section contains a variable number of entry points: the only addresses where instructions in unprotected memory can jump to and execute. The data section is accessible only from the protected partition. Based on the location of the program counter, instructions that violate the access control policy cause the execution to halt[10,11].The table below summarises the access control model enforced by PMA.From≥toProtectedUnprotectedEntry pointCodeDataProtectedr xr xr wr w xUnprotectedxr w xFollowing are some code snippets that exemplify how the PMA access control mechanism works, and, introduce the syntax of theA+Ialong the way. AllA+Iexamples throughout the paper assume the presence of a protected memory section spanning from address 100 to 200, with a single entry point at address 100. In the examples, call the code located in the protected section Psand the code located in the unprotected section Pu. Every instruction is preceded by the address where it is located; execution starts at address 0.Example 1No execution of code in the protected code sectionPuinitialises registerr0to 101 (line 1) and then jumps to that address (line 2).Since address 101 is not an entry point of the protected memory section, the jump ofPudoes not succeed.Puinitialises registerr0to 101 (line 1) and registerr1to 20 (line 2), then it writes the contents ofr1to the address inr0(line 3).Since address 101 is protected,Pucannot write there, so execution is halted, as in Example 1. Analogously, if the instruction of line 2 were replaced withmovlr0r1, the execution halts. In that case,Puwould be attempting to read the protected memory section, while it does not have that privilege.Puinitialises registerr0to 12 (line 1), registerr1to 10 (line 2), registerr5to 100 (line 3) and then calls to the protected function located at address 100 (line 4), storing address 4 on the call stack (implicit).Pssubtracts registersr0andr1(line 6) and, if the result is greater than or equal to zero, returns that result (line 9). Otherwise, if the result is less than zero,Psjumps to address 104 (lines 7 and 8), and returns 0 (lines 10 and 11). Execution then continues in unprotected memory at address 4 (line 5, omitted), which is the address popped from the call stack (implicit).To provide a better understanding of the PMA memory layout, Fig. 1below provides a graphical representation of the layout of this example.As seen in Example 3, the description of the behaviour of protectedA+Icode can be rather burdensome as it is expressed in terms of the external code and each protected instruction. A trace semantics can give a simpler description of the behaviour of protectedA+Icode in terms of a set of sequences of labels. These labels capture how communication between protected and unprotected codes happens and what is communicated. In this paper, trace semantics are devised to capture the behaviour of a protected program, which is a program allocated in the protected memory partition. Example 4 presents a trace-based description of the behaviour of the protected code of Example 3. After showing the limitations of the initial trace semantics, this section presents the pitfalls that arise when considering writes (Section 2.2.1) and reads (Section 2.2.2) to unprotected memory.Example 4Describing behaviour with tracesConsider only the protected code of the snippet from Example 3.Since there is a single entry point to this code, located at address 100, this code just represents a single function. A possible behaviour of this code can be expressed as follows (·is used to separate actions of the same trace):call100r0,…,r11·retr0To describe the behaviour of the code of Example 4 as a trace, we identify the actions that are observable from the point of view of code interacting with the snippet above: call and ret. These actions are the labels of the trace semantics; they are generated by call and ret instructions. Not all instructions generate a visible label in a trace, only those whose effect can be observed from the unprotected code.Following is the syntax of labels of a trace semantics for protectedA+Icode.L::=a∣τ,a::=g?∣g!,g::=callp(v¯)∣retvA label L can be an observable action a or a non-observable action τ. Decorations ? and!indicate the direction of the observable action: from unprotected to protected code (?) or vice versa(!). Address p is an address in memory,v¯is a list of the contents of all registers in a call and v indicates the contents of registerr0in a return. Calls and returns executed by unprotected code are named calls and returnbacks, dually, if they are executed by protected code they are named callbacks and returns[10,16].This paper aims at providing a fully abstract trace semantics, thus implying that the trace semantics is the most precise. Informally, a trace semantics is fully abstract when its labels capture all that is being communicated between the protected and the unprotected code but no more. A trace semantics following the discussion above would not be fully abstract due to a number of subtleties, as highlighted in Example 5.Example 5Limitation of the aforementioned trace semanticsConsider the two protectedA+Iprograms below, call the left one PLand the right one PR. When presenting snippets side by side, differences are highlighted in a blue font.Both PLand PRassign the result ofr0−r1tor0(line 1). If the result of the operation is not less than 0 (line 3), they respectively write the contents ofr4andr5to the unprotected address 10 (lines 4 and 5) and call the function whose address is stored inr2(line 6). Otherwise, they assign different values tor11(line 7) and return 0 (lines 8 and 9).With the trace semantics hinted at after Example 4, the behaviours of PLand PRcoincide, as they generate the same traces. However, PLand PRcan be distinguished by an external observer, and the traces they generate should reflect this. Consider tracea1¯, which is generated by both PLand PR(omitted details are indicated using …).a1¯=call100(1,2,…)?·ret0!a1¯does not capture the different values contained inr11(line 7), which, even if they are not the returned values of the function, still constitutes an observable difference between PLand PR.Tracea2¯is also generated by both PLand PR.a2¯=call100(2,1,40,…)?·call40(…)!a2¯does not capture the different value written at address 10 (line 5), which also constitutes an observable difference between PLand PR.Sincea1¯anda2¯do not capture the observable differences between PLand PR, the trace semantics fails to be fully abstract.Let us now consider writing and reading to unprotected memory.Protected code writing a value into the unprotected memory partition is called a writeout. Since such values can be observed by unprotected code, writeouts need to be captured in traces. This is done with a writeout label of the following form:write(a,v)stating what was written (v) and where (a). Following are the subtleties that need to be considered when introducing writeouts into the trace semantics (Examples 6– 9). In the first case the problem is that the write is not observable, while in the second case the problem is the ordering of writeout labels. In the remaining cases the problem is that control is not returned to the external code, which means that it will not be able to detect the difference introduced by the writeout.Example 6Invisible writeoutsThe following PLand PRread a value from an unprotected address 10 and 20, respectively (line 2), and then rewrite the same value back to the same address (line 3).The writeouts of PLand PRare invisible. In fact, they do not alter the contents of unprotected memory, since address 10 (20, resp.) already contains the written value. Thus, PLand PRare contextually equivalent. However, they are not trace equivalent, since the following is a trace of PLand not of PR:call100(⋯)?·read(10,0)write(10,0)ret0!Notice that if the readout were absent, the writeout would distinguish between PLand PR, as there are unprotected memories whose existing value at address 10 (20, resp.) differs from what is written by PLor PR.To address this concern, the readout information must be accumulated and used to detect when a writeout is not introducing an observable difference in unprotected memory.The following PLand PRwrite 0 to addresses 10 and 20 in unprotected memory (lines 4 and 5). The only difference between the two is that PLwrites to address 10 then to address 20 while PRdoes the same writes in the opposite order.These programs are contextually equivalent, but if their labels are generated by the orders of the instructions, they will have different labels, since the following will be a trace of PLand not of PR.call100(⋯)?·write(10,0)write(20,0)ret0!To address this concern, writeouts need to be sorted when they are added to a trace. A more precise discussion over this solution is delayed until Example 15 since the solution is affected by the solutions of other.The following PLand PRwrite 0 and 1 respectively to address 10 in unprotected memory (line 3) and then terminate (line 4).The only difference between PLand PRis the value written at address 10. However, the unprotected code cannot detect this difference since execution is halted before control is returned to it. Thus, PLand PRare contextually equivalent. If the writeout would appear in the traces, PLand PRwould be trace-inequivalent, since the trace below would belong to PLand not to PR.call100(⋯)?·write(10,0)√Consequently, writeouts do not appear if the protected program halts afterwards.The following PLand PRsetr0to 20 and 10 respectively (line 1), then write the instructionjmpr0at addresses 20 and 10 respectively (line 2). Finally, they jump to the instruction they just wrote (line 3).Whenr0is set to 20 (resp. 10), the instructionjmpr0written at address 20 (resp. 10) will diverge when called. Thus, PLand PRare contextually equivalent, since no context can differentiate between them. However, PLand PRare trace inequivalent, since the following is a trace of PLand not of PR, since a trace of PRwould contain awrite(10,“jmpr0”)call10(10,⋯)!label.call100(⋯)?·write(20,“jmpr0”)call20(20,⋯)!The solution to this concern is to split the unprotected memory in a code and a data section and to allow writeouts only to the unprotected data section. A more complete analysis of the solution is delayed until Example 16.A readout occurs when protected code reads unprotected memory. Not all PMA implementations allow readouts, they are forbidden in some implementations [3] and discouraged by others [4,6]. When protected code can perform readouts, devising a fully abstract trace semantics is challenging. The readout labelread(a,v)states that a value v was read from address a. It is not obvious to decide when such a label should appear and the following examples present when the readout label should appear in traces or not (Examples 10–16).Example 10Unobservable readoutsConsider the two protectedA+Iprograms below.PLand PRread the contents of unprotected addresses 10 and 20, respectively, and store the result in registerr1(line 2), then they set registersr0andr1to 0 (lines 3 and 4) and return (line 5). In this case, the value read does not influence the behaviour of PLor PR, which behave the same, so the readout should not appear in their traces.Consider the two protectedA+Iprograms below:Here, PLreads the contents of address 10 intor0(line 2), performs computations untilr0contains a constant value k (omitted lines), independent of the value read, and then returns (line 5). PRsimply initialisesr0to k (line 2) and returns (line 3).These programs are contextually equivalent, both always return k, however, PLalso performs a readout. If this readout appears in traces, it would be a failure of full abstraction, since the traces of PRdo not have such a label. The problem here is that the omitted code of PLalways reduces the contents ofr0to a constant, no matter what values it contained beforehand. The trace semantics must be able to identify that the value read does not affect the execution of the program and thus not include the read label in this case.Consider the two protectedA+Iprograms below.In this case PLand PRread the contents of unprotected addresses 10 and 20, respectively, in registerr1(line 2). Then, if those values are less than 0 (lines 3 and 4) they jump to address 108 (lines 5 and 6) and return (line 9), otherwise they call to a function at address 30 (lines 7 and 8).The value read in unprotected memory constitutes an observable difference between PLand PR, as it alters the execution flow. Thus, the readout value should itself be present in the trace.The problem in this case is detecting when does a read affect the behaviour of a program. A read affects the behaviour of a program if some future behaviour of the program depends on the value read; when different values are read, the behaviour of the programs varies. On the other hand, if a read does not affect the behaviour, any value can be read and the program behaves the same. By viewing readout values as inputs, in the former case we can say that different inputs make a program have different behaviours (as in Example 12, while in the latter case different inputs do not vary the behaviour of a program (as in Examples 10 and 11).The concept described above is analogous to non-interference[17,18]. Non-interference is a property of systems whose input can be classified to be either low or high security (for non-sensible and classified material respectively). A system is non-interfering if for a given set of low inputs it will produce the same low outputs, regardless of what the high level inputs are.In this setting, if we treat readouts as high inputs and future traces as low outputs, we can apply non-interference notions to detect whether a readout affects a program. A readout does not affect a program if it is non-interfering, i.e. for any readout value (high input) the future traces (low output) do not vary. The trace semantics can use the non-interference information to decide whether a readout label should appear on traces or not. In Examples 10 and 11, the readouts are non-interfering, whatever value is read, the behaviour of the program does not vary, thus the trace semantics can exclude these readouts from traces. However, in Example 12 if the value read is 0, the program will behave differently than if it is not 0, so the readout is interfering. Here the trace semantics can tell that the readout must be included in the trace.The main difference between the way non-interference is used in the literature and in this work is in the treatment of readout values. These values are in the external memory, thus intuitively low security, and they should be kept immutable. However, in order to apply non-interference correctly, they have to vary, thus they are regarded as high security.Example 13Unobservable readouts after writeoutThe following PLand PRwrite 0 to address 10 (line 3), then PRreads from address 10 (line 4).These programs are thus contextually equivalent, but the following is a trace of PRand not of PL.call100(⋯)?·write(10,0)read(10,0)ret0!To address this concern, reads to an address that was the subject of a writeout should not appear on traces. In fact, the readout value cannot be different from the writeout one, and that information is already known to protected programs.The following PLand PRread from address 10 in unprotected memory (line 2).The only difference between the two is that PRreads from address 10 twice, but this does not affect its behaviour, since the same value is read. Thus, these programs are contextually equivalent, but the following is a trace of PLand not of PR.call100(⋯)?·read(10,v)ret0!To address this concern, multiple readouts to the same address should thus be filtered, only one must be present in the traces.In the following, PLreads the contents of unprotected address 10 into registerr1(line 2), then it reads the contents of unprotected address 20 into registerr2(line 4). Finally, it calls to a function located at address 20 (line 5, the value of registerr0). PRdoes the same, but first its reads happen in the reversed order: first it reads address 20 into registerr2(line 2), then address 10 into registerr1(line 2).These programs are contextually equivalent, but the traces they create are different. The order in which the readouts are executed and accumulated on the traces makes it so that the following trace is generated by PLand not by PR.call(⋯)?·read(10,v)read(20,v′)call20(20,v,v′,10,⋯)!To address this and the concern of Example 7, readouts and writeouts can be sorted based on the address to which the operation is performed.This introduces a sort of normal form for traces, which consist of a sorted prefix of readouts and writeouts followed by a call or a return. The normal form effectively merges the solutions to Examples 13 and 14.In the following, PLalways halts while PRreads the contents of address 10 intor1(lines 1, 2). If the value read is not an instruction (line 3, omitted for the sake of simplicity), PRjumps there (line 4), otherwise it halts (line 6).These two programs are contextually equivalent: they always terminate. However, PRgenerates the following trace, which PLdoes not:call(⋯)?·read(10,v)call10(10,v,⋯)!The problem is that the trace above will always be followed by termination (in unprotected code), which unprotected code cannot observe. This is due to PRreading executable unprotected code and PRbehaving differently based on the value read.To address this concern and Example 9, unprotected code is split in a code and a data section, just as protected code is. Writeouts and readouts can only be performed on the data section of unprotected code, so protected code cannot read nor write executable unprotected code.From the threat modeling perspective, this assumption somewhat reduces the attacker׳s power, since she is not able to execute the values written by the protected code. However, this assumption seems reasonable, since most times we are interested in modelling the behaviour of code that uses readouts for parameters and not to execute readout values. Future work will consider writeouts and readouts of executable unprotected code.As Curien stated [19], two ways to achieve full abstraction for a trace semantics exist. The first is to change the operational semantics to restrict what is communicated to what is captured by the labels. This is achieved by restricting the ways in which communication is performed, e.g. by preventing readouts and writeouts. The second is to modify the labels so that they capture more precisely what is communicated between protected and unprotected codes. In this case, labels should capture the values of all registers and flags as well as what protected code reads and writes in unprotected memory. Both approaches are presented in Section 4. These are based on theA+Iassembly language and its operational semantics, which are given in Section 3.This section formalises the syntax (Section 3.1) and operational semantics (Section 3.2) ofA+I, a PMA-enhanced assembly language, and concludes with the definition of contextual equivalence forA+Iprograms (Section 3.3).A+Iprograms run on an architecture that models a von Neumann machine consisting of a program counter p, a register file r, a flags register f and memory space m. The program counter indicates the address of the instruction that is executed next. The register file contains 12 general purpose registersr0tor11and a stack pointer registerSP, which contains the address of the top of the current call stack. The flags register contains a zero flagZFand a sign flagSF, which are set or cleared by arithmetic instructions and are used by branching instructions, respectively.Fig. 2presents elements of the formalisation. Addresses a are natural numbers. Words are natural numbers plus −1, which serves as a value that is not in the address range in order to stop computation (As described in Definition 2 below). Memories m are infinite maps from addresses to words. Memory access, denoted as m(a), is defined as follows:m(a)=wifa↦w∈m; it is undefined otherwise. Define the domain of a memory asdom(m)={a|a↦w∈m}. If two memories m andm′have disjoint domains, they can be merged into another memory. Formally, ifdom(m)∩dom(m′)=∅, thenm+m′={a↦w|a↦w∈mora↦w∈m′}. Memory descriptors s are sextuples:(ab,nc,nd,n,auc,aud)that formalise the concepts of Section 2.1. abis the address where the protected memory partition starts, ncand ndare the sizes (in number of addresses) of the code and data section respectively and n is the number of entry points. Additionally, aucstates where the code section of the unprotected code starts and audstates where the data section of the unprotected code starts (and where the unprotected code section ends). This partitioning of unprotected code is not required by PMA architectures but it helps devising a fully abstract trace semantics, as explained previously. Entry points are allocated starting from the base address ab. Each entry point isNewords long. Assume that the entry points do not overflow the protected code section, thus the constraintn·Ne<ncholds for the all memory descriptors. Programs P are pairs of a memory m and amemory descriptor s. Instructions i are elements of the setIand define the programming language executed on the architecture (Fig. 3).Before introducing the semantics, a number of auxiliary notions are defined.Fig. 4defines the access control enforcement rules informally presented in Section 2.1. Read judgmentss⊢predicate(a,b,⋯)as “according to memory descriptor s,predicateholds for addresses a, b,⋯”.Define functionsmsec(m,s)andmext(m,s), which return the protected and unprotected parts of a memory m according to descriptor s, respectively asmsec(m,s)={a↦w|a↦w∈m,s⊢protected(a)}mext(m,s)={a↦w|a↦w∈m,s⊢unprotected(a)}In the semantics there are two call stacks, one for the protected code, called the secure stack, and one for the unprotected code, called the insecure stack. Each stack is preceded by a word containing the location of the current top of the stack:SPsecandSPextare memory locations that indicate the top of the secure and insecure stack respectively. Given a memory descriptors=(ab,nc,nd,n,auc,aud), the secure stack starts at the beginning of the protected data section and the insecure stack starts at beginning of the unprotected data section, the stack grows up. ThusSPsec=(ab+nc)and, initially,SPsec↦(ab+nc+1); analogously,SPext=(aud)and, initially,SPext↦(aud+1). Call and return instructions see theSPregister being set to the correct address when crossing boundaries between protected and unprotected memory by usingSPsecandSPext. The value of the program counter is pushed onto the stack by acallinstruction, while aretinstruction pops one address from the top of the stack and jumps to that location. Updating the stack pointerSPis performed using the auxiliary function↘SS(Fig. 5).In the rules, notationm[a↦w]indicates that memory m is updated to a new one that is equal to m except that the value stored at address a is w. Notationr[r↦w]indicates that the register file r is updated to a new one that is equal to r except that the value stored in registerris w. Notationr(r)indicates the value contained in registerrin register file r. Given a jump between addresses p andp′, the stack switch rules produce a new register filer′and a new memorym′based on old ones r and m. The memory is updated to store the top of the current stack, located inSP, in the address storing the top of the current stack. When the stack is changed, the register file is updated to initialiseSPto the top of the right stack: the address stored atSPsecorSPext.The operational semantics is a small step semantics that describes how each instruction of the language transforms an execution state into a new one. The operational semantics describes programs in the whole memory: both the protected and unprotected partitions.Definition 1Execution stateAn execution state, denoted as Ω, is a quintupleΩ=(p,r,f,m,s), where p is a program counter, r is a register file, f is a flags register, m is a memory and s is a memory descriptor.Given execution stateΩ=(p,r,f,m,s), let⌊Ω⌋be the state(p,r,f,msec(m,s),s)and⌈Ω⌉be the state(p,r,f,mext(m,s),s). Relations→iand→edescribe the evaluation of instructions that only affect the protected and unprotected parts of memory respectively. These relations build up to the complete operational semantics. Rules for→ecan be obtained from the rules for→i(Figs. 6 and 7) by replacing allintJumpassumptions with anextJumpone and are thus omitted. Letm(p)=instdenote thatinstis the word allocated in m(p), whereinst∈I. When an access control violation is detected, or when the secure stack is overflowed, all registers and flags are reset and the execution is halted. Note that the program counter is set to −1 whenever thehaltinstruction is encountered, in order to capture termination. This way, no progress can be made, asm(−1)does not return a valid instruction: the program is in a stuck state.Definition 2Stuck stateA stateΩ=(p,r,f,m,s)is stuck, denoted asΩ⊥, when the program counter does not point to a valid instruction:m(p)∉I.The operational semantics ofA+Iis a binary relation over states→⊆Ω×Ω(Figs. 8 and 9). Rule Eval-callback and Eval-returnback ensure that the address to be followed after a callback is stored in the secure stack and that the address of the returnback entry point is pushed onto the insecure stack. Thus the unprotected code always jumps to the returnback entry point when returning from a callback. Code located at the returnback entry point must contain aretinstruction in order to correctly resume the execution.The reflexive, transitive closure of relation→is indicated with→⁎. A state Ω performing n reduction steps is indicated asΩ→nΩ′. The evaluation of program P is a sequence of steps that takes the initial state of P to another state.Definition 3Initial stateThe initial state of a program (m,s), denoted asΩ0(m,s), is a state(p0,r0,f0,m,s), wheres=(ab,nc,nd,n),p0=(ab+nc+nd+2),r0=[SP↦m(SPext);ri↦0i=0‥11], andf0=[ZF↦0;SF↦0].The evaluation of P terminates if∃Ω′.Ω0(P)→⁎Ω′andΩ′⊥; the result of the computation is stored inr0. If the evaluation of program P does not terminate, P diverges, i.e. it executes an unbounded number of reduction steps, this is denoted asP⇑. Formally:P⇑if∀n∈N,∃Ω′.Ω0(P)→nΩ′.Contextual equivalence relates two programs that cannot be distinguished by any third program interacting with them [20]. This notion relies on the concept of contexts, which is introduced before presenting the equivalence itself.Since our focus is onA+Iprograms P that are placed in protected memory and interact with arbitrary unprotected code, contexts model that unprotected code. Thus for any descriptor s, contextsMare partial memories with a hole:M=m[·], where all addresses ofMare unprotected. Formally, given s,∀a∈dom(M),s⊢unprotected(a). The hole models the possibility to combine a program P with the memoryMiff they are compatible, denoted asP⌢M, thus if the memories of P andMhave disjoint domains. Letdom(M)=dom(m)ifM=m[·]; formally,P⌢MifP=(m′,s)anddom(m′)∩dom(M)=∅. If P andMare compatible, the hole ofMcan be filled with P in order to model interaction between P andM. Formally, ifP⌢MthenM[(m′,s)]=(m′+m,s).Programs P1 and P2 are contextually equivalent, denoted asP1≃P2, when, for all contexts they interact with, P1 diverges if and only if P2 also diverges.Definition 4Contextual equivalenceP1≃P2if∀M.P1⌢M∧M[P1]⇑⟺P2⌢M∧M[P2]⇑.An implication of this definition is that for P1 and P2 to be contextually equivalent they must have the same memory descriptor. For the sake of simplicity, always assume the compatibility of a protected program and the context it is plugged in, shortening the above definition to:P1≃P2if∀M.M[P1]⇑⟺M[P2]⇑.Example 17Contextually equivalent programsThe following programs PLand PRwrite the values ofr1andr2respectively to the protected address 150 (line 2) and then return 0 (line 3). Recall that the protected memory partition spans from address 100 to 200, with one entry point at address 100.The only difference between PLand PRis in the value stored at address 150. However, an unprotected program cannot read that value. Since that value does not affect the computation of PLor PRor the unprotected code, PLand PRare contextually equivalent.Having defined the assembly language and its operational semantics, the paper introduces the two different trace semantics. Trace equivalence is also introduced, it will be proven the same as contextual equivalence in Section 5, thereby establishing full abstraction of the trace semantics.This section gives two different trace semantics for protectedA+Iprograms. The differences between these semantics stem out of the different ways to achieve full abstraction pointed out by Curien [19]. The first trace semantics,TrS, relies on changes to the semantics of protected programs (Section 4.1), while the second one,TrL, possesses more expressive labels (Section 4.2). Both are proven to be fully abstract w.r.t. the appropriate operational semantics in Section 5. Finally, this section defines when two programs are trace equivalent (Section 4.3).As for the operational semantics, a notion of execution states is required for the trace semantics as well. Execution states forTrS, denoted as Θ, are the same as Ω except that Θ does not deal with the whole memory, just with its protected partition. So, the memory m of(p,r,f,m,s)spans only the protected memory partition indicated by memory descriptor s. Additionally, Θ can be(unk,m,s), an unknown state that models when code is executing in unprotected memory [16].Definition 5Initial state for tracesThe initial state for traces of a program (m,s), denoted asΘ0(m,s), is the state(unk,m,s).The semantics of protected programs is changed as follows (Fig. 10):•when the program counter jumps between the protected and the unprotected memory partitions, or vice versa, flags are set to 0 (Rule Stack-out-to-in׳ and Stack-in-to-out׳);in case of areturn, all registers butr0are also set to 0 (Rule Eval-return׳);readouts and writeouts are prohibited (Rule Aux-write-1׳ and Aux-read-2׳ replace the access control rules with the homonymous name).Following are the labels ofTrS, they include those presented in Section 2.2. Observable actions include a tick√indicating that the evaluation has terminated. Flags do not appear in traces because they are always set to 0, as are all registers butr0in case of a return. Readouts and writeouts are prohibited, so there are no labels that capture them.LabelsL::=a∣τiObservableactionsa::=√∣g?∣g!Actionsg::=callp(r)∣retpr(r0)The relation↠defines how labels are generated (Fig. 11). Internal instructions, generated by a→itransition, do not produce a visible label (Rule Trace-s-internal). If a state is stuck, then the label for termination is produced (Rule Trace-s-termination). A call to an entry point generates a call label (Rule Trace-s-call) while a return to the returnback entry point generates a returnback label (Rule Trace-s-returnback). Calling to an unprotected address generates a callback label (Rule Trace-s-callback), while returning to any unprotected address generates a return label (Rule Trace-s-return).The reflexive and transitive closure of↠, denoted with, is responsible for the accumulation of labels into traces (Fig. 12).TheTrStraces of a program P are defined as follows:TrS(P)={a¯|∃Θ.Θ0(P)Θ}This section presentsTrL, a trace semantics that changes the labels of Section 2.2 to include all possible observable behaviour, including readouts and writeouts. The semantics used here is the one presented in Section 3.The states of theTrLsemantics are indicated with Θ, they do not change from the definition given for theTrSsemantics. The syntax of labels, however, changes as indicated below, including a readout and a writeout label.Labelsλ::=τ∣αObservableactionsα::=γ?∣δ!∣√Actionsγ::=callp(r;f)∣retp(r;f)Prefixableactionsδ::=γ∣ω(a,v).δPrefixesω::=read∣writeTo ensure that the issues of Examples 6 and 7 and Examples 13– 15 (Sections 2.2.1 and 2.2.2) do not arise,δ!labels are converted to a normal form.The normal form ofδ!labels is achieved by applying the rewrite rules presented in Fig. 13. Rules (Constriant-write) to (Constriant-read) ensure that labels created by the semantics are consistent [21]. Rules (Write-order), (Read-order), (WR-order) and (RW-order) ensure that the prefix of reads and writes is sorted based on the address field. If two actions are performed at the same address, their order is the same as the order in which the program performed those actions. Rules (Write-no-read) to (Read-no-write) ensure that reading the same writeout value (resp. writing the same readout value) does not appear in labels. Rules (Write-drop) to (Read-drop) eliminate multiple writeouts and readouts to the same address.The rewrite rules of Fig. 13 are convergent so their application always returns a unique result (Theorem 3 in Appendix A). We can thus define the normal-form functionnorm(·)as the application of those rewrite rules. This function inputs a δ label and returns it in normal form, i.e. a sequence ofwrite(a,v)andread(a,v)label sorted on the address parameter a.The rules that define the single label relation↠⊆Θ×λ×Θ(Fig. 14) rely on the semantics presented in Section 3.2. Rules for generatingcall,returnand τ labels resemble the rules for theTrSsemantics. Rule Trace-tau-compression ensures that τ labels are not accumulated, so readout and writeout labels are not spaced out with τs. For writeouts, Rule Trace-writeout ensures that writeout labels are always created, dually, for readouts, Rule Trace-readout ensures that readout labels are always created when reading unprotected data. Rule Trace-writeout-termination addresses Example 8, so no writeout label is created when a program terminates.The reflexive transitive closure of the↠relation is captured by relation⊆Θ×α¯×Θ(Fig. 15). The only difference with the way this is performed with regard toTrS(Fig. 12) is that when a label is produced inTrL, it is converted to a normal form via thenorm(·)function and stripped of its non-interfering reads via theStripNI(·)function (Fig. 16defined below).The trace semantics of a state is defined as follows:Tr-state(Θ)={α¯|∃Θ′.ΘΘ′}Thus, theTrLtraces of a program P are defined as the traces of its initial state:TrL(P)=Tr-state(Θ0(P))The greatest concern when adding readouts is detecting whether a readout is non-interfering, as explained in Examples 10– 12. In fact, non-interfering readouts must not have a corresponding label in traces. To understand whether a readout to a certain address is non-interfering, we rely on judgmentNI(Θ,a). That judgment tells whether an address a is non-interfering for a state Θ if Θ performs a readout to a that does not affect future traces but for the read value. Formally:NI(Θ,a)≜∀v,w.ΘΘ′andΘΘ″andα1=ω(a′,v′)¯read(a,v)δ!andα2=ω(a′,v′)¯read(a,w)δ!andTr-state(Θ′)=Tr-state(Θ″)TheNI(·)definition relies on the formalisation ofTr-state(Θ)which returns the set of traces that can be generated from Θ; it is formalised below.Tr-state(·)is used to access the behaviour of the program after either value is read from address a, no difference can be found there for the readout to be non-interfering. It is not sufficient to check the single immediate action δ following the readout, as the readout value could be stored in memory and be used only for successive computations. The prefixω(a′,v′)¯makes it possible to identify a readout that happens at any point during the first action.Note that the definition ofTr-state(·)and that ofNI(·)are mutually recursive. However, they are still well-founded sinceTr-state(·)usesNI(·)when filtering a labelδ!generated asΘΘ′and thenNI(·)relies onTr-state(·)on the traces generated fromΘ′onwards.With this information, define a functionStripNI(Θ,α)that returnsα′which is α stripped of its non-interfering reads, provided that α is generated from Θ (Fig. 16). Since this function preserves the ordering of the labels in α, when applied to labels in normal form it still produces labels in normal form.The notion of trace equivalence is presented generically for both trace semantics under consideration. UseTr(P)to indicate the traces of anA+Iprogram P, be it expressed throughTrSorTrL. Two programs P1 and P2 are trace-equivalent, denoted asP1≃TP2, if their traces are the same and they have the same memory descriptor.Definition 6Trace equivalenceP1≃TP2ifTr(P1)=Tr(P2)andP1=(m1,s)andP2=(m2,s).Following are two examples of trace equivalent and inequivalent programs. For the sake of simplicity, we use theTrLsemantics and indicate arbitrary values for registers and flags with notation (r,f) and an unprotected address with p.Example 18Traces of previous examplesThe code of Example 5 is not trace equivalent; the following trace is generated by PLbut not by PR:call100(r;f)?·retp(…,41;f)!·√!The code of Example 12 is not trace equivalent; the following trace is generated by PLbut not by PR:call100(r;f)?·read(10,v)call30(30,…;f)!The code of Example 17 is trace equivalent since the trace semantics of both PLand PRis a set whose sequences are concatenations of the following trace, each element of the sequence having possibly different values of r and f:call100(r;f)?·retp(r[r0↦0];f)!This section presents the general proof strategy through which bothTrSandTrLare proven to be fully abstract w.r.t. the corresponding operational semantics.A fully abstract trace semantics is both sound and complete with respect to the operational semantics. Soundness means that the trace semantics captures all behaviours expressible with the operational semantics. Thus, for all contexts, two trace equivalent programs cannot be told apart. Completeness means that the trace semantics does not capture additional behaviours that are not expressible with the operational semantics. Thus, for all trace-inequivalent programs, there exists a context that can differentiate them.Full abstraction of trace semantics is formally stated asP1≃TP2⟺P1≃P2; its proof is split into two cases, one for each direction of the co-implication.Call the interface of a state its registers, flags and unprotected memory. Two states Ω1 and Ω2 have the same interface, denoted asΩ1≗Ω2, if they have the same registers, flags and unprotected memory. Formally,Ω1≗Ω2ifΩ1=(p1,r,f,m1,s1)andΩ2=(p2,r,f,m2,s2)andmext(m1,s1)=mext(m2,s2). GivenΩ=(p,r,f,m,s), define∥Ω∥to be the stateΘ=(p,r,f,msec(m,s),s)ifs⊢protected(p)and(unk,m,s)otherwise.The proof of soundness (Theorem 1 below) states that an unprotected program interacting with P1 cannot distinguish it from P2. The proof strategy relies on both programs offering the same interface to the unprotected program. This proof depends on an interface-preservation lemma (Lemma 1) which must be proven for each trace semantics since it depends on the labels of each trace semantics. Lemma 1 says that two states with the same interface still have the same interface after they perform the same observable action. Thus unprotected programs do not see differences, in terms of flags, registers and unprotected memory, between P1 and P2.The proofs of Lemma 1 and of Theorems 1 and 2 can be found in Appendices B–D.Lemma 1Interface preservation after same observable actionIf Θ1↠αΘ1′andΘ1=∥Ω1∥andΩ1→⁎Ω1′andΘ1′=∥Ω1′∥andΘ2↠αΘ2′andΘ2=∥Ω2∥andΩ2→⁎Ω2′andΘ2′=∥Ω2′∥andΩ1≗Ω2thenΩ1′≗Ω2′(assuming there is no overflow of the secure stack).P1≃TP2⇒P1≃P2(assuming there is no overflow of the secure stack).P1≃P2⇒P1≃TP2(assuming there is no overflow of the secure stack).This general proof strategy is presented for both Theorems 1 and 2. The generalised approach is tailored to each semantics only in the relatively simple proof of Lemma 1. Since Theorems 1 and 2 hold for bothTrLandTrS, both semantics are fully abstract w.r.t. the corresponding operational semantics.

@&#CONCLUSIONS@&#
