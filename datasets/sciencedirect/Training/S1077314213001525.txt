@&#MAIN-TITLE@&#
Manifold surface reconstruction of an environment from sparse Structure-from-Motion data

@&#HIGHLIGHTS@&#
The surface is directly estimated from the sparse Structure-from-Motion data.Both visibility and manifold constraints are enforced.We experiment with hand-held and helmet-held low cost omnidirectional cameras.Compact models of complete environments are obtained with low time complexity.

@&#KEYPHRASES@&#
2-Manifold reconstruction,3D Delaunay triangulation,Steiner vertices,Complexity analysis,Sparse point cloud,Structure-from-Motion,

@&#ABSTRACT@&#
The majority of methods for the automatic surface reconstruction of an environment from an image sequence have two steps: Structure-from-Motion and dense stereo. From the computational standpoint, it would be interesting to avoid dense stereo and to generate a surface directly from the sparse cloud of 3D points and their visibility information provided by Structure-from-Motion. The previous attempts to solve this problem are currently very limited: the surface is non-manifold or has zero genus, the experiments are done on small scenes or objects using a few dozens of images. Our solution does not have these limitations. Furthermore, we experiment with hand-held or helmet-held catadioptric cameras moving in a city and generate 3D models such that the camera trajectory can be longer than one kilometer.

@&#INTRODUCTION@&#
The topic of the paper is the reconstruction of a manifold surface using a sparse method. The definition and the importance of the manifold property are detailed in Section 1.1. Section 1.2 explains the motivations for a sparse method, i.e. a method which reconstructs a surface directly from the sparse point cloud estimated by Structure-from-Motion (SfM). Section 1.3 compares our work to the previous sparse methods and Section 1.4 summarizes our contributions.Remember that SfM is a necessary and preliminary step which estimates the successive poses and (sometimes) intrinsic parameters of the camera from an image sequence. The sparsity comes from the fact that the SfM calculations are done for interest points, which have uneven distributions and low densities in the images (about 1 pixel over 200–300 is reconstructed in our experiments using Harris points [15]).The sparse methods contrast with the predominant dense methods. There are two main cases of dense methods which estimate a manifold:1.A surface evolves in 3D such that it minimizes a photo-consistency cost function for all image pixels [11,17,18,31].A surface reconstruction method [41,6,21] is applied on a dense point cloud obtained by a dense stereo method [12,22].Combinations of both cases are possible (e.g.[23]) and an exhaustive list of references for dense methods is outside the paper scope. By contrast to the dense methods, the sparse methods are less popular and are a minority [10,19,27,29,32,36,38] in the bibliography.In a 2-manifold, i.e. a 2D topological manifold surface, every point of the surface has a surface neighborhood which is homeomorphic to a disk [5]. In short, a 2-manifold is parametrized by two real parameters. In the discrete case, a 2-manifold is usually defined by a list of triangles such that every triangle is exactly connected by its three edges to three other triangles.The manifold property is required to enforce smoothness constraints on the computed surface. Indeed, the continuous differential operators of normal and curvature are extended to the discrete case thanks to this property [28,5], and then we can use them to enforce smoothness constraints on the triangle list as in dense stereo [17]. More generally, a lot of Computer Graphic algorithms are not applicable if the triangle list is not a 2-manifold [5]. In our work, the manifold property is used to constrain a surface interpolating the sparse SfM point cloud and to improve surface denoising.There are several reasons to estimate a surface directly from the sparse SfM cloud. First, it would be ideal for both time and space complexities. This is interesting for obtaining compact models of large and complete environments like cities or for an implementation in a small embedded hardware. Second, it could be used for navigation pre-visualization [8], for initialization of dense stereo methods (e.g.[17,18]), or for autonomous navigation [7]. Last, the accuracy of a point in SfM cloud is expected to be better than that of a point in a dense stereo cloud, thanks to the SfM machinery [16] involving interest point detection and bundle adjustment.Methods [10,19,27,29,32,36,38] using our input (sparse SfM data) start by establishing potential adjacency relationships between the input points, which are selected latter to build a surface. These methods can be classified by examining the data structures encoding the potential adjacencies: [10,32,27,38] use one 3D Delaunay triangulation (Section 1.3.2) and [29,36,19] use 2D Delaunay triangulations (Section 1.3.3). The SfM data also includes visibility constraints, i.e. line segments (rays) which should not intersect the target surface, except at a segment end. A ray links a point to one of the view points used by SfM to reconstruct the point.The sculpting method in [4] is closely related to our method, although it does not use rays. It partitionsR3into tetrahedra of the 3D Delaunay triangulation of the input points. The tetrahedra are labeled as inside or outside, and the surface is the list of triangles which bound the inside region (according to [2] and Fig. 1, a “good” surface can be obtained by such a segmentation). Every tetrahedron is initialized inside; the remainder ofR3is outside. Then an inside tetrahedron is selected by a geometric criterion and becomes outside while the resulting surface is manifold and every Delaunay vertex is in an inside tetrahedron. This method requires that the input point cloud is denser that ours and does not contain bad points.Methods [10,22,32,27,38,39] use rays to label the tetrahedra of the 3D Delaunay triangulation: a tetrahedron is freespace if it is intersected by ray(s), otherwise it is matter.In contrast to our method, [22,32] do not enforce manifold constraint and [27] directly consider the surface as the list of triangles separating the freespace and matter tetrahedra. Then, the resulting surface can be non-manifold. For example, the surface has a singularity at vertex v if all tetrahedra which have vertex v are matter, except two freespace tetrahedra Δ1 and Δ2 such that the intersection of Δ1 and Δ2 is exactly v (left of Fig. 2). Another singularity example is obtained if we replace “vertex v” by “edge e” in the previous example (right of Fig. 2). A post-processing [13] can be applied to obtain a 2-manifold by removing the singularities, but such an approach does not enforce the manifold constraint during the surface calculation and generates new vertices for every singular vertex.Only [10] and our previous work [38,39] provide a 2-manifold. In [10], a region growing procedure in the matter tetrahedra removes all surface singularities and reconstructs very simple scenes. In [38,39], the region growing is in the freespace tetrahedra and deals with more complex topologies than those in [10,4]: the estimated surface can be a torus with several handles. Our region growing is essentially a best first approach based on the number of ray intersections per tetrahedron ([10] does not use this information). In [39], artifacts called “spurious handles” and generated by [38] are removed while maintaining the manifold property. Here the largest handles are removed thanks to the tetrahedron labels (e.g. freespace). The previous removal methods [37,42] remove the smallest handles without these labels.Methods [29,36,19] use 2D Delaunay triangulations in images. In [19], the surface is not 2-manifold and the approach is applied to a small sequence of real images. In [29], the surface is a 2-manifold limited to a simple topology (sphere or plane). In [36], reconstructed edges are inserted in the constrained 2D triangulations, then the back-projected 2.5d triangulations are merged by computing the union of the freespace defined by the 2.5d triangulations. The resulting implicit surface is converted to manifold mesh by the marching cube method [26], which requires a thin-scale regular subdivision of space. However, an irregular space subdivision is better for large scale scene [22]. Compared to these methods, ours estimates a 2-manifold without topology limitation and without thin-scale regular space subdivision.According to Sections 1.3.2 and 1.3.3, our contributions over the other sparse methods are the following: we combine both 2-manifold and visibility constraints without limitation on the surface genus (i.e. the number of handles of the surface), and the experiments are done on larger image sequences of complete environments (hundreds/thousands of images in a few seconds/minutes). Furthermore, this paper is an extended version of our previous work [38,39]. New material includes: highlight of our method with visibility optimization (Section 2), efficient tetrahedron-based manifold test (Section 2), discussion on bad SfM points (Section 3.6), complexity analysis (Sections 5 and 6). Section 3 describes the overall method, then artifacts called “spurious handles” are removed by the methods in Section 4. Also there are new experiments in Section 7 about manifold constraint, varying densities of reconstructed and Steiner points, comparison with the Poisson surface reconstruction [21], larger still and video sequences. Note that we do not focus on the incremental surface reconstruction [40].Our algorithm needs prerequisites on 2-manifolds embedded in a 3D Delaunay triangulation. Here we introduce notations (Section 2.1), our optimization problem (Section 2.2), and the 2-manifold tests (Section 2.3).Let P be a set of reconstructed points. The 3D Delaunay triangulation of P is a list T of tetrahedra which meets the following conditions: the tetrahedra partition the convex hull of P, their vertex set is P, and the circumscribing sphere of every tetrahedron does not contain a vertex in its interior. A vertex/edge/triangle is a face of a tetrahedron in T. Assuming L⊆T, border δL is the list of triangles which are included in exactly one tetrahedron of L. Let F⊆T be the list of freespace tetrahedra, i.e. the tetrahedra intersected by ray(s). The tetrahedra which are not freespace are matter. According to Section 1.3.2, δF can be non-manifold. Here we introduce O⊆F, the list of outside tetrahedra, such that δO is manifold. The tetrahedra which are not outside are inside.We also consider T as a graph: a graph vertex is a tetrahedron, a graph edge is a triangle between two tetrahedra. A standard practice is to introduce infinite vertex v∞ such that we define a virtual tetrahedron connecting δT triangle and v∞[1]. The virtual tetrahedra do not exist in 3D, but they are vertices of the graph. They make easier both implementation and paper clarity since every tetrahedron has exactly four neighbors in the graph.Since P is reconstructed in all directions around the view points to model complete environments, all rays are included in the convex hull of P. Then the virtual tetrahedra are labeled matter. Every matter tetrahedron is inside.Note that δF and δO are closed surfaces; δF cutsR3into free-space (F) and matter, δO cutsR3into outside (O) and inside. Furthermore, O⊆F.In short, the target surface δO is a 2-manifold which should separate the matter and free-space tetrahedra “as much as possible”. Letr:F→R+∗a scalar and positive function. We extend r to O⊆F byr(O)=∑Δ∈Or(Δ). We would like to estimate O included in F and maximizing r(O) subject to the constraint that δO is a 2-manifold. Intuitively (if r=1), a large O in F with a 2-manifold border δO is a good solution. Now we give two remarks.First, this optimization problem is difficult due to the manifold constraint. Then we solve it using a greedy algorithm: we add progressively free-space tetrahedra in O as long as δO remains a 2-manifold, then r(O) increases and the final δO is an approximation of the exact solution of our problem.Second, several definitions of r are possible. Here we optimize visibility by defining r(Δ) as the number of rays which intersect tetrahedron Δ. Since our paper focuses on manifold extraction and related complexity, we do not investigate on more sophisticated definitions of r inspired by [27,32,22,20].Here we explain how to check that a surface S (a list of triangles of T) is a 2-manifold. This topic is somewhat technical but very important in practice for the computation time of our method.Let v be a point in S. We say that v is regular if it has a neighborhood in S which is topologically a disk. Otherwise v is singular. By definition (Section 1.1), S is 2-manifold if all its points are regular. In our context where S is a list of triangles of T, we only need to check that every vertex v of S is regular using the following neighborhood of v: the list of the S triangles which have vertex v[4]. Now we describe three 2-manifold tests.Vertex v is regular if and only if [4] the edges opposite to v in the triangles of S having v as vertex form a simple polygon (Fig. 3). A simple polygon is topologically a circle, i.e. a list of segments which forms a closed path without self-intersection. This test was used in our previous work [38,39].The test in Section 2.3.1 is adequate if the surface S is implemented as an adjacency graph of triangles. This is not the case here since S is embedded in a Delaunay T implemented as an adjacency graph of tetrahedra.So we introduce a faster test to check that v is regular. Let gvbe the graph of the tetrahedra incident to v (gvis a sub-graph of T). Section A shows that the v-opposite edges above form a simple polygon if and only if the inside tetrahedra of gvare connected and the outside tetrahedra of gvare connected (Fig. 4). Thus we check that v is regular thanks to a simple traversal of graph gvwhere the edges between inside and outside are removed.Now we explain how to use the 2-manifold tests in Sections 2.3.1 and 2.3.2. In our context, S=δO is estimated by a greedy method (Section 2.2). Assume that δO is a 2-manifold. We add A⊆F into O. Then we should check that (the new) δO is still a 2-manifold. We collect in list W all vertices of the tetrahedra in A which are in δO. The new δO is a 2-manifold if every vertex in W is regular. Otherwise, it is not and A is removed from O. The vertices of δO which are not in W do not need to be checked since the labels outside-inside of their incident tetrahedra do not change by adding A.In the special case where list A contains a single tetrahedron Δ, there is a test based on [4], which is faster than those in Section 2.3.3. In this case, we first check a condition on O and then add Δ to O (if the condition is meet). This condition is detailed in Section B. It only requires to read once the lists of tetrahedra incident to the four Δ-vertices.Every sub-section describes a step of our method, except the last one which discusses bad (false positive) SfM points.Assume that SfM estimates the geometry of the whole image sequence. The geometry includes the sparse cloud of points {pi}, camera locations {cj} and rays defined by visibility lists {Vi}. List Viis the list of indices of images which reconstruct the 3D point pi, and a ray is a line segment linking pitocjif j∈Vi. The size of Viis greater than 2 (2 is the theoretical minimum but it is insufficient for robustness).Point pihas poor accuracy if it is reconstructed in degenerate configuration [16]: if piand all cj, j∈Viare nearly collinear. This case occurs in part of the camera trajectory which is a straight line and if points reconstructed from this part are close to the straight line. Thus, the point cloud is filtered as in [9]: piis added in T if and only if there is {j, k}⊆Visuch that anglecjpick^meets∊⩽cjpick^⩽π-∊using threshold ∊>0.We set r=0 and apply ray tracing to all rays. Since T is a graph (Section 2.1), tracing a ray cjpiis a walk in the graph, starting from a tetrahedron incident to pi, moving to another tetrahedron through the triangle intersected by the line segment cjpi, and stopping to the tetrahedron which contains cj(the inverse walk is also possible). Ray cjpiis traced if and only if piis a vertex of T. For every tetrahedron Δ intersected by a ray, r(Δ) is increased by 1. We obtain function r and list F of the free-space tetrahedra.According to Section 2.2, we use a greedy algorithm to approximate the list O which maximizes r(O) such that δO is a 2-manifold and O⊆F: O grows from ∅ by adding free-space tetrahedra such that δO remains 2-manifold. The result of this step is the final δO. We use r to define a priority for the free-space tetrahedra: the Δs with the largest r(Δ) are added in O before others. Due to the manifold constraint, we also require that the selected Δ has (at least) one face in δO to avoid that the greedy algorithm gets stuck too easily in a bad solution.The tetrahedra in the neighborhood of O are stored in a heap (priority queue) for fast selection of the tetrahedron with the greatest r. Thus O usually grows from the most confident free-space tetrahedra (with large r) to the less confident ones (with small r).Algorithm 1 presents our growing method in C style. The inputs are the initial O, list F, list Q0 of tetrahedra which includes the initial value of the heap, and function r. Here we use O=∅ and Q0=∅. The output is O.Algorithm 1Outside Growing01: Q=∅; // ∗∗∗ initialization of priority queue Q ∗∗∗02: if (O==∅) { // Section 3.303: let Δ∈F be such that r(Δ) is maximum;04:Q←Q∪{Δ};05: } else for each Δ∈Q0∩F // Section 3.406:if (Δ∉O and Δ has a 4-neighbor in O)07:Q←Q∪{Δ};08: while (Q!=∅) { // ∗∗∗ region growing of O ∗∗∗09: pick from Q the Δ which has the largest r(Δ);10:if (Δ∈O) continue;11:O←O∪{Δ};12:if (all vertices of Δ are regular) {13:for each 4-neighbor tetrahedron Δ′ of Δ14:if (Δ′∈F and Δ′∉O)15:Q←Q∪{Δ′};16:} elseO←O⧹{Δ};17: }The outside region O computed in Section 3.3 has the ball topology since we add tetrahedra one-by-one [4]. This is problematic if the true outside does not have the ball topology, e.g. if the camera trajectory contains closed loop(s) around building(s). In the simplest case of one loop, the true outside has the toroid topology and the computed outside O cannot close the loop (as shown by Fig. 5).This problem is corrected as follows. Firstly, we find a vertex in δO such that all inside tetrahedra incident to this vertex are free-space. Secondly, these tetrahedra are collected in list A. Thirdly, we try to add A into O using a 2-manifold test in Section 2.3. At last, if the test is successful, we use the region growing in Section 3.3 where Q0 is the list of tetrahedra neighbors of A. In practice, we go through the list of δO vertices several times to do this process.Although the surface S provided by the previous steps is a 2-manifold (S=δO), it has several weaknesses which are easily noticed during visualization. Now we examine these weaknesses and explain how to remove or reduce them using prior knowledge of the scene.A peak is a vertex pion S such that the ring of its incident triangles in S defines a solid angle w which is too small to be physically plausible, i.e. w<w0 where w0 is a threshold. Let L be the list of the tetrahedra in the acute side of the peak ring. L is outside or inside. Now we reverse the L label: inside becomes outside, and vice versa. The removal of peak pifrom S is successful if all vertices of the L tetrahedra remain regular. Otherwise, the label of L is restored to its original value and we try to remove another peak. In practice, we go through the list of S vertices several times to detect and remove peaks. Note that this step ignores the free-space/matter labeling.The S reconstruction noise is reduced thanks to a smoothing filter p′=p+Δp where p is a vertex of S and Δp is a discrete Laplacian defined on S vertices [35]. The smoothed p′ is stored in a distinct array of p. We do not apply p←p′ to avoid the computation overhead due to vertex update in T.Up to now, S is closed and contains triangles which correspond to the sky (assuming outdoor image sequence). These triangles should be removed since they do not approximate a real surface. They also complicate the visualization of the 3D model from a bird’s-eye view. Firstly, the upward vertical direction u is robustly estimated assuming that the camera motion is (roughly) on a horizontal plane. Secondly, we consider open rectangles defined by the finite edge cici+1 and the two infinite edges (half lines) starting from ci(or ci+1) with direction u. A triangle of S which is intersected by an open rectangle is a sky triangle and is removed from S. Now S has hole in the sky. Lastly, the hole is increased by propagating its border from triangle to triangle while the angle between triangle normal (oriented from outside to inside) and u is less than threshold β.SfM can reconstruct bad point p due to repetitive texture or image noise. Now we discuss the consequences and give solutions for this problem. If p is in the true matter of the scene, there are tetrahedra that should be matter which are labeled free-space due to bad ray of p. If these tetrahedra are in O, δO can be corrupted, e.g. a wall with a spurious concavity. In practice, the risk of bad p is low thanks to the SfM machinery (bundle adjustment, RANSAC, robust matching, interest point detectors).Nevertheless, our method reduces this risk and can remove spurious concavities. First, the risk is reduced thanks to the choice of ∊ in the point selection step (Section 3.1): the larger ∊, the more accurate points and their rays used by ray tracing (Section 3.2), the lower risk of spurious concavity. Second, the spurious concavities created by the manifold constraint in the growing steps (Sections 3.3 and 3.4) cannot be worse (larger) than those of the free-space in the matter. Indeed, a concavity is a list of outside tetrahedra which are included in free-space. Third, Section C explains how Peak Removal (Section 3.5.1) can remove spurious concavities.Section 4.1 introduces spurious handles. Then two removal methods are presented in Sections 4.2 and 4.3, which complete our methods in Section 3 (the removal methods are not presented in Section 3 for the paper clarity).Topology Extension (Section 3.4) calculates a 2-manifold without genus constraint and improves our solution of the optimization problem (Section 2.2), but it has one drawback: it can generate spurious handles. Fig. 6shows an example in a real case: the oblique handle on the left connects a small wall to the ground. This handle is spurious: it does not exist on the true scene surface and it should be removed while maintaining the manifold property.In the paper, we remove the handles which are both “visually critical” and due to “incomplete” outside growing in the free-space. “Visually critical” means that we ignore the handles that are too small to be easily noticeable by viewers (virtual pedestrians) located at all view points cjreconstructed by SfM. “Incomplete” means that the handles only contains free-space tetrahedra that are inside and which should be forced to outside. We use these conditions to localize the spurious handles and to obtain a final 2-manifold which meets the visibility constraints provided by the rays. For the remainder of the paper, a “spurious handle that is visually critical and due to incomplete growing” is shortened to “spurious handle”.Our spurious handle removal methods use Steiner vertices, i.e. extra points in T which are not in the original (SfM) input. The Steiner vertices do not have rays.In [38], a simple method is used to reduce the risk of spurious handles. In the 3D Delaunay step (Section 3.1), Steiner points are added in T such that the long tetrahedra potentially involved in spurious handles are split in smaller tetrahedra. The Steiner points are added in the critical region for visualization: the immediate neighborhood of the camera trajectory. We randomly add a fixed and small number of Steiner vertices at the neighborhood of every camera location cj. A neighborhood is a ball centered at cjwith radius defined as a multiple (e.g. 10) of meanj∥cj+1−cj∥.Another removal method [39] is applied after “Topology Extension” and before “Post-Processing”. Every sub-section describes a step of the method.Let e be an edge with finite vertices aeand be. Let α>0 be a threshold. Edge e is “visually critical” if1.every tetrahedron including e is free-space andat least one inside tetrahedron includes e andthere is a view point cjsuch that angleaecjbe^is greater than α.The first step is the calculation of all visually critical edges in list Lα. A spurious handle has critical edges both on its border and its interior (Fig. 7).The larger α, the smaller size of Lαand also the greater lengths of the edges in Lα. We use this to select a moderated number of handles and apply on every selected handle a processing, whose time computation per tetrahedron/vertex is greater than those in Sections 3.3 and 3.4.This step needs a mesh operator called “Edge Splitting”. It splits an edge of T by adding a Steiner vertex on the edge, and every tetrahedron including the edge is also split in two tetrahedra whose labels (free-space, matter, inside, outside) are the same as the original tetrahedra. Thus, the resulting triangulation T is not 100% Delaunay after this step, but our surface δO which separates outside and inside tetrahedra is still a 2-manifold (the set of surface points is unchanged).Now we split every Lαedge by a Steiner vertex on its middle (one example in Fig. 7). This changes the graph of tetrahedra and provides new tetrahedra for the next step, which is a local region growing of O in F. For each vertex vion (split) critical edges, we define the list of tetrahedra Liincident to viwhich are free-space and inside. Then a first round of (Force,Repair) is applied to the list Li. Function “Force” adds tetrahedra in O without checking that δO is a 2-manifold, and function “Repair” (Section 4.3.3) tries to grow O such that δO becomes a 2-manifold. If it fails, another round of (Force,Repair) is tried for every tetrahedron of Li. Algorithm 2 presents our method in C style.Algorithm 2Force Tetrahedra Outside01: for each vertex viof the (split) edges of every e∈Lα{02: let Libe the list of tetrahedra incident to vi;03:G=(Li∩F)⧹O;04:O←O∪G; // Force05:if (!Repair)06:for each tetrahedron Δ∈Li07:if (Δ∈F and Δ∉O) {08:G={Δ};09:O←O∪G; // Force10:Repair;11:}12: }The repair step is a local growing of O in F such that the number n of singular vertices of surface δO decreases and every regular vertex is maintained regular. At the beginning, n>0 is due to the addition of G in O (Force). Then a free-space and inside tetrahedron Δ is chosen in the neighborhood of G, and it is added to O. If n increases, we remove Δ from O and try another tetrahedron. We continue until every Δ candidate increases n. If the final n is 0, the local region growing succeeds. Otherwise it fails and O is restored to its value before the Force step.The inputs are O, G and g0 (an upper bound to limit the local growing complexity). The output is a boolean which asserts that Repair is successful or failed. Repair can also modify O. Algorithm 3 presents function Repair in C style. Note that this algorithm looks like the one in Section 3.3. The main differences are (1) the 2-manifold tests are replaced by non-increase tests of the number of singular vertices and (2) the process can fail.Algorithm 3Repair01: let Y be the list of vertices of the tetrahedra in G;02: let n be the number of singular vertices in Y;03: // ∗∗∗∗ initialization of priority queue Q ∗∗∗∗04: Q=∅;05: for each tetrahedron Δ in G06:for each 4-neighbor tetrahedron Δ′ of Δ07:if (Δ′∈F and Δ′∉O)08:Q←Q∪{Δ′};09: // ∗∗∗∗ region growing of O ∗∗∗∗10: while (Q!=∅) {11: pick from Q the Δ which has the largest r(Δ);12:if (Δ∈O) continue;13: letbi0be true iff the i-th vertex of Δ is singular14:n0=∑i=14bi0; // number of singular Δ-vertices15:O←O∪{Δ};16: letbi1be true iff the i-th vertex of Δ is singular17:n1=∑i=14bi1; // number of singular Δ-vertices18:if (n0⩾n1 &&b10⩾b11&&b20⩾b21&&b30⩾b31&&b40⩾b41) {19:G←G∪{Δ}; // G is used latter20:n←n+n1−n0; // fast n update21:if (the size of G is g0)22:break; // too large computation: stop23:for each 4-neighbor tetrahedron Δ′ of Δ24:if (Δ′∈F and Δ′∉O)25:Q←Q∪{Δ′};26:} elseO←O⧹{Δ}; // failure of Δ addition27: }28: // ∗∗∗∗ check the result ∗∗∗∗29: if (n) {30:O←O⧹G;31:return 0;32: } else return 1;Here we evaluate the time complexities of the 2-manifold tests (Section 5.2) and region growing (Section 5.3) using notations and data structures in Section 5.1. Then Section 5.4 discusses the worst case complexities of these steps and others. We use the standard “big o” notationO; x is bounded ifx=O(1).The 3D Delaunay triangulation T is the labeled graph defined in Section 2.1. We note ∣L∣ the number of elements of list L; ∣T∣ is the number of tetrahedra. Let v be the number of tetrahedra vertices. We assume that every tetrahedron Δ stores a label outside-inside, the number r(Δ) of intersected rays, the list of 4 vertices, and the list of 4 neighbor tetrahedra. The tetrahedra and their vertices are referenced by integers in the lists above. There is a table of vertices and a table of tetrahedra. Note that Δ∈F if and only if r(Δ)>0. Let d be the maximum vertex degree, i.e. the number of tetrahedra incident to every finite vertex (every vertex except v∞) is less or equal to d.In Section 2.3.3, we add A to O if and only if δO remains 2-manifold, i.e. if every vertex of W is regular. According to Sections 3.3 and 3.4, A has a single tetrahedron or several tetrahedra sharing a surface vertex. This vertex cannot be v∞ since all v∞-incident tetrahedra are matter and every surface vertex is incident to a free-space tetrahedron. Thus, ∣A∣⩽d. Since W is the list of the vertices of the tetrahedra in A, its complexity isO(d). Furthermore, the complexity to check that a vertex is regular using the Graph-Based Test in Section 2.3.2 isO(d). Thus the time complexity of the 2-manifold test for list A isO(d2). If A has a single tetrahedron, both graph-based method (Section 2.3.2) and single tetrahedron method (Section B) areO(d).Here we estimate the time complexity of Algorithm 1. Let q0 be the number of tetrahedra in list Q0. Let g be the number of grown tetrahedra, i.e. the difference between the number of tetrahedra in the output O and the number of tetrahedra in the input O of this algorithm. A tetrahedron Δ is definitely added at most one time into O. In this case, at most four tetrahedra are added to Q. There is no other addition to Q, except at the initialization of Q where there are at mostO(q0)additions to Q. Thus, the number of “while” iterations isO(g+q0).Now the time complexity of one iteration is estimated. Picking the best tetrahedron in heap Q isO(log(g+q0)). The other instructions in one “while” iterations areO(d)due to the 2-manifold test (Section 5.2 using ∣A∣=1).If we start from O=∅, we should add the complexity of Q initialization: the time complexity of one region growing isO(∣T∣+g(d+log(g))). If we start from O≠∅, this time complexity isO((g+q0)(d+log(g+q0))).The number of tetrahedra is|T|=O(v2)and the maximum vertex degree isd=O(v)since T has v vertices [3,34]; the worst case exists but it is rare. Furthermore, a theoretical study starting from these numbers provides time complexities that are not tight enough to be interesting. Here are two examples. First, the time complexity in the worst case to trace a single ray isO(v2). Indeed, one line segment can intersect all tetrahedra [34], but this is almost impossible in practice. A second example is the region growing which isO(v3)in the worst case (used=O(v)andg+q0=O(v2)in Section 5.3), but it is quite smaller in practice. So we will use neither|T|=O(v2)nord=O(v)in the complexity analysis below.Section 6.1 introduces two new assumptions: the bounded density of the SfM points and the addition in T of a Cartesian grid of Steiner vertices. Section 6.2 lists all our assumptions and Section 6.3 provides the worst case time complexities for the steps of our method.We assume that the density of reconstructed points in 3D is bounded: there are p>0 and q>0 such that every p-ball contains at most q points. A p-ball is a ball with radius p. This could be justified as follows: (1) only interest points are reconstructed and (2) the scene surface has texture such that the interest points, which are detected due to gray-level 2D variations in their neighborhood, have a bounded density (e.g. no fractal-like texture).We also use a bounding box of the reconstructed points, which is computed from the point coordinates. This box has Delaunay mesh T with two kinds of vertices: the reconstructed vertices (Section 3.1) and Steiner vertices located at the corners of a Cartesian grid. The adding of Steiner vertices (i.e. extra points) is a standard method in Computational Geometry to generate meshes with good properties, e.g. to guarantee a linear-size 3D Delaunay triangulation with bounded vertex degree [3]. Every Steiner vertex has an empty visibility list. In practice, the number s of Steiner vertices is quite smaller than the number m of reconstructed vertices (v=m+s≈m).Thanks to the bounded density of the SfM points and the Cartesian grid of Steiner vertices, Section D shows that the tetrahedron density is also bounded, i.e. there are p′>0 and q′>0 such that every p′-ball intersects at most q′ tetrahedra. The proof has two steps: first the tetrahedron diameter is bounded by the diagonal length l of a grid voxel, second we use the bounded density of the points in the p′+l-ball which includes all tetrahedra intersecting the p′-ball. If the p′-ball is centered at a finite vertex, we see that the maximum vertex degree d is bounded.This list is used in the complexity proofs.H0:T has m reconstructed and s Steiner vertices where s<m,the tetrahedron density is bounded,the maximum vertex degree d is bounded,the access to the 4 neighbors of a tetrahedron isO(1),the size of visibility list Viis bounded,the distance between two consecutive view points is bounded.H0–2 are in Section 6.1. H3 is in Section 5.1. In practice, the distance between the locations of two successive images is bounded (H5) and we assume that the track length (of interest point in successive images) is also bounded (H4).Table 1gives the time complexities of the steps of our method. Here we briefly summarize these results. The detailed proofs are in Section E.Step “3D Delaunay Triangulation” has the largest complexity:O(m2). This is due to the computation of the Delaunay triangulation in 3D [14]. Fortunately, the experimental complexity is almost linear in m[10].Step “Ray-Tracing” isO(m)since the ray length is bounded (using ∊>0, H4 and H5) and thanks to H1–3.Step “2-Manifold Extraction” isO(mlogm). Indeed, there areO(m)tetrahedra (since T hasO(m)vertices (H0) and d is bounded (H2)) and we obtain the result thanks to Section 5.3 and H2.Step “Topology Extension” is alsoO(mlogm). This is essentially due to the fact that the successive outside growings of this step are disjoint in the free-space.Step “Post-Processing” isO(cm), where c is the number of camera locations ck. More precisely, Peak Removal and Surface Denoising areO(m), Sky Removal isO(cm). In practice, c is quite smaller than the number m of reconstructed vertices (c<m/85 in our experiments).Step “Handle Removal” in Section 4.2 has no “O” additional complexity. Indeed, it adds to T a number of Steiner vertices which is linear to c, and the complexities of all steps of the methods do not change since c<m.Step “Handle Removal” in Section 4.3 isO(cm+wg0logg0), where w is the number of critical edges. Term cm is due to the detection of the critical edges; term wg0logg0 is due to the force and repair operations (region growings whose sizes are bounded by g0). In practice, the main term is w g0logg0 where g0=10d and w is smaller than m (w<m/4.6 in our experiments). We obtain complexityO(cm)usingw=O(m)(H2) andg0=O(1).

@&#CONCLUSIONS@&#
