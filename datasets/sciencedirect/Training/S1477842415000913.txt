@&#MAIN-TITLE@&#
Implementing design patterns as parametric aspects using ParaAJ: The case of the singleton, observer, and decorator design patterns

@&#HIGHLIGHTS@&#
Implementation of design patterns depends on the language being used.ParaAJ helps in creating reusable aspects.Some design patterns can be implemented as reusable aspects in ParaAJ.ParaAJ simplifies the reuse of design patterns to a single line of code.

@&#KEYPHRASES@&#
Design patterns,Reusability,Parametric aspects,ParaAJ,

@&#ABSTRACT@&#
Implementation of a design pattern can take many forms according to the programming language being used. Most of the literature presents design patterns in their conventional object-oriented implementations. Several other studies show the implementation in aspect-oriented languages such as AspectJ, EOS, and Caesar. In this work, we compare the implementation of three design patterns: singleton, observer, and decorator design patterns in these languages and also discuss the possibility of implementing them in ParaAJ: an extension to the AspectJ language that implements the idea of parametric aspects. We found that ParaAJ helps in making the implementation of the singleton and observer patterns reusable but it fails to help in the decorator case. The problem with the decorator pattern exists because of the current translation mechanism of ParaAJ׳s aspects to normal AspectJ׳s aspects. This opens the door for further work in ParaAJ to better support the idea of parametric aspects.

@&#INTRODUCTION@&#
Design patterns represent proven solutions to commonly recurring problems [1]. Most of the literature presents design patterns implementations in object oriented (OO) languages. Although OO languages are sufficient to implement most patterns, they lack proper constructs to make the implementation of design patterns maintainable, local, and reusable. Design patterns differ in their complexity and structure. In some cases, the pattern code gets scattered in many modules making it difficult to implement and even more difficult to maintain. As Denier and Cointe [2] state, a major problem when implementing design patterns is that they tend to disappear in the code.Aspect oriented programming (AOP) [3] provides extra constructs to deal with crosscutting concerns. Those constructs can also be used to enhance design patterns implementation. The first study in this area is the one conducted by Hannemann and Kiczales [4] who implemented the design pattern catalog [1] in AspectJ – an aspect oriented version of the Java programming language. The implementation showed an improvement in 17 out of 23 design patterns in the original catalog [1].Many design patterns have similar structures (and implementation) across different applications. Examples of these patterns include the observer, singleton, and decorator patterns. Other patterns depend heavily on their structure and implementation on the application they are applied in (e.g., facade and adapter). For those patterns which have similar structure and implementation, it would be advantageous to implement them as reusable modules instead of having to go through the tedious task of creating their template code every time they are required in a new application.For example, in the observer design pattern, there is nothing special about the addObserver() and removeObserver() methods and they will probably be the same in all applications. Yet, we have to write them every time we use the observer pattern (considering Java as the implementation language). The AspectJ implementation of the observer pattern (as implemented in [4]) provides a better solution but it also suffers from some problems that will be discussed in Section 4.2. Other AOP languages such as EOS and Caesar have different mechanism and construct to deal with crosscutting concerns and thus can be used differently to implement the various design patterns. We will highlight the advantages and disadvantages of each approach during our discussion in the following sections. We focus mainly in this paper on aspect-oriented languages since they represent the proper tool to deal with crosscutting concerns – a problem that appears clearly in most design patterns.ParaAJ[5] is a language extension built on top of AspectJ to facilitate the idea of parametric aspects. With parametric aspects, aspects can be parameterized so that they can be reused easily in different contexts. This is different from the reuse opportunities currently available in AOP languages such as AspectJ.As we mentioned before, not every pattern can be made reusable because the idea of that pattern can be implemented differently according to the context in which it is applied. Hence, we are focusing on this paper on three design patterns: singleton, observer, and decorator. The reason of choosing these three patterns is the high frequency of usage among developers and therefore the need for these patterns to be made reusable.The main contribution of this work is the implementation of some design patterns as reusable components (parametric aspects) using the ParaAJ language. Parametric aspects can be used generally but in this paper we showed how they can be effectively used to implement design patterns. The approach we are presenting is unique in the sense that the effort required to apply a design pattern in a new context is only one line of code.The rest of this paper is outlined as follows. Section 2 provides some background about the idea of parametric aspects and ParaAJ. Sections 3, 4 and 5 show the various ways of implementing the singleton, observer, and decorator patterns respectively in traditional object-oriented and also aspect-oriented languages. Section 6 briefly discusses why this paper focuses on these three patterns and not on other patterns. Section 7 presents some related work and finally Section 8 includes some concluding remarks.In this section, we will discuss the main constructs of the ParaAJ language and its approach toward the idea of parametric aspects [5]. This is needed for our discussion in the next few sections. A parametric aspect (para-aspect for short) is an abstract aspect that defines a self-contained piece of reusable functionality. It provides an explicit interface between itself and its clients and is considered abstract because it cannot be used as is; it has to be applied to a target component and each application specifies a separate concrete aspect.Kersten and Murply [6] distinguish four types of class-aspect association: closed, open, class-directional, and aspect-directional associations. A closed association means that both the aspect and its target (usually a class) do not know about each other. In an open association, on the other hand, both know about the other by means of references in the aspect or in the class itself. Most AspectJ׳s aspects rely on class-directional association where aspects include information about affected class but the class is oblivious to this relation.Parametric aspects in ParaAJ use the aspect-directional relation where the aspect is generic and oblivious to the relation and the class has all the information about the connection between the two. Thus, ParaAJ shifts the control point from the aspect to the class side. With this kind of association, the developer can see the various aspects affecting the class by looking at its source code (hence, improving visibility) and still have the crosscutting concern code encapsulated in the aspect (avoiding the tangling and scattering problems associated with most crosscutting concerns).Another advantage in the parametric aspect approach is aspect reusability as they can be implemented without explicitly referring to their targets (i.e., base code). Unlike normal aspects, a parametric aspect uses parameters as an interface between itself and its clients. This avoids any coupling resulting from hard-coding the target class in the pointcut. Mainly, parameters are used to pass target class information but they can also be used to pass any other parameters as we do in constructor and method parameters. Target class information might include pointcuts, types, field names, method names and signatures. We believe that this would be more convenient than using aspect inheritance to create a separate specialized aspect for each use of a reusable aspect.ParaAJ[5] is an extension to the AspectJ language that allows the creation of component aspects, i.e., modular aspects that can be applied and used in different contexts according to the supplied parameters. One of the main goals of ParaAJ is to overcome the limited reuse opportunities in AspectJ (abstract pointcuts). This can have many applications beyond implementation of design patterns but we focus in this paper in this particular topic.ParaAJ allows either aspect-directional or closed associations. Its main distinguishing features are that aspects must be explicitly applied to the classes they affect, and that aspect applications may specify parameters that indicate how the aspect is to be applied. These features enhance maintainability, as the aspect parameters create a formal interface between aspects and classes, allowing each to be developed and maintained separately, and encouraging reuse of both aspects and classes.It is worth noting that ParaAJ׳s parameters are different from the currently available parameters in AspectJ׳s constructs such as pointcut and advice. The parameters in AspectJ are translated simply to method parameters during the weaving process. Then, they get evaluated at run-time. In ParaAJ, on the other hand, parameters can be used to represent programming constructs (e.g., fields and methods).The parameters in parametric aspects are similar to the constructor and method parameters in normal classes except for the fact that they are evaluated at compile-time. ParaAJ׳s parameters come right after the aspect name in the declaration following the syntax:〈visibility〉aspect〈name〉(〈formals〉)̲{〈aspectbodydeclarations〉}where〈visibility〉is a visibility modifier as can be applied to a normal aspect;〈name〉is an aspect name;〈formals〉specifies the formal parameters of the aspect; and〈aspectbodydeclarations〉are any declarations that can appear in a normal AspectJ aspect.Similar to normal parameters in constructors and methods, each formal parameter declaration consists of a type and a name. The name can be any normal Java identifier. The type can be any primitive Java type such as int, double, char, boolean, etc. or a meta-type that could be one of the following: type, field, fields, method, methods, pointcut, and ident.type is a meta-type to pass primitive or reference type names. We would be able to achieve the same thing using an identifier (ident) but using type instead helps the compiler to detect errors early if a wrong type is passed to the aspect (for example, if we pass string instead of String). The type ‘field’ and ‘fields’ are used to pass field names to the aspect. Such parameters can be used to construct pointcuts inside the aspect. Also, ‘method’ and ‘methods’ are used in the same way.The ident type is a new type that we introduced to the language to allow developers to pass arbitrary identifiers to the aspects. This would be particularly useful for aspects that introduces new members to targets and we would like to parameterize the name of these members.Usually in methods and constructors, when a parameter is declared in the module definition, it is used inside the module as it is. For example, in the following listing, the parameters a and b appear inside the method in the same format as the method definition.However, inside the body of parametric aspects, parameter names should appear between ‘$[’ and ‘]’ symbols. The reason in using this notation is that parametric aspect parameters are evaluated during compile-time and thus we need a way to differentiate them from other symbols in the aspect body. In programming languages compiler terms, if the compiler encounters the following statement:it would declare a variable of class or interface Foo. However, if the compiler encounters the following statement:it would declare variable of type specified by aspect parameter foo. These nodes (i.e., meta-nodes) are replaced during compilation with the actual values passed by the apply declaration (shown next).As mentioned before, ParaAJ allows parameters to appear only inside the body of the aspect. However, it restricts the places where the parameter can be used according to the type of the parameter itself. For example, in Java grammar, Type is a Java rule to represent primitive types (such as int, char, etc.) or reference types (for example, String, java.util.List, user created types, etc.). This rule is used in many rules in Java and AspectJ. For example, in Java it is used in field declarations, method headers (return types), and formal parameters. Also, in AspectJ, it is used in inter-type member declarations and type patterns. ParaAJ adds a rule to the grammar to allow meta-types to appear anywhere where a type can be applied.The advantage of this restriction is to ensure that ParaAJ can produce semantically correct programs. In a similar way, ParaAJ allows several other grammar rules such as meta-field declaration and meta-inter-type declaration. At this stage, ParaAJ does not support passing complete statements or a group of statements to the parametric aspect. We believe that this would add more power to the language but it is not supported yet.Parametric aspects can be applied to a target class internally resulting in an aspect-directional relationship, or externally (from another class) resulting in a closed association between the aspect and the class. Both cases leave the parametric aspect reusable and the second case allows the target class to be reused with or without the application of that aspect. Deciding on whether we should apply an aspect internally or externally depends mainly on the aspect and on the concern it is implementing.Internal application: In an internal application, the apply declaration resides inside the target class and only affects that particular class. It can be placed anywhere where class members can be declared and has the following syntax:apply〈name〉(〈actuals〉);where〈name〉is a parametric aspect name;〈actuals〉specifies the actual parameters that will be passed to the aspect.External application: In an external application, the apply declaration resides inside one class (the host) but specifies that it applies to another class (the target). The overall effect of this kind of application is a crosscutting concern that connects the functionality of two separate classes. The syntax of the apply declaration in this case is:〈target〉. apply〈name〉(〈actuals〉);Consider a logging requirement that logs any updates that are performed on a certain field. To implement this requirement, we create a parametric aspect that takes the field name as its interface as shown in Listing 1. This field should belong to the target that is using the aspect and can be used (i.e., the field) inside the aspect to build other constructs such as pointcuts.Listing 1A simple parametric aspect and applying it to a class.In AspectJ, the pointcut set(field_pattern) is used to capture any statement modifying the field matched by field_pattern. A field_pattern consists of modifier (optional), field type, host, and field name. For example, we could write:set(int︸typeFoo︸host·bar︸name︸fieldpattern)In ParaAJ, we need not, and must not, specify the host class, as that is determined by the class to which our aspect is applied. In this example, $[f] specifies the field whose changes should be announced. The actual name of the field will be passed in the apply statement. After defining the aspect, it can be applied to any class using the apply declaration shown in Line 9 in Listing 1.Based on the capabilities of ParaAJ, we believe that it would be advantageous to use them in implementing design patterns. As we mentioned before, the current problem when it comes to implementing design patterns is that the implementation tends to disappear in the core logic [2]. In the aspect-oriented based implementation [4], the case is better but we still have the problem of implementation overhead i.e., number of lines required to achieve a certain design pattern. Because of these reasons, we thought of using parametric aspects to implement some design patterns to achieve better maintainability, reusability, and expressiveness. In the following sections, we will discuss various implementations of three design patterns (singleton, observer, and decorator) in different object-oriented and aspect-oriented languages.The singleton design pattern is a very well known pattern that is used to “ensure that a class has only one instance, and provides a global point of access to it” [1].In object-oriented languages such as Java, this pattern can be implemented as shown in Listing 2. The implementation is divided into three parts: (1) an instance variable holding a reference to the created object, (2) a private constructor, and (3) a public method to get the instance. When an object of type MyClass gets created for the first time, theInstance field would be created. Later requests to create new objects would not create another theInstance field, but rather, would return the object that has already been created.Listing 2Implementing the singleton pattern in Java.Although the implementation does not appear to be crosscutting, it actually mixes the singleton logic with the actual functionality of the class (not shown in the listing). The singleton pattern is widely used and the same procedure has to be followed whenever the singleton is needed.Hannemann and Kiczales [4] reimplemented the singleton design pattern using AspectJ (see Listing 3). The main component in their implementation is an abstract aspect (SingletonProtocol). In this abstract aspect, they provide an empty interface (usually called marker interface[7,8]) that is used as a parent interface (i.e., the class to be made singleton should implement it). They use a pointcut that captures calls to the class constructor “call((Singleton+).new(..))” and uses an around advice to create a new instance or returns the existing one.Listing 3Implementing the singleton pattern in AspectJ.This implementation separates the singleton logic from the core logic of the class. The SingletonProtocol represents the reusable building block for the singleton pattern. However, creating the actual singleton instance (Lines 19–26 and 27–34) is not as easy as we think it should be. There is a lot of code that will be the same in each singleton instance; yet, it has to be repeated every time. The gray-shaded areas in Listing 3 represent the parts that will vary in each application of the SingletonProtocol. Other un-shaded parts will remain the same and have to be duplicated in all aspects.AspectJhas many powerful constructs and supports aspect reuse through abstract aspects. However, as we can see in Listing 3 (Lines 21 and 29), one of the main limitations of AspectJ is the inability to make inter-type declarations reusable i.e., they have to be declared completely in each new concrete aspect. In other words, inter-type declarations cannot be parameterized in the current implementation of AspectJ.Furthermore, the identifiers PrinterSubclass and ScreenSubclass that appear in the pointcuts (Lines 25 and 33) cannot be passed easily to the aspect. In other words, the protectionExclusions pointcuts have to be repeated just to include these small parts (i.e., the identifiers).An interesting approach is the one followed in Sally[9]. Sally is a general-purpose aspect-oriented language that has many similarities to AspectJ. However, unlike AspectJ, Sally uses normal classes to encapsulate crosscutting code (instead of creating new constructs such as aspects). Also, it adds more power to the language by allowing variability in its static crosscutting constructs. In other words, while AspectJ pointcut language expresses only the dynamic parts of the language (for example, methods call and field access), Sally allows introductions to be expressed in a parametric way. This is useful to create generic aspects; many AspectJ aspects cannot be expressed easily in a generic way because of the inability to write reusable introductions. Using parametric introductions, developers can declare what to be introduced to the target class without explicitly specifying the actual target. Listing 4 shows an implementation of a generic singleton aspect in Sally.Listing 4Parametric singleton implementation pattern Sally.ParaAJis similar to Sally[9] in that it supports parameterization in modules. In ParaAJ, this is applied to aspects. The implementation of the singleton pattern as a parametric aspect has many similarities to the original object-oriented implementation. The only difference is the parts that refer to the actual class that need to be made as singleton. The implementation is shown in Listing 5.Listing 5Implementing parametric singleton aspect in ParaAJ.The code includes some new constructs that we did not cover in Section 2: the inject and thisTarget keywords. The inject statement is similar to inter-type declaration in AspectJ except that it does not need to specify the target class where the member is to be introduced (i.e., that contains the apply declaration). The effect of this injection is creating a member that is visible to the target class (i.e., as if it was hard coded in that class). The thisTarget is a kind of reflection mechanism that specifies the class or component which is applying the aspect. To make a class singleton, we just need to apply the MakeSingleton aspect as shown in Line 11.The advantage of this approach is that the aspect clearly reflects the conventional object-oriented approach of implementing the singleton pattern. Any developer who is familiar with the object oriented implementation of the singleton can understand and modify the aspect (e.g., to apply the double-checking mechanism required in multi-threaded applications).The implementation in ParaAJ is different from the one in AspectJ in the sense that AspectJ׳s aspect is used for all classes that need to be implemented as singleton. In ParaAJ, the aspect serves as a template, whenever a class applies it, a new aspect specific to that class will be created.

@&#CONCLUSIONS@&#
