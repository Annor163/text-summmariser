@&#MAIN-TITLE@&#
An on-the-fly grammar modification mechanism for composing and defining extensible languages

@&#HIGHLIGHTS@&#
We evaluate an adaptable model based on Parsing Expressions Grammars, called APEG.we define the syntax of SugarJ and Fortress using APEG.We analyze the flexible mechanism of APEG to change the grammar on-the-fly.The flexibility to modify grammars allows APEG to reuse other grammars definitions.The mechanism of on-the-fly modification of grammars allows composing languages.

@&#KEYPHRASES@&#
Parsing Expression Grammars,Extensible languages,Grammars,Language composition,

@&#ABSTRACT@&#
Adaptable Parsing Expression Grammar (APEG) is a formal method for defining the syntax of programming languages. It provides an on-the-fly mechanism to perform modifications of the syntax of the language during parsing time. The primary goal of this dynamic mechanism is the formal specification and the automatic parser generation for extensible languages. In this paper, we show how APEG can be used for the definition of the extensible languages SugarJ and Fortress, clarifying many aspects of the syntax of these languages. We also show that the mechanism for on-the-fly modification of syntax rules can be useful for defining grammars in a modular way, implementing almost all types of language composition in the context of specification of extensible languages.

@&#INTRODUCTION@&#
The use of Domain-Specific Languages (DSLs)[1,2] has been considered a good way to improve readability of software, bridging the gap between domain concepts and their implementation, while improving productivity [3–5] and maintainability [3,6,7]. Despite the various methods for implementing DSLs, extensible languages seem to have several advantages over other approaches [8–10]. One of the advantages is the possibility of implementing DSLs in a modular way. For example, Erdweg et al. show how DSLs can be implemented using the extensible language SugarJ [8], by means of syntax units designated as sugar libraries, which specify a new syntax for a domain concept. Tobin-Hochstadt et al. also discuss the advantages of implementing DSLs by means of libraries [9].The implementation of extensible languages requires adapting the parser every time the language is extended with a new construction. This task has been implemented in an ad-hoc way by regenerating a static grammar which accomplishes the new changes, compiling this grammar and using it for parsing the program [8,11,12]. Another way is to use models that provide mechanisms for dynamically changing grammar rules. The latter approach has several advantages [13].Reis et al. observed this lack of formalization when defining the syntax of extensible languages and proposed a new formal method to fill this gap, which is called Adaptable Parsing Expression Grammars (APEG)[14]. The main feature of APEG is the ability for formally describing how the syntax of a language can be modified on the fly, while parsing a program. Although APEG was initially proposed as a formal method for defining the syntax of extensible languages and efficiently parsing them, its flexibility for dynamically changing the grammar during parsing time also accredits APEG to implement other important issues in language design.The main application of on-the-fly grammar modification during parsing is on the definition of extensible languages. This work is an extension of [13], and shows that the mechanism for on-the-fly modification of syntax rules can implement almost all types of language composition defined in [8] and allows defining grammars in a modular way. It proves that the on-the-fly mechanism of APEG for changing grammars is powerful to define extensible languages. Composing grammars dynamically also may be useful for defining parameterized DSL librariesExtending and composing languages require more than only syntax. It involves semantics and also language-based tools, such as editors and debuggers. In this paper, we only address syntactic aspects of extensibility. The semantic issues will be object of further research.The remaining of this paper starts giving a brief introduction on how APEG works, in Section 2. Section 3 discusses APEG specifications of the extensible languages SugarJ and Fortress. In Sections 4 and 5, we show how the mechanisms provided by APEG allow building modular specifications and language composition, respectively. Section 6 discusses the related work and Section 7 presents the conclusions.Adaptable Parsing Expression Grammars or APEG [14] is an extension of PEG [15], so as to allow the set of grammar rules to be changed during parsing. APEG associates attributes with nonterminal symbols and achieves adaptability through a special inherited attribute called language attribute. The language attribute is the first attribute of every nonterminal. It represents the current APEG grammar and contains the set of all its rules. This attribute can be changed, using update expressions, by a special function adapt. During the recognition process, when the APEG parser initiates the expansion of a nonterminal, its definition is obtained from its current language attribute.Fig. 1shows an example of an APEG grammar for parsing programs in a language initially containing only sum expressions and also a construction to extend itself with other rules. The nonterminals Start, Sum, Add_Num and Num only have the language attribute, enclosed by the symbols [and]. The nonterminal rule is the only one that has a synthesized attribute, which is defined by the returns clause. The list of attributes of a nonterminal occurring on the right hand side of a rule is enclosed by the symbols<and>. Each list begins with the inherited attributes followed by the synthesized ones. One example is the use of the nonterminal rule in the definition of the nonterminal Start, in Fig. 1.The language defined by the nonterminal Start is a sequence of one or more Sum ‘;’ or ‘extend’ rule<g,r>’;’ {g=adapt(g,r);}. The nonterminal Sum defines an arithmetic expression using only the addition operation. The parsing expression ‘extend’ rule<g,r>‘;’ {g=adapt(g,r);} is a construction used in this example to extend the language. This parsing expression specifies a syntax that begins with the keyword extend followed by a nonterminal rule and ends with the semicolon symbol. The parsing expression {g=adapt(g,r);} is an update expression of APEG, and it is defined within the symbols {and}. That update expression extends the grammar g with new rules, encoded in the string r. The function adapt receives a grammar and a string representing the rules to be added to it and returns a new grammar, which contains the new rules [16]. APEG only permits modifying the grammar by creating new rules or adding new choices to the end of existing rules [16].The definition of the nonterminals Sum, Add_Numm and Num is straightforward. The nonterminal rule just defines a string which encodes a rule. This string is a sequence of characters enclosed by “and”. The parsing expression s=(!”.)* in the definition of the nonterminal rule is a bind expression. It captures the text matched by the parsing expression (!”.)* and binds it to the synthesized attribute s. The parsing expression !”. uses the not-predicate operator, !, to assure that the next symbol is not ”, without consuming it. Next, exactly one symbol is consumed using the any-expression symbol (a dot), which recognizes any character. Summarizing, the parsing expression s=(!”.)* matches a sequence of symbols until it finds ”, associating this sequence to the variable s.If we have the program of Fig. 2as input, the parser will work as follows: it begins parsing with the nonterminal Start with the initial grammar, containing only the rules of Fig. 1. After this, it successfully matches the first expression 1+2 using the first rule choice, Sum ‘;’, and does not change the grammar. Next, the construction adding new rules is parsed using the second choice of the repetition. This time, the grammar g is modified with the new rule Add_Num[Grammar g]: ‘-’ Num<g>;, by the update expression. Therefore, the new grammar has a new choice for the nonterminal Add_Num, allowing the minus expression. In the next iteration of the repetition, when parsing the last expression, the language attribute g passed to the nonterminal Sum has this new rule, so it is possible to correctly parse the expression in line 3.It is important to highlight that although in this example we use the keyword extend in the construction that extends the language, it is not a requirement of the APEG model. A language designer can create a construct that extends the language using different keywords, or even no keyword at all.This example illustrates some important features that APEG adds to the PEG model. The update expression is a new feature added by APEG, which is used, in the example, to assign a new grammar to the language attribute. However, the adaptability effectively takes place only when this attribute is passed to the nonterminal Sum as its language attribute in the next iteration of the repetition. APEG also has constraint expressions, which may indicate that a parsing expression fails if the given condition is not satisfied. We may omit the language attribute whenever it is only passed on without modifications.A formal definition of the semantics of APEG is presented in [14].As we stated in the introduction, extensible languages arise as a good method for implementing DSLs. However, analyzing extensible languages which have the properties required for defining DSLs in a modular way, such as the languages SugarJ [8], Fortress [17,18,11] and XAJ [12], we have noted a lack of formal tools for their definition, leading to ad-hoc implementations. The parsers available for these languages use a mix of a handwriting approach and automatic generation, first collecting all definitions of new syntax and, next, generating a new parser table at compile-time for parsing the code that uses the new syntax.Due the flexibility of APEG to change the grammar definition on the fly, it is possible to formally define the syntax of extensible languages, including the extensibility mechanism, and automatically parse them. In order to show how extensible languages can be implemented using APEG, we specify the syntax of the extensible languages SugarJ and Fortress, described in Sections 3.1 and 3.2, respectively.SugarJ [8] is a language recently developed by Erdweg et al. to experiment and validate their idea of sugar libraries. The main aim of sugar libraries is to encapsulate the definition of extensions for the Java language in units that may be imported or composed for creating other extensions, in a modular way. Fig. 3shows an example of a definition of a sugar library for a new syntax for pairs, creating two new rules: a rule for the definition of pair types in line 5,type→‘(’type ‘,’ type; ‘)’, and a rule for using pair expressions in line 6,expr→‘(’expr ‘,’ expr; ‘)’. Note that the definition of a rule in SugarJ is in an order that is reverse to the one commonly used in context-free grammars.A definition of a sugar library does not immediately extend the language, an extension is only created when a module or file imports a sugar library. As an example, Fig. 4shows a program that imports the sugar library Pair in line 1. After this import statement, the parser effectively extends the language, adding the two rules defined by the sugar library. The rules added are used for correctly parsing the instance variable p of the class Test in line 5.We have defined the syntax of SugarJ in APEG and used an experimental version of an interpreter of the model to automatically perform parsing. As APEG is based on PEG, we adapted an implementation of the Java grammar for the Mouse project [19], which is also based on PEG, and extended it to allow the definition of sugar libraries. Fig. 5shows the syntax definition of sugar libraries. As a definition of a sugar library does not extend immediately the grammar, the nonterminal sugar_decl only collects the name of the sugar library and the rules in a single string. This information is passed through the rules of Fig. 5 as synthesized attributes and is used later in an import statement to extend the grammar. Differently from the implementation of SugarJ, which defines the rules in SDF [20] syntax, we have decided to use the PEG style for defining the rules of SugarJ, because of the base model. Otherwise, we would have to translate the context-free rules to PEG and this would add complexity that is out of the scope of the project. The nonterminal peg_rule defines a sequence of rules in the PEG style (lines 5 and 6 of Fig. 3 are a concrete example of the kind of syntax defined by this rule), but they are in an order that is reverse to the one commonly used in PEGs. The update expression of the peg_rule, {rule +=id + ‘:’ + s + ‘;’;}, creates a string representing the rules being defined, in the APEG style. The other nonterminals define the syntax of parsing expressions and return their respective strings.We have also modified the nonterminal that represents type declarations to allow declarations of sugar libraries. Therefore, the definition rule for this nonterminal has a new choice:type_declaration[Stringpack,Mapm]returns[Mapm1]:…/sugar_decl<s,r>{m1=add(m,pack,s,r);}The nonterminal type_declaration has two inherited attributes, the package name and a map from names to rules, and one synthesized attribute, a map from sugar names to their corresponding definitions. So, when a sugar library is defined by the user, a type_declaration returns a new map associating the sugar library to its rules. Fig. 6shows a new syntax definition for a compilation unit, highlighting the possible changes on the grammar rules. The nonterminal compilation_unit receives a map of sugar libraries and passes it to the nonterminal import_decl. The nonterminal import_decl checks if the file is importing a sugar library and adapts the grammar, if necessary, using the function adapt. The adaptable grammar is returned as a synthesized attribute and passed to the nonterminal type_declaration, which may use the new syntax.Every file is parsed by the nonterminal compilation_unit. So, for parsing our examples of Figs. 3 and 4, the compiler parses the definition in Fig. 3 with the nonterminal compilation_unit, which receives the initial grammar of the SugarJ language and an empty map without any definition of sugar libraries. As a result, the nonterminal compilation_unit returns a new map that has an entry for the new sugar library Pair. This new map is used in the import declaration for parsing the program text in Fig. 4, so that the grammar is modified with the new rules defining Pair syntax.Composing sugar libraries: Sugar libraries are composed by importing more than one sugar library into the same file. As an example, Fig. 7shows a program that uses the syntax of pairs and closures. The compiler extends the grammar with the rules of the syntax of closures defined in Fig. 8when parsing the first import statement, in line 1. Next, the grammar is also changed with the syntax of pairs when parsing the import declaration in line 2. The modified grammar, which has the syntactic rules of pairs and closures, is used for parsing the class Partial.The implementation of SugarJ uses SDF [20] and it may be necessary to write disambiguation rules when composing various grammars. However, it is impossible to prevent all the possibilities of ambiguities and conflicts, consequently composing two or more sugar libraries is not always possible. APEG avoids ambiguities using ordered choice, so composition is, in principle, always possible using APEG. In fact, if there is some overlapping between the rules of two or more extensions, the first option on the ordered choice clause will prevail. As new choices are always inserted at the end of a rule definition, a user may change the priority altering the order of the import declarations. It seems a simple task, but it is not always easy to understand the interactions between overlapping rules.The main goals of the design of the Fortress language were to emulate mathematical syntax and to be extensible [18]. These two goals impose additional difficulties to build a parser for the language. However, defining the extensibility system in a formalism like PEG [15], which supports unlimited lookahead, would bring some advantages [18,11].Fig. 9shows an example of the definition of an extension in Fortress. Line 1 defines a new grammar, called ForLoop, which may use symbols of two other grammars, Expression and Identifier. The Fortress language has two types of nonterminal specifications: the extension of an existing nonterminal, using the symbol|≔(line2)or the definition of a new one (line 4). The right-hand side of a rule has two parts, a parsing expression and an action. The parsing expression defines the syntax of the new construct in a PEG style and the action part specifies how to translate the syntax into the core language. The action part is everything after the symbol⇒. It is possible to use aliases associated with terminal or nonterminal symbols, creating references for them, which can be used in the action part. Fig. 9 shows an example in which the nonterminal forStart is referenced by b in line 2.Fig. 10shows part of an APEG syntax definition of the Fortress language. Similar to the SugarJ definition, the nonterminal gram_def defines the syntax of an extension in Fortress and returns a map with the new entry for it. However, different from the SugarJ definition, a grammar in Fortress allows self-recursion and may use the new syntax in the action part. Therefore, it is necessary to collect the grammar rules before parsing the code. We use the and-predicate operator “&” to specify this, collecting the grammar rules while ignoring the action part. Next, we reparse the program with the modified grammar. Note that, when collecting the grammar rules using the and-predicate operator, the action part is parsed as a string, ignoring every symbol between ‘<[’ and ‘]>’ (nonterminal syn). After collecting the rule definitions, we adapt the grammar and generate a new grammar g1. This new grammar is passed to the nonterminal nonterm_def, which passes it to its children, allowing parsing the action part (nonterminal syntax). Therefore, the action part may use the new syntax being defined.The use of the and-operator, which allows an infinite lookahead, was very important to handle self-recursion, a kind of forward reference. This operator is inherited by APEG from PEG and it is implemented efficiently with the packrat algorithm, using memoization.Combining grammars: Fig. 11shows an example of composition of grammars in Fortress. Grammar A defines a new nonterminal Nt, and grammar B extends grammar A. Fortress allows the use of the syntax of A in the action part of B, as in line 6. Grammar C extends B and can use its syntax, however, C cannot use the syntax of A because it does not explicitly extend grammar A. In [18], the authors report that they need to resolve the set of extensions (for example, in grammar C it may use syntax defined in C or B, but not in A) to generate the table for parsing the action part and this is not an easy task.Using the APEG model, defining the task described above is simple and clear. We adapt the grammar, adding the rules of the grammars specified in the extends part. For example, parsing the grammar B, we add only the rules of A and when parsing the grammar C, we add only the rules of B. Another difficulty reported in [18] is how to compose the rules with multiple extensions, as defined in grammar D. In APEG, to have the same behavior of the original Fortress implementation, we must adapt the grammar in the following order: first, we add the rules of the grammar which is currently being defined (rules of D in the example), next the grammars in the extends part in the same order that is specified (first, it adds rules of B and in the sequel, rules of C, for the example of Fig. 11).The combination of extensions is difficult in the Fortress implementation because it must generate an entire grammar which must contain the definitions of all grammars used. As in the APEG model the grammar is changed locally and only as needed, combining grammars is easy and clear.Grammars in APEG are first-class types in the sense that they can be used as inherited or synthesized attributes from which APEG fetches the parsing expression of the associated nonterminal during parsing. This feature enables us to pass pieces of grammars as attributes and to use them to build other grammars.For example, Fig. 12shows an APEG grammar for expressions, and Fig. 13shows an example of a language which uses the definition of the language of expressions. In Fig. 14, we show a concrete example of an input string which conforms with grammar of Fig. 13. Observe that, in the definition of the nonterminal stmt in Fig. 13, the nonterminal expr comes from the grammar g_exp, which is an inherited attribute of nonterminal stmt. This is possible because of the APEG semantics of the use of a nonterminal on a parsing expression. The parsing expression of the nonterminal is fetched from the language attribute being used. For example, when using expr<g_exp>in Fig. 13, the parsing expression associated with the nonterminal expr is defined by the grammar g_exp, which is the language attribute in this case.The APEG flexibility for changing grammars during parsing allows building grammars in a modular way. It is possible to define different pieces of grammars and use all of them together for building another language. So, we can think of an APEG grammar as a module, which defines a set of “syntactic functions”. Thus, grammars can be passed on as inherited attributes and their “syntactic functions” can be used when these grammars are selected as the language attribute.Another advantage of this APEG semantics is that we can change the language just by using a different grammar definition. For example, the attribute exp of the nonterminal start could be associated with alternative grammars for expressions using postfix or prefix notation, creating different languages without modifying the text of Fig. 13. This feature can be useful for describing the syntax of languages by means of a parametrization mechanism in which a symbol has different meanings in different contexts, such as the “if” expression in the AspectJ language.Erdweg et al. proposed a new taxonomy for distinguishing different types of language composition, namely language extension and restriction, self-extension, language unification and extension composition[21]. Although APEG has been originally proposed as a formalism for defining the syntax of extensible languages [14,16] (self-extension as defined by Erdweg et al.), its dynamic behavior is able to specify these kinds of language composition, in the syntactic level. In this section, we discuss how each type of language composition can be defined using APEG.Erdweg et al. define that a language supports self-extension if the language can be extended by programs of the language itself without changing its implementation [21].In Section 3, we showed how to define the entire syntax of two self-extensible languages, SugarJ and Fortress, using APEG. Our specifications define clearly what rules are available at a given moment during parsing. The combination of Fortress grammars is clear in the APEG specification, showing explicitly what set of rules will be used when a grammar extends another. So, we have provided enough evidence that APEG is capable for specifying self-extensible languages. The original definition and implementation of the languages SugarJ and Fortress present a lack of formalization of the syntax, especially for the aspects related with the extensibility mechanism of the language. When comparing the APEG specifications with those definitions, it is even more clear that APEG is appropriate to specify self-extensible languages.Different from self-extensibility, which is a property of the language, language extensibility is a property of language definitions. Erdweg et al. define that a system has this property if it allows extending a base language by reusing its definition without modifications [21].APEG clearly has this property and it is used for defining the syntax of extensible languages, as in the case of SugarJ and Fortress. In fact, when the SugarJ grammar (the base language) is extended with a new DSL (for example, the Pair DSL of Fig. 4), the language extensibility property provided by APEG is used for extending the language.The initial formalization of APEG [14] does not restrict how the grammar can be extended, indicating that extensions will be performed by functions defined by the designer. Later, in a prototype interpreter that was developed [16], extensions on the base grammar were restricted by the addition of new rules or by the addition of new choices at the end of an existing rule. As APEG has ordered choices as in PEG, language extension could not be always possible. For example, suppose a grammar consisting of the APEG rulerule:α.If we extend this rule with the new choiceαβ, this second choice will never be used, because if the input succeeds for the parsing expression α, the former choice will always be used. Otherwise, both choices fail. Although APEG may present this problem when extending a language, it can be avoided as we did when extending the SugarJ language with some DSLs [16].Another limitation imposed by APEG when extending a grammar is that it is not possible to change the set of attributes (inherited or synthesized) of nonterminals. The attributes in APEG are syntactic, evaluated during parsing. When a nonterminal is used on a parsing expression, all its attributes must be specified. They are very similar to arguments in function calls. So, if APEG allowed adding a new attribute on a nonterminal, it would be necessary to change every use of this nonterminal on all parsing expressions for defining the value of the new attribute. To avoid redefining many rules, APEG does not allow changing the set of attributes.Erdweg et al. present another type of language composition, the language restriction[21]. The idea of language restriction is the opposite of language extension: it consists in the exclusion of features from a language. Erdweg et al. do not give special treatment to this type of language composition because they argue that language restriction can be implemented as an extension of the validation phase of the base language. APEG does not have any feature to restrict the base language, thus it does not provide any support for language restriction. In [22] it is shown how to give support for language restriction.A language-development system supports language unification when it is possible to reuse, unchanged, the implementation of two languages being unified only by the addition of glue code [21]. A possible solution for unifying languages using APEG is to use ideas similar to the ones presented in Section 4, for modularization of grammars. We may define a grammar which has the two other grammars being unified as inherited attributes and create a new one which uses or has the definition of these two grammars.For example, Fig. 15shows a language for declaring variables. In Fig. 16, we show how to combine the language of Fig. 15 with the language of expressions of Fig. 12, so as to build a new language which allows variables in expressions. In line 3 of Fig. 16, a new grammar which has the rules of both grammars is created. This is done by adding all rules of the grammar expr to grammar decl. Note that, if there is any nonterminal in the second grammar which is already defined in the first grammar, the parsing expression of this nonterminal in the first grammar is extended with a new choice, consisting of the parsing expression of the second one. It is similar to add a new rule, as explained in Section 2, but, in this case, it may add a set of rules. In line 4, the resulted grammar is extended with a rule to allow variables in expressions and, in line 5, a new nonterminal definition, exprdecl, which defines a rule for allowing a list of declarations followed by an expression is added, completing the unification of the language of declaration with that of expressions. The grammar unified is stored in the synthesized attribute result, allowing other grammars to use it.Creating a new grammar by extending a grammar with the rules of another one, such as in line 3 of Fig. 16, resembles the idea of inheritance of object-oriented programming. Mernik shows that the notion of inheritance enables us to implement all the types of language composition described by Erdweg et al. [22]. Thus, by passing grammars as inherited attributes and using the idea presented in Fig. 16, which simulates inheritance, APEG can achieve language unification. However, APEG does not allow overriding a nonterminal definition as in object-oriented programming, or simulate it, thus it is not possible to use inheritance as discussed in [22] when it is needed to override a nonterminal definition. Also, unifying languages by creating a new grammar dynamically, as in Fig. 16, is not efficient when the set of nonterminals and rules are static. However, in the context of defining the syntax of extensible languages, composing grammars in this way using APEG could be useful, because the syntax would change dynamically.The kind of language composition described above only defines how a system can be extended with a single extension. To refer to a system which allows composing more than one extension, Erdweg et al. [21] define a new term, extension composition. There are two interesting cases of extension composition: incremental extension and extension unification.A system supports incremental extension if it is possible to extend a base language with a extension E1 and also extends the result with another extension, E2. In other words, the system allows language extensibility twice or more times in the base language. APEG supports incremental extension because it is possible to extend a grammar and, afterwards, to extend the result. In fact, this property was used to implement composition of sugar libraries of SugarJ, as shown in Fig. 7. The only restriction to incremental extension of APEG is the problem discussed in Section 5.2 that can occur between extensions too.A system supports extension unification when it allows extending a language with the result of the unification of two other languages or extending the result of the unification. So it refers to the process of combining together the properties language extension and language unification. APEG also supports extension unification. As an example, Fig. 17shows an extension to the result of the unification shown in Fig. 16. In line 2, the grammar of Fig. 16 is used to unify the languages of declarations and expressions. In the sequel, line 3 extends the result with the rule mul:‘/’ to allow division operation in expressions. Finally, line 4 uses the definition of the nonterminal exprdecl, fetching the parsing expression of this nonterminal from the new grammar, represented by the attribute result.Fig. 18shows a concrete example which conforms with the syntax defined by the grammar of Fig. 17. Note that the language defined (nonterminal exprdecl) is a list of variable declarations followed by an expression, as defined by the unification (grammar of Fig. 16). However, as the result of the unification was extended to allow the division operation, expressions can use this operation. Therefore, line 1 has a list of variable declarations, which comes from the nonterminal declist that was originally defined by the grammar of Fig. 15, and line 2 shows the extended version of expressions, which allows the division operation. This example shows a language unification and afterwards a language extension, giving a idea of how APEG supports extension unification. The same idea can be used to extend a language with the set of rules that results from the unification of other two languages.The APEG ability to add new rules or rule choices and also to change the grammar during parsing provides a flexible mechanism to compose languages. APEG is indeed a powerful mechanism to define extensible languages by means of features for composing and reusing definitions of DSLs.

@&#CONCLUSIONS@&#
