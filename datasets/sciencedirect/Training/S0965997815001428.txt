@&#MAIN-TITLE@&#
SMT: An interface for localized storm surge modeling

@&#HIGHLIGHTS@&#
Simulation of engineering designs subject to coastal flooding is computationally expensive.A graphical user interface is presented that employs subdomain modeling to reduce the effort required.Software design and implementation issues that make the approach practical are presented.Novel aspects include an extensible, object-oriented architecture and generalized range search algorithm.Descriptions of the overall methodology and performance results are given, along with a case study.

@&#KEYPHRASES@&#
Hurricane storm surge,Subdomain modeling,Finite element analysis,ADCIRC,Range search,Visualization,

@&#ABSTRACT@&#
The devastation wrought by Hurricanes Katrina (2005), Ike (2008), and Sandy (2012) in recent years continues to underscore the need for better prediction and preparation in the face of storm surge and rising sea levels. Simulations of coastal flooding using physically based hydrodynamic codes like ADCIRC, while very accurate, are also computationally expensive, making them impractical for iterative design scenarios that seek to evaluate a range of countermeasures and possible failure points. We present a graphical user interface that supports local analysis of engineering design alternatives based on an exact reanalysis technique called subdomain modeling, an approach that substantially reduces the computational effort required. This interface, called the Subdomain Modeling Tool (SMT), streamlines the pre- and post-processing requirements of subdomain modeling by allowing modelers to extract regions of interest interactively and by organizing project data on the file system. Software design and implementation issues that make the approach practical, such as a novel range search algorithm, are presented. Descriptions of the overall methodology, software architecture, and performance results are given, along with a case study demonstrating its use.

@&#INTRODUCTION@&#
Hurricane storm surge poses a threat to coastal communities, which risk destruction to life and property. The succession of events that begins with wind and pressure fields and results in catastrophic, overland flooding is mathematically complex and operates over multiple scales of time and space. While the aftereffects of coastal storms are readily apparent, predicting them remains a challenge because of the computational effort demanded by large-scale storm surge models. Multiplying the challenge, from an engineering perspective, is the need to consider – and simulate surge events over – alternative topographies that represent hypothetical design and failure scenarios of levees and other critical infrastructure.To make storm surge simulations more practical for engineering analysis, we have developed an approach, called subdomain modeling[1], that substantially reduces the computational effort required to evaluate multiple topographic changes in a geographic region of interest. Using this approach, a storm event is first simulated on a large-scale domain, such as the western North Atlantic Ocean, that is able to capture the evolution of processes that originate far from the engineer’s region of interest [2]. Then, design and failure scenarios are introduced on a local domain that makes use of boundary conditions obtained from the full domain, thereby avoiding computations that would fall outside the sphere of influence of any changes that have been introduced. The intuition is that the local failure of a levee or rebuilding of a stretch of dunes, say, remains local, and is unlikely to create hydrodynamic effects tens of miles up the coastline.Because subdomain modeling suggests new steps in the simulation workflow, we introduce a graphical user interface that allows modelers to work directly with large-scale grids, extract regions of interest, and manage projects and files for simulation and analysis. We begin with background on ADCIRC and subdomain modeling, and continue with motivation, design, and implementation considerations.The Advanced Circulation model (ADCIRC) is a parallel, unstructured-grid finite element hydrodynamic code that supports three dimensional (3D) and two dimensional depth integrated (2DDI) analyses [3]. It is used by the U.S. Army Corps of Engineers (USACE), the Federal Emergency Management Agency (FEMA), and others to simulate storm surge and tides along the East coast of the United States and elsewhere [4,5]. The 2DDI formulation used in subdomain modeling is derived from the vertically integrated shallow water equations using the generalized wave continuity equation (GWCE) formulation [3].Three primary routines drive the physics of the ADCIRC model and are executed in succession at each timestep: the GWCE routine, the wet/dry routine, and the momentum equation routine [4]. The GWCE routine, which determines the free surface elevation at each node in the domain for the current timestep, can use either a spatially implicit or explicit method, employing an iterative Jacobi Conjugate Gradient method or a lumped mass matrix method, respectively. Subdomain modeling uses the implicit method. The wet/dry routine determines the wet or dry status of each node based on elevation, velocity, wet/dry status in the previous timestep, and wet/dry status of neighboring nodes [6]. The momentum routine determines the x and y velocity at each node for the current timestep by explicitly solving the shallow water equations using a lumped mass matrix.The necessity and effectiveness of large-scale approaches for tide and storm surge modeling are addressed by Blain et al. [2], who examine combinations of domain size and boundary conditions for their effects on computed storm surge characteristics. The authors conclude that small domains, whose boundaries are in the same regions where surge effects appear, are inadequate because the surge effects on those boundaries cannot be known, and hence enforced, a priori. The open ocean boundaries of very large domains, however, are far enough removed from these regions that the influence of the boundary condition specification is minimal, and such domains are found to be the most practical and effective.In order to retain the accuracy and effectiveness of large-scale simulations in ADCIRC while providing the speed and portability of small-scale simulations, we have developed the subdomain modeling approach. Subdomain modeling allows one to perform a series of hurricane simulations on multiple, alternative topographies in a geographic region of interest. This capability is achieved by recording data at the boundaries of the region of interest during the simulation of a storm event over the entire geographic region (called a full domain). The recorded data are then used to enforce the boundary values during a subdomain run using a new type of boundary condition. Like the domain decomposition solver used in Parallel ADCIRC [4], the new boundary condition makes use of water surface elevation, wet/dry status, and depth averaged water velocity by:•working with the existing non-periodic elevation boundary condition formulation in ADCIRC, which specifies nodal elevations in the implicit GWCE formulation,incorporating the ability to force wet/dry status on boundary nodes while the wetting and drying routine executes, andtaking advantage of the explicit nature of the momentum equation solver to assign boundary velocities outright.By employing this new boundary condition, a subdomain can produce a solution that matches a full domain run in a small fraction of the time. Modifications to ADCIRC enable this basic functionality and are now part of the official distribution [7]; those implementation details are provided in a companion paper [1]. The focus here is on a graphical user interface, the Subdomain Modeling Tool (SMT), that improves upon the command-line interface by providing an intuitive and interactive workflow for subdomain modeling, while offering compatibility with existing mesh development tools in an extensible architecture designed for cross-platform expansion and future growth.Before laying out design goals for a more sophisticated user interface, we begin with the underlying building blocks on which such an interface could be built. These low-level steps are largely driven by the mathematical formulation of coastal hydrodynamic codes like ADCIRC, and by the computational aspects of subdomain modeling.The construction of a subdomain model consists of four main steps, as outlined in Fig. 1. Initially, a region of interest is identified, and subdomain input and control files are generated. Then, a full domain ADCIRC run is performed, after which a subdomain boundary conditions file is extracted from the full domain output files. Finally, a subdomain ADCIRC run is performed, generating results that can be used to verify the subdomain model against the full domain.Following the construction of the subdomain model, subsequent case studies can be carried out by iteratively making local changes to the subdomain mesh and performing an ADCIRC run on the modified subdomain. After each iteration, the modified subdomain can be verified to ensure that the effects of the changes do not propagate to the subdomain boundaries, or that the extent of the variations at the boundaries are within an acceptable tolerance, at the discretion of the modeler. Additional details and case studies describing the verification of subdomain boundaries and results are presented elsewhere [1,8].Considering a couple of these steps in more detail, in the first, a region of interest can be identified using simple geometric shapes with numerical parameters given textually. Absent visual interaction, the modeler confirms by some other means that the extracted area matches her region of interest. This step produces the required ADCIRC input files, along with additional ones for subdomain modeling, though manual intervention is needed for adjusting some of ADCIRC’s control parameters. In the third step, the modeler can generate the subdomain boundary conditions files using the basic building blocks provided. The generated files must then be placed in expected locations before moving on to step four and performing a subdomain run. The verification of the subdomain model can be performed by generating images and hydrographs at specific nodal locations, and by manually comparing their values.In practice, studies employing subdomain modeling lead to multiple, alternative subdomain meshes. For example, the design of a levee system could use a single region of interest to test a variety of levee configurations and failure scenarios. Upon creating a subdomain model, each levee configuration would be incorporated into a unique copy of the subdomain mesh, and each of these unique configurations would be generated by the modeler performing the case study. Getting new topographic features into a mesh might be achieved either with SMT, or by using other software packages developed specifically for the purpose of re-meshing and mesh editing. One of the more popular tools used within the ADCIRC community and by other surface-water modelers is SMS (Surface-water Modeling System), a proprietary software product developed and maintained by Aquaveo [9]. SMS provides interactive tools for generating and editing ADCIRC meshes, although they do not include the features necessary to create subdomains or manage the file formats specific to subdomain modeling.Building on these basic capabilities, we outline the design goals of a more interactive and visually oriented interface for subdomain modeling that also includes project management features.•Targeting regions of interest - A visual representation of ADCIRC meshes, capable of displaying topographies and nodal attributes with customizable color gradients, allows modelers to identify features and regions of interest interactively by panning and zooming. Selection tools would then allow the modeler both to select and deselect elements to be included in the subdomain. Ideally, interaction with a mesh would be rapid and direct. Based on empirical studies, operations that are able to complete within about 100 ms appear as though immediate [10,11].Managing subdomains - An ability to create, manage, and view the location of files is needed for a streamlined workflow. Files specific to subdomain modeling, such as those enforcing boundary conditions, would be created automatically at the appropriate stage within the workflow.Subdomain verification - Following the construction of a subdomain model, the subdomain grid should be verified to ensure that results of the subdomain and full domain runs match. Support for this verification step would include visual and numerical inspection tools that could also be used after subdomains are modified to show that they are large enough to fully contain the altered hydrodynamics.Our design approach is intended to address several major goals, each aimed at improving the basic workflow and promoting the use of subdomain modeling:1.Leverage the power of subdomain modeling with a visual interface that maintains compatibility with ADCIRC and other complementary tools that users already employ.Let users work within their problem domain using direct manipulation [12], a term suggesting that interactions are more effective if the interface provides a continuous representation of the problem, the modeler manipulates this representation through physical actions (as opposed to syntax), and the interactions are both rapid and visually reversible.Realize these goals through an extensible, open-source architecture designed for cross-platform expansion and future growth.ADCIRC already has a well established community-driven software development approach, with many extensions being successfully added to the code-base, including the subdomain approach itself. However, less attention has been paid to mesh editing and visualization tools for the ADCIRC community, with a proprietary tool like SMS serving routine needs. New capabilities sometimes warrant new interface features to hook into them, so we hope to provide a base implementation for visualization and user interaction that can support the broader research and development communities and also encourage experimentation.Our approach to extensibility is of the glass-box variety, meaning that developers who wish to extend the software can view the code, but should separate their additions from the original software in a way that does not affect the original code [13]. Such architecture driven frameworks typically rely on features like inheritance and dynamic binding in order to achieve extensibility, and are often easier to work with than those employing black-box extensibility.Library dependencies and overall architecture are chosen to allow for cross-language, multi-platform growth. Not only does this promote code reuse within the ADCIRC community as researchers and developers create their own tools, it simplifies the translation of existing code onto new delivery platforms, such as web browsers and mobile devices, as the demand for tools on these platforms increases.Good interfaces allow a user to accomplish tasks as simply and efficiently as possible. In seeking to design one, we begin by observing users and their customary workflow, and look for opportunities to improve upon it.A typical SMT user will be familiar with finite element meshes, and will often have experience using SMS as a mesh editing tool. Current users of subdomain modeling, however, are required to perform their tasks from the command line. SMT aims to improve upon the existing subdomain modeling workflow by providing a complementary interface on top of the existing subdomain modeling functionality. In order to provide a simple and intuitive interface, the layout and design of SMT draws from vector graphics editors and mesh visualization tools by grouping similar features into distinct modules.The SMT interface is divided into two main sections, as seen in Fig. 2. On the right side of the SMT window, and occupying the majority of the available space, is the visualization pane, where a mesh is displayed and all panning, zooming, and selections are performed. On the left is a module stack containing five modules, each providing tools specific to a distinct step in the subdomain modeling process.The spatial refinement in ADCIRC models tends to vary, so displaying an entire mesh in a single window means that features in regions with tight nodal spacing may not be seen clearly. For example, Fig. 2 shows an SMT window with a mesh of the western North Atlantic Ocean that contains a high level of refinement along the North Carolina coast. Elements in the deep ocean, which are on the order of hundreds of kilometers in size, can be seen clearly. Coastlines, on the other hand, are much more highly refined and cannot be easily distinguished. SMT provides visual access to all parts of a large ADCIRC mesh by zooming and panning.Subdomain modeling places no restrictions on the shape of a subdomain other than that it be a contiguous region, and SMT provides tools that allow users to design the shapes of their subdomains interactively. The following selection tools, available in the ‘Create New Subdomain’ module and listed by their icons in the SMT interface, give users several ways of selecting elements to be included in their subdomains:•- Select or deselect individual elements- Select or deselect elements by drawing a circle- Select or deselect elements by drawing a square- Select or deselect elements by drawing a polygon.Note that each of these tools includes the ability both to select and deselect elements in the full domain, allowing users to produce very complex shapes. Additionally, SMT provides undo and redo capabilities, allowing users to quickly correct inadvertent selections.To support data management, SMT introduces the concept of a subdomain project for organizing the files associated with a full domain and any of its associated subdomains. First in the module stack is the ‘Project Explorer’, which shows the structure of the current subdomain project in a collapsible file tree viewer. This structure is mirrored in the underlying file system, and all files maintain their original names and formats if they have come from another tool or system (e.g., ADCIRC files). Subdomain project information is maintained by SMT in an XML file with the .spf (subdomain project file) file extension, which is used to maintain project state between SMT sessions.The ‘Edit Subdomain’ module provides basic tools for editing nodal properties such as location, elevation, and Manning’s n. While there is no pressing need to duplicate the more sophisticated re-meshing and editing features of more commonly available tools like SMS, the SMT implementation provides robust selection tools and modular data structures that would make such extensions straightforward.Both full domain and subdomain ADCIRC can be run either within or outside the SMT interface. As outlined in Section 2, the second and fourth steps of constructing a subdomain model involve a full domain ADCIRC run that records values at the subdomain boundary nodes, and a subdomain run that uses the recorded data to force values along the boundaries of the subdomain, respectively. SMT ensures that steps such as these are performed in the correct order by only giving users the option to run a subdomain once the full domain run has completed and the appropriate boundary condition files have been generated by SMT.Fig. 4 shows the options available in the ‘ADCIRC’ module of a project in which the full domain run has completed. The full domain is run by pressing the ‘Run Full Domain’ button. SMT detects when a full domain run is complete and automatically generates the boundary condition files needed to run the subdomain in a project. Any subset of the subdomains in the project can be run by selecting the desired subdomains from the list and pressing the ‘Run Selected Subdomains’ button. Subdomains can be edited and rerun at any time once the full domain run has completed, and duplicates of subdomains can be created and modified, allowing users to make localized changes and perform any number of individual simulations on the same subdomain.Users must be able to verify that the results of an unchanged subdomain and the full domain are equivalent. The ‘Analyze Results’ module of SMT provides users with the ability to compare subdomain runs with the full domain run. Differences in elevation, velocity, and wet/dry status can easily be displayed as a color gradient on the subdomain mesh, and a playback tool allows users to interactively animate these differences through every timestep of the subdomain run at which output was recorded. Additionally, users can select individual nodes in order to view the exact elevation and velocity values from both the full and subdomain runs.After a subdomain has been modified and a simulation performed, the user must verify that variations in the hydrodynamics as a result of the modifications have not propagated to the boundaries of the subdomains, as outlined in Section 2. The same tools provided for the purpose of validating the initial, unmodified subdomain can also be used in the analysis of subdomains with modified topographies.Consistent with our intended goals, the SMT framework is designed to be flexible and extensible. The framework, which relies on object oriented design principles, is comprised of three major components. The first is the SMT backend, which is responsible for creating and maintaining subdomains and all related data. The second is the user interface framework, which is typically a platform dependent library, and the third is the graphics interface used to render ADCIRC meshes.Fig. 5 illustrates an overall architecture that accommodates cross-language, multi-platform growth. In this paper the focus is on the desktop implementation, written in C++ and Qt [14], which uses common classes and design patterns, as described in Section 4.1, simplifying the translation to other languages and platforms. High performance visualization of ADCIRC meshes is achieved using OpenGL, as described in Section 4.2. OpenGL itself offers a cross-language, multi-platform API, so calling code is also easily transported across platforms. However, because user interface libraries are typically platform and language specific, the user interface component must be designed with a specific platform in mind. This structure, wherein the backend and rendering are separated from the user interface, clearly enhances flexibility and extensibility.Connecting the backend of SMT to the user interface is straightforward using Qt’s signal/slot mechanism. Additionally, the Qt object model provides convenient memory management capabilities. A number of other popular open-source user interface libraries, such as GTK+ and wxWidgets were considered, but ultimately Qt provided the right balance of user interface features and development tools, including a library specific IDE and debugger, with the added benefit of supporting multiple operating systems, allowing deployment to Windows, Mac, and Linux desktop environments.In the following sections, we give an overview of some of the design patterns used in the backend of SMT, a description of the framework used for high performance visualization of ADCIRC meshes, and the implementation details and performance metrics of the search algorithms used for node and element selection. Additionally, we discuss possible alternative approaches and the reasoning behind the implementation decisions made during development.The structure of the SMT backend relies heavily on object oriented design principles. Their use allows us to separate SMT functionality from platform and language specific features, such as the user interface framework, as well as providing glass-box extensibility.The underlying class structure of SMT mirrors the project structure seen in Fig. 3. The class diagram in Fig. 6shows a small portion of the full SMT backend. We use UML [15], the Unified Modeling Language, a common notation in software development for describing the relationships between classes. In the figure we see two such types of relationships. The first is an aggregation, or a ‘has a’ relationship, which is indicated by a hollow diamond shape on the containing class with a single line that connects it to the contained class. The number at each end of this line, called a multiplicity, indicates the number of allowed instances of that entity in the relationship. For example, a Project can only have a single FullDomain, indicated by a 1 on the Project end, whereas a FullDomain can be a part of any number of Projects, indicated by a 1..* on the FullDomain end. The second is a generalization, or an ‘is a’ relationship, which is indicated by hollow triangle on the superclass with a line that connects it to a subclass.At the top level of our partial class diagram is a Project class which is largely responsible for communicating with the user interface, as it has access to all data associated with a project. An instance of the Project class is required to contain an instance of a single FullDomain class, and may contain any number of instances of the SubDomain class. This directly reflects the project structure that can be seen in Fig. 3.The FullDomain and SubDomain classes both extend the purely abstract Domain class. The Domain class provides all the general functionality needed to access the data and functionality associated with an ADCIRC run. For example, ADCIRC requires, at minimum, a fort.14 file which contains the mesh definition and a fort.15 files which defines model control parameters in order to perform an ADCIRC run [7]. The data associated with these files is represented in SMT by the Fort14 and Fort15 classes, respectively, and every Domain instance has access to exactly one of each. Additionally, various abstract method definitions needed by the user interface to interact with ADCIRC domains are provided by the Domain class. FullDomain and SubDomain inherit all of the data access functionality of their superclass, but are required to implement abstract methods like runAdcirc(). These implementations are unique since they both require different file configurations for the ADCIRC run to be successful. The two subclasses are also free to implement additional functionality. For example, the SubDomain class makes use of two additional classes, Py140 and Py141, which are responsible for providing access to the py.140 and py.141 files, which are exclusive to subdomain ADCIRC runs.Structuring the code using object-oriented principles provides multiple levels of glass-box extensibility. Each ADCIRC file format has a corresponding class which is responsible for I/O operations in addition to data specific functionality. For example, the Fort14 class is capable of reading and writing fort.14 files, as well as performing searches over mesh data. This broad level of extensibility allows developers to freely use and build upon this functionality without requiring any specific ties to subdomain modeling or SMT. Developers who require more in-depth functionality could, for example, use the FullDomain class and all classes that it depends on to incorporate the data and functionality of a full domain in their projects, again, without requiring any ties to subdomain modeling or SMT. Additionally, because the functionality has been implemented with standard types and common programming idioms, the backend that powers SMT is easily translated into different languages for use on different platforms.The visualization of large meshes in SMT is achieved using OpenGL, a cross-language, multi-platform API for rendering 2D and 3D graphics that is robust and well maintained. The OpenGL specification describes an abstract API, defining a number of language independent functions. In addition, the specification contains nothing on the subject of creating and managing a context for rendering, leaving this task to the underlying windowing system. Therefore, the choice of using OpenGL for rendering in SMT is consistent with the design goal of providing a cross-language and multi-platform architecture.In OpenGL, a basic rendering primitive is the triangle, large numbers of which may be arranged as a mesh in order to represent a three-dimensional surface. In ADCIRC, the earth’s surface is similarly represented using a triangulated irregular network, or TIN, which is made up of irregularly distributed three-dimensional points arranged in a network of non-overlapping triangles. This parallelism of representation further makes OpenGL a natural choice over external graphics libraries that may employ different data structures for representing surfaces.The choice of search algorithm used in the selection tools provided by SMT has a direct impact on user experience. The simplest approach would be to test each element one by one against the requested shape, or in other words, to perform a brute force search; this works well when the number of elements in the dataset is small, but performance becomes worse as the size of the dataset increases. ADCIRC domains, in order to sufficiently represent topography so that simulation results are accurate, are typically on the order of millions to tens of million of elements. A dataset this size can cause a brute force search to take seconds to complete on commonly available hardware. Because seamless user interaction is central to its functionality, the design of SMT strives to avoid perceptible system lags in responsiveness, and does so by employing a generalized range search algorithm to provide sufficiently fast search results.

@&#CONCLUSIONS@&#
