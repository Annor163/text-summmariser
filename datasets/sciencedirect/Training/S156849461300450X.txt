@&#MAIN-TITLE@&#
Artificial chromosomes with genetic algorithm 2 (ACGA2) for single machine scheduling problems with sequence-dependent setup times

@&#HIGHLIGHTS@&#
The major motivation of ACGA2 is to take the bi-variate probabilistic models into the consideration.We further provide a theoretical analysis of the two-models EDAs.This studied conducted extensive experiments on the single machine scheduling problems with sequence-dependent setup times in a common due-date environment.The experimental result shows the proposed ACGA2 outperforms ACGA significantly because the average error ratio of ACGA2 is half of ACGA.

@&#KEYPHRASES@&#
ACGA,Bi-variate EDAs,Scheduling problems,Sequence-dependent setup times,Common due-date,Variable neighborhood search,

@&#ABSTRACT@&#
Artificial chromosomes with genetic algorithm (ACGA) is one of the latest versions of the estimation of distribution algorithms (EDAs). This algorithm has already been applied successfully to solve different kinds of scheduling problems. However, due to the fact that its probabilistic model does not consider variable interactions, ACGA may not perform well in some scheduling problems, particularly if sequence-dependent setup times are considered. This is due to the fact that the previous job will influence the processing time of the next job. Simply capturing ordinal information from the parental distribution is not sufficient for a probabilistic model. As a result, this paper proposes a bi-variate probabilistic model to add into the ACGA. This new algorithm is called the ACGA2 and is used to solve single machine scheduling problems with sequence-dependent setup times in a common due-date environment. A theoretical analysis is given in this paper. Some heuristics and local search algorithm variable neighborhood search (VNS) are also employed in the ACGA2. The results indicate that the average error ratio of this ACGA2 is half the error ratio of the ACGA. In addition, when ACGA2 is applied in combination with other heuristic methods and VNS, the hybrid algorithm achieves optimal solution quality in comparison with other algorithms in the literature. Thus, the proposed algorithms are effective for solving the scheduling problems.

@&#INTRODUCTION@&#
In our previous studies [1–3], the ACGA algorithm was applied in the solving of several scheduling problems. The main characteristic of ACGA is that it alternates the EDAs and genetic operators in each generation. Since other EDAs [4–8] do not use genetic operators, this is a distinguishing feature of ACGA. This approach is beneficial for EDAs to have a diversified population [9]; GA-EDA [10] used a similar framework.ACGA utilizes a univariate probabilistic model which extracts parental distribution from previous searches when the EDAs operator is responsible for generating offspring. After extraction the univariate probabilistic model is used to sample new solutions called artificial chromosomes. These prior studies show that the ACGA algorithm is able to provide satisfactory results.The univariate probabilistic model of ACGA assumes that there are no dependencies between/among variables. However, some studies have pointed out that when variable interactions exist, EDAs may employ bi-variate or even multi-variate probabilistic models [11,12,5,13]. This research studied single machine scheduling problems with sequence-dependent setup times in a common due date environment [14]. Because a prior job influences the processing time of the next job when we consider the setup times, there exists strong interaction between the jobs. If ACGA is used to solve this scheduling problem, a satisfactory result may not be achieved. Stem from Jarboui et al. [15], a new bi-variate probabilistic model in conjunction with the univariate probabilistic model was adopted into the proposed algorithm, named ACGA2. As a result, ACGA2 is able to capture a more accurate parental distribution from the two probabilistic models and thus produce better offspring.To provide more comparable result, some heuristic approaches and a famous local search algorithm, i.e., variable neighborhood search (VNS), are both employed in the ACGA2. The resultant algorithms could obtain better solution quality when we compare it with others in literature.The organization of this paper is as follows: Section 2 discusses the importance of the scheduling problems in question and provides a problem definition. The related works of EDAs and VNS are also discussed in this section. The details of the ACGA2 and the theoretical analysis of using the univariate and bi-variate probabilistic models are introduced in Section 3. In Section 4 we make extensive comparisons with other algorithms in the literature that are commonly used to solve the scheduling problems under discussion. Finally, we present our conclusions in Section 5.This research discusses single machine scheduling problems with sequence-dependent setup time in a common due date environment. The objective was to minimize the total earliness and tardiness cost. To explain the importance of these scheduling problems, Section 2.1 presents a literature survey and the problem statement. In Section 2.2, we further explain the model of the scheduling problem.Single-machine scheduling problems are one of the well-studied problems by many researchers. The application of single machine scheduling with setups can be found in minimizing the cycle time for pick and place (PAP) operations in Printed Circuit Board manufacturing company [16]; in a steel wire factory in China [17] and a sequencing problem in the weaving industry [18]. The results developed in the literature not only provide the insights into the single machine problem but also for more complicated environment such as flow shop or job shop. For the detail review of the scheduling problems with setup costs, it is available in [19].The problem considered in this paper is to schedule a set of n jobs {j1, j2, …, jn} on a single machine that is capable of processing only one job at a time without preemption. As explained in [20,14], all jobs are available at time zero, and a job j requires a processing time Pj. Job j belongs to a group gj∈{1, …, q} (with q≤n). Setup or changeover times, which are given as two q×q matrices, are associated to these groups. This means that in a schedule where jjis processed immediately after jiwhere i, j∈{1, 2, …, n}, there must be a setup time of at least Sijtime units between the completion time of ji, denoted by Ci, and the start time of jj, which is Cj−Pj. During this setup period, no other task can be performed by the machine and we assume that the cost of the setup operation is c(gi;gj)≥0 and let it be equal to machine setup time Sijwhich is included as sequence dependent.Apart from the sequence-dependent setup times, the objective is to complete all the jobs as close as possible to a large, common due date d. To accomplish this objective, the summation of earliness and tardiness is minimized. The earliness of job j is denoted as Ej=max(0, d−Cj) and its tardiness as Tj=max(Cj−d, 0), where Cjis the completion time of job j. Earliness and tardiness penalties for job j are weighted equally. The objective function is given by:(1)minZ=∑j=1n(Ej+Tj)=∑j=1n|d−Cj|The inclusion of both earliness and tardiness costs in the objective function is compatible with the philosophy of just-in-time production, which emphasizes producing goods only when they are needed. The early cost may represent the cost of completing a product early, the deterioration cost for a perishable goods or a holding (stock) cost for finished goods. The tardy cost can represent rush shipping costs, lost sales and loss of goodwill. Some specific examples of production settings with these characteristics are provided by Ow and Morton [21]. The set of jobs is assumed to be ready for processing at the beginning which is a characteristic of the deterministic problem. The set of jobs is assumed to be ready for processing at the beginning which is a characteristic of the deterministic problem. As a generalization of weighted tardiness scheduling, the problem is strongly NP-hard in [22]. Consequently, the early/tardy problem is also a strong NP-hard problem. It is the reason why this work attempts to use eACGA to conquer this NP-hard problem in a reasonable time.An example of the application of the common due date model would be an assembly system in which the components of the product should be ready at the same time, or to a shop where several jobs constitute a single customer's order [23]. Kanet [24] shows that the optimal sequence is when the bth job is completed at the due-date. The value of b is given by:(2)b=n/2ifnis even,(n+1)/2ifnis odd,The common due-date (k*) is the sum of processing times of jobs in the first b positions in the sequence; i.e.,(3)k*=CbAs soon as the common due date is assigned, see Fig. 1, jobs can be classified into two groups that are early and tardy which are at position from 1 to b and b+1 to n respectively. The following notations are employed in the latter formulations.j: job in position j.A: the job set of tardy jobs.B: the job set of early jobs.S[j][j+1]: Setup time of a job in position [j+1] follows a job in position [j].AP[j][j+1]: Adjusted processing time for the job in position j followed by the job in position [j+1].b: the median position.AP[j][j+1] is actually the processing time of job j+1 with setup time. Thus, the original form of AP[j][j+1] is written as:(4)AP[j][j+1]=S[j][j+1]+Pj+1Our objective is to minimize the total earliness/tardiness cost. The formulation is given below.(5)Minimizef(x)=∑j=1n(Ej+Tj)=TT+TEwhere TT is total tardiness for a job sequence; TE is total earliness for a job sequence; and TT and TE can be transformed into the following equations based on the pre-defined adjusted processing time.(6)TT=∑j=bn−1(n−j)AP[j][j+1](7)TE=∑j=1b(j−1)AP[j−1][j]In recent years, EDAs is one of the most popular evolutionary algorithms [25,26,15,7,27]. EDAs explicitly learn and build a probabilistic model to capture the parental distribution, and then samples new solutions from the probabilistic model [28]. Sampling from probabilistic models avoids the disruption of partial dominant solutions represented by the model, contrary to what usually takes places when applying genetic operators, such as crossover and mutation operator [8]. This is the most important characteristic to distinguish EDAs and Genetic Algorithms (GAs). As claimed by Zhang and Muhlenbein [29], EDAs might be a promising method capable of capturing and manipulating the building blocks of chromosomes and, hence, efficiently solving hard optimization problems.VNS has undergone a variety of systematic changes to its neighborhood structure during a local search [30,31]. Because VNS is able to solve the combinatorial optimization problems effectively, this meta-heuristic method has been used extensively. Take the scheduling problems for example, Tasgetiren et al. [32] employed the VNS to further improve the performance of Particle Swarm Optimization approach greatly when they solve the PFSPs. In the research of Sevkli and Aydin [33], since the combination of shaking and local search method could influence the performance, they tested various configurations when they attempted to deal with job shop scheduling problems. They indicated that the best shaking scheme may involve three consecutive steps: exchange, insert, and exchange. After the shaking procedure is done, the local search stage may apply two kinds of local heuristics, including the insert and exchange local search. The combination of shaking and local search scheme yields the lowest relative error ratio and the greatest optimum value for hit ratio.When it comes to the combination of EDAs and VNS, Santana et al. [8] could be the first paper to evaluate the synergy of the two optimization algorithms. They defined three possible ways to combine these two methods in solving the protein side chain placement problem. After that, Jarboui et al. [15] proposed the EDAs with VNS, named (EDA-VNS) to solve the PFSPs with minimization of total flowtime. Their probabilistic model considered the order of the job in the sequence and the building blocks of the jobs. In addition, VNS is an improvement procedure as the EDA is run. Jarboui et al. [15] found EDA-VNS was effective in small benchmarks; however, when it comes to larger size problems, VNS is better than EDA-VNS in terms of the objective values and the computational time. It could be worthwhile to examine the reason why EDA-VNS does not outperform the VNS in large size benchmarks.

@&#CONCLUSIONS@&#
This study proposed an ACGA2 which enables the ACGA algorithm to cope with interactions between variables. Both univariate and bi-variate probabilistic models are used in ACGA2 so that the ACGA2 can extract a more accurate problem structure from parental distribution. In addition, this paper gives a theoretical analysis of the two probabilistic models in this paper. ACGA2 and other algorithms were adopted to deal with the single machine scheduling problem with sequence-dependent setup times in a common due date environment. Due to the issue that the previous job impacts the processing time of the next job, there exists strong variable interactions in the problem. As a result, when ACGA2 is compared with ACGA, ACGA2 is superior to ACGA because the average error ratio of ACGA2 is just half the average error ratio of ACGA. It is thus apparent that the bi-variate probabilistic model together with the univariate probabilistic model could gain more information from previous searches for the conditions of sequence-setup times (Fig. 4).Although the bi-variate probabilistic model is useful, some domain-specific heuristics could further improve the solution quality of ACGA2. When ACGA2 is run in combination with DP or SAPT, the two hybrid algorithms are further improved. In particular ACGA2SAPTis state-of-the-art when compared with others in the literature. In future studies, ACGA2 could be used to solve larger-size single machine sequence-dependent scheduling problems than the existing 25-job benchmark problem. Larger size problems could aid in distinguishing the performance of the different algorithms. In this way we could better understand the advantages or disadvantages of the proposed algorithm.