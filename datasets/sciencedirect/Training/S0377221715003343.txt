@&#MAIN-TITLE@&#
Methods for solving the mean query execution time minimization problem

@&#HIGHLIGHTS@&#
It is shown that greedy algorithms can solve efficiently the view selection problem.Several algorithms for the view selection problem are comprehensively compared.Improvements of used algorithms for the view selection problem are considered.The proposed methods can be used to solve the largest problems considered so far.

@&#KEYPHRASES@&#
Decision support systems,Heuristics,OLAP,View materialization,View selection problem,

@&#ABSTRACT@&#
One of the most significant and common techniques to accelerate user queries in multidimensional databases is view materialization. The problem of choosing an appropriate part of data structure for materialization under limited resources is known as the view selection problem. In this paper, the problem of the mean query execution time minimization under limited storage space is studied. Different heuristics based on a greedy method are examined, proofs regarding their performance are presented, and modifications for them are proposed, which not only improve the solution cost but also shorten the running time. Additionally, the heuristics and a widely used Integer Programming solver are experimentally compared with respect to the running time and the cost of solution. What distinguishes this comparison is its comprehensiveness, which is obtained by the use of performance profiles. Two computational effort reduction schemas, which significantly accelerate heuristics as well as optimal algorithms without increasing the value of the cost function, are also proposed. The presented experiments were done on a large dataset with special attention to the large problems, rarely considered in previous experiments. The main disadvantage of a greedy method indicated in literature was its long running time. The results of the conducted experiments show that the modification of the greedy algorithm together with the computational effort reduction schemas presented in this paper result in the method which finds a solution in short time, even for large lattices.

@&#INTRODUCTION@&#
On-Line Analytical Processing (OLAP) is one of the most important technologies applied in modern decision support systems. OLAP provides users with ability to perform on-line, multidimensional analysis requiring the computation of many aggregating functions, frequently on large volumes of data. The query response time is considered as the main measure of system efficiency. Many methods are used to meet the performance demands, beginning from the base OLAP characteristic – the specialized multidimensional structure, through data indexing strategies, partitioning, or query optimizers. One of the common techniques is precomputing (materializing) the part of data cube aggregates. The user queries can retrieve data from prepared structures instead of making all calculations on the fly (Chaudhuri, Dayal, & Narasayya, 2011). The problem of choosing part of data structure for materialization under limited resources is universally known as the view selection problem, or as the warehouse view selection problem when used in designing data warehouses. The solution to this problem is not as simple as materializing the cells which are most frequently requested by users’ queries, since cells are dependent on each other and some may be even not asked at all but their materialization will greatly facilitate calculation of other cells. In general case, the problem of selecting the right part of cube for materialization is NP-hard (Gupta, 1997).To illustrate the concept of using materialized views to answer queries let us consider an example of simple star schema database (Kimball & Ross, 2002), which is derived from O’Neil, O’Neil, and Chen (2009). The schema consists of four dimension tables: CUSTOMER, SUPPLIER, PART and DATE and one fact table: LINEORDER. For simplification, assume that every dimension table has only one attribute, called the same as dimension name and fact table has only one measure Revenue. The database schema is presented in Fig. 1(a). For example, a user may be interested in revenue by customers and parts, which is expressed by the following SQL query:SELECT C.Customer, P.Part, SUM(L.Revenue)FROM dbo.LINEORDER L, dbo.CUSTOMER C, dbo.PART PWHERE L.Customer=C.Customer and L.Part=P.PartGROUP BY C.Customer, P.PartThe query could be answered directly from the schema tables, but if the view grouping data by customers and parts is materialized, it could be used to save time on joins, groupings, and aggregations.The above query could also be answered from the view which groups data by customers, parts, and suppliers (by summing revenue over all suppliers), or from the view which groups data by customers, parts, and dates (by summing revenue over all dates). The lattice framework introduced in Harinarayan, Rajaraman, and Ullman (1996) could be used to describe relations between all possible views which aggregate revenue by attributes from dimension tables. Views are represented as nodes in the lattice diagram. Every edge that connects two views means that a higher view (parent) can be calculated from a lower view (child). More precisely, if ≻ denotes a strong partial order between views,11vi≻vjfor vi≠ vjif and only if vican be answered using only the results of vj– we say that viis calculated from vj.vi≠ vjand vi≻vjthen there is an edge between two views viand vjand there is no vksuch that vi≻vk≻vj, vk≠ viand vk≠ vj.22In fact, in order to have the lattice it is also required that for any two views the least upper bound (supremum) and the greatest lower bound (infimum) must exist. However, after Harinarayan et al. (1996) it is postulated that: (1) there is a partial order between views; (2) there exists one view from which every other view could be determined.All possible views with dependencies between them, for the considered example, are presented in Fig. 1(b). Each view is labelled according to the first letter of attributes in its GROUP BY (and WHERE) clause. The ‘All’ view contains one value which aggregates all the data (note, that it can be computed from any other view). The lowest view is created by joining all dimension tables with a fact table with grouping on all attributes. In this paper, the lowest view is called the base view. Every view could be computed from the base view.The considered problem is as follows: giving the data cube, probability distribution of user queries and maximum space allocated for views materialization, find a set of views for materialization which minimizes the mean response time of user queries. As in most papers (Asgharzadeh Talebi, Chirkova, and Fathi, 2007 and antecedent papers, Asgharzadeh Talebi, Chirkova, and Fathi, 2013; Gupta, Harinarayan, Rajaraman, and Ullman, 1997; Harinarayan et al., 1996; Kalnis, Mamoulis, and Papadias, 2002; Li, Asgharzadeh Talebi, Chirkova, and Fathi, 2005; Shukla, Deshpande, and Naughton, 1998) the analysis is restricted to a data cube, which views form OR view graph (Gupta, 1997; Gupta & Mumick, 2005). The view graph is OR if every parent view can be computed from any of its children (as in the lattice defined above). It is also assumed that each query is always answered from one view (as in Asgharzadeh Talebi et al., 2007 and antecedent papers, Asgharzadeh Talebi et al., 2013; Gupta et al., 1997; Harinarayan et al., 1996; Kalnis et al., 2002; Li et al., 2005; Shukla et al., 1998) and based on that assumption in the rest of the paper the terms query evaluation time and view evaluation time are used interchangeably. When the cube views are described as the lattice, the view selection problem corresponds to selecting nodes from the lattice diagram. As stressed in Harinarayan et al. (1996) the storage space is also a good indicator of the time needed to create the cube.The research presented here was motivated by the conclusions from Asgharzadeh Talebi et al. (2007) and antecedent papers. Intuitively, it may be supposed that for real size problems an exponential algorithm like Branch and Bound performs much worse with respect to the execution time than a polynomial time heuristic like a greedy algorithm. However, from Asgharzadeh Talebi et al. (2007) and antecedent papers it can be learnt that branch and bound actually performs better not only with respect to the quality of solution (which is obvious) but also with respect to the execution time.The specific contributions of the paper are as follows:(i)Different heuristics presented in literature and based on a greedy method are compared with widely used Integer Programming procedures.The numerical experiments presented in the paper were done on large datasets since that minimizes the influence of untypical cases. A special attention was paid to large problems rarely considered in numerical experiments discussed so far in literature.The presented paper is the first one in which different algorithms for the view selection problem are compared comprehensively with the help of performance profiles (Dolan & Moré, 2002).Using the example of the lattice from Karloff and Mihail (1999) it has been shown that the popular greedy algorithm presented in Gupta and Mumick (2005) has no performance guarantee for the discussed view selection problem.Several modifications to the greedy heuristic from Gupta and Mumick (2005) have been proposed to construct the method which is better with the respect to the value of objective function and with respect to the computational time.It has been proved that the greedy heuristic from Asgharzadeh Talebi, Chirkova, and Fathi (2006) has no performance guarantee for the query response time minimization and benefit maximization problems.Two improvement schemas which significantly accelerate methods for solving the view selection problem without sacrificing the goal function results have been proposed (these procedures are up to three orders of magnitude faster after applying the schemas).It has been experimentally shown that the proposed modifications of the greedy algorithm from Gupta and Mumick (2005) (including these mentioned above) lead to the procedure which finds near-optimal solutions in a very short time even for large lattices.

@&#CONCLUSIONS@&#
The paper presents analysis of exact and inexact methods for solving the mean view evaluation time minimization problem. Different heuristics, based on greedy method, presented in literature and standard IP software are compared with the help of performance profiles. Modifications to GreedyG algorithm are proposed, which not only improve its solution cost but also decrease the algorithm running time. Furthermore, two theorems regarding greedy algorithms performance are proved. Additionally, two schemas for reduction of the computational effort are proposed, they tremendously accelerate heuristic as well as optimal algorithms running times without sacrificing the goal function results (these times are up to three orders of magnitude lower after applying the schemas). Arguably, for the first time, the effect of specialized data structure usage on the algorithms computational effort for the view selection problem is discussed. The schema of the search space reduction described in this paper, in contrast to the method from Asgharzadeh Talebi et al. (2007), works for general problems without assumptions regarding a set of possible queries (in particular their method is inapplicable, if all queries from the data cube lattice are possible). The tests presented in this paper have been made on large dataset and that should minimize the influence of untypical cases. Special attention has been paid to large lattices (rarely considered in previous experiments).Although the paper provides the proof that GreedyG algorithm has no worst case performance guarantee for the cost minimization problem, enclosed numerical results show that in practice the proposed modification of GreedyG resulting in GreedyGImp finds near optimal solutions. Moreover, in combination with the proposed improvement schemas it finds solution in time shorter than a few seconds, even for large lattices. GreedyGImp could be used instead of faster heuristics (Kalnis et al., 2002; Shukla et al., 1998) which find solutions with worse mean query execution times.Proof of Theorem 5To prove Theorem 5 the lattice from Fig. A.1is used. There are n ≥ 7 views. The available space S = n − 2, every view has the same probability of being asked (so it is omitted from formulas).At the beginning, every view could be computed from the base view with the cost n − 1. When the view b is chosen for materialization, the views ci, where i = 1, 2, …, n − 2, could be computed from b with cost n − 2. The benefit of b materialization is (for the simplicity of presentation the base view is omitted from the calculations)(A.1)B({b},∅)=(n−1)(n−1)−(n−1)(n−2)=(n−1)(n−1−n+2)=n−1.The benefit of any view cimaterialization is(A.2)B({ci},∅)=(n−1)(n−1)−[(n−2)(n−1)+1]=(n−1)(n−1−n+2)−1=n−2.As the benefit of the view b is the largest, the view b is chosen for materialization by GreedyA. As sb= n − 2 = S GreedyA stops with the solution M = {b}. However, the optimal solution O is to materialize all civiews with the benefit(A.3)B({c1,c2,…,cn−2},∅)=(n−1)(n−1)−[(n−2)1+n−1]=n2−4n+4=(n−2)2.The benefit of M to O is(A.4)B(M,∅)B(O,∅)=n−1(n−2)2<2n<1−1/e2,for n ≥ 7. GreedyG, in contrast to GreedyA, will choose the optimal set of views for the materialization. The benefit of any ciview materialization per unit space is n − 2, whereas benefit of the view b materialization per unit space isn−in−2,where i = 1, 2, …, n − 2 is the iteration number of the algorithm.Let us analyse now GreedyA efficiency for special cases such as data cube lattices. The data cube lattice with m ≥ 5 dimensions, each with only one attribute is considered. It is assumed that views which group data by one attribute have the same cost x ≥ 2 while the views which group data by two attributes have the same cost x2. Generally, the views which group data by i attributes have the cost xi. As every dimension in the considered exemplary lattice contains just one attribute, for every dimension, it is possible to aggregate data by that attribute. As there are m dimensions, there are 2mways of grouping the data (views). For a view which groups data by i attributes, data are already aggregated for m − i dimensions, so there is just i attributes left, for which aggregation is possible. In consequence, there are just 2iviews which can be computed from such views (including views themselves). The number of views which group data by i attributes is equal to the number of ways i attributes can be picked out from m attributes. Furthermore, it is assumed that the space available for materialization is equal to x4. The example of such a lattice is presented in Fig. A.2and the benefits of the views grouping are presented in Table A.1.Let x be such that the sum of the sizes of views grouping data by less than four attributes is less or equal to the size of views grouping data by four attributes:(A.5)1+mx+(m−1)m2x2+(m−2)(m−1)m6x3≤x4.Later in the proof it will be shown that there is an infinite number of x which satisfies inequality (A.5).GreedyA chooses any view which groups data by four attributes with the benefit B(M, ∅) = 16xm− 16x4 as it has the benefit greater than the benefit of any view which groups data by i = {0, 1, 2, 3} attributes:(A.6)24(xm−x4)−2i(xm−xi)=(24−2i)xm−24x4+2ixi=x4[(24−2i)xm−4−16+2ixi−4]≥x4[16−16+2ixi−4]=2ixi>0,since 24 − 2i≥ 8, m − 4 ≥ 1 and x ≥ 2.In the optimal solution all views which group data by less than four attributes are chosen with the benefit(A.7)B(O,∅)=(1+m+(m−1)m2+(m−2)(m−1)m6)xm−(1+mx+(m−1)m2x2+(m−2)(m−1)m6x3).Let us define the following variables:(A.8)z1=1+m+(m−1)m2+(m−2)(m−1)m6=m3+5m+66,z2=1+mx+(m−1)m2x2+(m−2)(m−1)m6x3,then(A.9)B(M,∅)B(O,∅)=16xm−16x4z1xm−z2.According to (A.5)z2 ≤ x4 thus the following holds(A.10)B(M,∅)B(O,∅)≤16xm−16x4z1xm−x4<16z1=96m3+5m+6<(1−1/e)2,for large enough m.□Assume that x ≥ m. Since(A.11)mx+(m−1)m2x2≤x2+(m−1)m2x2=m2−m+22x2<m22x2≤m2x3,then(A.12)1+mx+(m−1)m2x2+(m−2)(m−1)m6x3<1+m2x3+(m−2)(m−1)m6x3=1+m3−3m2+5m6x3.Now, these values of m for which the following inequality is true (with x ≥ m) are determined:(A.13)1+m3−3m2+5m6x3≤m3−3m2+2m5x3.To this end, let us consider the equivalences(A.14)1+5(m3−3m2+5m)30x3≤6(m3−3m2+2m)30x3,1≤6m3−18m2+12m−5m3+15m2−25m30x3,30≤m(m2−3m−13)x3.The smallest integer m for which (m2 − 3m − 13) is positive equals 6. Since by assumption x ≥ m, inequality (A.14) is true for any m ≥ 6. From (A.12) and (A.13) one can get(A.15)1+mx+(m−1)m2x2+(m−2)(m−1)m6x3<(m−2)(m−1)m5x3.Inequality (A.5) is surely true when the following inequality is true(A.16)(m−2)(m−1)m5x3≤x4.Inequality (A.16) is satisfied ifx≥(m−2)(m−1)m5. There is an infinite number of such x. Notice that for m = 5, inequality (A.5) is true for any x ≥ 11.□In contrast to GreedyA, GreedyG chooses the optimal solution. It can be proved by dividing the benefit of the view chosen by GreedyA per unit space, i.e.,24(xm−x4)x4,by a benefit of a view which groups data by i = {0, 1, 2, 3} attributes, i.e.,2i(xm−xi)xi(see Table A.1):(A.17)242i(xm−x4)xi(xm−xi)x4=24−i(xm−x4)(xm−xi)xi−4=xm−x4xm−xixi−42i−4=xm−x4xm−xi(x2)i−4<1,asxm−x4xm−xi<1,x2≥1and(x2)i−4≤1.Note that it does not mean that GreedyG always finds a set of views with the benefit greater than GreedyA does. There are cases where GreedyG solution has the benefit lesser than GreedyA solution.Proof of Theorem 6To prove Theorem 6 consider the lattice example from Karloff and Mihail (1999) (Fig. B.1). Each branch of the lattice hasN=n−44nodes where n ≥ 20 is some natural number. The available space S = 4, every view has the same probability of being asked (so it will be omitted from formulas) and it is not possible to use more space than is available for the materialization.At the beginning every view could be computed from the base view with the cost 36N. The lattice has 4N + 4 views, so the total cost is(B.1)∑i=14N+436N=(4N+4)36N.When a1 is chosen for the materialization the views ci1 and ci2, where i = 1, 2, …, N, are calculated from a1 instead of from the base view with the cost 2. When a2 is chosen it has the same benefit as a1. The benefit from the a1, or a2 materializations per space occupied by that views is:(B.2)B({a1},∅)sa1=B({a2},∅)sa2=36N−22(2N+1).When b is chosen for the materialization the views ci2 and ci3, where i = 1, 2, …, N, are calculated from b instead of from the base view, with the cost 1. The benefit from b materialization per its space is:(B.3)B({b},∅)sb=36N−11(2N+1).When any view cij, where i = 1, 2, …, N, j = 1, 2, 3, 4, is chosen only the cost of that view will be reduced from 36N to 1, so the benefit from any cijmaterialization per its space is:(B.4)B({cij},∅)scij=36N−11,wherei={1,2,…,N},j={1,2,3,4}.The view b has the maximum benefit per unit space, so it is chosen for the materialization by GreedyG. In the second iteration of the algorithm, the views will have the following benefits from their materializations:(B.5)B({a1},{b})sa1=B({a2},{b})sa2=36N−22(N+1),(B.6)B({cij},{b})scij=36N−11,wherei={1,2,…,N},j={1,4},(B.7)B({cij},{b})scij=1−11=0,wherei={1,2,…,N},j={2,3}.The second choice could be a1 or a2, and it is assumed that the view a1 is chosen. In the third iteration, only 1 unit of available space is left, so only cijviews could be chosen:(B.8)B({cij},{b,a1})scij=2−11=1,wherei={1,2,…,N},j={1},(B.9)B({cij},{b,a1})scij=1−11=0,wherei={1,2,…,N},j={2,3},(B.10)B({cij},{b,a1})scij=36N−11=36N−1,wherei={1,2,…,N},j={4}.The third choice will be one of ci4 views, and it is assumed that the view c14 is chosen. To sum up GreedyG choice is M = {a1, b, c14}. The optimal solution is O = {a1, a2}.The benefit of M to O is quite good, always greater than12:(B.11)B(M,∅)B(O,∅)=(36N−1)(2N+1)+(36N−2)(N+1)+(36N−1)(36N−2)(4N+2)=4(N+1)(27N−1)4(2N+1)(18N−1)>N+12N+1=(2N+1)+12(2N+1)=12+12(2N+1)>12,but the ratio of the cost found by GreedyG to the optimal cost (sets M and O) is always greater thann+412:(B.12)∑i∈Icosti(M)∑i∈Icosti(O)=36N(N+1)+2(N+1)+1(2N+2)36N(2)+2(4N+2)=4(N+1)(9N+1)4(20N+1)>N+23=n+412.□Note that GreedyA chooses exactly the same set of views as GreedyG, so Theorem 6 is also valid for GreedyA.