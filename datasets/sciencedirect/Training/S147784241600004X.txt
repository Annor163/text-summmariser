@&#MAIN-TITLE@&#
Domains: Sharing state in the communicating event-loop actor model

@&#HIGHLIGHTS@&#
The domain model is an extension to the communicating event-loop actor model.The domain model retains the safety and liveness properties of the actor model.We provide an operational semantics and validation of the domain model.

@&#KEYPHRASES@&#
Actor model,Domains,Synchronization,Shared state,Race-free mutation,

@&#ABSTRACT@&#
The actor model is a message-passing concurrency model that avoids deadlocks and low-level data races by construction. This facilitates concurrent programming, especially in the context of complex interactive applications where modularity, security and fault-tolerance are required. The tradeoff is that the actor model sacrifices expressiveness and safety guarantees with respect to parallel access to shared state.In this paper we present domains as a set of novel language abstractions for safely encapsulating and sharing state within the actor model. We introduce four types of domains, namely immutable, isolated, observable and shared domains that each is tailored to a certain access pattern on that shared state. The domains are characterized with an operational semantics. For each we discuss how the actor model׳s safety guarantees are upheld even in the presence of conceptually shared state. Furthermore, the proposed language abstractions are evaluated with a case study in Scala comparing them to other synchronization mechanisms to demonstrate their benefits in deadlock freedom, parallel reads, and enforced isolation.

@&#INTRODUCTION@&#
In practice, the actor model is made available either via dedicated programming languages (actor languages) or via libraries in existing languages. Actor languages are mostly pure, in the sense that they usually enforce strict isolation of actors: the state of an actor is fully encapsulated, cannot leak, and asynchronous access to it is enforced. Examples of pure actor languages include Erlang [1], SALSA [2], E [3], AmbientTalk [4], and Kilim [5]. The major benefit of pure actor languages is that the developer gets strong safety guarantees: low-level data races are ruled out by design. The downside is that this strict isolation severely restricts the way in which access to shared resources can be expressed.At the other end of the spectrum, we find actor libraries, which are often built on top of a shared-memory concurrency model. For Java alone, examples include ActorFoundry [6], Actor Architecture [7], ProActive [8], AsyncObjects [9], JavAct [10], Jetlang [11], and AJ [12]. Scala, which inherits shared-memory multithreading as its standard concurrency model from Java, features multiple actor frameworks, such as Scala Actors [13] and Akka [14]. These libraries have in common that they do not enforce actor isolation, i.e., they cannot guarantee that actors do not share mutable state. There exist techniques to circumvent this issue. For example, it is possible to extend the type system of Scala to guarantee data-race freedom [15]. However, it is easy for a developer to use the underlying shared-memory concurrency model as an “escape hatch” when direct sharing of state is the most natural or most efficient solution. Once the developer chooses to go this route, the benefits of the high-level actor model are lost and the developer typically has to resort to other ad hoc synchronization mechanisms to prevent data races.A recent study [16] has shown that 56% of the examined Scala programs use actors purely for concurrency in a non-distributed setting. That same study has shown that in 68% of those applications, the programmers’ mixed actor library constructs with other concurrency mechanisms. When asked for the reason behind this design decision, one of the main motivations’ programmers brought forward was inadequacies of the actor model, stating that certain protocols are easier to implement using shared-memory than using asynchronous communication mechanisms without shared state.In conclusion, pure actor languages are often more strict, which allows them to provide strong safety guarantees. The downside is that they often restrict the expressiveness when it comes to modeling access to a shared resource while impure actor libraries are more flexible at the cost of some of those safety guarantees.The goal of this work is to enable safe and expressive state sharing among actors in a pure actor language. In this paper, we study the actor model only with the aim of applying it to improve shared-memory concurrency. We do not consider applications that require actors to be physically distributed across machines. In addition, while our approach applies to a wide variety of actor models, in this paper we focus on the Communicating Event-Loop Actor Model (CEL Actor Model) [3] specifically (see Section 2). To achieve this goal, we aim to relax the strictness of the event-loop model via the controlled use of novel language abstractions. We aim to improve state sharing among actors on two levels:SafetyThe isolation between actors enforces a structure on programs and thereby facilitates reasoning about large-scale software. Consider for instance a plug-in or component architecture. By running plug-ins in their own isolated actors, we can guarantee that they do not violate certain safety and liveness invariants of the “core” application. Thus, as in pure actor languages, we seek an actor system that maintains strong language-enforced guarantees and prevents low-level data races and deadlocks by design.Many phenomena in the real world can be naturally modeled using message-passing concurrency, for instance telephone calls, e-mail, digital circuits, and discrete-event simulations. Sometimes, however, a phenomenon can be modeled more directly in terms of shared state. Consider for instance the scoreboard in a game of football, which can be read in parallel by thousands of spectators. As in impure actor libraries, we seek an actor system in which one can directly express access to shared mutable state, without having to encode shared state as encapsulated state of a shared actor. Furthermore, by enabling direct synchronous access to shared state, we gain stronger synchronization constraints and prevent the inversion of control that is characteristic for interacting with actors using asynchronous message-passing.This work extends and unifies the language abstractions presented in De Koster et al. [17] and De Koster et al. [18] in a novel programming model. This unified programming model was formalized in an operational semantics (see Appendix A) and serves as a platform for experimenting with new language abstractions expressing shared state within the actor model. Our validation shows the usefulness of our language abstractions based on a case study in Scala (see Section 5).This paper is structured as follows. Section 2 introduces the Communicating Event-Loop Actor Model and Shacl[19], a communicating event-loop actor language developed as a platform for experimenting with new language features. Section 3 shows the lack of good abstractions to represent shared resources in modern actor systems by giving an overview of the drawbacks of common techniques to represent shared state in the communicating event-loop model. Section 4 presents the taxonomy that led to the design of four distinct types of domains, namely immutable, isolated, observable, and shared domains. Subsequently each of the different types of domains and their use in Shacl is discussed. Section 5 validates the usefulness of the domain model. We start with a survey of synchronization patterns used by developers in existing open-source Scala projects and then compare these patterns with our domain abstractions. Section 6 discusses related work and Section 7 concludes this paper.The communicating event-loop (CEL) model: The CEL model was originally intended as an object-oriented programming model for secure distributed computing [3]. The goal of our Domain Model is to increase the expressiveness of the CEL model in a shared-memory context by allowing safe access to shared state. In the CEL model an actor is represented by a vat. Throughout this paper the terms actor, event-loop actor and vat are used interchangeably and always refer to “actors” as defined by the CEL model. As shown in Fig. 1, each vat has a single thread of control (the event-loop), a heap of objects, a stack, and an event queue. Each object in a vat׳s object heap is owned by that vat and those objects all share the same event-queue and event-loop. This means that vats are strictly isolated from one another.Within a vat, references to objects owned by that same vat are called near references. Those references can be used as in traditional object-oriented programming to directly invoke methods on the referenced object. Throughout the rest of this paper this is referred to as sending a synchronous message. The most distinguishing difference between communicating event-loops and traditional actor models is that traditional actors provide only a single entry point or address for each actor, and thus are first class. In the CEL model vats are not first class entities, i.e. an object cannot hold a reference to a vat. Rather objects can hold references to objects owned by other vats and those references are called far references. Such a reference can be used as the target for asynchronous communication. An asynchronous message sent to a far reference is enqueued as an event in the event-queue of the actor that owns the target object. Eventually that event will be processed by the event-loop of that vat by forwarding the message to the target object (i.e. directly invoking the method). Processing a single message is called a turn. The fact that objects can hold far references to objects owned by another vat does not break actor isolation. Any asynchronous message sent to a far reference will eventually be processed by the owner of the receiver object.The ShaclLanguage: A Shacl VM is started with a single “main actor”. All input expressions from the read-eval-print loop (REPL) are evaluated as a single turn of that main actor. Other actors are created by means of the actor primitive. Listing 1 illustrates how to create an actor in Shacl. When an actor is created, it is initialized with a new event-loop, object heap and event queue. The event queue is initially empty. The object heap initially hosts a single object which is said to be the actor׳s behavior. In this example, the object defines a single method, namely say_hello. The actor that created the new actor, in this case the main actor, gets back a far reference to that behavior object.Listing 1Hello World actor in Shacl.On Line 1, the main actor gets back a far reference to the newly created actor and stores it in the variable a. On Line 5, it uses that far reference to send an asynchronous message to the newly created actor.Synchronous communication: The event-loop of an actor can only process synchronous messages (using the dot notation o.m()) when the receiver object is owned by the actor that is processing that message. In other words, an actor can only send synchronous messages to near references. Any attempt to synchronously access a far reference is considered to be an erroneous operation and will throw a runtime exception.Asynchronous communication: Actors in Shacl are not first class entities and do not send messages to each other directly. Instead, objects owned by different actors send asynchronous messages to each other using far references to objects owned by another actor (using the arrow notationo<−m()). An asynchronous message sent to an object in a different actor is enqueued in the event queue of the actor that owns the receiver object. The thread of execution of that actor is an event-loop that perpetually takes one event (i.e. a queued message send) from its event queue and delivers it to the local receiver object. Hence, events are processed one by one. The processing of a single event is called a turn. An important note is that Shacl guarantees message ordering on the outgoing messages towards a single actor. Messages sent from one actor to another will be received in the same order as sent. There are no ordering guarantees on messages sent to multiple distinct actors.All arguments to an asynchronous message are evaluated before that message is enqueued in the event queue of the receiver actor. Immediate values such as booleans, numbers and strings are sent as a near reference to the receiver actor. Any composite value such as tables, closures or objects are passed by far reference. At the receiver׳s side there is an extra resolution step to check whether any of the far references are pointing to objects that are owned by the receiver. In this case, the far reference is resolved to a near reference on the receiver side. Note that this is done only on the receiver side, the sending actor still only holds a far reference to that object. In conclusion, any reference to a composite value that is owned by another actor is always a far reference. All other references are always near references.The isolated turn principle: An important benefit of the semantics of the original actor model is that it enables a macro-step semantics[20]. With the macro-step semantics, the actor model provides an important property for formal reasoning about program semantics, which also provides additional guarantees to facilitate application development. The macro-step semantics says that in an actor model, the granularity of reasoning is at the level of a turn, i.e., an actor processing a message from its inbox. This means that a single turn can be regarded as being processed in a single isolated step. Throughout the rest of this paper we refer to this principle as the isolated turn principle. The isolated turn principle leads to a convenient reduction of the overall state-space that has to be considered in the process of formal reasoning. Furthermore, this principle is directly beneficial to application programmers, because the amount of processing done within a single turn can be made as large or as small as necessary, which reduces the potential for problematic interactions. In other words, this principle guarantees that, during a single turn, an actor has a consistent view over the whole program environment. Furthermore, the principle guarantees that the actor model, in this case the CEL model, is free of low-level data races. However, as the actor model only guarantees isolation within a single turn, high-level race conditions can still occur with bad interleaving of different messages. The general consensus when programming in an actor system is that when an operation spans several messages the programmer must provide a custom synchronization mechanism to prevent bad interleavings and ensure correct execution.If we want to model a shared resource in a pure actor system it must be represented either by replicating the shared resource over the different actors or by encapsulating the shared resource in an additional independent delegate actor. When replicating shared state over the different actors write operations on that shared state typically need to be propagated to the different actors by means of an ad hoc consistency protocol. Additionally, replication increases the memory usage with the amount of shared state and the number of actors. Depending on the granularity with which actors are created, this might incur a memory overhead that is too high. These drawbacks make replicating the shared state a rarely chosen option among software developers (see Section 5). The most common approach for representing shared state in pure actor systems is by encapsulating the shared state in a separate delegate actor. As a result, any actor that wants to access the shared resource is forced to use asynchronous message passing. There are however four different classes of problems when using this approach: the code is fragmented by the enforced continuation-passing style, read access to the shared resource cannot be parallelized, message-level deadlocks as well as race conditions can occur.In this section we discuss these four issues using the example in Listing 2. On Line 1 we define a mutable cell as an actor with one field, content, and two messages namely get and put. In this example, we define a client as an actor that first sends a get message to retrieve the value of the cell and when it receives a reply, sends a put message to increment that value in the cell by one.Listing 2A shared counter represented by a delegate actor.Using a distinct actor to represent conceptually shared state implies that this resource cannot be accessed directly from any other actor since all communication happens asynchronously within the actor model. Thus, the interface with which to access the shared resource now becomes asynchronous rather than synchronous. This implies the introduction of explicit request–reply-style communication, where the continuation of the request must be turned into a callback. The style of programming where the control of the program is passed around explicitly as a continuation is called continuation-passing style (CPS). The problem with this style of programming is that it leads to “inversion of control” [21].In the example in Listing 2 we see that every time the client wants to retrieve the value of the mutable cell, an extra customer parameter needs to be provided. This parameter expects an object that models the continuation of our program provided a callback message, namely reply. Consequently, the code that is responsible for incrementing the value of the cell is fragmented over the different callbacks. If that callback would contain another invocation of the get message, another callback has to be made. Every time this is done, another level of CPS is introduced.Future-type messages: Many actor languages include future-type messages to overcome this issue of code fragmentation when using callbacks. While typically, asynchronous messages do not have a return value, future-type messages return a future. That future is a placeholder for the return value of the asynchronous message. Once the message is processed, the future is resolved with the return value of the message.In Shacl, every asynchronous message send is a future-type message send and returns a future. Listing 3 illustrates the use of future-type messages in Shacl. We use the return value of the message on Line 1 to store a reference to a future in the future variable. Note that the extra customer callback parameter has disappeared as this parameter becomes implicit when using futures. Once the get message is processed by the actor that owns the cell object, that future will be resolved. On Line 2, the when_resolved primitive is used to register a closure that needs to be called when the future is resolved.Listing 3A future-type message in Shacl.To maintain the isolated turn principle, two conditions must be met when implementing future-type messages. On one hand, accessing that future-value has to be an asynchronous operation. Otherwise we would introduce a blocking operation, potentially reintroducing deadlocks. On the other hand, when the future is resolved, the registered closure has to be executed during its own isolated turn. Following from the isolated turn principle, turns cannot be interleaved, because interleaving would introduce low-level race conditions.Registering a closure using the when_resolved primitive is done explicitly. This forces the programmer to apply CPS. The registered closure then represents the continuation of the program given the return value of the message. Once the future is resolved an event that is responsible for calling the closure is scheduled in the event queue of the actor that issued the request. Thus guaranteeing that the closure is called in its own turn.Using future-type messages prevents code fragmentation because the callback can be scheduled immediately after sending the message. Additionally, there are techniques to avoid CPS programming by moving the CPS transformation into the compiler (e.g., C# and Scala assync and await[22,23]). What is worse is that the operation on our shared resource now spans several turns. Meaning that we can only benefit from the isolated turn principle for each individual turn, but not for the entire operation. Ideally we would like to have synchronous access to the shared resource for the duration of a whole turn to avoid for instance message-level race conditions.State that is shared by using a delegate actor can never be read truly in parallel because all accesses to the shared resource are sequentialized by the inbox of the delegate actor. Each request to read (part of) the delegate actor׳s state is taken out of the inbox and processed one by one. Furthermore, current actor systems do not parallelize reads, even though it would be safe to do so. Other researchers have identified this drawback of the actor model and there exist extensions to the actor model that allow for parallel execution of read-only operations [24].The traditional actor model does not allow specifying extra synchronization conditions on multiple compound operations. Messages from a single sender are usually processed in the same order as they were sent. However, the order in which messages from different senders are handled is nondeterministic. This means that messages from different senders can be arbitrarily interleaved. Bad interleaving of the different messages can potentially lead to message-level race conditions. In Listing 2, the asynchronous messages sent by the client on lines 9 and 12 can be interleaved with get and put messages of other actors, potentially causing a race condition. This type of high-level race condition is typically avoided by increasing the amount of operations in a single turn, i.e., coarsening it up. For example, by introducing an increment message that adds a given value to the cell in a single isolated turn. Generally, bad interleaving of messages occurs because different messages, sent by the same actor, cannot always be processed synchronously. Programmers cannot specify synchronization conditions on batches of messages. Therefore, a programmer is limited by the smallest unit of non-interleaved operations provided by the interface of the delegate actor he is using and there are no mechanisms provided to eliminate unwanted interleaving without changing the implementation of the delegate actor, i.e., there are no means for client-side synchronization.The full operational semantics is built in four steps. In Appendix A.2 we build an operational semantics for a regular communicating event-loop language. Isolated domains are interchangeable with the object heap of a traditional event-loop actor as they have equivalent properties. Thus, in the first version, the object heaps of actors are already replaced with the associated isolated domains. In the subsections that follow we extend the operational semantics with immutable, observable and shared domains. Each extension of the semantics can be done with minimal changes to the original rules. If a semantic rule is replaced this will be announced in the text.In this subsection we start off by modeling a small event-loop actor model. This first version models objects, actors, event-loops, and object heaps. The object heap of an actor is modeled as isolated domains. The addition of isolated domains is not visible in the syntax as no syntax was added for creating new isolated domain. However, the fact that object heaps are already separated from actors allows us to extend these semantics with additional domains with minimal changes to the existing rules. It also allows for a uniform definition of object ownership.Fig. A1lists the different semantic entities of Shacl-Lite. Calligraphic letters likeAandMare used as “constructors” to distinguish the different semantic entities syntactically instead of using “bare” cartesian products. Actors, domains, and objects each has a distinct address or identity, denotedιa,ιdandιorespectively (Fig. A2).In Shacl-Lite a Configuration consists of a set of live actors, A and a set of domains, D. A single configuration represents the whole state of a Shacl-Lite program in a single step. In Shacl-Lite each Actor has an identityιa. Currently the only type of domain that is represented is the Isolated domain, I. All actors are associated with a single isolated domain with the same identity as the actor. This isolated domain represents the actor׳s heap. This design decision makes it so that all objects belong to a certain domain and that accessing these objects can be uniformly defined. Because each actor is associated with a single domain (the one with the same Id as the actor, i.e.,ιa=ιd), the set of isolated Ids is a subset of the set of domain Ids. Each actor also has a queue of pending messages Q, and the expression e it is currently evaluating, i.e., reducing. An Object has an identityιo, a set of fields F, and a set of methods M. An asynchronous Message holds a reference r, to the object that was the target of the message, the message identifier m, and a list of valuesv¯, that were passed as arguments. The Queue used by the event-loop of an actor is an ordered list of pending messages. A Method has an identifier m, a list of parametersx¯, and a body e. A Field consists of an identifier f, that is bound to a value v. Values can either be a reference r or null. A reference identifies an object located within a certain domain. In this version of the semantics only isolated domains exist.Syntax: Shacl-Lite features both functional and object-oriented elements. It has anonymous functions(λx.e)and function invocation(e(e¯)). Local variables can be introduced with a let statement. Objects can be created with the object literal syntax. Objects may be lexically nested and are initialized with a number of fields and methods. Those fields can be updated with new values and the object׳s methods can be called both synchronously(e.m(e¯))and asynchronously(e←m(e¯)). In the context of a method, the pseudo-variable this refers to the enclosing object. this cannot be used as a parameter name in methods or redefined using let. New actors can be spawned using the actor literal expression. This creates a fresh actor that is linked with a fresh isolated domain by sharing the same identifier. This isolated domain is instantiated with a single new object, with the given fields and methods, in its heap. The newly created actor executes in parallel with the other actors in the system. Expressions contained in actor literals may not refer to lexically enclosing variables, apart from the this pseudo-variable. That is, all variables have to be bound except this, which meansFV(e)⊆{this}needs to hold for all field initializer and method body expressions e. Because these expressions do not contain any free variables, actors and domains are isolated from their surrounding lexical scope, making them self-contained.Runtime syntax: Our reduction rules operate on so-called run-time expressions; these are a superset of source-syntax phrases. The additional forms represent references, r, and object literals that are annotated with the domain identifier of their lexically enclosing domain. This annotation is required so that upon object creation each object gets associated with the appropriate domain.Evaluation contexts: We use evaluation contexts [40] to indicate what subexpressions of an expression should be fully reduced before the compound expression itself can be further reduced.e□denotes an expression with a “hole”. Each appearance ofe□indicates a subexpression with a possible hole. The intent is for the hole to identify the next subexpression to reduce in a compound expression.Syntactic sugar: Anonymous functions are translated to objects with one method named apply. Note that the pseudovariable this is replaced by a newly introduced variable xthisso that this still references the surrounding object in the body-expression of that anonymous function. Applying an anonymous function is the same as invoking the method apply on the corresponding object.Substitution rules: Fig. A3lists the different rules for propagating variable/value substitutions. For completeness, the substitution rules for the different domains have already been included at this stage. In most cases the variable is substituted by the value within the different subexpressions of the compound expression. Expressions contained in the actor literal and the different domain literals have to be lexically closed, this means that subexpressions are not substituted.Tagging rules: Every object literal is tagged at runtime with the identifier of its lexically enclosing domain,ιd, using theobjectιdruntime syntax. Fig. A4lists a number of rules on how this tag is propagated through the different subexpressions. Any compound expression simply propagates the substitution to its subexpressions except for the actor literal and the different domain literals.Notation: Actor heaps O are sets of objects. To lookup and extract values from a set O, we use the notationO=O′{o}. This splits the set O into a singleton set containing the desired object o and the disjoint setO′=O⧹{o}. The notationQ=Q′·mdeconstructs a sequence Q into a subsequenceQ′and the last element m. In Shacl-Lite, queues are sequences of messages and are processed right-to-left, meaning that the last message in the sequence is the first to be processed. We denote both the empty set and the empty sequence using ∅. The notatione□[e]indicates that the expression e is part of a compound expressione□, and should be reduced first before the compound expression can be reduced further.Any Shacl-Lite program represented by expression e is run using the initial configuration:K〈{A〈ιa,∅,〚e〛ιa〉},{I〈ιa,∅}〉The initial configuration contains a main actor and its associated empty isolated domain. Every lexically nested object expression in the program is annotated with the domain identifier of the main isolated domain using the〚e〛ιasyntax.Actor-local reductions: Actors operate by perpetually taking the next message from their message queue, transforming the message into an appropriate expression to evaluate, and then evaluating (reducing) this expression to a value. When the expression is fully reduced, the next message is processed.If no actor-local reduction rule is applicable to further reduce a reducible expression, i.e., when the reduction is stuck, this signifies an error in the program. The only valid state in which an actor cannot be further reduced is when its message queue is empty, and its current expression is fully reduced to a value. A value cannot be further reduced and the actor sits idle until it receives a new message.We now summarize the actor-local reduction rules in Fig. A5:•let: Reducing a “let”-expression simply substitutes the value of x for v in e.process-message: this rule describes the processing of incoming asynchronous messages directed at local objects. A new message can be processed only if two conditions are satisfied: the actor׳s queue Q is not empty, and its current expression cannot be reduced any further (the expression is a value v).invoke: a method invocation simply looks up the method m in the receiver object (belonging to some domain) and reduces the method body expression e with appropriate values for the parametersx¯and the pseudovariable this. It is only possible for an actor to invoke a method on an object within its associated isolated domain (with the same domain identifier,ιa).field-access, field-update. It is only possible for an actor to access or update a field of an object within its associated isolated domain. A field update modifies the owning domain׳s heap so that it contains an object with the same address but with an updated set of fields.congruence: this rule simply connects the actor local reduction rules to the global configuration reduction rules.Rules for object and actor literals: We summarize the creation reduction rules in Fig. A6:•new-object: An object expression can only be reduced once its field initialization expressions have been reduced to a value. All object expressions are tagged with the domain id of the lexically enclosing domain. The effect of reducing an object literal expression is the addition of a new object to the heap of that domain. The literal expression reduces to a domain reference r to the new object.new-actor: when an actorιareduces an actor literal expression, a new actorιa′is added to the set of actors of the configuration. A newly created isolated domain is associated with that actor. The new domain׳s heap consists of a single new objectιowhose fields and methods are described by the literal expression. The〚e〛ιdsyntax makes sure that all lexically nested object expressions are tagged with the domain id of the newly created domain. The actor literal expression reduces to a domain reference to the new object, allowing the actor that created the new actor to communicate further with that actor.Asynchronous communication reductions: We summarize the asynchronous communication reduction rules in Fig. A7:•local-asynchronous-send: an asynchronous message sent to a local object (i.e., an object owned by the isolated domain of the sender) simply appends a new message to the end of the actor׳s own message queue. The message send itself immediately reduces to null.remote-asynchronous-send: this rule describes the reduction of an asynchronous message send expression directed at a remote isolated reference, i.e., an isolated domain reference whoseιa′is the same as another actor in the system. A new message is appended to the queue of the recipient actorιa′(top part of the rule). As in the local-asynchronous-send rule, the message send expression itself evaluates to null.An immutable domain is an object heap of immutable objects. Each lexically nested object expression will reduce to an object that belongs to that immutable domain. This is achieved by the tagging rules as described in Appendix A.2.3. Immutability of objects owned by an immutable domain is achieved by not specifying a reduction rule for updating the field of an object owned by an immutable domain. The addition of immutable domains does not alter any of the existing reduction rules (Fig. A8).The set of domains is extended with the set of immutable domains. An Immutable domain has an identifier,ιcand an object heap. ImmutableId and IsolatedId are a distinct subset of DomainId (Fig. A9).The Shacl-Lite syntax is extended with syntax to create new immutable domains. Similar to the object syntax, the field initializer expressions of an isolated domain expression need to be reduced to a value from left to right before the isolated domain literal can be further reduced. An additional evaluation context was added to specify this behavior.Actor-local reductions: We summarize the actor-local reduction rules in Fig. A10:•immutable-invoke: Similar to a method invocation on an isolated domain reference, the method m is simply looked up in the receiver object (belonging to some domain) and reduces the method body expression e with appropriate values for the parametersx¯and the pseudovariable this. However, in this case any actor can invoke a method on an immutable domain reference, regardless of the identifier of the domain.immutable-field-access. Any actor can access a field of an immutable domain object. The object is looked up in the appropriate immutable domain and the field access is reduced to the associated value.immutable-field-update. There is no rule specified for field updates on immutable domain references. A field update expression on an immutable domain reference will not be further reduced and lead to a stuck state.Rules for object and immutable domain literals: We summarize the immutable domain creation reduction rules in Fig. A11:•new-immutable-object: An object expression can only be reduced once its field initialization expressions have been reduced to a value. The effect of reducing an object literal expression is the addition of a new object to the heap of the immutable domain. The literal expression reduces to a domain reference r to the new object.new-immutable-domain: A domain literal will reduce to the construction of a new immutable domain with a single object in its heap. That domain is added to the set of domains in the configuration. Similar to the rule for new-object, the immutable domain expression can only be further reduced once its field initialization expressions have been reduced to a value. The domain expression reduces to an immutable domain reference r to the newly created object.〚e〛ιcdenotes a transformation that makes sure that all lexically nested object expressions are annotated with the domain id of the newly created domain.Asynchronous communication reductions: We summarize the asynchronous communication reduction rule in Fig. A12:•immutable-asynchronous-send: an asynchronous message sent to an immutable object simply appends a new message to the end of the sender׳s own message queue. The asynchronous message send itself immediately reduces to null.An observable domain object is synchronously readable by every actor as long as they have obtained a reference to that object. To ensure that the isolated turn principle remains valid, any actor always reads values from a consistent snapshot of the object heap of an observable domain. That snapshot is stored in the semantic function, f. The addition of observable domains alters the reduction rule for processing messages, process-message, such that each actor takes a snapshot of the various observable domains at the start of a turn and commits any changes made at the end of a turn (Fig. A13).The set of domains is extended with the set of observable domains. An Observable domain has an identifier(ιb)and an identifier that specifies the owner of the domain(ιa). It also has a semantic function, f, that maps actor identifiers to a temporary snapshot of the object heap of the observable domain. Each time an actor accesses an observable domain, that actor will read from that snapshot. Lastly, it has an object heap, O, that represents the latest consistent version of the objects in the domain. ImmutableId, IsolatedId and ObservableId are distinct subsets of DomainId (Fig. A14).The Shacl-Lite syntax is extended with a new syntax expression to create new observable domains. Additional runtime syntax was added to ensure that an actor commits any changes made to its observable domains at the end of each turn. Similar to the object syntax, the field initializer expressions of an observable domain expression need to be reduced to a value from left to right before the observable domain literal can be further reduced. An additional evaluation context was added to specify this behavior.Actor-local reductions: We summarize the actor-local reduction rules in Fig. A15:•process-message: this rule replaces the rule for processing messages in Fig. A5. A new message can be processed only if two conditions are satisfied: the actor׳s queue Q is not empty, and its current expression cannot be reduced any further (the expression is a value v). The processing of an asynchronous message reduces to a synchronous method invocation followed by the runtime syntax commit. The most important change is that before the start of the turn, first a snapshot is taken of any domain which is not owned by the actor using the auxiliary snapshot function. While reducing the synchronous method invocationιa.ιo.m(v¯), any field access to an observable domain reference will be looked up using that snapshot.commit: The runtime syntax commit is always the last expression that needs to be reduced before the end of a turn. The reduction of this rule replaces all the object heaps of the observable domains owned by the actor in D with its own local copy using the auxiliary commit function.observable-invoke: In the case of method invocation, the method m is looked up in the copy of the object that is located in the snapshot of the observable domain,f(ιa). Note that the owner of the domain,ιa′, does not necessarily need to be the same as the actor that is invoking the method,ιa. Any actor can invoke a method on an observable domain reference, regardless of the owner of the domain. A method invocation reduces the method body expression e with appropriate values for the parametersx¯and the pseudovariable this.observable-field-access. Similar to method invocation, the field is looked up in the copy of the object that is located in the snapshot of the observable domain,f(ιa). Any actor can access a field of an observable domain object.observable-field-update. A field update to an observable domain reference can only be reduced if the owner of the observable domain is the same as the actor performing the update. Note that the field is only updated in the local snapshot that the actor has of the domain׳s heap. Any field updates are only propagated to the observable domain׳s heap at the end of a turn when the actor commits.Rules for object and observable domain literals: We summarize the immutable domain creation reduction rules in Fig. A16:•new-observable-object: An object expression can only be reduced once its field initialize expressions have been reduced to a value. The effect of reducing an object literal expression is the addition of a new object to the actor׳s local snapshot of the heap of the observable domain. The literal expression reduces to a domain reference r to the new object.new-observable-domain: A domain literal will reduce to the construction of a new observable domain with the current actor,ιaas its owner and with a single object in its heap. That domain is added to the set of domains in the configuration. Similar to the rule for new-object, the observable domain expression can only be further reduced once its field initialize expressions have been reduced to a value. The domain expression reduces to an observable domain reference r to the newly created object. The〚e〛ιdsyntax makes sure that all lexically nested object expressions are tagged with the domain id of the newly created domain.Asynchronous communication reductions: We summarize the asynchronous communication reduction rules in Fig. A17:•observable-asynchronous-send: this rule describes the reduction of an asynchronous message send expression directed at an observable reference. A new message is appended to the queue of the owner of the observable domainιa′(top part of the rule). The message send expression itself evaluates to null.Auxiliary functions: The auxiliary function snapshot ensures that at the start of a turn an actor takes a snapshot of each observable domain by storing a copy of its object heap. The first rule takes a new snapshot,f[ιa→O], of the latest version of the object heap, O, for any observable domain and recursively calls snapshot on the remaining domains. The second rule just returns the leftover set of domains, D, if all observable domains have been visited.The auxiliary function commit ensures that at the end of a turn any changes made to domains owned by the actor during that turn are committed. The first rule replaces the object heap, O, of any observable domain owned by the actor,ιawith the snapshot stored in the semantic function,f(ιa), and recursively calls commit on the remaining domains. The second rule just returns the leftover set of domains, D, if all observable domains owned by the actor have been visited.Objects owned by a shared domain can be accessed by any actor in the system given they have obtained a reference to that object. However, before an actor can read from and write to a shared domain object it first needs to obtain a view on the associated shared domain. A view is processed in its own turn and is called a notification. Adding shared domains does not change any of the existing reduction rules (Fig. A18).The set of domains is extended with the set of shared domains. A Shared domain has an identifier,ιs, a single Access Modifierl (or lock), a set of actor ids, S, that currently have shared access to the domain and a set of actor ids, E, that currently have exclusive access to the domain. It also has a set of pending view requests, R, and its object heap, O. A pending Request has a referenceιa, to the actor that placed the request, the type of request, t, and an expression e, that will be reduced in the context of a view once the domain becomes available. The Type of a request is either shared (sh) or exclusive (ex). A Notification or view is a special type of event that has a reference to the domain on which a view was requested, the type of view that was requested and the expression that is to be reduced once the notification-event is being processed. The Queue used by the event-loop of an actor is also extended to also allow the reception of notifications. The request-type is also a first class Value.New shared domains can be created using the shared literal. This creates a new object with the given fields and methods in a fresh shared domain. Shacl׳s whenShared and whenExclusive primitives are represented by theacquiree(e){e}primitive in Shacl-Lite. The aquire primitive is used to acquire views on a domain. It is parameterized with three expressions of which the first two have to reduce to a request type and a domain identifier respectively.Runtime syntax: Additional runtime syntax was added to release a view at the end of a turn (Fig. A19).Evaluation contexts: An additional evaluation context was added to define the order in which the expressions of the acquire primitive need to be reduced. Similar to the object syntax, the field initializer expressions of a shared domain expression need to be reduced to a value from left to right before the shared domain literal can be further reduced. An additional evaluation context was added to specify this behavior.Actor-local reductions: We now summarize the actor-local reduction rules in Fig. A20:•invoke: a method invocation simply looks up the method m in the receiver object (belonging to some domain) and reduces the method body expression e with appropriate values for the parametersx¯and the pseudovariable this. It is only possible for an actor to invoke a method on an object within a domain on which that actor currently holds either a shared or exclusive view(ιa∈S∪E).field-access, field-update: a field update modifies the owning domain׳s heap so that it contains an object with the same address but with an updated set of fields. Field accesses apply only to objects located in domains on which the actor has either an exclusive or shared view(ιa∈S∪E)while field updates only apply in the case of an exclusive view(ιa∈E).Rules for object, domain and actor literals: We summarize the creation reduction rules in Fig. A21:•new-object: All object literals are tagged with the domain id of the lexically enclosing domain. The effect of evaluating an object literal expression is the addition of a new object to the heap of that domain. Evaluating an object literal reduces to a shared domain reference r to the new object.new-shared-domain: A shared domain literal will reduce to the construction of a new domain with a single object in its heap. Similar to the rule for new-object, the shared domain expression can only be further reduced once its field initialize expressions have been reduced to a value. The domain expression reduces to a shared domain reference r to the newly created object.〚e〛ιddenotes a transformation that makes sure that all lexically nested object expressions are annotated with the domain id of the newly created shared domain. The access modifier is initially set to free. No actors have a view on the domain and the set of requests is empty.Asynchronous communication reductions: We summarize the asynchronous communication reduction rules in Fig. A22:•shared-asynchronous-send: this rule describes the reduction of an asynchronous message send expression directed at a shared domain reference. Reducing an asynchronous message to a shared domain reference is semantically equivalent to reducing an exclusive view request on that reference and invoking the method synchronously while holding the view (See View Reductions). The domain reference is the target of the request and the body of the request is the invocation of the method on that reference. Further reduction of the acquire statement will eventually reduce the entire statement to null.View reductions: We summarize the view reduction rules in Fig. A23:•acquire-view: This rule describes the reduction of acquire expressions. This rule simply adds the view-request to the set of requests in the domain. Note that this set is not an ordered set and thus requests can in principle be handled in any order. The acquire expression reduces to null.process-view-request: Processing a view request is also considered as a turn of the actor. That means we first have to commit any changes to observable domains at the end of processing the notification. The request is removed from the set of requests and the access modifier of the domain is updated. How the access modifier is allowed to transition from one value to another is described by the auxiliary function lock. Any request to a domain that is currently unavailable will not be matched by acquire and cannot be reduced as long as that domain remains unavailable. The auxiliary function lock yields the new value for the access modifier given the type of request and the current access modifier of the domain. As a result of processing a request a new notification is scheduled in the requesting actor׳s queue. Processing a view request can be done in parallel with reducing actor expressions.process-view-notification: Processing a notification will add the actor id,ιa, to the set of shared or exclusively accessible domains in the shared domain. Analogous to the processing of messages, a new notification can be processed only if two conditions are satisfied: the actor׳s queue Q is not empty, and its current expression cannot be reduced any further (the expression is a value v). The domain׳s set of available shared or exclusive views is updated according to the request using the add function. Processing a notification reduces to the expression that is associated with the notification, followed by a release expression and a commit. Because processing a notification is regarded as a separate turn, the actor needs to take a snapshot of the latest observable domains and commit at the end of the turn (See Appendix A.4).release-view: Releasing a view on the domain removes the actor id from the set of shared or exclusively views of the domain. The access modifier of the domain is also updated, potentially allowing other view requests on that domain to be processed. The release statement, which is always the last statement that is reduced by an actor before reducing other messages in its queue, also reduces to null.Auxiliary functions and predicates: The auxiliary functionunlock(t,l)describes the transition of the value of an access modifier when releasing it. If a domain was locked for exclusive access its lock will be w (write) and can be changed to f (free). If that resource was locked for shared access we transition either to f or subtract one from the read modifier׳s value. Similar to the unlock rule, thelock(t,l)rule describes the transition of the value of the access modifier of a shared resource when acquiring it. These two rules effectively mimic multiple-reader, single-writer locking.The add and subtract rules with four parameters describe the updates to the set of shared, S, and exclusive, E, actor ids of a shared domain. The add rule adds actor ids to either sets while subtract rule subtracts actor ids from either sets, depending on the type of the view.The operational semantics for Shacl-Lite was based on the semantics for the AmbientTalk language [25]. As such, we followed their syntax for many of the concepts of the basic event-loop model, which is different from the regular Shacl syntax. Semantically both languages are identical except for the fact that in Shacl-Lite an object expression is syntax that only allows the specification of the fields and methods of an object while in Shacl, object is a primitive with a single functional parameter that accepts any valid Shacl expression for initialization.One difference between the actual implementation of the domain model and the operational semantics is that the implementation prioritizes exclusive view requests to prevent starvation. The operational semantics handles view requests non-deterministically.

@&#CONCLUSIONS@&#
