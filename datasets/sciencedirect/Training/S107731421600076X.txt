@&#MAIN-TITLE@&#
A real-time Human-Robot Interaction system based on gestures for assistive scenarios

@&#HIGHLIGHTS@&#
We present a multi-robot human interaction system with two robots and a depth sensor.It includes a static and dynamic gestures recognition module.The set of gestures is described using arm/body and facial/head features.Interactive disambiguation for floor and object detection based on pointed location.Tested with several real users as well as with an offline test setting.

@&#KEYPHRASES@&#
Gesture recognition,Human Robot Interaction,Dynamic Time Warping,Pointing location estimation,

@&#ABSTRACT@&#
Natural and intuitive human interaction with robotic systems is a key point to develop robots assisting people in an easy and effective way. In this paper, a Human Robot Interaction (HRI) system able to recognize gestures usually employed in human non-verbal communication is introduced, and an in-depth study of its usability is performed. The system deals with dynamic gestures such as waving or nodding which are recognized using a Dynamic Time Warping approach based on gesture specific features computed from depth maps. A static gesture consisting in pointing at an object is also recognized. The pointed location is then estimated in order to detect candidate objects the user may refer to. When the pointed object is unclear for the robot, a disambiguation procedure by means of either a verbal or gestural dialogue is performed. This skill would lead to the robot picking an object in behalf of the user, which could present difficulties to do it by itself. The overall system — which is composed by a NAO and Wifibot robots, a KinectTM v2 sensor and two laptops — is firstly evaluated in a structured lab setup. Then, a broad set of user tests has been completed, which allows to assess correct performance in terms of recognition rates, easiness of use and response times.

@&#INTRODUCTION@&#
Autonomous robots are making their way into human inhabited environments such as homes and workplaces: for entertainment, helping users in their domestic activities of daily living, or helping disabled people in personal care or basic activities, which would improve their autonomy and quality of life.In order to deploy such robotic systems inhabiting unstructured social spaces, robots should be endowed with some communication skills so that users can interact with them just as they would intuitively do, eventually considering a minimal training. Besides, given that a great part of the human communication is carried out by means of non-verbal channels [1,2], skills like gesture recognition and human behavior analysis reveal to be very useful for this kind of robotic systems, which would include viewing and understanding their surroundings and the humans that inhabit them.Gesture recognition is an active field of research in Computer Vision that benefits from many machine learning algorithms, such as temporal warping [3–5], Hidden Markov Models (HMMs), Support Vector Machines (SVMs) [6], random forest classifiers [7] and deep learning [8], just to mention a few of them. Moreover, gesture recognition personalization techniques have also been proposed in [9] to adapt the system to a given user. Studies in Human Computer Interaction (HCI) and more specifically Human Robot Interaction (HRI) take advantage of this field. Hence, many recent contributions [10–14] consider KinectTM-like sensors to recognize gestures given the discriminative information provided by multi-modal RGB-Depth data. A KinectTM based application is introduced in [15] for taking order service of an elderly care robot. Static body posture is analyzed by an assistive robot in [16] to detect whether the user is open towards the robot interaction or not. Communicative gestures are contrasted from daily living activities in [17] for an intuitive human robot interaction. A novice user can generate his/her gesture library in a semi-supervised way in [18], which are then recognized using a non-parametric stochastic segmentation algorithm. In [19], the user can define specific gestures that mean some message in a human-robot dialogue, and in [20] a framework to define user gestures to control a robot is presented. Deep neural networks are used in [21] to recognize gestures in real time by considering only RGB information. Pointing gestures, similar to the one we propose in this paper, have been studied mostly focusing in hand gestures [22], using the hand orientation and face pose [23]. The pointing direction is estimated in [24,25] using gaze and finger orientation, and deictic gesture interactions that people use to refer to objects in the environment are studied in [26]. Related pointing interactions have also been used for robot guidance [27].In this work we introduce a real time Human Robot Interaction (HRI) system whose objective is to allow user communication with the robot in an easy, natural and intuitive gesture-based fashion. The experimental setup is composed by a humanoid robot (Aldebaran’s NAO) and a wheeled platform (Wifibot) that carries the NAO humanoid and a KinectTM sensor. In this set-up, the multi-robot system is able to recognize static and dynamic gestures from humans based on geometric features extracted from biometric information and dynamic programming techniques. From the gesture understanding of a deictic visual indication of the user, robots can assist him/her in tasks such as picking up an object from the floor and bringing it to the user. In order to validate the system and extract robust conclusions of the interactive behavior, the proposed system has been tested in offline experiments, reporting high recognition rates, as well as with an extensive set of user tests in which 67 people assessed its performance.The remainder of the paper is organized as follows: Section 2 introduces the methods used for gesture recognition and Human Robot Interaction. Section 3 presents the experimental results including the offline and user tests and, finally, Section 4 concludes the paper.With the aim to study gestural communication for HRI, a robotic system has been developed able to understand four different gestures so a human user can interact with it: wave (hand is raised and moved left and right), pointing at (with an outstretched arm), head shake (for expressing disagreement) and nod (head gesture for agreement).The overall robotic system involves several elements: an Aldebaran’s NAO robot, a small size humanoid robot which is very suitable to interact with human users; a Microsoft’s KinectTM v2 sensor to get RGB-Depth visual data from the environment and track the user; and, given that the vision sensor exceeds NAO’s robot capabilities (in size and computing performance), a Nexter Robotics’ Wifibot wheeled platform is used to carry the sensor as well as the NAO, easing its navigation and precision at long ranges.In fact, the proposed robotic system takes inspiration from the DARPA Robotics Challenge 201511theroboticschallenge.orgin which a humanoid robot should drive a car towards an interest place and exit the car in order to finish its work by foot. In a similar way, the wheeled robot was added to the system in order to carry the sensor along with the little humanoid, which should also exit it to complete its task by walking. This multi-robot setup allows the NAO to use the information from the Kinect’sTM v2 sensor and eases its navigation. And for its side, the NAO is the one in charge of directly interacting with the user, also being able to act on the environment, for instance, by grasping objects. The overall setup is shown in Fig. 1, with the NAO seated on the Wifibot. The setup also includes a laptop with an Intel i5 processor to deal with KinectTM’s data and another Intel Core 2 Duo laptop, which sends commands to the robots using the Robot Operating System (ROS)22ros.org[28]. The depth maps are processed using the Point Clouds Library (PCL)33pointclouds.org[29], and body tracking information is obtained using the KinectTM v2 SDK.The system has been programmed as an interactive application, and tested with several users of different ages and not related with the robotics world (see Section 3.2).This section explains the methods used to perform the gesture recognition and image understanding. Given that the application of the system is to enhance the interaction between a human user and a robot, the defined gestures should be as natural for the user as possible, avoiding user training or learning of a specific set of gestures. Instead, the robot should understand gestures as a human would understand another human’s gestures, and should reply to that visual stimulus in real time.The considered set of human gestures has been divided into two categories, depending on the amount of movement involved in their execution:•Static gestures are those in which the user places his/her limbs in a specific position and stands for a while, without any dynamics or movement involved. In this case, the transmitted information is obtained through the static pose configuration. Pointing at an object is an example of static gesture.Dynamic gestures are, in contrast, those in which the movement is the main gesture’s feature. The transmitted information comes from the type of movement as well as its execution velocity. It may also contain a particular pose for a limb during the movement. Examples of dynamic gestures are a wave to salute someone or a gesture with the hand to ask someone to approach to the user’s location.Four different gestures have been included in the designed system to interact with the robot, being three of them dynamic and the remaining one static. The dynamic gestures are the wave, the nod and a facial negation gesture. The static one is the pointing at an object. Both categories are tackled using different approaches. Next we describe the extracted features, the gesture recognition methods and how the gesture’s semantic information is extracted.Gesture recognition is performed based on some features extracted from the user body information obtained from depth maps. For the included arm gestures or any possible new gestures involving more body parts, skeletal data is obtained from depth images of the KinectTM sensor using the KinectTM SDK v2.0.Given that a limb gesture such as the wave does not depend on the position of other parts of the body such as the legs, the rest of the body is not taken into consideration when the recognition is performed. So, rather than directly using the joint coordinates of the whole body, as in [4,30], our proposed method only takes into account the involved limbs from which some distinctive features are extracted. This approach allows the system to recognize gestures any time the skeletal data is properly tracked from the sensor, including situations such as sitting (for instance a person in a wheelchair), as well as standing up or crouching.The application is able to recognize four gestures: the pointing at, the wave, the nod and the head negation. The point at gesture’s features on the skeleton are displayed in Fig. 2a. They can be described as:•δp, the Euclidean distance between the hand and hip joints of the same body part. This feature discriminates between the pointing position and the resting one in which the arms may be outstretched at the sides of the body but not pointing at a place.θp, the elbow joint angle, defined as the angle between the vector from the elbow joint to the shoulder one and the vector from the elbow to the hand joint. It defines when the arm is outstretched.ρp, the position of the hand joint.Given the presented setup and the overall structure of the robotic system, the above features only accounts for large pointing gestures (with the full arm extended), as the ones one would use to point at something laying on the ground.The features and dynamics for the wave gesture are shown in Fig. 2b. They are defined as:•δw, the Euclidean distance between neck and hand joints. Although it was not necessary in order to perform the tests with the current set of gestures, this measure could be normalized by dividing it by the longitude of the arm to have a standardized value in the range [0, 1] to handle body variations.θw, the elbow joint angle, as defined in the point at gesture.The elbow angle used in the features above does not require from normalization as it is not affected by different body heights.The orientation of the face provided by the sensor is used to describe the nod gesture (vertical movement of the head) and the negation one (horizontal movement of the head). The three usual angular axes — pitch, roll and yaw — are used but instead of taking the absolute values, its derivatives are employed as frame features,ΔOi,a=Oi,a−Oi−1,a,where Oi, ais the orientation in degrees of the face in the frame i according to the a axis. Moreover, one out of F frames is used to compute the features to filter noisy orientation estimations, and the values are thresholded to a given value D in order to end up with a sequence of directional changes. More formally, the feature of a frame i for the axis a, fi, a, is computed as:(1)fi,a=(|ΔOi,a|≥D)·sign(ΔOi,a).Fig. 3depicts the facial gestures.A Dynamic Time Warping (DTW) [31] approach is used to detect the dynamic gestures. The DTW algorithm matches two temporal sequences finding the minimum alignment cost between them. One sequence is the reference gesture model of the gesture g,Rg={r1,⋯,rm},and the other is the input streamS={s1,⋯,s∞},where riand siare feature vectors. Features will depend on the gesture to be recognized: for the wave,ri={δiw,θiw}andri={fi,pitch,fi,roll,fi,yaw}for the facial gestures. Both sequences are aligned by means of the computation of a m × n dynamic programming matrix M, where n is the length of the temporal window being used to discretize the infinite time, as data keeps entering the system while no gesture has been identified. Provided that gesture spotting is not needed, the minimum value for n is two.Each element mi, j∈ M represents the distance between the subsequences{r1,⋯,ri}and{s1,⋯,sj},so it is computed as:(2)mi,j=d(ri,sj)+min(mi,j−1,mi−1,j,mi−1,j−1),where d( ·, ·) is a distance metric of choice. Different distance metrics can be used in our implementation. For instance, the Hamming distance:(3)dH(ri,sj)=∑k=0o{rik≠sjk},with o being the number of features of the gesture, is used for the facial gestures case. The weighted L1 distance is employed for the case of the wave gesture, computed as:(4)dL1(ri,sj)=∑k=0oαk|rik−sjk|,with αka positive weighting constant.A gesture g will be considered as recognized if a subsequence of the input data stream S is similar enough to the reference sequence Rg:(5)mm,k≤μg,∀k,where μgis obtained using a training method for each gesture g, detailed in Section 3.1.1.In order to assure the fulfillment of the real time constraint, the DTW is executed in a multi-threaded way in which the different gestures are spread between different threads that run the gesture recognition method simultaneously, stopping in case one of the methods finds a gesture in the input sequence.In case of the need of properly segmenting the gesture in a begin-end manner, such as for validation purposes, the warping path can be found to locate the beginning of a gestural sequence. This warping path:(6)W={w1,⋯,wT},withmax(m,n)≤T<m+n+1,is a matrix of pairs of indexes of contiguous elements in the matrix M that define a mapping between the reference gesture Rgand a subsequence of the input sequence S, subject to the following constraints:•w1=(1,j)andwt=(m,j′).forwt−1=(a′,b′)andwt=(a,b)thena−a′≤1andb−b′≤1.The warping path W that minimizes the warping cost:(7)Cw(M)=minw∈W{1T∑t=1TMwt},can be found for the matrix M by backtracking of the minimum path from mm, j, to m1, k, being k the starting point of the segmented gesture and j the ending of it.A static approach has been selected for static gesture recognition, in the sense that a gesture is considered as recognized when features are within certain values for a given number of contiguous frames and small movement is involved. The number of frames and the feature thresholds are obtained through a similar training method as for the dynamic case.In our case, the pointing gesture is recognized when, for a certain number of frames F, the elbow angle is greater than a threshold Teaindicating the arm is outstretched and the distance between the hand and the hip is greater than a certain distance Tdmeaning that the arm is not in the resting position. Moreover, the hand coordinates are used in order to check the constraint that the position is hold still and not moving. That is, a gesture is recognized if the following constraints are held during Fpframes:(8)δip>Td,θip>Tea,dE(ρip,ρi−1p)≈0,where dErepresents the Euclidean distance.The system runs the static gesture recognition in parallel with the dynamic one, in a multi-threaded way.Once a pointing gesture has been recognized, some information needs to be extracted from it in order to perform its associated task and help the user. The main information that this deictic gesture gives is the pointed location, which is the region of the surrounding space that has some elements of interest for the user. To estimate it, a floor plane description, the pointing direction and some coordinates belonging to the ground are needed.First of all, the arm position has to be obtained in order to know the pointing direction. To do so, the arm joints of the last ten frames of the gesture are averaged to obtain the mean direction and avoid tracking errors. Then, the coordinates of the hand joint H and the elbow joint E are used to get the pointing direction as theEH→=H−Evector. Even though the KinectTM v2 sensor provides information about the hand tip joint, the direction provided by the elbow to hand vector proved to be more precise than the hand to hand tip one in preliminary tests.The ground plane is extracted using the plane estimation method of the PCL library [32]. A depth image of the KinectTM is obtained and converted to a point cloud, the planes of which are segmented using a Random Sample Consensus (RANSAC) method [33]. Those planes that have a similar orthogonal vector to a reference calibrated plane are used as floor planes. The reference plane is automatically obtained at system start up by segmenting all the planes in the depth image and keeping the parameters of the plane whose orthogonal vector is the same as the vertical axis (y axis) of the sensor. In case the camera is not in a parallel position with the ground or no plane is found which fulfills this condition, the reference plane is obtained from the user who has to click three points of the ground in the graphical interface, from which the plane is estimated. Then, the ground point coordinates are obtained by picking one element from the floor cloud.Therefore, let Pfbe the ground point andN→f=(A,B,C)the orthogonal vector of the floor planeπf=Ax+By+Cz+D=0,the pointed point Ppcan be obtained by:(9)Pp=H+(Pf−H)·N→fEH→·N→f·EH→.An example of the pointing location estimation is shown in Fig. 4a.After some tests with users, we observed that the bones were correctly tracked by the KinectTM sensor but not precisely enough to get an accurate pointing direction. This was more clear when the pointing gesture was performed with the hand in front of the body. Also, the users tended to actually point farther than the objects’ location, and the real pointed line did not intersect with the objects, as it can be observed in Fig. 4b. In order to deal with this imprecision, we corrected the pointing position just by slightly translating the pointed location backwards.Similar to what humans do as a response to a pointing gesture, we want that the robots look at the surroundings of the estimated pointed location to detect possible objects that the user is referring to. Notice that in our case we do not care about recognizing the actual objects but rather detecting their presence.This is performed by first extracting the set of points X from the scene point cloud in which each xi∈ X is selected such that its Euclidean distance dEto the pointed point is smaller than a certain value r, dE(xi, Pp) ≤ r, being X a spherical point cloud of radius r and centered in the pointed point Pp. After the extraction of the floor plane,Z=X∖{xi|xi∈πf},all the objects should be isolated and a clustering algorithm is applied to the sub point cloud Z in order to join all the points of the same objects in a smaller point cloud per each object. The clustering algorithm that has been used is the Euclidean Cluster Extraction method [32], which starts the clustering by picking a point zi∈ Z and joining to it all its neighbors zj∈ Z such that dE(zi, zj) < dth, being dtha user defined threshold. The process is repeated for all of these neighbors until no more points are found, in which case a cluster Ciis obtained. The remaining points of the cloud Z are processed in the same way to get the other object clusters. Once the objects are found, its centroid point is computed as the mean coordinates of all the points of the cluster,1|Ci|∑z∈Ciz,and then each cluster’s convex hull is reconstructed in order to compute its area. This allows the system to get a notion of its position in the space and size (see Fig. 4a).However, it may be the case in which the pointed location is not clearly near a single object, so there is a doubt on which was the referred one. When this situation arises, a spoken disambiguation process is started in which the robot asks the user about the object. To do so, the robot may ask if the person was pointing at the biggest object if the objects are clearly of different sizes, otherwise it asks about its relative position, for instance asking a question like “is it the object at your right?”. The user can respond to the question with a yes or no utterance, recognized using NAO’s built in speech recognition software, or by performing the equivalent facial gestures, and the robot will know which was the referred object if there were only two of them, or it may ask another question in case there were three dubious objects in sight. A flowchart of the disambiguation process is included in the supplementary material.The gesture recognition makes the robotic system able to understand some human gestures. But, the human user must be able to recognize what is the robot doing for the interaction to be successful and pleasant. In our case, this means that the robots must work together in order to fulfill the task and respond to the user in an appropriate way. For instance, the Wifibot is able to perform a more precise navigation, whereas the NAO is ideal to interact and speak to the user as well as to act on the environment. This means that the answer of the system to a visual stimuli made by the person has to be expected for them, thus being a natural response to the gesture. Fig. 5shows the flow of the application in a normal use case. The application has been programmed using a state machine paradigm to control the workflow. Details of the implemented state machines are shown in the supplementary material.For the wave gesture, the expected response would be waving back to the user, performing a similar gesture to the one made by him/her and maybe performing some utterance. In the case of the pointing gesture, the robot has to approach the pointed location and analyze which objects are present, trying to deduce which object was the user referring to. Notice that there is no need that the user points to a place which is in the field of view of the sensor, being it possible to point at some objects which are farther away which will also make the robot go to the pointed location to check for objects.Once the object is known and has been disambiguated in case of doubt, the NAO goes down the Wifibot (Fig. 6) and approaches the object, which is then shown to the user performing a gesture with the hand and the head to expose that it understood the object correctly, as it can be seen in Fig. 7. Note that this could be extended to grasp the object and bring it to the user.

@&#CONCLUSIONS@&#
In this work, we presented a multi-robot system designed to interact with human users in a real time gesture based manner. The system is a proof of concept that shows how important is the interaction phase in order to be able to assist users with special needs, such as elderly or handicapped people. Consequently, they could interact with the robot in the way they are used to do with other human beings, and the robot can use the information provided by the users to help them. For instance, the robot could pick something up from the floor without the need of actually recognizing the object but just knowing that the person referred it with a deictic gesture.We included a gesture recognition method based on the KinectTM v2 sensor which takes into account dynamic gestures, recognized by a DTW using specific features from the face and the body, and static gestures such as deictic ones to refer to something present in the environment.The multi-robot system is shown as an effective way of combining efforts with specialized robots, one to carry the weight of the sensor and the computing power with a precise navigation, and the other able to speak and interact in a natural way with the user. Their collaboration in performing the tasks leads to the success of the system and the interaction.Furthermore, an extensive set of user tests was carried out with 67 users who had little contact with robots and that were able to perform the tests with minimal external indications, resulting in a natural interaction for them in most of the cases. Offline tests also showed high recognition rates performing real time gesture detection and spotting in a specifically recorded data set.Nevertheless, different elements of the system such as the detection of the pointing direction could be improved as future work. For instance, the use of a more accurate hand pose estimator like the ones proposed in [34–36] may allow the direction of the finger to be used to obtain the pointing direction, probably resulting in a more precise location estimation. The facial gestures are another element which could be highly improved, first by trying to use a better facial tracker which can properly handle side views (which clearly affect the detection of the negation gesture), but also by exploring or adding other kind of features.