@&#MAIN-TITLE@&#
Relations, models and a memetic approach for three degree-dependent spanning tree problems

@&#HIGHLIGHTS@&#
We study three spanning tree problems with degree-dependent objective functions.Finding the ST with fewest leaves is proven to be relevant for optical networks.Several relations among the three problems are demonstrated.We propose mathematical models and a memetic approach for the problems.We show the effectivity of the proposed approach on test instances.

@&#KEYPHRASES@&#
Combinatorial optimization,Memetic algorithms,Spanning trees,Optical networks,

@&#ABSTRACT@&#
In this paper we take into account three different spanning tree problems with degree-dependent objective functions. The main application of these problems is in the field of optical network design. In particular, we propose the classical Minimum Leaves Spanning Tree problem as a relevant problem in this field and show its relations with the Minimum Branch Vertices and the Minimum Degree Sum Problems. We present a unified memetic algorithm for the three problems and show its effectiveness on a wide range of test instances.

@&#INTRODUCTION@&#
Spanning tree problems with degree-related objective functions or constraints are widely studied in the field of network design. In such problems, we generally look for spanning trees that optimize or respect certain properties related to the degree of the vertices, in order to model cost factors or restrictions deriving from the underlying real-world applications.In the Minimum Branch Vertices Problem (or MBV), we look for the spanning tree with the minimum number of vertices (called branch vertices) with a degree higher than two.This problem has great relevance, for instance, in the context of multicast on optical networks. On such networks, the optical signal can be split and therefore sent from a source to multiple destinations by using an appropriate network device (switch). Multicast communications can therefore be performed through a spanning tree of the network (light-tree), by placing a switch on each branch vertex. For several reasons (such as budget constraints or signal quality preservation, among others) it can be important to determine the spanning tree which requires the minimum number of switches, that is, the optimal solution for the MBV problem.Indeed, many switch devices can only duplicate laser beams; therefore, the actual number of devices to be located on a branch vertex is related to the degree of the node. For this reason, the problem of minimizing the degree sum of the branch vertices of any spanning tree of the network (Minimum Degree Sum Problem or MDS) has been proposed in the literature.However, as can be noted from Fig. 1, if δ(u, T) is the degree of a branch node that is used to propagate information, the exact number of required devices is δ(u, T)−2. More in general, in this context, the optimization problem consists in minimizing the degree sum of the branch vertices less the cardinality of the set of branch vertices multiplied by two. In this paper we show for the first time that this problem, which models the considered underlying application more accurately than MDS, is equivalent to the well known Minimum Leaves Problem (ML), i.e. the problem of finding the spanning tree with the minimum number of degree-1 vertices. This will be proved in Section 2.The aim of this paper is therefore to propose ML as a relevant problem in the field of optical network design and to show that it is closely related to MDS and MBV, by demonstrating some theoretical properties linking their three objective functions. These objectives are also pursued by presenting a unified memetic algorithm that makes use of a single set of rules to perform crossover, mutation and local search operations for the three problems. An extensive experimental analysis proves the effectivity of the proposed approach.MBV has been first introduced in Gargano, Hell, Stacho, and Vaccaro (2002) where the problem was shown to beNP-Hard. In Carrabs, Cerulli, Gaudioso, and Gentili (in press) the authors present four different mathematical formulations and compare the results of different relaxations, solving the lagrangian dual by means of a standard subgradient method and an ad hoc finite ascent algorithm. In Gargano and Hammar (2003) and Gargano, Hammar, Hell, Stacho, and Vaccaro (2004), the authors give conditions for the existence of spanning spiders (i.e. spanning tree containing at most one branch vertex) and, more in general, spanning trees with a bounded number of branch vertices. Another problem related to MBV is the degree-constrained minimum spanning tree. Given an edge-weighted graph G=(V, E) and a value b(i)⩾1, ∀i∈V, the aim is to find a spanning tree with minimum weight such that the degree of each node i is bounded by b(i). In Ribeiro and de Souza (2002), the authors solve the problem by presenting a VNS metaheuristic that embeds a Variable Neighborhood Descent (VND) strategy for local search. An improvement of this algorithm is described in de Souza and Martins (2008). The new algorithm uses guiding strategies based on the Second Order algorithm in the shaking phase and the Skewed approach to avoid degeneration into a multistart heuristic. A branch-and-cut method for solving the problem is discussed in Caccetta and Hill (2001). In Duhamel, Gouveia, Moura, and Souza (2011), the authors present a generalization of the problem which considers a non-linear stepwise cost function on every node. They present two linear programming formulations as well as a hybrid GRASP/VND metaheuristic embedding a Path Relinking strategy applied at the end of each GRASP iteration. MDS has been presented and analyzed in Cerulli, Gentili, and Iossa (2009), which also contains some mathematical formulations and heuristic procedures for both MBV and MDS. Other heuristic approaches for MBV and MDS have been recently proposed in Sundar, Singh, and Rossi (2012). The ML problem was proven to beNP-Hard and hard to approximate in Lu and Ravi (1996). In Salamon and Wiener (2008), the authors introduce some approximation algorithms for the related problem of maximizing the number of internal nodes (of course, the two problems have identical optimal solutions). In Fernandes and Gouveia (1998), given an edge-weighted graph and a natural number k⩾1, the authors study the problem of finding the minimum weight spanning tree with exactly k leaves. Two mathematical formulations derived from the minimum weight spanning tree problem as well as upper bounding and lower bounding schemes are presented.The sequel of the paper is organized as follows. Section 2 contains the formal definition of the studied problems, and the demonstrations of several relations among them. Section 3 introduces some mathematical formulations for each of the three problems, and Section 4 describes the memetic algorithm that we propose to solve them. Section 5 includes the results of the extensive computational tests we performed to compare our memetic approach with the mathematical formulations solved by means of the CPLEX solver. Finally, Section 6 presents some final remarks.Let G=(V, E) be a connected undirected input graph, and T=(V, E′) be a subgraph of G. Let V(T)i⊆V, i⩾0 be the set of vertices with degree i in T. Moreover, define V(T)B=V⧹{V(T)1∪V(T)2}; that is, if T is a spanning tree, V(T)Bis the set of its branch vertices.Moreover, for each j∈V, let δ(j, T) be the degree of j in T. Note that if j∈V(T)i, then δ(j, T)=i. Finally, for each set of vertices X⊆V, let Δ(X, T) be the degree sum of the vertices of X in T(Δ(X,T)=∑j∈Xδ(j,T)).In order to better clarify the introduced notation, consider the tree T in Fig. 2. We have that V(T)1={a, b, c, d, h}, V(T)2={g}, V(T)3={e}, V(T)4={f}, V(T)B={e, f}. Moreover, for example, δ(g, T)=2, Δ({a, b, f}, T)=6, Δ(V(T)B, T)=Δ({e, f}, T)=7.We can now formally define the three problems studied in this paper.Minimum Branch Vertices Problem (MBV).Find a spanning tree T of G such that the number of branch vertices is minimized, that is, such that the set V(T)Bhas the minimum cardinality.Minimum Degree Sum Problem (MDS).Find a spanning tree T of G such that the degree sum of the branch vertices is minimized, that is, such that Δ(V(T)B, T) is minimized.Minimum Leaves Problem (ML).Find a spanning tree T of G such that the number of degree-1 vertices is minimized, that is, such that the set V(T)1 has the minimum cardinality.In Cerulli et al. (2009) the authors proved that, though being strictly related, MDS and MBV are not equivalent. This was shown by presenting an example graph admitting two distinct optimal solutions for MBV, one of which is also optimal for MDS, while the other is not. However, it was not proved whether an optimal solution for MDS is always optimal for MBV. Here we provide evidence that this is not true, and therefore that optimal solutions for the two problem can be completely distinct.Consider the example graph in Fig. 3(a). The optimal solution for the MBV problem consists in a spanning tree with a single branch vertex, as shown in Fig. 3(b). However, the optimal solution value of MDS for this graph is six, that is also the degree sum of the two branch vertices of the tree shown in Fig. 3(c), which of course is not an optimal solution for MBV.It can also be easily shown that the ML problem is not equivalent to neither MBV nor MDS. For example, given the graph in Fig. 4(a), the optimal solution value for MBV is one, and the optimal solution value for MDS is five; Fig. 4(b) shows an optimal tree for both the problems. This solution has five degree-1 vertices, while the optimal ML solution value for this instance is four; the related optimal solution is shown in Fig. 4(c). This solution is not optimal for the other two problems, having two branch vertices with a total degree sum equal to six.Now, consider the following propositions:PropositionGiven a connected undirected graph G=(V, E) and a spanning tree T=(V, E′) of G, the following equation holds:(1)Δ(V,T)=2|V|-2.Since any spanning tree T of G has exactly ∣V∣−1 edges and any edge of T increases the degree of two nodes by one, if follows that(2)Δ(V,T)=2|E′|=2(|V|-1)=2|V|-2.□Given a connected undirected graph G=(V, E) and a spanning tree T=(V, E′) of G, the following equation holds:(3)Δ(V(T)B,T)=2|V|-2-|V(T)1|-2|V(T)2|.It is straightforward to observe that(4)Δ(V(T)B,T)=Δ(V,T)-Δ(V(T)1,T)-Δ(V(T)2,T);(5)Δ(V(T)1,T)=|V(T)1|;(6)Δ(V(T)2,T)=2|V(T)2|.By substituting (1), (5) and (6) inside (4), we obtain (3).□Given a connected undirected graph G=(V, E) and a spanning tree T=(V, E′) of G, the following equation holds:(7)|V(T)1|=Δ(V(T)B,T)-2|V(T)B|+2.By reformulating (3) we have(8)|V(T)1|=2(|V|-|V(T)2|)-2-Δ(V(T)B,T);it is also easy to note that(9)|V|-|V(T)2|=|V(T)B|+|V(T)1|.By substituting (9) in (8) and reformulating, we obtain (7).□We can use (7) to show that ML is a problem of interest in the field of optical network design. As already said in Section 1, many switch devices can only duplicate light signals. Consider a spanning tree T=(V, E′) which is used for multicast communications on a graph G=(V, E). Let u be a given vertex which is reached by the signal; no switch devices are needed in u if δ(u, T)=1 (i.e., u is a leaf) or δ(u, T)=2 (u just propagates the signal coming from its parent in T to its child). If u is a branch vertex, the signal entering in u must be propagated to its δ(u, T)−1⩾2 children; without loss of generality let us call them v1,…,vδ(u, T)−1. As exemplified in Fig. 1, this can be accomplished using δ(u, T)−2 devices (s1,…,sδ(u, T)−2): the signal is sent from u to s1 and each sipropagates it to viand to either si+1 if i<δ(u, T)−2 or vi+1 if i=δ(u, T)−2. By iterating this reasoning for each branch vertex, we have that the number of required switch devices is Δ(V(T)B, T)−2∣V(T)B∣, which is the right hand side of (7) minus a constant factor of 2. Therefore ML can be used to find the spanning tree which requires the minimum number of switch devices.The relations among the three problems can be further highlighted by rewriting their objective functions in terms of a parametric unified objective function, as we will show in the following.The MBV objective function can be reformulated as(10)min|V(T)B|=min(|V|-|V(T)1|-|V(T)2|);since ∣V∣ is a constant value,(11)min|V(T)B|=-max(|V(T)1|+|V(T)2|)+|V|.Moreover, using (3) the MDS objective function can be reformulated as(12)minΔ(V(T)B,T)=min(2|V|-2-|V(T)1|-2|V(T)2|);since 2∣V∣−2 is a constant value,(13)minΔ(V(T)B,T)=-max(|V(T)1|+2|V(T)2|)+2|V|-2.Finally, it is also easy to note that the ML objective function can be reformulated as(14)min|V(T)1|=-max-|V(T)1|.We can then use the following objective function to find optimal solutions for the three problems(15)max(α|V(T)1|+β|V(T)2|),where•for MBV: α=1, β=1;for MDS: α=1, β=2;for ML: α=−1, β=0.We present three mathematical formulations for each of the three considered problems. To impose the selection of a spanning tree T of the input graph, two formulations for each of the problems are flow-based, while the remaining three use the well-known Miller–Tucker–Zemlin (MTZ) subtour elimination constraints (see Miller, Tucker, & Zemlin, 1960). The formulations for MBV were originally proposed in Carrabs et al. (in press). Formulations proposed in the literature for problems that impose hard constraints on node degrees, such as the degree-constrained spanning tree problem, cannot be naturally adapted to the problems presented in this work. The section also presents a mixed integer-continuous relaxation for each model. The formulations are defined on directed graphs, therefore we consider a directed version of G that contains both arcs (u, v) and (v, u) for each edge (u, v)∈E; let Gd=(V, Ed) be this graph. An arbitrary node s∈V is selected as root node of T.The models are presented in Sections 3.1–3.3 while relaxations are discussed in Section 3.4.In Sections 3.1–3.3, the three formulations for MBV are presented and analyzed.(16)min∑v∈Vyv,(17)s.t.∑(u,v)∈Edxuv=1∀v∈V⧹{s},(18)∑(u,v)∈Edxuv=n-1,(19)∑(s,v)∈Edfsv-∑(v,s)∈Edfvs=|V|-1,(20)∑(v,u)∈Edfvu-∑(u,v)∈Edfuv=-1∀v∈V⧹{s},(21)∑(v,u)∈Edxvu+∑(u,v)∈Edxuv⩽δ(v,G)yv+2∀v∈V,(22)xuv⩽fuv⩽(|V|-1)xuv∀(u,v)∈Ed,(23)yv∈{0,1}∀v∈V,(24)xuv∈{0,1}∀(u,v)∈Ed,(25)fuv⩾0∀(u,v)∈Ed.Variables xuv, fuv∀(u, v)∈Eddetermine whether (u, v) is part of T and the amount of flow passing through it, respectively. Each binary variable yv∀v∈V is equal to 1 if v is a branch vertex.The objective function (16) minimizes the number of branch vertices. Constraints (17) make sure that each vertex except the source has exactly one parent in T, while Constraints (18) make sure that exactly n−1 arcs are selected in the solution. Constraints (19) and (20) are flow conservation constraints, imposing that exactly ∣V∣−1 flow units are produced in s and one of them is retained by each node in V ⧹{s}. Constraints (21) impose vertex v to be a branch if its degree is greater than two in the tree; note that the value of yvis unconstrained if δ(v, T)⩽2, however in this case it will be set to 0 by the objective function. Finally, Constraints (22) make sure that there is a positive amount of flow only on arcs that belong to T.(26)min∑v∈Vyv,(27)s.t.(17),(18),(21),(23),(24),∑(v,u)∈Edfvuk-∑(u,v)∈Edfuvk=0∀k∈V,v∈V⧹{s},v≠k,(28)∑(s,v)∈Edfsvk-∑(v,s)∈Edfvsk=1∀k∈V⧹{s},(29)∑(k,v)∈Edfkvk-∑(v,k)∈Edfvkk=-1∀k∈V⧹{s},(30)fuvk⩽xuv∀k∈V,(u,v)∈Ed,(31)fuvk⩾0∀k∈V,(u,v)∈Ed.For each (u, v)∈Ed, k∈V⧹{s}, flow variablefuvkis equal to 1 if a unit of flow produced by s and targeted to k passes through (u, v) (that is, if (u, v) is part of the path from s to k in the solution), 0 otherwise. Constraints (27)–(29) are a disaggregated version of the flow conservation constraints, imposing that w produces one unit of flow for each k∈V ⧹{s}, and that any unit of flow entering into a node v and targeted to k is absorbed if v=k, while is forwarded to a different node otherwise. Constraints (30) impose that the units of flow can only pass though arcs that are included into the solution.(32)min∑v∈Vyv,(33)s.t.(17),(18),(21),(23),(24),ts=0,(34)tv⩾1∀v∈V⧹{s},(35)(|V|-2)xvu+|V|xuv+tu⩽tv+(|V|-1)∀(u,v)∈Ed,(36)tv∈{0,1,…}∀v∈V.Variables tvcontain the values of a labeling function defined on the nodes of Gd. The idea underlying MTZ constraints is to assign to the root s the smallest label (as imposed by Constraints (33) and (34)) and to impose that for each arc (u, v) selected to be part of T vertex u has a smaller label than v. More in detail, Constraints (35) ensure that if xuv=1, then tv=tu+1, and are a lifted version proposed in Desrochers and Laporte (1991) of the original MTZ constraints.With respect to the MBV formulations, an additional set of variables zvis needed in order to take into account the degree of the branch vertices. The models use the constraints of the corresponding MBV formulations to build a spanning tree, as well as Constraints (21) to identify branch vertices. Moreover, Constraints (38) are used by the three models to impose zv⩾δ(v, T) if yv=1 and therefore v is a branch vertex, leaving it unconstrained if yv=0. The objective function (37) minimizes the sum of variables zvand therefore will impose zv=δ(v, T) for the branch vertices, 0 otherwise.(37)min∑v∈Vzv,(38)s.t.(17)–(25)∑(v,u)∈Edxvu+∑(u,v)∈Edxuv⩽zv+2-2yv∀v∈V,(39)zv⩾0∀v∈V.(40)min∑v∈Vzv,s.t.(17),(18),(21),(23),(24),(27)–(31),(38),(39).(41)min∑v∈Vzv,s.t.(17),(18),(21),(23),(24),(33)–(36),(38),(39).In the ML formulations, variables yvare used to represent whether the vertices are leaves or not in T. Again, constraints to define a tree structure are retained. Constraints (43) ensure that yv=1 if δ(v, T)=1. The value of yvis not constrained if it is not a leaf, however since the objective function (45) minimizes the sum of yvvariables, it will be set to 0.(42)min∑v∈Vyv,(43)s.t.(17)–(20),(22)–(25),∑(v,u)∈Edxvu+∑(u,v)∈Edxuv+yv⩾2∀v∈V.(44)min∑v∈Vyv,s.t.(17),(18),(23),(24),(27)–(31),(43).(45)min∑v∈Vyv,s.t.Eqs.(17),(18),(23),(24),(33)–(36),(38),(39),(43).For all the presented formulations, we take into account a mixed integer-continuous relaxation, obtained by relaxing integrality on xuvvariables.Furthermore, as already done for example in Akgün and Tansel (2011) and Carrabs et al. (in press), the bounds returned by the relaxations are improved by adding the following set of constraints:(46)xuv+xvu⩽1∀(u,v)∈Ed,u<v.Memetic algorithms combine population-based metaheuristics (such as genetic or other evolutive algorithms) and more traditional local search schemes. The idea is to obtain a good compromise between the respective strengths of these approaches, in particular with respect to diversification to explore new regions of the search space, and intensification of the search in promising regions. For a survey on memetic algorithms for discrete optimization, refer to Hao (2012).Our memetic algorithm (or MA in the following) combines a genetic algorithm with a local search step.Genetic algorithms (GA) are randomized metaheuristic techniques based on the biological process of natural selection that have been successfully applied to many combinatorial optimization problems. A genetic algorithm emulates the evolutionary process on a population composed of solutions (chromosomes). While starting populations are often created randomly, new individuals are iteratively formed by recombining together two or more older chromosomes, or by perturbing a single one; the best chromosomes have generally better chances of being selected in these steps. Therefore, new solutions are likely to inherit good characteristics from old solutions, and, by repeating this process over a sufficient number of generations, eventually near-optimal solutions can be reached. For an introduction to genetic algorithms, see for example (Reeves, 2010). Genetic algorithms have been applied with success on Spanning Tree problems; see, for example, (Neumann, 2007; Zhou & Gen, 1999).The main elements that must be provided in order to implement a GA are:•A representation scheme for each chromosome. Our algorithm considers only feasible solutions, therefore each chromosome is a spanning tree and is represented internally as a list of its edges.A function to evaluate each chromosome (fitness function). Our algorithm evaluates the chromosomes using the parametric objective function (15). Depending on the problem on which we intend to focus, the appropriate values for parameters α and β are used.Rules to derive new solutions, by combining two parent solutions (crossover) and by perturbing a single individual (mutation). Our crossover and mutation operators are described in Sections 4.2 and 4.3 respectively.Termination criteria for the procedure. In our case, the algorithm ends when a given number of iterations without improvements has been performed.A high level outline of the procedure is given in Algorithm 1. Each step reported in Algorithm 1 will be explained in detail in the remaining part of this section. The algorithm description makes use of various input parameters, whose setting during our experimental analysis is discussed in Section 5.Algorithm 1Memetic Algorithm1: Build a random population Π2: while iterations without improvements ⩽max-itdo3:choose two parent chromosomes T1, T24:perform crossover on T1 and T2 obtaining T35:perform a mutation on T3 obtainingT3′6:perform a local search starting fromT3′, obtainingT3″7:insertT3″in Π substituting an older chromosome Ti8: end whileAs reported in Line 3 of Algorithm 1, at each iteration, two chromosomes are selected for the crossover phase. Our algorithm uses tournament selection, which is a scheme commonly used by GAs in order to promote good individuals.We implemented a simple tournament selection which can be summarized as follows:•Select randomly h chromosomes from the population Π; let T1 be the one with the best fitness function value among them.Select randomlyh2chromosomes from Π⧹{T1}; let T2 be the one with the best fitness function value among them.Select T1, T2 as parents for the crossover phase.Ties are broken randomly. The idea underlying the implemented tournament scheme is to promote the selection of at least a parent chromosome with a good fitness value, while a higher degree of diversity is left for the selection of the other parent. Of course, the chosen value for parameter h influences both the convergence rate of the algorithm and its capacity to escape from local minima.The new chromosomeT3″that will result after the phases reported in Lines 4–6 will replace an older one; therefore the population size ∣Π∣ is constant throughout every phase of the algorithm. The substituted element is also selected using a tournament mechanism:•Select randomly k chromosomes from Π; let Tibe the one with the worst fitness function value among them.Substitute TiwithT3″in Π.The crossover operator builds a new individual from two parents. In classical GAs, crossover is performed by simple recombination of the information contained in the parents. For example, supposing that in a GA chromosomes are represented as lists, two children might be obtained from two parents by swapping between them all the data contained after a given position (crossover point). Our crossover, instead, creates new individuals which inherit “good” characteristics from the parents, but are not a direct recombination of them.More in detail, given the parent chromosomes T1 and T2, we start by defining two weight functions w1 and w2 on the edges of the input graph G=(V, E); each wiis based on the characteristics of Ti. Finally, the new spanning tree T3 is built by finding a Minimum Spanning Tree of the weighted graph Gw=(V, E, w), wherew(u,v)=w1(u,v)+w2(u,v)∀(u,v)∈E.The aim of the weight functions is to penalize or promote the selection in T3 of the edges of E, using three key ideas:•Strongly promote the selection of chains coming from the parents; this is an obvious choice since we would like to obtain the highest possible number of vertices with degree ⩽2 in the final solution. The longer is a chain, the more its edges are promoted.promote the selection of edges connected to vertices that are branch in the parents; as the procedure converges, some branch vertices are likely to be perceived as required. Edges actually belonging to the parents are more promoted than new edges connected to such vertices.Penalize the selection of edges connected to vertices with degree 2 in the chains, in order to avoid new branch vertices.These guidelines might suggest both to penalize and to promote the same edge. We represent penalizing and promoting weights for each edge (u, v) and parent Ti=(V, Ei) using three positive input parameters M, Ω, ω, such that M>4Ω and Ω>4ω. More in detail, wiis computed as follows:1.Initialize wi(u, v)=0 ∀(u, v)∈E.For each u∈V(Ti)B, add −Ω to wi(u, v) ∀(u, v)∈Ei.For each u∈V(Ti)B, add −ω to wi(u, v) ∀(u, v)∈E⧹Ei.Remove all edges connected to branch vertices from Ti, obtaining the forestFi=V,Ei′.For each(u,v)∈Ei′, let l(u, v) be the length of the chain it belongs to in Fi, and add −Ml(u, v) to wi(u, v).For each u∈V(Fi)2, add 2ω to wi(u, v)∀(u,v)∈E⧹Ei′.A positive value for wi(u, v) means that the selection of (u, v) is penalized according to parent Ti, while a negative value means that it is considered a useful edge (recall that the weights are used to compute a minimum spanning tree).The steps described above are illustrated on the tree shown in Fig. 5. In particular, Fig. 5(b) shows the negative weights applied to promote edges connected to the branch vertex 2. In Fig. 5(c) the negative weights associated with chains are added, and finally Fig. 5(d) includes the penalizing weights for the edges connected to nodes with degree 2 in Fi. It can be noted that each edge with a positive weight would add at least one branch vertex if included in Fi; in particular, the promoting weight assigned to (2,6) for being connected to branch vertex 2 is counterbalanced by its penalization deriving from vertex 6.The chosen values for parameters ω, Ω and M are reported in Section 5. By imposing M>4Ω, we make sure that edges belonging to chains are always promoted with respect to other edges (the smallest weight that can be assigned to an edge that is not in a chain is −4Ω, associated to an edge belonging to both parents and connected to two branch vertices in each of them). For a similar reasoning, we also impose Ω>4ω.Given the new individual T3 resulting from the crossover, the mutation phase operates by applying two different mutation operators M1, M2. M1 is always executed, while M2 is executed after M1 with probability pm2. The operators work as follows:•M1: A leaf node of T3 is randomly selected and connected to another random node. The resulting cycle is broken randomly obtaining a new spanning tree.M2: Randomly eliminates two edges, trying to promote the elimination of branch vertices by repeating the random choice up to a fixed number of iterations,itM2. The resulting three components are rejoined by randomly selecting two new edges, obtaining the new tree.Mutation M2 is illustrated in Fig. 6, where two branch vertices are removed by selection edges (2,4) and (5,8), and a new branch vertex is created when edges (1,7) and (6,9) (supposing that they exist in G) are chosen to rejoin the three components.At the end of each iteration of the genetic algorithm, a local search is performed on the new chromosomeT3′obtained after the mutation phase. Similarly to the M1 operator, each iteration of the local search tries to switch one of the edges belonging to the current solution with a new one; however, instead of selecting edges randomly, we look for an improvement of the original tree. The improvement is evaluated according to a heuristic function that promotes the introduction of new nodes whose degree is not greater than two, and that strongly penalizes the introduction of new branch vertices. Additional edges added to old branch vertices are also penalized, using values that are inversely proportional to the node degree. More in detail, given a subgraph H of G, we define the following functions:1.Let im(x, H) be a function defined on the nodes of H, such that im(x, H) is equal to: 0 if δ(x, H)⩽2, M if δ(x, H)=3, 1/δ(x, H) if δ(x, H)>3.Let IM((u, v), H) be a function defined on the edges of H such that IM((u, v), H)=im(u, H)+im(v, H).Let (u′, v′) be an edge ofT3′; moreover, let(u″,v″)∉T3′be an edge of G with an endpoint in each of the two connected components that would be created by removing (u′, v′) fromT3′. We use the IM function to evaluate if replacing (u′, v′) with (u″, v″) would be a convenient choice as follows:1.LetH=T3′∪{(u″,v″)}.If IM((u″, v″), H)<IM((u′, v′), H) thenT3″=H⧹{(u′,v′)}is an improvement ofT3′.Each iteration of the local search looks for an improvement, by considering all the possible edge substitutions that can be used to obtain a new tree. Each iteration accepts the first improvement found, and the local search phase ends when no improvements are available.Two local search iterations are shown in Fig. 7. Starting from the tree with two branch vertices in Fig. 7(a), removing (3,4) and rejoining the components using edge (8,9) (supposing that it exists in the graph) produces a new tree that is an improvement of the previous one, as shown in Fig. 7(b). Note that due to the weighting function, the degree of vertex 3 is lowered from 4 to 3, even if the degree of vertex 9 increases from 4 to 5. On the resulting tree, assuming that edge (5,7) also exists in the graph, it allows to decrease again the degree of vertex 3 by removing edge (3,5), as illustrated in Fig. 7(c), producing the tree with a single branch vertex shown in Fig. 7(d).In this section, we describe the computational results that we obtained by applying the proposed MA for the three problem variants on a set of test instances. The SC and MTZ mathematical formulations introduced in Section 3 were used to obtain optimal solutions as well as lower bounds for the more complex instances. The MC formulations results are not reported since they did not provide solutions in reasonable computational time for most of the considered test instances.In order to test the performance of our memetic algorithm, we considered a wide set of test instances which belong to two main groups, identified as Type 1 and Type 2 in the following.The instances belonging to the first group (Type 1), generated according to parameters originally proposed in Carrabs et al. (in press) for the MBV problem, are designed to be sparse in order to require a significant number of branch vertices. We generated instances with 14 different values for the number of nodes ∣V∣ between 150 and 1000. The number of edges is generated according to the following formula:(|V|-1)+i×1.5×|V|with i=1, 2, 3, 4, 5. We randomly generated five instances for each choice of V and i, therefore the total number of Type 1 instances is 350.Furthermore, in order to test our approaches on more challenging scenarios, we defined instances belonging to Type 2. The instances are generated by merging together short subtours composed of four nodes each. The construction of such instances starts from a first four nodes tour (see Fig. 8(a)). Then, two non-connected nodes of the tour are randomly selected, connected and used to construct a new subtour together with two new nodes, as illustrated in Fig. 8(b). The construction goes on by iteratively adding couple of nodes which are used to produce new tours together with randomly chosen couple of nodes belonging to previous tours. Couple of nodes already belonging to the graph could be randomly chosen more than once, therefore, not every iteration connects two previously disjoint nodes (as in the example in Fig. 8(c)), leading to diversity in terms of nodes degree and overall number of edges. The construction of tours ends when the desired number of nodes ∣V∣ is reached; finally, ∣V∣/2 random edges are added to the graph to further increase diversity. Instances were generated for 10 different values of ∣V∣ between 50 and 1500, generating 10 instances for each choice, for a total of 100 Type 2 instances.Regarding our memetic algorithm, after a tuning phase we chose the following values for the parameters, which seemed to provide a good tradeoff among solution quality and computational time: ∣Π∣=1000, max-it=25,000, h=8, k=3, M=21, Ω=5, ω=1, pm2=0.5, itm2=5. The MA has been coded in C++. The IBM ILOG CPLEX 12 solver was used to solve the mathematical formulations, considering a time limit of 1hour for each instance. All tests have been executed on an Intel Xeon 2Ghz workstation with 8gigabytes of RAM.

@&#CONCLUSIONS@&#
In this paper, we show that finding a spanning tree with the minimum number of leaves is a relevant problem in the context of multicast communications on optical networks. In particular, we demonstrate that it can be used to model the problem of minimizing the number of required light-splitting devices more accurately than two problems already proposed in the literature to solve the same issue (namely, the Minimum Branch Vertices and the Minimum Degree Sum Problems). Moreover, we propose a unified memetic procedure that makes use of a common set of rules to produce accurate solutions for the three problems, as shown by our computational tests.Future research will be aimed at obtaining a better characterization of the similarities among the three problems, looking for possible dominance relations under particular assumptions. Further efforts will be also spent at producing improved resolution approaches and test instances coming from real-world applications.