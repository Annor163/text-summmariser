@&#MAIN-TITLE@&#
Flexary connectives in Mizar

@&#HIGHLIGHTS@&#
Two new logical connectives are introduced to the Mizar language.Inference rules to deal with the connectives are introduced.Processing of the connectives by the Mizar proof checker is described.

@&#KEYPHRASES@&#
Proof assistant,Ellipsis,Flexary conjunction,Flexary disjunction,Mizar,

@&#ABSTRACT@&#
One of the main components of the Mizar project is the Mizar language, a computer language invented to reflect the natural language of mathematics. From the very beginning various linguistic constructions and grammar rules which enable us to write texts which resemble classical mathematical papers have been developed and implemented in the language.The Mizar Mathematical Library is a repository of computer-verified mathematical texts written in the Mizar language. Besides well-known and important theorems, the library contains series of some quite technical lemmas describing some properties formulated for different values of numbers. For example the sequence of lemmasfornbeingNatstn <=1holdsn=0orn=1;fornbeingNatstn <=2holdsn=0orn=1orn=2;fornbeingNatstn <=3holdsn=0orn=1orn=2orn=3;which for a long time contained 13 such formulae.In this paper, we present an extension of the Mizar language – an ellipsis that is used to define flexary logical connectives. We define flexary conjunction and flexary disjunction, which can be understood as generalization of classical conjunction and classical disjunction, respectively. The proposed extension enables us to get rid of lists of such lemmas and to formulate them as single theorems, e.g.form,nbeingNatstn <=mholdsn=0or ... orn=m;covering all cases between the bounds 0 and m in this case.Moreover, a specific inference rule to process flexary formulae, formulae using flexary connectives, is introduced. We describe how ellipses are incorporated into the Mizar language and how they are verified by the Mizar proof checker.

@&#INTRODUCTION@&#
In mathematics, an ellipsis is used in various contexts and with different meanings. It may mean “and so forth” when patterns of expressions are predictable (e.g. to express consequent odd natural numbers one may write1,3,5,…); and when patterns are unknown (e.g. to express approximate value of the constante≈2.71828…). A very common usage of an ellipsis is to write finite terms without listing all their components (e.g. factorial of the number n as the product1⁎2⁎…⁎n). An ellipsis is also used to express “long” vectors, matrices, etc.In the paper we focus on another usage of ellipses, namely used to formulate flexary conjunctions and flexary disjunctions, which can be understood as generalizations of classical conjunctions and classical disjunctions. We present how ellipses are incorporated into the Mizar language and are verified by the Mizar proof checker.The paper is structured as follows. In Section 2 we present basic information and features of the Mizar system required to explain the main track of the paper. In Section 3 we present motivations for using flexary connectives. Experimental results how ellipses influence the content of the Mizar library are shown. In Section 4 we describe how ellipses are implemented in Mizar. Moreover, the way how they are proceeded in the Mizar framework is described.The Mizar project started in 1973 under the leadership of Andrzej Trybulec at the Płock Scientific Society in Poland. Currently, since 1976, it is maintained at the University of Białystok, Poland. The principal goal of the project is to design a computer environment that supports writing traditional mathematical papers under strict control of computer programs that check syntactical, semantical and logical correctness of texts. Mizar is a common name of different components of the Mizar project. It is the name of the project itself. It is the name of a language invented to write mathematical texts to be processed by computers. It is also the name of a bunch of computer programs designed and implemented for processing texts written in the Mizar language, with its core program, a proof checker named Verifier, suitable for formal verification [3,54,66].Currently there are available dozens of proof assistants usable for proving very advanced mathematical theorems, with leading role of the HOL Light theorem prover,11http://www.cl.cam.ac.uk/~jrh13/hol-light/Isabelle,22http://www.cl.cam.ac.uk/research/hvg/Isabelle/the Coq proof assistant,33http://coq.inria.frMetamath,44http://us.metamath.orgProofPower,55http://www.lemma-one.com/ProofPower/index/Nqthm/ACL2,66http://www.cs.utexas.edu/users/moore/acl2/the PVS specification and verification system,77http://pvs.csl.sri.comthe Nuprl/PRL project,88http://www.nuprl.organd Mizar.99http://mizar.orgMizar differs from mentioned systems by adopted logical and theoretical foundations which are briefly presented in the following sections.The Mizar language is a declarative language that allows writing texts resembling traditional mathematical papers. It was invented by Andrzej Trybulec on one hand to enable computers to process mathematical texts written in the language efficiently and on the other hand developed to reflect the natural language of mathematics. It implements rules for writing predicates; terms in prefix, infix and suffix forms; adjectives [36]; types [6]; formulae of various kinds (universal, existential, predicative, attributive, qualifying); definitions; theorems; local lemmas; reasoning methods (including straightforward reasoning, diffused reasoning, proof by exhaustion); proof steps (including generalizations, assumptions, exemplifications, conclusions, linking, references); different ways of introducing variables; syntactic constructions to launch distinguished algorithms for processing particular mechanisms (e.g. term identifications, term reductions [32], properties of predicates and functors [40]); etc.Over decades many versions of the Mizar language have been issued [35]. Some of them inspired other proof assistants to incorporate the so-called Mizar modes to the systems. The most notable are the Mizar mode for HOL [26], Mizar-light for HOL Light [64], the Mizar mode for Coq [16], the declarative proof language (DPL) for Coq [12], and the Isar proof language for the Isabelle theorem prover [63]. The Mizar way of writing proofs was also the model for the notion of ‘formal proof sketches’ [65].For the purposes of this paper we recall some basic information about formulae supported by the Mizar language. We can distinguish three kinds of atomic formulae: predicative formulae, adjective formulae and qualifying formulae. Predicative formulae express relations between objects and use predicates symbols as main operators of the formulae, e.g. 2 in {1,2,3}. Adjective formulae express that objects satisfy some adjectives and use attributes symbols as main symbols of the formulae, e.g. {x} is finite. Qualifying formulae declare that objects are of some types and use mode symbols, e.g. (#INT,addint#) is Group. Atomic formulae can be combined into complex formulae using traditional logical connectives (negation not, conjunction &, disjunction or, implication implies, and equivalence iff) and quantifiers (general quantifier for ... holds ... and existential quantifier ex ... st …). In spite of the fact that in Mizar texts one can use all these logical operators, internally all formulae are represented using general quantifier, negation and conjunction only. Formulae are transformed according to standard logical laws (de Morgan׳s laws and double negation elimination):¬¬α⇝αα∨β⇝¬(¬α∧¬β)α⇒β⇝¬(α∧¬β)α⟺β⇝¬(α∧¬β)∧¬(β∧¬α)∃x:α(x)⇝¬∀x:¬α(x)The logical basis of the Mizar is the classical first-order logic with equality (in some contexts, free second-order variables are permitted what enables to introduce schemes, for example, the scheme of mathematical induction). The proof system is based on the Jaśkowski style of natural deduction [31] (similar systems have been developed independently by Fitch [15] and Ono [43]). Structures of proofs are basically related to the structures of the formulae being proved with application of definitional expansions. Proofs are closed within proof and end brackets, when the proven statement is known a priori; and within now and end brackets, when the proven statement is computed from the proof. Moreover, proofs by exhaustion are allowed. Each case of the reasoning is closed within suppose and end brackets [22]. Here we list examples of proof sketches of some simple formulaeP&QPimpliesQPorQforxholdsP[x]proofproofproofproofthusP;assumeP;assumenotP;letx;thusQ;thusQ;thusQ;thusP[x];end;end;end;end;where P and Q are arbitrary formulae, assume derives assumptions, thus derives conclusions, and let fixes variables.The correctness of reasonings is controlled by the main program of the Mizar system, i.e. Verifier. Basically, it is a standalone program completely designed and implemented by the Mizar developers. However, there are successful trials to involve external highly optimized algorithms provided by other systems to perform some particular tasks during processing Mizar texts, e.g. [39,38,37].Verifier is a classical proof checker based on the notion of the inference obviousness [14,46] instead of using a fixed set of inference rules and proof tactics, what makes it different from Coq, Isabelle, HOL Light, and some others. Verifier is designed to keep balance between readability of proofs written by humans and automation of reasoning. Therefore, the kernel of Verifier contains series of modules and adequate procedures responsible for processing particular verification mechanisms and linguistic constructs provided by the Mizar language.The basic modules of Verifier are the following:Parserwhich is responsible for controlling the lexical structure of a given text and generating the parse tree of the text.which identifies objects and operations, performs type checking and resolves possible ambiguities caused by overloading of symbols. Moreover, it verifies if constraints required by particular constructions are fulfilled.which controls structures of proofs according to the natural deduction rules.which verifies logical correctness of inferences. As a disprover it tries to refute negations of processed sentences. It performs propositional calculus (Prechecker), equational calculus over equalities accessible in inferences (Equalizer) and unification (Unifier).Over time, it turned out that to enable writing more and more advanced papers it is worth to accumulate formalized knowledge, to built a comprehensive library of mathematical notions [23] and to collect detailed proofs verified by the Mizar proof checker [22,41]. Then, in 1989, the Mizar Mathematical Library (MML) [2] was established. It is a collection of fully verified papers based on the Tarski–Grothendieck (TG) set theory, which is a variant of the ZFC set theory [27], where the axiom of infinity is replaced by Tarski׳s axiom of existence of arbitrarily large, strongly inaccessible cardinals [51].The current Version 5.32.1240 of the Mizar Mathematical Library contains 1240 articles (89,715,215 bytes in total) devoted to different branches of mathematics, including set theory, logic, topology, calculus, lattice theory, group theory, abstract algebra theory, many-sorted algebras, category theory, probability theory, mathematical models of computations, and others.Developing of the MML goes in different directions. The most important are collecting of new knowledge and refactoring of the database [24] to keep its integrity [47] and to increase readability of the stored proofs [45]. Collecting new knowledge is realized by developing background knowledge within chosen domains to prepare a comprehensive database of formalized knowledge for practicing mathematicians and for educational purposes; formalization of entire mathematical books [17,8]; and formalization of either well-known theorems [1] or developing new theories [11,19,18,21]. Some new results are achieved using external theorem provers, e.g. EQP/Otter1010https://www.cs.unm.edu/~mccune/eqp/and Prover9,1111https://www.cs.unm.edu/~mccune/mace4/and then translated into the Mizar language [20].Knowledge stored in the database is used in various branches of science and education, e.g. for representing mathematics on WWW [30,57], as an input for ATP systems [60,61,59,58], as an input for services classifying mathematics [25], and others.Many mathematical theorems are expressible by formulae(1)∀c:Θa≺c∧c≺b⇒ϕ(c)or(2)∃c:Θa≺c∧c≺b∧ϕ(c)where a, b, and c are terms of a common type Θ equipped with a comparison relation ≺, and ϕ is a formula over Θ. Moreover, when the type is equipped with the successor operation S, and when there is a way to compute the distance between two values a and b (i.e. the number of times the successor function should be applied to pass from a to b) the formulae can be understood as the enumerations(3)ϕ(a)∧ϕ(S(a))∧ϕ(S(S(a)))∧…∧ϕ(b)and(4)ϕ(a)∨ϕ(S(a))∨ϕ(S(S(a)))∨…∨ϕ(b)respectively, where the successor S is applied the distance times.It is seen that in such circumstances there is an equivalence between general quantifiers and conjunctions and between existential quantifiers and disjunctions. For mathematicians such an equivalence is obvious, but for computer systems it has to be established by implementation of adequate logical rules. One solution could be to choose a kind of normal form for such equivalent formulae, and to rewrite all formulas to their normal forms. Another way could be to expand such general formulae as conjunctions and existential formulae as disjunctions and to keep both in each case. But such a solution would expand many formulae, even if their originals forms are acceptable in leading reasonings.To utilize this correspondence effectively, we propose an extension of formal languages and to introduce two new logical connectives: flexary conjunction which represents both formulae (1) and (3), and flexary disjunction which represents both formulae (2) and (4). Flexary connectives written in texts would be internally expanded to corresponding quantified formulae and to corresponding classical conjunctions and classical disjunctions, if they are of reasonable length (to not exceed computer memory, or to preserve reasonable time of processing). Such extra connectives allow us to execute translations of formulae from one form to another one, in a sense, on the order of authors of documents.One of the crucial principles of the Mizar project is that all changes in the software, before they are issued in new versions, are always tested on the whole content of the Mizar Mathematical Library. New rules and constructions of the Mizar language allow rewriting collected texts using new forms. New functionalities of Verifier usually influence proof techniques making proofs better in different senses: shorter, better structured [44], more readable [45], more effectively processed [36], etc. MML is then a subject to constant changes and revisions [24].In the current version of the MML there are 194 occurrences of flexary conjunctions and 258 occurrences of flexary disjunctions – 23 flexary conjunctions and 19 flexary disjunctions are in formulations of theorems and definitions; and 171 flexary conjunctions and 239 flexary disjunctions are in proofs. Some of them were introduced by authors while writing new articles, but some were introduced as a result of a revision carried out on the MML while testing how Verifier works with flexary formulae.Flexary formulae influence the Mizar Mathematical Library in at least two aspects. First, they allow us to integrate several theorems (often possibly infinite sequences of theorems) into one theorem, and in fact to get rid of lists of such lemmas from the MML. Second, application of flexary formulae allow us to shorten proofs.Natural applications of flexary connectives are in theorems on properties of natural numbers, liketheorem :: NAT_6:13 [48]for n being non-zero natural number, x being integer number holdsx,0 are_congruent_mod n or...or x,n-1 are_congruent_mod n;ortheorem :: NAT_1:60[4]for m,n being Nat st n<=mholds n=0 or ... or n=m;Using the flexary disjunction in theorem NAT_1:60 enabled us to formulate the theorem as is and to remove the sequence of lemmasfornbeingNatstn <=1holdsn=0orn=1;fornbeingNatstn <=2holdsn=0orn=1orn=2;fornbeingNatstn <=3holdsn=0orn=1orn=2orn=3;which for a long time contained 13 such formulae. The theorem covers all cases between the bounds 0 and m in this case.Other usages occur in properties of particular objects constructed for some fixed limits, for example describing instructions of mathematical models of computing machines (SCM is one of the models developed in the MML)theorem :: RELOC:4 [50]for I being Instruction of SCM, k being Element of NAT stInsCode I=0 or ... or InsCode I=5 holds IncAddr (I,k)=I;or describing different logical languages and systemstheorem :: CQC_THE1:21 [13]0 in Proof_Step_Kinds & ... & 9 in Proof_Step_Kinds;where Proof_Step_Kinds are defined asdefinitionfunc Proof_Step_Kinds -> set equals:: CQC_THE1:def 3{k where k is natural number :k<=9};end;Another natural application of flexary formulae is the theory of finite sequences. Basic examples from the MML are properties of the concatenation of sequences:theorem :: FINSEQ_3:154 [56]for p being n-element FinSequence, q being FinSequenceholds (p ^ q).1=p.1 & ... & (p ^ q).n=p.n;andtheorem :: FINSEQ_3:155 [56]for p being n-element FinSequence, q being m-element FinSequenceholds (p ^ q).(n+1)=q.1 & ... & (p ^ q).(n+m)=q.m;Moreover, many formulae about finite sequences are of the formforibeingNatst1 <=i & i <=lenfholdsP[i];which is simply the expansion ofP[1]&…&P[len f];But, because the property P occurs in the flexary form twice, readability of such formulations depends on the length of the property P. For that reason, the Library Committee that is responsible for management of the Mizar Mathematical Library recommended not to change that part of the MML, and to leave decisions about using flexary connectives in such cases to the authors of submissions.Main profits from flexary connectives used on the level of formulation of theorems are single theorems expressing sequences of lemmas formulated for different values of numbers. However, inside proofs, flexary formulae allow us to replace classical conjunctions and classical disjunctions containing a number of conjuncts or disjuncts by one formula. For example, the usage of flexary formulae in the article DESCIP_1[42] has shortened it from 4430 to 3360 lines (24%) and from 153,917 to 114,975 bytes (25%). It is a result of replacing the reasoningsiinSeg64;theni=1ori=2ori=3or...ori=64byFINSEQ_1:91;which was traced in the article dozens times for different numbers, by the reasoningsiinSeg64;theni=1or...ori=64byFINSEQ_1:91;where theorem FINSEQ_1:91[7] says thatxinSegnimpliesx=1or...orx=n;Quite common examples of using flexary formula in the MML are consequences of theorems comparing some natural numbers representing varied objects in various theories, e.g. codes of instructions (InsCode) of some computing machines (SCM+FSA). For exampleInsCodeI=0or...orInsCodeI=12;is a consequence oftheorem :: SCMFSA_2:16 [55]for I being Instruction of SCM+FSA holds InsCode I<=12;A specific way of processing flexary disjunctions (generating the disjunction of atomic formulae for consequent numbers between bounds of the flexary disjunction described in details in next sections) allows to construct splitting reasoning (per cases) in the way presented in the exampleassumen=0 or...orn=2;thenpercases;supposen=0;…end;supposen=1;…end;supposen=2;…end;The statement then per cases does not require any additional justification, because the flexary disjunction n=0 or ... or n=2 is internally expanded to the disjunctionn=0orn=1orn=2which enables to split the reasoning into the three cases.Ellipses are discussed and used in some other formal languages as well, e.g. [29,28,49,10,34].Extensions of formal systems and languages by new constructions can be processed in different ways, e.g.:•as syntactic sugar of some built-in mechanisms preprocessed at the syntactic level,by introducing new inference rules.In the case of flexary formulae, each flexary conjunctionϕ(a)∧…∧ϕ(b)could be treated as syntactic sugar of the formula∀i∈N:a≤i∧i≤b⇒ϕ(i)and each flexary disjunctionϕ(a)∨…∨ϕ(b)as syntactic sugar of the formula∃i∈N:a≤i∧i≤b∧ϕ(i). Syntactic sugar makes texts more varied, but it does not enable us to replace the above-mentioned sequence of lemmas with one lemma. If we, for example, expandform,nbeingNatstn<=mholdsn=0or…orn=m;we get the formulaform,nbeingNatstn<=mexibeingNatst0<=i&i<=m&n=i;that only states, in a complicated way, that natural numbers are non-negative.Expressiveness of an ellipsis may be semantically increased by defining new inference rules to process it. We use the following rule proposed by Andrzej Trybulec:(5)α(i)&⋯&α(j)α(i)&⋯&α(j)that replaces flexary conjunction by the “long” conjunction provided the length of the conjunction is known. Note the difference in fonts (different dots):&⋯&is a Mizar ellipsis, while&⋯&is a meta ellipsis. For example(6)α(1)&…&α(4)α(1)&α(2)&α(3)&α(4)In the Mizar language, flexary formulae are represented by two new binary logical connectives & ... & denoting the flexary conjunction and or…or denoting the flexary disjunction. These two connectives are represented by three tokens each (spaces between dots and both & and or are allowed). Priority of flexary conjunction is set between priorities of regular conjunction and regular disjunction; and priority of flexary disjunction is set between priorities of regular disjunction and implication. That is, Mizar allows connectives not, &, & ... &, or, or ... or, implies and iff listed in the descending priority order (with one exception because priorities of implication and equivalence are equal).Parser processes flexary connectives as other connectives. But, to increase readability of formulae involving flexary connectives one more parsing rule has been implemented. Namely, if a formula with a flexary connective is an operand of another flexary connective we get the formula of the formα(m,i)∧…∧α(m,j)∧…∧α(n,i)∧…∧α(n,j).If such an embedding is applied k times, we get a formula containing2k−1ellipses, where the main one is on the2k−1-th place. To improve the readability of such formulae, when operands of flexary formulae are flexary, parentheses around operands are obligatory. The correct form of the above formula is(α(m,i)∧…∧α(m,j))∧…∧(α(n,i)∧…∧α(n,j)).In this section requirements and restrictions of flexary connectives implemented in Mizar are explained.Flexary conjunction and flexary disjunction are intended to represent classical conjunctions and classical disjunctions of series of formulae, which conjuncts and disjuncts express some relations involving consequent numbers. For example, in the formulafornbeingNatstn<=3holdsn=0orn=1orn=2orn=3;the disjunction n=0 or n=1 or n=2 or n=3 states several disjuncts, in which the variable n is compared with consequent numbers from 0 to 3, and as such could be written as the flexary disjunction n=0 or ... or n=3, which should be semantically equivalent to the original disjunction. To make both disjunctions equivalent Verifier should be able to expand the flexary disjunction to the classical disjunction of appropriate disjuncts. To make it possible several conditions should be satisfied by all formulae involved in flexary formulae.First of all, an important condition that flexary formulae must fulfill is that their both operands (flexary conjunction and flexary disjunction are binary connectives) must be of the same form, in the sense that•If the left operand is an atomic formula (a formula with neither logical connective nor quantifier), then the right operand is an atomic formula, as well. Moreover, in such a case both operands must use the same predicate, if they are predicative formulae; the same adjective, if they are adjective formulae; and the same type, if they are qualifying formulae.If the left operand is a compound formula, then the right one must be a compound formula. Moreover, both operands must use the same connective or quantifier, and their all operands must be of the same form in the sense just defined. More precisely, because Verifier represents all formulae using negations, conjunctions and general quantifiers only, the internal representations of the operands of flexary connectives must agree with each other.If the condition is satisfied, Analyzer tries to detect bounds of expansions. Computation of the bounds is based on terms occurring in formulae being operands of flexary formulae, sayϕ(a)andϕ(b). The terms a and b represent the minimum difference between forms of terms ofϕ(a)andϕ(b). It is important to notice that only one difference is allowed, but it may occur in operands several times. For example,ϕ(n)∧…∧ϕ(n+5)results in a=n andb=n+5, whileϕ(n+0)∧…∧ϕ(n+5)gives a=0 and b=5.Finally, Analyzer establishes communication of flexary formulae with non-flexary mathematics. It is realized by generating special formulae (called expansions) related to flexary formulae. The expansion of each flexary conjunctionϕ(a)∧…∧ϕ(b)is(7)∀i:a≤i∧i≤b⇒ϕ(i)and the expansion of every flexary disjunctionϕ(a)∨…∨ϕ(b)is(8)∃i:a≤i∧i≤b∧ϕ(i).Moreover, when the distance from a to b is small (in the current implementation it is set to 100), the Rule (5) is applied, and one more expansion for each flexary formula is generated. For flexary conjunctions it is(9)ϕ(a)∧ϕ(succ(a))∧…∧ϕ(b)and for flexary disjunctions it is(10)ϕ(a)∨ϕ(succ(a))∨…∨ϕ(b).The number of components in expansions is controlled to avoid generating too long formulae, which could decrease effectiveness of the processing.The question that arises here is what is the i in formulae (7) and (8). More precisely, what is the type of i, and what are the types of the bounds a and b. It is seen that variable i has to be comparable with a and b; the successor of a has to be definable; and the distance from a to b has to be computable.Among various types satisfying all these requirements (e.g. naturals, integers, ordinals) in the current implementation of Verifier and the current content of the MML it was decided to choose the natural numbers as the type of all these three components a, b and i. In this context, the notion of a natural number is associated with its definition introduced to MML in [5]. To ensure that the definition is accessible in articles using flexary connectives, the environment parts (imports from the database) of the articles have to contain a special directive requirements NUMERALS. Moreover, because the comparison of numbers is involved in generated expansions requirements REAL is necessary. The lack of these directives is reported by the respective errors, see Section 4.6.In next sections we present how generated expansions are used by Checker.The Mizar proof system is based on the Jaśkowski style of natural deduction [31]. Structures of proofs are related to the structures of the formulae being proved. However, if for some reasons it is difficult or impossible to trace reasoning on the level of flexary formulae, Reasoner allows moving to non-flexary reasonings through expansions of the formulae. Possible forms of proof sketches areP[a]&…&P[b]P[a]or…orP[b]proofproofletibenaturalnumber;takei=_example_;assumea <=i&i <=b;thusa <=i&i <=b;thusP[i];thusP[i];end;end;which are compatible with generated expansions. _example_ used in the proof should be a natural number i that fulfills all conditionsa<=i,i<=b, and P[i].When a processed Mizar text is parsed and interpreted in the sense that all symbols and all operations are identified, and when the structure of proofs is accepted, the main phase of verification is launched. Verifier checks the obviousness of proof steps [46] processing single inferences one by one. A single inference is a formulaϕ1,ϕ2,…,ϕnψwhere the formulae ϕiare premises and ψ is the conclusion. Since Mizar is a disprover, the conclusion is negated and added to the premises, so such an inference is transformed toϕ1,ϕ2,…,ϕn,¬ψ⊥or more precisely to(11)ϕ1∧ϕ2∧…∧ϕn∧¬ψ⊥where⊥means falsehood.The premise is then translated into its disjunctive normal form (DNF), i.e. a disjunction of conjunctions of possibly negated propositionally atomic formulae. Propositionally atomic formulae include atomic formulae, flexary formulae, and formulae whose the principal operator is a universal quantifier. Since the acceptance of the original inference is equivalent to the refutation of the corresponding DNF, i.e. refutation of each disjunct separately, the task of next passes of the inference checker (i.e. Equalizer and Unifier) is to check inferences of the formα1∧α2∧…∧αk⊥where the αiare possibly negated propositionally atomic formulae.The main idea behind justification of inferences including flexary formulae is to expand such formulae and to connect each flexary formula with its expansion. Such an extension is realized at the stage when the formula (11) is generated. Let φ represents a formula occurring in the formula (11) andφ^represents its expansion generated by Analyzer. If φ is positive, i.e. when φ is a premise, then its expansion is connected conjunctively, that is φ is replaced by the conjunctionφ∧φ^. Whereas if φ occurs negatively, i.e. when¬φis a premise, then its expansion is connected disjunctively, that is φ is replaced by the disjunctionφ∨φ^, what by the de Morgan law results in¬φ∧¬φ^. In both cases we get the stronger set of premises. Such an approach (expanding a formula conjunctively or disjunctively depending on its sign (dual instantiation[9])) protects satisfiability of the input inference, because any formula α is satisfiable if and only ifα∧αis satisfiable and α is satisfiable if and only ifα∨αis satisfiable.The same technique has also been successfully implemented in the Mizar system when definitional expansions of formulae where added to the formulae and processed by Checker[33].Flexary connectives are binary connectives. It is natural to talk about their algebraic properties. In this section we present why the Mizar implementation of flexary connectives does not preserve basic properties of binary operations. Flexary connectives implemented in the Mizar system, in contrary to their non-flexary counterparts, are neither associative, commutative, nor idempotent.A binary operationf:A×A→Ais associative, if for everya,b,c∈Aholdsf(f(a,b),c)=f(a,f(b,c)). In terms of flexary conjunctions the property can be expressed as(α∧…∧β)∧…∧γ=α∧…∧(β∧…∧γ), whereα,βand γ are arbitrary formulae. But, as was said earlier, both operands of flexary connectives have to be of the same form, and it may be not satisfied by the formula γ in(α∧…∧β)∧…∧γand by the formula α inα∧…∧(β∧…∧γ). For example, atomic α or γ do break the property.A binary operationf:A×A→Ais commutative, if for everya,b∈Aholdsf(a,b)=f(b,a). In terms of flexary conjunctions the property can be expressed asα∧…∧β=β∧…∧α, where α and β are arbitrary formulae. Assuming that both formulae α and β satisfy all requirements verified by Analyzer described in Section 4.2 (this assumption is fulfilled when we can writeα∧…∧β), commutativeness can be rewritten asϕ(a)∧…∧ϕ(b)=ϕ(b)∧…∧ϕ(a)for some bounds a and b. Then, two expansions are generated:∀i∈N:a≤i∧i≤b⇒ϕ(i)and∀i∈N:b≤i∧i≤a⇒ϕ(i), which fora≠bare not equivalent.A binary operationf:A×A→Ais idempotent, if for everya∈Aholdsf(a,a)=a. In terms of flexary conjunctions the property can be expressed asα∧…∧α=α, for arbitrary formula α; or after computing boundsϕ(a)∧…∧ϕ(a)=ϕ(a). Because the expansion∀i∈N:a≤i∧i≤a⇒ϕ(i)of the formulaϕ(a)∧…∧ϕ(a)is equal toϕ(a), from mathematical point of view flexary formulae are idempotent. But, during the designing process of flexary formulae in Mizar it was decided that Analyzer should not allow to use the same formula as the left and the right operand of any flexary formula. Mizar users are then forced to write simply α instead ofα∧…∧α. As a consequence, flexary connectives implemented in the Mizar system are not idempotent.Similar reasonings can be made about flexary disjunctions, which in Mizar are neither associative, commutative, nor idempotent, as well.In this section all errors to flexary formulae which can be detected by Verifier in Mizar texts are listed. ::> starts lines with comments that are generated by Verifier. Short explanations of reasons of the errors and possible solutions to the errors are also presented.0 in 10 & ... & 9 in 10;::>⁎281::> 281: "NUMERALS" missing in the "requirements" directive0 in 10 & ... & 9 in 10;::>⁎282::> 282: "REAL" missing in the "requirements" directiveExpansions of the above formulae involve the adjective natural and the comparison of numbers<=. To ensure that these two notions are accessible in a given article, the environment part of the article has to contain the directive requirements NUMERALS, REAL.1 in 10 & ... & 9 in 10 & ... & 1 in 20 & ... & 9 in 20;::>⁎395::> 395: Justification expectedThe formula is a flexary conjunction of flexary conjunctions. Parentheses around the flexary conjunctions being operands are necessary. The correct form is (1 in 10 & ... & 9 in 10) & ... & (1 in 20 & ... & 9 in 20);.1 in 10 & ... & 1 in 10;::>⁎283::> 283: The left and the right operand of the ellipsis are the sameThe comment of the error explains it. The correct form is simply 1 in 10;.1 < 10 & ... & 9 in 10;::>⁎284::> 284: The left and the right operand of the ellipsis::>differ in their predicate symbolThe left operand of the flexary formula compares numbers (using predicate<), while the right one considers membership (using in). Different relations are not allowed.1 in 10 & ... & 9 in 20;::>⁎285::> 285: The left and the right operand of the ellipsis::> differ in more than one termAnalyzer detected differences in formulae in two places: in the left arguments of the membership (from 1 to 9) and in the right arguments of the membership (from 10 to 20). These two differences cause that the iterator cannot be determined uniquely, and the error is reported.-1 < 10 & ... & 9 <10;::> ⁎286::> 286: The ellipsis term in the left operand::> is not a natural number1 < 10 & ... & -9 < 10;::>⁎287::> 287: The ellipsis term in the right operand::> is not a natural numberAnalyzer detected differences in formulae: from −1 to 9 in the first example and from 1 to −9 in the second one. The current implementation of flexary formulae requires natural bounds, not integer. A natural way to express such properties is their expansions, that isforibeingIntegerst−1 <=i& i <=9holdsi <10;andforibeingIntegerst−9 <=i& i <=1holdsi <10;1 in 10 & ... & 9 in 10prooflet m be Nat;assume 1 < = & m < = 10;::>⁎52thus m in 10;::>⁎4end;::> 52: Invalid assumptionAnalyzer detected bounds 1 and 9, and then the generated expansion is formbeingNatst1<=m&m<=9holds m in 10;.The proof sketch has to fit the formula, and then the assumption should be1<=m&m<=9;.Verification of Mizar texts is dispersed among different modules of the entire checker. The proposed extension of the Mizar system required touching each basic module: Scanner to introduce a new token (…); Parser to introduce parsing rules interpreting new connectives (&…& and or…or); Analyzer to compute bounds of flexary connectives (length of conjunctions and disjunctions) and to generate corresponding expansions; Reasoner to control correctness of sketches of proofs involving flexary connectives; and finally Checker to strengthen premises of processed inferences by expansions generated by Analyzer. Changes in Scanner and Parser were very routine – support for evident cases has been added to existing procedures. The biggest effort was done in the implementation of Analyzer – new procedures comparing various kinds of formulae being left and right operands of flexary connectives, the algorithm computing the smallest differences between all terms occurring in the formulae and procedures generating adequate expansions have been implemented. Changes in Checker use also typical Mizar techniques and procedures. Available expansions of formulae are added to the expanded formulae by Prechecker, and then processed in the standard way.Moreover, because Mizar Verifier is not designed to have a small proof kernel (what results in that the de Bruijn criterion is not met by Verifier), but it contains pieces of code used for various purposes, some other modules of Verifier were modified – modules that are not directly involved in the verification of Mizar texts, but serve, for example, for generating input for HTML-presentation of knowledge collected in the MML, as an input for automated theorem provers (ATP), etc.At the end we present some statistics about implementation. Table 1shows the number of files involved in each basic module, the number of lines before introducing ellipsis and after that, the difference between both numbers, and the ratio between the differences and the number of lines before the implementation of flexary connectives. Scanner and Parser are listed together because they both are related to lexical analysis of Mizar texts. Analyzer and Reasoner are listed together because in practice Reasoner is a part of Analyzer.

@&#CONCLUSIONS@&#
