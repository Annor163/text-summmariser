@&#MAIN-TITLE@&#
Evolving Fortran types with inferred units-of-measure

@&#HIGHLIGHTS@&#
We provide a units-of-measure type system for Fortran as a pre-processor.This provides a lightweight verification tool for computational science code.Our approach aids adoption to existing code via type inference and polymorphism.A ‘critical variables’ procedure guides minimal annotation for maximum information.Our approach reduces the unit annotation burden by roughly 80%.

@&#KEYPHRASES@&#
Units-of-measure,Dimension typing,Type systems,Verification,Code base evolution,Fortran,Language design,

@&#ABSTRACT@&#
Dimensional analysis is a well known technique for checking the consistency of equations involving physical quantities, constituting a kind of type system. Various type systems for dimensional analysis, and its refinement to units-of-measure, have been proposed. In this paper, we detail the design and implementation of a units-of-measure system for Fortran, provided as a pre-processor. Our system is designed to aid adding units to existing code base: units may be polymorphic and can be inferred. Furthermore, we introduce a technique for reporting to the user a set of critical variables which should be explicitly annotated with units to get the maximum amount of unit information with the minimal number of explicit declarations. This aids adoption of our type system to existing code bases, of which there are many in computational science projects.

@&#INTRODUCTION@&#
Type systems are one of the most popular static techniques for recognizing and rejecting large classes of programming error. A common analogy for types is of physical quantities (e.g., in [2]), where type checking excludes, for example, the non-sensical addition of non-comparable quantities such as adding 3m to 2J; they have different dimensions (length vs. energy) and different units (metres vs. joules). This analogy between types and dimensions/units goes deeper. The approach of dimensional analysis checks the consistency of formulae involving physical quantities, acting as a kind of type system (performed by hand, long before computers). Various automatic type-system-like approaches have been proposed for including dimensional analysis in programming languages (e.g.[10] is a famous paper detailing one such approach, which also cites much of the relevant history of other systems).Failing to ensure that the dimensions (or units) of values are correctly matched can be disastrous. An extreme example of this is the uncaught unit mismatch which led to the destruction of the Mars Climate Orbiter [20]. Many programs in computational science are also sensitive to this kind of error since they focus on modelling the physical world. The software for the Mars Orbiter had orders of magnitude more resources devoted to the robustness and correctness of code than is possible in normal scientific research circumstances. It therefore seems inevitable that these errors are likely in computational science too.The importance of units is often directly acknowledged in source code. We have seen source files carefully commented with the units and dimensions of each variable and parameter. We have also watched programmers trying to use this information: a process of scrolling up and down, repeatedly referring to the unit specification of each parameter. Incorporating units into the type system would move the onus of responsibility from the programmer to the compiler.A recent ISO standards proposal (N1969) for Fortran introduces a units-of-measure system which follows Fortran's tradition of explicitness [7]. Every variable declaration must have an explicit unit declaration and every composite unit (e.g., metres times seconds) must itself be explicitly declared. This imposes the extra burden of annotating variables directly on the programmer. As an example, we studied two medium-sized models (roughly 10,000 lines of code each) and found roughly a 1:10 ratio between variable declarations and lines of code. Thus, adding explicit units of measure to a project with 10,000 lines of code means manually adding 1000 unit declarations. This is prohibitively large.In this paper, we show how the bulk of this work can be done automatically based on a few manual annotations. This approach might be used to automatically add N1969 annotations to a codebase or in an Integrated Development Environment (IDE) to inform the programmer of the units as they code. Our approach is to add a validation step prior to compilation: our tool takes annotated Fortran code and validates the units. The annotations can then be automatically removed and the program compiled as normal using the preferred compiler.We describe a lightweight extension to Fortran's type system for polymorphic units-of-measure (Section 2) and explain the inference process which reduces the amount of explicit declaration required (Section 3). By default, it is always possible to infer all variables as “unitless” if no explicit unit declarations are given. However, this is not useful. In order to minimise the task of adding explicit unit declarations, our system can automatically identify a minimal set of variables for which an explicit annotation is needed (Section 4). We evaluate our approach on a number of small but useful examples Section 5) and show we can reduce the burden of explicit annotation by roughly 80%. We compare our approach with existing proposals and argue that our system is more lightweight and requires less programmer effort (Section 6).The general idea and approach of inferring units-of-measure is already well established. Instead the contribution of this paper is in the application of this technique to Fortran and existing code base, helping to evolve the language and co-evolve existing code via inference and our method for identifying which variables require manual annotation.The type checker, inference, and analysis described here are implemented as part of the CamFort project, a research infrastructure for the analysis, transformation, refactoring, and extension of Fortran [14]. CamFort is open-source and available online.11http://www.cl.cam.ac.uk/research/dtg/naps.Our long term interest is in how software engineering interacts with the scientific method and how techniques from programming language theory and design can be beneficially applied [15]. The present paper is a contribution in this space.ExampleFig. 1shows a simple Fortran program which computes (one-dimensional) velocity (v) and speed (s) from a given distance (x) and time (t). As a use case of our tool, the programmer initially runs the analysis phase of CamFort (Fig. 1(a)) and is told that only x and t need be annotated. Fig. 1(b) shows the syntax used by the programmer to add m (metres) and s (seconds) units respectively to the distance and time variables. CamFort then infers the units of v and s automatically from the program itself and inserts those into the code (without disturbing any formatting/comments).Unit attributes In our extensions, units-of-measure can be explicitly declared for variables similarly to types and other attributes of variables. Our extension adds the attribute unit, which is shown in the above example (Fig. 1). The unit attribute takes a single unit expression as an argument, the syntax of which is defined by the following grammar (where the right-hand side shows an example of the syntax):(grammar)(description)(example)name::=[a−zA−Z]+unitnames;regularexpressionm,metres…ℝ::=ℤintegerconstants1,2,−2…∣ℤ/ℤfractionoftwointegers2/3,4/2…u,v::=ϵempty—equivalenttounitlessx∣1unitlessunit(1)::x∣nameunitidentifierunit(m)::x∣u**(ℝ)rationalpowerunit(s**(1/2))::x∣uvproductunit(ms**2)::x∣u/vdivisionunit(m/s**3)::xIdentifiers for unit names are not themselves explicitly declared. For example, a unit attribute unit(m) implicitly introduces the unit named m to the program, where any other uses of m as a unit in the program denote the same unit.A unit attribute can be given to any type, not just numerical types (this differs from others, e.g., [10]). In practice, numerical types tend to benefit the most from unit attributes, but there are some situations where it is useful to ascribe units to non-numerical types, e.g., to string representations of numerical values or to booleans for grouping related control variables.An empty unit expression is equivalent to a unitless specification, i.e., unit()=unit(1). Any variable which does not have an explicit unit declaration will have its unit inferred.Unit declarations Named aliases for unit expressions can be declared in the declarations part of a Fortran file with the following syntax:decls::=…∣unit::name=u(namedalias)unit::speed=m/sDuring unit checking, any occurrences of a derived unit name are replaced by their declared unit expression. Hence in the unit checker, an alias is indistinguishable from its defining unit expression. A global check ensures that no named aliases conflict (e.g., redefine) each other.Type systemFig. 2describes the type system of CamFort in a standard declarative and inductive way, defining the relation Γ⊢F:u, where Γ is a map from program variables to their unit and F is a Fortran expression of unit u. The type system definition (and its implementation) extends the visible syntax of units with some additional constructs: (1) function types(u1,…,un→v)i.e., the unit specification of a Fortran function with n formal parameters (or dummy variables in Fortran parlance) of units u1…unand result unitv, (2) variable placeholders for units, written α (3) universal quantification ∀α.u for unit polymorphism. Fig. 2 shows the polymorphic unit types of some core Fortran intrinsic operators. When a unit is associated with a value type (e.g., integer) we write u[t] for a value type t as in rule (real-pow). The (int-pow) and (rational-pow) rules raise their unit to the power provided by a static constant.Polymorphism in our unit system follows a similar approach to that of types in the polymorphic λ-calculus [18], though we restrict universal quantification to the top-level of a unit expression (i.e., not nested). The introduction of universal quantification (unit generalisation) occurs only when a function is defined. The complementary (spec) rule, specialises a universally quantified unit by substituting a unitvfor the variable α. By the form of the (app) rule, a polymorphic function must be specialised first before it is applied. For example:(app)(spec)[α↦m]Γ⊢abs:∀α.α→αΓ⊢abs:m→m(var)(x:m)∈ΓΓ⊢x:mΓ⊢abs(x):mUnit polymorphism example A key part of our unit type system is that it provides polymorphic unit support on top of Fortran's monomorphic type system. As an example, Fig. 3(a) defines a square function without any unit annotations. Under the typing scheme described in this section, then square:∀u.[u]real→[u**2]real. Fig. 3(b) shows a program fragment using square with two different units. These are inferred as m**2 and s**2 respectively by specialising the type of square. As an example of a function which combines both unit polymorphism with monomorphic units, Fig. 3(c) defines a function which squares its input then scales by a real number of unit m. By our typing scheme, scale_square:∀u.[u]real→[mu**2]real, which exposes constant scaling by a real of unit m inside the function.Inference of units is done through Gaussian elimination, similar to the work of Kennedy [10]. The idea is that the type system described in the previous section can be used to generate a series of constraints on unit terms which can be treated as linear equations and solved using the standard Gaussian elimination method. Here we briefly outline our technique through two examples, one for a monomorphic program, and the other for a polymorphic program.Monomorphic exampleFig. 4(a) shows a simple program and Fig. 4(b) the corresponding constraints generated from the rules of the units-of-measure system. Each constraint is turned into a linear equation (sum of scalar-variable products) by taking logarithms, e.g.:uvolume=upi·uradius2·uheight⟶logloguvolume=logupi+2loguradius+loguheightThis system of linear equations is then represented as a matrix in the type checker, where each equation is a row and each column is a log variableloguv(forloguvwe write justvfor the column headings here). Gaussian elimination is then applied by scaling a row by a non-zero scalar, adding one row to another, or swapping rows. These operations are applied until the matrix is in row echelon form, where all entries to the left of the diagonal are zero. Fig. 5shows this transformation for our example monomorphic program.A matrix in reduced row echelon form has zero in every entry apart from its diagonal (like the above). This represents a unique solution to the system of equations. In this case, we have a unique solution for the typing of the program, where every inferred type is then added into the program. For example loguvolume=3logm and so uvolume=m3.Polymorphic example To accommodate polymorphism in the Gaussian elimination procedure, we extend the usual technique slightly. As an example, consider the polymorphic square function in Fig. 3(a), and its use in Fig. 3(b) with two variables of different units.Functions and subroutines in a program are analysed and a set of constraints is built and reduced using Gaussian elimination. This results in a relationship between the units of the parameters and the unit of the result. This relationship, which we call a procedure constraint, results in a constraint on units. The procedure constraint for square is 2logusquare#0=logu=square, meaning the log-unit of the result is two times the log-unit of the first (and only) parameter.For every procedure call a new constraint (matrix row) is added based on the corresponding procedure constraint by copying the parameter coefficients to the columns for the corresponding arguments and copying the result coefficient to the column of the calling expression. This step corresponds to the (spec) rule in Fig. 2; this new constraint introduces a unit specialisation.If there are local variables in the procedure which require annotation then CamFort identifies these when deriving the procedure constraint. These can then be annotated by the programmer as required. This approach is sufficient for all cases except if the units of the local variable depend on the units of the parameters. The CamFort syntax currently does not allow a programmer to express this polymorphism. We plan to address this in future work.Consider an expression a + b + c. In the units system described above, this expression elicits the constraints that a, b, and c have equal units. Without any concrete unit given to any of these variables, the inference procedure can only infer they are unitless. But to give a concrete, unitful type requires only a single explicit unit annotation for one variable, not all.In order to reduce the burden on programmers adopting our units-of-measure system and evolving their existing code, our tool includes a feature for reporting on “critical” subsets of the variables in a program which, if given an explicit annotation, provide a solution without any unnecessary defaulting to unitless. This was shown in Fig. 1(a). Here we outline the procedure, which builds on the Gaussian elimination procedure described in Section 3.Consider the program fragment e = a + b*c*d in which only d has an explicit unit declaration as unit m. For this program, the system generates the following constraints and corresponding linear constraints (by applying the logarithm and rearranging variables to the left):(1)ua=ueua=ubucudud=mlogua−logue=0logua−logub−loguc−logud=0logud=logmThe linear constraints are represented via the following matrix (on the left) which is then reduced into row echelon form (on the right):(2)If there are non-zero values on the leading diagonal of the matrix then we can solve for all variables (this is the back-substitution phase of Gaussian Elimination). Therefore, a zero value on the diagonal corresponds to an unknown variable. In the right matrix above, we can follow the leading diagonal for variables a and b, but the third row has no value to determine c. Instead the column for d has the leading non-zero coefficient, so we record c as missing and continue. We then find that e is missing (it has no row with a leading non-zero coefficient) and so record this too and stop. Variables c and e are therefore reported as being critical variables.DefinitionCritical variables, formallyLet mibe the number of the first column in the row i with a non-zero coefficient, assigning the value of ∞ if all columns are zero (or undefined). The critical variable set C has the property that ∀k such that mi<k<mi+1 thenvk∈Cfor each row i where mi+1>mi+1.There are often many possible solutions for C, but each will provide equivalent information.ExampleIn the matrix above m1,m2,m3,m4,m5 are the values 1,2,4,∞,∞ respectively. When i=2 we have m3=4 and m2=2 so m3>m2+1. C therefore containsvkfor 2<k<4 (i.e., k=3). Also, when i=3 we have m4=∞ and m3=4 and so we addvkfor 4<k<∞ (i.e., k=5) to C. Therefore the critical variable set for is{v3,v5}which are the variables {c, e}.An interesting nuance to the critical variable analysis is deciding what units to infer for literals; a literal constant in a program might be unitless (e.g., a scalar translation) or not. There is no single correct choice which covers all situations and so we provide an option to control the default assumption made by CamFort. We illustrate the three available choices via the example of Celsius-Fahrenheit conversion: s = 1.8; a = 32.0; f = s * c + a.•Polymorphic literals are assumed polymorphic. In this case the possible critical variable sets are {f, s}, {f, c}, {s, c}, {s, a}, {c, a}. This is the safest option as it minimises the number of values assumed to be unitless, but in turn will require the most annotation.Unitless literals are assumed all to be unitless. In this case no further annotation is required for our example since this forces all quantities to be unitless.Mixed literals are assumed to require units if used in a conf−op or a rel−op (see Fig. 2) and to be unitless otherwise. This captures the intuition that we add a value with units (+ is a conf−op) but we multiply by a unitless scalar. This option leaves the possible critical value sets as {f},{c},{32.0}, each requiring less annotation than the polymorphic case.

@&#CONCLUSIONS@&#
