@&#MAIN-TITLE@&#
Can local NURBS refinement be achieved by modifying only the user interface?

@&#HIGHLIGHTS@&#
A mechanism providing local NURBS refinement by changing only the user interface.Provides the user with local editing without changing the underlying representation.A middle way between global refinement and changing to a different representation.The method will degenerate to non-local refinement in certain cases.

@&#KEYPHRASES@&#
NURBS,User interface,Local refinement,Surface design,Hierarchical B-spline,Control mesh,

@&#ABSTRACT@&#
NURBS patches have a serious restriction: they are constrained to a strict rectangular topology. This means that a request to insert a single new control point will cause a row of control points to appear across the NURBS patch, a global refinement of control. We investigate a method that can hide unwanted control points from the user so that the user’s interaction is with local, rather than global, refinement. Our method requires only straightforward modification of the user interface and the data structures that represent the control mesh, making it simpler than alternatives that use hierarchical or T-constructions. Our results show that our method is effective in many cases but has limitations where inserting a single new control point in certain cases will still cause a cascade of new control points to appear across the NURBS patch.

@&#INTRODUCTION@&#
NURBS are the standard mechanism for modelling in CAD. For decades  [1], there has been interest in producing hierarchical NURBS, NURBS with T-junctions, and other NURBS variants that allow for local refinement of a NURBS patch (Section  3). None of these solutions, however, has yet been widely adopted in the CAD industry. Some require significant changes to the underlying NURBS engine. We investigate whether it is possible to construct a mechanism that provides local refinement to the designer by modifying only the user interface, leaving the underlying NURBS engine unchanged (Sections  5 and 6).Our motivation is that providing local refinement through the user interface alone would allow CAD software providers to add the extra functionality without the need to make expensive additions and changes to the underlying NURBS engine. Our investigation shows that our method does deliver such functionality but that it suffers from inescapable limitations (Section  8). Nevertheless, this idea provides an interesting intermediate option between the status quo and adoption of a new engine.Bivariate NURBS patches are composed, in parameter space, as the tensor product of univariate NURBS. It is well known that, in the univariate case, a NURBS curve can be locally refined arbitrarily often in arbitrary locations (Fig. 3). A NURBS patch cannot be refined arbitrarily often at arbitrary point locations, owing to its tensor product nature. Any refinement of the NURBS patch will stretch from one side of the patch to the other (Fig. 1).Our basic idea is to provide a mechanism whose user interface shows only the desired control points to the designer. That is, it hides unwanted control points. We implement this as a series of tensor product control meshes, each of which we call a layer. Each layer is a refinement of the layer above in which a single knot is added. Some points from a given layer may be visible to the user and some may be hidden. The rationale here is that the positions of the hidden control points, in the refined layer, can be calculated from control points in the previous layer without altering the shape of the surface. This is just basic knot insertion where, in the univariate case, inserting a single knot in a curve of orderk(degreek−1) causes one new control point to be introduced andk−2existing control points to be moved without changing the shape of the curve.Our basic idea is illustrated in Fig. 2.Fig. 2(a) shows what the user sees in the user-interface. Fig. 2(b)–(f) shows how this can be implemented as a series of layers, each of which introduces a single new knot. The bottom-most layer, Fig. 2(f), is a tensor-product NURBS that is passed to the underlying NURBS engine. There are three types of points: visible control points available in the user interface (coloured circles), replaced control points (grey circles) that have been superseded by points in a lower layer, and hidden points (coloured diamonds) that are calculated from points in the layer above. Note that every layer is a tensor-product arrangement, while the control mesh visible to the user is not necessarily tensor-product and is constructed by building a mesh from the control points that are marked as visible in the various layers.

@&#CONCLUSIONS@&#
