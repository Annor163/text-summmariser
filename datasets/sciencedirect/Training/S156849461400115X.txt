@&#MAIN-TITLE@&#
Joint SPIHT compression and selective encryption

@&#HIGHLIGHTS@&#
We propose JCSE-SPIHT, an algorithm of joint compression and selective encryption based on SPIHT.We design a fast random insertion to accelerate the encryption from taking O(n2) time to O(n).JCSE-SPIHT can generate plaintext-dependent keystream by cryptographically secure PRNG.We exam the security of JCSE-SPIHT by traditional cryptanalysis and image processing techniques.

@&#KEYPHRASES@&#
Selective encryption,Joint compression and encryption,Set partitioning in hierarchical trees,

@&#ABSTRACT@&#
JCSE-SPIHT, an algorithm of joint compression and selective encryption based on set partitioning in hierarchical trees (SPIHT), is proposed to achieve image encryption and compression simultaneously. It can protect SPIHT compressed images by only fast scrambling a tiny portion of crucial data during the coding process while keeping all the virtues of SPIHT intact. Intensive experiments are conducted to validate and evaluate the proposed algorithm; the results show that the efficiency and the compression performance of JCSE-SPIHT are very close to original SPIHT. In security analysis, JCSE-SPIHT is proved to be immune to various attacks not only from traditional cryptanalysis, but also by utilizing sophisticated image processing techniques.

@&#INTRODUCTION@&#
While powerful hardware facilitates the capturing and processing of high-resolution images, the increasing volume of massive images is a great challenge for their storage and transmission, especially in some resource-constrained environments such as wireless sensor networks (WSN) and smartphone platforms. Compression plays a vital role for images in saving memory space and transmission bandwidth; it undoubtedly becomes an indispensable part in various image standards such as GIF, JPEG, and JPEG2000. Another issue is the security problem in image storage and distribution, and encryption is a prevalent and effective way to solve this problem. However, it is impractical to adopt traditional encryption schemes here due to: (1) the characteristics of image data, such as high correlation and redundancy, (2) the requirement of transmission rate in delay-sensitive communications, and (3) the requirement of energy consumption in resource-constrained environments.There have been various explorations of cryptosystems tailored for image encryption by considering the characteristics of image data and the techniques of image processing. Among those schemes, two ideas are promising and have been attracting plenty of attention in recent research. One idea is joint compression and encryption [1–11], which can perform encryption and compression in a single step by embedding encryption operation into compression process. Traditionally, encryption and compression are considered as two independent procedures; when they are concerned together, encryption usually comes after compression since the encrypted data is incompressible in theory. But when encryption is seamlessly embedded into compression, the two procedures are simplified as one. The other is selective encryption (or called as partial encryption) [12–17]. As its name indicated, selective encryption only selectively encrypts a portion of image data, i.e. the important data that is curial for image visualization. Compared with traditional encryption schemes taking the whole image data into consideration, selective encryption can improve encryption efficiency greatly as the volume of data to be encrypted is significantly reduced.Set partitioning in hierarchical trees (SPIHT) was proposed by Said and Pearlman [18] based on the work in [19]. It outperforms the other existing compression algorithms in excellent compression performance and extremely low computational complexity, and can be utilized in various application scenarios and network environments such as WSN [20]. For this reason, selective image encryption based on SPIHT has attracted increasing attentions, and lots of related work can be found in the existing literature. The selective encryption schemes based on SPIHT can be classified into categories: confidential encryption and degradative encryption. In confidential encryption, the important information for visualization is selectively encrypted to keep the whole image confidential. In [13], a selective encryption scheme is proposed to only encrypt significance information in the two highest pyramid levels. In [21] the authors proposed to confuse the positions of four coefficients having the same father node, and encrypt the sign information of coefficients by chaotic map. Later in [22], this ideal is extended to work in 3D-SPIHT algorithm. Only the significance bits of individual wavelet coefficients are encrypted for several iterations of Color-SPIHT algorithm in [23]. A secure shape and texture SPIHT (SecST-SPIHT) scheme is presented in [24] for secure coding of arbitrarily shaped visual objects, where the bits that represent object shape information and significance information of individual coefficients are selectively encrypted. In [25], the output of SPIHT is classified into structure bits and data bits, and only those structure bits are encrypted by chaotic map. To further reduce encryption overhead, the scheme in [26] only encrypts the significant bits representing the vertical descendants of coefficients in the list of insignificant sets. In [27], the output bits of SPIHT are encrypted by randomized arithmetic coding algorithm and nonlinear dynamic filters based on different application scenario. The scheme in [28] consists of two steps: DWT coefficient in the same band is first confused by a chaotic map, then the output of SPIHT is masked by another chaotic map except the two most significant bits and the sign bit. The authors in [29] employ piecewise linear chaotic map to encrypt significance information in the list of insignificant pixels for Color-SPIHT algorithm. In degradative encryption, a low-resolution version of original image is obtained after encryption for preview or access control. In [30], it is proposed to only encrypt partial sign coefficients of SPIHT output to degrade the original image and keep the skeleton discernible. The scheme in [27] also supports conditional access.There are some problems about the existing solutions. First, most existing selective encryption schemes based on SPIHT are not closely coupled with the SPIHT coding procedures as they target on the input and/or output of SPIHT. That is to say, they selectively encrypt some input and/or output coefficients of SPIHT, and have no impact on the unencrypted part of code stream. As a result, the compression procedures are unaware and independent of the encryption, and they can be separated into two independent parts. Second, the security of some existing schemes is not well analyzed and guaranteed. For example, many of them are vulnerable to chosen-plaintext attack; also, the attacks by utilizing image processing techniques are not considered. Last, some schemes utilize chaotic maps to perform the encryption, and the processing speed may be a bottleneck when dealing with massive data in real-time applications since plenty of floating-point operations are involved.In this paper, by taking both into consideration the ideas of selective encryption and joint compression and encryption, we propose a joint compression and selective encryption scheme for secure SPIHT coding. We seamlessly embed the encryption operation into SPIHT coding procedures by selectively confusing the elements of several important lists in the beginning coding passes of SPIHT. Furthermore, the confusion effect after encryption can be fully propagated to the subsequent coding procedures and the entire code stream, so the encrypted images are well protected by selectively encrypting a tiny portion of data. Finally, the coding efficiency and compression performance of SPIHT algorithm are almost intact.The contribution of this paper can be summarized as follows:•We propose JCSE-SPIHT, a joint SPIHT compression and selective encryption algorithm. Different from previous schemes that work on input and/or output coefficients of SPIHT, the encryption process of JCSE-SPIHT is embedded into SPIHT coding process.We propose a method of generating plaintext-dependent keystream in JCSE-SPIHT and make it immune to chosen-plaintext attacks.We propose a fast random insertion algorithm to accelerate the encryption from taking O(n2) time to O(n) without any security compromise, which makes the proposed scheme highly efficient.We analyze the security and performance of JCSE-SPIHT by extensive experiments, especially, we utilize some well-established image processing techniques to analyze the security of JCSE-SPIHT.The rest of the paper is organized as follows. Section 2 gives a brief review of SPIHT compression algorithm. The joint compression and selective encryption scheme based on SPIHT is described in Section 3. Section 4 presents the experimental results on the proposed encryption scheme. Security analysis is discussed in Section 5. Finally, Section 6 concludes the paper.SPIHT is an improved algorithm based on the embedded zerotree wavelet (EZW) algorithm [19], and its performance is comparable to or surpass the original EZW both in theory and practice. The encoding procedures are computationally efficient and can be stopped at any compression ratio by the feature of progressive coding. In a low ratio, the algorithm is still able to gain a clear recognizable image when an appropriate wavelet is selected.SPIHT is operated on the coefficients of discrete wavelet transform (DWT) that are organized in tree structure. Specially, an image is first transformed using a multiple-level DWT as shown in Fig. 1(a). DWT divides the image into four sub-bands: LL, HL, LH, and HH. LL sub-band is the approximation of the original image and will be decomposed recursively in multiple-level decomposition, LH sub-band preserves the horizontal edge details, HL sub-band preserves the vertical edge details, and HH sub-band represents the diagonal details. Then the resulting coefficients are grouped into spatial orientation trees (SOT) as shown in Fig. 1(b) and coded using successive approximation quantization. The following partitioning sets of coordinates are defined based on the structure of SOT: (1)O(i,j): set of coordinates of all offspring of the coefficient at (i, j); (2)D(i,j): set of coordinates of all descendants of the coefficient at (i, j); (3)H: set of coordinates of all coefficients in the root level; and (4)L(i,j)=D(i,j)−O(i,j).A significance test is defined to estimate the significance of the coefficients corresponding to the coordinates in these partitioning sets. For a partitioning subsetT, the significance test is formalized as(1)Sn(T)=1,max(i,j)∈T{|ci,j|≥2n},0,otherwisewhere ci,jdenotes the coefficient at (i, j). That means given a threshold 2n, a set of coefficientsTis significant if there is a coefficient inTwhose magnitude is at least 2n.The coordinates in these partitioning sets are then classified into three lists by the significance test as below: (1) list of insignificant sets (LIS): it contains two types of entries representing the setsD(i,j)andL(i,j), and to differentiate between them, we say that an LIS entry is of type A if it representsD(i,j), and of type B if it representsL(i,j); (2) list of insignificant pixels (LIP): a list of insignificant coefficients that do not belong to any of the sets in LIS; and (3) list of significant pixels (LSP): a list of coefficients that have been identified as significant. These lists are dynamically maintained during the running of the algorithm.The coding process of SPIHT algorithm can be summarized as: given a magnitude threshold, scan the DWT coefficients in SOT with significance test and transmit the test results and the remaining most significant bits of significant coefficients; then decrease the threshold and repeat the process. The flowchart of SPIHT algorithm is shown in Fig. 2. The algorithm consists of four phases: initialization, sorting pass, refinement pass, and quantization-step update. The initialization sets LSP as an empty list, adds all the coordinates inHto LIP, and only those with descendants to LIS as type A entries. In the sorting pass, each coordinate in LIP and LIS is fed to significance test and the result is output to code stream. If the result is true, it will be moved to LSP; otherwise it will be moved to the end of LIP or LIS. The refinement pass outputs the significant bits of coefficients in LSP except the newly added ones in the sorting pass. The magnitude of significance test is decreased in the last phase, and the last three phases are iterated until the termination condition is satisfied.In this section, we propose an algorithm of joint compression and selective encryption based on SPIHT (JCSE-SPIHT) while keeping all the virtues of SPIHT intact. The basic idea is to embed encryption into the coding procedures by selectively encrypting a small portion of vital information in the beginning coding iterations. The impact of selective encryption can propagate rapidly to the subsequent coding iterations and then protect the entire code stream. We first discuss the feasibility of scrambling the scanning order of three lists maintained by SPIHT coding algorithm, and then present the JCSE-SPIHT algorithm. We also introduce a fast random insertion algorithm with suitable data structure to accelerate the encryption. The block diagram of the proposed algorithm is described in Fig. 3.The coordinates of coefficients are used in SPIHT coding algorithm but never transmitted. As the scanning order of SOT and the results of branching test are the same both in encoding and decoding procedures, the decoder can recover the values of coefficients and their coordinates successfully. That is to say, the three lists (i.e. LIP, LIS, and LSP) created and maintained by the encoder and the decoder are identical, and are scanned with the same order. On the contrary, if the scanning orders of the encoder and the decoder are different, the original coefficients cannot be recovered, and then the reconstructed image is confused.In the process of SPIHT encoding, the scanning order is maintained by LIP, LIS, and LSP. SPIHT algorithm first scans all the coefficients in LIP to determine their significance; then proceeds to check the significance of the descendant coefficients in LIS; after scanning all nodes in LIP and LIS, it outputs refinement bits of LSP coefficients. In addition, during the encoding process, these three linked lists are interacted: if a node in LIP is significant, the node will be inserted to the end of LSP (as shown in Fig. 4(a)); if a node of type A in LIS is significant, the offspring of the node will be inserted to the end of LSP or LIP; and if a node of type B in LIS is significant, the offspring of the node will be inserted to the end of LIS (as shown in Fig. 4(b)).From Fig. 4 it is known that the significant nodes in LIP and LIS will always be inserted to the end of a determined list, and this guarantees the possibility for the decoder to duplicate the encoder's execution path and reconstruct the image exactly. If significant node in LIP or LIS is inserted into a random position instead of the end of the list, the scanning order of encoder will be scrambled and the decoder cannot duplicate this order unless it knows the random position. This process is called as random insertion.To demonstrate the different impacts of random insertion on the three linked lists, a 512×512 gray-level Lena is used as the test image (Fig. 5(a)). SPIHT algorithm runs at 1.0bpp, and random insertions are performed on LIP, LIS and LSP respectively and jointly. Rabbit algorithm [31], which is a synchronous stream cipher and faster than commonly used ciphers, is adopted as the pseudo random number generator (PRNG) to generate a random number within the current length of the list. The results are shown in Fig. 5. Fig. 5(b)–(d) shows the results of random insertion on a single list. It's clear that the decoded image is not confused very well; some blurry outlines and skeletons can be found, especially for the random insertion on LIP. Fig. 5(e)–(g) shows the results of random insertion on two lists, and the decoded images are unrecognizable. But the result of random insertion on LIS and LSP is not very good, because in the beginning of SPIHT coding, LIP contains the most significant coefficients but it is not scrambled. Fig. 5(h) shows the result of random insertion on three lists, which also has good confusion effect but is time-consuming since the volume of encrypted data is too large.Based on the above analysis, it is feasible to protect SPIHT compressed images by scrambling the scanning order during SPIHT coding. In this paper, we propose to selectively encrypt the order of LIS and LIP by random insertion, and the reasons of doing so are multifold. First, LIS and LIP control the structure of SOT, and altering the orders of LIS and LIP has significant impact on the subsequent updating of LIP, LIS and LSP, so the final visualization of the image will be totally destroyed if the orders of LIS and LIP are scrambled. Second, we only encrypt the orders of LIS and LIP in the beginning iterations which are curial to the structure of SOT, to gain a good balance between security and computational overhead. Furthermore, we also conduct the similar experiments on all the gray-level images in USC-SIPI image database [32], and the results verify the feasibility of our idea.A fast random insertion (FRI) is proposed here to accelerate the encryption, because the access to a linked list is sequential and finding a given random position is time-consuming. Specifically, in the process of random insertion, after a pseudo-random number p is generated as a position in the linked list, the pointer needs to scan the linked list from the head node till pth node, then inserts the new node before the pth node. Therefore, addressing a node in a linked list takes the time of O(n); if the encoding process generates n nodes to be inserted, the random insertion operation will totally take the time of O(n2). It is so slow that it takes about one minute to encrypt a 512×512 Lena at 1.0bpp. To conquer this drawback, we introduce a simple scheme to accelerate the speed of random insertion, which is quite fast and can obtain equal confusion effect.The basic idea of FRI is converting sequential addressing on a linked list to random addressing on a dynamic address array (DAA). DAA consists of a segment of successive memory and saves the addresses of all nodes for a linked list, as shown in Fig. 6(a), so we can access to any node of the linked list immediately rather than scan from the link header. FRI process can be described as follows. After generating a node N, add the corresponding address to DAA L in sequence; upon obtaining a random position p, it is easy to get the address L[p] which points to a node in the linked list; then insert N before the node whose address is L[p]. Fig. 6(b) gives an example of FRI where p=2, and it is clear that the new node N is inserted into the front of Node3 quickly by using L[p].By random addressing on DAA, it is clear that FRI takes O(1) time to insert a node to a random position. Given the same assumption, i.e. there are n nodes in total to be randomly inserted, FRI only takes linear time O(n) in total, which is a substantial acceleration compared to O(n2). For example, with FRI it only takes hundreds of milliseconds to encrypt a 512×512 Lena at 1.0bpp (more experimental results can be found in Section 4.2).Since the address of newly generated node is always added to the end of DAA whatever the random position is, the order of addresses in DAA may be different from those in linked list as shown in Fig. 6. That is to say, given a random position p, the newly generated node is not actually inserted before the p-th node of linked list, but before the node whose address is the p-th element in DAA. However, this inconsistency does not degrade the randomness of the insertion, and actually it achieves the same randomness as the case when the order of addresses in DAA is synchronized with those in linked list. This conclusion holds as long as the output distribution of PRNG is uniform, which is satisfied for a cryptographically secure PRNG. Under this circumstance, the randomness of the selected address in DAA is the same regardless of the order of its permutation.We propose JCSE-SPIHT, a joint SPIHT compression and selective encryption algorithm based on the preceding statements in this subsection. The basic idea of JCSE-SPIHT is performing FRI on LIP and LIS in the selected number of SPIHT coding iterations. Due to the characteristics of SOT, the number of nodes, which are near to the root and generated in the beginning iterations, is small; but they are critical for the reconstruction of the SOT since they represent the most significant information of an image. Therefore, we selectively scrambling the nodes in LIP and LIS by FRI in the first r rounds of iterations, where the parameter r controls the selective encryption strength. By proper selection of r, we can get a good tradeoff between security requirement and computational overhead.Essentially, JCSE-SPIHT is a permutation-only cipher, and one obvious deficiency of many existing permutation-only ciphers is that they are not secure against chosen-plaintext attack [33,34]. The problem is caused by that the keystream for permutation is independent of plaintext, so the attacker can recover the permutation rule if the key is reused. In this paper, we solve this problem by generating plaintext-dependent keystream by PRNG without extra payload on cipher image. The basic idea is making the generated random number dependent on significant coefficients, and the schema is described in Fig. 7. If a node is to be inserted into LIP or LIS, we feed back the significant coefficient of that node to a status vectorvby one-bit logical left shift ofv(v≪1) and concatenation it with the significant bit (the initial value ofvis randomized); thenvand the last output of PRNG c are exclusive-ORed to feed into the PRNG to generate a random value. Since the significant bits are generated by wavelet coefficients, the keystream is dependent on plain image.The procedures of proposed algorithm are described in Algorithm 3.1. Although JCSE-SPIHT is closed coupled with SPIHT coding algorithm, it only alters the process of inserting nodes into LIP and LIS. That is to say, the most part of SPIHT coding is intact and we can ignore their detail here to concentrate on the understanding of our proposed algorithm. The encryption procedures are explained as follows.Algorithm 3.1JCSE-SPIHT1: Parameter initialization: initialize the parameters of SPIHT, PRNG, and status vector (v); let i=1 (first round in SPIHT).2: SPIHT coding: run SPIHT coding algorithm until a newly generated node N is to be inserted into LIP or LIS.3: Random position generation: get the significant bit b of N,v=(v≪1)|b,s=c⊕v; take s as in input of PRNG to generate a random number c; then obtain a random position p=cmodl where l is the length of current list to be inserted.4: FRI: Insert N to position p by using FRI.5: Repeat 2–4 until current round of SPIHT coding ends;6: ifi<rthen7: i=i+1 (next round in SPIHT), and goto step 2;8: end ifIn the initialization, a secret key must be first determined to run the algorithm. A threshold value r is selected to decide how many round of encryption should be performed, i.e. to control the encryption strength. In other words, great value of r means more data will be encrypted; but small value of it will save computational overhead. In practical deployment, a proper value of r should be selected to get a good tradeoff between security and efficiency. The parameters of PRNG and SPIHT should also be initialized accordingly.After the initialization, SPIHT coding procedures are executed until a newly generated node N is to be inserted into LIP or LIS. At this point, the significant bit b of N is gotten and fed back it to the input of PRNG by following equations:(2)v=(v≪1)|b(3)s=c⊕vwherevis the status vector, b is the significant bit of N, c is the output of PRNG, and ≪ is the logical left shift operation. s is then used to fed back to PRNG and generate a random position p by the following rule:(4)p=cmodlwhere l is the length of current list to be inserted.After the generation of random position p, the node N is inserted into position p of LIP or LIS by using FRI instead of the end of the list. As it is stated in Section 3.2, N is actually inserted before the node whose address is the pth element in DAA. The algorithm maintains two DAAs for LIP and LIS.The process of SPIHT coding is iterative. In one iteration, all the elements of LIS are scanned in the sorting pass [18]; so steps 2–4 in Algorithm 3.1 will be repeated for several times in one iteration of SPIHT coding. Because the encryption is only performed in the beginning r rounds of SPIHT coding iteration, a iteration counter i is utilized to check whether the exit condition is satisfied.After the explanation of JCSE-SPIHT, it is easy to understand that our proposed algorithm is closely coupled with SPIHT coding process, which is different from most existing schemes only encrypting the input and/or output of SPIHT. As LIP and LIS are scrambled in the beginning of SPIHT coding iterations and they will be further used in the subsequent coding iterations, the superiorities of JCSE-SPIHT are obvious. First, we only need to encrypt a small portion of data and the encryption effect will be diffused quickly to all the subsequent coding procedures, which makes the final output of code stream totally scrambled. Second, the efficiency of JCSE-SPIHT is quite satisfactory since only LIP and LIS in the first r rounds are encrypted; what is more, by utilizing PRI, the efficiency of JCSE-SPIHT is further optimized.

@&#CONCLUSIONS@&#
In this paper, we propose JCSE-SPIHT, an algorithm of joint compression and selective encryption based on set partitioning in hierarchical trees (SPIHT), by embedding encryption into SPIHT coding procedures. Since the soul of SPIHT is spatial orientation trees (SOT), and the scanning order of SOT decides the execution path of the codec and reconstructed image, we propose to scramble the list of insignificant sets (LIS) and the list of insignificant pixels (LIP) in the beginning r rounds of SPIHT coding, where r controls the tradeoff between encryption strength and computational overhead; we further introduce a fast random insertion (FRI) to accelerate the encryption from taking O(n2) time to O(n) without any security compromise. To make the scrambling resistant to chosen-plain attack, we investigate the method of generating plaintext-dependent keystream by cryptographically secure pseudo random number generator (PRNG).Intensive experiments are conducted to exam the security, efficiency, and compression performance of JCSE-SPIHT, as well as its format compliance. By setting r=6, we can achieve a good security by only selectively encrypting 1%−4% data, while the coding efficiency is almost not affected. As for the compression performance, there is only about 4dB reduction on PSNR or 0.03 in MSSIM on average compared with the original SPIHT algorithm. In security analysis, not only do we study the security of JCSE-SPIHT from traditional cryptanalysis, but also exam its resistance to the attacks with the help of image processing techniques. None of them is found to be capable of improving the quality of encrypted image significantly.