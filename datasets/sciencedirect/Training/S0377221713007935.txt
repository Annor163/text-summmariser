@&#MAIN-TITLE@&#
An exact method for scheduling a yard crane

@&#HIGHLIGHTS@&#
We study sequencing container storage and retrieval requests in a container terminal.We minimize the total travel time of a yard crane to handle requests in a block.We model the problem as a continuous time integer model and prove the complexity.We propose a two-phase solution method to quickly and optimally solve the problem.Our method reduces the travel time by 30% and 14% compared to random and NN heuristics.

@&#KEYPHRASES@&#
Container storage and retrieval,Sequencing,Multiple I/O points,Travel time,Traveling salesman problem,

@&#ABSTRACT@&#
This paper studies an operational problem arising at a container terminal, consisting of scheduling a yard crane to carry out a set of container storage and retrieval requests in a single container block. The objective is to minimize the total travel time of the crane to carry out all requests. The block has multiple input and output (I/O) points located at both the seaside and the landside. The crane must move retrieval containers from the block to the I/O points, and must move storage containers from the I/O points to the block. The problem is modeled as a continuous time integer programming model and the complexity is proven. We use intrinsic properties of the problem to propose a two-phase solution method to optimally solve the problem. In the first phase, we develop a merging algorithm which tries to patch subtours of an optimal solution of an assignment problem relaxation of the problem and obtain a complete crane tour without adding extra travel time to the optimal objective value of the relaxed problem. The algorithm requires common I/O points to patch subtours. This is efficient and often results in obtaining an optimal solution of the problem. If an optimal solution has not been obtained, the solution of the first phase is embedded in the second phase where a branch-and-bound algorithm is used to find an optimal solution. The numerical results show that the proposed method can quickly obtain an optimal solution of the problem. Compared to the random and Nearest Neighbor heuristics, the total travel time is on average reduced by more than 30% and 14%, respectively. We also validate the solution method at a terminal.

@&#INTRODUCTION@&#
Containerized transportation has become an essential part of world trade during the past decades (Kim & Kim, 1999; Steenken, Voß, & Stahlbock, 2004). Between 1990 and 2015, the total number of full containers shipped internationally is expected to grow from 28.7 million 20-feet equivalent units (TEU) to 177.6 million TEU (United Nations: ESCAP, 2007). All these containers pass through different container terminals all around the globe. As a result, container terminals daily deal with a large number of containers (Drewry, 2011; Kim & Kim, 1999). The terminals in the Port of Rotterdam, for example, handled approximately 11 million TEU in 2010 (Port of Rotterdam Authority, 2010).Fig. 1a shows a container terminal with several blocks of containers in the stacking area where yard cranes (YCs) stack and retrieve containers. Other terminal layouts are studied by Wiese, Suhl, and Kliewer (2010). Each YC can handle containers in a single block consisting of multiple rows, tiers, and bays as shown in Fig. 1b. The YC can move containers along the bays and rows of the block simultaneously. A number of input/output (I/O) points are located at the seaside and landside of the block. When a container is to be retrieved, the YC picks it up from its location in the block and drops it at an I/O point at the container’s destination side of the block. In case of a storage request, the YC picks up a container from its I/O point and stores it in a location in the block.Handling a large number of containers affects the performance of a container terminal. For the container terminal operator, minimizing the makespan of vessels is the most important performance criterion (see, for example, Böse, 2011; De Koster, Balk, & Van Nus, 2009; Linn & Zhang, 2003), as shipping lines are the terminal’s paying customers. In order to minimize the berthing time of a ship, container terminal operators assign multiple quay cranes (QCs) to load and unload each ship, and do not allow them to fall idle, if possible. Furthermore, over the years, the speed of QCs has improved substantially. However, the performance of QCs also depends on the performance of YCs. The speed of a YC, calculated as the number of handled containers per hour, is approximately one-third of a modern QC (Murty, 2007). As a result, in order to fully utilize QCs, containers to be loaded or unloaded by each QC must be distributed over several blocks. Furthermore, while retrieving and stacking containers of ships, each YC should also serve the landside. At the landside, trains and trucks supply the stack with containers and also demand services from the YCs. Therefore, at every moment, each YC has to deal with a set of containers of the same relative priority waiting to be stacked or retrieved. If the makespan of YCs is not minimized, not only the berthing times of ships but also the waiting times of trucks and trains increase. Cost-based objective functions do not satisfy this purpose, as all costs for delays of individual containers are artificial. In addition, individual containers have quite a bit of flexibility in due time. In practice, a block sequencing policy is implemented in which containers are grouped and requests are performed block by block (see the case study in Section 4.2). Within each block, containers of about the same priority can be carried out in any order with the objective of minimizing YC makespan.We therefore consider the problem of sequencing a given set of requests to be stacked or retrieved by a YC in a single block. The objective is to minimize the travel time of the YC to carry out the requests. We formulate this problem with multiple I/O points as a special case of an asymmetric traveling salesman problem (ATSP), in which the YC must visit an I/O point to carry out every request. We prove that the problem complexity stems from the number of requests and the number of I/O points. We propose a two-phase solution method which can quickly solve the problem. In the first phase of the solution method, we develop a new merging algorithm to patch subtours of an optimal solution of the assignment problem (AP) relaxation of the problem without adding extra travel time. In this phase, we first search for two arcs from every two different subtours visiting a common I/O point, and swap the destinations of them to merge the subtours. Next, based on the fact that in some arcs, the YC has multiple I/O point options with the same travel time to visit, we can create further opportunities to merge more subtours. We show that the first phase runs in polynomial time, and often finds an optimal solution. Otherwise, a branch-and-bound (B&B) algorithm is used in the second phase to find an optimal solution of the problem. In this phase, the merging algorithm is again used in each node of the B&B tree to save computation time.The numerical experiments show that the two-phase solution method is quite efficient. For instances up to 200 requests, an optimal solution can be obtained in less than a second. Furthermore, we show that the travel time reduction between the optimal and random sequence is around 30%, on average. The reduction is around 14%, in case the Nearest Neighbor (NN) heuristic is used to find the sequence. Reducing the total travel time of the YC helps not only to improve the performance of the terminal but also to decrease the negative environmental impacts of container handling operations. Container terminal nowadays hugely invest in developing new technologies to reduce fuel consumption and YC emissions. The average fuel consumption of traditional manual YCs ranges between 20 and 30liters of diesel per hour. In peak hours, the amount can exceed 100liters per hour. The result is more than 350 tons of CO2 emissions per year (Zrnić & Vujičić, 2012). Reducing the travel time by 30% or 14% can result in substantially less fuel consumption, and consequently less emissions. Finally, the results show that the two-phase solution method can obtain significantly better results than CPLEX truncated after five hours.The scheduling of stacking cranes at a container terminal has been studied for some time already. An important body of research concerns QCs that must be synchronized with berthing operations (see Bierwirth and Meisel (2010) for a comprehensive literature review). On the other hand, yard crane scheduling has not been well studied compared to QC scheduling (see the recent literature reviews, for example, Gharehgozli, Laporte, Yu, & De Koster, 2013; Stahlbock & Voß, 2008). In general, scheduling a yard crane to carry out storage and retrieval requests can be modeled as an ATSP or one of its special cases such as the rural postman problem, or Chinese postman problem, depending on the properties of the problem (Vis & Roodbergen, 2009). In the following, we present a brief review on the ATSP, and then we review related applications in sequencing storage and retrieval requests.Simply stated, the ATSP is a combinatorial problem in which from a given list of locations with given pairwise travel times, a tour must be determined passing every location exactly once in such a way that the total travel time is minimized (Lawler, Lenstra, Rinnooy Kan, & Shmoys, 1985). In general, the ATSP is proven to beNP-hard (see, for example, Karp, 1972). Several exact and heuristic algorithms have been proposed to solve the ATSP. Among all exact algorithms, a large body of research focuses on the B&B algorithm based on the subtour elimination approach proposed by Carpaneto and Toth (1980) and later improved by Carpaneto, Dell’Amico, and Toth (1995) and Miller and Pekny (1991). This is closely related to the second phase of our solution method. The core idea of the B&B algorithm is the AP relaxation. In each node of the B&B tree, an AP with some extra constraints is solved. Constraints exclude a number of arcs and require some others to appear in the AP solution so that some subtours can be avoided. Carpaneto et al. (1995) and Miller and Pekny (1991) also propose two merging algorithms to improve the computation time. In these algorithms, the reduced costs of the arcs are used to merge subtours, and they are thus time consuming. Therefore, Carpaneto et al. (1995) for example use the merging algorithm in every node if the number of zero-reduced cost arcs is more than a threshold. In addition, the objective value may increase after merging subtours. These issues make their algorithms different than the one developed in this paper, in a sense that our algorithm uses swappable arcs with one or multiple common visiting I/O points to quickly patch subtours without extra travel time.In the literature available on sequencing container storage and retrieval requests, many authors deal with problems where either storage or retrieval requests are considered (see, for example, Kim & Kim, 1999; Narasimhan & Palekar, 2002; Ng, 2005), or where multiple YCs carry out the requests (see, for example, Cheung, Li, & Lin, 2002; Dorndorf & Schneider, 2010; Li, Wu, Petering, Goh, & de Souza, 2009; Vis & Carlo, 2010; Zhang, Wan, Liu, & Linn, 2002). In most of these papers discrete time models are used to formulate the problem and the solution approaches do not apply here. The first problem type is more limited than our problem and the second is more general and heuristic algorithms are usually proposed to solve it. Apart from this literature, reviewing the papers on scheduling a single crane to carry out storage and retrieval requests of containers at a container terminal (Vis & Roodbergen, 2009) or of unit loads in a warehouse (De Koster & Van der Poort, 1998; Ratliff & Rosenthal, 1983; Van den Berg & Gademann, 1999) reveals that specific properties of each individual problem determine whether a polynomial solution method can be developed. These properties are: (1) the number of I/O points and (2) the number of rows in which containers are stored or retrieved. The literature can therefore be categorized based on these properties as follows.In case of a single I/O point, polynomial solution methods can be developed (see Burkard, Deineko, Van Dal, Van der Veen, & Woeginger (1998) for solvable TSP cases). In this case, all subtours of an optimal solution of an AP relaxation to the ATSP can be merged as a complete Hamiltonian tour, since the crane returns to the same I/O point for every request. Having returned to the I/O point, the crane can select any storage request. It can also select a retrieval request in case in the optimal AP solution that retrieval request is sequenced after another retrieval request. Therefore, all subtours can be merged without adding extra travel time.Van den Berg and Gademann (1999) discuss a problem with both an output point where retrievals are dropped off and an input point where storages are picked up. They assume that storage requests are executed in a first-come-first-served order. The problem is to find which retrieval requests must be interleaved after each storage. This allows a formulation as a transportation problem using a bipartite graph. They prove that each feasible solution of the transportation problem corresponds to a retrieval and storage sequence of the main problem. Their problem is similar to the situation with a single I/O point, since the I/O is fixed for each request.Vis and Roodbergen (2009) consider a problem with a single block where the block corresponds to multiple rows separated by aisles. Each row has one I/O point at each end which serves that row. A single straddle carrier stores or retrieves all containers in the rows, where each container passes an appropriate I/O point of its row. The straddle carrier must exit the current row at the end in order to travel from one row to the other one, which is time-consuming. Therefore, it usually finishes all requests in that row before traveling to another. Based on this specific characteristic of straddle carriers, they can decompose the problem with multiple rows into several problems with one row and two I/O points and solve them separately. They propose a solution method based on dynamic programming to determine the shortest path for the straddle carrier crossing multiple rows. The dynamic programming allows multiple visits of a single row. It uses an optimal storage and retrieval request sequence in each row. Using an optimal AP solution to sequence the requests in a row with two I/O points results in maximum two subtours. They prove that in order to obtain the optimal solution, these subtours can be merged by enumerating and exchanging arcs in O(N) time because the travel time matrix has the properties of a Monge matrix in the case of a single row and two I/O points (see Gilmore & Gomory, 1964). Vis and Carlo (2010) also use the same method to find a lower bound for their container sequencing problem with a single block and two YCs. To obtain the lower bound, they collapse all rows of the block together as a single row and assume that a single YC carries out all requests. Considering two YCs to carry out the requests makes the problem complex so that they resort to a metaheuristic to solve the problem.Vis and Roodbergen (2009) extend the models proposed by Ratliff and Rosenthal (1983) and De Koster and Van der Poort (1998) for routing an orderpicker in a warehouse. Ratliff and Rosenthal (1983) consider a warehouse with parallel aisles (comparable to a container terminal with parallel rows), a central I/O point and no storage request, whereas De Koster and Van der Poort (1998) consider the same situation but the warehouse can have an I/O point at the end of each aisle. Dynamic programming is used in both studies to decompose and solve the problems.Different from the previous line of research, in this paper, a continuous time integer programming model is proposed to stack and retrieve containers in a block with multiple I/O points and rows densely located together. Since the YC can simultaneously move across the rows and does not return to the row ends to switch rows, the problem is more complex. Compared to the current YC position, many locations in neighbor rows have identical travel times. In order to obtain the optimal solution, all rows and I/O points must be considered at the same time in the solution method. Decomposing the block into multiple single-row blocks for adopting the methods proposed by Vis and Roodbergen (2009), De Koster and Van der Poort (1998), and Ratliff and Rosenthal (1983) is not possible, since returning to an I/O point located at either end of each row is essential in the proposed network models and solution methods. Extra arcs are necessary in the network to model switching rows without returning to the I/O points. Even if the block is divided into multiple single-row blocks, the optimal solution of each row cannot be obtained using the enumerative method. The reason is that containers are not dropped off or picked up at dedicated I/O points at the end of the row. Some requests are connected to other I/O points, which means that by solving an AP, the number of subtours is not necessarily two but can be more.The rest of this paper is organized as follows. In Section 2, we describe the technical aspects of the problem and present the mathematical model. In Section 3, the solution method is developed. Section 4 presents computational experiments and Section 5 contains the conclusions.This section describes the research problem, introduces notations, and then formulates the problem.We study how to sequence N container storage and retrieval requests in a single block of containers consisting of X rows, Y bays, Z tiers, and M I/O points. Let I/Om, m=1,…,S, be the location of the mth I/O point at the seaside whereas I/Om, m=S+1,…,M, be the location of the mth I/O point at the landside. A single YC stacks n containers from the I/O points to given locations in the block and retrieves N−n containers from the block to the I/O points. A storage container is a container that must be stacked in the block and a retrieval container is a container that must be retrieved from the block. The objective is to minimize the total travel time of the YC. From a given starting location, the YC can carry out the requests in any sequence in order to minimize total travel time. We denote by 0′ and 0″, respectively, the starting and ending locations of the YC. These locations can be anywhere in the block. The starting location is given, but the ending location depends on whether the request carried out last by the YC is a storage or a retrieval (see Table 1). The YC can only carry a single container at a time and containers cannot be dropped off at temporary locations.We denote byV={1,…,N,0′,0″}the set of all storage and retrieval locations including the YC starting and ending locations. Note that every request corresponds to a unique location in the block and a unique container. Thus, for ease of notation, we use their notations interchangeably as follows. Container i of storage request i is currently located at an I/O point and is waiting to be stored in location i in the block, i=1,…,n. Container j of retrieval request j is already stacked in location j in the block, j=n+1,…,N, and is waiting to be delivered to an I/O point either at the seaside or landside, depending on whether they should be transported by truck/train, or by ship, respectively. Due to the abundance of internal transport vehicles (like automated guided vehicles (AGVs) and chassis) to pick up containers at the seaside and landside, retrieved containers can be delivered to any I/O point at the landside or the seaside.Locations as well as destination sides of retrieval containers and I/O points of storage containers are known; in practice, they are determined at a higher hierarchical planning level. This level focuses on providing quick accessibility of containers for future handling (De Castillo & Daganzo, 1993; Kim, Park, & Ryu, 2000; Wan, Liu, & Tsai, 2009) and speeding up the loading and unloading process of a ship (Kim & Kim, 1999; Vis & Roodbergen, 2009). In addition, storage and retrieval locations do not coincide. These assumptions are in line with the literature (Li et al., 2009, 2012; Vis & Roodbergen, 2009; Vis & Carlo, 2010), and are also reasonable from a practical point of view. In practice, N is much smaller than the block size, and the block utilization is often fairly low. Considering these situations, while making the storage assignment decision, terminal operators separate retrieval and storage piles and avoid stacking a container on the top of another one that has to be retrieved in the same time period, as rehandling is time consuming. Storage containers are piled up based on type (i.e., weight, destination port, or size), strongly limiting the number of options. Finally, we assume that containers do not have explicit precedence constraints. In the introduction, it is already explained that container terminals usually use a block sequencing approach to carry out requests. Blocks are carried out one by one, but containers within each block are not prioritized and can be carried out in any order (see the case study in Section 4.2). Once there are more than two requests, we have a potential to shorten the travel time by optimization. If new requests arrive over time, they can be added to the list. Since our algorithm is fast, the algorithm can be called repeatedly to provide the optimal solution instantaneously.Fig. 2shows a top view of a small block (X=7, Y=10, and Z=4) of containers with three storages and four retrievals. Locations of storages, retrievals and I/O points are highlighted with different colors. The origin of the Cartesian coordinate system is indicated at the bottom left corner (the tiers are counted from the top). The first storage container must be picked up at I/O1, the second at I/O1, and the third at I/O7. On the other hand, retrieval container 4 must be moved to one of the I/O points at the seaside and containers 5, 6, and 7 must be moved to one of the I/O points at the landside.In order to mathematically formulate the problem and calculate the total travel time of the YC, the pairwise travel times between the storage and retrieval locations in the block must be calculated. If the YC travels directly from location i, (xi, yi, zi), to location j, (xj, yj, zj), the travel time of the YC can be calculated as follows:(1)tij=max{|xi-xj|,|yi-yj|}+|zi|+|zj|,where (xi, yi, zi) and (xj, yj, zj) are the Cartesian coordinations of locations i and j, with 0⩽xi, xj⩽Tx, 0⩽yi, yj⩽Ty, and 0⩽zi, zj⩽Tz. Here, Tx, Ty, and Tz, are the furthest travel times of locations in the block in X, Y, and Z directions, respectively. The first term at the right-hand side of Eq. (1) emphasizes that the YC can move in the X and Y directions simultaneously. The vertical dimension travel time includes extra necessary processing times such as the time required to lock the spreader to the container or the time required to change the yard chassis or AGVs.In order to calculate the travel times between storage and retrieval locations, we additionally must consider that the YC needs to travel through I/O points to pick up or deliver containers. For example, to move from storage location i to storage location j, the YC needs to travel first to the I/O point where container j is located and then move container j to location j. Table 1 summarizes how to calculate the travel times between different locations. It divides all feasible moves into three categories depending on whether the YC starts from a storage location, a retrieval location, or the starting location. All other moves (i.e., to move from a location to the starting location) are not feasible. Therefore, the travel times are forced to be infinite, as shown in the last row of the table, so that they do not appear in the solution. Furthermore, without loss of generality, we assume that the YC stops at location i, if storage request i is the last one. We also assume that the YC delivers the container j to an I/O point and stops there, if retrieval request j is the last request. Finally, in our problem, the travel time of the YC satisfies the triangle inequality, although this is not necessary in the ATSP.The mathematical formulation of the problem as an ATSP requires a unique travel time between every two locations. However, in an arc in which the YC travels from a retrieval location to another location, the YC is allowed to deliver the retrieval container to any of the multiple I/O point options. Each possible I/O point results in a different travel time. The YC selects the I/O point which gives the minimum travel time between the retrieval location and the immediate next storage or retrieval location, and we define it as minimum pairwise travel time for each pair of locations. Note that multiple I/O points can result in the minimum travel time, and each can be selected to retrieve the container. Later in the solution method section, we explain how we should select an I/O point from multiple options.The problem of sequencing storage and retrieval requests is mathematically stated as the following integer programming model. Let xijbe the binary decision variable which equals 1 if and only if location j is visited immediately after locationi,i,j∈V,i≠j.The objective function is to minimize the total travel time of the YC:(2)minimizeZ=∑i∈V⧹{j,0″}∑j∈V⧹{0′}tijxij.The model has the following constraints.Visiting all locations and carrying out all requests: Each location must be entered and exited exactly once. Of course, the starting location has no ingoing arc and the ending location has no outgoing arc:(3)∑i∈V⧹{j,0″}xij=1,∀j∈V⧹{0′},(4)∑j∈V⧹{i,0′}xij=1,∀i∈V⧹{0″}.Subtour elimination constraints: The YC must avoid traveling subtours. Therefore, for any subset of locationsO⊆V⧹{0′,0″},O≠∅where|O|is the size ofO, we have the following constraints:(5)∑i,j∈Oxij⩽|O|-1.All the variables are binary:(6)xij∈{0,1},∀i,j∈V.The problem is defined as an ATSP (since the YC may not travel in both directions or the distances might be different), consisting of assignment constraints plus subtour elimination constraints. Therefore, every feasible solution of the YC scheduling problem corresponds to a feasible AP solution since by relaxing the subtour elimination constraints the remaining problem is an AP. This implies that the AP provides a lower bound for the problem (see also Bellmore & Nemhauser, 1968). Theorem 1 shows the complexity of a special case of the problem considered in this paper.Theorem 1The YC scheduling problem with a prescribed I/O point for each retrieval request isNP-hard.The proof can be found in Appendix A. In Section 3, we develop a solution method to quickly solve the problem to optimality.A relaxation of the problem is an AP that can be efficiently solved in O(N3) steps where N is the number of requests (Kuhn, 1955). An optimal AP solution often contains subtours since the subtour elimination constraints (Eq. (5)) may not be satisfied. In order to merge subtours to obtain an optimal solution of our problem, we first develop some unique properties of the problem. Using these properties, an algorithm is developed in Section 3.1 to merge subtours without adding extra travel time. If all subtours have been merged into a single tour, an optimal solution is found. Otherwise, some subtours have not been merged, and a B&B algorithm is developed in Section 3.2 to merge all remaining subtours to obtain an optimal solution of our problem.In Section 3.1.1, we first explain how to patch subtours of an optimal AP solution. We merge all subtours in multiple steps by selecting two of them in each step and swapping arcs between them. We show that no extra travel time is added to the solution if the YC visits an I/O point twice while traveling from the origins to the destinations of the two arcs. Then, in Section 3.1.2, we introduce arcs in which the YC can visit multiple I/O point options while traveling from the origins to the destinations of the arcs. These arcs create opportunities to merge more subtours. Finally, in Section 3.1.3, we present the merging algorithm. We show that the objective value does not change after this merging.In this section, we find some properties of the problem to merge subtours of the AP solution without adding extra travel time.Definition 1The visiting I/O point of an arc is the I/O point that the YC needs to travel through either to pick up or to deliver a container in order to travel the arc connecting two requests.In order to visualize the visiting I/O point of an arc, we need to distinguish carrying and non-carrying moves. In case of a retrieval request, the YC starts with a non-carrying move from a storage location (or an I/O point) to the retrieval location, and then continues with a carrying move from the retrieval location to an I/O point. In case of a storage request, the YC starts with a carrying move from an I/O point to the storage location, and then continues with a non-carrying move from the storage location to an I/O point or retrieval location. Note that the travel time from or to such I/O points is explicitly included in Table 1.Fig. 3b shows carrying and non-carrying moves of the arcs of an optimal AP solution presented in Fig. 3a. For clarity, in Fig. 3b, only the first and second subtours are considered. For example, storage request 1 is connected to I/O1 by a carrying move and to retrieval request 4 by a non-carrying move. Furthermore, retrieval request 4 is connected to I/O1 by a carrying move and to storage request 1 by a non-carrying move. As a result, I/O1 is the visiting I/O point of arc (4,1).If (i, j) and (k, l) are two arcs of two subtours (xij=xkl=1), the two subtours can be merged by setting xij=xkl=0 and xil=xkj=1. Theorem 2 states that if arcs are swappable, as defined in the following, the total travel time remains the same. Otherwise, it may increase.Swappable arcs are two arcs in two different subtours that have a common visiting I/O point.If two subtours contain a pair of swappable arcs, they can be merged without adding extra travel time.The proof can be found in Appendix B.In the optimal AP solution presented in Fig. 3a, (4, 1) and (0′, 2) define a pair of swappable arcs because both arcs visit I/O1 (follow the carrying moves in Fig. 3b). Therefore, based on Theorem 2, replacing them with (4, 2) and (0′, 1) results in merging subtours 1 and 2 without adding extra travel time. Merged subtour 1+2 is shown in Fig. 3c:0′→x0′1=11→x14=14→x42=12→x25=15→x50″=10″.In the previous section, we used the following type of swappable arcs in Theorem 2 to patch subtours of an optimal AP solution.Definition 3An arc with a single irreplaceable visiting I/O point is an arc in which the YC has a unique visiting I/O point option with the minimum travel time to visit and travel from the origin to the destination of the arc.The assumption that all arcs have a single irreplaceable visiting I/O point results in missing some merging opportunities. As the last column of Table 1 shows, in some arcs, the YC may be able to visit one of multiple I/O points with the same travel time. Arcs without any I/O point such as moving from a storage location to a retrieval location are not a matter of attention here because swappable arcs need to have a common visiting I/O points. Therefore, we can introduce the following type of arcs.An arc with replaceable visiting I/O points is an arc in which the YC has multiple visiting I/O point options with the minimum travel time to visit and travel from the origin to the destination of the arc.Based on the last column of Table 1, an arc with replaceable visiting I/O points can be realized if the request corresponding to the location at the origin of an arc is a retrieval request. The retrieved container must be delivered to an I/O point which results in the minimum travel time for the YC in order to travel from the origin to the destination of the arc. In some cases, multiple I/O points may give the same minimum travel time one of which can be chosen. Arcs with replaceable visiting I/O points create extra opportunities to merge subtours.During the merging algorithm, we check each arc to find out the number of visiting I/O points. It is clear from Table 1 that arc (i, j) has a single irreplaceable visiting I/O point in these two cases (the other arcs may have replaceable or irreplaceable I/O points): (1) requests i and j are both storage requests or (2) request i is a retrieval request, request j is a storage request. In these arcs, the single irreplaceable visiting I/O point is the I/O point where storage container j is located. As an example, arc (4, 1) in Fig. 3a shows an arc with a single irreplaceable visiting I/O point, as I/O1 is the only I/O point that can be visited (see Fig. 3b). In Fig. 4a where subtours 1+2 and 3 are shown, arc (5, 0″) is an arc with four replaceable visiting I/O points, I/Om, m=5, 6, 7, 8, that give the same minimum travel time,t50″. Arc (6, 7) is also an arc with replaceable visiting I/O points, I/Om, m=6, 7. In Fig. 4b, carrying and non-carrying moves of arcs (5, 0″) and (6, 7) are shown in black and gray, respectively.Based on Theorem 2, if two subtours contain a pair of swappable arcs of which at least one has an irreplaceable visiting I/O point, the subtours can be merged without extra travel time by using that single common visiting I/O point. In a more general case, if two subtours contain a pair of swappable arcs, both with replaceable visiting I/O points, the subtours can be merged without extra travel time using any of the common visiting I/O points. An example is presented in Fig. 4. Swappable arcs of subtours 1+2 and 3 are (6, 7) and (5, 0″), as shown in Fig. 4a. The replaceable visiting I/O points of these arcs are shown in Fig. 4b. Common visiting I/O points, I/Om, m=6, 7, can be used to merge subtours 1+2 and 3. A complete tour is shown in Fig. 4c. In this solution, I/O6 is for example selected to deliver the retrieved container 6.Having considered different properties of the problem, the merging algorithm can be presented. In the algorithm, merging subtours will be carried out by using the following arcs consecutively: (1) swappable arcs with a single irreplaceable visiting I/O point, (2) swappable arcs with replaceable visiting I/O points, and (3) swappable arcs of which one has a single irreplaceable visiting I/O point and the other has replaceable visiting I/O points. The reason behind this sequence is as follows:In case both swappable arcs have a single irreplaceable visiting I/O point, merging two subtours results in a merged subtour in which the same common visiting I/O point will be visited by the new arcs replacing the swappable arcs. This is the ideal case because the subtours are merged without omitting any I/O point. In the other two cases, only common visiting I/O points remain. Other visiting I/O points are omitted and we lose the opportunity to use them for further merging, if necessary. In the second case, arcs replacing the swappable arcs can visit all common visiting I/O points, whereas in the third case, they can visit only a single irreplaceable common visiting I/O point. In other words, in the second case, all common visiting I/O points can be used to patch the merged subtour to other subtours, whereas in the third case, only a single common visiting I/O point can be used for further merging. Therefore, the second case has priority in subtour merging over the third case.In Algorithm 1,UmandUm′are the sets of all arcs in an optimal AP solution with irreplaceable and replaceable visiting I/O points respectively, which visit I/Om, m=1,…,M.Algorithm 1Merging algorithmRequire: An optimal AP solution;Ensure: An optimal solution of the problem with the same optimal AP objective value and a complete Hamiltonian tour, or an optimal AP solution with the same optimal AP objective value and a few subtours;1: procedure MERGE2: classify and assign arcs of the AP optimal solution to the sets of arcs with irreplaceable and replaceable visiting I/O points,UmandUm′,m=1,…,Musing Definitions 3 and 4;3:form=1,…,Mdo4:if|Um|>1then5:subtours can be merged two by two using the common I/O point, I/Om;6:updateUmandUm′, m=1,…,M;7:end If8:end for9: repeat steps 3–8 forUm′. If|Um′|>1, m=1,…,M;10: repeat step 3–8 forUm∪Um′. IfUm∪Um′>1,m=1,…,M;11:if the number of subtours is 1 then12: an optimal solution of the problem is obtained; output the solution;13:else14: an optimal solution is not found because it does not satisfy Eq. (5). The B&B algorithm presented in Section 3.2 will be called to find an optimal solution;15:end if16: end procedureThe merging algorithm runs in polynomial time. The complexity of the algorithm comes from identifying each type of arc. In each step, it needs to go through all the arcs and decide whether they have replaceable or irreplaceable I/O points.Theorem 3If the output of the merging algorithm is a complete tour, an optimal solution of the problem is obtained.The proof is straightforward as we solve an AP and patch subtours without adding any extra travel time (see Theorem 2). Since every feasible solution of the YC scheduling problem corresponds to a feasible AP solution, the AP provides a lower bound for the problem. Therefore, if the merging algorithm patches all subtours of an optimal AP solution as a complete tour, then the optimal solution of our problem is obtained.The merging algorithm does not change any of the inputs of the problem and it does not add or remove any constraints (see Sections 3.1.1–3.1.3). In fact, it is a method to change an optimal AP solution to another optimal AP solution (possibly satisfying the subtour elimination constraints) by exchanging some of the arcs.If, upon completion of the merging algorithm, the solution still contains at least two subtours, a further step is needed. This section introduces a modified ATSP B&B algorithm to merge all subtours as a complete Hamiltonian tour with the minimum total travel time.The classic ATSP B&B algorithm is based on the AP relaxation and subtour elimination. It has been shown that an optimal ATSP solution can be obtained by starting from an optimal AP solution with multiple subtours in Node 0 of the B&B tree, exhaustively branching on all the arcs in a chosen subtour, solving a new AP in each of the resulting nodes, and repeating the same procedure until all nodes are fathomed (see the overview by Laporte (1992), the first implementation of the algorithm by Eastman (1958), or the recent ones by Carpaneto and Toth (1980) and Carpaneto et al. (1995)).To solve our YC scheduling problem, formulated as an ATSP, we start from an optimal AP solution (the solution of the first phase of the algorithm), and extend the B&B algorithm by using our merging algorithm to patch subtours of the optimal AP solution in each node. The AP usually has multiple optimal solutions. Carpaneto et al. (1995) explain that any of them may be used to bound the node. They further mention that the optimal solution with the minimum number of subtours generally leads to the minimum computation effort later on in the B&B tree. Therefore, they propose a heuristic algorithm to merge subtours in each node and find another optimal AP solution with the minimum or possibly no subtours (see the discussion in the introduction). Our merging algorithm is a new method to patch subtours of an optimal AP solution to obtain another optimal AP solution with the same optimal value but fewer or no subtours. Note that in the first phase of our algorithm we also solve an AP and try to merge all subtours. Therefore, the solution (with multiple subtours) can serve as the input in node 0. In fact, we separate the first phase because it provides an optimal solution in almost all instances (see the computational experiments). In the following, it is explained in detail how the B&B algorithm proceeds until the optimal solution is obtained.Step 1. InitializationThe output of the merging algorithm is an optimal AP solution with|W|subtours, whereWis the set of subtours. The output serves as the input of the B&B algorithm in node 0. In addition, determine the best solution found so far X∗, with the objective value Z∗ (which serves as an upper bound for the B&B algorithm) by using a heuristic algorithm such as the random or NN algorithm.Step 2. First branchingThe B&B algorithm continues by selecting a subtourw∈Wcontaining the minimum number of arcs to branch node 0 (Carpaneto & Toth, 1980). The branches divide the solution space into complementary solution subspaces such that w can be removed. This is carried out by sequentially excluding a next arc of the (now broken) subtour w and including (keeping) the preceding arcs. The excluding arcs must disappear in the next solution and including arcs must appear. Arcs can be excluded and included by assigning 0 and 1 to their corresponding variables, respectively. Assume subtour w can in general be represented as[1]→x[1][2]=1[2]→⋯→[K]→x[K][1]=1[1], where [i] is the ith location, i=1,…,K, that will be visited by the YC in this subtour. Subtour w results in K child nodes. As shown in Eqs. (8) and (7), in each node a setEjof arcs is excluded and a setIjof arcs is included in the solution for some j, where j=1,…,K. More specifically, in child node j, we exclude arc ([j],[j+1]). In other words,Ej={([j],[j+1])}, and we have to set x[j][j+1] to zero. Furthermore, all the arcs before this arc in subtour w have to appear in the solution of child node j. This means thatIj={([1],[2]),…,([j-2],[j-1])}, and associated variables, x[1][2],…,x[j−2][j−1], have to be set to one.(7)Ej={([j],[j+1])},j=1,…,K,(8)Ij={([1],[2]),…,([j-2],[j-1])},j=2,…,K,whereI1=∅, and [K+1]=1 in Eq. (7).Later, in the proof of Theorem 4, we show that such a branching strategy results in an optimal solution. The subspaces are collectively exhaustive with respect to feasible ATSP tours. The branching rule divides the solution space into complimentary subspaces such that in none of them the same subtour (selected from the parent node) appears since one arc of that subtour is excluded in each child node.Step 3. Fathoming and boundingAt each child node, l=1,…,K, we solve a modified AP, introduced by considering constraints forced by Eqs. (7) and (8) as well as other general constraints of the AP (Eqs. (2)–(4) and (6)).AssumeZAPl, and Xl, l=1,…,K, are the optimal AP objective value and an optimal AP solution at node l. IfZAPl⩾Z∗, fathom the node. IfZAPl<Z∗and the optimal solution to the modified AP at node l is a complete Hamiltonian tour, updateZ∗=ZAPl, X∗=Xland fathom the node. Otherwise, ifZAPl<Z∗and the optimal solution is not a complete tour, add l to the set of live nodes,L(L=∅at node 0). The set of live nodes is the set of nodes that are not fathomed yet and must be considered.Step 4. Further branchingChoose one of the live nodes fromLto be evaluated next. In our implementation, this is carried out by using the depth-first-search (DFS) as the overall strategy and the best-first-search (BeFS) when a choice is to be made between nodes at the same level of the tree (see Clausen, 2003). In case several nodes can be chosen, choose one randomly. Furthermore, ifLis empty, X∗ is an optimal solution and Z∗ is the optimal value.Assume nodelˆ∈Lis selected. IfZAPlˆ⩾Z∗, omit this node from the set and choose another one; otherwise, find out which subtour must be split. We follow Carpaneto and Toth (1980), who propose to select the subtour with the minimum number of non-included arcs to be split. A non-included arc of a subtour is an arc that is not forced byIlˆto appear in the optimal AP solution of nodelˆ. The subtour with the minimum number of non-included arcs generates the minimum number of child nodes from nodelˆ. Assumelˆ, has Q subtours whereGqis the set of arcs in the qth subtour. As a result, subtourq¯will be chosen to be split ifM=|Gq¯|-|Gq¯∩Ilˆ|=minq=1,…,Q{|Gq|-|Gq∩Ilˆ|}, where|Gq∩Ilˆ|is the number of arcs showing up both in the qth subtour and in the set of included arcs of nodelˆ.In order to break subtourq¯, we use the same branching rule explained in Eq. (8) and (7). However, instead of considering all arcs in subtourq¯, we only consider the non-included arcs because we cannot include or exclude a previously-included arc. Consider that subtourq¯can be represented as[1]→x[1][2]=1[2]→⋯→[K]→x[K][1]=1[1]of which the set of non-included in total contains C arcs, {([1o],[1d]),…,([Co],[Cd])}, where [io] and [id] are the origin and destination of the ith non-included arc, i=1,…,C, respectively. The sequence of arcs in the set of non-included arcs can be determined randomly. Nodelˆresults in C child nodes, each with the corresponding sets of excluded and included arcs as follows:(9)EB+j=Elˆ∪{([jo],[jd])},j=1,…,C,(10)IB+j=Ilˆ∪{([1o],[1d]),…,([j-1,o],[j-1,d])},j=2,…,C,whereIB+1=Ilˆ∪∅and B is the total number of nodes in the B&B tree before generating the new child nodes.The same fathoming and bounding strategy discussed in step 3 for the child nodes of node 0 applies here. In each child node, an optimal solution of the modified AP and the best solution found so far determine whether (1) the child node must be fathomed because the optimal AP solution is worse than the best solution found, or (2) the child node must be fathomed because a better solution is found, or (3) the child node must be added toL. Next, based on the branching strategy, another node will be chosen and the algorithm will repeat until the set of live nodes is empty,L=∅.Fig. 5shows the steps of the B&B algorithm. Note that using the merging algorithm, we can merge all subtours of the AP relaxation of the problem presented in Fig. 2 as a single tour in Fig. 4c. However, assume that the problem has two more requests: retrieval request 9 and storage request 8. These requests cause an extra subtour which cannot be merged with the other ones because its associated arc do not have any common visiting I/O point with the arcs of other subtours. Therefore, the outcome of the merging algorithm would be the solution presented at node 0. The B&B algorithm chooses subtour 4 for branching because it has only two arcs whereas the other one has eight arcs.As it is shown in Fig. 5, solving the modified APs at child nodes 1 and 2 results in solutions each consisting of 2 subtours, namely subtours 6 and 7 for l=1, and subtours 8 and 9 for l=2. However,ZAP2=281.46⩾280.02=Z∗=ZNN, so node 2 must be fathomed. Note that X∗ and Z∗ are obtained by the NN heuristic. On the other hand,ZAP1=277.96<280.02=Z∗=ZNN. Therefore, node 1 will be added to the set of live nodes and the B&B algorithm continues as shown in Fig. 6a. The B&B algorithm must evaluate four more nodes (seven nodes in total), nodes 3, 4, 5, and 6 which are the child nodes of node 1, to find an optimal solution.In Step 4, after selecting the next live node, ifZAPlˆ<Z∗,lˆ∈L, the B&B algorithm chooses a subtour to be split and generates the branches. However, in this section, before choosing a subtour and branching, we introduce an extra step (denoted by Step 4∗) which tries to patch the subtours by using the merging algorithm. The smaller the number of subtours is, the fewer nodes will be produced afterwards in the B&B tree. Furthermore, we may also obtain a complete tour which fathoms the node and makes further branching unnecessary. As a result, the number of nodes of the B&B tree decreases significantly.Step 4∗. Merging algorithm. Merge subtours of the optimal AP solution in the selected live node using the merging algorithm. If the output of the merging algorithm is a complete Hamiltonian tour updateZ∗=ZAPlˆ,X∗=Xlˆ, fathom the node and select another live node. Otherwise, choose a subtour and branch the node.Fig. 6 is used to explain Step 4∗ of the algorithm. Fig. 6a shows that the basic B&B algorithm find an optimal solution in seven nodes. On the other hand, Fig. 6b shows that no extra branching is necessary if the modified B&B algorithm is used (3 nodes in total). As a result, computation time is reduced. This is due to the fact that, in Step 4∗, using the merging algorithm, all subtours of node 1 are merged and therefore, it must be fathomed. Furthermore, in this specific case, X1 is also an optimal solution with the optimal value Z∗=277.96.Theorem 4The two phase algorithm provides an optimal solution to the problem.The proof can be found in Appendix C.Multiple numerical experiments have been performed to investigate the effectiveness of the two-phase solution method consisting of the merging algorithm and the modified B&B algorithm, including validation at a real terminal. In the basic scenario, we consider a single block of containers with 30 bays, 10 rows, four tiers, and 10 I/O points. Furthermore, 100 requests are considered of which the percentage of retrieval requests,P, is 50%. At large container terminals, the inbound and outbound flows of a container block are usually reasonably balanced. Other input data can be found in Table 2. The two-phase solution method is used to optimally sequence all the requests.In this section, we evaluate the performance of the two-phase solution method. In Table 3, the results of the two-phase solution method are presented. In Table 4, our solution method is compared with the random and NN heuristics. In each scenario of the simulation study, 100 realizations of N requests with their storage and retrieval locations and corresponding I/O points are randomly generated by Monte Carlo simulation. The number of realizations satisfiesNrealz.⩾σ2(1+ε)Z1-α/2εμ2with a 90% confidence level (α=10%), where σ2 and μ are respectively the variance and mean of the objective values,Z1-α/2is the 1−α/2 percentile of the normal distribution, and ε=5% is the relative error (Law & Kelton, 1999). The study is performed on a Notebook with 2.40gigahertz Intel® Core™ i5 processor, with 4.00gigabytes of RAM and the programming language is MATLAB® 2010a.Based on the results presented in Tables 3 and 4, the following insights can be obtained:•The results in Table 3 show that the two-phase solution method can find the optimal solution of the problem in less than a second in all scenarios. The reason is that in majority of scenarios, the problem is completely solved in the first phase using the efficient merging algorithm, and the B&B algorithm is seldom recalled. This can be seen in the column presenting ρ, which is the ratio of the problems solved in the first phase of the solution method. When ρ=1, the problem is completely solved in phase 1 and we do not need to enter phase 2. The same conclusion can be obtained from the columns showing the average, maximum and minimum number of nodes needed in each scenario. In most of the scenarios, the average number of nodes of the B&B tree is close to 1.The merging algorithm also performs well for large instances. The reason is that as the number of requests N increases, the number of arcs visiting each I/O point increases, and consequently the number of swappable arcs increases. Therefore, most of the subtours can be merged in the first phase and the second phase becomes unnecessary.The algorithm is robust. From Table 3 it is clear that for a fixed number of requests, the computation time and number of nodes of the two-phase solution method are quite insensitive to changes in problem inputs such as: number of bays, rows, requests and percentage of retrieval requests in different scenarios. The reason is that the performance of the solution method depends on the performance of the merging algorithm which mainly depends on the ratio of the number of requests to the number of I/O points. When the number of requests is 100 and the number of I/O points is less than 10, the ratio of the requests to I/O points is high enough (even in case of 10 I/O points, on average 10 containers are picked up or delivered at each I/O point) for the merging algorithm in order to be able to patch all subtours in the first phase of the algorithm. The computation time of the first phase of the solution method is about the same for all scenarios with a fixed number of requests.The last four rows of Table 3 investigate theoretical cases with 50 or more I/O points, in order to find out the effect of the number of I/O points on the computation time complexity. By increasing the number of I/O points the probability of merging subtours in the first phase decreases. As a result, ρ, the computation time and the number of nodes increases. However, in this problem, when the number of I/O points is 50, each I/O point is on average shared by 2 requests (N=100). Therefore, it is still probable that the subtours can be merged in the first phase using swappable arcs with common visiting I/O points. Furthermore, we have 50 retrieval requests that can be delivered to any I/O point at their destination side. The flexibility created by these requests definitely helps to patch many subtours in the merging algorithm. Finally, the travel times in this problem are confined to the size of the block. As a result, the AP relaxation of the problem provides a good lower bound, as shown in columnZAP∗Z∗. Therefore, even if the merging algorithm cannot merge subtours using the common I/O points, the optimal solution can be found in a limited number of nodes.The optimal solution is significantly better than the solutions obtained by the NN and random heuristics. Based on the results presented in Table 4, when there is a balance between the number of storage and retrieval requests (P=50%), the average objective value improvement is more than 30% in case of the random heuristic, and 14% in case of the NN heuristic. On the other hand, in case of an imbalance between the number of storage and retrieval requests (moving towardP=0or 100%), both random and NN heuristics perform better. The reason is that in the optimal solution, more pure storage and retrieval requests must be individually executed by the YC, and there is less opportunity to sequence retrieval requests after storage requests for minimizing the empty travel time of the YC.We also compare the results of 12 different random instances obtained by the two-phase solution method with those results obtained by CPLEX 12.2 coded in C++ using the Concert Technology framework and executed by a g++ compiler on a 2.40gigahertz AMD Opteron™ Processor 250, with 8.00gigabytes of RAM under the Linux operating system. The results presented in Table 5confirm the complexity of the problem, as CPLEX cannot solve the problems in reasonable time. The computation in CPLEX was truncated after 18,000seconds. Table 5 shows that there is a large gap between the feasible objective value obtained by CPLEX in 18,000seconds and the optimal objective value (obtained in less than a second). By increasing the number of requests, the gap between the two values increases. To start CPLEX, we use the problem formulation presented in Eqs. (2)–(6).In this section, we use real data, provided by the Ultimate project (see Ultimate, 2013), to evaluate the performance of our solution method at a hinterland terminal linked to the Port of Rotterdam. Table 6shows an excerpt from the terminal database including requests with their locations and transport modes with which they arrive or leave the terminal in the next half hour. We use this list of requests to evaluate our method.The terminal uses a score-based heuristic available in the terminal operating software to sort requests to be handled. The score points given to each container are determined by the due-time and the transport mode to deliver it or pick it up. Using this heuristic, many containers receive relatively the same total score. The heuristic can therefore categorize containers into multiple groups handled one by one based on their scores. Containers within each group can be sorted in any order, and are carried out using the NN heuristic.All containers listed in Table 6 receive roughly the same score. Thus, the terminal uses the NN heuristic to sort them. We use our two-phase solution method to sort them. Our calculations show that the improvement over the NN objective value is 8.4%. The improvement depends on how many containers receive the same relative score. It can be large if many containers can be sequenced simultaneously. If there is a balance between the number of storage and retrieval requests at the seaside and landside, our solution method can improve the result significantly by performing double cycles.At terminals, the list of container requests is updated in given time periods. We can run our solution method and find a new request sequence as soon as the list is updated. The ending location of the YC in the previous time period serves as the starting location of the YC in the current time period.We model and solve a difficult operational problem in which a set of container storage and retrieval requests must be sequenced. We minimize the total travel time of a single YC carrying out the requests in a single block of containers. An efficient YC scheduling operation can significantly affect the overall performance of the container terminal. We formulate the problem as an integer model, prove the problem complexity, and develop a two-phase solution method to obtain optimal solutions. The merging algorithm proposed in the first phase to patch subtours of an optimal AP solution works efficiently specially for large-scale problems. As the number of requests increases, the average number of requests per I/O point increases and therefore, the merging algorithm has more opportunity to patch subtours. As a result, in most of the realizations of the scenarios an optimal solution can be obtained in the first phase by optimally solving the AP and using the merging algorithm. If an optimal solution cannot be obtained in the first phase, a B&B algorithm in the second phase rapidly finds an optimal solution. The computation time of the solution method is low, i.e. it is less than a second when the number of requests is 200. The gaps between the optimal value and the objective values of the random and NN heuristics are on average more than 30% and 14%, respectively. Furthermore, the two-phase solution method significantly outperforms CPLEX for small-size instances. For instances with 80 requests, CPLEX cannot obtain a feasible solution after five hours. We also have tested the method on data from a hinterland terminal and found an improvement of 8.4%.The model developed in this paper can be extended in several directions. We focus on scheduling isolated YC operations. Container handling operations at a terminal requires integrated coordination from QCs, vehicles, YCs, and gates at the seaside, stacking area, and landside. The terminal resources need to be coordinated effectively and the interactions among them need to be understood well. Furthermore, we consider that storage locations are given. However, one may consider combining the YC scheduling problem with the container allocation problem. Finally, we consider that all storage containers are available at the I/O points and a retrieval container can be dropped off at the same I/O point from where another container has to be stacked in the block. But safety regulations and space availability cause some limitations. Extra constraints are required to model reality.

@&#CONCLUSIONS@&#
