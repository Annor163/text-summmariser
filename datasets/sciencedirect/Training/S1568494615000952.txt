@&#MAIN-TITLE@&#
Order acceptance and scheduling to maximize total net revenue in permutation flowshops with weighted tardiness

@&#HIGHLIGHTS@&#
This paper studies the permutation flowshop scheduling problem with order acceptance and weighted tardiness.The proposed algorithm provides a practical means of solving this problem.Experimental results reveal that the proposed algorithm outperforms the state-of-the-art algorithm.

@&#KEYPHRASES@&#
Order acceptance and scheduling problem,Multi-initiator simulated annealing,Permutation flowshop,Weighted tardiness,

@&#ABSTRACT@&#
The order acceptance and scheduling (OAS) problem is important in make-to-order production systems in which production capacity is limited and order delivery requirements are applied. This study proposes a multi-initiator simulated annealing (MSA) algorithm to maximize the total net revenue for the permutation flowshop scheduling problem with order acceptance and weighted tardiness. To evaluate the performance of the proposed MSA algorithm, computational experiments are performed and compared for a benchmark problem set of test instances with up to 500 orders. Experimental results reveal that the proposed heuristic outperforms the state-of-the-art algorithm and obtains the best solutions in 140 out of 160 benchmark instances.

@&#INTRODUCTION@&#
The order acceptance and scheduling (OAS) problem, proposed by Guerrero and Kern [1], has attracted increasing attention both from researchers and practitioners. Order acceptance involves determining the orders to be accepted for processing, while order scheduling involves deciding the production sequence of the accepted orders [2]. A trade-off between revenue and cost is inevitably in the decision-making of order processing [1]. Trade-offs often occur in many make-to-order production systems that have limited production capacity and short delivery deadlines, such as in the printing [3], lamination [4], steel production [5] and laundry service [6] industries.Various OAS problems with different characteristics and objectives have been studied over the last two decades. Many exact methods have been utilized to solve those OAS problems, such as integer programming [7], mixed integer programming [4,8–11], dynamic programming [12–16] and branch-and-bound algorithms [11,17–19]. Due to the complexity of the OAS problem, a global optimal solution can be difficult to find when the problem size is particularly large. Accordingly, researchers may seek efficient approximation heuristics in order to find a near-optimal solution within reasonable computation time. Many approximation heuristics are proven robust in delivering near-optimal solutions and resolving limitations encountered in exact methods [20,21]. Currently available approximation heuristics for solving OAS problems can be generally classified into two categories: constructive heuristics (CHs) and improvement heuristics (IHs).CHs, such as those developed by Stern and Avivi [7], Kyparisis et al. [22], Lewis and Slotnick [16], Engels et al. [12], Yang and Geunes [23], Lee and Sung [17], Oğuz et al. [4], Cesaret et al. [24] and Xiao et al. [6], add orders one at a time and examine the effect of each addition on the objective function value. When an order has been accepted and sequenced, it is fixed and cannot be reversed. Among the available CHs, the weighted shortest processing time (WSPT) heuristic and the due date (DD) heuristic, proposed by Xiao et al. [6], are two of the better approaches. The WSPT heuristic makes order-acceptance decisions based on the increasing order of the weighted shortest processing time; the sequence order of the DD heuristic is made on the basis of increasing due dates, after which the same acceptance decision procedure as for WSPT is applied. However, a common feature of these CHs is the non-robustness of their solutions. Although these CHs yield solutions rapidly, there is not a specific CH which outperforms all other CHs for all problems under a specific performance criterion and manufacturing environment. Additionally, the quality of solutions obtained by the CHs is not always as good as expected, especially for large-scale problems [2].On the other hand, IHs, such as those developed by Akkan [8], Lewis and Slotnick [16], Yang and Geunes [23], Charnsirisakskul et al. [10], Slotnick and Morton [25], Cesaret et al. [24] and Xiao et al. [6], begin with an initial solution, which is then iteratively improved so as to yield a (near-) optimal solution. In recent decades, the development of metaheuristic-based IHs for solving OAS problems has attracted increasing interest from both industry and academia. The existing metaheuristic-based IHs for solving OAS problems include extremal optimization [26], genetic algorithm [5,26,27], simulated annealing [4,6,27], Tabu search [24], hybrid evolutionary algorithm [26], hybrid artificial bee colony algorithm [28,29] and partial optimization algorithm [6]. Experimental results have shown that these metaheuristic-based IHs provide satisfactory solutions for various OAS problems; however, most of the studies dealt with the single machine OAS problem [2,30]. The reader is referred to the excellent reviews of the literature by Keskinocak and Tayur [30] and Slotnick [2] for a detailed discussion and taxonomy of the application models and available heuristics for solving various OAS problems.The permutation flowshop scheduling problem (PFSP) is one of the most extensively studied problems in industry and it continues to be of interest to researchers and practitioners [31–33]. Owing to the nature of various industrial processes, many variants of the basic PFSP have been formulated and studied. Recently, Xiao et al. [6] formulated the permutation flowshop scheduling problem with order acceptance and weighted tardiness (PFSP-OAWT) as an integer programming model. They proposed two versions of the partial optimization algorithm (POA) and a simulated annealing based on the partial optimization (SABPO) algorithm to solve it. The first version of POA, called POA_O, begins with the sequence of orders. The second version of POA, POA_Y, begins with the acceptance states of the orders. Their computational results showed that SABPO outperformed all existing algorithms. To the best of our knowledge, the SABPO algorithm is the best available algorithm for solving the PFSP-OAWT with respect to maximizing the total net revenue.The simulated annealing (SA) algorithm, which is a type of single solution-based metaheuristic, can be used for solving hard optimization problems. Due to the theoretical challenges of solving the OAS problem, an innovative multi-initiator simulated annealing (MSA) algorithm is herein proposed as a step toward developing a more efficient algorithm for solving the PFSP-OAWT. Two problems associated with any optimization algorithm are related to its convergence and escape local optimality [34,35]. The MSA algorithm exhibits the advantages of the SA algorithm as it effectively achieves search convergence. The multi-initiator method incorporates a powerful form of diversification in the generation of initial solutions to help escape local optimality, without which the SA algorithm may become confined to a small region of the solution space, making it hard to discover a global optimum.The remainder of this paper is organized as follows. The problem is formulated in Section 2; in Section 3 the proposed MSA algorithm is described; using an existing benchmark problem set, the effectiveness and efficiency of the proposed MSA algorithm is empirically evaluated in Section 4 by comparing its performance with that of the traditional SA and the state-of-the-art SABPO algorithm; and, finally, in Section 5, conclusions are drawn and recommendations for future research are made.This section defines the PFSP-OAWT and formulates it as an integer programming (IP) model. Before this, the following notations are defined to simplify the exhibition of this formulation.Parametersnnumber of ordersnumber of machinesindex of orders, i∈{1, 2, ..., n}index of machines, j∈{1, 2, ..., m}index of positions, k∈{1, 2, ..., n}identification (ID) of the order that ranks in kth position, k∈{1, 2, ..., n}processing time of order i on machine jdue date of order imaximum revenue of order iper unit-time delay penalty of order icompletion time of order i on machine jcompletion time of the order that ranks in kth position on machine ja binary index, which equals 1 if order i is accepted and otherwise equals 0an integer variable denoting the sequence position of order iBased on the above notations, the PFSP-OAWT can be formally defined as follows. A collection of n incoming orders (jobs) are to be processed on m machines in an identical technological order given by the indexing of the machines; the sequence in which all accepted orders are processed is the same on all machines, with both the limited production capacity and the order delivery requirements determining the acceptance of orders.Each incoming order i is identified with the following non-negative data: the processing time required for each incoming order i (i=1, ..., n) on machine j (j=1, ..., m) pi,j; a preferred due date, di, after which a tardiness penalty is incurred; a maximum revenue, Qi, gained by the manufacturer if order i is accepted and its tardiness is zero; and a weight, wi, which is the penalty per unit-time delay beyond diin the delivery to the customer. Since tardiness penalties result in a loss of revenue, order acceptance and scheduling decisions are necessary.Based on the above definitions, the objective is to determine the orders to be accepted for processing and the production sequence for the accepted orders, with the aim to maximize the total net revenue (TNR), which can be formulated as follows:TNR=∑i=1nxi(Qi−wiTi)where xiis an indicator that equals 1 if order i is accepted, and 0 otherwise; and Ti=max{0, Ci,m−di} is the tardiness of order i, in which Ci,mis the completion time of order i. Obviously, TNR equals the revenues from all accepted orders minus the total weighted tardiness penalties.In the PFSP-OAWT considered in this study, the following assumptions have been made:•Each machine is initially idle at the beginning of the scheduling period and can execute at most one accepted order at a time.Each accepted order is processed no more than once on each machine and can be processed by only one machine at a time.No preemptive priority is assigned. When the processing of an accepted order on a machine has begun, it must be completed before another accepted order can be processed on that machine.Each order is independent of every other order and is released to the shop at the beginning of the scheduling period.The setup times of the orders on machines are negligible.The machines are always available for processing all accepted orders throughout the scheduling period and no interruptions occur.If the next machine in the sequence needed by an accepted order is not available, then the order can wait in a stocking area and joins the queue at that machine.The PFSP-OAWT described above can be formulated as the following IP model [6].MaximizeTNR=∑i=1nxi(Qi−wimax{0,Ci,m−di})Subject to(1)Ci,j≥xj(Ci,j−1+pi,j),∀i,j,(2)C[k],j≥C[k],j−1+xipi,j,i=o[k],∀k,j,(3)si=k,∀i=o[k],(4)si≠si′,∀i≠i′,(5)xi∈{0,1},∀i,(6)si∈{1,2,...,n},∀i.Constraint set (1) indicates that an order can be processed at stage j only after it has been processed at stage j−1. Constraint set (2) denotes that an order can be processed at stage j only after the orders ranking in its front have been processed. Constraint set (3) represents that the sequence index can be get through an order ID or, conversely, the order ID can be get through its sequence index. Constraint set (4) is used to ensure that no two orders can be assigned to the same sequence position. Finally, constraint sets (5) and (6) define the decision variables.The PFSP-OAWT is commonly faced by make-to-order production systems that have to select a subset of orders from the candidate order set and synchronously schedule the selected orders on a flowshop processing line, in order to maximize the total net revenue with weighted tardiness penalties. If two integer sets are used to represent the sequence positions and acceptance states of n orders in a solution, respectively, the size of the solution space is n!·2n. To reduce the solution space, in this study, an integer set is used to represent the preferred sequence of n orders. Those orders entering with negative net revenues at a certain position in the preferred sequence will be rejected; the size of the solution space will be reduced to n!. If all orders are accepted, the PFSP-OAWT is reduced to a corresponding PFSP with a total weighted tardiness penalty, which is proven to be NP-hard in the strong sense, even in the case of a single machine [36]. As a more complicated case, the PFSP-OAWT is also strongly NP-hard in the strong sense. Consequently, exact algorithms are practical only for very small-sized PFSP-OAWT.The concept of the proposed MSA algorithm is taken from the annealing process utilized in the metallurgical industry, by which metals are slowly cooled to produce better aligned, low-energy crystallization [37]. Metropolis et al. [38] introduced the concept of SA, which was subsequently popularized by Kirkpatrick et al. [39] and Cerny [40] for solving challenging optimization problems. The SA algorithm typically begins with an initial solution generated randomly or by heuristic [41,42]. Subsequently, in each iteration, the SA generates a new solution from the neighborhood of the incumbent solution. If the value of the objective function of the new generated solution is better than that in the incumbent solution, it will replace the incumbent solution from which the search proceeds. A new solution with a poorer objective function value could be accepted as the incumbent solution with a probability.The following subsections discuss the representation of the solution, the order acceptance method, the initial solution, the neighborhood and the procedure of the proposed MSA algorithm for solving the PFSP-OAWT.A solution σ is denoted by a sequence of numbers (σ1, σ2, …, σn) that represents the preferred sequence of n orders. The orders in the preferred sequence which have positive net revenues (i.e.Qi−wiT>0) will be selected, while those orders entering with negative net revenues (i.e.Qi−wiT≤0) at a certain position in the sequence will be rejected. It is clear that this solution representation always gives a feasible solution that can determine which orders are accepted and their operational sequence. Another advantage of this solution representation is that it can automatically balance the acceptance and scheduling of orders in the optimization process.To demonstrate the representation of the solution and the order acceptance method, a problem that involves seven orders and three machines, specified in Table 1, can be used. Consider a solution [7536421], where 1 denotes order O1, 2 denotes O2 and so forth. Since the orders O7, O5, O3 and O6 in the preferred sequence have positive net revenues, they are accepted. Order O4 is rejected due to entering with negative net revenues at the fifth position in the preferred sequence. Finally, orders O2 and O1, which have positive net revenues at the fifth and sixth positions in the sequence of selected orders, are accepted for processing. The corresponding relationship between the order sequence of selected orders and the processing machines is shown in a Gantt chart (Fig. 1), where the total net revenue is 162.60. Notably, orders O5 and O1 have time delays of one and two units, respectively. Hence, the net revenues generated by orders O5 and O1 are 16.8 and 23.8, respectively.The initial solution is generated by randomly sorting the n orders. Let σ be the incumbent solution and N(σ) the set of solutions that are neighbors of σ. The set N(σ) can be obtained by applying either a swap or an insertion operation to the orders. For the swap operation, N(σ) is sampled by directly swapping one order selected at random with another; while for the insertion operation, N(σ) is sampled by inserting a randomly selected order immediately before another randomly selected order. To balance the swap and insertion operations, in this study, the probabilities of applying the swap and insertion operations were fixed at 0.5 and 0.5, respectively.Fig. 2presents the procedures of the proposed MSA algorithm. Initially, the five parameters of the MSA algorithm: T0, β, Iiter, Nnon-improvingand Psize, are input, where T0 is the initial temperature; β denotes the coefficient controlling the cooling schedule; Iiterrepresents the number of iterations performed by the search at a particular temperature; Nnon-improvingstands for the allowable number of reductions in temperature where the objective function value of the obtained best solution is not improved during the searching procedures; and Psizeis the number of the initial solutions. In Step 1, Psizeinitial solutions σp(p=1, …, Psize) are randomly generated. Then, in Step 2, TNR(σp), ∀p×, is calculated using the equationTNR=∑i=1nxi[Qi−wiTi], where xi=1 ifQi−wiT>0, and xi=0 otherwise. In Step 3, we let σbestbe the best one among the Psizeinitial solutions, and set TNRbest=TNR(σbest), T=T0; I=0; and N=0, where T denotes the current temperature. I is the accumulated number of iterations performed by the search at a particular temperature, and N is a counter of the number of temperature reductions. In Step 4, a main loop is performed until N<Nnon-improving. In each iteration of the main loop, the next solutionsσ′p(p=1, …, Psize) are randomly selected from their corresponding N(σp). Let Δpbe the difference between TNR(σp) andTNR(σ′p), i.e.Δp=TNR(σp)−TNR(σ′p). If Δp≥0, σpwill be replaced byσ′p. Otherwise, the probability of replacing σpwithσ′p, given Δp<0, is Exp(Δp/T). This replacement can be performed by generating a random number r from the standard uniform distribution on interval [0,1] and replacing solution σpwithσ′pif r<Exp(Δp/T). If a new σbestsolution is obtained, then all of the incumbent solutions σp(p=1, …, Psize) are set to the new σbestsolution. The current temperature T will be reduced after Iiteriterations from the previous decrease according to the formula T←βT, where 0<β<1. If the current best solution σbestis not improved in Nnon-improvingsuccessive temperature reductions, then the algorithm is terminated. Following the termination of the MSA algorithm, in Step 5, a (near-) global optimal solution can be obtained from σbest. Since the proposed MSA algorithm is a probabilistic metaheuristic for finding a near-optimal solution in a large search space, the solution may be different in each run. However, if we fix the random seed of the random number generator, the solution of the proposed MSA algorithm can be repeated.Notably, the main differences between MSA and SABPO include four aspects: the representation of the sequence positions and acceptance states of orders in a solution, the neighborhoods generation method, the termination condition, and the number of initial solutions. First, SABPO used two integer sets to represent the sequence positions and acceptance states of orders in a solution, respectively, producing a solution space with a size of n!·2n; MSA only used an integer set to represent a solution, which produced a solution space with a size of n!. Second, SABPO employed a partial optimization strategy to generate neighborhoods, partially optimizing one of two integer sets (i.e. the sequence positions and acceptance states of orders) while fixing the other in turn; MSA directly applied either a swap or an insertion operation to the orders of an integer set to generate neighborhoods. Third, SAPBO used a threshold temperature to indicate whether the annealing process should be terminated; MSA is terminated when the current best solution is not improved in a threshold number of successive temperature reductions. Fourth, a solution is initialized randomly as the incumbent solution in SABPO; a multi-start strategy is applied to generate a set of initial solutions in MSA. Moreover, if Psize=1, the proposed MSA algorithm will be reduced to an SA algorithm, which is used to compare with MSA to evaluate the impact of the multi-start strategy on solution quality.In this section, the computational tests that were used to evaluate the performance of the proposed MSA algorithm are elucidated, with a discussion in the following subsections of the details of the test problems and the selection of parameters. The computational results of the proposed MSA algorithm are compared with the state-of-the-art SABPO algorithm and the SA algorithm, that is, MSA with Psize=1, for the PFSP-OAWT.To evaluate the performance of the proposed MSA algorithm, computational simulations and comparisons were performed using a well-known benchmark problem set of Xiao et al. [6]. The benchmark instances consisted of 16 different sizes, with the number of orders varying from 10 to 500 and the number of machines varying from 3 to 20. For each size of problem, 10 instances were randomly generated, resulting in 160 test instances in total. The first five instances of each size of problem had relatively short due dates to simulate heavy loading, while the second five instances had relatively long due dates to simulate light loading. Obviously, a heavy loading instance will result in more rejected orders than a light loading instance. For each order i(i=1, …, n) on each machine j(j=1, …, m), an integer processing time pijwas generated from the uniform distribution [1,100]. The revenues Qiand weights wiof each order i(i=1, …, n) were randomly generated from the uniform distribution, [1,500] and [0.5, 1.5], respectively. The due date diof each order i(i=1, …, n) was randomly generated from the uniform distribution, [1,40×n×m] and [1,40×n×m], in a heavy loading environment and a light loading environment, respectively. The files that correspond to these test instances are available on the web site (http://swlin.cgu.edu.tw/data/PFSS-OAWT-Data.zip). It should be noted that some orders do not have positive net revenue even if they are the first order to be processed; therefore, if these orders are omitted in the solution space, a better performance may be obtained.Since the parameters of the proposed MSA algorithm may affect the performance of the algorithm, extensive computational testing was carried out to determine the appropriate parameter values. Sixteen instances were randomly selected from the benchmark problem set for preliminary testing. The following combinations of the parameter values were tested on 16 test instances, with each instance solved in 30 independent runs of the proposed MSA algorithm, with Iiter=500/Psize, 1000/Psize, 1500/Psize, 2000/Psize; Nnon-improving=5, 10, 15, 20; T0=3, 5, 10, 15, 20; β=0.90, 0.93, 0.95, 0.97; and Psizein the range of 1–21. The test results showed that the best solution was obtained within a reasonable computation time using T0=10, Iiter=1000/Psize, Nnon-improving=20, β=0.90 and Psize=18. Therefore, these parameter values were used in the experiments in this study.

@&#CONCLUSIONS@&#
