@&#MAIN-TITLE@&#
Parallel heuristics for scalable community detection

@&#HIGHLIGHTS@&#
Novel parallel heuristics for community detection in large-scale graphs.Multi-threaded implementations using OpenMP.Thorough experimental evaluation of parallel heuristics on a platform with 32 cores.

@&#KEYPHRASES@&#
Community detection,Parallel graph heuristics,Graph coloring,Graph clustering,

@&#ABSTRACT@&#
Community detection has become a fundamental operation in numerous graph-theoretic applications. It is used to reveal natural divisions that exist within real world networks without imposing prior size or cardinality constraints on the set of communities. Despite its potential for application, there is only limited support for community detection on large-scale parallel computers, largely owing to the irregular and inherently sequential nature of the underlying heuristics. In this paper, we present parallelization heuristics for fast community detection using the Louvain method as the serial template. The Louvain method is a multi-phase, iterative heuristic for modularity optimization. Originally developed by Blondel et al. (2008), the method has become increasingly popular owing to its ability to detect high modularity community partitions in a fast and memory-efficient manner. However, the method is also inherently sequential, thereby limiting its scalability. Here, we observe certain key properties of this method that present challenges for its parallelization, and consequently propose heuristics that are designed to break the sequential barrier. For evaluation purposes, we implemented our heuristics using OpenMP multithreading, and tested them over real world graphs derived from multiple application domains (e.g., internet, citation, biological). Compared to the serial Louvain implementation, our parallel implementation is able to produce community outputs with a higher modularity for most of the inputs tested, in comparable number or fewer iterations, while providing absolute speedups of up to16×using 32 threads.

@&#INTRODUCTION@&#
Community detection, or graph clustering, is becoming pervasive in the data analytics of various fields including (but not limited to) scientific computing, life sciences, social network analysis, and internet applications [1]. As data grows at explosive rates, the need for scalable tools to support fast implementations of complex network analytical functions such as community detection is critical. Given a graph, the problem of community detection is to compute a partitioning of vertices into communities that are closely related within and weakly across communities. Modularity is a metric that can be used to measure the quality of communities detected [2]. Modularity maximization is an NP-Complete problem [3] and therefore fast approximation heuristics are used in practice. One such heuristic is the Louvain method [4].Our basis for selecting the Louvain heuristic for parallelization hinges on its increasing popularity within the user community and owing to its strengths in algorithmic and qualitative robustness. With well over 1700 citations to the original paper (as of this writing), the user base for this method has been rapidly expanding in the last few years. As network sizes continue to grow rapidly into scales of tens or even hundreds of billions of edges [5], the memory and runtime limits of the serial implementation are likely to be tested. However, parallelization of this inherently serial algorithm can be challenging (as discussed in Section 4).The parallel solutions presented in this paper (Section 5) provide a way to overcome key scalability challenges. In devising our algorithm, we factored in the need to parallelize without compromising the quality of the original serial heuristic and yet be capable of achieving substantial speedup. Where possible, we also factored in the need for guaranteeing stability in output across different platforms and programming models. The resulting algorithm, presented in Section 5.4, is a combination of heuristics that can be implemented on both shared and distributed memory machines. As demonstrated in our experimental section (Section 6), our multi-threaded implementations output results that have either a higher or comparable modularity to that of the serial method, and is able to reduce the time to solution by factors of up to16×. These observations are supported over a number of real-world networks.Contributions: The main contributions of this paper are:(i)Introduction of novel and effective heuristics for parallelization of the Louvain algorithm on multithreaded architectures;Experimental studies using 11 real-world networks obtained from varied sources including the DIMACS10 challenge website, University of Florida sparse matrix collection and biological databases; andA thorough comparative study of the performance and related trade-offs among the different parallel heuristics along with the serial Louvain method.LetG(V,E,ω)be an undirected weighted graph, where V is the set of vertices, E is the set of edges andω(.)is a weighting function that maps every edge in E to a non-zero, positive weight.1If the graph is unweighted, then we treat every edge to be of weight 1.1In the input graph, edges that connect a vertex to itself are allowed — i.e.,(i,i)can be a valid edge. However, multi-edges are not allowed. Let the adjacency list of i be denoted byΓ(i)={j|(i,j)∈E}. Letkidenote the weighted degree of vertex i — i.e.,ki=∑j∈Γ(i)ω(i,j). We will use n to denote the number of vertices inG;Mto denote the number of edges in the graph; and m to denote the sum of all edge weights — i.e.,m=12∑i∈Vki.A community within graph G represents a (possibly empty2The notion of empty communities does not have practical relevance. We have intentionally defined it this way so as to make our later algorithmic descriptions easier. It is guaranteed, however, that all output communities at the end of our algorithm will be non-empty subsets.2) subset of V. In practice, for community detection, we are interested in partitioning the vertex set V into an arbitrary number of disjoint non-empty communities, each with an arbitrary size (>0and⩽n). We call a community with just one element as a singlet community. We will useC(i)to denote the community that contains vertex i in a given partitioning of V. We use the term intra-community edge to refer to an edge that connects two vertices of the same community. All other edges are referred to as inter-community edges. LetEi→Crefer to the set of all edges connecting vertex i to vertices in community C. And letei→Cdenote the sum of the edge weights for the edges inEi→C.(1)ei→C=∑(i,j)∈Ei→Cω(i,j)LetaCdenote the sum of the degrees of all the vertices in community C (also referred to as community degree).(2)ac=∑i∈CkiModularity: LetP={C1,C2,…Ck}denote the set of all communities in a given partitioning of the vertex set V inG(V,E,ω), where1⩽k⩽n. Consequently, the modularity (denoted by Q) of the partitioning P is given by the following expression [2]:(3)Q=12m∑i∈Vei→C(i)-∑C∈PaC2m·aC2mModularity is not an ideal metric for community detection and issues such as resolution limit have been identified [1,6]; a few variants of modularity definitions have also been devised [6–8]. However, the definition provided in Eq. (3) continues to be the more widely adopted version in practice, including in the Louvain method [4], and therefore, we will use that definition for this paper.Community detection: GivenG(V,E,ω), the problem of community detection is to compute a partitioning P of communities that maximizes modularity.This problem has been shown to be NP-Complete [3]. Note that this problem is different from graph partitioning problem and its variants [9], where the number of clusters and the rough size distribution of those target clusters are known a priori. In the case of community detection, both quantities are unknown prior to computation. In fact they encapsulate the input properties that one seeks to discover out of the community detection exercise.In 2008, Blondel et al. presented an algorithm for community detection [4]. The method, called the Louvain method, is a multi-phase, iterative, greedy heuristic capable of producing a hierarchy of communities. The main idea of the algorithm can be summarized as follows: The algorithm has multiple phases, and within each phase it carries out multiple iterations until a convergence criterion is met.At the beginning of the first phase, each vertex is assigned to a separate community. Subsequently, the algorithm progresses from one iteration to another until the net modularity gain becomes negligible (as defined by a predefined threshold). Within each iteration, the algorithm linearly scans the vertices in an arbitrary but predefined order. For every vertex i, all its neighboring communities (i.e., the communities containingi’s neighbors) are examined and the modularity gain that would result if i were to move to each of those neighboring communities from its current community is calculated. Once the gains are calculated, the algorithm assigns a neighboring community that would yield the maximum modularity gain, as the new community for i (i.e., newC(i)), and updates the corresponding data structures that it maintains for the source and target communities. Alternatively, if all gains turn out to be negative, the vertex stays in its current community. An iteration ends once all vertices are linearly scanned in this fashion. Consequently, the modularity is a monotonically increasing function across iterations of a phase.Once the algorithm converges within a phase, it proceeds to the next phase by collapsing all vertices of a community to a single “meta-vertex”; placing an edge from that meta-vertex to itself with an edge weight that is the sum of weights of all the intra-community edges within that community; and placing an edge between two meta-vertices with a weight that is equal to the sum of the weights of all the inter-community edges between the corresponding two communities. The result is a condensed graphG′(V′,E′,ω′), which then becomes the input to the next phase. Subsequently, multiple phases are carried out until the modularity score converges. Note that each phase represents a coarser level of hierarchy in the community detection process.At any given iteration, letΔQi→C(j)denote the modularity gain that would result from moving a vertex i from its current communityC(i)to a different communityC(j). This term is given by:(4)ΔQi→C(j)=ei→C(j)-ei→C(i)⧹{i}m+2·ki·aC(i)⧹{i}-2·ki·aC(j)(2m)2Consequently, the new community assignment for i at an iteration is determined as follows. Forj∈Γ(i)∪{i}:(5)C(i)=argmaxC(j)ΔQi→C(j)In the implementation [10], several data structures are maintained such that each instance ofΔQi→C(j)can be computed inO(1)time. Consequently, the algorithm’s time complexity per iteration isO(M). While no upper bound has been established on the number of iterations or on the number of phases, it should be evident that the algorithm is guaranteed to terminate with the use of a cutoff for the modularity gain (because of the modularity being a monotonically increasing function until termination). In practice, the method needs only tens of iterations and fewer phases to terminate on most real world inputs.Any attempt at parallelizing the Louvain method should factor in the sequential nature in which the vertices are visited within each iteration and the impact it has on convergence. Visiting the vertices sequentially gives the advantage of working with the latest information available from all the preceding vertices in this greedy procedure. Furthermore, in the serial algorithm, when a vertex computes its new community assignment (using Eq. (5)), it does so with the guarantee that no other part of the community structure is concurrently being altered. These guarantees may not hold in parallel. In other words, if communities are updated in parallel, it could lead to some interesting situations with an impact on the convergence process as described below.To illustrate the case in point, consider the example scenario illustrated in Fig. 1, where two vertices i and j are both connected to a third vertex k with all three of them in different communities initially — i.e.,i∈C(i),j∈C(j),k∈C(k)s.t.C(i)≠C(j)≠C(k). If both vertices i and j evaluate the possibility of moving toC(k)independently, using Eq. (4), then from each of their perspectives, their predicted value for the new modularity isQold+ΔQi→C(k)andQold+ΔQj→C(k), respectively. However, if both i and j decide to move toC(k)in parallel, then the actual value for the new modularity will beQold+ΔQ{i,j}→C(k), where:(6)ΔQ{i,j}→C(k)=ΔQi→C(k)+ΔQj→C(k)+ω(i,j)m-2·ki·kj(2m)2If(i,j)∉E,ω(i,j)=0, implying:(7)ΔQ{i,j}→C(k)=ΔQi→C(k)+ΔQj→C(k)-2·ki·kj(2m)2⩽ΔQi→C(k)+ΔQj→C(k)Furthermore, ifΔQi→C(k)+ΔQj→C(k)<2·ki·kj(2m)2(8)⇒ΔQ{i,j}→C(k)<0On the other hand, ifω(i,j)m>2·ki·kj(2m)2(can be true only if(i,j)∈E), then:(9)ΔQ{i,j}→C(k)>ΔQi→C(k)+ΔQj→C(k)This is becauseΔQi→C(k)>0andΔQj→C(k)>0; the latter two inequalities follow from the fact that i and j chose to move toC(k). Note that if this happens, then parallel version could potentially surpass the serial version toward modularity convergence.Lemma 1At any given iteration of the Louvain algorithm, if community updates for vertices are performed in parallel, then the net modularity gain achieved cannot be guaranteed to be always positive.Follows directly from inequality (7). □The above lemma has a direct implication on the convergence property of the Louvain method, one way or another. Pessimistically speaking, if the net modularity gain can become negative between consecutive iterations of the algorithm, then there is no theoretical guarantee that the algorithm will terminate. Even if the chances of non-termination turn out to be bleak, it could potentially slow down the rate at which the algorithm progresses toward a solution, causing more number of iterations. For this reason, the number of iterations that the algorithm takes to converge toward the solution and the quality of the solution relative to the serial algorithm’s can be good indicators of the effectiveness of a parallel strategy. Note that the above example with three vertices can be extended to scenarios where multiple unrelated vertices are trying to enter a community at its periphery without mutual knowledge.There exists another scenario that could impede the progression of the parallel algorithm toward a solution. Consider a simple example where two vertices i and j connected by an edge(i,j)∈Es.t.,C(i)={i}andC(j)={j}. In the interest of increasing modularity, if the two vertices make a decision to move to each other’s community concurrently, then such an update could potentially result in both vertices simply swapping their community assignments without achieving any modularity gain. This could also happen in a more generalized setting, where subsets of vertices between two different communities swap their community assignments, each unaware of the other’s intent to also migrate.A parallel algorithm also runs the risk of settling on locally optimal decisions. This could happen even in serial; in parallel such scenarios may arise if a single community gets partitioned into equally weighted sub-communities, in which there is no incentive for any individual vertex to merge with any of the other sub-communities; and yet, if all vertices from each of the sub-communities were to merge together to form a single community the net modularity gain could be positive. An example of this case will be shown later in Section 5.1. Getting stuck in a locally optimal solution, however, can be resolved when the algorithm progresses to subsequent phases.In this section, we present our ideas to tackle the challenges outlined above in parallelizing the Louvain heuristic community detection.Section 4.2 elaborated on the possibilities of swapping conditions that may delay the parallel algorithm’s convergence to a solution. In this section we present a heuristic designed to address some of these cases. Let us consider the simple case of two vertices i and j outlined in Section 4.2. Here both vertices are initially in communities of size one, and a decision in favor of merging at any given iteration will lead them to simply swap their respective communities without resulting in any net modularity gain. This is outlined in the Case 1a of Fig. 2. Such a swap can be easily prevented by introducing a labeling scheme where it can be enforced that only one of them move to other’s community. More specifically, let the communities at any given stage of the algorithm be labeled numerically (in an arbitrary order). We will use the notationℓ(C)to denote the label of a community C. Then the heuristic is as follows:The singlet minimum label heuristic: In the parallel algorithm, at any given iteration, if a vertex i which is in a community by itself (i.e.,C(i)={i}), decides (in the interest of modularity gain) to move to another communityC(j)which also contains only one vertex j, then that move will be performed only ifℓ(C(j))<ℓ(C(i)).The above heuristic can be generalized to other cases of swapping or local maxima. For instance, let us consider the 4-clique of{i4,i5,i6,i7}shown in Fig. 2: case 2, assuming that each vertex is in its own individual community to start with. Here, in the absence of an appropriate heuristic there is a chance that the algorithm would settle on a local maxima. For instance, maximum modularity gains can be achieved at vertexi4by either moving toC(i6)orC(i7), and similarly for vertexi5. However, ifi4moves toC(i6)andi5toC(i7), then the resulting solution{i4,i6},{i5,i7}(shown in case 2a of Fig. 2) will represent a local maxima from which the algorithm may not proceed in the current phase. This is because, once these partial communities form, there is no incentive fori4ori6to individually move to the community containing{i5,i7}, without each other’s company. This is a limitation imposed by the Louvain heuristic, which makes decisions at the vertex level. However, if we label and treat the communities in a certain way then such local maxima situations can be avoided.The generalized minimum label heuristic: In the parallel algorithm, at any given iteration, if a vertex i has multiple neighboring communities yielding the maximum modularity gain, then the community which has the minimum label among them will be selected asi′s destination community.In the example for Fig. 2: case 2, verticesi6andi7will both yield the maximum modularity gain for verticesi4andi5. However, using the above minimum label heuristic, all three vertices{i4,i5,i7}will migrate toC(i6), whilei6stays inC(i6)— i.e., assumingℓ(C(i4))<ℓ(C(i5))<ℓ(C(i6))<ℓ(C(i7)).While swap situations may delay convergence, they can never lead to nontermination of the algorithm due to the use of a minimum required net modularity gain threshold to continue a phase. As for local maxima, a general proof that effects of elimination of local maxima cases progressively as the algorithm progresses is not possible due to the heuristic nature of algorithm. However, many situations, similar to those explained earlier in Section 4.2, typically get resolved in subsequent phases; this is because the representation of the individual sub-communities as meta-vertices is likely to lead them to merge with one another forming the containing communities eventually in the output.In this section, we explore the idea of graph coloring to address some of the parallelization challenges outlined in Section 4. A distance-k coloring of a graph is an assignment of colors to vertices such that no two vertices separated by a distance of at most k are assigned the same color. It should be easy to see that using distance-1 coloring to partition the vertices into color sets prior to the processing would prevent vertex-to-vertex swap scenarios. In this scheme, vertices of the same color are processed in parallel, and this is equivalent of guaranteeing that no two adjacent vertices will be processed concurrently. However, distance-1 coloring may not be adequate to address other potential complications that may arise during parallelization (see Section 4.1).Corollary 2Applying and processing the vertices in parallel by distance-1 coloring does not necessarily preclude the possibility of negative modularity gains between iterations.Follows directly from the three vertex example case presented for Lemma 1. □In fact the same result can be extended for application of a distance-k coloring scheme, wherek>1, as was shown in [11].Despite these lack of guarantees for a positive modularity gain between iterations, coloring still could be effective as a heuristic in practice, as we will demonstrate in Section 6. The performance trade-off presented by coloring is a potential reduction in the degree of parallelism versus faster convergence to higher modularity. Coloring also presents an added advantage of being able to use higher modularity gain thresholds during the earlier phases of the algorithm, as will be explored in Section 6. The run-time cost of coloring is expected to be dominated by the time spent within iterations; furthermore, for scalability in preprocessing, we use a parallel implementation to perform coloring [12].In this section, we will layout a particular property of the serial Louvain algorithm in the way it treats vertices with single neighbors, and devise a heuristic around it. For the purpose of the lemma below, we will assume a version of Louvain algorithm which continues with iterations within a phase, until the communities stop changing. We also distinguish between vertex i being a single degree vertex and a single neighbor vertex — the former is when the only edge incident on i is(i,j), whereas the latter is when i could have up to two edges incident with(i,j)being mandatory and(i,i)being optional.Lemma 3Given an input graphG(V,E,ω), let i and j be two different vertices such that i is a single degree vertex with only one incident edge(i,j)∈E. Then, in the final solutionC(i)=C(j)— i.e., i should be part of the same community as j.Consider any iteration r in which vertices i and j are in two different communities — i.e.,C(i)≠C(j). During iteration r, the value ofΔQi→C(j)will evaluate to the following:(10)ΔQi→C(j)=ω(i,j)m+2·ki·aC(i)⧹{i}-2·ki·aC(j)(2m)2⩾ω(i,j)m-2·ki·aC(j)(2m)2(∵aC(i)⧹{i}⩾0)=ω(i,j)2m22m-ki·aC(j)ω(i,j)Since vertex i is a single degree vertex,ki=ω(i,j). Therefore,(11)ΔQi→C(j)⩾ω(i,j)2m22m-aC(j)Now, if i were to decide against moving toC(j),ΔQi→C(j)⩽0. Given that the above inequality (11) is a lower bound forΔQi→C(j), and also that all edge weights are non-negative:(12)⇒2m-aC(j)⩽0⇒2m⩽aC(j)But inequality (12) is not possible becauseaC(j)⩽2mfor any community (by the definition in Eq. 2) and in this case, sincei∉C(j),aC(j)⩽(2m-ω(i,j))<2m. This implies that i will have no choice but to move toC(j)in iteration r. □We refer to the guarantee provided by the above lemma as the vertex following (VF) rule. Note that it is guaranteed to hold only for single degree vertices in the input graph. The implication of this rule is that there is no need to explicitly make decisions on single degree vertices during the Louvain algorithm’s iterations. Instead, we can preprocess the input such that all single degree vertices are merged a priori into their respective neighboring vertex. More specifically, let i be a single degree vertex with j as its neighbor. Then, we remove vertex i from the graph, and replace j with a new vertexj′, such thatΓ(j′)={Γ(j)⧹{i}}∪{j′}andω(j′,j′)=ω(i,j)if(j,j)∉E; andω(j′,j′)=ω(j,j)+ω(i,j)otherwise.This preprocessing not only could help reduce the number of vertices that need to be considered during each iteration, but it also allows the vertices that contain multiple neighbors (that tend to be the hubs in the networks) be the main drivers of community migration decisions. This is more important under a parallel setting because if the single degree vertices were retained in the network the hub nodes could potentially gravitate temporarily toward one of their single degree mates, thereby delaying progression of solution or getting stuck in a local maxima.We could also extend the result of the Lemma 3 to benefit cases where vertex i is a single neighbor vertex. The idea is similar to that of a k-core decomposition of the graph [13]. Intuitively, during preprocessing, single neighbor vertices can be collapsed into their only neighboring vertex recursively until the negative component of the inequality (10) starts to dominate its positive counterpart. Termination of this recursive merging can be implemented either by explicitly calculating both sides of the inequality (10) or by estimating through other means via lower bounds or statistical thresholds. The idea is to lead to fast compression of chains within the input graph prior to application of the Louvain heuristic. We omit further details of this idea and for the purpose of this paper, we only consider the single degree version of the vertex following heuristic for implementation and experimental evaluation.Algorithm 1. The parallel Louvain algorithm for a single phase. The inputs are a graph (G(V,E,ω)) and an array of size|V|that represents an initial assignment of community for every vertexCinit1: procedure Parallel Louvain(G(V,E,ω),Cinit)2:ColorSets←Coloring(V), where ColorSets represents a color-based partitioning of V.▷ If the coloring step is omitted, then it automatically implies that all vertices belong to the same color set.3:Qcurr←04:Qprev←-∞▷ Current & previous modularity5:Ccurr←Cinit6:whiletruedo▷ Iterate until modularity gain becomes negligible.7:for eachVk∈ColorSetsdo8:Cprev←Ccurr9:for eachi∈Vkin paralleldo10:Ni←Cprev[i]11:for eachj∈Γ(i)doNi←Ni∪{Cprev[j]}12:target←argmaxt∈NiΔQi→t13:ifΔQi→target>0then14:Ccurr[i]←target15:16:Cset←the set of non-empty communities corresponding toCcurr17:Qcurr←Compute modularity as defined byCset18:ifQcurr-QprevQprev<θthen▷θis a user specified threshold.19:break▷ Phase termination20:else21:Qprev←QcurrOur parallel algorithm has the following major steps:(1)VF preprocessing (Optional): Apply the vertex following heuristic by merging all single degree vertices into their respective neighboring vertices (as explained in Section 5.3). This step is performed in parallel. Label the resulting vertices from1…nusing an arbitrary ordering.Coloring preprocessing (Optional): Color the input vertices using distance-k coloring. For this paper, we only explore distance-1 coloring. For coloring, we used the parallel implementation from [12].Phases: Execute phases one at a time as per Algorithm 1. Within each phase, the algorithm runs multiple iterations, with each iteration performing a parallel sweep of vertices without locks and using the community information available from the previous iteration. If coloring was applied, then the processing of each color set is parallelized internally and the community information from the previous coloring stages is available to make migration decisions in subsequent coloring stages. This is carried on until the modularity gain between successive iterations becomes negligible.Graph rebuilding: Between two successive phases, the community assignment output of the completed phase is used to construct the input graph for the next phase. This is done by representing all communities of the completed phase as “vertices” and accordingly introducing edges, identical to the manner in which it is done in the serial algorithm. This step is also implemented in parallel as described in Section 5.5.We note here that the above parallel algorithm, with the exception of coloring heuristic, is stable in that it always produces the same output regardless of the number of cores used. When coloring is applied, the use of multiple threads within a given iteration could potentially vary the order in which decisions are made, thereby leading to potential variations in the output. In our experiments, we found the magnitudes of such variations to be negligible.

@&#CONCLUSIONS@&#
