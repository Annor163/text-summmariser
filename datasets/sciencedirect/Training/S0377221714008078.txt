@&#MAIN-TITLE@&#
Incremental network design with maximum flows

@&#HIGHLIGHTS@&#
An incremental network design problem is studied, where the objective is to maximize the cumulative s-t-flow over a time horizon.Two mixed integer programming (MIP) formulations are presented.Two greedy heuristics are described and performance guarantees in special cases are proved.The MIP formulations as well as the heuristics are compared in computational experiments on randomly generated instances.

@&#KEYPHRASES@&#
Network design,Approximation algorithms,Scheduling,

@&#ABSTRACT@&#
We study an incremental network design problem, where in each time period of the planning horizon an arc can be added to the network and a maximum flow problem is solved, and where the objective is to maximize the cumulative flow over the entire planning horizon. After presenting two mixed integer programming (MIP) formulations for this NP-complete problem, we describe several heuristics and prove performance bounds for some special cases. In a series of computational experiments, we compare the performance of the MIP formulations as well as the heuristics.

@&#INTRODUCTION@&#
In the planning process for many network infrastructures, when the network is constructed over a significant period of time, the properties of the intermediate partial networks have to be taken into account. Incremental network design, introduced in Baxter et al. (2014), represents a class of optimization problems capturing that feature and combining two types of decisions: which arcs should be added to a given network in order to achieve a certain goal, and when should these arcs be added?Variants of this problem have been studied in diverse contexts, for instance, the design of transportation networks (Kim et al., 2008; Ukkusuri and Patil, 2009), network infrastructure restoration after disruptions due to natural disasters (Cavdaroglu et al., 2013; Lee et al., 2007; 2009), and the transformation of an electrical power grid into a smart grid (Mahmood et al., 2008; Momoh, 2009). Our study is motivated by infrastructure expansion questions arising in the coal export supply chain in the Hunter Valley with coal terminals in the Port of Newcastle (see Boland and Savelsbergh, 2011 for details).A general class of mathematical optimization problems that captures essential features of the described decision problems, and includes the problem discussed in this paper as a special case, was introduced in Nurre et al. (2012) and Nurre and Sharkey (2014), where an integrated network design and scheduling problem is specified by (1) a scheduling environment that describes the available resources for adding arcs to the network, (2) a performance measure, which prescribes how a given network is evaluated (for instance by the shortest s-t path or by the maximum s-t flow in the network), and (3) by the optimization goal, which is either to reach a certain level of performance as quickly as possible or to optimize the cumulative performance over the entire planning horizon.We focus on the special case corresponding to incremental network design as introduced in Baxter et al. (2014). Our scheduling environment is such that at most one arc can be added to the network in each time period, and we optimize the cumulative performance, i.e., the sum of the performance measures of the networks in all time periods. Even in this simple setting, the problem has been shown to be NP-complete for classical network optimization problems: for the shortest s-t path problem in Baxter et al. (2014), and for the maximum s-t flow problem in Nurre and Sharkey (2014). Interestingly, the incremental variant of the minimum spanning tree problem can be solved efficiently by a greedy algorithm (Engel et al., 2013), while it becomes NP-complete in the more general setup of Nurre and Sharkey (2014). The performance measure considered in this paper is the value of a maximum s-t flow.In Section 2, we introduce notation, state the problem precisely, and present two MIP formulations. In Section 3, we describe three heuristics, the first one seeks to increment the flow as quickly as possible, the second seeks to reach a maximum flow as quickly as possible, and the third one is a hybrid of the first two. In Section 4, we prove performance guarantees for the first two heuristics in special cases: for unit capacity networks they provide a 2-approximation algorithm and a 3/2-approximation algorithm, respectively, and these bounds can be strengthened when the network has a special structure. Section 5 discusses the results of a set of computational experiments using randomly generated instances. After describing the instance generation, we compare the performance of the two MIP formulations, and evaluate and compare the heuristics on hard instances. We end, in Section 6, with some final remarks.We are given a network D = (N, A) with node set N and arc set A = Ae∪Ap, where Aecontains existing arcs and Apcontains potential arcs, as well as a source s ∈ N and sink t ∈ N. For each arc, we are given an integer capacity ua> 0, and for every node v ∈ N, we denote with δin(v) and δout(v) the set of arcs entering v and the set of arcs leaving v, respectively. Let T > |Ap| be the length of the planning horizon. In every period, we have the option to expand the useable network, which initially consists of only the existing arcs, by “building” a single potential arc a ∈ Ap, which will be available for use from the following time period on. In every period, the value of a maximum s-t flow is recorded (using only useable arcs, i.e., existing arcs and potential arcs that have been built in previous periods). The objective is to maximize the total flow over the planning horizon. Note that the length of the planning horizon ensures that every potential arc can be built. We refer to a maximum s-t flow using only existing arcs as an initial maximum flow, and to a maximum flow for the complete network as an ultimate maximum flow. This problem is strongly NP-hard (Nurre and Sharkey, 2014) even when restricted to instances where every existing arc has capacity 1 and every potential arc has capacity 3. (A simple proof of this result can be found in Appendix A.)The problem can be formulated as a mixed integer program. For every a ∈ A and k ∈ {1, …, T}, we have a flow variable xak≥ 0, and for every a ∈ Apand k ∈ {1, …, T}, we have a binary variable yakwhich indicates if arc a is built before period k (yak= 1) or not (yak= 0). The incremental maximum flow problem is thenmax∑k=1T(∑a∈δout(s)xak−∑a∈δin(s)xak)subject to∑a∈δout(v)xak−∑a∈δin(v)xak=0forv∈N∖{s,t},k∈{1,…,T},xak⩽uafora∈Ae,k∈{1,…,T},xak⩽uayakfora∈Ap,k∈{1,…,T},yak⩾ya,k−1fora∈Ap,k∈{2,…,T},ya1=0fora∈Ap,∑a∈Ap(yak−ya,k−1)⩽1fork∈{2,…,T−1},xak⩾0fora∈A,k∈{1,…,T},yak∈{0,1}fora∈Ap,k∈{1,…,T}.We denote this formulation by IMFP1.A potential weakness of IMFP1 is that it may suffer from symmetry. If multiple arcs need to be build to increase the maximum s-t flow, then the order in which these arcs are build does not matter, which introduces alternative, symmetrical solutions. Next, we present an alternative MIP formulation which avoids this difficulty. Let f and F denote the initial and the ultimate maximum flow value, respectively, and let r = F − f. We introduce binary variables yakfor a ∈ Apand k = 1, 2, …, r with the interpretationyak={1ifarcaisbuildwhilethemaxflowvalueislessthanf+k,0otherwise.The number of time periods with maximum flow value f is∑a∈Apya1,and for k = 1, …, r − 1, the number of time periods with maximum flow value f + k is∑a∈Ap(ya,k+1−yak). Consequently, the total flow isf∑a∈Apya1+∑k=1r−1(f+k)∑a∈Ap(ya,k+1−yak)+F(T−∑a∈Apyar)=TF+∑a∈Ap∑k=1ryak[(f+k−1)−(f+k)]=TF−∑a∈Ap∑k=1ryak.Hence the incremental maximum flow problem can also be formulated as followsmin∑a∈Ap∑k=1ryaksubjectto∑a∈δout(v)xak−∑a∈δin(v)xak={0forv∉{s,t}f+kforv=s−f−kforv=tforv∈N,k∈{1,…,r},xak⩽uafora∈Ae,k∈{1,…,r},xak⩽uayakfora∈Ap,k∈{1,…,r},yak⩽ya,k+1fora∈Ap,k∈{1,…,r−1},xak⩾0fora∈A,k∈{1,…,r},yak∈{0,1}fora∈Ap,k∈{1,…,r}.We denote this formulation by IMFP2.Observe that the size of IMFP1 strongly depends on the length of the planning horizon, whereas the size of IMFP2 strongly depends on the difference between the initial and ultimate maximum flow values.In this section, we introduce two natural strategies for trying to obtain high quality solutions: (1) getting a flow increment as quickly as possible, and (2) reaching a maximum possible flow as quickly as possible, as well as a hybrid strategy.A natural greedy strategy is to build the arcs such that a flow increment is always reached as quickly as possible. Suppose we have already built the arcs in B⊆Apto reach a maximum flow value f + k. A smallest set of potential arcs to be built, in addition to B, to reach a flow of value at least f + k + 1 can be determined by solving a fixed charge network flow problem: find a flow of value f + k + 1 where arcs in Ae∪B have zero cost, and arcs in Ap∖B incur a cost of 1 if they carry a nonzero flow. More formally, in order to determine the smallest number of potential arcs that have to be built to increase the flow from f + k to at least f + k + 1, we solve the problem MinArcs(B, k + 1):minz=∑a∈Ap∖Byasubjectto∑a∈δout(v)xa−∑a∈δin(v)xa={0forv∉{s,t}f+k+1forv=s−f−k−1forv=tforv∈N,xa⩽uafora∈Ae∪B,xa⩽uayafora∈Ap∖B,xa⩾0fora∈A,ya∈{0,1}fora∈Ap∖B.Next, among all the possibilities that increase the flow by building the smallest possible number of potential arcs, we want to choose one that maximizes the flow increase. Given the optimal value z* for the problem MinArcs(B, k + 1), this can be achieved by solving another MIP, denoted by MaxVal(B, z*):maxξsubjectto∑a∈δout(v)xa−∑a∈δin(v)xa={0forv∉{s,t}ξforv=s−ξforv=tforv∈N,xa⩽uafora∈Ae∪B,xa⩽uayafora∈Ap∖B,∑a∈Ap∖Bya=z*xa⩾0fora∈A,ya∈{0,1}fora∈Ap∖B.The greedy heuristic is described formally in Algorithm 1(assuming the entire set Apis provided as input). In general, this heuristic still requires the solution of MIPs MinArcs(B, k + 1) and MaxVal(B, z*), hence we do not get a polynomial bound on the runtime. But these MIPs are much smaller than IMFP1 and IMFP2, so they can be solved more efficiently, which is demonstrated by the computational results presented in Section 5.However, if the capacities of all potential arcs are equal to 1, then the problems MinArcs(B, k + 1) reduce to minimum cost flow problems, and their solutions are already optimal for MaxVal(B, z*), because the optimal flow increment is 1. Thus for these instances, the quickest increment heuristic runs in polynomial time.Furthermore, if the maximization of the flow increment is omitted, then the heuristic can be implemented to run in polynomial time even for general capacities. For this purpose, suppose we have already built the arcs in B⊂Apand we have a maximum flowxof value f + k for the network (V, Ae∪B). Using the residual network with respect tox, we can apply a labeling procedure which computes for each node v a triple (d(v), δ(v), p(v)), where•d(v) is the minimum number of arcs in Ap∖B on any augmenting s-v-path,δ(v) is the maximum augmentation for any s-v-path using at most d(v) arcs from Ap∖B, andp(v) is the predecessor of v on an s-v-path which contains d(v) arcs from Ap∖B and can be augmented by δ(v) units of flow.This can be done in time O(|A|), for instance using BFS starting from s, and the distance label d(t) equals the minimum size of a set B′⊆Ap∖B with the property that the maximum s-t-flow value in the network (V, Ae∪B∪B′) is strictly larger than f + k. Furthermore, B′ = P∩(Ap∖B) is such a set of size d(t), where P is the augmenting s-t-path corresponding to the result of the labeling procedure. Suppose there is a set B′′⊆Ap∖B with |B′′| < d(t) such that the maximum flow in (V, Ae∪B∪B′′) is strictly larger than f + k. Then the residual network for (V, Ae∪B∪B′′) with respect to the flowxof value FBmust contain an augmenting path P′. Now P′∩(AP∖B)⊆B′′, thus P′ is an augmenting s-t-path which contains less than d(t) arcs from Ap∖B, which contradicts the construction of d(t). Using this labeling procedure, a quickest-increment heuristic can be described as follows.•Initialize the set of built arcs B = ∅ and a zero flowx= 0whilexis not a maximum flow for (V, A) do•Find an augmenting path P using the smallest number of new potential arcs.Add the potential arcs on P to B.Update the flowx.This algorithm runs in time O(|V||A|3). The δ-component in our node labels ensures that we find the augmenting path that (1) requires the smallest number of new arcs to be built, and (2) allows the maximum augmentation among these paths. Nevertheless, it might be beneficial to build another path which allows more augmentations afterward without building additional arcs. This is illustrated in Fig. 1.Since Algorithm 1, which solves subproblems MinArcs(B, k + 1) and MaxVal(B, z*), when implemented using state-of-the-art commercial MIP solver, turned out to be sufficiently efficient for our test instances, we decided not to implement the polynomial variant for our computational study, which is presented in Section 5.A potential drawback of the quickest increment heuristic is that it might build arcs which yield (small) flow increments but that are not used in an ultimate maximum flow. To force the heuristic to build arcs that are used in an ultimate maximum flow, we can first determine a smallest set of potential arcs that admit an ultimate maximum flow by finding an optimal solution (x*, y*) to the problem MinArcs(∅, r), and then restricting the arc choices in Algorithm 1 to the arcs used in the optimal solution (x*, y*), i.e., by fixing ya= 0 for all a ∈ Apwithya*=0. This algorithm is described formally in Algorithm 2. Because the smallest set of potential arcs that admits an ultimate maximum flow is unlikely to be unique, it is possible that the initial choice of arcs may not be the best.Combining the ideas of quickest flow increment and quickest ultimate flow, we can design a general framework. Let 0 = r0 < r1 < r2 < ⋅⋅⋅ < rk= r be a sequence of target values. Put B0 = ∅, and for i ≥ 1 suppose that we have already determined a set Bi − 1⊆Apsuch that the maximum flow value for Ae∪Bi − 1 is f + ri − 1. Following the quickest ultimate flow strategy, we can determine a smallest set of potential arcs Biwith Bi − 1⊆Bi⊆Apsuch that Ae∪Biallows a flow of value f + ri, and then we can use the quickest flow increment strategy to specify the order in which the arcs in Bi∖Bi − 1 are built. This is described in detail in Algorithm 3. Note that this framework implicitly also provides a risk mitigation strategy, because we are not locked in to a set of arcs for the entire planning period, as in Quickest-to-ultimate.As mentioned in the introduction, the incremental network design problem with maximum flows is strongly NP-hard even when restricted to instances where every existing arc has capacity 1 and every potential arc has capacity 3. That leaves open the possibility that when all arcs have capacity 1, i.e., both existing and potential arcs, the problem is polynomially solvable. Unfortunately, we have been unable to settle the complexity status of the unit-capacity case, but we have been able to derive a number of results regarding the performance of Quickest-increment and Quickest-to-ultimate in the unit-capacity case, which are presented in this section.Figs. 2 and 3illustrate that the heuristics can be off by a factor of close to 2 (Quickest-to-ultimate) and 3/2 (Quickest-increment).The dashed arcs represent paths of potential arcs whose lengths are indicated by the arc labels. For the instance in Fig. 2, the time horizon is T = 2k + 2 and the optimal solution (which is found by Quickest-increment) has value 2k + 2, while Quickest-to-ultimate provides a solution of value k · 0 + k · 1 + 2 · 2 = k + 4. For the instance in Fig. 3, the time horizon is T = 3k and the optimal solution (which is found by Quickest-to-ultimate) has value 3k, while Quickest-increment provides a solution of value (k − 1) · 0 + 2k · 1 + 2 = 2k + 2. Combining the two examples we get an instance that fools both heuristics (Fig. 4). For this instance, Quickest-to-ultimate achieves a total flow of 10k + 4, Quickest-increment gets 11k + 3, but a combination of the two strategies yields a total flow of 13k.In this subsection, we show that the instances in Figs. 2 and 3 represent the worst situations for the heuristics Quickest-to-ultimate and Quickest-increment, respectively. Let z*, z1 and z2 denote the optimal objective value, and the values obtained by Quickest-to-ultimate and Quickest-increment, respectively. For i = 0, …, r − 1, let λiand μidenote the number of time periods with a maximum flow value f + i in the solution from Quickest-to-ultimate and Quickest-increment, respectively. In other words, λiand μiare the optimal values of the problems MinArcs(B, i + 1) which are solved for increasing the flow from f + i to f + i + 1. Furthermore, let cjfor 0 ≤ j ≤ r be the minimum number of potential arcs that have to be built in order to reach a flow of f + j:(1)cj=min{∑a∈Apxa:∑a∈δout(v)xa−∑a∈δinv)xa={0forv∈V∖{s,t},f+jforv=s,−f−jforv=t,0⩽xa⩽1foralla∈A{0forv∈V∖{s,t},f+jforv=s,−f−jforv=t,}(2)=max{∑a∈A(f+j)(πs−πt)+∑a∈Aya:πv−πw+ya⩽{1fora=(v,w)∈Ap,0fora=(v,w)∈Ae,ya⩽0foralla∈A{1fora=(v,w)∈Ap,0fora=(v,w)∈Ae,}.Observe that if the associated sets of arcs would be nested, then they would give rise to an optimal solution. However, since this is unlikely to be the case in general, the values cjcan only be used to derive an upper bound.Lemma 1z*⩽TF−∑j=1rcj⩽TF−12r(r−1)−cr.For i = 0, …, r − 1, letλi*be the number of time periods with flow f + i in an optimal solution. Since any feasible solution must have at least ci + 1 periods with flow value at most f + i, we haveλ0*+⋯+λi*⩾ci+1.Summing over i, we obtain∑i=0r−1λi*(r−i)⩾∑j=1rcj,hencez*=∑i=0r−1λi*(f+i)+(T−∑i=0r−1λi*)(f+r)=TF−∑i=0r−1λi*[(f+r)−(f+i)]=TF−∑i=0r−1λi*(r−i)⩽TF−∑j=1rcj.This proves the first inequality and the second one follows with cj≥ j for 1 ≤ j ≤ r.□The values z1 and z2 can be expressed in terms of the sequences (λi) and (μi), respectively.Lemma 2z1=TF−∑i=0r−1λi(r−i)andz2=TF−∑i=0r−1μi(r−i).We havez1=∑i=0r−1λi(f+i)+(T−∑i=0r−1λi)(f+r)=TF−∑i=0r−1λi(r−i),and similarly for z2.□The sequences (λi)i = 0, …, r − 1 and (μi)i = 0, …, r − 1 are non-decreasing.Lemma 3We haveλ0 ≤ λ1 ≤ ⋅⋅⋅ ≤ λr − 1and μ0 ≤ μ1 ≤ ⋅⋅⋅ ≤ μr − 1.LetA¯=Ae∪A¯pbe the set of arcs that are used by Quickest-to-ultimate. Set B0 = ∅, and for i = 1, …, r − 1 let Bibe the set of arcs which are built by Quickest-to-ultimate in the first λ0 + ⋅⋅⋅ + λi − 1 time periods. Thenλi=min{{0forv∈V∖{s,t},f+i+1forv=s,−f−i−1forv=t,∑a∈A¯p∖Bixa:∑a∈δout(v)xa−∑a∈δin(v)xa={0forv∈V∖{s,t},f+i+1forv=s,−f−i−1forv=t,0⩽xa⩽1foralla∈A¯{0forv∈V∖{s,t},f+i+1forv=s,−f−i−1forv=t,}=max{{1fora=(v,w)∈A¯p∖Bi,0fora=(v,w)∈Ae∪Bi,(f+i+1)(πs−πt)+∑a∈A¯ya:πv−πw+ya⩽{1fora=(v,w)∈A¯p∖Bi,0fora=(v,w)∈Ae∪Bi,ya⩽0foralla∈A¯∑a∈A¯}.Fix some i < r − 1, and let (π*, y*) be an optimal solution for the dual characterization of λi. Since Ae∪Bican carry an s-t-flow of value f + i, the optimal value for the optimization problem which characterizes λibecomes 0 when the flow value f + i + 1 is replaced by f + i. In the dual problem this is corresponds to the coefficient of (πs− πt) in the objective function, and since (π*, y*) is also feasible for this modified dual problem, we have(f+i)(πs*−πt*)+∑a∈A¯ya⩽0,and thereforeλi=(f+i+1)(πs*−πt*)+∑a∈Aya*⩽πs*−πt*.On the other hand, we obtain a feasible solution (π′, y′) for the dual characterization of λi + 1 by setting π′ = π* andya′={ya*−1fora∈Bi+1∖Bi,ya*fora∈A¯∖(Bi+1∖Bi),and together with |Bi + 1∖Bi| = λithis impliesλi+1⩾(f+i+2)(πs*−πt*)+∑a∈A¯ya*−λi=πs*−πt*.The inequality μi≤ μi + 1 is proved in the same way (with A instead ofA¯).□Quickest-to-ultimate is a 2-approximation algorithm for the incremental maximum flow problem with unit capacities, i.e., z* ≤ 2z1.Using Lemma 3, we have∑i=0r−1λi(r−1−2i)=∑i=0⌊(r−1)/2⌋(λi−λr−1−i)(r−1−2i)⩽0.Adding the inequality (λ0 + ⋅⋅⋅ + λr − 1)r ≤ TF, it follows thatTF−∑i=0r−1λi(2(r−i)−1)⩾0.By construction, cr= λ0 + ⋅⋅⋅ + λr − 1, and with Lemma 1 we derivez*⩽TF−12r(r−1)−∑i=0r−1λi⩽TF−12r(r−1)−∑i=0r−1λi+(TF−∑i=0r−1λi(2(r−i)−1))=2(TF−∑i=0r−1λi(r−i))−12r(r−1)=2z1−12r(r−1).□In order to prove that for Quickest-increment the case in Fig. 3 illustrates an upper bound for the approximation ratio, we need some technical preparations. We start by bounding the numbers μiby the numbers cj.Lemma 4We haveμi⩽cj/(j−i)for all (i, j) with 0 ≤ i < j ≤ r.Fix i and j with 0 ≤ i < j ≤ r, and let X be the feasible region of the maximization problem which characterizes μi, i.e.,X={(y,π)∈R|A|×R|V|:πv−πw+ya⩽{0fora=(v,w)∈Ae∪Bi,1fora=(v,w)∈Ap∖Bi,ya⩽0foralla∈A},where Biis the set of arcs built by Quickest-incrementin the first μ0 + ⋅⋅⋅ + μi − 1 time periods. Since the maximum flow value on Ae∪Biequals f + i, we have that X⊆Y whereY={(y,π)∈R|A|×R|V|:πv−πw+ya⩽{0fora=(v,w)∈Ae,1fora=(v,w)∈Ap,(f+i)(πs−πt)+∑a∈Aya⩽0,ya⩽0foralla∈A},Consequently,μi⩽max{(f+i+1)(πs−πt)+∑a∈Aya:(y,π)∈Y},and by taking the dual we obtain(3)μi⩽min{∑a∈Apxa:∑a∈δout(v)xa−∑a∈δinv)xa={0forv∈V∖{s,t},f+i+1−(f+i)zforv=s,−f−i−1+(f+i)zforv=t,xa+z⩽1foralla∈A,xa⩾0foralla∈A,z⩾0}.Letx∈R|A|be an optimal solution for the problem (1) to determine cj, i.e., an s-t-flow of value f + j. Solving the system(f+j)γ=f+i+1−(f+i)z,γ+z=1for γ and z yields γ = 1/(j − i) and z = (j − i − 1)/(j − i), and this implies that a feasible solution (x′, z) for problem (3) can be obtained by settingxa′=xa/(j−i)for all a ∈ A and z = (j − i − 1)/(j − i). Hence the optimal value of problem (3) is at most cj/(j − i) and this concludes the proof.□From Lemmas 3 and 4 it follows that(μ,c,T)∈Rr×Rr+1×Rsatisfies the following conditions:(4)μi−μi+1⩽0for0⩽i⩽r−2,(5)(j−i)μi−cj⩽0for0⩽i<j⩽r,(6)∑i=0r−1μi−T⩽0,(7)c0=0,(8)μi,cj⩾0for0⩽i⩽r−1,1⩽j⩽r.LetX(r)⊆Rr×Rr+1×Rdenote the set of all (μ, c, T) satisfying (4)–(8). Using Lemmas 1 and 2, a number γ > 1 is an upper bound for the approximation ratio of Quickest-increment, providedTF−∑j=1rcj⩽γ[TF−∑i=0r−1μi(r−i)]is a valid inequality for X(r), or equivalentlyF(1−γ)T−∑j=1rcj+γ∑i=0r−1μi(r−i)⩽0for all (μ, c, T) ∈ X(r). Since F ≥ r and γ > 1, this inequality is strengthened when F is replaced by r on the left hand side. By duality, the stronger inequality is valid for X(r), provided the following system has a solution:(9)∑i=0j−1yij⩽1for1⩽j⩽r,(10)z+∑j=i+1r(j−i)yij+xi−xi−1⩾γ(r−i)for0⩽i⩽r−1,(11)z⩽r(γ−1),(12)x−1=xr−1=0,(13)z,xi⩾0for0⩽i⩽r−2,(14)yij⩾0for0⩽i<j⩽r.LetY(r,γ)⊆Rr+1×Rr(r+1)/2×Rbe the set of all (x, y, z) satisfying (9)–(14). The above argument implies the following theorem which provides a sufficient condition for γ to be an approximation factor for Quickest-increment on all instances with F − f = r.Theorem 2If Y(r, γ) ≠ ∅, then Quickest-increment is a γ-approximation algorithm for all instances of the incremental maximum flow problem with unit capacities and F − f = r.Consequently, in order to establish that Quickest-increment is a 3/2-approximation algorithm, it is sufficient to prove the Y(r, 3/2) ≠ ∅ for all r ≥ 2. To do this, we need another lemma.Lemma 5Let r ≥ 2 and s = ⌊(r + 2)/3⌋. Then the following system has a solution with non-negative yijfor 0 ≤ i ≤ s, i + 1 ≤ j ≤ r:∑j=i+1r(j−i)yij⩾r−32i0⩽i⩽s,∑i=0min{j−1,s}yij⩽11⩽j⩽r.We proceed by induction on r. For r = 2, s = 1, a solution is given by y01 = 1, y02 = y12 = 1/2. So we assume r > 2, and we distinguish two cases.Case 1.r≡0or2(mod3). By induction, there are nonnegative numbers yijfor 0 ≤ i ≤ s and i + 1 ≤ j ≤ r − 1 satisfying∑j=i+1r−1(j−i)yij⩾r−1−32i0⩽i⩽s,∑i=0min{j−1,s}yij⩽11⩽j⩽r−1.We extend this by yir= 1/(r − i) for 0 ≤ i ≤ s. Then∑j=i+1r(j−i)yij⩾r−32ifor 0 ≤ i ≤ s and∑i=0syir=∑i=0s1r−i⩽s+1r−s⩽1.Case 2.r≡1(mod3)and s = (r + 2)/3. For r = 4, a solution is given byy01=1,y02=1,y03=1/3,y04=0,y12=0,y13=2/3,y14=7/18,y23=0,y24=1/2.For r > 4, by induction, there are nonnegative numbers yijfor 0 ≤ i ≤ s − 1 and i + 1 ≤ j ≤ r − 3 satisfying∑j=i+1r−3(j−i)yij⩾r−3−32i0⩽i⩽s−1,∑i=0min{j−1,s−1}yij⩽11⩽j⩽r−3.Let i0 = ⌊(r − 5)/4⌋. We extend our solution byyij={3(r−2)−iforj=r−2,0forj∈{r−1,r}for0⩽i⩽i0,yij={3(r−1)−iforj=r−1,0forj∈{r−2,r}fori0+1⩽i⩽s−1,ysj={3(r−2)4(r−1)forj=r,0forj<r.Then∑j=i+1r(j−i)yij⩾r−32ifor 0 ≤ i ≤ s,∑i=0syi,r−2=∑i=0i03(r−2)−i⩽3(i0+1)r−2−i0⩽3(r−1)/4r−2−(r−5)/4=1,∑i=0syi,r−1=∑i=i0+1s−13(r−1)−i⩽3(s−1−i0)r−1−(s−1)⩽3(r+23−1−r−54)r−r+23=14(r+11)13(2r−2)=3r+338r−8⩽1,where we used r ≥ 5 for the last inequality, and∑i=0syir=ysr⩽1.□Using Lemma 5, we can exhibit a point in Y(r, 3/2).Lemma 6Y(r, 3/2) ≠ ∅ for all r ≥ 2.Let s = ⌊(r + 2)/3⌋ and let yijfor 0 ≤ i ≤ s and i + 1 ≤ j ≤ r be a point as described in Lemma 5. For i > s and i + 1 ≤ j ≤ r, let yij= 0. In addition, let xi= 0 for 0 ≤ i ≤ s, and z = r/2. Finally, letxi=(i−s)(r−32s−34(i−s+1))fors+1⩽i⩽r−2.We claim that (x, y, z) ∈ Y(r, 3/2). Constraints (9) follow immediately Lemma 5. The same is true for constraints (10) for 0 ≤ i ≤ s. For s < i ≤ r − 2, constraint (10) is satisfied becausexi−xi−1=(i−s)(r−32s−34(i−s+1))−(i−1−s)×(r−32s−34(i−s))=r−32i.Finally, constraint (10) for i = r − 1 follows fromxr−2=(r−2−s)(r−32s−34(r−1−s))={r/2−3/2ifr≡0(mod3),r/6−2/3ifr≡1(mod3),r/3−7/6ifr≡2(mod3),which also implies xi≥ 0 for all i.□The bound of 3/2 for the approximation ratio of Quickest-increment is a consequence of Theorem 2 and Lemma 6.Theorem 3Quickest-increment is a 3/2-approximation algorithm for the incremental maximum flow problem with unit capacities.Let us examine the example in Fig. 3 more closely. It has initial flow value f = 0 and ultimate flow value F = 2 and the essence of the example is that the arcs that are built to reach a flow value 1 cannot be used for the (ultimate) flow value 2. Fig. 5shows an attempt to generalize the example to one with initial flow value f = 0 and ultimate flow value F = 3. The instance has a time horizon T = 7k + 3. Quickest-increment starts with building the middle path with k − 1 potential arcs. Then the cheapest way to achieve a flow of value 2 is to build the two paths containing k potential arcs each. Finally, all the remaining arcs have to be built in order to achieve a flow of value 3. This gives a total flow of(k−1)·0+2k·1+(4k+3)·2+3=10k+9.On the other hand, the optimum for large k is to build the ultimate flow immediately which yields(k+1)·0+(k+1)·1+(2k+1)·2+3k·3=14k+3.What works in favor of the heuristic, in terms of performance, is that in order for the heuristic not to build the upper path to achieve a flow of value 2, it has to be long enough, i.e. longer than the sum of the lengths of the diagonal paths that the heuristic chooses.If we defineφ(r)=inf{γ:Quickest−incrementisaγ-approximationforinstanceswithF−f=r},then Theorem 3 shows that φ(r) ≤ 3/2. It is possible to show that φ(r) ≤ 4/3 for r ≥ 70, and we conjecture that it is possible to show that limr → ∞φ(r) = 1.In our quest for polynomially solvable cases of incremental network design with maximum flows, we next consider, in addition to unit capacities on all arcs, imposing a restriction on the structure of the network. More specifically, a node set N = V∪W∪{s, t} and an arc set A consisting of existing arcs (s, v) for all v ∈ V, existing arcs (w, t) for all w ∈ W, and some arcs (v, w) with v ∈ V and w ∈ W, which can be either existing or potential. Thus, s-t flows correspond to matchings in the bipartite graph (V∪W, {{v, w}: (v, w) ∈ A}), and therefore we call this special case the incremental maximum matching problem.The example in Fig. 6shows that Quickest-to-ultimate may fail to find an optimal solution. The unique maximum cardinality matching is {(1, 2), (3, 4), …, (15, 16)} and building arcs (1, 2), (3, 4), (5, 6), and (7, 8), followed by arcs (9, 10), (11, 12), (13, 14), and (15, 16), followed by (9, 4) results in a total cumulative flow for Quickest-to-ultimate of 4 · 6 + 4 · 7 + 2 · 8 = 68, whereas building arcs (1, 2) and (9, 4), followed by arcs (3, 4), (5, 6), …, (15, 16) results in a total cumulative flow of 2 · 6 + 7 · 7 + 8 = 69.Similarly, the example in Fig. 7shows that Quickest-increment may fail to find an optimal solution. The initial maximum matching has size 5, and the unique cheapest way to obtain a matching of size 6 is to build arcs (5, 8) and (7, 10). After that, all the remaining potential arcs need to be build to reach a matching of size 7, and the total cumulative flow for Quickest-increment is 2 · 5 + 6 · 6 + 7 = 53. On the other hand, building arcs (1, 2), …, (13, 14) followed by arcs (5, 8) and (7, 10) results in a total cumulative flow of 3 · 5 + 3 · 6 + 3 · 7 = 54.Thus, even restricting the structure of the network to bipartite graphs does not trivially give a polynomially solvable case of incremental network design with maximum flows. We have been able to improve the performance guarantee of Quickest-to-ultimate to 4/3 for instances of the incremental maximum matching problem. The proof is given in Appendix A.We have conducted a computational study to gain insight into the characteristics that make instances of the incremental maximum flow problem hard to solve, to compare the performance of the two MIP formulations, and to assess the performance of the three heuristics.The following computational tools were used to develop and analyze the formulations and algorithms: Python 2.7.5, Matplotlib 1.3.1, NetworkX 1.8.1, and Gurobi 5.5. All computational experiments were conducted on a 64-bit Win7 with Intel Xeon CPU (E5-1620) with 8 cores and 32GB of RAM using a single thread.For the computational experiments in which we compare the performance of the IP formulations and the heuristics, we use two classes of instances: one using general graphs and one using layered graphs.General graphs are parameterized by the number of nodes n, the expected density d = 2|A|/n(n − 1) ∈ {0.1, 0.3, 0.7}, the expected fraction of potential arcs p = |Ap|/|A| ∈ {0.3, 0.7}, and the maximum arc capacity umax  ∈ {1, 3, 10}. For each combination of parameters, 10 random instances are generated. More specifically, for a given number of nodes n, an arc between two nodes exists with probability d, and if an arc between two nodes exists, the arc is a potential arc with probability p (and thus an existing arc with probability 1 − p).Layered graphs consist of a source node, a sink node, and ℓ layers in between (ℓ ≥ 2). The source is connected to every node in the first layer and every node in the last layer is connected to the sink. The nodes in layer i may be connected to a node in layer i + 1. Layered graphs are parameterized by the number of layers ℓ, the number of nodes in each layer n, the expected density d = |A|/(ℓ − 1)n2 ∈ {0.1, 0.3, 0.7}, the expected fraction of potential arcs p = |Ap|/|A| ∈ {0.3, 0.7}, and the maximum arc capacity umax  ∈ {1, 3, 10}. For each combination of parameters, 10 random instances are generated. The generation proceeds similar to the generation of general instances. Layered instances are considered because they ensure a minimum distance between the source and the sink.We start by determining the characteristics that make an instance difficult to solve and, at the same time, comparing the performance of the two MIP formulations presented in Section 2.Tables 1and 2present average performance statistics for various combinations of the instance parameters (with n = 35 for general graphs and ℓ = 5 and n = 10 for layered graphs). More specifically, we report the arc density (d), the fraction of potential arcs (p), the maximum arc capacity (umax ), the difference between the value of an ultimate and an initial maximum flow (F − f), the number of instances not solved to optimality within the time limit (#), the average initial gap (initial gap), computed as (zLP − zIP)/zIP, where zLP is the value of the LP relaxation and zIP is the value of the best solution found, the average final gap over the instances not solved to optimality (final gap), where in the gap computation zLP is replaced by the best bound at termination, and the average solution time (time) and average number of nodes in the search tree (#nodes) over the instances solved to optimality.First and foremost, we observe that IMFP2 performs significantly better than IMFP1; not only are more instances solved to optimality within the time limit of 1 hour, but the instances are solved much faster. (Interestingly, the initial gap for IMFP2 tends to be larger than the initial gap for IMFP1 when the maximum arc capacity is greater than 1.)As expected, the instances get more difficult when the density, and thus the number of arcs, increases, when the fraction of potential arcs, and thus the planning horizon, increases, and when the maximum arc capacity increases.IMFP1 is impacted primarily by the length of the planning horizon, i.e., the number of possible build sequences, whereas IMFP2 is impacted primarily by the difference between the value of the ultimate flow F and the value of the initial flow f, i.e., the flow increase that has to be accommodated.The density d relates to the number of arcs in the graph and thus the number of paths from source to sink and thus the maximum flow. Therefore, if the density increases, then the length of the planning horizon and the difference between F and f increase, which impacts the performance of both formulations. The fraction of potential arcs p relates to the planning horizon and thus the number of possible sequences in which arcs can be build, but also impacts f and thus the difference between F and f. Therefore, if this fraction increases, then the length of the planning horizon and the difference between F and f increase, which should impact the performance of both formulations, but most likely the performance of IMFP1. The maximum arc capacity umax  impacts the difference between F and f. Therefore, if the arc capacity increases, then the difference between F and f increases, which impacts the performance of IMFP2, but also IMFP1.To further investigate the behavior of the two formulations, Tables 3and 4present detailed performance statistics for 10 instances in the most difficult class, i.e., d = 0.3, p = 0.7, and umax  = 10, when the time limit is increased to 4 hours. The instances are presented in nondecreasing order of the difference between the value of the ultimate flow and the value of the initial flow, i.e., F − f.We see that the difference between the value of the ultimate flow and the value of the initial flow, i.e., F − f, is a good predictor of the difficulty of an instance for both formulations. The larger the value of F − f, the more likely it is that the instance cannot be solved and if an instance cannot be solved, the more likely it is that the final gap is large. These “trends” are most clearly seen in the results for the layered instances. For the layered instances, it is also interesting to note that there is one instance that can be solved by IMFP1, but not by IMFP2.Additional analysis and experimentation revealed that in addition to the difference F − f, the number of flow increases from f to F also seems to impact solution time, with more flow increases usually resulting in longer solution times. The number of flow increases from f to F depends on the arc capacities in an instance, and on how these arc capacities interact on the different paths from source to sink.For the difficult instances, we compare the performance of Quickest-increment, Quickest-to-ultimate, and Quickest-to-target with p = 2, r0 = f, r1 = ⌊(F − f)/2⌋, and r2 = F. The results are shown in Tables 5and 6, where we report the difference between the ultimate and initial flow values (F − f), for each of the heuristics the cumulative flow (flow), the relative difference to the best known cumulative flow (Δ = (zbest − zheur)/zbest), and the solution time (time), and for IMFP2 the value of the first feasible solution (first), the relative difference to the best solution (Δ = (zbest − zfirst)/zbest), the time to reach the first feasible solution, the value of the best solution (best), and the time to reach the best feasible solution (time). A time limit of 3600 seconds was imposed for the solution of IMFP2.As expected, the three heuristics are able to produce high-quality solutions quickly (with Quickest-increment possibly being slightly slower than the other two). For these instances, the hybrid heuristic Quickest-to-target seems to perform best (on average within 0.03 percent from the best known solution for instances on general graphs and within 0.47 percent from the best known solution for instances on layered graphs). However, IMFP2 also produces high-quality solutions when given an hour of computing time, often noticeably better than the heuristic solutions.As the instances used for the above experiments are relatively small, we performed a final experiment in which we use general and layered graphs with 300 nodes to investigate whether the performance of the heuristics (both in terms of quality and time) scales well. Instances of this size are beyond what can be solved to optimality in a reasonable amount of time with IMFP2. Therefore, instead, we solved the instances twice with Gurobi parameter SolutionLimit set to one the first time and to two the second time. When SolutionLimit is set to one, Gurobi uses its embedded heuristics to generate a feasible solution and does not even solve the linear programming relaxation. When SolutionLimit is set to two, Gurobi solves at least one linear programming relaxation. The results can be found in Tables 7and 8.A few interesting observations can be made. For general instances of this size, Quickest-increment performs best (it produces the best solution for all but one instance), but it is noticeably slower than Quickest-to-ultimate and Quickest-to-target. The first solution found by IMFP2 is the worst for all instances, but the second solution found by IMFP2 matches the best in all but one instance. However, it takes substantially longer to find that solution. For layered instances of this size, the situation is not as clear cut, both Quickest-increment and Quickest-to-ultimate perform well and outperform IMFP2 in all but one instance. Overall, Quickest-to-target produces high-quality solution very efficiently for all instances and should be the method of choice when time is important.We have studied the incremental network design with maximum flows. We have investigated the performance of mixed integer programming formulations and we have analyzed the performance of natural heuristics, both theoretically and empirically.On the theoretic side, the complexity status of the incremental maximum flow problem for instances with unit arc capacities remains open, even when the network is restricted to bipartite graphs. On the algorithmic side, we have identified classes of instances where integer programming solvers struggle and where the natural heuristics, although fast, do not necessarily provide high-quality solutions. Thus, there is an opportunity to explore more sophisticated heuristics, e.g., metaheuristics.Finally, there are various other incremental network design problems that are worth studying, e.g., the incremental multicommodity flow problem.

@&#CONCLUSIONS@&#
